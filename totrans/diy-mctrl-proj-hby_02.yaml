- en: '*Chapter 2*: Software Setup and C Programming for Microcontroller Boards'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will review the basic configuration of the IDEs used for
    programming the Blue Pill and Curiosity Nano microcontroller boards, as well as
    learn the basics of the C programming language necessary for coding applications
    for the Blue Pill and the Curiosity Nano. This is by no means a comprehensive
    C tutorial. It contains important information to understand and complete the exercises
    explained in all the chapters of this book. In this chapter, we''re going to cover
    the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the C programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Curiosity Nano microcontroller board programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Blue Pill microcontroller board programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example – Programming and using the microcontroller board's internal LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have received a solid introduction to the
    C programming language, including a set of programming instructions useful for
    developing many small and mid-sized microcontroller projects with the Blue Pill
    and Curiosity Nano microcontroller boards. This chapter also covers the use of
    the internal LED, which both the Blue Pill and the Curiosity Nano have. This can
    be very useful for quickly showing digital results (for example, confirming actions
    in your project).
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The software that we will use in this chapter is the Arduino and MPLAB X IDEs
    for programming the Blue Pill and the Curiosity Nano, respectively. Their installation
    process was described in [*Chapter 1*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014)*,*
    *Introduction to Microcontrollers and Microcontroller Boards*. We will also use
    the same code examples that were used in the aforementioned chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will also use the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: A solderless breadboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Blue Pill and Curiosity Nano microcontroller boards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A micro USB cable for connecting your microcontroller boards to a computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ST-LINK/V2 electronic interface needed to upload the compiled code to the
    Blue Pill. Remember that the ST-Link/V2 requires four female-to-female DuPont
    wires.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are fundamental hardware components that will suffice for the examples
    described in this chapter, and will also prove useful in other more complex projects
    explained in other chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code used in this chapter can be found at the book''s GitHub repository
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/DIY-Microcontroller-Projects-for-Hobbyists/tree/master/Chapter02](https://github.com/PacktPublishing/DIY-Microcontroller-Projects-for-Hobbyists/tree/master/Chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for this chapter can be found here: [https://bit.ly/3xwFvPA](https://bit.ly/3xwFvPA)'
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains a concise introduction to the C programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the C programming language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **C programming language** was initially created in the early seventies
    for developing the UNIX operating system, but it has been ported to practically
    all operating systems ever since. It is a mid-level programming language because
    it shares properties from high-level languages such as Python and low-level languages,
    for example, the assembly language. The C language is generally easier to program
    than low-level languages because it is very *human-readable* and there are many
    libraries available that facilitate the development of software applications,
    among other reasons. It is also very efficient for programming embedded systems.
    C is one of the most popular coding languages, and virtually all microcontrollers
    can be programmed with C compilers – Blue Pill and Curiosity Nano are no exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The C language is not completely portable among different families and manufacturers
    of microcontrollers. For example, the I/O ports and the interrupts are not programmed
    the same in both Blue Pill and Curiosity Nano. That is why two types of C compilers
    and different libraries are needed for programming both microcontroller boards.
    In fact, the Arduino IDE used for programming the Blue Pill uses a variant of
    C called **C++**. C++ is a powerful extension of the C programming language that
    incorporates features such as object-oriented and low-memory level programming.
  prefs: []
  type: TYPE_NORMAL
- en: The following section explains the basics of the C language structure. This
    section includes an explanation of the `#include` directive, writing comments,
    understanding variables, using constants, a keywords list, declaring functions,
    evaluating expressions, and writing loops in C.
  prefs: []
  type: TYPE_NORMAL
- en: The basic structure of the C language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with other programming languages, C makes it possible to declare program
    elements such as constants, types, functions, and variables in separate files
    called `.h`. This can help to organize C instructions and reduce clutter in your
    main C code. A library is a header file containing program elements (such as functions)
    that can be shared with other C programmers or constantly used in different C
    programs. C language compilers contain important libraries that we will use in
    this book. The header files can be included (that is, linked and compiled) along
    your main program using the `#include` directive; hence, the programming elements
    declared in the header file will be called and used in your C program.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many useful standard and non-standard libraries. We will review and
    use both. The `#include` directive is a special instruction for the C compiler
    and not a regular C instruction. It should be written at the beginning of the
    program and without a semicolon at the end. Only the C statements have a semicolon
    at the end. There are three ways to write and apply the `#include` directive.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#include <file_name.h>`: This type of directive uses the less than and greater
    than symbols, meaning that the header file (`.h`) is placed in the compiler path.
    You don''t need to write the complete path to the header file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include "file_name.h"`: This type of directive uses double quotes. The header
    file is stored in the project''s directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include "sub_directory_name/file_name.h"`: This directive type tells the
    compiler that the header file is placed in a sub-directory. Please note that the
    slash symbol is applied depending on the operating system that you are using.
    For example, Windows computers use a backslash (*\*) symbol as a directory separator.
    Linux and Mac computers use the forward-slash (*/*) symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next sub-section shows how to define and use header files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of the #include directive'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following program example shows how to include a header file that is placed
    in the project''s directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `x`, `y`, and `z` variables were declared in
    the `main_file.h` header file, so they are not declared in the main program. The
    header file (`file.h`) contains the following code declaring the three variables
    used in the main code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We could declare the variables in the main program and not declare the variables
    in a header file (`.h`). It is up to you whether you want to write program elements
    in header files. We will learn more about variables later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The C language is case sensitive, so be careful when writing C code. Most C
    language instructions are written in non-capitalized letters. Be careful when
    you declare a variable, too. For example, the variables *x* and *X* are different
    in C.
  prefs: []
  type: TYPE_NORMAL
- en: There are standard libraries that come with the C language and many programmers
    make good use of them. The `stdio.h` library (stored as a header file) is widely
    used in C programming. It defines several macros, variable types, and also specialized
    functions for performing data input and output; for example, taking input letters
    from a keyboard or writing text to the console. The console is a text-based area
    provided by the IDE where reading data from a keyboard or writing text or special
    characters happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a short C program example using the `<stdio.h>` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: C program files are stored with the `.c` extension (such as `mainprogram.c`).
    The C++ program files are generally stored with the `.cpp` extension (for example,
    `mainprogram.cpp`).
  prefs: []
  type: TYPE_NORMAL
- en: The `printf()`, which displays characters (for example, a text message) on the
    IDE's console. As you can see from the preceding program example, we wrote some
    comments explaining each line of code. The next section shows the different ways
    of writing comments in the C language.
  prefs: []
  type: TYPE_NORMAL
- en: Using comments in C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Comments** are either blocks or lines of text that don''t affect the functioning
    of C programs. Writing comments in C programming is useful because they can be
    used to explain and clarify the meaning or the functioning of instructions, functions,
    variables, and so on. All the comments that we write in the program are ignored
    by the compiler. There are a couple of ways of writing comments in C:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using double slashes (`//`): This makes a single-line comment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using slashes and asterisks (`/*  */`): This makes a comment with a block of
    text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This code example demonstrates how to use both types of comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is a good programming practice to write the code's purpose, version number
    and date, and the author's name(s) as comments at the beginning of your C program.
  prefs: []
  type: TYPE_NORMAL
- en: The next section describes how to declare and use variables in C programming.
    Variables are very useful, and you will use them in most of the chapters of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding variables in C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **variable** is a name (also called an identifier) assigned via programming
    to a microcontroller memory storage area that holds data temporarily. There are
    specific types of variables in C that hold different types of data. The variable
    types determine the layout and size of the variable's assigned microcontroller
    memory (generally, its internal random-access memory or RAM).
  prefs: []
  type: TYPE_NORMAL
- en: 'We must declare a variable in the C language first to use it in your code.
    The variable declaration has two parts – a data type and an identifier, using
    this syntax: `<data_type> <identifier>`. The following explains both:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **data type** (or just type) defines the type of data to be stored in the
    variable (for example, an integer number). There are many data types and their
    modifiers. The following table describes the four main types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Table 2.1 – The main four data types used in the C language](img/Table_2.1_B16413.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – The main four data types used in the C language
  prefs: []
  type: TYPE_NORMAL
- en: Each type from *Table 2.1* has the modifiers `unsigned`, `signed`, `short`,
    and `long`, among others. For example, we can declare a variable that holds unsigned
    integers as `unsigned int x;`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is another type named `void`. This type has no value and is generally
    used to define a function type that returns nothing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An identifier is a unique name identifying the variable. Identifiers can be
    written with the letters a..z or A..Z, the numbers 0..9, and the underscore character:
    _. The identifier must not have spaces, and the first character must not be a
    number. Remember that identifiers are case-sensitive. In addition, an identifier
    should have fewer than 32 characters according to the ANSI C standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let''s declare a variable named x that can hold a floating-point
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float x;`'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding line of code example, the C compiler will assign variable *x*
    a particular memory allocation holding only floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use that variable in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x=1.10;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we store the floating-point value of 1.10 in the variable named
    *x*. The following example demonstrates how to use a variable in a C program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can initialize a variable with a value when it is declared, as shown in
    the preceding example for the `fahrenheit_degrees` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also store strings in a variable using double quotes at the beginning
    and end of the string. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`char  name = "Michael";`'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example shows how a string is stored in a char variable type,
    which is an array of characters.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring local and global variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two types of variables in C depending on where they are declared.
    They can have different values and purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global variables**: These are declared outside all the functions from your
    code. These variables can be used in any function and through the whole program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local variables**: Local variables are declared inside a function. They only
    work inside the function that were declared, so their value cannot be used outside
    that function. Have a look at this example containing both global and local variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the global variables *y*, *m*, *x*, and *b* work in
    all programs, including inside the `straight_line_equation()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Constants** (also called constant variables) can be used to define a variable
    that has a value that does not change throughout the entire program. Constants
    in C are useful for defining mathematical constants. This is the syntax for declaring
    a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const <data_type> <identifier>=<value>;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the data type can be either `int`, `float`, `char`, or `double`, or their
    modifiers, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can also declare variables using the `#define` directive. It is written
    at the beginning of a program, right after the `#include` directive, without a
    semicolon at the end of the line, using this syntax: `#define` `<identifier> <value>`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to declare the constant''s data type. The compiler will determine
    that dynamically. The following examples show how to declare constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The next section deals with keywords from the C language that are widely used
    in C programs.
  prefs: []
  type: TYPE_NORMAL
- en: Applying keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: "The ANSI C standard defines a number of **keywords** that have a specific purpose\
    \ in \LC programming. These keywords cannot be used to name variables or constants.\
    \ These are the keywords (statements) that you can use in your C code:"
  prefs: []
  type: TYPE_NORMAL
- en: '`auto, break, case, char, const, continue, default, do, double, else,  enum,
    extern, float, for, goto, if, int, long, register, return, short, signed sizeof,
    static, struct, switch, typedef, union, unsigned, void, volatile, while.`'
  prefs: []
  type: TYPE_NORMAL
- en: The compilers used to compile programs for the Blue Pill and Curiosity Nano
    boards have additional keywords. We will list them in this chapter. The following
    section explains what functions in C are.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring functions in C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `main()`. This function is written in C programs, and other functions are
    called from it. You can logically divide your code up into functions to make it
    more readable and to group instructions that are related to the same task, giving
    the instructions some structure. Functions in C are defined more or less like
    algebraic functions where you have a function name, a function definition, and
    a function parameter(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'The general form for defining a function in C is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `return` statement allows a value from a function to be returned, and this
    returned value is used in other parts of the program. The return statement is
    optional since you can code a function that does not return a value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is a good programming practice to indent the instructions contained in a
    function block. This gives the function more visual structure and readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function example shows how to use parameters and how data is
    returned from a function, where `number1` and `number2` are the function parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the function returns the results of the comparison
    between the two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the function's data type has the same type as the variable used
    in the `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for some reason, you don''t need to return a value from a function, you
    can use the `void` statement instead of defining the function''s data type, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are not using the `return 0` statement in the function
    because it's not returning any value. We can then `error_message();`.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we declare a function, we need to **call** it, that is, run it in another
    part of your code. This transfers the program control to the called function and
    it will run the instruction(s) contained in it. After executing all the instructions
    from the function, the program control resumes, running instructions from the
    main program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call a function, you will need to write the function name and the required
    values for the parameters. If your function returns a value, you can store it
    in a variable. For example, let''s call the `max()` function that we explained
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the result of the number comparison made by the `maxnumber()`
    function will be stored in the `result2` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating expressions (decision statements)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C language provides a way to declare one or more **logic conditions** that
    can be evaluated (tested) by the program, as well as some statements that need
    to be executed according to the result of that evaluation, that is, if the condition
    is either true or false.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C programming language assumes that the true value is any non-null or non-zero
    value. It is false if the value is zero or null. C has the following decision-making
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` (expression_to_evaluate) {statements}: This has a Boolean expression in
    the decision that is followed by one or more statements to be run if the decision
    is true, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`if` (decision) {statements} `else` {statements}: The `else` component can
    be used after an `if` statement and can be useful when running one or more statements
    if the decision is false, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding example, the x variable is analyzed, and if x is greater than
    10, it will print out this message on the IDE''s console: `yes, x is greater than
    10`, otherwise it will print out `no, x is not greater than 10`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Be careful when you evaluate two variables with the `if` statement. Use double
    equal signs for that (==). If you use only one equal sign, the compiler will raise
    an error. Do it like this: `if` (x==y) {statements}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `switch` statement compares the value of a variable against a number of
    possible values, which are called cases. Each case from the `switch` statement
    has a unique name (identifier). If a match is not found in the list of cases,
    then the default statement will be executed and the program control goes out of
    the `switch` with the list of cases. The optional `break` statement is used to
    terminate the program control outside of the `switch` block. This is useful if,
    for some reason, you don''t want the `switch` statement to keep evaluating the
    rest of the cases. The following is the syntax for the `switch` statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows the syntax for the `switch` statement, including its
    break sentence. The following code is an example of using `switch`, which will
    compare the variable age against three cases. In case the variable has a value
    of `10`, it will print out the following text: `the person is a child`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have reviewed how to logically evaluate an expression. The next section
    explains how to run one or more statements repeatedly. This can be useful for
    some repetitive tasks for the microcontroller board, such as reading data from
    an input microcontroller port continuously.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `for`, `while`, and `do..while`:'
  prefs: []
  type: TYPE_NORMAL
- en: for loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `for` loop repeats one or more statements contained in its block until
    a test expression becomes false. This is the syntax of the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding syntax, the `counter_variable` initialization is executed
    once. Then, the expression is evaluated with `counter_variable`. If the tested
    expression is false, the loop is terminated. If the evaluated expression is true,
    the block statement(s) are executed, and `counter_variable` is updated. `counter_variable`
    is a local variable that only works in the `for` loop. This example prints out
    a list of numbers from 1 to 10 on the IDE''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the x++ statement is the same as writing x=x+1.
  prefs: []
  type: TYPE_NORMAL
- en: while loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `while` loop repeats one or more statements from its block while a given
    condition is true, testing its condition prior to executing the statements. When
    its condition tests false, the loop terminates. Here is the syntax for the `while`
    loop statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the syntax for the `while` loop. The following is example
    code that uses the `while` loop, counting from 0 to 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'do..while loop:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This type of loop is very similar to the `while` loop. The `do..while` loop
    executes its block statement(s) at least once. The expression is evaluated at
    the end of the block. The process continues until the evaluated expression is
    false.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the syntax for the `do..while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example uses the `do..while` loop, counting numbers from 5 to
    50, while the sum is < 50:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the variable called `number` has the value 5 added to
    it and the variable is printed out on the IDE's console at least once, and then
    the variable is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: The infinite loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also program an **infinite loop**, which, of course, will run endlessly
    (the loop does not terminate) until we abort the program (or disconnect the power
    from the microcontroller board!). Infinite loops can be useful for showing a result
    from a microcontroller continuously, reading data from a microcontroller board
    continuously without stopping it, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this using any of the three types of loops. The following are some
    examples of infinite loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, programming endless loops is easy and
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: The break and continue keywords in loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can `break` keyword. The `break` statement of the following example will
    stop the `for` loop, but the statement will run only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `break` statement in any of the three types of loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `continue` keyword. This example will not print out the second line of
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code displays the value of x without displaying the next line
    of text because of the `continue` statement, moving the program control to the
    beginning of the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The next section deals with a number of C statements and functions that were
    created specifically for the Curiosity Nano microcontroller board and that are
    slightly different from those for the Blue Pill board.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Curiosity Nano microcontroller board programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned from [*Chapter 1*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014),
    *Introduction to Microcontrollers and Microcontroller Boards*, the Curiosity Nano
    can be programmed using ANSI C language, explained in this chapter, using the
    MPLAB X IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure of a C program for the Curiosity Nano is similar to the
    one explained above using the `main()` function, but its declaration changes.
    You have to include the keyword void in it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The file `16F15376_Curiosity_Nano_IOPorts.zip` from the book's GitHub page contains
    the necessary `IO_RD1_GetValue()` function will read an analog value from the
    Curiosity Nano's RD1 port.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are useful functions that you can use for programming the Curiosity
    Nano, which is already defined by the MPLAB X compiler. Note that `xxx` means
    the Curiosity Nano''s port name. Please read [*Chapter 1*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014),
    *Introduction to Microcontrollers and Microcontroller Boards*, to familiarize
    yourself with the Curiosity Nano''s I/O port names and their respective chip pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IO_xxx_SetHigh();`: This function writes the logic HIGH (3.3 V) value on the
    specified pin (port).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IO_xxx_SetLow();`: This function writes the logic LOW (0 V) value on the specified
    pin (port).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IO_xxx_GetValue();`: This function returns the logic (digital) value (either
    HIGH or LOW) that is read from the specified port. HIGH is returned as 1\. LOW
    is returned as 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADC_GetConversion(xxx);`: This function reads an analog value from the specified
    port and returns a value from 0 to 1023 corresponding to the analog-to-digital
    conversion done on the read value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYSTEM_Initialize();`:  This function initializes the microcontroller ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__delay_ms(number_milliseconds);`: This function pauses the program for a
    number of milliseconds (there are 1,000 milliseconds in one second).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IO_xxx_Toggle();`: This function toggles the port''s value to its opposite
    state of the specified port. If the port has a logic of HIGH (1), this function
    will toggle it to 0, and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use some of the preceding functions in an example explained later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.1* shows the Curiosity Nano''s pins. Bear in mind that many of them
    are I/O ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Curiosity Nano''s pins configuration](img/Figure_2.1_B16413.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Curiosity Nano's pins configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'We have configured the following ports from the Curiosity Nano microcontroller
    board as I/O ports. We did this in all the Curiosity Nano''s software project
    files from this book. The ports'' pins can be seen in *Figure 2.1*. Some of them
    are used throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: RA0, RA1, RA2, RA3, RA4, RA5, RB0, RB3, RB4, RB5, RC0, RC1, RC7, RD0, RD1, RD2,
    RD3, RD5, RD6, RD7, RE0, RE1, and SW0.
  prefs: []
  type: TYPE_NORMAL
- en: The following section explains the basic programming structure and important
    functions for the Blue Pill board microcontroller board coding, which are somewhat
    different from the Curiosity Nano board.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Blue Pill microcontroller board programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned from [*Chapter 1*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014),
    *Introduction to Microcontrollers and Microcontroller Boards*, you can program
    the Blue Pill board using the Arduino IDE, along with a special library installed
    in the IDE. Remember that this IDE uses C++ language, which is an extension of
    C. Programs are also called sketches in Arduino IDE programming. All the sketches
    must have two functions, called `setup()` and `loop()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `setup()` function is used to define variables, define input or output ports
    (board pins), define and open a serial port, and so on, and this function will
    run only once. It must be declared before the `loop()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `loop()` function is the main block of your code and will run the main statements
    of your program. This `loop()` function will run repeatedly and endlessly. Sketches
    do not require the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the main structure for your sketches (programs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how to define pins (a microcontroller board''s ports) either as inputs
    or outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: An input port will serve to read data from a sensor or switch, and an output
    port will be used to send data to another device or component, turn on an LED,
    and suchlike.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Programming in the Arduino IDE is case-sensitive. Be careful when you write
    function names, define variables, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the preceding code, each block of statements is enclosed
    in curly brackets, and each statement ends with a semicolon, similar to ANSI C.
    These are useful functions that can be used for programming the Blue Pill:'
  prefs: []
  type: TYPE_NORMAL
- en: '`digitalWrite(pin_number, value);`: This function writes a HIGH (3.3 V) or
    LOW (0 V) value on the specified pin (port); for example, `digitalWrite(13,HIGH);`
    will send a HIGH value to pin (port) number 13.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You must previously declare `pin_number` as `OUTPUT` in the `setup()` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`digitalRead(pin_number);`: This function returns either a logic HIGH (3.3
    V) or logic LOW (0 V) value that is read from a specified pin (port), for example,
    `val = digitalRead(pin_number);`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You must previously declare `pin_number` as `INPUT` in the `setup()` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`analogWrite(pin_number, value);`: This function writes (sends) an analog value
    (0..65535) to a specified PIN (output port) of the Blue Pill.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`analogRead(pin_number);`: This function returns an analog value read from
    the specified PIN. The Blue Pill has 10 channels (ports or pins that can be used
    as analog inputs) with a 12-bit `analogRead()` function will map input voltages
    between 0 and 3.3 volts into integer numbers between 0 and 4095, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int val = analogRead(A7);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay(number_of_milliseconds);`: This function pauses the program for the
    specified amount of time defined in milliseconds (remember that there are one
    thousand milliseconds in a second).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also use the C language structure explained in this section for programming
    the Arduino microcontroller boards, with the only difference being that the range
    of values for `analogWrite()` will be 0...255 instead of 0...65535, and `analogRead()`
    will have a range of 0 to 1023 instead of 0 to 4095.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Figure 2.2* shows the I/O ports and other pins from the Blue Pill:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The Blue Pill''s pins configuration](img/Figure_2.2_B16413.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The Blue Pill's pins configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'The ports'' pins can be seen in *Figure 2.2*. Some of them are used in this
    book''s chapters. The Blue Pill has the following analog ports: A0, A1, A2, A3,
    A4, A5, A6, A7, B0, and B1\. The following are digital I/O ports: C13, C14, C15,
    B10, B11, B12, B13, B14, B15, A8, A9, A10, A11, A12, A15, B3, B4, B5, B6, B7,
    B8, and B9.'
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that in the code, the ports are referenced as `PA0`, `PA1`, and
    so on, adding a letter `P`.
  prefs: []
  type: TYPE_NORMAL
- en: We will use some of the preceding functions in an example in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Example – Programming and using the microcontroller board's internal LED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use common statements from C/C++ languages for controlling
    an internal LED from the Blue Pill and the Curiosity Nano boards. The internal
    LED can be very useful for quickly verifying the state of I/O ports, showing data
    from sensors, and so on, without the need to connect an LED with its respective
    resistor to a port. The next section will show how to compile and send a piece
    of code to the microcontroller boards using their internal LED.
  prefs: []
  type: TYPE_NORMAL
- en: Programming the Blue Pill's internal LED
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section covers the steps for programming the internal LED. You don''t
    need to connect any external electronic component, such as external LEDs. Using
    the internal LED from the Blue Pill is useful for quickly testing out and showing
    the result or variable value from a program. You will only need to use the microcontroller
    boards. The following steps demonstrate how to upload and run the program to the
    Blue Pill:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the ST-LINK/V2 interface to the Blue Pill, as explained in [*Chapter
    1*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014), *Introduction to Microcontrollers
    and Microcontroller Boards*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the USB cable to the Blue Pill and your computer. Insert the Blue Pill
    into the solderless breadboard. *Figure 2.3* shows the internal LED from the Curiosity
    Nano and the Blue Pill boards:![Figure 2.3 – The Blue Pill (top) and the Curiosity
    Nano's internal LEDs](img/Figure_2.3_B16413.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 2.3 – The Blue Pill (top) and the Curiosity Nano's internal LEDs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open Arduino IDE. Write the following program in its editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the `PC13` for `LED_BUILTIN`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could leave the Blue Pill without inserting it in a solderless breadboard
    because we are not connecting any component or wire to the Blue Pill's ports in
    the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Programming the Curiosity Nano's internal LED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the Blue Pill, you can use the Curiosity Nano's internal LED to quickly
    show data from sensors, and so on, without connecting an LED to a port. The whole
    project containing this example and other supporting files necessary for compiling
    it on the MPLAB X IDE is stored on the GitHub page. It is a zip file called `16F15376_Curiosity_Nano_LED_Blink_Delay.zip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to run the program on the MPLAB X IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the USB cable to the Curiosity Nano and insert the board in the solderless
    breadboard. Unzip the `16F15376_Curiosity_Nano_LED_Blink_Delay.zip` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the MPLAB X IDE, click on **File/Open Project** and then open the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the project folder and click on the `Source Files` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on `main.c` and you will see the following source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the code by clicking on the run icon (colored green), which
    is on the top menu. If everything went well, you will see Curiosity Nano's internal
    LED blinking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see from the preceding example, it has useful C functions specifically
    created for the Curiosity Nano board, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetLow(), SetHigh() and __delay_ms().`'
  prefs: []
  type: TYPE_NORMAL
- en: Those functions are essential for making projects with microcontroller boards,
    and they are used in other chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to properly configure and set up the MPLAB X
    and the Arduino IDEs for the C microcontroller board programming. We were introduced
    to the C programming language, and in particular, a set of C language instructions
    necessary for programming the Blue Pill and microcontroller boards. To practice
    what you have learned about the C language, we looked at a number of practical
    circuits using the boards' internal and external LEDs. The instructions and structure
    learned in this chapter can be applied to the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B16413_03_Final_NM_ePub.xhtml#_idTextAnchor041), *Turning an
    LED On and Off Using a Push Button*, will focus on how to connect a push button
    with a pull-up resistor to a microcontroller board, as well as how to minimize
    electrical noise when using the push button. It will also explain how to set up
    a microcontroller board''s input port via software, along with possible applications
    of push buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gay, W. (2018). *Beginning STM32: Developing with FreeRTOS, libopencm3, and
    GCC*. St. Catharines, ON: Apress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microchip Technology (2019). *MPLAB X IDE User's Guide.* Retrieved from [https://ww1.microchip.com/downloads/en/DeviceDoc/50002027E.pdf](https://ww1.microchip.com/downloads/en/DeviceDoc/50002027E.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
