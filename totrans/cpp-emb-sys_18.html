<html><head></head><body>
<div><h1 class="chapterNumber">14</h1>
<h1 class="chapterTitle" id="_idParaDest-192">Enhancing Super-Loop with Sequencer</h1>
<p class="normal"><strong class="keyWord">Super-loop</strong> is the <a id="_idIndexMarker622"/>basic software architecture of bare-metal firmware. It is an infinite loop that executes tasks (functions) often conditioned by flags set in an <strong class="keyWord">Interrupt Service Routine</strong> (<strong class="keyWord">ISR</strong>). As <a id="_idIndexMarker623"/>the complexity of business logic increases, so does the size of a super loop, which can quickly turn into a spaghetti mess. To solve this problem within bare-metal constraints (no operating system), we can use a sequencer.</p>
<p class="normal">A <strong class="keyWord">sequencer</strong> stores <a id="_idIndexMarker624"/>and executes tasks (functions) in an organized fashion. Instead of setting a flag in an ISR, checking it in a super loop, and executing a function if a flag is set, we simply add a task to a sequencer from the ISR. The super loop then runs the sequencer, which executes the added tasks. Tasks in the sequencer can be prioritized, so the sequencer will execute higher-priority tasks first.</p>
<p class="normal">In this chapter, we’re going to cover sequencer design and implementation through the following main topics:</p>
<ul>
<li class="bulletList">Super-loop and motivation for a sequencer</li>
<li class="bulletList">Designing a sequencer</li>
<li class="bulletList">Storing a callable</li>
<li class="bulletList">Implementing a sequencer</li>
</ul>
<h1 class="heading-1" id="_idParaDest-193">Technical requirements</h1>
<p class="normal">The examples from this chapter are available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter14">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter14</a>). To get the most out of this chapter, run the examples in the Renode simulator.</p>
<h1 class="heading-1" id="_idParaDest-194">Super-loop and motivation for a sequencer</h1>
<p class="normal">Before we <a id="_idIndexMarker625"/>get into the design and implementation of a sequencer, we will first analyze the limitations of a super loop. In a usual super-loop scenario, we check flags that are set from an ISR. Below is an example pseudocode of a super loop:</p>
<pre class="programlisting code"><code class="hljs-code">bool data_read_ready = false;
bool data_send_timeout = false;
int main() {
    // initialize hardware
while(1) {
        if(data_read_ready) {
            sensor_data_read_and_buffer();
            data_read_ready = false;
        }
        if(data_send_timeout) {
            data_send_from_buffer();
            data_send_timeout = false;
        }
        if(!data_read_ready &amp;&amp; !data_send_timeout) {
            enter_sleep();
        }
    }
}
</code></pre>
<p class="normal">In the preceding <a id="_idIndexMarker626"/>pseudocode, we perform the following steps:</p>
<ol>
<li class="numberedList" value="1">Check the Boolean flag <code class="inlineCode">data_read_ready</code> and, if it is set, we execute the function <code class="inlineCode">sensor_data_read_and_buffer</code>. We then reset the <code class="inlineCode">data_read_ready</code> flag.</li>
<li class="numberedList">Check the Boolean flag <code class="inlineCode">data_send_timeout</code> and, if it is set, we execute the function <code class="inlineCode">data_send_from_buffer</code>. We then reset the <code class="inlineCode">data_send_timeout</code> flag.</li>
<li class="numberedList">Both the <code class="inlineCode">data_read_ready</code> and <code class="inlineCode">data_send_timeout</code> flags are set from an ISR. In our example, this might be the timer’s ISR.</li>
<li class="numberedList">Finally, we check if both flags are false, and if they are, we enter sleep mode.</li>
</ol>
<p class="normal">The example we discussed is simple, but as the number of flags grows, so does the size of the super loop, the number of global variables (flags), and the possibility of a mistake such as resetting a flag or forgetting to include it in the <code class="inlineCode">if</code> statement, which provides the conditions for entering sleep mode.</p>
<p class="normal">Now, imagine we wanted to prioritize functions executed in the super loop. Using the current approach would be difficult. Adding a priority variable and checking it in <code class="inlineCode">if</code> statements might work initially, but the code would quickly become messy and difficult to maintain.</p>
<p class="normal">To address issues of a super loop in a bare-metal environment, we will utilize a sequencer. Instead of defining global flags and setting them from an ISR, we will add tasks to the sequencer from an ISR. Each task will include priority information, enabling the sequencer to organize them in an internal queue based on their priority.</p>
<p class="normal">In the main loop, the sequencer<a id="_idIndexMarker627"/> runs repeatedly. It handles tasks by always picking the highest-priority one from the queue and executing it first, keeping task management efficient and orderly.</p>
<p class="normal">Next, we will proceed with the design of the sequencer.</p>
<h1 class="heading-1" id="_idParaDest-195">Designing a sequencer</h1>
<p class="normal">We will<a id="_idIndexMarker628"/> base the sequencer design on a command pattern that we covered in <a href="Chapter_10.xhtml"><em class="italic">Chapter 10</em></a>. In the command pattern, a sequencer will take the role of invoker. In our design, we’ll use the term <em class="italic">task</em> instead of <em class="italic">command</em>. This <em class="italic">task</em> is equivalent to a function – it represents a specific unit of functionality – not a task as defined in operating systems.</p>
<figure class="mediaobject"><img alt="Figure 14.1 – Sequencer design – UML diagram" src="img/B22402_14_01.png"/></figure>
<p class="packt_figref">Figure 14.1 – Sequencer design – UML diagram</p>
<p class="normal"><em class="italic">Figure 14.1</em> depicts a UML diagram of a sequencer. We can see it takes the role of a sequencer in the <a id="_idIndexMarker629"/>command pattern, as described earlier. Instead of a command interface and concrete command, this UML design uses a <code class="inlineCode">std::function</code> class template (we used the same approach in the <em class="italic">GPIO Interrupt manager</em> example of <a href="Chapter_10.xhtml"><em class="italic">Chapter 10</em></a>).</p>
<p class="normal">The <code class="inlineCode">sequencer</code> class holds an array of tasks, which are used to store callable objects. The sequencer provides a simple interface, with just two methods:</p>
<ul>
<li class="bulletList"><code class="inlineCode">void add(task t)</code>: The method used to add a task to the sequencer</li>
<li class="bulletList"><code class="inlineCode">void run()</code>: The method used to take a task with the highest priority, execute it, and remove it from the sequencer</li>
</ul>
<p class="normal">Before we go into the implementation of sequencer methods, we will first go over the <code class="inlineCode">task</code> class and alternatives to <code class="inlineCode">std::array</code> for storing tasks. The <code class="inlineCode">task</code> class represents a unit of functionality that will be executed by a sequencer according to priority. It has the following members:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::function&lt;void()&gt; the_task_</code>: An actual callable that will be executed</li>
<li class="bulletList"><code class="inlineCode">std::uint8_t priority_</code>: Priority according to which tasks will be sorted in the sequencer’s storage</li>
</ul>
<p class="normal">Below is the code that implements the <code class="inlineCode">task</code> class:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename CallableHolder&gt;
class task {
public:
    constexpr static std::uint8_t c_prio_default = 250;
    constexpr static std::uint8_t c_prio_max = 255;
    constexpr static std::uint8_t c_prio_min = 0;
    task(CallableHolder the_task, std::uint8_t prio = c_prio_default) :
        the_task_(the_task), priority_(prio) {}
    void execute() {
        if(the_task_) {
            the_task_();
        }
    }
    bool operator&lt;(const task &amp;rhs) const
    {
        return priority_ &lt; rhs.priority_;
    }
private:
    CallableHolder the_task_;
    std::uint8_t priority_ = c_prio_default;
};
</code></pre>
<p class="normal">This code <a id="_idIndexMarker630"/>implements the task as a class template, allowing us to use it with different callable holders. The one we introduced in the book previously is <code class="inlineCode">std::function</code>. The class template task has the following members:</p>
<ul>
<li class="bulletList">A constructor that initializes the <code class="inlineCode">the_task_</code> member, which is type <code class="inlineCode">CallableHolder</code></li>
<li class="bulletList">The <code class="inlineCode">void execute()</code> method, which calls <code class="inlineCode">operator()</code> on <code class="inlineCode">the_task_</code></li>
<li class="bulletList"><code class="inlineCode">operator&lt;</code>, which compares task by priority</li>
</ul>
<p class="normal">This code demonstrates the usage of the class template task:</p>
<pre class="programlisting code"><code class="hljs-code"> using callable_holder = std::function&lt;void()&gt;;
    auto fun_a = []() {
        printf("High priority task!\r\n");
    };
    task&lt;callable_holder&gt; task_a(fun_a, 255);
    auto fun_b = []() {
        printf("Low priority task!\r\n");
    };
    task&lt;callable_holder&gt; task_b(fun_b, 20);
    if(task_a &lt; task_b) {
        task_b.execute();
    }
    else {
        task_a.execute();
    }
</code></pre>
<p class="normal">In this example, we<a id="_idIndexMarker631"/> instantiate the class template task with <code class="inlineCode">std::function&lt;void()&gt;</code>. We create two objects, <code class="inlineCode">task_a</code> and <code class="inlineCode">task_b</code>, and then execute one with higher priority by using <code class="inlineCode">operator&lt;</code> to compare them. Task objects in this example are initialized with lambdas, which are internally stored in <code class="inlineCode">std::function&lt;void()&gt;</code>. If you run the preceding example, you will see the following output:</p>
<pre class="programlisting con"><code class="hljs-con">High priority task!
</code></pre>
<p class="normal">As you can see, the task with higher priority was executed thanks to the overloaded <code class="inlineCode">operator&lt;</code>.</p>
<p class="normal">In <a href="Chapter_10.xhtml"><em class="italic">Chapter 10</em></a>, we saw that the class template <code class="inlineCode">std::function</code> can resort to dynamic memory allocation to store lambdas that are captured. To mitigate this concern, we will introduce the <strong class="keyWord">Embedded Template Library</strong> (<strong class="keyWord">ETL</strong>), a library that defines a set of containers and algorithms whose operations are deterministic and don’t use dynamic memory allocation. The ETL will be discussed more in <a href="Chapter_17.xhtml"><em class="italic">Chapter 17</em></a>.</p>
<h1 class="heading-1" id="_idParaDest-196">Storing a callable</h1>
<p class="normal">Instead of <code class="inlineCode">std::function</code>, we can use <code class="inlineCode">etl::delegate</code> – a callable holder from the ETL. One of its <a id="_idIndexMarker632"/>limitations is it doesn’t work with capturing lambdas. This may affect the code expressiveness, but it provides us with equivalent functionality that allows us to capture different callables. This code demonstrates using the class template task with <code class="inlineCode">etl::delegate</code>:</p>
<pre class="programlisting code"><code class="hljs-code"> using callable_etl = etl::delegate&lt;void()&gt;;
    using task_etl = task&lt;callable_etl&gt;;
    class test {
    public:
        test(int x) : x_(x) {}
        void print() const {
            printf("This is a test, x = %d.\r\n", x_);
        }
        void static print_static() {
            printf("This is a static method in test.\r\n");
        }
    private:
        int x_ = 0;
    };
    test test_1(42);
    task_etl task_member_fun(callable_etl::create&lt;test, &amp;test::print&gt;
(test_1));
    task_member_fun.execute();
    task_etl task_static_fun(callable_etl::create&lt;test::print_static&gt;());
    task_static_fun.execute();
    task_etl task_lambda([](){
        printf("This is non capturing lambda!\r\n");
    });
    task_lambda.execute();
</code></pre>
<p class="normal">This code <a id="_idIndexMarker633"/>demonstrates how we can use <code class="inlineCode">etl::delegate</code> to store a callable:</p>
<ul>
<li class="bulletList"><code class="inlineCode">callable_etl::create&lt;test, &amp;test::print&gt;(test_1)</code> creates <code class="inlineCode">etl::delegate</code> using the template method <code class="inlineCode">create</code> instantiated with the class <code class="inlineCode">test</code> and its member <code class="inlineCode">print</code></li>
<li class="bulletList"><code class="inlineCode">callable_etl::create&lt;test::print_static&gt;()</code> creates <code class="inlineCode">etl::delegate</code> using the template method <code class="inlineCode">create</code> instantiated with the static method <code class="inlineCode">print_static</code></li>
<li class="bulletList"><code class="inlineCode">task_lambda([](){ printf("This is non capturing lambda!\r\n");});</code> initializes <code class="inlineCode">etl::delegate</code> with the provided non-capturing lambda</li>
</ul>
<p class="normal">Running the preceding example will result in the following output:</p>
<pre class="programlisting con"><code class="hljs-con">This is a test, x = 42.
This is a static method in test.
This is non capturing lambda!
</code></pre>
<p class="normal">You can run the full example in the Renode simulator. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter14/sequencer</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel
cmake --build build --target run_in_renode
</code></pre>
<p class="normal">We have alternative implementations for callable storage – <code class="inlineCode">std::function</code> from the standard library, or the more embedded-friendly <code class="inlineCode">etl::delegate</code> from ETL. Next, let us consider options for a container for storing the tasks inside the sequencer.</p>
<p class="normal">In the UML diagram in <em class="italic">Figure 14.1</em>, the sequencer is using <code class="inlineCode">std::array</code> to store tasks. This implies that <a id="_idIndexMarker634"/>sorting the elements of an array according to the priority is handled by the sequencer itself. Instead of implementing this manually, we can use <code class="inlineCode">std::priority_queue</code> – a container adapter from the standard library.</p>
<p class="normal"><code class="inlineCode">std::priority_queue</code> is a template class that is used as an adapter for another container, which provides a random access iterator and the following methods:</p>
<ul>
<li class="bulletList"><code class="inlineCode">front()</code></li>
<li class="bulletList"><code class="inlineCode">push_back()</code></li>
<li class="bulletList"><code class="inlineCode">pop_back()</code></li>
</ul>
<p class="normal">We could use <code class="inlineCode">std::vector</code> from the standard library, as it meets all the requirements imposed by <code class="inlineCode">std::priority_queue</code>. As you know, <code class="inlineCode">std::vector</code> uses dynamic memory allocation, which doesn’t make it a good fit for most of the embedded applications.</p>
<p class="normal">ETL provides a fixed-size implementation of a vector with a similar interface as standard library implementation. This makes it compatible with the priority queue. This code demonstrates using <code class="inlineCode">etl::vector</code> with <code class="inlineCode">std::priority_queue</code>:</p>
<pre class="programlisting code"><code class="hljs-code">    std::priority_queue&lt;int, etl::vector&lt;int, 6&gt;&gt; pq{};
    pq.push(12);
    pq.push(6);
    pq.push(16);
    pq.push(8);
    pq.push(1);
    pq.push(10);
    printf("priority queue elements:\r\n");
    while(!pq.empty()) {
        printf("top element: %d, size: %d\r\n", pq.top(), pq.size());
        pq.pop();
    }
</code></pre>
<p class="normal">This code performs <a id="_idIndexMarker635"/>the following steps:</p>
<ol>
<li class="numberedList" value="1"><code class="inlineCode">std::priority_queue&lt;int, etl::vector&lt;int, 6&gt;&gt; pq{}</code> defines a priority queue, <code class="inlineCode">pq</code>, with the underlying container <code class="inlineCode">etl::vector&lt;int, 6&gt;</code>, which is a fixed size vector of size <code class="inlineCode">6</code>.</li>
<li class="numberedList"><code class="inlineCode">pq.push(12)</code> inserts an element (<code class="inlineCode">12</code>) in the priority queue, <code class="inlineCode">pq</code>, and sorts the queue.</li>
<li class="numberedList">Using the <code class="inlineCode">push</code> method, we add 5 more elements in the queue – <code class="inlineCode">6</code>, <code class="inlineCode">16</code>, <code class="inlineCode">8</code>, <code class="inlineCode">1</code>, and <code class="inlineCode">10</code>.</li>
<li class="numberedList">With <code class="inlineCode">while(!pq.empty())</code>, we run a <code class="inlineCode">while</code> loop until the priority queue is empty.</li>
<li class="numberedList">Inside the <code class="inlineCode">while</code> loop, we print the top element, which we access using the <code class="inlineCode">top()</code> method, and size using the <code class="inlineCode">size()</code> method. Then, we pop the top element from the queue using <code class="inlineCode">pop()</code>.</li>
</ol>
<p class="normal">Running the preceding code will result in the following output:</p>
<pre class="programlisting con"><code class="hljs-con">priority queue elements:
top element: 16, size: 6
top element: 12, size: 5
top element: 10, size: 4
top element: 8, size: 3
top element: 6, size: 2
top element: 1, size: 1
</code></pre>
<p class="normal">As you can see from the output, the elements in the priority queue are sorted. This makes it a good solution for storing tasks that can be sorted thanks to the overloaded <code class="inlineCode">operator&lt;</code>. You can run the full example in the Renode simulator. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter14/sequencer</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container <a id="_idIndexMarker636"/>terminal:</p>
<pre class="programlisting con"><code class="hljs-con">cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel
-DMAIN_CPP_FILE_NAME=main_pq.cpp
cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Now that we have all the elements we need for the sequencer, we will proceed with the implementation.</p>
<h1 class="heading-1" id="_idParaDest-197">Implementing a sequencer</h1>
<p class="normal">In this<a id="_idIndexMarker637"/> chapter, we introduced <code class="inlineCode">etl::delegate</code> – an alternative to <code class="inlineCode">std::function</code> and fixed size vector implementation from ETL. As ETL avoids dynamic memory allocation, we will use these components for the implementation of the sequencer. Below is an updated UML diagram:</p>
<figure class="mediaobject"><img alt="Figure 14.2 – UML sequencer diagram using ETL components" src="img/B22402_14_02.png"/></figure>
<p class="packt_figref">Figure 14.2 – UML sequencer diagram using ETL components</p>
<p class="normal"><em class="italic">Figure 14.2</em> depicts a UML diagram of the sequencer using delegate and vector ETL components and the<a id="_idIndexMarker638"/> priority queue from the standard library. This code implements <code class="inlineCode">sequencer</code>:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename Task, std::size_t Size&gt;
struct sequencer {
    sequencer() = delete;
    static void add(Task task) {
        if(pq.size() &lt; Size) {
            __disable_irq();
            pq.push(task);
            __enable_irq();
        }
    }
    static void run() {
        if(!pq.empty()) {
            __disable_irq();
            auto task = pq.top();
            pq.pop();
            __enable_irq();
            task.execute();
        }
    }
private:
    static inline std::priority_queue&lt;Task, etl::vector&lt;Task, Size&gt;&gt; pq{};
};
</code></pre>
<p class="normal">In this code, <code class="inlineCode">sequencer</code> is implemented as a static template class with <code class="inlineCode">Task</code> and <code class="inlineCode">Size</code> as template parameters. This allows us to use it with either <code class="inlineCode">std::function</code> or <code class="inlineCode">etl::function</code>-based tasks<a id="_idIndexMarker639"/> and to define the size of the ETL vector. <code class="inlineCode">sequencer</code> has the following members:</p>
<ul>
<li class="bulletList"><code class="inlineCode">static inline std::priority_queue&lt;Task, etl::vector&lt;Task, Size&gt;&gt; pq{}</code>: A private static priority queue based on an ETL vector.</li>
<li class="bulletList"><code class="inlineCode">static void add(Task task)</code>: A static method used to add tasks to the queue using the <code class="inlineCode">push</code> method, guarded by disabling and enabling interrupts, as it can be called from an ISR. </li>
<li class="bulletList"><code class="inlineCode">static void run()</code>: A static method used to take the top element from the queue and execute it. Access to the queue is guarded by disabling and enabling interrupts.</li>
</ul>
<p class="normal">Below is an example of using the sequencer:</p>
<pre class="programlisting code"><code class="hljs-code"> using callable_etl = etl::delegate&lt;void()&gt;;
    using task_etl = task&lt;callable_etl&gt;;
    class test {
    public:
        test(int x) : x_(x) {}
        void print() const {
            printf("This is a test, x = %d.\r\n", x_);
        }
        void static print_static() {
            printf("This is a static method in test.\r\n");
        }
    private:
        int x_ = 0;
    };
    test test_1(42);
    task_etl task_member_fun(callable_etl::create&lt;test, &amp;test::print&gt;
(test_1), 20);
    task_etl task_static_fun(callable_etl::create&lt;test::print_static&gt;(), 30);
    task_etl task_lambda([](){
        printf("This is non capturing lambda!\r\n");
    }, 10);
    using seq = sequencer&lt;task_etl, 16&gt;;
    seq::add(task_member_fun);
    seq::add(task_static_fun);
    seq::add(task_lambda);
    while(true)
    {
        seq::run();
    }
</code></pre>
<p class="normal">In this code, we <a id="_idIndexMarker640"/>do the following:</p>
<ul>
<li class="bulletList">Instantiate the <code class="inlineCode">etl::delegate</code>-based tasks <code class="inlineCode">task_member_fun</code>, <code class="inlineCode">task_static_fun</code>, and <code class="inlineCode">task_lambda</code>.</li>
<li class="bulletList">We add tasks to the sequencer using the sequencer <code class="inlineCode">add</code> method.</li>
<li class="bulletList">We run the sequencer in the main <code class="inlineCode">while</code> loop using the method <code class="inlineCode">run()</code>.</li>
</ul>
<p class="normal">Running the preceding code will result in the following output:</p>
<pre class="programlisting con"><code class="hljs-con">This is a static method in test.
This is a test, x = 42.
This is non capturing lambda!
</code></pre>
<p class="normal">As we can see in this code, the tasks are executed according to the assigned priority. You can run the full example in Renode. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter14/sequencer</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the<a id="_idIndexMarker641"/> Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel
-DMAIN_CPP_FILE_NAME=main_seq.cpp
cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Running the example in the simulator should provide the same console output. I invite you to explore the sequencer by adding tasks from the timer or external interrupts.</p>
<p class="normal">A sequencer offers a better alternative to a super loop by organizing tasks in a strictly sequential, prioritized manner. Deterministic behavior needs to be assured through task implementation. For instance, in the case of real-time requirements, each task must include internal monitoring to guarantee it meets the necessary real-time constraints.</p>
<h1 class="heading-1" id="_idParaDest-198">Summary</h1>
<p class="normal">In this chapter, we examined the common problems with a basic super loop, which motivated our move toward a sequencer design. We covered sequencer design in detail and introduced ETL components <code class="inlineCode">etl::delegate</code> – callable holder which is an alternative to <code class="inlineCode">std::function</code> – and a fixed size vector, which are both great fits for embedded applications as they don’t use dynamic memory allocation.</p>
<p class="normal">In the next chapter, we will learn about the observer pattern and apply it to a temperature-reading application.</p>
</div>
</body></html>