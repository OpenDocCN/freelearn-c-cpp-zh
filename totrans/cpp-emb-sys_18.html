<html><head></head><body>
<div id="_idContainer075">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 class="chapterTitle" id="_idParaDest-192"><span class="koboSpan" id="kobo.2.1">Enhancing Super-Loop with Sequencer</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.3.1">Super-loop</span></strong><span class="koboSpan" id="kobo.4.1"> is the </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.5.1">basic software architecture of bare-metal firmware. </span><span class="koboSpan" id="kobo.5.2">It is an infinite loop that executes tasks (functions) often conditioned by flags set in an </span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">Interrupt Service Routine</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.8.1">ISR</span></strong><span class="koboSpan" id="kobo.9.1">). </span><span class="koboSpan" id="kobo.9.2">As </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.10.1">the complexity of business logic increases, so does the size of a super loop, which can quickly turn into a spaghetti mess. </span><span class="koboSpan" id="kobo.10.2">To solve this problem within bare-metal constraints (no operating system), we can use a sequencer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.11.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.12.1">sequencer</span></strong><span class="koboSpan" id="kobo.13.1"> stores </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.14.1">and executes tasks (functions) in an organized fashion. </span><span class="koboSpan" id="kobo.14.2">Instead of setting a flag in an ISR, checking it in a super loop, and executing a function if a flag is set, we simply add a task to a sequencer from the ISR. </span><span class="koboSpan" id="kobo.14.3">The super loop then runs the sequencer, which executes the added tasks. </span><span class="koboSpan" id="kobo.14.4">Tasks in the sequencer can be prioritized, so the sequencer will execute higher-priority tasks first.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.15.1">In this chapter, we’re going to cover sequencer design and implementation through the following main topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Super-loop and motivation for a sequencer</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Designing a sequencer</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Storing a callable</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Implementing a sequencer</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-193"><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.21.1">The examples from this chapter are available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter14"><span class="url"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter14</span></span></a><span class="koboSpan" id="kobo.23.1">). </span><span class="koboSpan" id="kobo.23.2">To get the most out of this chapter, run the examples in the Renode simulator.</span></p>
<h1 class="heading-1" id="_idParaDest-194"><span class="koboSpan" id="kobo.24.1">Super-loop and motivation for a sequencer</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.25.1">Before we </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.26.1">get into the design and implementation of a sequencer, we will first analyze the limitations of a super loop. </span><span class="koboSpan" id="kobo.26.2">In a usual super-loop scenario, we check flags that are set from an ISR. </span><span class="koboSpan" id="kobo.26.3">Below is an example pseudocode of a super loop:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.27.1">bool</span></span><span class="koboSpan" id="kobo.28.1"> data_read_ready = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.29.1">false</span></span><span class="koboSpan" id="kobo.30.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.31.1">bool</span></span><span class="koboSpan" id="kobo.32.1"> data_send_timeout = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.33.1">false</span></span><span class="koboSpan" id="kobo.34.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.35.1">int</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.36.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.37.1">()</span></span><span class="koboSpan" id="kobo.38.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.39.1">// initialize hardware</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.40.1">while</span></span><span class="koboSpan" id="kobo.41.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.42.1">1</span></span><span class="koboSpan" id="kobo.43.1">) {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.44.1">if</span></span><span class="koboSpan" id="kobo.45.1">(data_read_ready) {
            sensor_data_read_and_buffer();
            data_read_ready = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.46.1">false</span></span><span class="koboSpan" id="kobo.47.1">;
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.48.1">if</span></span><span class="koboSpan" id="kobo.49.1">(data_send_timeout) {
            data_send_from_buffer();
            data_send_timeout = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.50.1">false</span></span><span class="koboSpan" id="kobo.51.1">;
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.52.1">if</span></span><span class="koboSpan" id="kobo.53.1">(!data_read_ready &amp;&amp; !data_send_timeout) {
            enter_sleep();
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.54.1">In the preceding </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.55.1">pseudocode, we perform the following steps:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.56.1">Check the Boolean flag </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">data_read_ready</span></code><span class="koboSpan" id="kobo.58.1"> and, if it is set, we execute the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">sensor_data_read_and_buffer</span></code><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">We then reset the </span><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">data_read_ready</span></code><span class="koboSpan" id="kobo.62.1"> flag.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.63.1">Check the Boolean flag </span><code class="inlineCode"><span class="koboSpan" id="kobo.64.1">data_send_timeout</span></code><span class="koboSpan" id="kobo.65.1"> and, if it is set, we execute the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.66.1">data_send_from_buffer</span></code><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">We then reset the </span><code class="inlineCode"><span class="koboSpan" id="kobo.68.1">data_send_timeout</span></code><span class="koboSpan" id="kobo.69.1"> flag.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.70.1">Both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.71.1">data_read_ready</span></code><span class="koboSpan" id="kobo.72.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.73.1">data_send_timeout</span></code><span class="koboSpan" id="kobo.74.1"> flags are set from an ISR. </span><span class="koboSpan" id="kobo.74.2">In our example, this might be the timer’s ISR.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.75.1">Finally, we check if both flags are false, and if they are, we enter sleep mode.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.76.1">The example we discussed is simple, but as the number of flags grows, so does the size of the super loop, the number of global variables (flags), and the possibility of a mistake such as resetting a flag or forgetting to include it in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.77.1">if</span></code><span class="koboSpan" id="kobo.78.1"> statement, which provides the conditions for entering sleep mode.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.79.1">Now, imagine we wanted to prioritize functions executed in the super loop. </span><span class="koboSpan" id="kobo.79.2">Using the current approach would be difficult. </span><span class="koboSpan" id="kobo.79.3">Adding a priority variable and checking it in </span><code class="inlineCode"><span class="koboSpan" id="kobo.80.1">if</span></code><span class="koboSpan" id="kobo.81.1"> statements might work initially, but the code would quickly become messy and difficult to maintain.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.82.1">To address issues of a super loop in a bare-metal environment, we will utilize a sequencer. </span><span class="koboSpan" id="kobo.82.2">Instead of defining global flags and setting them from an ISR, we will add tasks to the sequencer from an ISR. </span><span class="koboSpan" id="kobo.82.3">Each task will include priority information, enabling the sequencer to organize them in an internal queue based on their priority.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.83.1">In the main loop, the sequencer</span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.84.1"> runs repeatedly. </span><span class="koboSpan" id="kobo.84.2">It handles tasks by always picking the highest-priority one from the queue and executing it first, keeping task management efficient and orderly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">Next, we will proceed with the design of the sequencer.</span></p>
<h1 class="heading-1" id="_idParaDest-195"><span class="koboSpan" id="kobo.86.1">Designing a sequencer</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.87.1">We will</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.88.1"> base the sequencer design on a command pattern that we covered in </span><a href="Chapter_10.xhtml"><em class="italic"><span class="koboSpan" id="kobo.89.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">In the command pattern, a sequencer will take the role of invoker. </span><span class="koboSpan" id="kobo.90.3">In our design, we’ll use the term </span><em class="italic"><span class="koboSpan" id="kobo.91.1">task</span></em><span class="koboSpan" id="kobo.92.1"> instead of </span><em class="italic"><span class="koboSpan" id="kobo.93.1">command</span></em><span class="koboSpan" id="kobo.94.1">. </span><span class="koboSpan" id="kobo.94.2">This </span><em class="italic"><span class="koboSpan" id="kobo.95.1">task</span></em><span class="koboSpan" id="kobo.96.1"> is equivalent to a function – it represents a specific unit of functionality – not a task as defined in operating systems.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.97.1"><img alt="Figure 14.1 – Sequencer design – UML diagram" src="../Images/B22402_14_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.98.1">Figure 14.1 – Sequencer design – UML diagram</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.99.1">Figure 14.1</span></em><span class="koboSpan" id="kobo.100.1"> depicts a UML diagram of a sequencer. </span><span class="koboSpan" id="kobo.100.2">We can see it takes the role of a sequencer in the </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.101.1">command pattern, as described earlier. </span><span class="koboSpan" id="kobo.101.2">Instead of a command interface and concrete command, this UML design uses a </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">std::function</span></code><span class="koboSpan" id="kobo.103.1"> class template (we used the same approach in the </span><em class="italic"><span class="koboSpan" id="kobo.104.1">GPIO Interrupt manager</span></em><span class="koboSpan" id="kobo.105.1"> example of </span><a href="Chapter_10.xhtml"><em class="italic"><span class="koboSpan" id="kobo.106.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.107.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.108.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.109.1">sequencer</span></code><span class="koboSpan" id="kobo.110.1"> class holds an array of tasks, which are used to store callable objects. </span><span class="koboSpan" id="kobo.110.2">The sequencer provides a simple interface, with just two methods:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">void add(task t)</span></code><span class="koboSpan" id="kobo.112.1">: The method used to add a task to the sequencer</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.113.1">void run()</span></code><span class="koboSpan" id="kobo.114.1">: The method used to take a task with the highest priority, execute it, and remove it from the sequencer</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.115.1">Before we go into the implementation of sequencer methods, we will first go over the </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">task</span></code><span class="koboSpan" id="kobo.117.1"> class and alternatives to </span><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">std::array</span></code><span class="koboSpan" id="kobo.119.1"> for storing tasks. </span><span class="koboSpan" id="kobo.119.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.120.1">task</span></code><span class="koboSpan" id="kobo.121.1"> class represents a unit of functionality that will be executed by a sequencer according to priority. </span><span class="koboSpan" id="kobo.121.2">It has the following members:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.122.1">std::function&lt;void()&gt; the_task_</span></code><span class="koboSpan" id="kobo.123.1">: An actual callable that will be executed</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.124.1">std::uint8_t priority_</span></code><span class="koboSpan" id="kobo.125.1">: Priority according to which tasks will be sorted in the sequencer’s storage</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.126.1">Below is the code that implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">task</span></code><span class="koboSpan" id="kobo.128.1"> class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.129.1">template</span></span><span class="koboSpan" id="kobo.130.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.131.1">typename</span></span><span class="koboSpan" id="kobo.132.1"> CallableHolder&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.133.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.134.1">task</span></span><span class="koboSpan" id="kobo.135.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.136.1">public</span></span><span class="koboSpan" id="kobo.137.1">:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.138.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.139.1">static</span></span><span class="koboSpan" id="kobo.140.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.141.1">uint8_t</span></span><span class="koboSpan" id="kobo.142.1"> c_prio_default = </span><span class="hljs-number"><span class="koboSpan" id="kobo.143.1">250</span></span><span class="koboSpan" id="kobo.144.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.145.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.146.1">static</span></span><span class="koboSpan" id="kobo.147.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.148.1">uint8_t</span></span><span class="koboSpan" id="kobo.149.1"> c_prio_max = </span><span class="hljs-number"><span class="koboSpan" id="kobo.150.1">255</span></span><span class="koboSpan" id="kobo.151.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.152.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.153.1">static</span></span><span class="koboSpan" id="kobo.154.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.155.1">uint8_t</span></span><span class="koboSpan" id="kobo.156.1"> c_prio_min = </span><span class="hljs-number"><span class="koboSpan" id="kobo.157.1">0</span></span><span class="koboSpan" id="kobo.158.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.159.1">task</span></span><span class="koboSpan" id="kobo.160.1">(CallableHolder the_task, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.161.1">uint8_t</span></span><span class="koboSpan" id="kobo.162.1"> prio = c_prio_default) :
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.163.1">the_task_</span></span><span class="koboSpan" id="kobo.164.1">(the_task), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.165.1">priority_</span></span><span class="koboSpan" id="kobo.166.1">(prio) {}
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.167.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.168.1">execute</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.169.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.170.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.171.1">if</span></span><span class="koboSpan" id="kobo.172.1">(the_task_) {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.173.1">the_task_</span></span><span class="koboSpan" id="kobo.174.1">();
        }
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.175.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.176.1">operator</span></span><span class="koboSpan" id="kobo.177.1">&lt;(</span><span class="hljs-type"><span class="koboSpan" id="kobo.178.1">const</span></span><span class="koboSpan" id="kobo.179.1"> task &amp;rhs) </span><span class="hljs-type"><span class="koboSpan" id="kobo.180.1">const</span></span><span class="koboSpan" id="kobo.181.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.182.1">return</span></span><span class="koboSpan" id="kobo.183.1"> priority_ &lt; rhs.priority_;
    }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.184.1">private</span></span><span class="koboSpan" id="kobo.185.1">:
    CallableHolder the_task_;
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.186.1">uint8_t</span></span><span class="koboSpan" id="kobo.187.1"> priority_ = c_prio_default;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.188.1">This code </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.189.1">implements the task as a class template, allowing us to use it with different callable holders. </span><span class="koboSpan" id="kobo.189.2">The one we introduced in the book previously is </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">std::function</span></code><span class="koboSpan" id="kobo.191.1">. </span><span class="koboSpan" id="kobo.191.2">The class template task has the following members:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.192.1">A constructor that initializes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">the_task_</span></code><span class="koboSpan" id="kobo.194.1"> member, which is type </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">CallableHolder</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.196.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">void execute()</span></code><span class="koboSpan" id="kobo.198.1"> method, which calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">operator()</span></code><span class="koboSpan" id="kobo.200.1"> on </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">the_task_</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.202.1">operator&lt;</span></code><span class="koboSpan" id="kobo.203.1">, which compares task by priority</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.204.1">This code demonstrates the usage of the class template task:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.205.1">using</span></span><span class="koboSpan" id="kobo.206.1"> callable_holder = std::function&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.207.1">void</span></span><span class="koboSpan" id="kobo.208.1">()&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.209.1">auto</span></span><span class="koboSpan" id="kobo.210.1"> fun_a = []() {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.211.1">printf</span></span><span class="koboSpan" id="kobo.212.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.213.1">"High priority task!\r\n"</span></span><span class="koboSpan" id="kobo.214.1">);
    };
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.215.1">task&lt;callable_holder&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.216.1">task_a</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.217.1">(fun_a, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.218.1">255</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.219.1">)</span></span><span class="koboSpan" id="kobo.220.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.221.1">auto</span></span><span class="koboSpan" id="kobo.222.1"> fun_b = []() {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.223.1">printf</span></span><span class="koboSpan" id="kobo.224.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.225.1">"Low priority task!\r\n"</span></span><span class="koboSpan" id="kobo.226.1">);
    };
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.227.1">task&lt;callable_holder&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.228.1">task_b</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.229.1">(fun_b, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.230.1">20</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.231.1">)</span></span><span class="koboSpan" id="kobo.232.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.233.1">if</span></span><span class="koboSpan" id="kobo.234.1">(task_a &lt; task_b) {
        task_b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.235.1">execute</span></span><span class="koboSpan" id="kobo.236.1">();
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.237.1">else</span></span><span class="koboSpan" id="kobo.238.1"> {
        task_a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.239.1">execute</span></span><span class="koboSpan" id="kobo.240.1">();
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.241.1">In this example, we</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.242.1"> instantiate the class template task with </span><code class="inlineCode"><span class="koboSpan" id="kobo.243.1">std::function&lt;void()&gt;</span></code><span class="koboSpan" id="kobo.244.1">. </span><span class="koboSpan" id="kobo.244.2">We create two objects, </span><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">task_a</span></code><span class="koboSpan" id="kobo.246.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">task_b</span></code><span class="koboSpan" id="kobo.248.1">, and then execute one with higher priority by using </span><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">operator&lt;</span></code><span class="koboSpan" id="kobo.250.1"> to compare them. </span><span class="koboSpan" id="kobo.250.2">Task objects in this example are initialized with lambdas, which are internally stored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">std::function&lt;void()&gt;</span></code><span class="koboSpan" id="kobo.252.1">. </span><span class="koboSpan" id="kobo.252.2">If you run the preceding example, you will see the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.253.1">High priority task!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.254.1">As you can see, the task with higher priority was executed thanks to the overloaded </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">operator&lt;</span></code><span class="koboSpan" id="kobo.256.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.257.1">In </span><a href="Chapter_10.xhtml"><em class="italic"><span class="koboSpan" id="kobo.258.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.259.1">, we saw that the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">std::function</span></code><span class="koboSpan" id="kobo.261.1"> can resort to dynamic memory allocation to store lambdas that are captured. </span><span class="koboSpan" id="kobo.261.2">To mitigate this concern, we will introduce the </span><strong class="keyWord"><span class="koboSpan" id="kobo.262.1">Embedded Template Library</span></strong><span class="koboSpan" id="kobo.263.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.264.1">ETL</span></strong><span class="koboSpan" id="kobo.265.1">), a library that defines a set of containers and algorithms whose operations are deterministic and don’t use dynamic memory allocation. </span><span class="koboSpan" id="kobo.265.2">The ETL will be discussed more in </span><a href="Chapter_17.xhtml"><em class="italic"><span class="koboSpan" id="kobo.266.1">Chapter 17</span></em></a><span class="koboSpan" id="kobo.267.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-196"><span class="koboSpan" id="kobo.268.1">Storing a callable</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.269.1">Instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">std::function</span></code><span class="koboSpan" id="kobo.271.1">, we can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.272.1">etl::delegate</span></code><span class="koboSpan" id="kobo.273.1"> – a callable holder from the ETL. </span><span class="koboSpan" id="kobo.273.2">One of its </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.274.1">limitations is it doesn’t work with capturing lambdas. </span><span class="koboSpan" id="kobo.274.2">This may affect the code expressiveness, but it provides us with equivalent functionality that allows us to capture different callables. </span><span class="koboSpan" id="kobo.274.3">This code demonstrates using the class template task with </span><code class="inlineCode"><span class="koboSpan" id="kobo.275.1">etl::delegate</span></code><span class="koboSpan" id="kobo.276.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.277.1">using</span></span><span class="koboSpan" id="kobo.278.1"> callable_etl = etl::delegate&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.279.1">void</span></span><span class="koboSpan" id="kobo.280.1">()&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.281.1">using</span></span><span class="koboSpan" id="kobo.282.1"> task_etl = task&lt;callable_etl&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.283.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.284.1">test</span></span><span class="koboSpan" id="kobo.285.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.286.1">public</span></span><span class="koboSpan" id="kobo.287.1">:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.288.1">test</span></span><span class="koboSpan" id="kobo.289.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.290.1">int</span></span><span class="koboSpan" id="kobo.291.1"> x) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.292.1">x_</span></span><span class="koboSpan" id="kobo.293.1">(x) {}
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.294.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.295.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.296.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.297.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.298.1">{
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.299.1">printf</span></span><span class="koboSpan" id="kobo.300.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.301.1">"This is a test, x = %d.\r\n"</span></span><span class="koboSpan" id="kobo.302.1">, x_);
        }
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.303.1">void</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.304.1">static</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.305.1">print_static</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.306.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.307.1">{
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.308.1">printf</span></span><span class="koboSpan" id="kobo.309.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.310.1">"This is a static method in test.\r\n"</span></span><span class="koboSpan" id="kobo.311.1">);
        }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.312.1">private</span></span><span class="koboSpan" id="kobo.313.1">:
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.314.1">int</span></span><span class="koboSpan" id="kobo.315.1"> x_ = </span><span class="hljs-number"><span class="koboSpan" id="kobo.316.1">0</span></span><span class="koboSpan" id="kobo.317.1">;
    };
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.318.1">test </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.319.1">test_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.320.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.321.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.322.1">)</span></span><span class="koboSpan" id="kobo.323.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.324.1">task_etl </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.325.1">task_member_fun</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.326.1">(callable_etl::create&lt;test, &amp;test::print&gt;</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.327.1">(test_1))</span></span><span class="koboSpan" id="kobo.328.1">;
    task_member_fun.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.329.1">execute</span></span><span class="koboSpan" id="kobo.330.1">();
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.331.1">task_etl </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.332.1">task_static_fun</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.333.1">(callable_etl::create&lt;test::print_static&gt;())</span></span><span class="koboSpan" id="kobo.334.1">;
    task_static_fun.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.335.1">execute</span></span><span class="koboSpan" id="kobo.336.1">();
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.337.1">task_etl </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.338.1">task_lambda</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.339.1">([](){</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.340.1">        printf(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.341.1">"This is non capturing lambda!\r\n"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.342.1">);</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.343.1">    })</span></span><span class="koboSpan" id="kobo.344.1">;
    task_lambda.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.345.1">execute</span></span><span class="koboSpan" id="kobo.346.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.347.1">This code </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.348.1">demonstrates how we can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">etl::delegate</span></code><span class="koboSpan" id="kobo.350.1"> to store a callable:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">callable_etl::create&lt;test, &amp;test::print&gt;(test_1)</span></code><span class="koboSpan" id="kobo.352.1"> creates </span><code class="inlineCode"><span class="koboSpan" id="kobo.353.1">etl::delegate</span></code><span class="koboSpan" id="kobo.354.1"> using the template method </span><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">create</span></code><span class="koboSpan" id="kobo.356.1"> instantiated with the class </span><code class="inlineCode"><span class="koboSpan" id="kobo.357.1">test</span></code><span class="koboSpan" id="kobo.358.1"> and its member </span><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">print</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">callable_etl::create&lt;test::print_static&gt;()</span></code><span class="koboSpan" id="kobo.361.1"> creates </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">etl::delegate</span></code><span class="koboSpan" id="kobo.363.1"> using the template method </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">create</span></code><span class="koboSpan" id="kobo.365.1"> instantiated with the static method </span><code class="inlineCode"><span class="koboSpan" id="kobo.366.1">print_static</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">task_lambda([](){ printf("This is non capturing lambda!\r\n");});</span></code><span class="koboSpan" id="kobo.368.1"> initializes </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">etl::delegate</span></code><span class="koboSpan" id="kobo.370.1"> with the provided non-capturing lambda</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.371.1">Running the preceding example will result in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.372.1">This is a test, x = 42.
</span><span class="koboSpan" id="kobo.372.2">This is a static method in test.
</span><span class="koboSpan" id="kobo.372.3">This is non capturing lambda!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.373.1">You can run the full example in the Renode simulator. </span><span class="koboSpan" id="kobo.373.2">Start Visual Studio Code, attach it to the running container, open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.374.1">Chapter14/sequencer</span></code><span class="koboSpan" id="kobo.375.1"> project, as described in </span><a href="Chapter_04.xhtml"><em class="italic"><span class="koboSpan" id="kobo.376.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.377.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.378.1">cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel
cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.379.1">We have alternative implementations for callable storage – </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">std::function</span></code><span class="koboSpan" id="kobo.381.1"> from the standard library, or the more embedded-friendly </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">etl::delegate</span></code><span class="koboSpan" id="kobo.383.1"> from ETL. </span><span class="koboSpan" id="kobo.383.2">Next, let us consider options for a container for storing the tasks inside the sequencer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.384.1">In the UML diagram in </span><em class="italic"><span class="koboSpan" id="kobo.385.1">Figure 14.1</span></em><span class="koboSpan" id="kobo.386.1">, the sequencer is using </span><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">std::array</span></code><span class="koboSpan" id="kobo.388.1"> to store tasks. </span><span class="koboSpan" id="kobo.388.2">This implies that </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.389.1">sorting the elements of an array according to the priority is handled by the sequencer itself. </span><span class="koboSpan" id="kobo.389.2">Instead of implementing this manually, we can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">std::priority_queue</span></code><span class="koboSpan" id="kobo.391.1"> – a container adapter from the standard library.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">std::priority_queue</span></code><span class="koboSpan" id="kobo.393.1"> is a template class that is used as an adapter for another container, which provides a random access iterator and the following methods:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.394.1">front()</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">push_back()</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.396.1">pop_back()</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.397.1">We could use </span><code class="inlineCode"><span class="koboSpan" id="kobo.398.1">std::vector</span></code><span class="koboSpan" id="kobo.399.1"> from the standard library, as it meets all the requirements imposed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.400.1">std::priority_queue</span></code><span class="koboSpan" id="kobo.401.1">. </span><span class="koboSpan" id="kobo.401.2">As you know, </span><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">std::vector</span></code><span class="koboSpan" id="kobo.403.1"> uses dynamic memory allocation, which doesn’t make it a good fit for most of the embedded applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.404.1">ETL provides a fixed-size implementation of a vector with a similar interface as standard library implementation. </span><span class="koboSpan" id="kobo.404.2">This makes it compatible with the priority queue. </span><span class="koboSpan" id="kobo.404.3">This code demonstrates using </span><code class="inlineCode"><span class="koboSpan" id="kobo.405.1">etl::vector</span></code><span class="koboSpan" id="kobo.406.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.407.1">std::priority_queue</span></code><span class="koboSpan" id="kobo.408.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.409.1">    std::priority_queue&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.410.1">int</span></span><span class="koboSpan" id="kobo.411.1">, etl::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.412.1">int</span></span><span class="koboSpan" id="kobo.413.1">, 6&gt;&gt; pq{};
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.414.1">push</span></span><span class="koboSpan" id="kobo.415.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.416.1">12</span></span><span class="koboSpan" id="kobo.417.1">);
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.418.1">push</span></span><span class="koboSpan" id="kobo.419.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.420.1">6</span></span><span class="koboSpan" id="kobo.421.1">);
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.422.1">push</span></span><span class="koboSpan" id="kobo.423.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.424.1">16</span></span><span class="koboSpan" id="kobo.425.1">);
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.426.1">push</span></span><span class="koboSpan" id="kobo.427.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.428.1">8</span></span><span class="koboSpan" id="kobo.429.1">);
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.430.1">push</span></span><span class="koboSpan" id="kobo.431.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.432.1">1</span></span><span class="koboSpan" id="kobo.433.1">);
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.434.1">push</span></span><span class="koboSpan" id="kobo.435.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.436.1">10</span></span><span class="koboSpan" id="kobo.437.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.438.1">printf</span></span><span class="koboSpan" id="kobo.439.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.440.1">"priority queue elements:\r\n"</span></span><span class="koboSpan" id="kobo.441.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.442.1">while</span></span><span class="koboSpan" id="kobo.443.1">(!pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.444.1">empty</span></span><span class="koboSpan" id="kobo.445.1">()) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.446.1">printf</span></span><span class="koboSpan" id="kobo.447.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.448.1">"top element: %d, size: %d\r\n"</span></span><span class="koboSpan" id="kobo.449.1">, pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.450.1">top</span></span><span class="koboSpan" id="kobo.451.1">(), pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.452.1">size</span></span><span class="koboSpan" id="kobo.453.1">());
        pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.454.1">pop</span></span><span class="koboSpan" id="kobo.455.1">();
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.456.1">This code performs </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.457.1">the following steps:</span></p>
<ol>
<li class="numberedList" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">std::priority_queue&lt;int, etl::vector&lt;int, 6&gt;&gt; pq{}</span></code><span class="koboSpan" id="kobo.459.1"> defines a priority queue, </span><code class="inlineCode"><span class="koboSpan" id="kobo.460.1">pq</span></code><span class="koboSpan" id="kobo.461.1">, with the underlying container </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">etl::vector&lt;int, 6&gt;</span></code><span class="koboSpan" id="kobo.463.1">, which is a fixed size vector of size </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">6</span></code><span class="koboSpan" id="kobo.465.1">.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">pq.push(12)</span></code><span class="koboSpan" id="kobo.467.1"> inserts an element (</span><code class="inlineCode"><span class="koboSpan" id="kobo.468.1">12</span></code><span class="koboSpan" id="kobo.469.1">) in the priority queue, </span><code class="inlineCode"><span class="koboSpan" id="kobo.470.1">pq</span></code><span class="koboSpan" id="kobo.471.1">, and sorts the queue.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.472.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.473.1">push</span></code><span class="koboSpan" id="kobo.474.1"> method, we add 5 more elements in the queue – </span><code class="inlineCode"><span class="koboSpan" id="kobo.475.1">6</span></code><span class="koboSpan" id="kobo.476.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">16</span></code><span class="koboSpan" id="kobo.478.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.479.1">8</span></code><span class="koboSpan" id="kobo.480.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.481.1">1</span></code><span class="koboSpan" id="kobo.482.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.483.1">10</span></code><span class="koboSpan" id="kobo.484.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.485.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.486.1">while(!pq.empty())</span></code><span class="koboSpan" id="kobo.487.1">, we run a </span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1">while</span></code><span class="koboSpan" id="kobo.489.1"> loop until the priority queue is empty.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.490.1">Inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.491.1">while</span></code><span class="koboSpan" id="kobo.492.1"> loop, we print the top element, which we access using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.493.1">top()</span></code><span class="koboSpan" id="kobo.494.1"> method, and size using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">size()</span></code><span class="koboSpan" id="kobo.496.1"> method. </span><span class="koboSpan" id="kobo.496.2">Then, we pop the top element from the queue using </span><code class="inlineCode"><span class="koboSpan" id="kobo.497.1">pop()</span></code><span class="koboSpan" id="kobo.498.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.499.1">Running the preceding code will result in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.500.1">priority queue elements:
top element: 16, size: 6
top element: 12, size: 5
top element: 10, size: 4
top element: 8, size: 3
top element: 6, size: 2
top element: 1, size: 1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.501.1">As you can see from the output, the elements in the priority queue are sorted. </span><span class="koboSpan" id="kobo.501.2">This makes it a good solution for storing tasks that can be sorted thanks to the overloaded </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">operator&lt;</span></code><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">You can run the full example in the Renode simulator. </span><span class="koboSpan" id="kobo.503.3">Start Visual Studio Code, attach it to the running container, open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">Chapter14/sequencer</span></code><span class="koboSpan" id="kobo.505.1"> project, as described in </span><a href="Chapter_04.xhtml"><em class="italic"><span class="koboSpan" id="kobo.506.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.507.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.508.1">terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.509.1">cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel
-DMAIN_CPP_FILE_NAME=main_pq.cpp
cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.510.1">Now that we have all the elements we need for the sequencer, we will proceed with the implementation.</span></p>
<h1 class="heading-1" id="_idParaDest-197"><span class="koboSpan" id="kobo.511.1">Implementing a sequencer</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.512.1">In this</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.513.1"> chapter, we introduced </span><code class="inlineCode"><span class="koboSpan" id="kobo.514.1">etl::delegate</span></code><span class="koboSpan" id="kobo.515.1"> – an alternative to </span><code class="inlineCode"><span class="koboSpan" id="kobo.516.1">std::function</span></code><span class="koboSpan" id="kobo.517.1"> and fixed size vector implementation from ETL. </span><span class="koboSpan" id="kobo.517.2">As ETL avoids dynamic memory allocation, we will use these components for the implementation of the sequencer. </span><span class="koboSpan" id="kobo.517.3">Below is an updated UML diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.518.1"><img alt="Figure 14.2 – UML sequencer diagram using ETL components" src="../Images/B22402_14_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.519.1">Figure 14.2 – UML sequencer diagram using ETL components</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.520.1">Figure 14.2</span></em><span class="koboSpan" id="kobo.521.1"> depicts a UML diagram of the sequencer using delegate and vector ETL components and the</span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.522.1"> priority queue from the standard library. </span><span class="koboSpan" id="kobo.522.2">This code implements </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">sequencer</span></code><span class="koboSpan" id="kobo.524.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.525.1">template</span></span><span class="koboSpan" id="kobo.526.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.527.1">typename</span></span><span class="koboSpan" id="kobo.528.1"> Task, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.529.1">size_t</span></span><span class="koboSpan" id="kobo.530.1"> Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.531.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.532.1">sequencer</span></span><span class="koboSpan" id="kobo.533.1"> {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.534.1">sequencer</span></span><span class="koboSpan" id="kobo.535.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.536.1">delete</span></span><span class="koboSpan" id="kobo.537.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.538.1">static</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.539.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.540.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.541.1">(Task task)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.542.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.543.1">if</span></span><span class="koboSpan" id="kobo.544.1">(pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.545.1">size</span></span><span class="koboSpan" id="kobo.546.1">() &lt; Size) {
            __disable_irq();
            pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.547.1">push</span></span><span class="koboSpan" id="kobo.548.1">(task);
            __enable_irq();
        }
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.549.1">static</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.550.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.551.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.552.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.553.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.554.1">if</span></span><span class="koboSpan" id="kobo.555.1">(!pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.556.1">empty</span></span><span class="koboSpan" id="kobo.557.1">()) {
            __disable_irq();
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.558.1">auto</span></span><span class="koboSpan" id="kobo.559.1"> task = pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.560.1">top</span></span><span class="koboSpan" id="kobo.561.1">();
            pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.562.1">pop</span></span><span class="koboSpan" id="kobo.563.1">();
            __enable_irq();
            task.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.564.1">execute</span></span><span class="koboSpan" id="kobo.565.1">();
        }
    }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.566.1">private</span></span><span class="koboSpan" id="kobo.567.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.568.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.569.1">inline</span></span><span class="koboSpan" id="kobo.570.1"> std::priority_queue&lt;Task, etl::vector&lt;Task, Size&gt;&gt; pq{};
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.571.1">In this code, </span><code class="inlineCode"><span class="koboSpan" id="kobo.572.1">sequencer</span></code><span class="koboSpan" id="kobo.573.1"> is implemented as a static template class with </span><code class="inlineCode"><span class="koboSpan" id="kobo.574.1">Task</span></code><span class="koboSpan" id="kobo.575.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.576.1">Size</span></code><span class="koboSpan" id="kobo.577.1"> as template parameters. </span><span class="koboSpan" id="kobo.577.2">This allows us to use it with either </span><code class="inlineCode"><span class="koboSpan" id="kobo.578.1">std::function</span></code><span class="koboSpan" id="kobo.579.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.580.1">etl::function</span></code><span class="koboSpan" id="kobo.581.1">-based tasks</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.582.1"> and to define the size of the ETL vector. </span><code class="inlineCode"><span class="koboSpan" id="kobo.583.1">sequencer</span></code><span class="koboSpan" id="kobo.584.1"> has the following members:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.585.1">static inline std::priority_queue&lt;Task, etl::vector&lt;Task, Size&gt;&gt; pq{}</span></code><span class="koboSpan" id="kobo.586.1">: A private static priority queue based on an ETL vector.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">static void add(Task task)</span></code><span class="koboSpan" id="kobo.588.1">: A static method used to add tasks to the queue using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.589.1">push</span></code><span class="koboSpan" id="kobo.590.1"> method, guarded by disabling and enabling interrupts, as it can be called from an ISR. </span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.591.1">static void run()</span></code><span class="koboSpan" id="kobo.592.1">: A static method used to take the top element from the queue and execute it. </span><span class="koboSpan" id="kobo.592.2">Access to the queue is guarded by disabling and enabling interrupts.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.593.1">Below is an example of using the sequencer:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.594.1">using</span></span><span class="koboSpan" id="kobo.595.1"> callable_etl = etl::delegate&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.596.1">void</span></span><span class="koboSpan" id="kobo.597.1">()&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.598.1">using</span></span><span class="koboSpan" id="kobo.599.1"> task_etl = task&lt;callable_etl&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.600.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.601.1">test</span></span><span class="koboSpan" id="kobo.602.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.603.1">public</span></span><span class="koboSpan" id="kobo.604.1">:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.605.1">test</span></span><span class="koboSpan" id="kobo.606.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.607.1">int</span></span><span class="koboSpan" id="kobo.608.1"> x) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.609.1">x_</span></span><span class="koboSpan" id="kobo.610.1">(x) {}
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.611.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.612.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.613.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.614.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.615.1">{
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.616.1">printf</span></span><span class="koboSpan" id="kobo.617.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.618.1">"This is a test, x = %d.\r\n"</span></span><span class="koboSpan" id="kobo.619.1">, x_);
        }
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.620.1">void</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.621.1">static</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.622.1">print_static</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.623.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.624.1">{
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.625.1">printf</span></span><span class="koboSpan" id="kobo.626.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.627.1">"This is a static method in test.\r\n"</span></span><span class="koboSpan" id="kobo.628.1">);
        }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.629.1">private</span></span><span class="koboSpan" id="kobo.630.1">:
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.631.1">int</span></span><span class="koboSpan" id="kobo.632.1"> x_ = </span><span class="hljs-number"><span class="koboSpan" id="kobo.633.1">0</span></span><span class="koboSpan" id="kobo.634.1">;
    };
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.635.1">test </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.636.1">test_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.637.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.638.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.639.1">)</span></span><span class="koboSpan" id="kobo.640.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.641.1">task_etl </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.642.1">task_member_fun</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.643.1">(callable_etl::create&lt;test, &amp;test::print&gt;</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.644.1">(test_1), </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.645.1">20</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.646.1">)</span></span><span class="koboSpan" id="kobo.647.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.648.1">task_etl </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.649.1">task_static_fun</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.650.1">(callable_etl::create&lt;test::print_static&gt;(), </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.651.1">30</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.652.1">)</span></span><span class="koboSpan" id="kobo.653.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.654.1">task_etl </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.655.1">task_lambda</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.656.1">([](){</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.657.1">        printf(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.658.1">"This is non capturing lambda!\r\n"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.659.1">);</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.660.1">    }, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.661.1">10</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.662.1">)</span></span><span class="koboSpan" id="kobo.663.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.664.1">using</span></span><span class="koboSpan" id="kobo.665.1"> seq = sequencer&lt;task_etl, </span><span class="hljs-number"><span class="koboSpan" id="kobo.666.1">16</span></span><span class="koboSpan" id="kobo.667.1">&gt;;
    seq::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.668.1">add</span></span><span class="koboSpan" id="kobo.669.1">(task_member_fun);
    seq::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.670.1">add</span></span><span class="koboSpan" id="kobo.671.1">(task_static_fun);
    seq::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.672.1">add</span></span><span class="koboSpan" id="kobo.673.1">(task_lambda);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.674.1">while</span></span><span class="koboSpan" id="kobo.675.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.676.1">true</span></span><span class="koboSpan" id="kobo.677.1">)
    {
        seq::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.678.1">run</span></span><span class="koboSpan" id="kobo.679.1">();
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.680.1">In this code, we </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.681.1">do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.682.1">Instantiate the </span><code class="inlineCode"><span class="koboSpan" id="kobo.683.1">etl::delegate</span></code><span class="koboSpan" id="kobo.684.1">-based tasks </span><code class="inlineCode"><span class="koboSpan" id="kobo.685.1">task_member_fun</span></code><span class="koboSpan" id="kobo.686.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.687.1">task_static_fun</span></code><span class="koboSpan" id="kobo.688.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.689.1">task_lambda</span></code><span class="koboSpan" id="kobo.690.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.691.1">We add tasks to the sequencer using the sequencer </span><code class="inlineCode"><span class="koboSpan" id="kobo.692.1">add</span></code><span class="koboSpan" id="kobo.693.1"> method.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.694.1">We run the sequencer in the main </span><code class="inlineCode"><span class="koboSpan" id="kobo.695.1">while</span></code><span class="koboSpan" id="kobo.696.1"> loop using the method </span><code class="inlineCode"><span class="koboSpan" id="kobo.697.1">run()</span></code><span class="koboSpan" id="kobo.698.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.699.1">Running the preceding code will result in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.700.1">This is a static method in test.
</span><span class="koboSpan" id="kobo.700.2">This is a test, x = 42.
</span><span class="koboSpan" id="kobo.700.3">This is non capturing lambda!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.701.1">As we can see in this code, the tasks are executed according to the assigned priority. </span><span class="koboSpan" id="kobo.701.2">You can run the full example in Renode. </span><span class="koboSpan" id="kobo.701.3">Start Visual Studio Code, attach it to the running container, open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">Chapter14/sequencer</span></code><span class="koboSpan" id="kobo.703.1"> project, as described in </span><a href="Chapter_04.xhtml"><em class="italic"><span class="koboSpan" id="kobo.704.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.705.1">, and run the following commands in the</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.706.1"> Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.707.1">cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel
-DMAIN_CPP_FILE_NAME=main_seq.cpp
cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.708.1">Running the example in the simulator should provide the same console output. </span><span class="koboSpan" id="kobo.708.2">I invite you to explore the sequencer by adding tasks from the timer or external interrupts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.709.1">A sequencer offers a better alternative to a super loop by organizing tasks in a strictly sequential, prioritized manner. </span><span class="koboSpan" id="kobo.709.2">Deterministic behavior needs to be assured through task implementation. </span><span class="koboSpan" id="kobo.709.3">For instance, in the case of real-time requirements, each task must include internal monitoring to guarantee it meets the necessary real-time constraints.</span></p>
<h1 class="heading-1" id="_idParaDest-198"><span class="koboSpan" id="kobo.710.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.711.1">In this chapter, we examined the common problems with a basic super loop, which motivated our move toward a sequencer design. </span><span class="koboSpan" id="kobo.711.2">We covered sequencer design in detail and introduced ETL components </span><code class="inlineCode"><span class="koboSpan" id="kobo.712.1">etl::delegate</span></code><span class="koboSpan" id="kobo.713.1"> – callable holder which is an alternative to </span><code class="inlineCode"><span class="koboSpan" id="kobo.714.1">std::function</span></code><span class="koboSpan" id="kobo.715.1"> – and a fixed size vector, which are both great fits for embedded applications as they don’t use dynamic memory allocation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.716.1">In the next chapter, we will learn about the observer pattern and apply it to a temperature-reading application.</span></p>
</div>
</body></html>