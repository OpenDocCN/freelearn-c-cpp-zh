<html><head></head><body>
<div id="_idContainer144">
<h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-174"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.2.1">Extending AI Behaviors</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Enhancing an enemy character’s behavior in a multiplayer game is a great way of making it more challenging and exciting for players. </span><span class="koboSpan" id="kobo.3.2">It can also help create a more immersive experience, as enemies become smarter, faster, and stronger. </span><span class="koboSpan" id="kobo.3.3">By introducing new abilities or changing existing ones, you can make your game stand out from other similar titles on </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the market.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, you will learn how to add improvements to your minion’s AI behavior – this will involve creating some sort of communication between your hero character’s stealth abilities and the undead minion sensing system. </span><span class="koboSpan" id="kobo.5.2">Additionally, you will learn how to make your opponents communicate and cooperate with each other, in order to give your thief a </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">hard time.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">You will also implement a health system for the AI opponents, make your character attack, and impart some damage on them. </span><span class="koboSpan" id="kobo.7.2">Finally, you will create some variations for the minions in order to make them less predictable and </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">more engaging.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">By the end of this chapter, you will have improved your understanding of managing AI Actors in a multiplayer game. </span><span class="koboSpan" id="kobo.9.2">Additionally, you will have a strong understanding of how to ensure effective communication within a </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">networked environment.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, I will guide you through the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Making AI opponents </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">more challenging</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Implementing an </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">alert system</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Adding health to </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the AI</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Adding a weapon system to </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">a character</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">AI variations</span></span></li>
</ul>
<h1 id="_idParaDest-175"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">To follow the topics presented in this chapter, you should have completed the previous ones and understood </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">their content.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">.zip</span></strong><span class="koboSpan" id="kobo.28.1"> project files provided at this book’s companion project </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">repository: </span></span><a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">You can download the files that are up to date with the end of the last chapter by clicking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">Unreal Shadows – </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">Chapter 08</span></strong></span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">End</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.36.1"> link.</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.37.1">Making AI opponents more challenging</span></h1>
<p><span class="koboSpan" id="kobo.38.1">So far, your undead lackey is equipped with a (more or less) keen sense of vision, allowing it to peer into the abyss of the dungeon, scouting for unsuspecting prey. </span><span class="koboSpan" id="kobo.38.2">However, even the sneakiest of thieves can unexpectedly bump into a hindrance while tip-toeing through the shadows. </span><span class="koboSpan" id="kobo.38.3">The cunning Lichlord knows this all too well and has bestowed upon his minions the added gift of acute hearing, so not even a pin drop </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">goes unnoticed!</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">In this section, you will implement a noise system based on player character movement. </span><span class="koboSpan" id="kobo.40.2">The game logic you will be adding is based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">following requisites:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.42.1">The thief character will make a noise </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">when sprinting</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">The noise level will be based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">character statistics</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">The AI minions will react when they hear </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">a noise</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.48.1">So, open your IDE, as it’s time to add a new component feature to </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">your hero!</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.50.1">Making some noise</span></h2>
<p><span class="koboSpan" id="kobo.51.1">In order to let your thief character </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.52.1">make noise while it’s sprinting, you will add a new component – a </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">pawn noise emitter</span></strong><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">This component will not spawn an actual sound or noise, but it will emit a signal that can be intercepted by the pawn-sensing component you have attached to the </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">minion character.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">In order to declare this component, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">US_Character.h</span></strong><span class="koboSpan" id="kobo.58.1"> header file, and in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">private</span></strong><span class="koboSpan" id="kobo.60.1"> section, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.62.1">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Stealth", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;UPawnNoiseEmitterComponent&gt; NoiseEmitter;</span></pre>
<p><span class="koboSpan" id="kobo.63.1">Now that the component has been declared, it’s time to initialize it. </span><span class="koboSpan" id="kobo.63.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">US_Character.cpp</span></strong><span class="koboSpan" id="kobo.65.1"> file and add the necessary </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">include</span></strong><span class="koboSpan" id="kobo.67.1"> declaration at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.69.1">
#include "Components/PawnNoiseEmitterComponent.h"</span></pre>
<p><span class="koboSpan" id="kobo.70.1">Then, find the </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.71.1">constructor, and just after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">FollowCamera</span></strong><span class="koboSpan" id="kobo.73.1"> initialization, add these </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">two lines:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
NoiseEmitter = CreateDefaultSubobject&lt;UPawnNoiseEmitterComponent&gt;(TEXT("NoiseEmitter"));
NoiseEmitter-&gt;NoiseLifetime = 0.01f;</span></pre>
<p><span class="koboSpan" id="kobo.76.1">After the component creation, we just initialize its lifetime to a really low value (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">0.01</span></strong><span class="koboSpan" id="kobo.78.1">) – this value indicates the time that should pass before the new noise emission overwrites the previous one. </span><span class="koboSpan" id="kobo.78.2">As we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">Tick()</span></strong><span class="koboSpan" id="kobo.80.1"> event to emit the noise, and this event is executed every frame, we don’t need a </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">high value.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Now, look for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">Tick()</span></strong><span class="koboSpan" id="kobo.84.1"> function, and just before its closing bracket, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.86.1">
if (GetCharacterMovement()-&gt;MaxWalkSpeed == GetCharacterStats()-&gt;SprintSpeed)
{
 auto Noise = 1.f;
 if(GetCharacterStats() &amp;&amp; GetCharacterStats()-&gt;StealthMultiplier)
 {
  Noise = Noise / GetCharacterStats()-&gt;StealthMultiplier;
 }
 NoiseEmitter-&gt;MakeNoise(this, Noise, GetActorLocation());
}</span></pre>
<p><span class="koboSpan" id="kobo.87.1">In the previous code, we verify whether the character is sprinting and proceed further only if the result is affirmative. </span><span class="koboSpan" id="kobo.87.2">We then compute the noise, based on a unity value divided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">StealthMultiplier</span></strong><span class="koboSpan" id="kobo.89.1"> character. </span><span class="koboSpan" id="kobo.89.2">As you will remember from </span><a href="B18203_06.xhtml#_idTextAnchor125"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.90.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.91.1">, </span><em class="italic"><span class="koboSpan" id="kobo.92.1">Replicating Properties </span></em><em class="italic"><span class="koboSpan" id="kobo.93.1">O</span></em><em class="italic"><span class="koboSpan" id="kobo.94.1">ver the Network</span></em><span class="koboSpan" id="kobo.95.1">, this value is declared inside the character statistics data table, and it grows as the character levels up. </span><span class="koboSpan" id="kobo.95.2">This means the higher the multiplier, the </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.96.1">lower the noise made by the character. </span><span class="koboSpan" id="kobo.96.2">After the noise has been evaluated, it is emitted by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">NoiseEmitter</span></strong><span class="koboSpan" id="kobo.98.1"> component by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">MakeNoise()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.100.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Now that our character has picked up the skill of making noise while sprinting, it’s time we equip our undead minions with some sharp-eared talents and set them </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">to action!</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.103.1">Enabling the hearing sense</span></h2>
<p><span class="koboSpan" id="kobo.104.1">The minion character already has the ability to hear noise through the pawn-sensing component, but at the </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.105.1">moment, this ability is not used. </span><span class="koboSpan" id="kobo.105.2">You’ll need to open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">US_Minion.h</span></strong><span class="koboSpan" id="kobo.107.1"> header file and add the following declaration to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">protected</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.109.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
UFUNCTION()
void OnHearNoise(APawn* PawnInstigator, const FVector&amp; Location, float Volume);</span></pre>
<p><span class="koboSpan" id="kobo.111.1">As you can see, this is a simple callback declaration that will be used to handle the hearing of </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">any noise.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">Next, add the following method declaration to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">public</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.115.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
UFUNCTION(BlueprintCallable, Category="Minion AI")
void GoToLocation(const FVector&amp; Location);</span></pre>
<p><span class="koboSpan" id="kobo.117.1">This is a simple utility function that we will use to send the minion to the origin of </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">the noise.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Now, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">US_Minion.cpp</span></strong><span class="koboSpan" id="kobo.121.1"> file and look for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">PostInitializeComponents()</span></strong><span class="koboSpan" id="kobo.123.1"> implementation. </span><span class="koboSpan" id="kobo.123.2">Just before the closing bracket, add the delegate binding for the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">hearing event:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
GetPawnSense()-&gt;OnHearNoise.AddDynamic(this, &amp;AUS_Minion::OnHearNoise);</span></pre>
<p><span class="koboSpan" id="kobo.126.1">Now, implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">OnHearNoise()</span></strong><span class="koboSpan" id="kobo.128.1"> function by adding the </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
void AUS_Minion::OnHearNoise(APawn* PawnInstigator, const FVector&amp; Location, float Volume)
{
 GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT("Noise detected!"));
 GoToLocation(Location);
 UAIBlueprintHelperLibrary::SimpleMoveToLocation(GetController(), PatrolLocation);
}</span></pre>
<p><span class="koboSpan" id="kobo.131.1">Once a noise has been detected, we send the minion to the location where it was generated. </span><span class="koboSpan" id="kobo.131.2">As </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.132.1">you can see, we don’t check whether the noise instigator is our thief character – the Lichlord has commanded his minions to meticulously investigate any and all audible disturbances, leaving no </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">corner unexplored!</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">Finally, add the implementation for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">GoToLocation()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.136.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
void AUS_Minion::GoToLocation(const FVector&amp; Location)
{
 PatrolLocation = Location;
 UAIBlueprintHelperLibrary::SimpleMoveToLocation(GetController(), PatrolLocation);
}</span></pre>
<p><span class="koboSpan" id="kobo.138.1">Here, we just set </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">PatrolLocation</span></strong><span class="koboSpan" id="kobo.140.1"> and send the minion there (it’s nothing fancy but extremely </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.141.1">useful, as you will see later in </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">the chapter).</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">The minion is now ready, so compile your project and start </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">some testing.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.145.1">Testing the hearing sense</span></h2>
<p><span class="koboSpan" id="kobo.146.1">To test the </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.147.1">brand-new hearing sense feature, start a game session and walk around the minions, paying attention to not enter their sight cone of vision. </span><span class="koboSpan" id="kobo.147.2">The minions won’t notice the character unless it starts sprinting. </span><span class="koboSpan" id="kobo.147.3">At that moment, you should get a debug message, and the minion will start chasing the thief. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.148.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.149.1">.1</span></em><span class="koboSpan" id="kobo.150.1"> shows a scenario where the character has carelessly run behind a couple of skeleton minions and has subsequently been detected by their </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">hearing sense.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer128">
<span class="koboSpan" id="kobo.152.1"><img alt="Figure 9.1 – The character has been detected" src="image/Figure_09_01_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.153.1">Figure 9.1 – The character has been detected</span></p>
<p><span class="koboSpan" id="kobo.154.1">In this section, you added a new sense to the minion characters; this will make the game more tactical for the players – running around the dungeon like there’s no tomorrow won’t be an </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">optionable solution!</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">In the upcoming section, you shall pave the way for a messaging system that enables even the humblest </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.157.1">minion to unleash a call to arms upon discovering fresh prey. </span><span class="koboSpan" id="kobo.157.2">Oh, you thought heroism was all smooth sailing, did you? </span><span class="koboSpan" id="kobo.157.3">Ah, how fallible the human mind can be (smirks </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">the Lichlord).</span></span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.159.1">Implementing an alert system</span></h1>
<p><span class="koboSpan" id="kobo.160.1">In this section, you will work on a system that allows an AI character to alert its fellow minions once it </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.161.1">detects a player character. </span><span class="koboSpan" id="kobo.161.2">At first glance, you might assume that the code logic to alert nearby AI opponents could be implemented directly inside the minion class – it’s just a matter of sending them a message, isn’t it? </span><span class="koboSpan" id="kobo.161.3">But there’s more to it than meets the eye, dear reader. </span><span class="koboSpan" id="kobo.161.4">It seems the Lichlord has bigger aspirations for communication than you had anticipated. </span><span class="koboSpan" id="kobo.161.5">Fear not, for he has dictated that you make use of a Gameplay Framework class that has lurked unnoticed in the shadows until this moment – the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">Game Mode.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">As you will remember from </span><a href="B18203_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.164.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.165.1">, </span><em class="italic"><span class="koboSpan" id="kobo.166.1">Setting Up Your First Multiplayer Environment</span></em><span class="koboSpan" id="kobo.167.1">, a </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">Game Mode</span></strong><span class="koboSpan" id="kobo.169.1"> is a class that </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.170.1">manages a game’s rules and settings – this includes tasks such as communicating with AI Actors in the level. </span><span class="koboSpan" id="kobo.170.2">Alerting them of a new intruder in the dungeon is definitely a feature we want to have in </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">this class.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.172.1">Declaring the Game Mode functions</span></h2>
<p><span class="koboSpan" id="kobo.173.1">As usual, you will </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.174.1">start by declaring the needed functions inside the class header – in this case, you will need just one, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">AlertMinions()</span></strong><span class="koboSpan" id="kobo.176.1">. </span><span class="koboSpan" id="kobo.176.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">US_GameMode.h</span></strong><span class="koboSpan" id="kobo.178.1"> header file and declare it in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">public</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.180.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
UFUNCTION(BlueprintCallable, Category = "Minions")
void AlertMinions(class AActor* AlertInstigator, const FVector&amp; Location, float Radius);</span></pre>
<p><span class="koboSpan" id="kobo.182.1">Although this function may appear pretty simple, it will provide valuable information such as which minion has detected something, the position where to investigate, and the distance at which fellow minions should </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">be alerted.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">Now, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">US_GameMode.cpp</span></strong><span class="koboSpan" id="kobo.186.1"> file and add the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">include</span></strong><span class="koboSpan" id="kobo.188.1"> declarations at the very top of </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
#include "US_Minion.h"
#include "Kismet/GameplayStatics.h"</span></pre>
<p><span class="koboSpan" id="kobo.191.1">As you already know, those declarations are needed to properly implement the code you will write in </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.192.1">the class. </span><span class="koboSpan" id="kobo.192.2">Once you have added those lines, you can add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">method implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
void AUS_GameMode::AlertMinions(AActor* AlertInstigator, const FVector&amp; Location, const float Radius)
{
 TArray&lt;AActor*&gt; Minions;
 UGameplayStatics::GetAllActorsOfClass(GetWorld(), AUS_Minion::StaticClass(), Minions);
 for (const auto Minion : Minions)
 {
  if(AlertInstigator == Minion) continue;
  if (const auto Distance = FVector::Distance(AlertInstigator -&gt;GetActorLocation(), Minion-&gt;GetActorLocation()); Distance &lt; Radius)
  {
   if (const auto MinionCharacter = Cast&lt;AUS_Minion&gt;(Minion))
   {
    MinionCharacter-&gt;GoToLocation(Location);
   }
  }
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.195.1">The code looks for all the classes that extend </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">AUS_Minion</span></strong><span class="koboSpan" id="kobo.197.1"> in the level through </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">GetActorsOfClass()</span></strong><span class="koboSpan" id="kobo.199.1"> and stores them in an array. </span><span class="koboSpan" id="kobo.199.2">After that, it loops through this array, computing the distance between each minion and the alerting one. </span><span class="koboSpan" id="kobo.199.3">If the distance is within range (i.e., the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">Radius</span></strong><span class="koboSpan" id="kobo.201.1"> property), the AI will be commanded to go to that location and investigate through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">GoToLocation()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">The alert behavior for </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.205.1">the Game Mode has been implemented; this means it’s now possible for minions to call for assistance whenever they detect </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">an intruder.</span></span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.207.1">Making the AI send alert messages</span></h2>
<p><span class="koboSpan" id="kobo.208.1">Sending messages from the AI character is a pretty straightforward task, as the Game Mode is reachable </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.209.1">from any Actor in the game as long as it’s on the server – as you may already know, this is an awesome feature provided by the Unreal Engine Gameplay Framework. </span><span class="koboSpan" id="kobo.209.2">So, let’s open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">US_Minion.h</span></strong><span class="koboSpan" id="kobo.211.1"> file and declare the alert radius for the soon-to-be-sent messages in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">private</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.213.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.214.1">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Minion AI", meta = (AllowPrivateAccess = "true"))
float AlertRadius = 6000.0f;</span></pre>
<p><span class="koboSpan" id="kobo.215.1">Using a configurable radius range will come in handy to create different types of minions – do you want a super-alert, ear-piercing sentinel? </span><span class="koboSpan" id="kobo.215.2">Set it to a very high value! </span><span class="koboSpan" id="kobo.215.3">Or go for a slimy, self-serving AI that’s just in it for the Lichlord’s favors and undead promotions by setting it to zero – this way, none of the fellow minions will be alerted and the sentinel will (hopefully) be granted a pat on the head by its lord upon reaching the player character. </span><span class="koboSpan" id="kobo.215.4">The choice </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">is yours!</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">To implement the function, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">US_Minion.cpp</span></strong><span class="koboSpan" id="kobo.219.1"> file and add the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">include</span></strong><span class="koboSpan" id="kobo.221.1"> at the very beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
#include "US_GameMode.h"</span></pre>
<p><span class="koboSpan" id="kobo.224.1">Then, locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">Chase()</span></strong><span class="koboSpan" id="kobo.226.1"> method. </span><span class="koboSpan" id="kobo.226.2">Before its closing bracket, add </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
if(const auto GameMode = Cast&lt;AUS_GameMode&gt;(GetWorld()-&gt;GetAuthGameMode()))
{
 GameMode-&gt;AlertMinions(this, Pawn-&gt;GetActorLocation(), AlertRadius);
}</span></pre>
<p><span class="koboSpan" id="kobo.229.1">As you can see, </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.230.1">once the Game Mode has been retrieved, we just send the alert message with the opportune parameters. </span><span class="koboSpan" id="kobo.230.2">It’s now time to compile the project and do </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">some testing.</span></span></p>
<h3><span class="koboSpan" id="kobo.232.1">Testing the alert implementation</span></h3>
<p><span class="koboSpan" id="kobo.233.1">Start a new game session, and once the number of minions is good enough, let your character be </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.234.1">detected by one of them. </span><span class="koboSpan" id="kobo.234.2">Once alerted, all nearby minions will begin investigating the area, posing a serious danger to the player as more and more AI characters spot them, leading to a potentially dangerous </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">chain reaction.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.236.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.237.1">.2</span></em><span class="koboSpan" id="kobo.238.1"> shows one such situation – the player has not been stealthy enough, and AI opponents have started detecting the character while alerting </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">each other.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer129">
<span class="koboSpan" id="kobo.240.1"><img alt="Figure 9.2 – The alert system in action" src="image/Figure_09_02_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.241.1">Figure 9.2 – The alert system in action</span></p>
<p><span class="koboSpan" id="kobo.242.1">In this section, you implemented a messaging system for your AI opponents and learned the power of having </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.243.1">a centralized place to manage your </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">gameplay logic.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">In the next section, you will use the Gameplay Framework damage system to let players defeat enemies. </span><span class="koboSpan" id="kobo.245.2">Did you really believe I’d allow the poor thief hero to rot in the Lichlord’s grasp without any aid? </span><span class="koboSpan" id="kobo.245.3">Well, think again, my </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">dear reader!</span></span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.247.1">Adding health to the AI</span></h1>
<p><span class="koboSpan" id="kobo.248.1">In this part of the </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.249.1">project, you will add a health system to </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.250.1">the minion AI to make it possible to defeat it during gameplay. </span><span class="koboSpan" id="kobo.250.2">You will also add a spawn system so that when the opponent is defeated, the player will be rewarded with a </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">well-deserved prize.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">To implement such features, we need to open the minion class and start doing some coding – open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">US_Minion.h</span></strong><span class="koboSpan" id="kobo.254.1"> header, and in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">private</span></strong><span class="koboSpan" id="kobo.256.1"> section, add these </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">two declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.258.1">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Health", meta = (AllowPrivateAccess = "true"))
float Health = 5.f;
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Pickup", meta = (AllowPrivateAccess = "true"))
TSubclassOf&lt;class AUS_BasePickup&gt; SpawnedPickup;</span></pre>
<p><span class="koboSpan" id="kobo.259.1">The first one is used to keep track of the enemy health, while the second one will contain the class of </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.260.1">the item pickup that will be spawned once </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.261.1">the minion is defeated. </span><span class="koboSpan" id="kobo.261.2">Both of them can be modified in a child Blueprint Class (thanks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">EditDefaultsOnly</span></strong><span class="koboSpan" id="kobo.263.1"> property specifier), so you can build your own variations of </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">the minion.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Now, locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">protected</span></strong><span class="koboSpan" id="kobo.267.1"> section and add the damage </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">handler declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.269.1">
UFUNCTION()
void OnDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser);</span></pre>
<p><span class="koboSpan" id="kobo.270.1">The header is now complete, so it’s time to open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">US_Minion.cpp</span></strong><span class="koboSpan" id="kobo.272.1"> file and implement the health system. </span><span class="koboSpan" id="kobo.272.2">As usual, start by adding the needed </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">include</span></strong><span class="koboSpan" id="kobo.274.1"> declarations at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.276.1">
#include "US_BasePickup.h"</span></pre>
<p><span class="koboSpan" id="kobo.277.1">Next, declare the base pickup that will be spawned when the character is defeated; you’ll use the pickup coin you created in </span><a href="B18203_06.xhtml#_idTextAnchor125"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.278.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.279.1">, </span><em class="italic"><span class="koboSpan" id="kobo.280.1">Replicating Properties </span></em><em class="italic"><span class="koboSpan" id="kobo.281.1">O</span></em><em class="italic"><span class="koboSpan" id="kobo.282.1">ver the Network</span></em><span class="koboSpan" id="kobo.283.1">. </span><span class="koboSpan" id="kobo.283.2">Locate the constructor, and just before the closing bracket, add </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
static ConstructorHelpers::FClassFinder&lt;AUS_BasePickup&gt; SpawnedPickupAsset(TEXT("/Game/Blueprints/BP_GoldCoinPickup"));
if (SpawnedPickupAsset.Succeeded())
{
 SpawnedPickup = SpawnedPickupAsset.Class;
}</span></pre>
<p><span class="koboSpan" id="kobo.286.1">This code logic should be familiar, as we get a Blueprint asset from the project library and assign it the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">SpawnedPickup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.288.1"> reference.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">Then, we need to implement the damage handler logic. </span><span class="koboSpan" id="kobo.289.2">Locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">PostInitializeComponents()</span></strong><span class="koboSpan" id="kobo.291.1"> method and add this line </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.293.1">
OnTakeAnyDamage.AddDynamic(this, &amp;AUS_Minion::OnDamage);</span></pre>
<p><span class="koboSpan" id="kobo.294.1">Here, we just </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.295.1">bind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">OnDamage</span></strong><span class="koboSpan" id="kobo.297.1"> handler to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">OnTakeAnyDamage</span></strong><span class="koboSpan" id="kobo.299.1"> delegate. </span><span class="koboSpan" id="kobo.299.2">As a </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.300.1">last step, we need to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">OnDamage()</span></strong><span class="koboSpan" id="kobo.302.1"> method, so add this code to </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">your class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
void AUS_Minion::OnDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy,
 AActor* DamageCauser)
{
 Health -= Damage;
 if(Health &gt; 0) return;
 if(SpawnedPickup)
 {
  GetWorld()-&gt;SpawnActor&lt;AUS_BasePickup&gt;(SpawnedPickup, GetActorLocation(), GetActorRotation());
 }
 Destroy();
}</span></pre>
<p><span class="koboSpan" id="kobo.305.1">What this function does is to subtract the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">Damage</span></strong><span class="koboSpan" id="kobo.307.1"> value from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">Health</span></strong><span class="koboSpan" id="kobo.309.1"> property; if the minion reaches zero health, it will immediately spawn the prize (i.e., the pickup) and then it will </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">destroy itself.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">In this section, you created a simple health system for the AI opponent, by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">Health</span></strong><span class="koboSpan" id="kobo.313.1"> property and keeping track of its value as damage is taken – whenever the minion has been defeated, it will spawn a coin or a similar prize, ready to be picked up by the nearest (or </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">swiftest) character!</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">Unfortunately for your players, the hapless band of thieving heroes is, at the moment, ill equipped to </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.316.1">dispatch the Lichlord’s minions in the </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.317.1">treacherous underground realm! </span><span class="koboSpan" id="kobo.317.2">Fear not, for we shall come to their aid by adding a splendid weapon inventory to their arsenal in the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">next section.</span></span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.319.1">Adding a weapon system to the character</span></h1>
<p><span class="koboSpan" id="kobo.320.1">Your beloved character has been longing for a weapon system ever since you started implementing it. </span><span class="koboSpan" id="kobo.320.2">In this </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.321.1">section, we shall finally grant its wishes and provide it the ability to wield (not-so) powerful tools of destruction. </span><span class="koboSpan" id="kobo.321.2">Let’s make our character stronger and more formidable by arming it with an </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">amazing weapon!</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Since our character hero is a sneaky thief who prefers to avoid direct combat with stronger and more heavily armored opponents, we will focus on a throwing </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">dagger system.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">In order to avoid adding cluttered code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">US_Character</span></strong><span class="koboSpan" id="kobo.327.1"> class, you’ll implement a brand-new component that will handle the weapon logic – this means that you’ll work on the </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">following features:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.329.1">A component that will be added to the character and handle the player input and dagger </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">spawn logic</span></span></li>
<li><span class="koboSpan" id="kobo.331.1">A dagger weapon that will be thrown at runtime and cause damage to the </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">enemy opponents</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.333.1">As a first step, we will create the weapon projectile that will be spawned by the character when attacking </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">during gameplay.</span></span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.335.1">Creating a dagger projectile</span></h2>
<p><span class="koboSpan" id="kobo.336.1">The first thing to do is </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.337.1">create a projectile class that will serve as a throwable dagger. </span><span class="koboSpan" id="kobo.337.2">To do so, in the Unreal Editor, create a new C++ class that will extend </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Actor</span></strong><span class="koboSpan" id="kobo.339.1">, and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">US_BaseWeaponProjectile</span></strong><span class="koboSpan" id="kobo.341.1">. </span><span class="koboSpan" id="kobo.341.2">Once it has been created, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">US_BaseWeaponProjectile.h</span></strong><span class="koboSpan" id="kobo.343.1"> file, and in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">private</span></strong><span class="koboSpan" id="kobo.345.1"> section, add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">component declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Components", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class USphereComponent&gt; SphereCollision;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Components", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;UStaticMeshComponent&gt; Mesh;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UProjectileMovementComponent&gt; ProjectileMovement;</span></pre>
<p><span class="koboSpan" id="kobo.348.1">As you can see, we will add a collision area to check hits during gameplay, a static mesh for the dagger model, and projectile logic to make the dagger move once it has </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">been thrown.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">Remaining in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">private</span></strong><span class="koboSpan" id="kobo.352.1"> section, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">Damage</span></strong><span class="koboSpan" id="kobo.354.1"> property with a base value </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.358.1">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Weapon", meta = (AllowPrivateAccess = "true"))
float Damage = 1.f;</span></pre>
<p><span class="koboSpan" id="kobo.359.1">Then, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">public</span></strong><span class="koboSpan" id="kobo.361.1"> section, add the usual getter methods for </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">the components:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.363.1">
FORCEINLINE USphereComponent* GetSphereCollision() const { return SphereCollision; }
FORCEINLINE UStaticMeshComponent* GetMesh() const { return Mesh; }
FORCEINLINE UProjectileMovementComponent* GetProjectileMovement() const { return ProjectileMovement; }</span></pre>
<p><span class="koboSpan" id="kobo.364.1">Finally, we need to add a handler for when the weapon makes contact with its target. </span><span class="koboSpan" id="kobo.364.2">Add the following </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.365.1">code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">protected</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.367.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
UFUNCTION()
void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse,
 const FHitResult&amp; Hit);</span></pre>
<p><span class="koboSpan" id="kobo.369.1">The header is ready, so we need to implement the logic – open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">US_BaseWeaponProjectile.cpp</span></strong><span class="koboSpan" id="kobo.371.1"> file and add the necessary </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">include</span></strong><span class="koboSpan" id="kobo.373.1"> declarations at </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">its top:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
#include "US_Character.h"
#include "US_CharacterStats.h"
#include "Components/SphereComponent.h"
#include "Engine/DamageEvents.h"
#include "GameFramework/ProjectileMovementComponent.h"</span></pre>
<p><span class="koboSpan" id="kobo.376.1">Then, locate the constructor and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
SphereCollision = CreateDefaultSubobject&lt;USphereComponent&gt;("Collision");
SphereCollision-&gt;SetGenerateOverlapEvents(true);
SphereCollision-&gt;SetSphereRadius(10.0f);
SphereCollision-&gt;BodyInstance.SetCollisionProfileName("BlockAll");
SphereCollision-&gt;OnComponentHit.AddDynamic(this, &amp;AUS_BaseWeaponProjectile::OnHit);
RootComponent = SphereCollision;
Mesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("Mesh");
Mesh-&gt;SetupAttachment(RootComponent);
Mesh-&gt;SetCollisionEnabled(ECollisionEnabled::PhysicsOnly);
Mesh-&gt;SetRelativeLocation(FVector(-40.f, 0.f, 0.f));
Mesh-&gt;SetRelativeRotation(FRotator(-90.f, 0.f, 0.f));
static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; StaticMesh(TEXT("/Game/KayKit/DungeonElements/dagger_common"));
if (StaticMesh.Succeeded())
{
 GetMesh()-&gt;SetStaticMesh(StaticMesh.Object);
}
ProjectileMovement = CreateDefaultSubobject&lt;UProjectileMovement Component&gt;("ProjectileMovement");
ProjectileMovement-&gt;UpdatedComponent = SphereCollision;
ProjectileMovement-&gt;ProjectileGravityScale = 0;
ProjectileMovement-&gt;InitialSpeed = 3000;
ProjectileMovement-&gt;MaxSpeed = 3000;
ProjectileMovement-&gt;bRotationFollowsVelocity = true;
ProjectileMovement-&gt;bShouldBounce = false;
bReplicates = true;</span></pre>
<p><span class="koboSpan" id="kobo.379.1">This code logic is lengthy but straightforward to comprehend – we just create and initialize the </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">necessary components:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">SphereCollision</span></strong><span class="koboSpan" id="kobo.382.1"> has some basic values you should be </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">familiar with:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Mesh</span></strong><span class="koboSpan" id="kobo.385.1"> is set to a dagger model and rotated and positioned in order to align with the </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">overall </span></span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">Actor</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">ProjectileMovement</span></strong><span class="koboSpan" id="kobo.389.1"> has gravity disabled and a speed that will move the Actor fast and simulate a </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">real dagger</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.391.1">One thing to </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.392.1">mention is that we bind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">OnHit()</span></strong><span class="koboSpan" id="kobo.394.1"> method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">OnComponentHit</span></strong><span class="koboSpan" id="kobo.396.1"> delegate through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">AddDynamic</span></strong><span class="koboSpan" id="kobo.398.1"> helper macro. </span><span class="koboSpan" id="kobo.398.2">Also, note the final line of code that activates replication for the weapon – always keep in mind that Actors are not replicated </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">by default!</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">Now, add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">OnHit()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1"> implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.403.1">
void AUS_BaseWeaponProjectile::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor,
 UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult&amp; Hit)
{
 auto ComputedDamage = Damage;
 if (const auto Character = Cast&lt;AUS_Character&gt;(GetInstigator()))
 {
  ComputedDamage *= Character-&gt;GetCharacterStats()-&gt;DamageMultiplier;
 }
 if (OtherActor &amp;&amp; OtherActor != this)
 {
  const FDamageEvent Event(UDamageType::StaticClass());
  OtherActor-&gt;TakeDamage(ComputedDamage, Event, GetInstigatorController(), this);
 }
 Destroy();
}</span></pre>
<p><span class="koboSpan" id="kobo.404.1">The code can be divided into three </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">main parts:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.406.1">In the first part, we compute the damage, starting from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">Damage</span></strong><span class="koboSpan" id="kobo.408.1"> base value. </span><span class="koboSpan" id="kobo.408.2">If the instigator (i.e., the character that spawned the projectile) is </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">US_Character</span></strong><span class="koboSpan" id="kobo.410.1">, we get its damage multiplier from the statistics and update the provoked damage. </span><span class="koboSpan" id="kobo.410.2">This means the higher the level of the character, the higher </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">the damage.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.412.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.413.1">For a refresher on how character statistics are managed, please take a look back at </span><a href="B18203_06.xhtml#_idTextAnchor125"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.414.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.415.1">, </span><em class="italic"><span class="koboSpan" id="kobo.416.1">Replicating Properties </span></em><em class="italic"><span class="koboSpan" id="kobo.417.1">O</span></em><em class="italic"><span class="koboSpan" id="kobo.418.1">ver </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.419.1">the Network</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.421.1">The second part of the code verifies whether the launched projectile has hit an Actor. </span><span class="koboSpan" id="kobo.421.2">If it has, it will then inflict the corresponding amount </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">of damage.</span></span></li>
<li><span class="koboSpan" id="kobo.423.1">The last and final </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.424.1">part simply destroys the projectile – its mission is finished, and this means it should be removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">the game.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.426.1">With the projectile all set up and ready to go, it’s time to implement some spawn logic so that your thief hero can unleash the full power of this shiny </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">new weapon.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.428.1">Implementing the weapon component</span></h2>
<p><span class="koboSpan" id="kobo.429.1">Let’s start by creating a class that will add new features to the character. </span><span class="koboSpan" id="kobo.429.2">As you may remember from </span><a href="B18203_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.430.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.431.1">, </span><em class="italic"><span class="koboSpan" id="kobo.432.1">Setting Up Your First Multiplayer Environment</span></em><span class="koboSpan" id="kobo.433.1">, a component will let you implement </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.434.1">reusable functionality and can be attached to any Actor or another component. </span><span class="koboSpan" id="kobo.434.2">In this case, we will implement a weapon system, with a </span><strong class="bold"><span class="koboSpan" id="kobo.435.1">Scene Component</span></strong><span class="koboSpan" id="kobo.436.1">, which has the ability to be placed somewhere </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.437.1">inside the parent Actor (i.e., the component has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Transform</span></strong><span class="koboSpan" id="kobo.439.1"> property) – this will allow you to position the component somewhere inside the character and act as a spawn point for the </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">thrown projectiles.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Let’s start by creating the class. </span><span class="koboSpan" id="kobo.441.2">To do so, create a new class that extends from a Scene component and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">US_WeaponProjectileComponent</span></strong><span class="koboSpan" id="kobo.443.1">. </span><span class="koboSpan" id="kobo.443.2">Once the creation process has finished, open </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">US_WeaponProjectileComponent.h</span></strong><span class="koboSpan" id="kobo.445.1">, and in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">private</span></strong><span class="koboSpan" id="kobo.447.1"> section, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">following declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.449.1">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Projectile", meta = (AllowPrivateAccess = "true"))
TSubclassOf&lt;class AUS_BaseWeaponProjectile&gt; ProjectileClass;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input", meta=(AllowPrivateAccess = "true"))
class UInputMappingContext* WeaponMappingContext;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input", meta=(AllowPrivateAccess = "true"))
class UInputAction* ThrowAction;</span></pre>
<p><span class="koboSpan" id="kobo.450.1">As you can see, we declare the projectile class (i.e., the projectile we previously created, or a subclass of it). </span><span class="koboSpan" id="kobo.450.2">Then, we declare the necessary elements that will let us take advantage of the enhanced input system. </span><span class="koboSpan" id="kobo.450.3">As we don’t want to add dependencies to the main character, we will use a different mapping context from the one used in </span><a href="B18203_05.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.451.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.452.1">, </span><em class="italic"><span class="koboSpan" id="kobo.453.1">Managing Actors in a Multiplayer Environment</span></em><span class="koboSpan" id="kobo.454.1"> – this will let us implement a flexible combat system and add as many features as we want, without adding clutter to the main character class. </span><span class="koboSpan" id="kobo.454.2">Imagine the thrill of watching your sneaky thief hero slipping through the shadows, quietly backstabbing the most despised minions of the dreaded Lichlord! </span><span class="koboSpan" id="kobo.454.3">The possibilities for mayhem and mischief will </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">be endless!</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">Okay, let’s stop dreaming and get back to coding. </span><span class="koboSpan" id="kobo.456.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">public</span></strong><span class="koboSpan" id="kobo.458.1"> section, add a setter for the projectile class that will allow you to change the spawned </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">dagger projectile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
UFUNCTION(BlueprintCallable, Category = "Projectile")
void SetProjectileClass(TSubclassOf&lt;class AUS_BaseWeaponProjectile&gt; NewProjectileClass);</span></pre>
<p><span class="koboSpan" id="kobo.461.1">This function has </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.462.1">nothing to do with throwing things around, but it will be most useful if you plan to add a weapon pickup to your game, in order to improve your character’s </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">fighting skills.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">Lastly, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">protected</span></strong><span class="koboSpan" id="kobo.466.1"> section, declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">Throw()</span></strong><span class="koboSpan" id="kobo.468.1"> action and its corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">server call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
void Throw();
UFUNCTION(Server, Reliable)
void Throw_Server();</span></pre>
<p><span class="koboSpan" id="kobo.471.1">This code will let us spawn the thrown daggers during gameplay from the server – always remember that the server should be in command when generating </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">replicated </span></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">Actors</span></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">Now that the header file is finished, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">US_WeaponProjectileComponent.cpp</span></strong><span class="koboSpan" id="kobo.477.1"> file to start implementing its features. </span><span class="koboSpan" id="kobo.477.2">As usual, locate the top of the file, and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">include</span></strong><span class="koboSpan" id="kobo.479.1"> declarations for the classes we </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">will use:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.481.1">
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"
#include "US_BaseWeaponProjectile.h"
#include "US_Character.h"</span></pre>
<p><span class="koboSpan" id="kobo.482.1">Then, in the constructor, add this single line </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">
ProjectileClass = AUS_BaseWeaponProjectile::StaticClass();</span></pre>
<p><span class="koboSpan" id="kobo.485.1">Here, we just declare the base projectile that will be spawned when the throw action is triggered; you </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.486.1">will obviously be able to change it in the derived Blueprint Classes if you need a </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">different weapon.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">Now, locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">BeginPlay()</span></strong><span class="koboSpan" id="kobo.490.1"> method, and just after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">Super::BeginPlay()</span></strong><span class="koboSpan" id="kobo.492.1"> declaration, add </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
const ACharacter* Character = Cast&lt;ACharacter&gt;(GetOwner());
if(!Character) return;
if (const APlayerController* PlayerController = Cast&lt;APlayerController&gt;(Character-&gt;GetController()))
{
 if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;(PlayerController-&gt;GetLocalPlayer()))
 {
  Subsystem-&gt;AddMappingContext(WeaponMappingContext, 1);
 }
 if (UEnhancedInputComponent* EnhancedInputComponent = Cast&lt;UEnhancedInputComponent&gt;(PlayerController-&gt;InputComponent))
 {
  EnhancedInputComponent-&gt;BindAction(ThrowAction, ETriggerEvent::Triggered, this, &amp;UUS_WeaponProjectileComponent::Throw);
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.495.1">In the previous code, we check that the component owner is our </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">US_Character</span></strong><span class="koboSpan" id="kobo.497.1"> class, in order to get its controller and initialize the mapping context and its actions. </span><span class="koboSpan" id="kobo.497.2">Note that this initialization is done inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">BeginPlay()</span></strong><span class="koboSpan" id="kobo.499.1"> function, which means that these steps will be done just once – that is, when the game is started – to be sure that there is an Actor owner and a </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">corresponding controller.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">Now, implement the </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.502.1">throw logic by adding the following </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">method implementations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.504.1">
void UUS_WeaponProjectileComponent::Throw()
{
 Throw_Server();
}
void UUS_WeaponProjectileComponent:: Throw_Server_Implementation()
{
 if (ProjectileClass)
 {
  const auto Character = Cast&lt;AUS_Character&gt;(GetOwner());
  const auto ProjectileSpawnLocation = GetComponentLocation();
  const auto ProjectileSpawnRotation = GetComponentRotation();
  auto ProjectileSpawnParams = FActorSpawnParameters();
  ProjectileSpawnParams.Owner = GetOwner();
  ProjectileSpawnParams.Instigator = Character;
  GetWorld()-&gt;SpawnActor&lt;AUS_BaseWeaponProjectile&gt;(ProjectileClass, ProjectileSpawnLocation, ProjectileSpawnRotation, ProjectileSpawnParams);
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.505.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">Throw()</span></strong><span class="koboSpan" id="kobo.507.1"> method simply calls the server-side implementation that will spawn the projectile from the component location. </span><span class="koboSpan" id="kobo.507.2">You are already familiar with the spawn action (do you remember the minion spawner?), but there is an important thing to notice this time – we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">FActorSpawnParameters</span></strong><span class="koboSpan" id="kobo.509.1"> structure to set the owner of the projectile and, most importantly, the instigator (i.e., the Actor that spawned the object). </span><span class="koboSpan" id="kobo.509.2">This property is used by the projectile to retrieve the character statistics and handle the damage multiplier, code logic we implemented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">previous section.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">Lastly, add the setter </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.512.1">method that will let you change the weapon spawned by </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">the character:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
void UUS_WeaponProjectileComponent::SetProjectileClass(TSubclassOf&lt;AUS_BaseWeaponProjectile&gt; NewProjectileClass)
{
 ProjectileClass = NewProjectileClass;
}</span></pre>
<p><span class="koboSpan" id="kobo.515.1">The component has now been properly set – you just need to attach an instance of it to the thief character to make it </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">fully operational.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.517.1">Attaching the WeaponProjectile component to the character</span></h2>
<p><span class="koboSpan" id="kobo.518.1">Now that you have </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.519.1">created a weapon component, it’s time to add it to the character. </span><span class="koboSpan" id="kobo.519.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">US_Character.h</span></strong><span class="koboSpan" id="kobo.521.1"> header file, and in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">private</span></strong><span class="koboSpan" id="kobo.523.1"> section, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">component declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.525.1">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Weapon", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UUS_WeaponProjectileComponent&gt; Weapon;</span></pre>
<p><span class="koboSpan" id="kobo.526.1">And, as usual, add the corresponding getter utility method to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">public</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.528.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.529.1">
FORCEINLINE UUS_WeaponProjectileComponent* GetWeapon() const { return Weapon; }</span></pre>
<p><span class="koboSpan" id="kobo.530.1">Then, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">US_Character.cpp</span></strong><span class="koboSpan" id="kobo.532.1"> source file and include the component class declaration at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
#include "US_WeaponProjectileComponent.h"</span></pre>
<p><span class="koboSpan" id="kobo.535.1">Now, locate the constructor, and just after the noise emitter creation and initialization, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.537.1">
Weapon = CreateDefaultSubobject&lt;UUS_WeaponProjectileComponent&gt;(TEXT("Weapon"));
Weapon-&gt;SetupAttachment(RootComponent);
Weapon-&gt;SetRelativeLocation(FVector(120.f, 70.f, 0.f));</span></pre>
<p><span class="koboSpan" id="kobo.538.1">As you can see, after we create the component, we attach it to the root component of the character and position it at a relative location, set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">(120, 70, 0)</span></strong><span class="koboSpan" id="kobo.540.1">. </span><span class="koboSpan" id="kobo.540.2">If you want your character to be left-handed, you can just use a negative value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">X</span></strong><span class="koboSpan" id="kobo.542.1"> coordinate (</span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">i.e., </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">-120.f</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">As hard as it may be to believe, the code to attach the weapon component to the character is </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.547.1">complete; the code logic is already handled in the component itself, so you can sit back, relax, and let everything fall into place like a </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">well-oiled machine!</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">You can now switch back to the Unreal Editor and compile your project – once finished, you can open the </span><strong class="bold"><span class="koboSpan" id="kobo.550.1">BP_Character</span></strong><span class="koboSpan" id="kobo.551.1"> Blueprint, and you will see that the character is now equipped with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">WeaponProjectile</span></strong><span class="koboSpan" id="kobo.553.1"> component, with </span><strong class="bold"><span class="koboSpan" id="kobo.554.1">Projectile Class</span></strong><span class="koboSpan" id="kobo.555.1"> set to a default value, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.556.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.557.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer130">
<span class="koboSpan" id="kobo.559.1"><img alt="Figure 9.3 – The WeaponProjectile component attached to the character Actor" src="image/Figure_09_03_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.560.1">Figure 9.3 – The WeaponProjectile component attached to the character Actor</span></p>
<p><span class="koboSpan" id="kobo.561.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">WeaponProjectile</span></strong><span class="koboSpan" id="kobo.563.1"> component attached to the character, the last thing to do is to create a </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.564.1">mapping context for the player input and an input action for the </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">throw logic.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.566.1">Adding an input system for the weapon</span></h2>
<p><span class="koboSpan" id="kobo.567.1">In the final part </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.568.1">of this section, you will define the mapping context </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.569.1">and the input action for the throw interaction. </span><span class="koboSpan" id="kobo.569.2">This is something you are already familiar with, as you previously created similar assets in </span><a href="B18203_05.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.570.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.571.1">, </span><em class="italic"><span class="koboSpan" id="kobo.572.1">Managing Actors in a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.573.1">Multiplayer Environment</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">So, without further ado, let’s open the Content Browser and navigate to the </span><strong class="bold"><span class="koboSpan" id="kobo.576.1">Content</span></strong><span class="koboSpan" id="kobo.577.1"> |</span><strong class="bold"><span class="koboSpan" id="kobo.578.1"> Input</span></strong><span class="koboSpan" id="kobo.579.1"> folder. </span><span class="koboSpan" id="kobo.579.2">We will create the throw action asset in the </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">following steps.</span></span></p>
<h3><span class="koboSpan" id="kobo.581.1">Setting up the input mapping context for the throw interaction</span></h3>
<p><span class="koboSpan" id="kobo.582.1">To create the action </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.583.1">asset for the throw interaction, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.585.1">Right-click in the Content Browser and select </span><strong class="bold"><span class="koboSpan" id="kobo.586.1">Input</span></strong><span class="koboSpan" id="kobo.587.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.588.1">Input Action</span></strong><span class="koboSpan" id="kobo.589.1">, naming the newly created </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">asset </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">IA_Throw</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.593.1">Double-click on the asset to open it, and from the </span><strong class="bold"><span class="koboSpan" id="kobo.594.1">Value Type</span></strong><span class="koboSpan" id="kobo.595.1"> dropdown, select </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.596.1">Digital (bool)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.598.1">Double-check that the </span><strong class="bold"><span class="koboSpan" id="kobo.599.1">Consume Input</span></strong><span class="koboSpan" id="kobo.600.1"> checkbox </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">is ticked.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.602.1">The final result for the throw action asset is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.603.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.604.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<span class="koboSpan" id="kobo.606.1"><img alt="Figure 9.4 – The throw action settings" src="image/Figure_09_04_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.607.1">Figure 9.4 – The throw action settings</span></p>
<p><span class="koboSpan" id="kobo.608.1">Now that the action </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.609.1">has been set, let’s create a mapping context for the </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">weapon interactions.</span></span></p>
<h3><span class="koboSpan" id="kobo.611.1">Setting up the input mapping context for the weapon interactions</span></h3>
<p><span class="koboSpan" id="kobo.612.1">To create the </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.613.1">weapon context mapping, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.615.1">Right-click in the Content Browser and select </span><strong class="bold"><span class="koboSpan" id="kobo.616.1">Input</span></strong><span class="koboSpan" id="kobo.617.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.618.1">Input Mapping Context</span></strong><span class="koboSpan" id="kobo.619.1">, naming the asset </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">IMC_Weapons</span></strong><span class="koboSpan" id="kobo.621.1">. </span><span class="koboSpan" id="kobo.621.2">Double-click on the asset to </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">open it.</span></span></li>
<li><span class="koboSpan" id="kobo.623.1">Add a new mapping context by clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.624.1">+</span></strong><span class="koboSpan" id="kobo.625.1"> icon next to the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.626.1">Mappings</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1"> field.</span></span></li>
<li><span class="koboSpan" id="kobo.628.1">From the drop-down menu that will be added, select </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">IA_Throw</span></strong><span class="koboSpan" id="kobo.630.1"> to add this action to the </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">mapping context.</span></span></li>
<li><span class="koboSpan" id="kobo.632.1">Click twice on the </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">+</span></strong><span class="koboSpan" id="kobo.634.1"> icon next to the drop-down menu to add two other control bindings for this action (one is set by default). </span><span class="koboSpan" id="kobo.634.2">In the drop-down menu next to each new field, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">following properties:</span></span><ul><li><span class="koboSpan" id="kobo.636.1">The first </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.637.1">binding should be set to </span><strong class="bold"><span class="koboSpan" id="kobo.638.1">Left Ctrl</span></strong><span class="koboSpan" id="kobo.639.1"> from the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.640.1">Keyboard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.641.1"> category</span></span></li><li><span class="koboSpan" id="kobo.642.1">The second binding should be set to </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">Gamepad Face Button Right</span></strong><span class="koboSpan" id="kobo.644.1"> from the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.645.1">Gamepad</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.646.1"> category</span></span></li><li><span class="koboSpan" id="kobo.647.1">The third binding should be set to </span><strong class="bold"><span class="koboSpan" id="kobo.648.1">Left Mouse Button</span></strong><span class="koboSpan" id="kobo.649.1"> from the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.650.1">Mouse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.651.1"> category</span></span></li></ul></li>
</ol>
<p><span class="koboSpan" id="kobo.652.1">The final result for the weapon mapping context should be like the one depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.653.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.654.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<span class="koboSpan" id="kobo.656.1"><img alt="Figure 9.5 – The weapon mapping context settings" src="image/Figure_09_05_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.657.1">Figure 9.5 – The weapon mapping context settings</span></p>
<p><span class="koboSpan" id="kobo.658.1">Now that the assets are ready, it’s time to add them to </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">the character:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.660.1">Open the </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">BP_Character</span></strong><span class="koboSpan" id="kobo.662.1"> Blueprint, select the </span><strong class="bold"><span class="koboSpan" id="kobo.663.1">Weapon</span></strong><span class="koboSpan" id="kobo.664.1"> component, and in the </span><strong class="bold"><span class="koboSpan" id="kobo.665.1">Details</span></strong><span class="koboSpan" id="kobo.666.1"> panel, locate the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.667.1">Input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.668.1"> category.</span></span></li>
<li><span class="koboSpan" id="kobo.669.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.670.1">Weapon Mapping Context</span></strong><span class="koboSpan" id="kobo.671.1"> field, assign the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.672.1">IMC_Weapons</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.673.1"> asset.</span></span></li>
<li><span class="koboSpan" id="kobo.674.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.675.1">Throw Action</span></strong><span class="koboSpan" id="kobo.676.1"> field, assign the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.677.1">IA_Throw</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.678.1"> asset.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.679.1">Once you have set </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.680.1">these properties, your </span><strong class="bold"><span class="koboSpan" id="kobo.681.1">Input</span></strong><span class="koboSpan" id="kobo.682.1"> category should look like the one depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.683.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.684.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer133">
<span class="koboSpan" id="kobo.686.1"><img alt="Figure 9.6 – The updated Input category" src="image/Figure_09_06_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.687.1">Figure 9.6 – The updated Input category</span></p>
<p><span class="koboSpan" id="kobo.688.1">Now that the input </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.689.1">settings have been properly updated, it’s time to do some testing to check that everything </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">works properly.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.691.1">Testing the weapon system</span></h2>
<p><span class="koboSpan" id="kobo.692.1">It’s time to show the Lichlord’s minions who the boss is and wreak some havoc in their underground lairs! </span><span class="koboSpan" id="kobo.692.2">Let’s give them a taste of our hero’s targeting skills by starting a </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">game session.</span></span></p>
<p><span class="koboSpan" id="kobo.694.1">During gameplay, your </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.695.1">character should be able to spawn a dagger whenever using the throw action – for example, by clicking the left mouse button. </span><span class="koboSpan" id="kobo.695.2">The dagger should destroy itself whenever it hits something and provoke damage to the </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">AI minions.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">Whenever a minion reaches zero health, it should be removed from the game, and a coin should spawn in the level. </span><span class="koboSpan" id="kobo.697.2">Collecting enough coins will make your character level up, and consequently, the character itself will provoke additional damage when hitting </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">any enemy.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.699.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.700.1">.7</span></em><span class="koboSpan" id="kobo.701.1"> shows the character throwing some daggers </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">during gameplay:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer134">
<span class="koboSpan" id="kobo.703.1"><img alt="Figure 9.7 – The dagger attack in action" src="image/Figure_09_07_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.704.1">Figure 9.7 – The dagger attack in action</span></p>
<p><span class="koboSpan" id="kobo.705.1">In this section, you implemented a weapon system through a new component that is attached to your character</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.706.1"> and a projectile Actor that can be spawned in the game and properly replicated through </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">the network.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">In the upcoming section, you will introduce some diverse variations of the AI opponents, with the aim of enhancing the game’s variety and </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">overall enjoyability.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.710.1">Creating AI variations</span></h1>
<p><span class="koboSpan" id="kobo.711.1">Now that we’ve got the AI opponents all set up and ready to go for some epic battles, let’s add some </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.712.1">more variations to AI minions and make things more interesting and engaging. </span><span class="koboSpan" id="kobo.712.2">If a project has been well planned, changing the behavior of an AI – even a basic one such as the one we created in this chapter – is usually just a matter of adjusting </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">some settings!</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">In this section, you’ll create a new AI opponent, starting from the basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">US_Minion</span></strong><span class="koboSpan" id="kobo.716.1"> class, and you will tweak its property in order to give it </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">different behavior.</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.718.1">Creating an AI sentinel</span></h2>
<p><span class="koboSpan" id="kobo.719.1">While watching mindless minions wander around a dungeon cluelessly may cause a chuckle </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.720.1">or two, it is certainly not enough for the Lichlord’s devious plans. </span><span class="koboSpan" id="kobo.720.2">He wants to be sure that each and every corner of his realm is safe and well guarded. </span><span class="koboSpan" id="kobo.720.3">This means you will craft some undead sentinels that will have keen senses and be </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">more territorial.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">Let’s start by creating a Blueprint Class, inheriting from the basic minion. </span><span class="koboSpan" id="kobo.722.2">Open the Content Browser and complete the </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.724.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">Blueprints</span></strong><span class="koboSpan" id="kobo.726.1"> folder, right-click and select </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.727.1">Blueprint Class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.729.1">From the window that pops up, select </span><strong class="bold"><span class="koboSpan" id="kobo.730.1">US_Minion</span></strong><span class="koboSpan" id="kobo.731.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.732.1">All </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.733.1">Classes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.734.1"> section.</span></span></li>
<li><span class="koboSpan" id="kobo.735.1">Name the newly created Blueprint </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">BP_MinionSentinel</span></strong><span class="koboSpan" id="kobo.737.1">, and then double-click on it to </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">open it.</span></span></li>
<li><span class="koboSpan" id="kobo.739.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.740.1">Details</span></strong><span class="koboSpan" id="kobo.741.1"> panel, locate the </span><strong class="bold"><span class="koboSpan" id="kobo.742.1">Minion AI</span></strong><span class="koboSpan" id="kobo.743.1"> category and apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">following settings:</span></span><ul><li><span class="koboSpan" id="kobo.745.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.746.1">Alert Radius</span></strong><span class="koboSpan" id="kobo.747.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">6000,0</span></strong></span></li><li><span class="koboSpan" id="kobo.750.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.751.1">Patrol Speed</span></strong><span class="koboSpan" id="kobo.752.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">60,0</span></strong></span></li><li><span class="koboSpan" id="kobo.755.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.756.1">Chase Speed</span></strong><span class="koboSpan" id="kobo.757.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">20,0</span></strong></span></li><li><span class="koboSpan" id="kobo.760.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.761.1">Patrol Radius</span></strong><span class="koboSpan" id="kobo.762.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">1000,0</span></strong></span></li><li><span class="koboSpan" id="kobo.765.1">The final settings for this category are shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.766.1">Figure 9.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">:</span></span></li></ul></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer135">
<span class="koboSpan" id="kobo.768.1"><img alt="Figure 9.8 – The sentinel Minion AI settings" src="image/Figure_09_08_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.769.1">Figure 9.8 – The sentinel Minion AI settings</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.770.1">Then, in </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.771.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.772.1">AI</span></strong><span class="koboSpan" id="kobo.773.1"> section, apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">following settings:</span></span><ul><li><span class="koboSpan" id="kobo.775.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.776.1">Hearing Threshold</span></strong><span class="koboSpan" id="kobo.777.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">600,0</span></strong></span></li><li><span class="koboSpan" id="kobo.780.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">LOSHearing Threshold</span></strong><span class="koboSpan" id="kobo.782.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">1000,0</span></strong></span></li><li><span class="koboSpan" id="kobo.785.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.786.1">Sight Radius</span></strong><span class="koboSpan" id="kobo.787.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">2500,0</span></strong></span></li><li><span class="koboSpan" id="kobo.790.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.791.1">Peripheral Vision Angle</span></strong><span class="koboSpan" id="kobo.792.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">60,0</span></strong></span></li></ul></li>
</ol>
<p><span class="koboSpan" id="kobo.795.1">The final settings for this category are shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.796.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.797.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer136">
<span class="koboSpan" id="kobo.799.1"><img alt="Figure 9.9 – The sentinel AI settings" src="image/Figure_09_09_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.800.1">Figure 9.9 – The sentinel AI settings</span></p>
<p><span class="koboSpan" id="kobo.801.1">With these settings, you will create a minion that will patrol an approximately small area, changing direction frequently and moving very slowly. </span><span class="koboSpan" id="kobo.801.2">Its senses will be keen, and its </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.802.1">alert radius will be larger than a regular minion. </span><span class="koboSpan" id="kobo.802.2">When an intruder has been spotted, the sentinel will slow down, calling for help, letting its more aggressive counterparts handle the chase. </span><span class="koboSpan" id="kobo.802.3">It’s not one for combat, but it’s still on the lookout for any </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">suspicious activity!</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.804.1">As a final touch, you can add a couple of glowing eyes for this darkness-gazing undead character by changing </span><strong class="bold"><span class="koboSpan" id="kobo.805.1">Element 5</span></strong><span class="koboSpan" id="kobo.806.1"> in the mesh </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">Materials</span></strong><span class="koboSpan" id="kobo.808.1"> list to the </span><strong class="bold"><span class="koboSpan" id="kobo.809.1">M_Base_Emissive</span></strong><span class="koboSpan" id="kobo.810.1"> material asset, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.811.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.812.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer137">
<span class="koboSpan" id="kobo.814.1"><img alt="Figure 9.10 – The Materials settings" src="image/Figure_09_10_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.815.1">Figure 9.10 – The Materials settings</span></p>
<p><span class="koboSpan" id="kobo.816.1">The final result of </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.817.1">the sentinel (with some dramatic lightning add-ons) can be seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.818.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.819.1">.11</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<span class="koboSpan" id="kobo.821.1"><img alt="Figure 9.11 – The sentinel added to the scene" src="image/Figure_09_11_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.822.1">Figure 9.11 – The sentinel added to the scene</span></p>
<p><span class="koboSpan" id="kobo.823.1">As you can see, you </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.824.1">have created a new AI with just a couple of tweaks to the </span><strong class="bold"><span class="koboSpan" id="kobo.825.1">Details</span></strong><span class="koboSpan" id="kobo.826.1"> panel. </span><span class="koboSpan" id="kobo.826.2">Let’s create another one, a more aggressive </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">undead minion.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.828.1">Creating an AI miniboss</span></h2>
<p><span class="koboSpan" id="kobo.829.1">You can actually </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.830.1">use the same process that worked in the previous subsection to create a new AI that will deal with hero intruders in a totally different way. </span><span class="koboSpan" id="kobo.830.2">It’s like getting creative with a recipe and making something new and unexpected but still (</span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">dangerously) delicious!</span></span></p>
<p><span class="koboSpan" id="kobo.832.1">Open the Content Browser and complete the </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.834.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">Blueprints</span></strong><span class="koboSpan" id="kobo.836.1"> folder, right-click and select </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.837.1">Blueprint Class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.839.1">From the window that pops up, select </span><strong class="bold"><span class="koboSpan" id="kobo.840.1">US_Minion</span></strong><span class="koboSpan" id="kobo.841.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.842.1">All </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.843.1">Classes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.844.1"> section.</span></span></li>
<li><span class="koboSpan" id="kobo.845.1">Name the newly created Blueprint </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">BP_MinionMiniboss</span></strong><span class="koboSpan" id="kobo.847.1">, and then double-click on it to </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">open it.</span></span></li>
<li><span class="koboSpan" id="kobo.849.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.850.1">Details</span></strong><span class="koboSpan" id="kobo.851.1"> panel, locate the </span><strong class="bold"><span class="koboSpan" id="kobo.852.1">Minion AI</span></strong><span class="koboSpan" id="kobo.853.1"> category and apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">following settings:</span></span><ul><li><span class="koboSpan" id="kobo.855.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.856.1">Alert Radius</span></strong><span class="koboSpan" id="kobo.857.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">100,0</span></strong></span></li><li><span class="koboSpan" id="kobo.860.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.861.1">Patrol Speed</span></strong><span class="koboSpan" id="kobo.862.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">100,0</span></strong></span></li><li><span class="koboSpan" id="kobo.865.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">Chase Speed</span></strong><span class="koboSpan" id="kobo.867.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">400,0</span></strong></span></li><li><span class="koboSpan" id="kobo.870.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.871.1">Patrol Radius</span></strong><span class="koboSpan" id="kobo.872.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">50000,0</span></strong></span></li><li><span class="koboSpan" id="kobo.875.1">The final settings for this category are shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.876.1">Figure 9.12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">:</span></span></li></ul></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer139">
<span class="koboSpan" id="kobo.878.1"><img alt="Figure 9.12 – The miniboss Minion AI settings" src="image/Figure_09_12_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.879.1">Figure 9.12 – The miniboss Minion AI settings</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.880.1">Then, in </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.881.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.882.1">AI</span></strong><span class="koboSpan" id="kobo.883.1"> section, apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">following settings:</span></span><ul><li><span class="koboSpan" id="kobo.885.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.886.1">Hearing Threshold</span></strong><span class="koboSpan" id="kobo.887.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">200,0</span></strong></span></li><li><span class="koboSpan" id="kobo.890.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.891.1">LOSHearing Threshold</span></strong><span class="koboSpan" id="kobo.892.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">400,0</span></strong></span></li><li><span class="koboSpan" id="kobo.895.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.896.1">Sight Radius</span></strong><span class="koboSpan" id="kobo.897.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">200,0</span></strong></span></li><li><span class="koboSpan" id="kobo.900.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.901.1">Peripheral Vision Angle</span></strong><span class="koboSpan" id="kobo.902.1"> to a value </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">20,0</span></strong></span></li></ul></li>
</ol>
<p><span class="koboSpan" id="kobo.905.1">The final settings for this category are shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.906.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.907.1">.13</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer140">
<span class="koboSpan" id="kobo.909.1"><img alt="Figure 9.13 – The miniboss AI settings" src="image/Figure_09_13_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.910.1">Figure 9.13 – The miniboss AI settings</span></p>
<p><span class="koboSpan" id="kobo.911.1">This AI opponent has been set to a really dull behavior while patrolling (low perception, slower movement, etc.), but it will become dangerously fast </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">once alerted.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">Also, the miniboss started </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.914.1">to look a bit dull, so the Lichlord has decided to give it a literal armor makeover. </span><span class="koboSpan" id="kobo.914.2">To do this, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.916.1">Select the </span><strong class="bold"><span class="koboSpan" id="kobo.917.1">Mesh</span></strong><span class="koboSpan" id="kobo.918.1"> component and change the </span><strong class="bold"><span class="koboSpan" id="kobo.919.1">Skeletal Mesh Asset</span></strong><span class="koboSpan" id="kobo.920.1"> property to the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.921.1">skeleton_warrior</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.922.1"> asset.</span></span></li>
<li><span class="koboSpan" id="kobo.923.1">Change the </span><strong class="bold"><span class="koboSpan" id="kobo.924.1">Mesh</span></strong><span class="koboSpan" id="kobo.925.1"> scale to a value of </span><strong class="bold"><span class="koboSpan" id="kobo.926.1">1.2</span></strong><span class="koboSpan" id="kobo.927.1"> to make </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">it bigger.</span></span></li>
<li><span class="koboSpan" id="kobo.929.1">Set the </span><strong class="bold"><span class="koboSpan" id="kobo.930.1">Health</span></strong><span class="koboSpan" id="kobo.931.1"> property to a value of </span><strong class="bold"><span class="koboSpan" id="kobo.932.1">20</span></strong><span class="koboSpan" id="kobo.933.1"> to make it </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">more damage-resistant.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.935.1">This foe is about to go from “meh” to menacing, and hero intruders better watch out! </span><span class="koboSpan" id="kobo.935.2">The final result of the miniboss, compared with a base minion, is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.936.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.937.1">.14</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer141">
<span class="koboSpan" id="kobo.939.1"><img alt="Figure 9.14 – The miniboss minion" src="image/Figure_09_14_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.940.1">Figure 9.14 – The miniboss minion</span></p>
<p><span class="koboSpan" id="kobo.941.1">The beauty of it all is that you can get really creative with your enemy opponents and test out all sorts of different behaviors and tactics. </span><span class="koboSpan" id="kobo.941.2">And if something just isn’t working for you, no worries! </span><span class="koboSpan" id="kobo.941.3">Just delete it and start afresh with something new in just a few </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">short minutes.</span></span></p>
<p><span class="koboSpan" id="kobo.943.1">As an additional nice touch to the AI, why not use the pickup spawn system we added earlier in this chapter t</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.944.1">o spice up the game? </span><span class="koboSpan" id="kobo.944.2">Depending on how rare or dangerous the defeated minion is, you could have it spawn different types </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">of coins!</span></span></p>
<p><span class="koboSpan" id="kobo.946.1">Once you have your undead army ready to go, you can get back to your enemy spawner and add the Blueprints to the system – something we will do in the </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">next subsection.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.948.1">Updating the minion spawner</span></h2>
<p><span class="koboSpan" id="kobo.949.1">As you may have </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.950.1">guessed, adding your brand-new minion varieties is just a matter of putting their Blueprints inside a spawner. </span><span class="koboSpan" id="kobo.950.2">To do so, select the spawner you previously added to the level, and in the </span><strong class="bold"><span class="koboSpan" id="kobo.951.1">Details</span></strong><span class="koboSpan" id="kobo.952.1"> panel, locate the </span><strong class="bold"><span class="koboSpan" id="kobo.953.1">Spawnable Minions</span></strong><span class="koboSpan" id="kobo.954.1"> array property in the </span><strong class="bold"><span class="koboSpan" id="kobo.955.1">Spawn System</span></strong><span class="koboSpan" id="kobo.956.1"> category – there should already be one item in the </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">list, </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.958.1">US_Minion</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.960.1">Add as many items as you wish, selecting the spawnable minions you need for that particular spawn area. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.961.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.962.1">.15</span></em><span class="koboSpan" id="kobo.963.1"> shows my setup for the main spawner area in </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">the level:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer142">
<span class="koboSpan" id="kobo.965.1"><img alt="Figure 9.15 – The spawn area setup" src="image/Figure_09_15_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.966.1">Figure 9.15 – The spawn area setup</span></p>
<p><span class="koboSpan" id="kobo.967.1">As you can see, I chose to work with five elements, allocating a 20% chance for each to be added to the </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.968.1">level every time the </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">Spawn()</span></strong><span class="koboSpan" id="kobo.970.1"> method is called. </span><span class="koboSpan" id="kobo.970.2">Since the basic minion utilizes three of these elements, there is a 60% chance that it will appear as an opponent, compared to the sentinel and miniboss, which only have a 20% probability </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">of spawning.</span></span></p>
<p><span class="koboSpan" id="kobo.972.1">Once you are happy with your setup, you can test the game. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.973.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.974.1">.16</span></em><span class="koboSpan" id="kobo.975.1"> shows my spawner in action at the start of </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">the game:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer143">
<span class="koboSpan" id="kobo.977.1"><img alt="Figure 9.16 – The spawner at the start of the game" src="image/Figure_09_16_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.978.1">Figure 9.16 – The spawner at the start of the game</span></p>
<p><span class="koboSpan" id="kobo.979.1">In this final section, you </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.980.1">created some variations for the base minions; by changing some of their base properties, you changed the way they behave during gameplay, making your level more engaging </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">and diverse.</span></span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.982.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.983.1">In this chapter, you actively worked to improve the behavior of your enemy AIs within the level. </span><span class="koboSpan" id="kobo.983.2">The focus was on developing new features that make the gaming experience even more engaging and challenging for players. </span><span class="koboSpan" id="kobo.983.3">You actually improved the Lichlord’s minions’ sense of hearing to make them even more alert and perceptive when it comes to spotting those poor </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">thieving heroes.</span></span></p>
<p><span class="koboSpan" id="kobo.985.1">On the flip side, you also implemented a health system for the minions and added some pretty sharp (literally!) tools to the player’s arsenal that they can use to take down those nasty foes! </span><span class="koboSpan" id="kobo.985.2">Finally, you created some enemy variations to make the dungeon less boring and more engaging for </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">the player.</span></span></p>
<p><span class="koboSpan" id="kobo.987.1">As you can see from what you have built here, if you plan ahead, improving gameplay can be a walk in the park! </span><span class="koboSpan" id="kobo.987.2">By taking the time to carefully map out your strategies and implement the right features, you can make gameplay engaging and immersive for players while also achieving your </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">desired results.</span></span></p>
<p><span class="koboSpan" id="kobo.989.1">In the next chapter, we will improve the overall look and feel of the game by adding animations and prisoners to rescue. </span><span class="koboSpan" id="kobo.989.2">Additionally, I will provide you with some tips on how to take your game to the next level, but let’s be clear – I’m not going to code it all for you! </span><span class="koboSpan" id="kobo.989.3">I believe in your ability to create something amazing, and I can’t wait to see what you come </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">up with!</span></span></p>
</div>
</body></html>