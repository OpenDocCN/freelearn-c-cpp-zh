<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor174"/>9</h1>
<h1 id="_idParaDest-174"><a id="_idTextAnchor175"/>Extending AI Behaviors</h1>
<p>Enhancing an enemy character’s behavior in a multiplayer game is a great way of making it more challenging and exciting for players. It can also help create a more immersive experience, as enemies become smarter, faster, and stronger. By introducing new abilities or changing existing ones, you can make your game stand out from other similar titles on the market.</p>
<p>In this chapter, you will learn how to add improvements to your minion’s AI behavior – this will involve creating some sort of communication between your hero character’s stealth abilities and the undead minion sensing system. Additionally, you will learn how to make your opponents communicate and cooperate with each other, in order to give your thief a hard time.</p>
<p>You will also implement a health system for the AI opponents, make your character attack, and impart some damage on them. Finally, you will create some variations for the minions in order to make them less predictable and more engaging.</p>
<p>By the end of this chapter, you will have improved your understanding of managing AI Actors in a multiplayer game. Additionally, you will have a strong understanding of how to ensure effective communication within a networked environment.</p>
<p>In this chapter, I will guide you through the following sections:</p>
<ul>
<li>Making AI opponents more challenging</li>
<li>Implementing an alert system</li>
<li>Adding health to the AI</li>
<li>Adding a weapon system to a character</li>
<li>Creating AI variations</li>
</ul>
<h1 id="_idParaDest-175"><a id="_idTextAnchor176"/>Technical requirements</h1>
<p>To follow the topics presented in this chapter, you should have completed the previous ones and understood their content.</p>
<p>Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the <code>.zip</code> project files provided at this book’s companion project repository: <a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</a>.</p>
<p>You can download the files that are up to date with the end of the last chapter by clicking the <code>Unreal Shadows – </code><code>Chapter 08</code><code> </code><code>End</code> link.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor177"/>Making AI opponents more challenging</h1>
<p>So far, your undead lackey is equipped with a (more or less) keen sense of vision, allowing it to peer into the abyss of the dungeon, scouting for unsuspecting prey. However, even the sneakiest of thieves can unexpectedly bump into a hindrance while tip-toeing through the shadows. The cunning Lichlord knows this all too well and has bestowed upon his minions the added gift of acute hearing, so not even a pin drop goes unnoticed!</p>
<p>In this section, you will implement a noise system based on player character movement. The game logic you will be adding is based on the following requisites:</p>
<ul>
<li>The thief character will make a noise when sprinting</li>
<li>The noise level will be based on the character statistics</li>
<li>The AI minions will react when they hear a noise</li>
</ul>
<p>So, open your IDE, as it’s time to add a new component feature to your hero!</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>Making some noise</h2>
<p>In order to let your thief character <a id="_idIndexMarker484"/>make noise while it’s sprinting, you will add a new component – a <strong class="bold">pawn noise emitter</strong>. This component will not spawn an actual sound or noise, but it will emit a signal that can be intercepted by the pawn-sensing component you have attached to the minion character.</p>
<p>In order to declare this component, open the <code>US_Character.h</code> header file, and in the <code>private</code> section, add the following code:</p>
<pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Stealth", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;UPawnNoiseEmitterComponent&gt; NoiseEmitter;</pre>
<p>Now that the component has been declared, it’s time to initialize it. Open the <code>US_Character.cpp</code> file and add the necessary <code>include</code> declaration at the top of the file:</p>
<pre class="source-code">
#include "Components/PawnNoiseEmitterComponent.h"</pre>
<p>Then, find the <a id="_idIndexMarker485"/>constructor, and just after the <code>FollowCamera</code> initialization, add these two lines:</p>
<pre class="source-code">
NoiseEmitter = CreateDefaultSubobject&lt;UPawnNoiseEmitterComponent&gt;(TEXT("NoiseEmitter"));
NoiseEmitter-&gt;NoiseLifetime = 0.01f;</pre>
<p>After the component creation, we just initialize its lifetime to a really low value (i.e., <code>0.01</code>) – this value indicates the time that should pass before the new noise emission overwrites the previous one. As we use the <code>Tick()</code> event to emit the noise, and this event is executed every frame, we don’t need a high value.</p>
<p>Now, look for the <code>Tick()</code> function, and just before its closing bracket, add the following code:</p>
<pre class="source-code">
if (GetCharacterMovement()-&gt;MaxWalkSpeed == GetCharacterStats()-&gt;SprintSpeed)
{
 auto Noise = 1.f;
 if(GetCharacterStats() &amp;&amp; GetCharacterStats()-&gt;StealthMultiplier)
 {
  Noise = Noise / GetCharacterStats()-&gt;StealthMultiplier;
 }
 NoiseEmitter-&gt;MakeNoise(this, Noise, GetActorLocation());
}</pre>
<p>In the previous code, we verify whether the character is sprinting and proceed further only if the result is affirmative. We then compute the noise, based on a unity value divided by the <code>StealthMultiplier</code> character. As you will remember from <a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Replicating Properties </em><em class="italic">O</em><em class="italic">ver the Network</em>, this value is declared inside the character statistics data table, and it grows as the character levels up. This means the higher the multiplier, the <a id="_idIndexMarker486"/>lower the noise made by the character. After the noise has been evaluated, it is emitted by the <code>NoiseEmitter</code> component by using the <code>MakeNoise()</code> method.</p>
<p>Now that our character has picked up the skill of making noise while sprinting, it’s time we equip our undead minions with some sharp-eared talents and set them to action!</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>Enabling the hearing sense</h2>
<p>The minion character already has the ability to hear noise through the pawn-sensing component, but at the <a id="_idIndexMarker487"/>moment, this ability is not used. You’ll need to open the <code>US_Minion.h</code> header file and add the following declaration to the <code>protected</code> section:</p>
<pre class="source-code">
UFUNCTION()
void OnHearNoise(APawn* PawnInstigator, const FVector&amp; Location, float Volume);</pre>
<p>As you can see, this is a simple callback declaration that will be used to handle the hearing of any noise.</p>
<p>Next, add the following method declaration to the <code>public</code> section:</p>
<pre class="source-code">
UFUNCTION(BlueprintCallable, Category="Minion AI")
void GoToLocation(const FVector&amp; Location);</pre>
<p>This is a simple utility function that we will use to send the minion to the origin of the noise.</p>
<p>Now, open the <code>US_Minion.cpp</code> file and look for the <code>PostInitializeComponents()</code> implementation. Just before the closing bracket, add the delegate binding for the hearing event:</p>
<pre class="source-code">
GetPawnSense()-&gt;OnHearNoise.AddDynamic(this, &amp;AUS_Minion::OnHearNoise);</pre>
<p>Now, implement the <code>OnHearNoise()</code> function by adding the following code:</p>
<pre class="source-code">
void AUS_Minion::OnHearNoise(APawn* PawnInstigator, const FVector&amp; Location, float Volume)
{
 GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT("Noise detected!"));
 GoToLocation(Location);
 UAIBlueprintHelperLibrary::SimpleMoveToLocation(GetController(), PatrolLocation);
}</pre>
<p>Once a noise has been detected, we send the minion to the location where it was generated. As <a id="_idIndexMarker488"/>you can see, we don’t check whether the noise instigator is our thief character – the Lichlord has commanded his minions to meticulously investigate any and all audible disturbances, leaving no corner unexplored!</p>
<p>Finally, add the implementation for the <code>GoToLocation()</code> function:</p>
<pre class="source-code">
void AUS_Minion::GoToLocation(const FVector&amp; Location)
{
 PatrolLocation = Location;
 UAIBlueprintHelperLibrary::SimpleMoveToLocation(GetController(), PatrolLocation);
}</pre>
<p>Here, we just set <code>PatrolLocation</code> and send the minion there (it’s nothing fancy but extremely <a id="_idIndexMarker489"/>useful, as you will see later in the chapter).</p>
<p>The minion is now ready, so compile your project and start some testing.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/>Testing the hearing sense</h2>
<p>To test the <a id="_idIndexMarker490"/>brand-new hearing sense feature, start a game session and walk around the minions, paying attention to not enter their sight cone of vision. The minions won’t notice the character unless it starts sprinting. At that moment, you should get a debug message, and the minion will start chasing the thief. <em class="italic">Figure 9</em><em class="italic">.1</em> shows a scenario where the character has carelessly run behind a couple of skeleton minions and has subsequently been detected by their hearing sense.</p>
<div><div><img alt="Figure 9.1 – The character has been detected" src="img/Figure_09_01_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The character has been detected</p>
<p>In this section, you added a new sense to the minion characters; this will make the game more tactical for the players – running around the dungeon like there’s no tomorrow won’t be an optionable solution!</p>
<p>In the upcoming section, you shall pave the way for a messaging system that enables even the humblest <a id="_idIndexMarker491"/>minion to unleash a call to arms upon discovering fresh prey. Oh, you thought heroism was all smooth sailing, did you? Ah, how fallible the human mind can be (smirks the Lichlord).</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor181"/>Implementing an alert system</h1>
<p>In this section, you will work on a system that allows an AI character to alert its fellow minions once it <a id="_idIndexMarker492"/>detects a player character. At first glance, you might assume that the code logic to alert nearby AI opponents could be implemented directly inside the minion class – it’s just a matter of sending them a message, isn’t it? But there’s more to it than meets the eye, dear reader. It seems the Lichlord has bigger aspirations for communication than you had anticipated. Fear not, for he has dictated that you make use of a Gameplay Framework class that has lurked unnoticed in the shadows until this moment – the Game Mode.</p>
<p>As you will remember from <a href="B18203_04.xhtml#_idTextAnchor086"><em class="italic">Chapter 4</em></a>, <em class="italic">Setting Up Your First Multiplayer Environment</em>, a <strong class="bold">Game Mode</strong> is a class that <a id="_idIndexMarker493"/>manages a game’s rules and settings – this includes tasks such as communicating with AI Actors in the level. Alerting them of a new intruder in the dungeon is definitely a feature we want to have in this class.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor182"/>Declaring the Game Mode functions</h2>
<p>As usual, you will <a id="_idIndexMarker494"/>start by declaring the needed functions inside the class header – in this case, you will need just one, called <code>AlertMinions()</code>. Open the <code>US_GameMode.h</code> header file and declare it in the <code>public</code> section:</p>
<pre class="source-code">
UFUNCTION(BlueprintCallable, Category = "Minions")
void AlertMinions(class AActor* AlertInstigator, const FVector&amp; Location, float Radius);</pre>
<p>Although this function may appear pretty simple, it will provide valuable information such as which minion has detected something, the position where to investigate, and the distance at which fellow minions should be alerted.</p>
<p>Now, open the <code>US_GameMode.cpp</code> file and add the following <code>include</code> declarations at the very top of the code:</p>
<pre class="source-code">
#include "US_Minion.h"
#include "Kismet/GameplayStatics.h"</pre>
<p>As you already know, those declarations are needed to properly implement the code you will write in <a id="_idIndexMarker495"/>the class. Once you have added those lines, you can add the following method implementation:</p>
<pre class="source-code">
void AUS_GameMode::AlertMinions(AActor* AlertInstigator, const FVector&amp; Location, const float Radius)
{
 TArray&lt;AActor*&gt; Minions;
 UGameplayStatics::GetAllActorsOfClass(GetWorld(), AUS_Minion::StaticClass(), Minions);
 for (const auto Minion : Minions)
 {
  if(AlertInstigator == Minion) continue;
  if (const auto Distance = FVector::Distance(AlertInstigator -&gt;GetActorLocation(), Minion-&gt;GetActorLocation()); Distance &lt; Radius)
  {
   if (const auto MinionCharacter = Cast&lt;AUS_Minion&gt;(Minion))
   {
    MinionCharacter-&gt;GoToLocation(Location);
   }
  }
 }
}</pre>
<p>The code looks for all the classes that extend <code>AUS_Minion</code> in the level through <code>GetActorsOfClass()</code> and stores them in an array. After that, it loops through this array, computing the distance between each minion and the alerting one. If the distance is within range (i.e., the <code>Radius</code> property), the AI will be commanded to go to that location and investigate through the <code>GoToLocation()</code> function.</p>
<p>The alert behavior for <a id="_idIndexMarker496"/>the Game Mode has been implemented; this means it’s now possible for minions to call for assistance whenever they detect an intruder.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/>Making the AI send alert messages</h2>
<p>Sending messages from the AI character is a pretty straightforward task, as the Game Mode is reachable <a id="_idIndexMarker497"/>from any Actor in the game as long as it’s on the server – as you may already know, this is an awesome feature provided by the Unreal Engine Gameplay Framework. So, let’s open the <code>US_Minion.h</code> file and declare the alert radius for the soon-to-be-sent messages in the <code>private</code> section:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Minion AI", meta = (AllowPrivateAccess = "true"))
float AlertRadius = 6000.0f;</pre>
<p>Using a configurable radius range will come in handy to create different types of minions – do you want a super-alert, ear-piercing sentinel? Set it to a very high value! Or go for a slimy, self-serving AI that’s just in it for the Lichlord’s favors and undead promotions by setting it to zero – this way, none of the fellow minions will be alerted and the sentinel will (hopefully) be granted a pat on the head by its lord upon reaching the player character. The choice is yours!</p>
<p>To implement the function, open the <code>US_Minion.cpp</code> file and add the following <code>include</code> at the very beginning of the file:</p>
<pre class="source-code">
#include "US_GameMode.h"</pre>
<p>Then, locate the <code>Chase()</code> method. Before its closing bracket, add this code:</p>
<pre class="source-code">
if(const auto GameMode = Cast&lt;AUS_GameMode&gt;(GetWorld()-&gt;GetAuthGameMode()))
{
 GameMode-&gt;AlertMinions(this, Pawn-&gt;GetActorLocation(), AlertRadius);
}</pre>
<p>As you can see, <a id="_idIndexMarker498"/>once the Game Mode has been retrieved, we just send the alert message with the opportune parameters. It’s now time to compile the project and do some testing.</p>
<h3>Testing the alert implementation</h3>
<p>Start a new game session, and once the number of minions is good enough, let your character be <a id="_idIndexMarker499"/>detected by one of them. Once alerted, all nearby minions will begin investigating the area, posing a serious danger to the player as more and more AI characters spot them, leading to a potentially dangerous chain reaction.</p>
<p><em class="italic">Figure 9</em><em class="italic">.2</em> shows one such situation – the player has not been stealthy enough, and AI opponents have started detecting the character while alerting each other.</p>
<div><div><img alt="Figure 9.2 – The alert system in action" src="img/Figure_09_02_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The alert system in action</p>
<p>In this section, you implemented a messaging system for your AI opponents and learned the power of having <a id="_idIndexMarker500"/>a centralized place to manage your gameplay logic.</p>
<p>In the next section, you will use the Gameplay Framework damage system to let players defeat enemies. Did you really believe I’d allow the poor thief hero to rot in the Lichlord’s grasp without any aid? Well, think again, my dear reader!</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/>Adding health to the AI</h1>
<p>In this part of the <a id="_idIndexMarker501"/>project, you will add a health system to <a id="_idIndexMarker502"/>the minion AI to make it possible to defeat it during gameplay. You will also add a spawn system so that when the opponent is defeated, the player will be rewarded with a well-deserved prize.</p>
<p>To implement such features, we need to open the minion class and start doing some coding – open the <code>US_Minion.h</code> header, and in the <code>private</code> section, add these two declarations:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Health", meta = (AllowPrivateAccess = "true"))
float Health = 5.f;
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Pickup", meta = (AllowPrivateAccess = "true"))
TSubclassOf&lt;class AUS_BasePickup&gt; SpawnedPickup;</pre>
<p>The first one is used to keep track of the enemy health, while the second one will contain the class of <a id="_idIndexMarker503"/>the item pickup that will be spawned once <a id="_idIndexMarker504"/>the minion is defeated. Both of them can be modified in a child Blueprint Class (thanks to the <code>EditDefaultsOnly</code> property specifier), so you can build your own variations of the minion.</p>
<p>Now, locate the <code>protected</code> section and add the damage handler declaration:</p>
<pre class="source-code">
UFUNCTION()
void OnDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser);</pre>
<p>The header is now complete, so it’s time to open the <code>US_Minion.cpp</code> file and implement the health system. As usual, start by adding the needed <code>include</code> declarations at the top of the file:</p>
<pre class="source-code">
#include "US_BasePickup.h"</pre>
<p>Next, declare the base pickup that will be spawned when the character is defeated; you’ll use the pickup coin you created in <a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Replicating Properties </em><em class="italic">O</em><em class="italic">ver the Network</em>. Locate the constructor, and just before the closing bracket, add this code:</p>
<pre class="source-code">
static ConstructorHelpers::FClassFinder&lt;AUS_BasePickup&gt; SpawnedPickupAsset(TEXT("/Game/Blueprints/BP_GoldCoinPickup"));
if (SpawnedPickupAsset.Succeeded())
{
 SpawnedPickup = SpawnedPickupAsset.Class;
}</pre>
<p>This code logic should be familiar, as we get a Blueprint asset from the project library and assign it the <code>SpawnedPickup</code> reference.</p>
<p>Then, we need to implement the damage handler logic. Locate the <code>PostInitializeComponents()</code> method and add this line of code:</p>
<pre class="source-code">
OnTakeAnyDamage.AddDynamic(this, &amp;AUS_Minion::OnDamage);</pre>
<p>Here, we just <a id="_idIndexMarker505"/>bind the <code>OnDamage</code> handler to the <code>OnTakeAnyDamage</code> delegate. As a <a id="_idIndexMarker506"/>last step, we need to implement the <code>OnDamage()</code> method, so add this code to your class:</p>
<pre class="source-code">
void AUS_Minion::OnDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy,
 AActor* DamageCauser)
{
 Health -= Damage;
 if(Health &gt; 0) return;
 if(SpawnedPickup)
 {
  GetWorld()-&gt;SpawnActor&lt;AUS_BasePickup&gt;(SpawnedPickup, GetActorLocation(), GetActorRotation());
 }
 Destroy();
}</pre>
<p>What this function does is to subtract the <code>Damage</code> value from the <code>Health</code> property; if the minion reaches zero health, it will immediately spawn the prize (i.e., the pickup) and then it will destroy itself.</p>
<p>In this section, you created a simple health system for the AI opponent, by adding the <code>Health</code> property and keeping track of its value as damage is taken – whenever the minion has been defeated, it will spawn a coin or a similar prize, ready to be picked up by the nearest (or swiftest) character!</p>
<p>Unfortunately for your players, the hapless band of thieving heroes is, at the moment, ill equipped to <a id="_idIndexMarker507"/>dispatch the Lichlord’s minions in the <a id="_idIndexMarker508"/>treacherous underground realm! Fear not, for we shall come to their aid by adding a splendid weapon inventory to their arsenal in the next section.</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor185"/>Adding a weapon system to the character</h1>
<p>Your beloved character has been longing for a weapon system ever since you started implementing it. In this <a id="_idIndexMarker509"/>section, we shall finally grant its wishes and provide it the ability to wield (not-so) powerful tools of destruction. Let’s make our character stronger and more formidable by arming it with an amazing weapon!</p>
<p>Since our character hero is a sneaky thief who prefers to avoid direct combat with stronger and more heavily armored opponents, we will focus on a throwing dagger system.</p>
<p>In order to avoid adding cluttered code in the <code>US_Character</code> class, you’ll implement a brand-new component that will handle the weapon logic – this means that you’ll work on the following features:</p>
<ul>
<li>A component that will be added to the character and handle the player input and dagger spawn logic</li>
<li>A dagger weapon that will be thrown at runtime and cause damage to the enemy opponents</li>
</ul>
<p>As a first step, we will create the weapon projectile that will be spawned by the character when attacking during gameplay.</p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor186"/>Creating a dagger projectile</h2>
<p>The first thing to do is <a id="_idIndexMarker510"/>create a projectile class that will serve as a throwable dagger. To do so, in the Unreal Editor, create a new C++ class that will extend <code>Actor</code>, and call it <code>US_BaseWeaponProjectile</code>. Once it has been created, open the <code>US_BaseWeaponProjectile.h</code> file, and in the <code>private</code> section, add the following component declarations:</p>
<pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Components", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class USphereComponent&gt; SphereCollision;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Components", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;UStaticMeshComponent&gt; Mesh;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UProjectileMovementComponent&gt; ProjectileMovement;</pre>
<p>As you can see, we will add a collision area to check hits during gameplay, a static mesh for the dagger model, and projectile logic to make the dagger move once it has been thrown.</p>
<p>Remaining in the <code>private</code> section, add the <code>Damage</code> property with a base value of <code>1</code>:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Weapon", meta = (AllowPrivateAccess = "true"))
float Damage = 1.f;</pre>
<p>Then, in the <code>public</code> section, add the usual getter methods for the components:</p>
<pre class="source-code">
FORCEINLINE USphereComponent* GetSphereCollision() const { return SphereCollision; }
FORCEINLINE UStaticMeshComponent* GetMesh() const { return Mesh; }
FORCEINLINE UProjectileMovementComponent* GetProjectileMovement() const { return ProjectileMovement; }</pre>
<p>Finally, we need to add a handler for when the weapon makes contact with its target. Add the following <a id="_idIndexMarker511"/>code to the <code>protected</code> section:</p>
<pre class="source-code">
UFUNCTION()
void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse,
 const FHitResult&amp; Hit);</pre>
<p>The header is ready, so we need to implement the logic – open the <code>US_BaseWeaponProjectile.cpp</code> file and add the necessary <code>include</code> declarations at its top:</p>
<pre class="source-code">
#include "US_Character.h"
#include "US_CharacterStats.h"
#include "Components/SphereComponent.h"
#include "Engine/DamageEvents.h"
#include "GameFramework/ProjectileMovementComponent.h"</pre>
<p>Then, locate the constructor and add the following code:</p>
<pre class="source-code">
SphereCollision = CreateDefaultSubobject&lt;USphereComponent&gt;("Collision");
SphereCollision-&gt;SetGenerateOverlapEvents(true);
SphereCollision-&gt;SetSphereRadius(10.0f);
SphereCollision-&gt;BodyInstance.SetCollisionProfileName("BlockAll");
SphereCollision-&gt;OnComponentHit.AddDynamic(this, &amp;AUS_BaseWeaponProjectile::OnHit);
RootComponent = SphereCollision;
Mesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("Mesh");
Mesh-&gt;SetupAttachment(RootComponent);
Mesh-&gt;SetCollisionEnabled(ECollisionEnabled::PhysicsOnly);
Mesh-&gt;SetRelativeLocation(FVector(-40.f, 0.f, 0.f));
Mesh-&gt;SetRelativeRotation(FRotator(-90.f, 0.f, 0.f));
static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; StaticMesh(TEXT("/Game/KayKit/DungeonElements/dagger_common"));
if (StaticMesh.Succeeded())
{
 GetMesh()-&gt;SetStaticMesh(StaticMesh.Object);
}
ProjectileMovement = CreateDefaultSubobject&lt;UProjectileMovement Component&gt;("ProjectileMovement");
ProjectileMovement-&gt;UpdatedComponent = SphereCollision;
ProjectileMovement-&gt;ProjectileGravityScale = 0;
ProjectileMovement-&gt;InitialSpeed = 3000;
ProjectileMovement-&gt;MaxSpeed = 3000;
ProjectileMovement-&gt;bRotationFollowsVelocity = true;
ProjectileMovement-&gt;bShouldBounce = false;
bReplicates = true;</pre>
<p>This code logic is lengthy but straightforward to comprehend – we just create and initialize the necessary components:</p>
<p><code>SphereCollision</code> has some basic values you should be familiar with:</p>
<ul>
<li><code>Mesh</code> is set to a dagger model and rotated and positioned in order to align with the overall Actor</li>
<li><code>ProjectileMovement</code> has gravity disabled and a speed that will move the Actor fast and simulate a real dagger</li>
</ul>
<p>One thing to <a id="_idIndexMarker512"/>mention is that we bind the <code>OnHit()</code> method to the <code>OnComponentHit</code> delegate through the <code>AddDynamic</code> helper macro. Also, note the final line of code that activates replication for the weapon – always keep in mind that Actors are not replicated by default!</p>
<p>Now, add the <code>OnHit()</code> implementation:</p>
<pre class="source-code">
void AUS_BaseWeaponProjectile::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor,
 UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult&amp; Hit)
{
 auto ComputedDamage = Damage;
 if (const auto Character = Cast&lt;AUS_Character&gt;(GetInstigator()))
 {
  ComputedDamage *= Character-&gt;GetCharacterStats()-&gt;DamageMultiplier;
 }
 if (OtherActor &amp;&amp; OtherActor != this)
 {
  const FDamageEvent Event(UDamageType::StaticClass());
  OtherActor-&gt;TakeDamage(ComputedDamage, Event, GetInstigatorController(), this);
 }
 Destroy();
}</pre>
<p>The code can be divided into three main parts:</p>
<ul>
<li>In the first part, we compute the damage, starting from the <code>Damage</code> base value. If the instigator (i.e., the character that spawned the projectile) is <code>US_Character</code>, we get its damage multiplier from the statistics and update the provoked damage. This means the higher the level of the character, the higher the damage.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For a refresher on how character statistics are managed, please take a look back at <a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Replicating Properties </em><em class="italic">O</em><em class="italic">ver </em><em class="italic">the Network</em>.</p>
<ul>
<li>The second part of the code verifies whether the launched projectile has hit an Actor. If it has, it will then inflict the corresponding amount of damage.</li>
<li>The last and final <a id="_idIndexMarker513"/>part simply destroys the projectile – its mission is finished, and this means it should be removed from the game.</li>
</ul>
<p>With the projectile all set up and ready to go, it’s time to implement some spawn logic so that your thief hero can unleash the full power of this shiny new weapon.</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/>Implementing the weapon component</h2>
<p>Let’s start by creating a class that will add new features to the character. As you may remember from <a href="B18203_04.xhtml#_idTextAnchor086"><em class="italic">Chapter 4</em></a>, <em class="italic">Setting Up Your First Multiplayer Environment</em>, a component will let you implement <a id="_idIndexMarker514"/>reusable functionality and can be attached to any Actor or another component. In this case, we will implement a weapon system, with a <code>Transform</code> property) – this will allow you to position the component somewhere inside the character and act as a spawn point for the thrown projectiles.</p>
<p>Let’s start by creating the class. To do so, create a new class that extends from a Scene component and call it <code>US_WeaponProjectileComponent</code>. Once the creation process has finished, open <code>US_WeaponProjectileComponent.h</code>, and in the <code>private</code> section, add the following declarations:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Projectile", meta = (AllowPrivateAccess = "true"))
TSubclassOf&lt;class AUS_BaseWeaponProjectile&gt; ProjectileClass;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input", meta=(AllowPrivateAccess = "true"))
class UInputMappingContext* WeaponMappingContext;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input", meta=(AllowPrivateAccess = "true"))
class UInputAction* ThrowAction;</pre>
<p>As you can see, we declare the projectile class (i.e., the projectile we previously created, or a subclass of it). Then, we declare the necessary elements that will let us take advantage of the enhanced input system. As we don’t want to add dependencies to the main character, we will use a different mapping context from the one used in <a href="B18203_05.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Actors in a Multiplayer Environment</em> – this will let us implement a flexible combat system and add as many features as we want, without adding clutter to the main character class. Imagine the thrill of watching your sneaky thief hero slipping through the shadows, quietly backstabbing the most despised minions of the dreaded Lichlord! The possibilities for mayhem and mischief will be endless!</p>
<p>Okay, let’s stop dreaming and get back to coding. In the <code>public</code> section, add a setter for the projectile class that will allow you to change the spawned dagger projectile:</p>
<pre class="source-code">
UFUNCTION(BlueprintCallable, Category = "Projectile")
void SetProjectileClass(TSubclassOf&lt;class AUS_BaseWeaponProjectile&gt; NewProjectileClass);</pre>
<p>This function has <a id="_idIndexMarker516"/>nothing to do with throwing things around, but it will be most useful if you plan to add a weapon pickup to your game, in order to improve your character’s fighting skills.</p>
<p>Lastly, in the <code>protected</code> section, declare the <code>Throw()</code> action and its corresponding server call:</p>
<pre class="source-code">
void Throw();
UFUNCTION(Server, Reliable)
void Throw_Server();</pre>
<p>This code will let us spawn the thrown daggers during gameplay from the server – always remember that the server should be in command when generating replicated Actors.</p>
<p>Now that the header file is finished, open the <code>US_WeaponProjectileComponent.cpp</code> file to start implementing its features. As usual, locate the top of the file, and add the <code>include</code> declarations for the classes we will use:</p>
<pre class="source-code">
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"
#include "US_BaseWeaponProjectile.h"
#include "US_Character.h"</pre>
<p>Then, in the constructor, add this single line of code:</p>
<pre class="source-code">
ProjectileClass = AUS_BaseWeaponProjectile::StaticClass();</pre>
<p>Here, we just declare the base projectile that will be spawned when the throw action is triggered; you <a id="_idIndexMarker517"/>will obviously be able to change it in the derived Blueprint Classes if you need a different weapon.</p>
<p>Now, locate the <code>BeginPlay()</code> method, and just after the <code>Super::BeginPlay()</code> declaration, add this code:</p>
<pre class="source-code">
const ACharacter* Character = Cast&lt;ACharacter&gt;(GetOwner());
if(!Character) return;
if (const APlayerController* PlayerController = Cast&lt;APlayerController&gt;(Character-&gt;GetController()))
{
 if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;(PlayerController-&gt;GetLocalPlayer()))
 {
  Subsystem-&gt;AddMappingContext(WeaponMappingContext, 1);
 }
 if (UEnhancedInputComponent* EnhancedInputComponent = Cast&lt;UEnhancedInputComponent&gt;(PlayerController-&gt;InputComponent))
 {
  EnhancedInputComponent-&gt;BindAction(ThrowAction, ETriggerEvent::Triggered, this, &amp;UUS_WeaponProjectileComponent::Throw);
 }
}</pre>
<p>In the previous code, we check that the component owner is our <code>US_Character</code> class, in order to get its controller and initialize the mapping context and its actions. Note that this initialization is done inside the <code>BeginPlay()</code> function, which means that these steps will be done just once – that is, when the game is started – to be sure that there is an Actor owner and a corresponding controller.</p>
<p>Now, implement the <a id="_idIndexMarker518"/>throw logic by adding the following method implementations:</p>
<pre class="source-code">
void UUS_WeaponProjectileComponent::Throw()
{
 Throw_Server();
}
void UUS_WeaponProjectileComponent:: Throw_Server_Implementation()
{
 if (ProjectileClass)
 {
  const auto Character = Cast&lt;AUS_Character&gt;(GetOwner());
  const auto ProjectileSpawnLocation = GetComponentLocation();
  const auto ProjectileSpawnRotation = GetComponentRotation();
  auto ProjectileSpawnParams = FActorSpawnParameters();
  ProjectileSpawnParams.Owner = GetOwner();
  ProjectileSpawnParams.Instigator = Character;
  GetWorld()-&gt;SpawnActor&lt;AUS_BaseWeaponProjectile&gt;(ProjectileClass, ProjectileSpawnLocation, ProjectileSpawnRotation, ProjectileSpawnParams);
 }
}</pre>
<p>As you can see, the <code>Throw()</code> method simply calls the server-side implementation that will spawn the projectile from the component location. You are already familiar with the spawn action (do you remember the minion spawner?), but there is an important thing to notice this time – we use the <code>FActorSpawnParameters</code> structure to set the owner of the projectile and, most importantly, the instigator (i.e., the Actor that spawned the object). This property is used by the projectile to retrieve the character statistics and handle the damage multiplier, code logic we implemented in the previous section.</p>
<p>Lastly, add the setter <a id="_idIndexMarker519"/>method that will let you change the weapon spawned by the character:</p>
<pre class="source-code">
void UUS_WeaponProjectileComponent::SetProjectileClass(TSubclassOf&lt;AUS_BaseWeaponProjectile&gt; NewProjectileClass)
{
 ProjectileClass = NewProjectileClass;
}</pre>
<p>The component has now been properly set – you just need to attach an instance of it to the thief character to make it fully operational.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor188"/>Attaching the WeaponProjectile component to the character</h2>
<p>Now that you have <a id="_idIndexMarker520"/>created a weapon component, it’s time to add it to the character. Open the <code>US_Character.h</code> header file, and in the <code>private</code> section, add the component declaration:</p>
<pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Weapon", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UUS_WeaponProjectileComponent&gt; Weapon;</pre>
<p>And, as usual, add the corresponding getter utility method to the <code>public</code> section:</p>
<pre class="source-code">
FORCEINLINE UUS_WeaponProjectileComponent* GetWeapon() const { return Weapon; }</pre>
<p>Then, open the <code>US_Character.cpp</code> source file and include the component class declaration at the top of the file:</p>
<pre class="source-code">
#include "US_WeaponProjectileComponent.h"</pre>
<p>Now, locate the constructor, and just after the noise emitter creation and initialization, add the following code:</p>
<pre class="source-code">
Weapon = CreateDefaultSubobject&lt;UUS_WeaponProjectileComponent&gt;(TEXT("Weapon"));
Weapon-&gt;SetupAttachment(RootComponent);
Weapon-&gt;SetRelativeLocation(FVector(120.f, 70.f, 0.f));</pre>
<p>As you can see, after we create the component, we attach it to the root component of the character and position it at a relative location, set to <code>(120, 70, 0)</code>. If you want your character to be left-handed, you can just use a negative value for the <code>X</code> coordinate (i.e., <code>-120.f</code>).</p>
<p>As hard as it may be to believe, the code to attach the weapon component to the character is <a id="_idIndexMarker521"/>complete; the code logic is already handled in the component itself, so you can sit back, relax, and let everything fall into place like a well-oiled machine!</p>
<p>You can now switch back to the Unreal Editor and compile your project – once finished, you can open the <code>WeaponProjectile</code> component, with <strong class="bold">Projectile Class</strong> set to a default value, as depicted in <em class="italic">Figure 9</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 9.3 – The WeaponProjectile component attached to the character Actor" src="img/Figure_09_03_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The WeaponProjectile component attached to the character Actor</p>
<p>With the <code>WeaponProjectile</code> component attached to the character, the last thing to do is to create a <a id="_idIndexMarker522"/>mapping context for the player input and an input action for the throw logic.</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor189"/>Adding an input system for the weapon</h2>
<p>In the final part <a id="_idIndexMarker523"/>of this section, you will define the mapping context <a id="_idIndexMarker524"/>and the input action for the throw interaction. This is something you are already familiar with, as you previously created similar assets in <a href="B18203_05.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Actors in a </em><em class="italic">Multiplayer Environment</em>.</p>
<p>So, without further ado, let’s open the Content Browser and navigate to the <strong class="bold">Content</strong> |<strong class="bold"> Input</strong> folder. We will create the throw action asset in the following steps.</p>
<h3>Setting up the input mapping context for the throw interaction</h3>
<p>To create the action <a id="_idIndexMarker525"/>asset for the throw interaction, follow these steps:</p>
<ol>
<li>Right-click in the Content Browser and select <code>IA_Throw</code>.</li>
<li>Double-click on the asset to open it, and from the <strong class="bold">Value Type</strong> dropdown, select <strong class="bold">Digital (bool)</strong>.</li>
<li>Double-check that the <strong class="bold">Consume Input</strong> checkbox is ticked.</li>
</ol>
<p>The final result for the throw action asset is shown in <em class="italic">Figure 9</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 9.4 – The throw action settings" src="img/Figure_09_04_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The throw action settings</p>
<p>Now that the action <a id="_idIndexMarker526"/>has been set, let’s create a mapping context for the weapon interactions.</p>
<h3>Setting up the input mapping context for the weapon interactions</h3>
<p>To create the <a id="_idIndexMarker527"/>weapon context mapping, follow these steps:</p>
<ol>
<li>Right-click in the Content Browser and select <code>IMC_Weapons</code>. Double-click on the asset to open it.</li>
<li>Add a new mapping context by clicking on the <strong class="bold">+</strong> icon next to the <strong class="bold">Mappings</strong> field.</li>
<li>From the drop-down menu that will be added, select <strong class="bold">IA_Throw</strong> to add this action to the mapping context.</li>
<li>Click twice on the <strong class="bold">+</strong> icon next to the drop-down menu to add two other control bindings for this action (one is set by default). In the drop-down menu next to each new field, use the following properties:<ul><li>The first <a id="_idIndexMarker528"/>binding should be set to <strong class="bold">Left Ctrl</strong> from the <strong class="bold">Keyboard</strong> category</li><li>The second binding should be set to <strong class="bold">Gamepad Face Button Right</strong> from the <strong class="bold">Gamepad</strong> category</li><li>The third binding should be set to <strong class="bold">Left Mouse Button</strong> from the <strong class="bold">Mouse</strong> category</li></ul></li>
</ol>
<p>The final result for the weapon mapping context should be like the one depicted in <em class="italic">Figure 9</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 9.5 – The weapon mapping context settings" src="img/Figure_09_05_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The weapon mapping context settings</p>
<p>Now that the assets are ready, it’s time to add them to the character:</p>
<ol>
<li>Open the <strong class="bold">BP_Character</strong> Blueprint, select the <strong class="bold">Weapon</strong> component, and in the <strong class="bold">Details</strong> panel, locate the <strong class="bold">Input</strong> category.</li>
<li>In the <strong class="bold">Weapon Mapping Context</strong> field, assign the <strong class="bold">IMC_Weapons</strong> asset.</li>
<li>In the <strong class="bold">Throw Action</strong> field, assign the <strong class="bold">IA_Throw</strong> asset.</li>
</ol>
<p>Once you have set <a id="_idIndexMarker529"/>these properties, your <strong class="bold">Input</strong> category should look like the one depicted in <em class="italic">Figure 9</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 9.6 – The updated Input category" src="img/Figure_09_06_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – The updated Input category</p>
<p>Now that the input <a id="_idIndexMarker530"/>settings have been properly updated, it’s time to do some testing to check that everything works properly.</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/>Testing the weapon system</h2>
<p>It’s time to show the Lichlord’s minions who the boss is and wreak some havoc in their underground lairs! Let’s give them a taste of our hero’s targeting skills by starting a game session.</p>
<p>During gameplay, your <a id="_idIndexMarker531"/>character should be able to spawn a dagger whenever using the throw action – for example, by clicking the left mouse button. The dagger should destroy itself whenever it hits something and provoke damage to the AI minions.</p>
<p>Whenever a minion reaches zero health, it should be removed from the game, and a coin should spawn in the level. Collecting enough coins will make your character level up, and consequently, the character itself will provoke additional damage when hitting any enemy.</p>
<p><em class="italic">Figure 9</em><em class="italic">.7</em> shows the character throwing some daggers during gameplay:</p>
<div><div><img alt="Figure 9.7 – The dagger attack in action" src="img/Figure_09_07_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – The dagger attack in action</p>
<p>In this section, you implemented a weapon system through a new component that is attached to your character<a id="_idIndexMarker532"/> and a projectile Actor that can be spawned in the game and properly replicated through the network.</p>
<p>In the upcoming section, you will introduce some diverse variations of the AI opponents, with the aim of enhancing the game’s variety and overall enjoyability.</p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor191"/>Creating AI variations</h1>
<p>Now that we’ve got the AI opponents all set up and ready to go for some epic battles, let’s add some <a id="_idIndexMarker533"/>more variations to AI minions and make things more interesting and engaging. If a project has been well planned, changing the behavior of an AI – even a basic one such as the one we created in this chapter – is usually just a matter of adjusting some settings!</p>
<p>In this section, you’ll create a new AI opponent, starting from the basic <code>US_Minion</code> class, and you will tweak its property in order to give it different behavior.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/>Creating an AI sentinel</h2>
<p>While watching mindless minions wander around a dungeon cluelessly may cause a chuckle <a id="_idIndexMarker534"/>or two, it is certainly not enough for the Lichlord’s devious plans. He wants to be sure that each and every corner of his realm is safe and well guarded. This means you will craft some undead sentinels that will have keen senses and be more territorial.</p>
<p>Let’s start by creating a Blueprint Class, inheriting from the basic minion. Open the Content Browser and complete the following steps:</p>
<ol>
<li>In the <code>Blueprints</code> folder, right-click and select <strong class="bold">Blueprint Class</strong>.</li>
<li>From the window that pops up, select <strong class="bold">US_Minion</strong> from the <strong class="bold">All </strong><strong class="bold">Classes</strong> section.</li>
<li>Name the newly created Blueprint <code>BP_MinionSentinel</code>, and then double-click on it to open it.</li>
<li>In the <code>6000,0</code></li><li>Set <code>60,0</code></li><li>Set <code>20,0</code></li><li>Set <code>1000,0</code></li><li>The final settings for this category are shown in <em class="italic">Figure 9.8</em>:</li></ul></li>
</ol>
<div><div><img alt="Figure 9.8 – The sentinel Minion AI settings" src="img/Figure_09_08_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – The sentinel Minion AI settings</p>
<ol>
<li value="5">Then, in <a id="_idIndexMarker535"/>the <code>600,0</code></li><li>Set <code>1000,0</code></li><li>Set <code>2500,0</code></li><li>Set <code>60,0</code></li></ul></li>
</ol>
<p>The final settings for this category are shown in <em class="italic">Figure 9</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 9.9 – The sentinel AI settings" src="img/Figure_09_09_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The sentinel AI settings</p>
<p>With these settings, you will create a minion that will patrol an approximately small area, changing direction frequently and moving very slowly. Its senses will be keen, and its <a id="_idIndexMarker536"/>alert radius will be larger than a regular minion. When an intruder has been spotted, the sentinel will slow down, calling for help, letting its more aggressive counterparts handle the chase. It’s not one for combat, but it’s still on the lookout for any suspicious activity!</p>
<ol>
<li value="6">As a final touch, you can add a couple of glowing eyes for this darkness-gazing undead character by changing <strong class="bold">Element 5</strong> in the mesh <strong class="bold">Materials</strong> list to the <strong class="bold">M_Base_Emissive</strong> material asset, as shown in <em class="italic">Figure 9</em><em class="italic">.10</em>:</li>
</ol>
<div><div><img alt="Figure 9.10 – The Materials settings" src="img/Figure_09_10_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – The Materials settings</p>
<p>The final result of <a id="_idIndexMarker537"/>the sentinel (with some dramatic lightning add-ons) can be seen in <em class="italic">Figure 9</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 9.11 – The sentinel added to the scene" src="img/Figure_09_11_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – The sentinel added to the scene</p>
<p>As you can see, you <a id="_idIndexMarker538"/>have created a new AI with just a couple of tweaks to the <strong class="bold">Details</strong> panel. Let’s create another one, a more aggressive undead minion.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor193"/>Creating an AI miniboss</h2>
<p>You can actually <a id="_idIndexMarker539"/>use the same process that worked in the previous subsection to create a new AI that will deal with hero intruders in a totally different way. It’s like getting creative with a recipe and making something new and unexpected but still (dangerously) delicious!</p>
<p>Open the Content Browser and complete the following steps:</p>
<ol>
<li>In the <code>Blueprints</code> folder, right-click and select <strong class="bold">Blueprint Class</strong>.</li>
<li>From the window that pops up, select <strong class="bold">US_Minion</strong> from the <strong class="bold">All </strong><strong class="bold">Classes</strong> section.</li>
<li>Name the newly created Blueprint <code>BP_MinionMiniboss</code>, and then double-click on it to open it.</li>
<li>In the <code>100,0</code></li><li>Set <code>100,0</code></li><li>Set <code>400,0</code></li><li>Set <code>50000,0</code></li><li>The final settings for this category are shown in <em class="italic">Figure 9.12</em>:</li></ul></li>
</ol>
<div><div><img alt="Figure 9.12 – The miniboss Minion AI settings" src="img/Figure_09_12_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – The miniboss Minion AI settings</p>
<ol>
<li value="5">Then, in <a id="_idIndexMarker540"/>the <code>200,0</code></li><li>Set <code>400,0</code></li><li>Set <code>200,0</code></li><li>Set <code>20,0</code></li></ul></li>
</ol>
<p>The final settings for this category are shown in <em class="italic">Figure 9</em><em class="italic">.13</em>:</p>
<div><div><img alt="Figure 9.13 – The miniboss AI settings" src="img/Figure_09_13_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – The miniboss AI settings</p>
<p>This AI opponent has been set to a really dull behavior while patrolling (low perception, slower movement, etc.), but it will become dangerously fast once alerted.</p>
<p>Also, the miniboss started <a id="_idIndexMarker541"/>to look a bit dull, so the Lichlord has decided to give it a literal armor makeover. To do this, follow these steps:</p>
<ol>
<li>Select the <strong class="bold">Mesh</strong> component and change the <strong class="bold">Skeletal Mesh Asset</strong> property to the <strong class="bold">skeleton_warrior</strong> asset.</li>
<li>Change the <strong class="bold">Mesh</strong> scale to a value of <strong class="bold">1.2</strong> to make it bigger.</li>
<li>Set the <strong class="bold">Health</strong> property to a value of <strong class="bold">20</strong> to make it more damage-resistant.</li>
</ol>
<p>This foe is about to go from “meh” to menacing, and hero intruders better watch out! The final result of the miniboss, compared with a base minion, is shown in <em class="italic">Figure 9</em><em class="italic">.14</em>:</p>
<div><div><img alt="Figure 9.14 – The miniboss minion" src="img/Figure_09_14_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – The miniboss minion</p>
<p>The beauty of it all is that you can get really creative with your enemy opponents and test out all sorts of different behaviors and tactics. And if something just isn’t working for you, no worries! Just delete it and start afresh with something new in just a few short minutes.</p>
<p>As an additional nice touch to the AI, why not use the pickup spawn system we added earlier in this chapter t<a id="_idIndexMarker542"/>o spice up the game? Depending on how rare or dangerous the defeated minion is, you could have it spawn different types of coins!</p>
<p>Once you have your undead army ready to go, you can get back to your enemy spawner and add the Blueprints to the system – something we will do in the next subsection.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor194"/>Updating the minion spawner</h2>
<p>As you may have <a id="_idIndexMarker543"/>guessed, adding your brand-new minion varieties is just a matter of putting their Blueprints inside a spawner. To do so, select the spawner you previously added to the level, and in the <strong class="bold">Details</strong> panel, locate the <strong class="bold">Spawnable Minions</strong> array property in the <strong class="bold">Spawn System</strong> category – there should already be one item in the list, <strong class="bold">US_Minion</strong>.</p>
<p>Add as many items as you wish, selecting the spawnable minions you need for that particular spawn area. <em class="italic">Figure 9</em><em class="italic">.15</em> shows my setup for the main spawner area in the level:</p>
<div><div><img alt="Figure 9.15 – The spawn area setup" src="img/Figure_09_15_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – The spawn area setup</p>
<p>As you can see, I chose to work with five elements, allocating a 20% chance for each to be added to the <a id="_idIndexMarker544"/>level every time the <code>Spawn()</code> method is called. Since the basic minion utilizes three of these elements, there is a 60% chance that it will appear as an opponent, compared to the sentinel and miniboss, which only have a 20% probability of spawning.</p>
<p>Once you are happy with your setup, you can test the game. <em class="italic">Figure 9</em><em class="italic">.16</em> shows my spawner in action at the start of the game:</p>
<div><div><img alt="Figure 9.16 – The spawner at the start of the game" src="img/Figure_09_16_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – The spawner at the start of the game</p>
<p>In this final section, you <a id="_idIndexMarker545"/>created some variations for the base minions; by changing some of their base properties, you changed the way they behave during gameplay, making your level more engaging and diverse.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor195"/>Summary</h1>
<p>In this chapter, you actively worked to improve the behavior of your enemy AIs within the level. The focus was on developing new features that make the gaming experience even more engaging and challenging for players. You actually improved the Lichlord’s minions’ sense of hearing to make them even more alert and perceptive when it comes to spotting those poor thieving heroes.</p>
<p>On the flip side, you also implemented a health system for the minions and added some pretty sharp (literally!) tools to the player’s arsenal that they can use to take down those nasty foes! Finally, you created some enemy variations to make the dungeon less boring and more engaging for the player.</p>
<p>As you can see from what you have built here, if you plan ahead, improving gameplay can be a walk in the park! By taking the time to carefully map out your strategies and implement the right features, you can make gameplay engaging and immersive for players while also achieving your desired results.</p>
<p>In the next chapter, we will improve the overall look and feel of the game by adding animations and prisoners to rescue. Additionally, I will provide you with some tips on how to take your game to the next level, but let’s be clear – I’m not going to code it all for you! I believe in your ability to create something amazing, and I can’t wait to see what you come up with!</p>
</div>
</body></html>