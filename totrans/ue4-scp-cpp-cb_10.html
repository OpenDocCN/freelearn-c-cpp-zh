<html><head></head><body>
        

                            
                    <h1 class="header-title">Integrating C++ and the Unreal Editor: Part II</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating a new editor module</li>
<li>Creating new toolbar buttons</li>
<li>Creating new menu entries</li>
<li>Creating a new editor window</li>
<li>Creating a new Asset type</li>
<li>Creating custom context menu entries for Assets</li>
<li>Creating new console commands</li>
<li>Creating a new graph pin visualizer for Blueprint</li>
<li>Inspecting types with custom Details panels</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In game development, in addition to creating games, you'll often need to create tools for other developers to use that have been customized to fit the project that you're working on. In fact, this is often one of the more common entry-level game developer positions in the AAA game industry. In this chapter, we will learn how to implement custom editor windows and custom detail panels to inspect types that have been created by users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new editor module</h1>
                
            
            
                
<p class="mce-root">The following recipes all interact with editor mode-specific code and engine modules. As a result, it is considered good practice to create a new module that will only be loaded when the engine is running in editor mode, so that we can place all our editor-only code inside it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your project's <kbd>.uproject</kbd> file in a text editor such as Notepad or Notepad++. You can find the file inside your project folder, and it should look similar to what's shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b4051c5c-b769-4866-98f4-39af0c8018de.png"/></p>
<ol start="2">
<li>Add the bold section of text in the following snippet to the file:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  "FileVersion": 3,<br/>  "EngineAssociation": "4.21",<br/>  "Category": "",<br/>  "Description": "",<br/>  "Modules": [<br/>    {<br/>      "Name": "Chapter_10",<br/>      "Type": "Runtime",<br/>      "LoadingPhase": "Default"<br/>    }<strong>, </strong><br/><strong>      { </strong><br/><strong>          "Name": "Chapter_10Editor", </strong><br/><strong>          "Type": "Editor", </strong><br/><strong>          "LoadingPhase": "PostEngineInit", </strong><br/><strong>          "AdditionalDependencies": [ </strong><br/><strong>            "Engine", </strong><br/><strong>            "CoreUObject" </strong><br/><strong>          ] </strong><br/><strong>      }</strong> <br/>  ]<br/>}<br/><br/></pre>
<p style="padding-left: 60px">Note the comma after the first module before the second set of curly braces.</p>
<ol start="3">
<li>In your <kbd>Source</kbd> folder, create a new folder using the same name as you specified in your <kbd>uproject</kbd> file (in this instance, <kbd>"Chapter_10Editor"</kbd>):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/fc3ee6b5-e94d-4330-a120-4b2f707d6edc.png"/></p>
<ol start="4">
<li>Open up the <kbd>Chapter_10Editor.Target.cs</kbd> file and update it to the following:</li>
</ol>
<pre style="padding-left: 60px">using UnrealBuildTool;<br/>using System.Collections.Generic;<br/><br/>public class Chapter_10EditorTarget : TargetRules<br/>{<br/>  public Chapter_10EditorTarget(TargetInfo Target) : base(Target)<br/>  {<br/>    Type = TargetType.Editor;<br/><br/>    ExtraModuleNames.AddRange( new string[] { "Chapter_10<strong>Editor</strong>" } );<br/>  }<br/>}</pre>
<ol start="5">
<li>Inside this new folder, create a blank <kbd>.txt</kbd> file and rename it to <kbd>Chapter_10Editor.Build.cs</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1f0a6cba-aeb7-420e-9d08-cec2aed2029e.png"/></p>
<ol start="6">
<li>Insert the following into the file:</li>
</ol>
<pre style="padding-left: 60px">using UnrealBuildTool;<br/><br/>public class Chapter_10Editor : ModuleRules<br/>{<br/>    public Chapter_10Editor(ReadOnlyTargetRules Target) : <br/>    base(Target)<br/>    {<br/>        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br/><br/>        PublicDependencyModuleNames.AddRange(new string[] { "Core", <br/>        "CoreUObject", "Engine", "InputCore", "RHI", "RenderCore", <br/>        "ShaderCore", "MainFrame", "AssetTools", "AppFramework", <br/>        "PropertyEditor"});<br/>    <br/>       PublicDependencyModuleNames.Add("Chapter_10");<br/><br/>        PrivateDependencyModuleNames.AddRange(new string[] { <br/>        "UnrealEd", "Slate", "SlateCore", "EditorStyle", <br/>        "GraphEditor", "BlueprintGraph" });<br/><br/>    }<br/>}</pre>
<ol start="7">
<li>Still inside of the <kbd>Chapter10_Editor</kbd> folder, create a new file called <kbd>Chapter_10Editor.h</kbd> and add the following:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "Engine.h"<br/>#include "Modules/ModuleInterface.h"<br/>#include "Modules/ModuleManager.h"<br/>#include "UnrealEd.h"<br/> <br/> <br/>class FChapter_10EditorModule: public IModuleInterface <br/>{ <br/>}; </pre>
<ol start="8">
<li>Lastly, create a new source file called <kbd>Chapter_10Editor.cpp</kbd>.</li>
<li>Add the following code:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_10Editor.h" <br/>#include "Modules/ModuleManager.h"<br/>#include "Modules/ModuleInterface.h"<br/><br/>IMPLEMENT_GAME_MODULE(FChapter_10EditorModule, Chapter_10Editor)</pre>
<ol start="10">
<li>Finally, close Visual Studio if you have it open. Then, right-click on the <kbd>.uproject</kbd> file and select Generate Visual Studio Project files:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/71edf948-dcce-4da8-a1a3-e8069a117f83.png"/></p>
<ol start="11">
<li>You should see a small window launch, display a progress bar, and then close:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/766c4e4b-557f-4785-8c01-ae82430cadc7.jpg" style="width:40.67em;height:7.75em;"/></p>
<ol start="12">
<li>You can now launch Visual Studio, verify that your new module is visible in the IDE, and compile your project successfully:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/770bd61f-d16a-49f2-9c81-f2f1d3be25d3.png" style="width:29.58em;height:32.50em;"/></p>
<ol start="13">
<li>The module is now ready for the next set of recipes.</li>
</ol>
<p>Code changes made in this editor module won't support hot-reloading in the same way that code in runtime modules does. If you get a compilation error that mentions changes to generated header files, simply close the editor and rebuild it from within your IDE instead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Unreal projects use the <kbd>.uproject</kbd> file format to specify a number of different pieces of information about the project.</p>
<p>This information is used to inform the Header and Build tools about the modules that comprise this project, and is used for code generation and <kbd>makefile</kbd> creation.</p>
<p>The file uses JSON-style formatting.</p>
<p>These include the following:</p>
<ul>
<li>The engine version that the project should be opened in</li>
<li>A list of modules that are used in the project</li>
<li>A list of module declarations</li>
</ul>
<p>Each of these module declarations contain the following:</p>
<ul>
<li>The name of the module.</li>
<li>The type of module—is it an editor module (only runs in editor builds, has access to editor-only classes) or a runtime module (runs in both editor and Shipping builds)?</li>
<li>The loading phase of the module—modules can be loaded at different points during program startup. This value specifies the point at which the module should be loaded, for example, if there are dependencies in other modules that should be loaded first.</li>
<li>A list of dependencies for the module. These are essential modules that contain exported functions or classes that the module relies on.</li>
</ul>
<p>We added a new module to the <kbd>uproject file</kbd>. The module's name is <kbd>Chapter_10Editor</kbd> (Conventionally, <kbd>Editor</kbd> should be appended to the main game module for an editor module).</p>
<p>This module is marked as an editor module, and is set to load after the baseline engine so that it can use the classes that have been declared in Engine code.</p>
<p>Our module's dependencies are left at the default values for now.</p>
<p>With the <kbd>uproject</kbd> file altered to contain our new module, we need a build script for it.</p>
<p>Build scripts are written in C#, and take the name <kbd>&lt;ModuleName&gt;.Build.cs</kbd>.</p>
<p>C#, unlike C++, doesn't use a separate header file and implementation – it's all there in the one <kbd>.cs</kbd> file.</p>
<p>We want to access the classes that have been declared in the <kbd>UnrealBuildTool</kbd> module, so we include a <kbd>using</kbd> statement to indicate that we want to access that namespace.</p>
<p>We create a <kbd>public</kbd> class with the same name as our module, which inherits from <kbd>ModuleRules</kbd>.</p>
<p>Inside our constructor, we add a number of modules to the dependencies of this module. There are both private dependencies and public dependencies.</p>
<p>According to the code of the <kbd>ModuleRules</kbd> class, public dependencies are modules that your module's public header files depend on. Private dependencies are modules that the private code depends on. Anything used in both public headers and private code should go into the <kbd>PublicDependencyModuleNames</kbd> array.</p>
<p>You'll note that our <kbd>PublicDependencyModuleNames</kbd> array contains our main game module. This is because some recipes in this chapter will extend the editor to better support the classes that are defined within our main game module.</p>
<p>Now that we've told the build system that we have a new module to build through the project file, and we've specified how to build the module with the build script, we need to create the C++ class that is our actual module.</p>
<p>We create a header file that includes the Engine header, the <kbd>ModuleManager</kbd> header, and the <kbd>UnrealEd</kbd> header.</p>
<p>We include <kbd>ModuleManager</kbd> because it defines <kbd>IModuleInterface</kbd>, the class that our module will inherit from.</p>
<p>We also include <kbd>UnrealEd</kbd> because we're writing an editor module that will need to access the editor functionality.</p>
<p>The class we declare inherits from <kbd>IModuleInterface</kbd>, and takes its name from the usual prefix, <kbd>F</kbd>, followed by the module name.</p>
<p>Inside the <kbd>.cpp</kbd> file, we include our module's header, and then use the <kbd>IMPLEMENT_GAME_MODULE</kbd> macro.</p>
<p><kbd>IMPLEMENT_GAME_MODULE</kbd> declares an exported C function, <kbd>InitializeModule()</kbd>, which returns an instance of our new module class.</p>
<p>This means that Unreal can simply call <kbd>InitializeModule()</kbd> on any library that exports it to retrieve a reference to the actual module implementation without needing to know what class it is.</p>
<p>Having added our new module, we now need to rebuild our Visual Studio solution, so we close Visual Studio and then regenerate the project files using the context menu.</p>
<p>With the project rebuilt, the new module will be visible in Visual Studio, and we can add code to it as usual.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating new toolbar buttons</h1>
                
            
            
                
<p class="mce-root">If you have created a custom tool or window for display within the editor, you probably need some way to let the user make it appear. The easiest way to do this is to create a toolbar customization that adds a new toolbar button, and have it display your window when clicked. Create a new engine module by following the previous recipe, as we'll need it to initialize our toolbar customization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol start="1">
<li>Inside of the <kbd>Chapter_10Editor</kbd> folder, create a new header file, <kbd>CookbookCommands.h</kbd>, and insert the following class declaration:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">#pragma once<br/>#include "Commands.h"<br/>#include "EditorStyleSet.h"<br/><br/><br/>class FCookbookCommands : public TCommands&lt;FCookbookCommands&gt;<br/>{<br/>public:<br/>  FCookbookCommands()<br/>    : TCommands&lt;FCookbookCommands&gt;( <br/>      FName(TEXT("UE4_Cookbook")), <br/>      FText::FromString("Cookbook Commands"), <br/>      NAME_None, <br/>      FEditorStyle::GetStyleSetName()) <br/>  {<br/>  };<br/><br/>  virtual void RegisterCommands() override;<br/><br/>  TSharedPtr&lt;FUICommandInfo&gt; MyButton;<br/>  <br/>  TSharedPtr&lt;FUICommandInfo&gt; MyMenuButton;<br/>};</pre>
<ol start="2">
<li>Implement the new class by placing the following in the <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "CookbookCommands.h"<br/>#include "Chapter_10Editor.h"<br/>#include "Commands.h"<br/><br/><br/>void FCookbookCommands::RegisterCommands()<br/>{<br/>#define LOCTEXT_NAMESPACE ""<br/>  UI_COMMAND(MyButton, "Cookbook", "Demo Cookbook Toolbar Command", EUserInterfaceActionType::Button, FInputGesture());<br/>  UI_COMMAND(MyMenuButton, "Cookbook", "Demo Cookbook Toolbar Command", EUserInterfaceActionType::Button, FInputGesture());<br/>#undef LOCTEXT_NAMESPACE<br/>}<br/><br/></pre>
<ol start="3">
<li>Next, we will need to update our module class (<kbd>Chapter_10Editor.h</kbd>) to the following:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "Engine.h"<br/>#include "Modules/ModuleInterface.h"<br/>#include "Modules/ModuleManager.h"<br/>#include "UnrealEd.h"<br/><strong>#include "CookbookCommands.h"</strong><br/><strong>#include "Editor/MainFrame/Public/Interfaces/IMainFrameModule.h"</strong><br/><br/> <br/>class FChapter_10EditorModule: public IModuleInterface <br/>{ <br/><strong>    virtual void StartupModule() override;</strong><br/><strong>    virtual void ShutdownModule() override;</strong><br/><br/><strong>    TSharedPtr&lt;FExtender&gt; ToolbarExtender;</strong><br/><strong>    TSharedPtr&lt;const FExtensionBase&gt; Extension;</strong><br/><br/><strong>    void MyButton_Clicked()</strong><br/><strong>    {</strong><br/>        <br/><strong>        TSharedRef&lt;SWindow&gt; CookbookWindow = SNew(SWindow)</strong><br/><strong>            .Title(FText::FromString(TEXT("Cookbook Window")))</strong><br/><strong>            .ClientSize(FVector2D(800, 400))</strong><br/><strong>            .SupportsMaximize(false)</strong><br/><strong>            .SupportsMinimize(false);</strong><br/><br/><strong>        IMainFrameModule&amp; MainFrameModule =</strong><br/><strong>            FModuleManager::LoadModuleChecked&lt;IMainFrameModule&gt;</strong><br/><strong>            (TEXT("MainFrame"));</strong><br/><br/><strong>        if (MainFrameModule.GetParentWindow().IsValid())</strong><br/><strong>        {</strong><br/><strong>            FSlateApplication::Get().AddWindowAsNativeChild</strong><br/><strong>            (CookbookWindow, MainFrameModule.GetParentWindow()</strong><br/><strong>                .ToSharedRef());</strong><br/><strong>        }</strong><br/><strong>        else</strong><br/><strong>        {</strong><br/><strong>            FSlateApplication::Get().AddWindow(CookbookWindow);</strong><br/><strong>        }</strong><br/>        <br/><strong>    };</strong><br/><br/><strong>    void AddToolbarExtension(FToolBarBuilder &amp;builder)</strong><br/><strong>    {</strong><br/>        <br/><strong>        FSlateIcon IconBrush =</strong><br/><strong>            FSlateIcon(FEditorStyle::GetStyleSetName(),</strong><br/><strong>                "LevelEditor.ViewOptions",</strong><br/><strong>                "LevelEditor.ViewOptions.Small"); builder.AddToolBarButton(FCookbookCommands::Get()</strong><br/><strong>                    .MyButton, NAME_None, FText::FromString("My Button"),</strong><br/><strong>                    FText::FromString("Click me to display a message"),</strong><br/><strong>                    IconBrush, NAME_None);</strong><br/>        <br/><strong>    };</strong><br/>}; </pre>
<p style="padding-left: 60px">Be sure to <kbd>#include</kbd> the header file for your command class as well.</p>
<ol start="4">
<li>We now need to implement <kbd>StartupModule</kbd> and <kbd>ShutdownModule</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_10Editor.h" <br/>#include "Modules/ModuleManager.h"<br/>#include "Modules/ModuleInterface.h"<br/><strong>#include "LevelEditor.h" </strong><br/><strong>#include "SlateBasics.h" </strong><br/><strong>#include "MultiBoxExtender.h" </strong><br/><strong>#include "CookbookCommands.h" </strong><br/><br/>IMPLEMENT_GAME_MODULE(FChapter_10EditorModule, Chapter_10Editor)<br/><br/><strong>void FChapter_10EditorModule::StartupModule()</strong><br/><strong>{</strong><br/>    <br/><strong>    FCookbookCommands::Register();</strong><br/>   <br/><strong>    TSharedPtr&lt;FUICommandList&gt; CommandList = MakeShareable(new FUICommandList());</strong><br/>    <br/><strong>    CommandList-&gt;MapAction(FCookbookCommands::Get().MyButton, FExecuteAction::CreateRaw(this, &amp;FChapter_10EditorModule::MyButton_Clicked), FCanExecuteAction());</strong><br/>    <br/>    <br/><strong>    ToolbarExtender = MakeShareable(new FExtender());</strong><br/><br/><strong>    FLevelEditorModule&amp; LevelEditorModule = FModuleManager::LoadModuleChecked&lt;FLevelEditorModule&gt;( "LevelEditor" );</strong><br/><br/><strong>    Extension = ToolbarExtender-&gt;AddToolBarExtension("Compile", EExtensionHook::Before, CommandList, FToolBarExtensionDelegate::CreateRaw(this, &amp;FChapter_10EditorModule::AddToolbarExtension)); </strong><br/>    <br/>    <br/><strong>    LevelEditorModule.GetToolBarExtensibilityManager()-&gt;AddExtender(ToolbarExtender);</strong><br/>    <br/>        <br/><strong>}</strong><br/><br/><strong>void FChapter_10EditorModule::ShutdownModule()</strong><br/><strong>{</strong><br/>    <br/><strong>    ToolbarExtender-&gt;RemoveExtension(Extension.ToSharedRef());</strong><br/>    <br/><strong>    Extension.Reset();</strong><br/><strong>    ToolbarExtender.Reset();</strong><br/>    <br/><strong>}</strong></pre>
<ol start="5">
<li>Regenerate your project piles if needed, compile your project from Visual Studio and start the editor.</li>
<li>Verify that there's a new button on the toolbar in the main level editor, which can be clicked on to open a new window:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6f9e599c-aee8-4438-a084-5350a219f1ea.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Unreal's editor UI is based on the concept of commands. Commands are a design pattern that allows looser coupling between the UI and the actions that it needs to perform.</p>
<p>To create a class that contains a set of commands, it is necessary to inherit from <kbd>TCommands</kbd>.</p>
<p><kbd>TCommands</kbd> is a template class that leverages the <strong>Curiously Recurring Template Pattern</strong> (<strong>CRTP</strong>). The CRTP is used commonly throughout Slate UI code as a means of creating compile-time polymorphism.</p>
<p>In the initializer list for <kbd>FCookbookCommands</kbd> constructor, we invoke the parent class constructor, passing in a number of parameters:</p>
<ul>
<li>The first parameter is the name of the command set, and is a simple <kbd>FName</kbd>.</li>
<li>The second parameter is a tooltip/human readable string, and, as such, uses <kbd>FText</kbd> so that it can support localization if necessary.</li>
<li>If there's a parent group of commands, the third parameter contains the name of the group. Otherwise, it contains <kbd>NAME_None</kbd>.</li>
<li>The final parameter for the constructor is the Slate Style set that contains any command icons that the command set will be using.</li>
</ul>
<p>The <kbd>RegisterCommands()</kbd> function allows TCommands-derived classes to create any command objects that they require. The resulting <kbd>FUICommandInfo</kbd> instances that are returned from that function are stored inside the <kbd>Commands</kbd> class as members so that UI elements or functions can be bound to the commands.</p>
<p>This is why we have the member variable <kbd>TSharedPtr&lt;FUICommandInfo&gt; MyButton</kbd>.</p>
<p>In the implementation for the class, we simply need to create our commands in <kbd>RegisterCommands</kbd>.</p>
<p>The <kbd>UI_COMMAND</kbd> macro that was used to create an instance of <kbd>FUICommandInfo</kbd> expects a localization namespace to be defined, even if it is just an empty default namespace. As a result, we need to enclose our <kbd>UI_COMMAND</kbd> calls with <kbd>#defines</kbd> to set a valid value for <kbd>LOCTEXT_NAMESPACE</kbd>, even if we don't intend to use localization.</p>
<p>The actual <kbd>UI_COMMAND</kbd> macro takes a number of parameters:</p>
<ul>
<li>The first parameter is the variable to store the <kbd>FUICommandInfo</kbd> in</li>
<li>The second parameter is a human-readable name for the command</li>
<li>The third parameter is a description for the command</li>
<li>The fourth parameter is <kbd>EUserInterfaceActionType</kbd></li>
</ul>
<p>This enumeration essentially specifies what sort of button is being created. It supports <kbd>Button</kbd>, <kbd>ToggleButton</kbd>, <kbd>RadioButton</kbd>, and <kbd>Check</kbd> as valid types.</p>
<p>Buttons are simple generic buttons. A toggle button stores on and off states. The radio button is similar to a toggle, but is grouped with other radio buttons, and only one can be enabled at a time. Lastly, the checkbox displays a read-only checkbox that's adjacent to the button.</p>
<p>The last parameter for <kbd>UI_COMMAND</kbd> is the input chord, or the combination of keys that are required to activate the command.</p>
<p>This parameter is primarily useful for defining key combinations for hotkeys linked to the command in question, rather than buttons. As a result, we use an empty <kbd>InputGesture</kbd>.</p>
<p>So, we now have a set of commands, but we haven't told the engine we want to add the set to the commands that show on the toolbar. We also haven't set up what actually happens when the button is clicked. To do this, we need to perform some initialization when our module begins, so we place some code into the <kbd>StartupModule</kbd>/<kbd>ShutdownModule</kbd> functions.</p>
<p>Inside <kbd>StartupModule</kbd>, we call the static <kbd>Register</kbd> function on the commands class that we defined earlier.</p>
<p>We then create a shared pointer to a list of commands using the <kbd>MakeShareable</kbd> function.</p>
<p>In the command list, we use <kbd>MapAction</kbd> to create a mapping, or association, between the <kbd>UICommandInfo</kbd> object, which we set as a member of the <kbd>FCookbookCommands</kbd>, and the actual function we want to execute when the command is invoked.</p>
<p>You'll note that we don't explicitly set anything regarding what could be used to invoke the command here.</p>
<p>To perform this mapping, we call the <kbd>MapAction</kbd> function. The first parameter to <kbd>MapAction</kbd> is a <kbd>FUICommandInfo</kbd> object, which we can retrieve from <kbd>FCookbookCommands</kbd> by using its static <kbd>Get()</kbd> method to retrieve the instance.</p>
<p><kbd>FCookbookCommands</kbd> is implemented as a singleton – a class with a single instance that exists throughout the application. You'll see the pattern in most places – there's a static <kbd>Get()</kbd> method available in the engine.</p>
<p>The second parameter of the <kbd>MapAction</kbd> function is a delegate bound to the function to be invoked when the command is executed.</p>
<p>Because <kbd>Chapter_10EditorModule</kbd> is a raw C++ class rather than a <kbd>UObject</kbd>, and we want to invoke a member function rather than a <kbd>static</kbd> function, we use <kbd>CreateRaw</kbd> to create a new delegate that's bound to a raw C++ member function.</p>
<p><kbd>CreateRaw</kbd> expects a pointer to the object instance, and a function reference to the function to invoke on that pointer.</p>
<p>The third parameter for <kbd>MapAction</kbd> is a delegate to call to test if the action can be executed. Because we want the command to be executable all the time, we can use a simple predefined delegate that always returns <kbd>true</kbd>.</p>
<p>With an association created between our command and the action it should call, we now need to actually tell the extension system that we want to add new commands to the toolbar.</p>
<p>We can do this via the <kbd>FExtender</kbd> class, which can be used to extend menus, context menus, or toolbars.</p>
<p>We initially create an instance of <kbd>FExtender</kbd> as a shared pointer so that our extensions are uninitialized when the module is shut down.</p>
<p>We then call <kbd>AddToolBarExtension</kbd> on our new extender, storing the results in a shared pointer so that we can remove it on module uninitialization.</p>
<p>First argument of <kbd>AddToolBarExtension</kbd> is the name of the extension point where we want to add our extension.</p>
<p>To find where we want to place our extension, we first need to turn on the display of extension points within the editor UI.</p>
<p>To do so, open Editor Preferences in the Edit menu within the editor:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/733efb6c-4df7-4663-b51c-2629dabb48c2.png"/></p>
<p>Open General | Miscellaneous and select Display UIExtension Points:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a7875429-2beb-4350-8952-b13d6b5f419d.png"/></p>
<p>Restart the editor, and you should see green text overlaid on the Editor UI, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9cd351fc-a334-42c3-8155-24fa0772578c.png"/></p>
<p>Green text overlaying the Editor UI</p>
<p>The green text indicates <kbd>UIExtensionPoint</kbd>, and the text's value is the string we should provide to the <kbd>AddToolBarExtension</kbd> function.</p>
<p>We're going to add our extension to the Compile extension point in this recipe, but of course, you could use any other extension point you wish.</p>
<p>It's important to note that adding a toolbar extension to a menu extension point will fail silently, and vice versa.</p>
<p>The second parameter to <kbd>AddToolBarExtension</kbd> is a location anchor relative to the extension point that's specified. We've selected <kbd>FExtensionHook::Before</kbd>, so our icon will be displayed before the compile point.</p>
<p>The next parameter is our command list that contains mapped actions.</p>
<p>Finally, the last parameter is a delegate that is responsible for actually adding UI controls to the toolbar at the extension point and the anchor that we specified earlier.</p>
<p>The delegate is bound to a function that has the form void (<kbd>*func</kbd>) (<kbd>FToolBarBuilder</kbd> and <kbd>builder</kbd>). In this instance, it is a function called <kbd>AddToolbarExtension</kbd>, which is defined in our module class.</p>
<p>When the function is invoked, calling commands on the <kbd>builder</kbd> that adds UI elements will apply those elements to the location in the UI we specified.</p>
<p>Lastly, we need to load the level editor module within this function so that we can add our extender to the main toolbar within the level editor.</p>
<p>As usual, we can use <kbd>ModuleManager</kbd> to load a module and return a reference to it.</p>
<p>With that reference in hand, we can get the Toolbar Extensibility Manager for the module, and tell it to add our Extender.</p>
<p>While this may seem cumbersome at first, the intention is to allow you to apply the same toolbar extension to multiple toolbars in different modules, if you would like to create a consistent UI layout between different editor windows.</p>
<p>The counterpart to initializing our extension, of course, is removing it when our module is unloaded. To do that, we remove our extension from the extender, then null the shared pointers for both Extender and extension, thus reclaiming their memory allocation.</p>
<p>The <kbd>AddToolBarExtension</kbd> function within the editor module is the one that is responsible for actually adding UI elements to the toolbar that can invoke our commands.</p>
<p>It does this by calling functions on the <kbd>FToolBarBuilder</kbd> instance that's passed in as a function parameter.</p>
<p>First, we retrieve an appropriate icon for our new toolbar button using the <kbd>FSlateIcon</kbd> constructor. Then, with the icon loaded, we invoke <kbd>AddToolBarButton</kbd> on the <kbd>builder</kbd> instance.</p>
<p><kbd>AddToolbarButton</kbd> has a number of parameters. The first parameter is the command to bind to – you'll notice it's the same <kbd>MyButton</kbd> member that we accessed earlier when binding the action to the command. The second parameter is an override for the extension hook we specified earlier, but we don't want to override that, so we can use <kbd>NAME_None</kbd>. The third parameter is a label override for the new button that we create. Parameter four is a tooltip for the new button. The second to last parameter is the button's icon, and the last parameter is a name that's used to refer to this button element for highlighting support if you wish to use the in-editor tutorial framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating new menu entries</h1>
                
            
            
                
<p class="mce-root">The workflow for creating new menu entries is almost identical to that for creating new toolbar buttons, so this recipe will build on the previous one and show you how to add the command created therein to a menu rather than a toolbar.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new function inside of the <kbd>FChapter_10EditorModule</kbd> class, which is in <kbd>Chapter10_Editor.h</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void AddMenuExtension(FMenuBuilder &amp;builder) 
{ 
  FSlateIcon IconBrush = <br/>   FSlateIcon(FEditorStyle::GetStyleSetName(), <br/>   "LevelEditor.ViewOptions", <br/>   "LevelEditor.ViewOptions.Small"); 
 
  builder.AddMenuEntry(FCookbookCommands::Get().MyButton); 
}; </pre>
<ol start="2">
<li>In the implementation file (<kbd>Chapter_10Editor.cpp</kbd>), find the following code within the <kbd>StartupModule</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">EExtension = ToolbarExtender-&gt;AddToolBarExtension("Compile", EExtensionHook::Before, CommandList, FToolBarExtensionDelegate::CreateRaw(this, &amp;FChapter_10EditorModule::AddToolbarExtension)); <br/>LevelEditorModule.GetToolBarExtensibilityManager()-&gt;AddExtender(ToolbarExtender);</pre>
<ol start="3">
<li>Replace the preceding code with the following:</li>
</ol>
<pre style="padding-left: 60px">Extension = ToolbarExtender-&gt;AddMenuExtension("LevelEditor", EExtensionHook::Before, CommandList, FMenuExtensionDelegate::CreateRaw(this,&amp;FChapter_10EditorModule::AddMenuExtension)); <br/>LevelEditorModule.GetMenuExtensibilityManager()-&gt;AddExtender(ToolbarExtender);</pre>
<ol start="4">
<li>Compile your code and launch the editor.</li>
</ol>
<ol start="5">
<li>Verify that you now have a menu entry under the Window menu that displays the Cookbook window when clicked. If you followed the preceding recipe, you'll also see the green text listing the UI extension points, including the one we used in this recipe (LevelEditor):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/23b9b8b0-5d3a-40ba-9ba8-cc176d0f1b58.png" style="width:47.92em;height:53.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You'll note that <kbd>ToolbarExtender</kbd> is of type <kbd>FExtender</kbd> rather than <kbd>FToolbarExtender</kbd> or <kbd>FMenuExtender</kbd>.</p>
<p>By using a generic <kbd>FExtender</kbd> class rather than a specific subclass, the framework allows you to create a series of command-function mappings that can be used on either menus or toolbars. The delegate that actually adds the UI controls (in this instance, <kbd>AddMenuExtension</kbd>) can link those controls to a subset of commands from your <kbd>FExtender</kbd>.</p>
<p>This way, you don't need to have different <kbd>TCommands</kbd> classes for different types of extensions, and you can place the commands into a single central class regardless of where those commands are invoked from the UI.</p>
<p>As a result, the only changes that are required are as follows:</p>
<ul>
<li>Swapping calls to <kbd>AddToolBarExtension</kbd> with <kbd>AddMenuExtension</kbd></li>
<li class="mce-root">Creating a function that can be bound to <kbd>FMenuExtensionDelegate</kbd> rather than <kbd>FToolbarExtensionDelegate</kbd></li>
<li class="mce-root">Adding the extender to a Menu Extensibility Manager rather than a Toolbar Extensibility Manager</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new editor window</h1>
                
            
            
                
<p class="mce-root">Custom editor windows are useful when you have a new tool with user-configurable settings, or want to display some information to people using your customized editor. Ensure that you have have an editor module by following the recipe earlier in this chapter before you start. Read through either the <em>Creating new menu entries</em> or <em>Creating new toolbar buttons</em> recipes so that you can create a button within the editor that will launch our new window.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol start="1">
<li>Inside your command's bound function (in our case, the <kbd>MyButton_Clicked</kbd> function in the <kbd>FChapter_10EditorModule</kbd> class that's found in <kbd>Chapter_10Editor.h</kbd>), add the following code:</li>
</ol>
<pre style="padding-left: 60px">void MyButton_Clicked()<br/>{<br/>        <br/>    TSharedRef&lt;SWindow&gt; CookbookWindow = SNew(SWindow)<br/>        .Title(FText::FromString(TEXT("Cookbook Window")))<br/>        .ClientSize(FVector2D(800, 400))<br/>        .SupportsMaximize(false)<br/>        .SupportsMinimize(false)<br/>        <strong>[</strong><br/><strong>            SNew(SVerticalBox)</strong><br/><strong>            + SVerticalBox::Slot()</strong><br/><strong>        .HAlign(HAlign_Center)</strong><br/><strong>        .VAlign(VAlign_Center)</strong><br/><strong>        [</strong><br/><strong>            SNew(STextBlock)</strong><br/><strong>            .Text(FText::FromString(TEXT("Hello from Slate")))</strong><br/><strong>        ]</strong><br/><strong>        ]</strong>;<br/><br/>    IMainFrameModule&amp; MainFrameModule =<br/>        FModuleManager::LoadModuleChecked&lt;IMainFrameModule&gt;<br/>        (TEXT("MainFrame"));<br/><br/>    if (MainFrameModule.GetParentWindow().IsValid())<br/>    {<br/>        FSlateApplication::Get().AddWindowAsNativeChild<br/>        (CookbookWindow, MainFrameModule.GetParentWindow()<br/>            .ToSharedRef());<br/>    }<br/>    else<br/>    {<br/>        FSlateApplication::Get().AddWindow(CookbookWindow);<br/>    }<br/>        <br/>};</pre>
<p style="padding-left: 60px">Note that we removed the <kbd>;</kbd> at the end of the line stating <kbd>.SupportsMinimize(false)</kbd>.</p>
<ol start="2">
<li>Compile your code and launch the editor.</li>
</ol>
<ol start="3">
<li>When you activate the command you created, either by selecting the custom menu option or the toolbar option that you added, you should see that the window has been displayed with some centered text in the middle:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/4e289ce2-a243-402b-9d35-319f0b8f2801.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Your new editor window won't display itself, and so, at the start of this recipe, it is mentioned that you should have implemented a custom menu or toolbar button or a console command that we can use to trigger the display of our new window.</p>
<p>All of Slate's widgets are usually interacted with in the form of <kbd>TSharedRef&lt; &gt;</kbd> or <kbd>TSharedPtr&lt; &gt;</kbd>.</p>
<p>The <kbd>SNew()</kbd> function returns a <kbd>TSharedRef</kbd> that's been templated on the requested widget class.</p>
<p>As we mentioned previously, Slate widgets have a number of functions that they implement, which all return the object that the function was invoked on. This allows for method chaining to be used to configure the object at creation time.</p>
<p>This is what allows for the Slate syntax of <kbd>&lt;Widget&gt;.Property(Value).Property(Value)</kbd>.</p>
<p>The properties that are set on the widget in this recipe are the window title, the window size, and whether the window can be maximized and minimized.</p>
<p>Once all the requisite properties on a widget have been set, the bracket operators (<kbd>[]</kbd>) can be used to specify the content to be placed inside the widget, for example, a picture or label inside a button.</p>
<p><kbd>SWindow</kbd> is a top-level widget with only one slot for child widgets, so we don't need to add a slot for it ourselves. We place content into that slot by creating it inside the pair of brackets.</p>
<p>The content we create is <kbd>SVerticalBox</kbd>, which is a widget that can have an arbitrary number of slots for child widgets that are displayed in a vertical list.</p>
<p>For each widget we want to place into the vertical list, we need to create a <strong>slot</strong>.</p>
<p>The easiest way to do this is to use the overloaded <kbd>+</kbd> operator and the <kbd>SVerticalBox::Slot()</kbd> function.</p>
<p><kbd>Slot()</kbd> returns a widget like any other, so we can set properties on it like we did on our <kbd>SWindow</kbd>.</p>
<p>This recipe centers the Slot's content on both horizontal and vertical axes using <kbd>HAlign</kbd> and <kbd>VAlign</kbd>.</p>
<p>A <kbd>Slot</kbd> has a single child widget, and it's created inside the <kbd>[]</kbd> operators, just like they are for <kbd>SWindow</kbd>.</p>
<p>Inside the <kbd>Slot</kbd> content, we create a text block with some custom text.</p>
<p>Our new <kbd>SWindow</kbd> now has its child widgets added, but it isn't being displayed yet because it hasn't been added to the window hierarchy.</p>
<p>The main frame module is used to check if we have a top-level editor window, and if it exists, our new window is added as a child.</p>
<p>If there's no top-level window to be added as a child to, then we use the Slate Application singleton to add our window without a parent.</p>
<p>If you would like to see the hierarchy of the window we've created, you can use the Slate Widget Reflector, which can be accessed via Window | Developer Tools | Widget Reflector.</p>
<p>If you select Pick Painted Widget and hover your cursor over the text in the center of our custom window, you will be able to see the SWindow with our custom widgets added to its hierarchy:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0de07d76-1193-4fc5-ab7c-ed947a065605.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><a href="a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml">Chapter 11</a>, <em>Working with UE4 APIs</em>, is all about UI, and will show you how to add additional elements to your new custom window</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new Asset type</h1>
                
            
            
                
<p class="mce-root">At some point in your project, you might need to create a new custom Asset class, for example, an Asset to store conversation data in an RPG. To properly integrate these with Content Browser, you'll need to create a new Asset type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new C++ class based on <kbd>UObject</kbd> called <kbd>MyCustomAsset</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d4eb0573-b97d-4470-90e8-3627adcf9c0d.png"/></p>
<ol start="2">
<li>Open up the script and update the code of the <kbd>.h</kbd> file to the following:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/NoExportTypes.h"<br/>#include "MyCustomAsset.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_10_API UMyCustomAsset : public UObject<br/>{<br/>  GENERATED_BODY()<br/><br/><strong>public:</strong><br/><strong>    UPROPERTY(EditAnywhere, Category = "Custom Asset")</strong><br/><strong>    FString Name;</strong><br/>  <br/>};</pre>
<ol start="3">
<li>Next, create a class based on <kbd>UFactory</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e3e7c79e-3eeb-4cc4-a1e2-cd8e5371e942.png"/></p>
<ol start="4">
<li>Give the script a name of <kbd>CustomAssetFactory</kbd> and press the Create Class button.</li>
<li>Open the script in Visual Studio and update the <kbd>CustomAssetFactory.h</kbd> file to the following:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Factories/Factory.h"<br/>#include "CustomAssetFactory.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_10_API UCustomAssetFactory : public UFactory<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public:<br/>    UCustomAssetFactory();<br/><br/>    virtual UObject* FactoryCreateNew(UClass* InClass,<br/>        UObject* InParent, FName InName, EObjectFlags Flags,<br/>        UObject* Context, FFeedbackContext* Warn, FName<br/>        CallingContext) override;<br/>};<br/> </pre>
<ol start="6">
<li>Then, switch over to the <kbd>CustomAssetFactory.cpp</kbd> file and implement the class:</li>
</ol>
<pre style="padding-left: 60px">#include "CustomAssetFactory.h" <br/><strong>#include "Chapter_10.h"</strong><br/><strong>#include "MyCustomAsset.h" </strong><br/><br/><br/><strong>UCustomAssetFactory::UCustomAssetFactory()</strong><br/><strong>    :Super()</strong><br/><strong>{</strong><br/><strong>    bCreateNew = true;</strong><br/><strong>    bEditAfterNew = true;</strong><br/><strong>    SupportedClass = UMyCustomAsset::StaticClass();</strong><br/><strong>}</strong><br/><br/><strong>UObject* UCustomAssetFactory::FactoryCreateNew(UClass*</strong><br/><strong>    InClass, UObject* InParent, FName InName, EObjectFlags</strong><br/><strong>    Flags, UObject* Context, FFeedbackContext* Warn, FName</strong><br/><strong>    CallingContext)</strong><br/><strong>{</strong><br/><strong>    auto NewObjectAsset = NewObject&lt;UMyCustomAsset&gt;(InParent,</strong><br/><strong>        InClass, InName, Flags);</strong><br/><strong>    return NewObjectAsset;</strong><br/><strong>}</strong></pre>
<ol start="7">
<li>Compile your code and open the editor.</li>
</ol>
<ol start="8">
<li>Right-click in Content Browser, from the Content folder and, under the Miscellaneous tab of the Create Advanced Asset section, you should see your new class and be able to create instances of your new custom type:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/df0751b0-3259-47e3-b851-07fd9e1401ba.png" style="width:49.17em;height:56.75em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The first class is the actual object that can exist in the game at runtime. It's your texture, data file, or curve data – whatever you require.</p>
<p>For the purpose of this recipe, the simplest example is an asset that has an <kbd>FString</kbd> property to contain a name.</p>
<p>The property is marked as <kbd>UPROPERTY</kbd> so that it remains in memory, and additionally marked as <kbd>EditAnywhere</kbd> so that it is editable on both the default object and on instances of it.</p>
<p>The second class is <kbd>Factory</kbd>. Unreal uses the <kbd>Factory</kbd> design pattern to create instances of assets.</p>
<p>This means that there is a generic base <kbd>Factory</kbd> that uses virtual methods to declare the interface of object creation, and then <kbd>Factory</kbd> subclasses are responsible for creating the actual object in question.</p>
<p>The advantage of this approach is that the user-created subclass can potentially instantiate one of its own subclasses if required; it hides the implementation details regarding deciding which object to create away from the object requesting the creation.</p>
<p>With <kbd>UFactory</kbd> as our base class, we include the appropriate header.</p>
<p>The constructor is overridden, because there are a number of properties that we want to set for our new factory after the default constructor has run.</p>
<p><kbd>bCreateNew</kbd> signifies that the factory is currently able to create a new instance of the object in question from scratch.</p>
<p><kbd>bEditAfterNew</kbd> indicates that we would like to edit the newly created object immediately after creation.</p>
<p>The <kbd>SupportedClass</kbd> variable is an instance of <kbd>UClass</kbd> containing reflection information about the type of object the factory will create.</p>
<p>The most significant function of our <kbd>UFactory</kbd> subclass is the actual factory method – <kbd>FactoryCreateNew</kbd>.</p>
<p><kbd>FactoryCreateNew</kbd> is responsible for determining the type of object that should be created, and using <kbd>NewObject</kbd> to construct an instance of that type. It passes a number of parameters through to the <kbd>NewObject</kbd> call.</p>
<p><kbd>InClass</kbd> is the class of object that will be constructed. <kbd>InParent</kbd> is the object that should be containing the new object that will be created. If this isn't specified, the object is assumed to go into the transient package, which means that it won't be automatically saved. <kbd>Name</kbd> is the name of the object to be created. <kbd>Flags</kbd> is a bitmask of creation flags that control things such as making the object visible outside of the package it is contained in.</p>
<p>Within <kbd>FactoryCreateNew</kbd>, decisions can be made regarding which subclass should be instantiated. Other initialization can also be performed; for example, if there are sub-objects that require manual instantiation or initialization, they can be added here.</p>
<p>An example from the engine code for this function is as follows:</p>
<pre style="padding-left: 30px">UObject* UCameraAnimFactory::FactoryCreateNew(UClass* <br/> Class,UObject* InParent,FName Name,EObjectFlags <br/> Flags,UObject* Context,FFeedbackContext* Warn) 
{ 
  UCameraAnim* NewCamAnim = <br/>   NewObject&lt;UCameraAnim&gt;(InParent, Class, Name, Flags);  NewCamAnim-&gt;CameraInterpGroup = <br/>   NewObject&lt;UInterpGroupCamera&gt;(NewCamAnim); 
  NewCamAnim-&gt;CameraInterpGroup-&gt;GroupName = Name; 
  return NewCamAnim; 
} </pre>
<p>As we can see, there's a second call to <kbd>NewObject</kbd> to populate the <kbd>CameraInterpGroup</kbd> member of the <kbd>NewCamAnim</kbd> instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <em>Editing class properties in different places in the editor</em> recipe earlier in this chapter gives more context to the <kbd>EditAnywhere</kbd> property specifier</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating custom context menu entries for Assets</h1>
                
            
            
                
<p class="mce-root">Custom Asset types commonly have special functions you wish to be able to perform on them. For example, converting images into sprites is an option you wouldn't want to add to any other Asset type. You can create custom context menu entries for specific Asset types to make those functions accessible to users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>From the <kbd>Chapter_10Editor</kbd> folder, create two new files called <kbd>MyCustomAssetActions.h</kbd> and <kbd>MyCustomAssetActions.cpp</kbd>.</li>
<li>Return to your project file and update your Visual Studio project. Once finished, open up the project in Visual Studio.</li>
<li>Open <kbd>MyCustomAssetActions.h</kbd> and use the following code:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/>#include "AssetTypeActions_Base.h"<br/>#include "Editor/MainFrame/Public/Interfaces/IMainFrameModule.h"<br/><br/>class CHAPTER_10EDITOR_API FMyCustomAssetActions : public FAssetTypeActions_Base<br/>{<br/>public:<br/>    <br/>    virtual bool HasActions(const TArray&lt;UObject*&gt;&amp; InObjects)<br/>    const override;<br/><br/>    virtual void GetActions(const TArray&lt;UObject*&gt;&amp; InObjects,<br/>    FMenuBuilder&amp; MenuBuilder) override;<br/><br/>    virtual FText GetName() const override;<br/><br/>    virtual UClass* GetSupportedClass() const override;<br/><br/>    virtual FColor GetTypeColor() const override;<br/><br/>    virtual uint32 GetCategories() override;<br/><br/>    void MyCustomAssetContext_Clicked()<br/>    {<br/>        TSharedRef&lt;SWindow&gt; CookbookWindow = SNew(SWindow)<br/>            .Title(FText::FromString(TEXT("Cookbook Window")))<br/>            .ClientSize(FVector2D(800, 400))<br/>            .SupportsMaximize(false)<br/>            .SupportsMinimize(false);<br/><br/>        IMainFrameModule&amp; MainFrameModule = <br/>        FModuleManager::LoadModuleChecked&lt;IMainFrameModule&gt;<br/>        (TEXT("MainFrame"));<br/><br/>        if (MainFrameModule.GetParentWindow().IsValid())<br/>        {<br/>            FSlateApplication::Get().AddWindowAsNativeChild(CookbookWindow, <br/>            MainFrameModule.GetParentWindow().ToSharedRef());<br/>        }<br/>        else<br/>        {<br/>            FSlateApplication::Get().AddWindow(CookbookWindow);<br/>        }<br/><br/>    };<br/>};<br/><br/></pre>
<ol start="4">
<li>Open <kbd>MyCustomAssetActions.cpp</kbd> and add the following code:</li>
</ol>
<pre style="padding-left: 60px">#include "MyCustomAssetActions.h"<br/>#include "Chapter_10Editor.h"<br/>#include "MyCustomAsset.h"<br/><br/>bool FMyCustomAssetActions::HasActions(const TArray&lt;UObject*&gt;&amp; InObjects) const<br/>{<br/>  return true;<br/>}<br/><br/>void FMyCustomAssetActions::GetActions(const TArray&lt;UObject*&gt;&amp; InObjects, FMenuBuilder&amp; MenuBuilder)<br/>{<br/>  MenuBuilder.AddMenuEntry(<br/>    FText::FromString("CustomAssetAction"),<br/>    FText::FromString("Action from Cookbook Recipe"),<br/>    FSlateIcon(FEditorStyle::GetStyleSetName(),<br/>    "LevelEditor.ViewOptions"),<br/>    FUIAction(<br/>      FExecuteAction::CreateRaw(this, <br/>      &amp;FMyCustomAssetActions::MyCustomAssetContext_Clicked),<br/>      FCanExecuteAction()<br/>      ));<br/>}<br/><br/>uint32 FMyCustomAssetActions::GetCategories()<br/>{<br/>  return EAssetTypeCategories::Misc;<br/>}<br/><br/>FText FMyCustomAssetActions::GetName() const<br/>{<br/>  return FText::FromString(TEXT("My Custom Asset"));<br/>}<br/><br/>UClass* FMyCustomAssetActions::GetSupportedClass() const<br/>{<br/>  return UMyCustomAsset::StaticClass();<br/>}<br/><br/>FColor FMyCustomAssetActions::GetTypeColor() const<br/>{<br/>  return FColor::Emerald;<br/>}<br/><br/></pre>
<ol start="5">
<li>Open up the <kbd>Chapter_10Editor.h</kbd> file and add the following property to the class:</li>
</ol>
<pre>#pragma once<br/><br/>#include "Engine.h"<br/>#include "Modules/ModuleInterface.h"<br/>#include "Modules/ModuleManager.h"<br/>#include "UnrealEd.h"<br/>#include "CookbookCommands.h"<br/>#include "Editor/MainFrame/Public/Interfaces/IMainFrameModule.h"<br/><strong>#include "Developer/AssetTools/Public/IAssetTypeActions.h"</strong><br/><br/> class FChapter_10EditorModule: public IModuleInterface <br/>{ <br/>    virtual void StartupModule() override;<br/>    virtual void ShutdownModule() override;<br/><br/><strong>    TArray&lt; TSharedPtr&lt;IAssetTypeActions&gt; &gt; CreatedAssetTypeActions;</strong><br/><br/>    TSharedPtr&lt;FExtender&gt; ToolbarExtender;<br/>    TSharedPtr&lt;const FExtensionBase&gt; Extension;<br/><br/></pre>
<p>Don't forget to add the <kbd>#include</kbd> for <kbd>IAssetTypeActions.h</kbd>.</p>
<ol start="6">
<li>Within your editor module (<kbd>Chapter_10Editor.cpp</kbd>), add the following code to the <kbd>StartupModule()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px"><strong>#include "Developer/AssetTools/Public/IAssetTools.h"</strong><br/><strong>#include "Developer/AssetTools/Public/AssetToolsModule.h"</strong><br/><strong>#include "MyCustomAssetActions.h"</strong><br/>// ...<br/><br/>void FChapter_10EditorModule::StartupModule()<br/>{<br/>    <br/>    FCookbookCommands::Register();<br/>   <br/>    TSharedPtr&lt;FUICommandList&gt; CommandList = MakeShareable(new FUICommandList());<br/>    <br/>    CommandList-&gt;MapAction(FCookbookCommands::Get().MyButton, FExecuteAction::CreateRaw(this, &amp;FChapter_10EditorModule::MyButton_Clicked), FCanExecuteAction());<br/>    <br/>    <br/>    ToolbarExtender = MakeShareable(new FExtender());<br/><br/>    FLevelEditorModule&amp; LevelEditorModule = FModuleManager::LoadModuleChecked&lt;FLevelEditorModule&gt;("LevelEditor");<br/><br/><strong>    IAssetTools&amp; AssetTools = <br/>    FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;<br/>    ("AssetTools").Get();</strong><br/><br/><strong>    auto Actions = MakeShareable(new FMyCustomAssetActions);</strong><br/><strong>    AssetTools.RegisterAssetTypeActions(Actions);</strong><br/><strong>    CreatedAssetTypeActions.Add(Actions);</strong><br/>    <br/>}</pre>
<ol start="7">
<li>Add the following code inside the module's <kbd>ShutdownModule()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">void FChapter_10EditorModule::ShutdownModule()<br/>{<br/>    <br/>    ToolbarExtender-&gt;RemoveExtension(Extension.ToSharedRef());<br/>    <br/>    Extension.Reset();<br/>    ToolbarExtender.Reset();<br/><br/><strong>    </strong><strong>IAssetTools&amp; AssetTools = FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;("Asset Tools").Get(); </strong><br/><br/><strong> for (auto Action : CreatedAssetTypeActions)</strong><br/><strong> {</strong><br/><strong> AssetTools.UnregisterAssetTypeActions(Action.ToSharedRef());</strong><br/><strong> }</strong><br/>    <br/>}</pre>
<ol start="8">
<li>Compile your project and launch the editor.</li>
<li>Create an instance of your custom Asset inside the Content Browser by right-clicking and selecting Miscellaneous | My Custom Asset.</li>
</ol>
<ol start="10">
<li>Right-click on your new asset to see our custom command in the context menu:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ae13de6c-8e5e-4f38-8a0e-06ad7da16286.png" style="width:40.00em;height:48.17em;"/></p>
<ol start="11">
<li>Select the CustomAssetAction command to display a new blank editor window.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The base class for all asset type-specific context menu commands is <kbd>FAssetTypeActions_Base</kbd>, so we need to inherit from that class.</p>
<p><kbd>FAssetTypeActions_Base</kbd> is an abstract class that defines a number of virtual functions that allow us to extend the context menu. The interface that contains the original information for these virtual functions can be found in <kbd>IAssetTypeActions.h</kbd>.</p>
<p>We also declare a function that we bind to our custom context menu entry.</p>
<p><kbd>IAssetTypeActions::HasActions ( const TArray&lt;UObject*&gt;&amp; InObjects )</kbd> is the function that's called by the engine code to see if our <kbd>AssetTypeActions</kbd> class contains any actions that can be applied to the selected objects.</p>
<p><kbd>IAssetTypeActions::GetActions(const TArray&lt;UObject*&gt;&amp; InObjects, class FMenuBuilder&amp; MenuBuilder)</kbd> is called if the <kbd>HasActions</kbd> function returns <kbd>true</kbd>. It calls functions on <kbd>MenuBuilder</kbd> to create the menu options for the actions that we provide.</p>
<p><kbd>IAssetTypeActions::GetName()</kbd> returns the name of this class.</p>
<p><kbd>IAssetTypeActions::GetSupportedClass()</kbd> returns an instance of <kbd>UClass</kbd> that our actions class supports.</p>
<p><kbd>IAssetTypeActions::GetTypeColor()</kbd> returns the color associated with this class and actions.</p>
<p><kbd>IAssetTypeActions::GetCategories()</kbd> returns a category that's appropriate for the asset. This is used to change the category under which the actions show up in the context menu.</p>
<p>Our overridden implementation of <kbd>HasActions</kbd> simply returns <kbd>true</kbd> under all circumstances, and relies on filtering based on the results of <kbd>GetSupportedClass</kbd>.</p>
<p>Inside the implementation of <kbd>GetActions</kbd>, we can call some functions on the <kbd>MenuBuilder</kbd> object that we are given as a function parameter. The <kbd>MenuBuilder</kbd> is passed as a reference, so any changes that are made by our function will persist after it returns.</p>
<p><kbd>AddMenuEntry</kbd> has a number of parameters. The first parameter is the name of the action itself. This is the name that will be visible within the context menu. The name is an <kbd>FText</kbd> so that it can be localized should you wish. For the sake of simplicity, we construct <kbd>FText</kbd> from a string literal and don't concern ourselves with multiple language support.</p>
<p>The second parameter is also <kbd>FText</kbd>, which we construct by calling <kbd>FText::FromString</kbd>. This parameter is the text that's displayed in a tooltip if the user hovers over our command for more than a small period of time.</p>
<p>The next parameter is <kbd>FSlateIcon</kbd> for the command, which is constructed from the <kbd>LevelEditor.ViewOptions</kbd> icon within the editor style set.</p>
<p>The last parameter to this function is an <kbd>FUIAction</kbd> instance. The <kbd>FUIAction</kbd> is a wrapper around a delegate binding, so we use <kbd>FExecuteAction::CreateRaw</kbd> to bind the command to the <kbd>MyCustomAsset_Clicked</kbd> function on this very instance of <kbd>FMyCustomAssetActions</kbd>.</p>
<p>This means that when the menu entry is clicked, our <kbd>MyCustomAssetContext_Clicked</kbd> function will be run.</p>
<p>Our implementation of <kbd>GetName</kbd> returns the name of our Asset type. This string will be used on the thumbnail for our Asset if we don't set one ourselves, apart from being used in the title of the menu section that our custom Assets will be placed in.</p>
<p>As you'd expect, the implementation of <kbd>GetSupportedClass</kbd> returns <kbd>UMyCustomAsset::StaticClass()</kbd>, as this is the Asset type we want our actions to operate on.</p>
<p><kbd>GetTypeColor()</kbd> returns the color that will be used for color coding in Content Browser – the color is used in the bar at the bottom of the asset thumbnail. I've used Emerald here, but any arbitrary color will work.</p>
<p>The real workhorse of this recipe is the <kbd>MyCustomAssetContext_Clicked()</kbd> function.</p>
<p>The first thing that this function does is create a new instance of <kbd>SWindow</kbd>.</p>
<p><kbd>SWindow</kbd> is the Slate Window – a class from the Slate UI framework.</p>
<p>Slate Widgets are created using the <kbd>SNew</kbd> function, which returns an instance of the widget requested.</p>
<p>Slate uses the <kbd>builder</kbd> design pattern, which means that all of the functions that are <strong>chained</strong> after <kbd>SNew</kbd>, return a reference to the object that was being operated on.</p>
<p>In this function, we create our new <kbd>SWindow</kbd>, then set the window title, its client size or area, and whether it can be maximized or minimized.</p>
<p>With our new Window ready, we need to get a reference to the root window for the editor so that we can add our window to the hierarchy and get it displayed.</p>
<p>We do this using the <kbd>IMainFrameModule</kbd> class. It's a module, so we use the Module Manager to load it.</p>
<p><kbd>LoadModuleChecked</kbd> will assert if we can't load the module, so we don't need to check it.</p>
<p>If the module was loaded, we check that we have a valid parent window. If that window is valid, then we use <kbd>FSlateApplication::AddWindowAsNativeChild</kbd> to add our window as a child of the top-level parent window.</p>
<p>If we don't have a top-level parent, the function uses <kbd>AddWindow</kbd> to add the new window without parenting it to another window within the hierarchy.</p>
<p>So, now we have a class that will display custom actions on our custom Asset type, but what we actually need to do is tell the engine that it should ask our class to handle custom actions for the type. To do that, we need to register our class with the Asset Tools module.</p>
<p>The best way to do this is to register our class when our editor module is loaded, and unregister it when it is shut down.</p>
<p>As a result, we place our code into the <kbd>StartupModule</kbd> and <kbd>ShutdownModule</kbd> functions.</p>
<p>Inside <kbd>StartupModule</kbd>, we load the Asset Tools module using Module Manager.</p>
<p>With the module loaded, we create a new shared pointer that references an instance of our custom Asset actions class.</p>
<p>All we need to do then is call <kbd>AssetModule.RegisterAssetTypeActions</kbd> and pass in an instance of our actions class.</p>
<p>We then need to store a reference to that <kbd>Actions</kbd> instance so that we can unregister it later.</p>
<p>The sample code for this recipe uses an array of all the created asset actions in case we want to add custom actions for other classes as well.</p>
<p>Within <kbd>ShutdownModule</kbd>, we again retrieve an instance of the Asset Tools module.</p>
<p>Using a range-based for loop, we iterate over the array of <kbd>Actions</kbd> instances that we populated earlier and call <kbd>UnregisterAssetTypeActions</kbd>, passing in our <kbd>Actions</kbd> class so it can be unregistered.</p>
<p>With our class registered, the editor has been instructed to ask our registered class if it can handle assets that are right-clicked on.</p>
<p>If the asset is of the Custom Asset class, then its <kbd>StaticClass</kbd> will match the one returned by <kbd>GetSupportedClass</kbd>. The editor will then call <kbd>GetActions</kbd>, and display the menu with the alterations made by our implementation of that function.</p>
<p>When the <kbd>CustomAssetAction</kbd> button is clicked, our custom <kbd>MyCustomAssetContext_Clicked</kbd> function will be called via the delegate that we created.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating new console commands</h1>
                
            
            
                
<p class="mce-root">During development, console commands can be very helpful by allowing a developer or tester to easily bypass content or disable the mechanics that are irrelevant to the current test being run. The most common way to implement this is via console commands, which can invoke functions during runtime. The console can be accessed using the tilde key (<kbd>~</kbd>) or the equivalent in the upper-left area of the alphanumeric zone of your keyboard:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fc5a434d-25b5-4071-8ef7-bbbad9ac670c.jpg" style="width:41.58em;height:14.75em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p class="mce-root">If you haven't already followed the <em>Creating a new editor module</em> recipe, do so, as this recipe will need a place to initialize and register the console command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your editor module's header file (<kbd>Chapter_10Editor.h</kbd>) and add the following code:</li>
</ol>
<pre style="padding-left: 60px">class FChapter_10EditorModule: public IModuleInterface <br/>{ <br/>    virtual void StartupModule() override;<br/>    virtual void ShutdownModule() override;<br/><br/>    TArray&lt; TSharedPtr&lt;IAssetTypeActions&gt; &gt; CreatedAssetTypeActions;<br/><br/>    TSharedPtr&lt;FExtender&gt; ToolbarExtender;<br/>    TSharedPtr&lt;const FExtensionBase&gt; Extension;<br/><br/><strong>    IConsoleCommand* DisplayTestCommand;</strong><br/><strong>    IConsoleCommand* DisplayUserSpecifiedWindow;</strong></pre>
<ol start="2">
<li>Add the following code within the implementation of <kbd>StartupModule</kbd>:</li>
</ol>
<pre style="padding-left: 60px">DisplayTestCommand = IConsoleManager::Get().RegisterConsoleCommand(TEXT("DisplayTestCommandWindow"), TEXT("test"), FConsoleCommandDelegate::CreateRaw(this, &amp;FChapter_10EditorModule::DisplayWindow, FString(TEXT("Test Command Window"))), ECVF_Default);<br/><br/>    DisplayUserSpecifiedWindow = IConsoleManager::Get().RegisterConsoleCommand(TEXT("DisplayWindow"), TEXT("test"), FConsoleCommandWithArgsDelegate::CreateLambda(<br/>        [&amp;](const TArray&lt; FString &gt;&amp; Args)<br/>    {<br/>        FString WindowTitle;<br/>        for (FString Arg : Args)<br/>        {<br/>            WindowTitle += Arg;<br/>            WindowTitle.AppendChar(' ');<br/>        }<br/>        this-&gt;DisplayWindow(WindowTitle);<br/>    }<br/><br/>    ), ECVF_Default);</pre>
<ol start="3">
<li>Inside <kbd>ShutdownModule</kbd>, add the following code:</li>
</ol>
<pre style="padding-left: 60px">if(DisplayTestCommand)<br/>{<br/>    IConsoleManager::Get().UnregisterConsoleObject(DisplayTestCommand);<br/>    DisplayTestCommand = nullptr;<br/>}<br/><br/>if(DisplayUserSpecifiedWindow)<br/>{<br/>    IConsoleManager::Get().UnregisterConsoleObject(DisplayUserSpecifiedWindow);<br/>    DisplayUserSpecifiedWindow = nullptr;<br/>}</pre>
<ol start="4">
<li>Implement the following function in the editor module (<kbd>Chapter_10Editor.h</kbd>):</li>
</ol>
<pre style="padding-left: 60px">void DisplayWindow(FString WindowTitle) 
{ 
  TSharedRef&lt;SWindow&gt; CookbookWindow = SNew(SWindow) 
  .Title(FText::FromString(WindowTitle)) 
  .ClientSize(FVector2D(800, 400)) 
  .SupportsMaximize(false) 
  .SupportsMinimize(false); 
  IMainFrameModule&amp; MainFrameModule = <br/>   FModuleManager::LoadModuleChecked&lt;IMainFrameModule&gt;<br/>   (TEXT("MainFrame")); 
  if (MainFrameModule.GetParentWindow().IsValid()) 
  { 
    FSlateApplication::Get().AddWindowAsNativeChild<br/>     (CookbookWindow, MainFrameModule.GetParentWindow()<br/>     .ToSharedRef()); 
  } 
  else 
  { 
    FSlateApplication::Get().AddWindow(CookbookWindow); 
  } 
}</pre>
<ol start="5">
<li>Compile your code and launch the editor.</li>
<li>Play the level, and then hit the tilde key to bring up the console.</li>
<li>Type <kbd>DisplayTestCommandWindow</kbd> and hit <em>Enter</em>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/639eb05b-4ada-4f76-96ed-3e94259015d3.png" style="width:43.50em;height:21.42em;"/></p>
<ol start="8">
<li>You should see our tutorial window open up:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f08671c4-aad4-4102-85ab-e0906f8a10ca.jpg" style="width:48.50em;height:26.08em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Console commands are usually provided by a module. The best way to get the module to create the command when it is loaded is to place the code in the <kbd>StartupModule</kbd> method.</p>
<p><kbd>IConsoleManager</kbd> is the module that contains the console functionality for the engine.</p>
<p>As it is a sub-module of the core module, we don't need to add any additional information to the build scripts to link in additional modules.</p>
<p>To call functions within the console manager, we need to get a reference to the current instance of <kbd>IConsoleManager</kbd> that is being used by the engine. To do so, we invoke the static <kbd>Get</kbd> function, which returns a reference to the module in a similar way to a singleton.</p>
<p><kbd>RegisterConsoleCommand</kbd> is the function that we can use to add a new console command and make it available in the console:</p>
<pre>virtual IConsoleCommand* RegisterConsoleCommand(const <br/> TCHAR* Name, const TCHAR* Help, const <br/> FConsoleCommandDelegate&amp; Command, uint32 Flags);</pre>
<p>The parameters for the function are as follows:</p>
<ul>
<li class="mce-root"><kbd>Name</kbd>: The actual console command that will be typed by users. It should not include spaces.</li>
<li class="mce-root"><kbd>Help</kbd>: The tooltip that appears when users are looking at the command in the console. If your console command takes arguments, this is a good place to display usage information to users.</li>
<li class="mce-root"><kbd>Command</kbd>: This is the actual function delegate that will be executed when the user types in the command.</li>
<li class="mce-root"><kbd>Flags</kbd>: These flags control the visibility of the command in a shipping build, and are also used for console variables. <kbd>ECVF_Default</kbd> specifies the default behavior wherein the command is visible, and has no restrictions on availability in a release build.</li>
</ul>
<p>To create an instance of the appropriate delegate, we use the <kbd>CreateRaw</kbd> static function on the <kbd>FConsoleCommand</kbd> delegate type. This lets us bind a raw C++ function to the delegate. The extra argument that is supplied after the function reference, the <kbd>FString</kbd><kbd>"Test Command Window"</kbd>, is a compile-time defined parameter that is passed to the delegate so that the end user doesn't have to specify the window name.</p>
<p>The second console command, <kbd>DisplayUserSpecifiedWindow</kbd>, is one that demonstrates the use of arguments with console commands.</p>
<p>The primary difference with this console command, aside from the different name for users to invoke it, is the use of <kbd>FConsoleCommandWithArgsDelegate</kbd> and the <kbd>CreateLambda</kbd> function on it in particular.</p>
<p>This function allows us to bind an anonymous function to a delegate. It's particularly handy when you want to wrap or adapt a function so that its signature matches that of a particular delegate.</p>
<p>In our particular use case, the type of <kbd>FConsoleCommandWithArgsDelegate</kbd> specifies that the function should take a <kbd>const TArray</kbd> of <kbd>FStrings</kbd>. Our <kbd>DisplayWindow</kbd> function takes a single <kbd>FString</kbd> to specify the window title, so we need to somehow concatenate all the arguments of the console command into a single <kbd>FString</kbd> to use as our window title.</p>
<p>The lambda function allows us to do that before passing the <kbd>FString</kbd> onto the actual <kbd>DisplayWindow</kbd> function.</p>
<p>The first line of the function, <kbd>[&amp;](const TArray&lt;FString&gt;&amp; Args)</kbd>, specifies that this lambda or anonymous function wants to capture the context of the declaring function by reference by including the ampersand in the capture options, <kbd>[&amp;]</kbd>.</p>
<p>The second part is the same as a normal function declaration, specifying that our lambda takes in <kbd>const Tarray</kbd>, which contains an FString as a parameter called <kbd>Args</kbd>.</p>
<p>Within the lambda body, we create a new <kbd>FString</kbd> and concatenate the strings that make up our arguments together, adding a space between them to separate them so that we don't get a title without spaces.</p>
<p>It uses a range-based <kbd>for</kbd> loop for brevity to loop over them all and perform the concatenation.</p>
<p class="mce-root"/>
<p>Once they're all concatenated, we use the <kbd>this</kbd> pointer (captured by the <kbd>&amp;</kbd> operator we mentioned earlier) to invoke <kbd>DisplayWindow</kbd> with our new title.</p>
<p>For our module to remove the console command when it is unloaded, we need to maintain a reference to the console command object.</p>
<p>To achieve this, we create a member variable in the module of type <kbd>IConsoleCommand*</kbd>, called <kbd>DisplayTestCommand</kbd>. When we execute the <kbd>RegisterConsoleCommand</kbd> function, it returns a pointer to the console command object that we can use as a handle later.</p>
<p>This allows us to enable or disable console commands at runtime based on gameplay or other factors.</p>
<p>Within <kbd>ShutdownModule</kbd>, we check to see if <kbd>DisplayTestCommand</kbd> refers to a valid console command object. If it does, we get a reference to the <kbd>IConsoleManager</kbd> object and call <kbd>UnregisterConsoleCommand</kbd>, passing in the pointer that we stored earlier in our call to <kbd>RegisterConsoleCommand</kbd>.</p>
<p>The call to <kbd>UnregisterConsoleCommand</kbd> deletes the <kbd>IConsoleCommand</kbd> instance via the passed-in pointer, so we don't need to <kbd>deallocate</kbd> the memory ourselves – we just reset <kbd>DisplayTestCommand</kbd> to <kbd>nullptr</kbd> so that we can be sure that the old pointer doesn't dangle.</p>
<p>The <kbd>DisplayWindow</kbd> function takes in the window title as an <kbd>FString</kbd> parameter. This allows us to either use a console command that takes arguments to specify the title, or a console command that uses payload parameters to hard-code the title for other commands.</p>
<p>The function itself uses a function called <kbd>SNew()</kbd> to allocate and create an <kbd>SWindow</kbd> object.</p>
<p><kbd>SWindow</kbd> is a Slate Window, a top-level window that uses the Slate UI framework.</p>
<p>Slate uses the <kbd>Builder</kbd> design pattern to allow for easy configuration of the new window.</p>
<p>The <kbd>Title</kbd>, <kbd>ClientSize</kbd>, <kbd>SupportsMaximize</kbd>, and <kbd>SupportsMinimize</kbd> functions that are used here are all member functions of <kbd>SWindow</kbd>, and they return a reference to an <kbd>SWindow</kbd> (usually, the same object that the method was invoked on, but sometimes, a new object is constructed with the new configuration).</p>
<p>The fact that all these member methods return a reference to the configured object allows us to chain these method invocations together to create the desired object in the right configuration.</p>
<p>The functions used in <kbd>DisplayWindow</kbd> create a new top-level Window that has a title based on the function parameter. It is 800 x 400 pixels wide, and cannot be maximized or minimized.</p>
<p>With our new Window created, we retrieve a reference to the main application frame module. If the top-level window for the editor exists and is valid, we add our new window instance as a child of that top-level window.</p>
<p>To do this, we retrieve a reference to the Slate interface and call <kbd>AddWindowAsNativeChild</kbd> to insert our window in the hierarchy.</p>
<p>If there isn't a valid top-level window, we don't need to add our new window as a child of anything, so we can simply call <kbd>AddWindow</kbd> and pass in our new window instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Refer to <a href="cf821ef4-8a19-440c-805d-573748b76d5f.xhtml">Chapter 5</a>, <em>Handling Events and Delegates</em>, to learn more about delegates. It explains payload variables in greater detail.</li>
<li>For more information on Slate, refer to <a href="a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml">Chapter 11</a>, <em>Working with UE4 APIs</em>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new graph pin visualizer for Blueprint</h1>
                
            
            
                
<p class="mce-root">Within the Blueprint system, we can use instances of our <kbd>MyCustomAsset</kbd> class as variables, provided we mark that class as a <kbd>BlueprintType</kbd> in its <kbd>UCLASS</kbd> macro. However, by default, our new asset is simply treated as a <kbd>UObject</kbd>, and we can't access any of its members:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/71c51dd0-1db5-4ab5-9c9e-45a433e1f2fd.jpg" style="width:18.42em;height:13.67em;"/></p>
<p class="mce-root">For some types of assets, we might wish to enable in-line editing of literal values in the same way that classes such as <kbd>FVector</kbd> support the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d2f07c2a-77ee-4333-aec6-47facbe0b76f.jpg" style="width:18.92em;height:13.00em;"/></p>
<p class="mce-root">To enable this, we need to use a <strong>Graph Pin</strong> visualizer. This recipe will show you how to enable in-line editing of an arbitrary type using a custom widget defined by you.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>First, we will update the <kbd>MyCustomAsset</kbd> class to be editable in Blueprints and reflect what we'll be doing in this recipe. Go to <kbd>MyCustomAsset.h</kbd> and update it to the following code:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/NoExportTypes.h"<br/>#include "MyCustomAsset.generated.h"<br/><br/><br/>UCLASS(<strong>BlueprintType, EditInlineNew</strong>)<br/>class CHAPTER_10_API UMyCustomAsset : public UObject<br/>{<br/>  GENERATED_BODY()<br/><br/>public:<br/>    UPROPERTY(<strong>BlueprintReadWrite,</strong> EditAnywhere, Category = "Custom Asset")<br/>    FString <strong>Color</strong>Name;<br/>  <br/>};</pre>
<ol start="2">
<li>From the <kbd>Chapter_10Editor</kbd> folder, create a new file called <kbd>MyCustomAssetPinFactory.h</kbd> .</li>
<li>Inside the header, add the following code:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/>#include "EdGraphUtilities.h"<br/>#include "MyCustomAsset.h"<br/>#include "SGraphPinCustomAsset.h"<br/><br/><br/>struct CHAPTER_10EDITOR_API FMyCustomAssetPinFactory : public FGraphPanelPinFactory<br/>{<br/>public:<br/>  virtual TSharedPtr&lt;class SGraphPin&gt; CreatePin(class UEdGraphPin* Pin) const override <br/>  {<br/>    if (Pin-&gt;PinType.PinSubCategoryObject == UMyCustomAsset::StaticClass())<br/>    {<br/>      return SNew(SGraphPinCustomAsset, Pin);<br/>    }<br/>    else<br/>    {<br/>      return nullptr;<br/>    }<br/>  };<br/>};<br/><br/><br/></pre>
<ol start="4">
<li>Create another header file called <kbd>SGraphPinCustomAsset.h</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/>#include "SGraphPin.h"<br/><br/><br/>class CHAPTER_10EDITOR_API SGraphPinCustomAsset : public SGraphPin<br/>{<br/>  SLATE_BEGIN_ARGS(SGraphPinCustomAsset) {}<br/>  SLATE_END_ARGS()<br/><br/>  void Construct(const FArguments&amp; InArgs, UEdGraphPin* InPin);<br/>protected:<br/>  virtual FSlateColor GetPinColor() const override { return FSlateColor(FColor::Black); };<br/><br/>  virtual TSharedRef&lt;SWidget&gt; GetDefaultValueWidget() override;<br/>  <br/>  void ColorPicked(FLinearColor SelectedColor);<br/>};<br/><br/></pre>
<ol start="5">
<li>Implement <kbd>SGraphPinCustomAsset</kbd> by creating the <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "SGraphPinCustomAsset.h"<br/>#include "Chapter_10Editor.h"<br/>#include "SColorPicker.h"<br/>#include "MyCustomAsset.h"<br/><br/>void SGraphPinCustomAsset::Construct(const FArguments&amp; InArgs, UEdGraphPin* InPin)<br/>{<br/>  SGraphPin::Construct(SGraphPin::FArguments(), InPin);<br/>}<br/><br/>TSharedRef&lt;SWidget&gt; SGraphPinCustomAsset::GetDefaultValueWidget()<br/>{<br/>  return SNew(SColorPicker)<br/>    .OnColorCommitted(this, &amp;SGraphPinCustomAsset::ColorPicked);<br/><br/>}<br/><br/>void SGraphPinCustomAsset::ColorPicked(FLinearColor SelectedColor)<br/>{<br/>  UMyCustomAsset* NewValue = NewObject&lt;UMyCustomAsset&gt;();<br/>  NewValue-&gt;ColorName = SelectedColor.ToFColor(false).ToHex();<br/>  GraphPinObj-&gt;GetSchema()-&gt;TrySetDefaultObject(*GraphPinObj, NewValue);<br/>}</pre>
<ol start="6">
<li>Regenerate your Visual Studio project.</li>
<li>Add <kbd>#include "MyCustomAssetPinFactory.h"</kbd> to the <kbd>Chapter_10Editor.h</kbd> module implementation file.</li>
<li>Add the following member to the editor module class (<kbd>FChapter_10EditorModule</kbd>):</li>
</ol>
<pre style="padding-left: 60px">TSharedPtr&lt;FMyCustomAssetPinFactory&gt; PinFactory; </pre>
<ol start="9">
<li>Open <kbd>Chapter_10Editor.cpp</kbd> and then add the following to <kbd>StartupModule()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">PinFactory = MakeShareable(new FMyCustomAssetPinFactory()); 
FEdGraphUtilities::RegisterVisualPinFactory(PinFactory); </pre>
<ol start="10">
<li>Also add the following code to <kbd>ShutdownModule()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">FEdGraphUtilities::UnregisterVisualPinFactory(PinFactory); PinFactory.Reset(); </pre>
<ol start="11">
<li>Compile your code and launch the editor.</li>
<li>Create a new Function inside of the Level Blueprint by clicking on the plus symbol beside Functions within the My Blueprint panel:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c9415a2e-d1eb-406e-b064-ae473029c34d.png"/></p>
<ol start="13">
<li>Add an input parameter:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d9209b56-9fbb-400f-b97a-42fa2ba9a246.png" style="width:42.58em;height:21.00em;"/></p>
<ol start="14">
<li>Set its type to <kbd>MyCustomAsset</kbd> (Object Reference):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f5d2f5e2-1f18-45ea-b6bd-31ee1db119c9.png" style="width:42.00em;height:27.83em;"/></p>
<ol start="15">
<li>In the Level Blueprint's Event Graph, place an instance of your new function and verify that the input pin now has a custom visualizer in the form of a color picker:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/779d7694-622f-4cd8-94ec-acdf6fffbc5c.png"/></p>
<p>Newly added color picker visualizer</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Customizing how objects appear as literal values on Blueprint pins is done using the <kbd>FGraphPanelPinFactory</kbd> class.</p>
<p>This class defines a single virtual function:</p>
<pre>virtual TSharedPtr&lt;class SGraphPin&gt; CreatePin(class <br/> UEdGraphPin* Pin) const</pre>
<p>The function of <kbd>CreatePin</kbd>, as the name implies, is to create a new visual representation of the graph pin.</p>
<p>It receives a <kbd>UEdGraphPin</kbd> instance. <kbd>UEdGraphPin</kbd> contains information about the object that the pin represents so that our factory class can make an informed decision regarding which visual representation we should be displaying.</p>
<p>Within our implementation of the function, we check that the pin's type is our custom class.</p>
<p>We do this by looking at the <kbd>PinSubCategoryObject</kbd> property, which contains a <kbd>UClass</kbd>, and comparing it to the <kbd>UClass</kbd> associated with our custom asset class.</p>
<p>If the pin's type meets our conditions, we return a new shared pointer to a Slate Widget, which is the visual representation of our object.</p>
<p>If the pin is of the wrong type, we return a null pointer to indicate a failed state.</p>
<p>The next class, <kbd>SGraphPinCustomAsset</kbd>, is the Slate Widget class, which is a visual representation of our object as a literal.</p>
<p>It inherits from <kbd>SGraphPin</kbd>, the base class for all graph pins.</p>
<p>The <kbd>SGraphPinCustomAsset</kbd> class has a <kbd>Construct</kbd> function, which is called when the widget is created.</p>
<p>It also implements some functions from the parent class: <kbd>GetPinColor()</kbd> and <kbd>GetDefaultValueWidget()</kbd>.</p>
<p>The last function that is defined is <kbd>ColorPicked</kbd>, a handler for when a user selects a color in our custom pin.</p>
<p>In the implementation of our custom class, we initialize our custom pin by calling the default implementation of <kbd>Construct</kbd>.</p>
<p>The role of <kbd>GetDefaultValueWidget</kbd> is to actually create the widget that is the custom representation of our class, and return it to the engine code.</p>
<p>In our implementation, it creates a new <kbd>SColorPicker</kbd> instance – we want the user to be able to select a color and store the hex-based representation of that color inside the <kbd>FString</kbd> property in our custom class.</p>
<p>This <kbd>SColorPicker</kbd> instance has a property called <kbd>OnColorCommitted</kbd> – this is a slate event that can be assigned to a function on an object instance.</p>
<p>Before returning our new <kbd>SColorPicker</kbd>, we link <kbd>OnColorCommitted</kbd> to the <kbd>ColorPicked</kbd> function on this current object so that it will be called if the user selects a new color.</p>
<p>The <kbd>ColorPicked</kbd> function receives the selected color as an input parameter.</p>
<p>Because this widget is used when there's no object connected to the pin we are associated with, we can't simply set the property on the associated object to the desired color string.</p>
<p>We need to create a new instance of our custom asset class, and we do that by using the <kbd>NewObject</kbd> template function.</p>
<p>This function behaves similarly to the <kbd>SpawnActor</kbd> function we discussed in other chapters, and initializes a new instance of the specified class before returning a pointer to it.</p>
<p>With a new instance in hand, we can set its <kbd>ColorName</kbd> property. <kbd>FLinearColors</kbd> can be converted into <kbd>FColor</kbd> objects, which define a <kbd>ToHex()</kbd> function that returns an <kbd>FString</kbd> with the hexadecimal representation of the color that was selected on the new widget.</p>
<p>Finally, we need to actually place our new object instance into the graph so that it will be referenced when the graph is executed.</p>
<p>To achieve this, we need to access the graph pin object that we represent, and use the <kbd>GetSchema</kbd> function. This function returns the Schema for the graph that owns the node that contains our pin.</p>
<p>The Schema contains the actual values that correspond to graph pins, and is a key element during graph evaluation.</p>
<p>Now that we have access to the Schema, we can set the default value for the pin that our widget represents. This value will be used during graph evaluation if the pin isn't connected to another pin, and acts like a default value that's provided during a function definition in C++.</p>
<p>As with all the extensions we've made in this chapter, there has to be some sort of initialization or registration to tell the engine to defer to our custom implementation before using its default inbuilt representation.</p>
<p>To do this, we need to add a new member to our editor module to store our <kbd>PinFactory</kbd> class instance.</p>
<p>During <kbd>StartupModule</kbd>, we create a new shared pointer that references an instance of our <kbd>PinFactory</kbd> class.</p>
<p>We store it inside the editor module's member so that it can be unregistered later. Then, we call <kbd>FEdGraphUtilities::RegisterVisualPinFactory(PinFactory)</kbd> to tell the engine to use our <kbd>PinFactory</kbd> to create the visual representation.</p>
<p>During <kbd>ShutdownModule</kbd>, we unregister the pin factory using <kbd>UnregisterVisualPinFactory</kbd>.</p>
<p>Finally, we delete our old <kbd>PinFactory</kbd> instance by calling <kbd>Reset()</kbd> on the shared pointer that contains it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inspecting types with custom Details panels</h1>
                
            
            
                
<p class="mce-root">By default, <kbd>UObject</kbd>-derived UAssets open in the generic property editor. It looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1cd21451-0090-40c5-b897-5525655f98ee.png" style="width:35.25em;height:17.25em;"/></p>
<p class="mce-root">However, at times, you may wish for custom widgets so that you can edit the properties on your class. To facilitate this, Unreal supports <strong>Details Customization</strong>, which is the focus of this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>From the <kbd>Chapter_10Editor</kbd> folder, create two new files called <kbd>MyCustomAssetDetailsCustomization.h</kbd> and <kbd>MyCustomAssetDetailsCustomization.cpp</kbd>.</li>
<li>Return to your project file and update your Visual Studio project. Once finished, open up the project in Visual Studio.</li>
<li>Add the following <kbd>#pragma</kbd> and <kbd>#includes</kbd> to the header (<kbd>MyCustomAssetDetailsCustomization.h</kbd>):</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "MyCustomAsset.h" 
#include "DetailLayoutBuilder.h" 
#include "IDetailCustomization.h" 
#include "IPropertyTypeCustomization.h" </pre>
<ol start="4">
<li>Define our customization class, as follows:</li>
</ol>
<pre style="padding-left: 60px">class FMyCustomAssetDetailsCustomization : public IDetailCustomization<br/>{<br/><br/>public:<br/>    virtual void CustomizeDetails(IDetailLayoutBuilder&amp; DetailBuilder) override;<br/><br/>    void ColorPicked(FLinearColor SelectedColor);<br/>    <br/>    static TSharedRef&lt;IDetailCustomization&gt; MakeInstance()<br/>    {<br/>        return MakeShareable(new FMyCustomAssetDetailsCustomization);<br/>    }<br/>    <br/>    TWeakObjectPtr&lt;class UMyCustomAsset&gt; MyAsset;<br/>};</pre>
<ol start="5">
<li>Below that, define the following additional class:</li>
</ol>
<pre style="padding-left: 60px">class FMyCustomAssetPropertyDetails : public IPropertyTypeCustomization<br/>{<br/>public:<br/>  void ColorPicked(FLinearColor SelectedColor);<br/>  static TSharedRef&lt;IPropertyTypeCustomization&gt; MakeInstance()<br/>  {<br/>    return MakeShareable(new FMyCustomAssetPropertyDetails);<br/>  }<br/><br/>  UMyCustomAsset* MyAsset;<br/>  virtual void CustomizeChildren(TSharedRef&lt;IPropertyHandle&gt; PropertyHandle, IDetailChildrenBuilder&amp; ChildBuilder, IPropertyTypeCustomizationUtils&amp; CustomizationUtils) override;<br/><br/>  virtual void CustomizeHeader(TSharedRef&lt;IPropertyHandle&gt; PropertyHandle, FDetailWidgetRow&amp; HeaderRow, IPropertyTypeCustomizationUtils&amp; CustomizationUtils) override;<br/><br/>};</pre>
<ol start="6">
<li>In the implementation file, add the following includes at the top of the file:</li>
</ol>
<pre style="padding-left: 60px">#include "MyCustomAssetDetailsCustomization.h" <br/>#include "Chapter_10Editor.h" <br/>#include "IDetailsView.h" <br/>#include "DetailLayoutBuilder.h" <br/>#include "DetailCategoryBuilder.h" <br/>#include "SColorPicker.h" <br/>#include "SBoxPanel.h" <br/>#include "DetailWidgetRow.h" </pre>
<ol start="7">
<li>Afterwards, create an implementation for <kbd>CustomizeDetails</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void FMyCustomAssetDetailsCustomization::CustomizeDetails(IDetailLayoutBuilder&amp; DetailBuilder)<br/>{<br/>    const TArray&lt; TWeakObjectPtr&lt;UObject&gt; &gt;&amp; SelectedObjects = DetailBuilder.GetDetailsView()-&gt;GetSelectedObjects();<br/><br/>    for (int32 ObjectIndex = 0; !MyAsset.IsValid() &amp;&amp; ObjectIndex &lt; SelectedObjects.Num(); ++ObjectIndex)<br/>    {<br/>        const TWeakObjectPtr&lt;UObject&gt;&amp; CurrentObject = SelectedObjects[ObjectIndex];<br/>        if (CurrentObject.IsValid())<br/>        {<br/>            MyAsset = Cast&lt;UMyCustomAsset&gt;(CurrentObject.Get());<br/>        }<br/>    }<br/><br/>    DetailBuilder.EditCategory("CustomCategory", FText::GetEmpty(), ECategoryPriority::Important)<br/>.AddCustomRow(FText::GetEmpty())<br/>    [<br/>    SNew(SVerticalBox)<br/>    + SVerticalBox::Slot()<br/>    .VAlign(VAlign_Center)<br/>        [<br/>            SNew(SColorPicker)<br/>            .OnColorCommitted(this, &amp;FMyCustomAssetDetailsCustomization::ColorPicked)<br/>        ]<br/>    ];<br/>}</pre>
<ol start="8">
<li>Also, create a definition for <kbd>ColorPicked</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void FMyCustomAssetDetailsCustomization::ColorPicked(FLinearColor SelectedColor)<br/>{<br/>    if (MyAsset.IsValid())<br/>    {<br/>        MyAsset.Get()-&gt;ColorName = SelectedColor.ToFColor(false).ToHex();<br/>    }<br/>}</pre>
<ol start="9">
<li>Beneath all of the scripts in <kbd>MyCustomAssetDetailsCustomization.cpp</kbd>, add the following code: </li>
</ol>
<pre style="padding-left: 60px">void FMyCustomAssetPropertyDetails::CustomizeChildren(TSharedRef&lt;IPropertyHandle&gt; PropertyHandle, IDetailChildrenBuilder&amp; ChildBuilder, IPropertyTypeCustomizationUtils&amp; CustomizationUtils)<br/>{<br/>}<br/><br/>void FMyCustomAssetPropertyDetails::CustomizeHeader(TSharedRef&lt;IPropertyHandle&gt; PropertyHandle, FDetailWidgetRow&amp; HeaderRow, IPropertyTypeCustomizationUtils&amp; CustomizationUtils)<br/>{<br/>    UObject* PropertyValue = nullptr;<br/>    auto GetValueResult = PropertyHandle-&gt;GetValue(PropertyValue);<br/><br/>    HeaderRow.NameContent()<br/>        [<br/>            PropertyHandle-&gt;CreatePropertyNameWidget()<br/>        ];<br/>    HeaderRow.ValueContent()<br/>        [<br/>            SNew(SVerticalBox)<br/>            + SVerticalBox::Slot()<br/>        .VAlign(VAlign_Center)<br/>        [<br/>            SNew(SColorPicker)<br/>            .OnColorCommitted(this, &amp;FMyCustomAssetPropertyDetails::ColorPicked)<br/>        ]<br/>        ];<br/>}<br/><br/>void FMyCustomAssetPropertyDetails::ColorPicked(FLinearColor SelectedColor)<br/>{<br/>    if (MyAsset)<br/>    {<br/>        MyAsset-&gt;ColorName = SelectedColor.ToFColor(false).ToHex();<br/>    }<br/>}</pre>
<ol start="10">
<li>In our editor module source file (<kbd>Chapter_10Editor.cpp</kbd>), add the following to your <kbd>#includes</kbd> in the <kbd>Chapter_10Editor.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "PropertyEditorModule.h" <br/>#include "MyCustomAssetDetailsCustomization.h"<br/>#include "MyCustomAssetPinFactory.h"</pre>
<ol start="11">
<li>Add the following to the implementation of <kbd>StartupModule</kbd>:</li>
</ol>
<pre style="padding-left: 60px">FPropertyEditorModule&amp; PropertyModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;("PropertyEditor");<br/>PropertyModule.RegisterCustomClassLayout(UMyCustomAsset::StaticClass()-&gt;GetFName(), FOnGetDetailCustomizationInstance::CreateStatic(&amp;FMyCustomAssetDetailsCustomization::MakeInstance));<br/>PropertyModule.RegisterCustomPropertyTypeLayout(UMyCustomAsset::StaticClass()-&gt;GetFName(), FOnGetPropertyTypeCustomizationInstance::CreateStatic(&amp;FMyCustomAssetPropertyDetails::MakeInstance));</pre>
<ol start="12">
<li>Add the following to <kbd>ShutdownModule</kbd>:</li>
</ol>
<pre style="padding-left: 60px">FPropertyEditorModule&amp; PropertyModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;("PropertyEditor");<br/>PropertyModule.UnregisterCustomClassLayout(UMyCustomAsset::StaticClass()-&gt;GetFName());</pre>
<ol start="13">
<li>Compile your code and launch the editor. Create a new instance of <kbd>MyCustomAsset</kbd> via the Content Browser.</li>
<li>Double-click on it to verify that the default editor that comes up now shows your custom layout:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/27a2b2cf-7c4b-45ba-a188-6e3894e6c8e3.png" style="width:38.58em;height:36.00em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Details Customization is performed through the <kbd>IDetailCustomization</kbd> interface, which developers can inherit when defining a class that customizes the way assets of a certain class are displayed.</p>
<p>The main function that <kbd>IDetailCustomization</kbd> uses to allow for this process to occur is as follows:</p>
<pre>virtual void CustomizeDetails(IDetailLayoutBuilder&amp; DetailBuilder) override;</pre>
<p>Within our implementation of this function, we use methods on <kbd>DetailBuilder</kbd> that are passed in as parameters to get an array of all selected objects. The loop then scans those to ensure that at least one selected object is of the correct type.</p>
<p>Customizing the representation of a class is done by calling methods on the <kbd>DetailBuilder</kbd> object. We create a new category for our details view by using the <kbd>EditCategory</kbd> function.</p>
<p>The first parameter of the <kbd>EditCategory</kbd> function is the name of the category we are going to manipulate.</p>
<p>The second parameter is optional, and contains a potentially localized display name for the category.</p>
<p>The third parameter is the priority of the category. A higher priority means it is displayed further up the list.</p>
<p><kbd>EditCategory</kbd> returns a reference to the category itself as <kbd>CategoryBuilder</kbd>, allowing us to chain additional method calls onto an invocation of <kbd>EditCategory</kbd>.</p>
<p>As a result, we call <kbd>AddCustomRow()</kbd> on <kbd>CategoryBuilder</kbd>, which adds a new key-value pair to be displayed in the category.</p>
<p>Using the Slate syntax, we then specify that the row will contain a Vertical Box with a single center-aligned slot.</p>
<p>Inside the slot, we create a color picker control and bind its <kbd>OnColorCommitted</kbd> delegate to our local <kbd>ColorPicked</kbd> event handler.</p>
<p>Of course, this requires us to define and implement <kbd>ColourPicked</kbd>. It has the following signature:</p>
<pre>void FMyCustomAssetDetailsCustomization::ColorPicked(FLinearColor SelectedColor)</pre>
<p>Inside the implementation of <kbd>ColorPicked</kbd>, we check to see if one of our selected assets was of the correct type, because, if at least one selected asset was correct, then <kbd>MyAsset</kbd> will be populated with a valid value.</p>
<p>Assuming we have a valid asset, we set the <kbd>ColorName</kbd> property to the hex string value corresponding to the color that was selected by the user.</p>


            

            
        
    </body></html>