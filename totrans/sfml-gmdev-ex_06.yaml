- en: Chapter 6. Set It in Motion! – Animating and Moving around Your World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：启动！ – 在你的世界中动画和移动
- en: Our first game, while functional, certainly wasn't that visually appealing,
    at least not for this century. First of all, the graphics barely represented what
    they were supposed to. Referring to a chain of blocks as a snake was the only
    thing that gave the player an idea of what they were in control of. The second
    staple of an older design was the static camera position. While it is a design
    choice in a game like *Snake*, more complex genres would be crippled by such a
    limitation. Titles like *Super Mario Bros* rely on the fact that the game world
    extends beyond the boundaries of your screen, not only because of visual appeal,
    but also because of the ability to build a larger game world that doesn't have
    to fit within a certain pre-designated rectangle. A simple decision to represent
    game characters with images instead of basic shapes, as well as providing the
    means for the screen to be moved opens up a lot of doors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一款游戏虽然功能齐全，但视觉上肯定不够吸引人，至少在这个世纪是这样。首先，图形几乎不能代表它们应有的样子。将一串方块称为蛇是唯一能让玩家了解他们控制的是什么的方法。较老的设计的第二个基本点是静态摄像机位置。虽然在像
    *Snake* 这样的游戏中这是一个设计选择，但更复杂的游戏类型会受到这种限制的阻碍。像 *Super Mario Bros* 这样的游戏依赖于游戏世界超出屏幕边界的事实，这不仅因为视觉吸引力，也因为能够构建一个更大的游戏世界，而这个世界不需要适应某个预先指定的矩形。简单地用图像而不是基本形状来表示游戏角色，以及提供屏幕移动的手段，打开了很多可能性。
- en: 'In this chapter, we will be covering:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: SFML views and screen scrolling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML 视图和屏幕滚动
- en: Automated resource management and handling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动资源管理和处理
- en: Creation and application of sprite-sheets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵表单的创建和应用
- en: Sprite-sheet animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵表单动画
- en: There's a lot to learn, so let's not waste any time and dive right in!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多东西要学习，所以我们不要浪费时间，直接深入吧！
- en: Use of copyrighted resources
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版权资源的使用
- en: 'Before proceeding any further, we would like to give credit where credit''s
    due to the artists who created the textures, sprites, and other art we''re going
    to be using for our game. These assets include:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，我们想要向那些为我们游戏创建纹理、精灵和其他艺术作品的艺术家表示敬意。这些资产包括：
- en: '*Lemcraft* by richtaur under CC0 1.0 license: [http://opengameart.org/content/lemcraft](http://opengameart.org/content/lemcraft)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: richtaur 的 *Lemcraft*，根据 CC0 1.0 许可证：[http://opengameart.org/content/lemcraft](http://opengameart.org/content/lemcraft)
- en: '*Prototyping 2D Pixelart Tilesets* by [http://www.robotality.com](http://www.robotality.com)
    under CC-BY-SA 3.0 license: [http://opengameart.org/content/prototyping-2d-pixelart-tilesets](http://opengameart.org/content/prototyping-2d-pixelart-tilesets)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 [http://www.robotality.com](http://www.robotality.com) 提供的 *Prototyping 2D
    Pixelart Tilesets*，根据 CC-BY-SA 3.0 许可证：[http://opengameart.org/content/prototyping-2d-pixelart-tilesets](http://opengameart.org/content/prototyping-2d-pixelart-tilesets)
- en: '*Generic Platformer Tileset (16x16) + Background* by etqws3 under CC0 1.0 license:
    [http://opengameart.org/content/generic-platformer-tileset-16x16-background](http://opengameart.org/content/generic-platformer-tileset-16x16-background)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etqws3 的 *Generic Platformer Tileset (16x16) + Background*，根据 CC0 1.0 许可证：[http://opengameart.org/content/generic-platformer-tileset-16x16-background](http://opengameart.org/content/generic-platformer-tileset-16x16-background)
- en: '*Knight* and *Rat* sprites by backyardninja: [http://www.dumbmanex.com/bynd_freestuff.html](http://www.dumbmanex.com/bynd_freestuff.html)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: backyardninja 的 *Knight* 和 *Rat* 精灵：[http://www.dumbmanex.com/bynd_freestuff.html](http://www.dumbmanex.com/bynd_freestuff.html)
- en: 'The licensing of all the resources listed above allows for any use of the material,
    even commercial. For more information on the two specific licenses, please visit
    the following links:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以上所有资源的许可允许任何形式的材料使用，包括商业用途。有关这两个具体许可的更多信息，请访问以下链接：
- en: '[http://creativecommons.org/publicdomain/zero/1.0/](http://creativecommons.org/publicdomain/zero/1.0/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://creativecommons.org/publicdomain/zero/1.0/](http://creativecommons.org/publicdomain/zero/1.0/)'
- en: '[http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/)'
- en: Finding and using the current directory
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找和使用当前目录
- en: 'There''s no doubt that after programming for a while, the inconveniences of
    reading or writing to files start to quickly build up. It may not be so bad when
    running programs outside of your compiler, but using a relative path can be a
    pain while debugging, because it is no longer relative to the directory where
    the executable is, but instead where the `.obj` files are located. For the rest
    of this book, we will be using a function to obtain the full path to your executable,
    regardless of where it is or how it''s being launched. Let''s take a look at a
    new header file that will contain this function, called `Utilities.h`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，编程一段时间后，读取或写入文件的麻烦开始迅速积累。当在编译器外运行程序时，这也许不是那么糟糕，但在调试时使用相对路径可能会很痛苦，因为它们不再相对于可执行文件的目录，而是相对于`.obj`文件的位置。在这本书的其余部分，我们将使用一个函数来获取可执行文件的完整路径，无论它在哪里或如何启动。让我们看看一个将包含此函数的新头文件，称为`Utilities.h`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`#pragma once` is widely supported, but is non-standard. It can be replaced
    by a typical inclusion guard if the code is being processed in an older compiler.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`#pragma once`被广泛支持，但不是标准。如果代码是在较旧的编译器中处理的，它可以被典型的包含保护符所替代。'
- en: If a `RUNNING_WINDOWS` macro is set, it defines a method that first obtains
    the full path including the executable and its extension, then obtains only the
    name and extension of the executable and finally strips the full path of it before
    returning the string, that now contains the full "address" of the directory the
    executable resides in. These functions are specific to Windows and won't work
    on other operating systems, so this header needs to define the same method differently
    for each of them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`RUNNING_WINDOWS`宏，它定义了一个方法，该方法首先获取包括可执行文件及其扩展名的完整路径，然后仅获取可执行文件的名字和扩展名，最后在返回字符串之前从完整路径中删除它，现在这个字符串包含了可执行文件所在目录的完整“地址”。这些函数是针对Windows的特定函数，在其他操作系统上无法工作，因此这个头文件需要为每个操作系统定义不同的相同方法。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using these functions to obtain the current directory requires the `Shlwapi.h`
    header file to be included, as well as the `shlwapi.lib` file being listed in
    the linker's additional dependencies in *all* configurations. Forgetting to fulfill
    these requirements will cause linker errors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数获取当前目录需要包含`Shlwapi.h`头文件，以及将`shlwapi.lib`文件列在链接器的附加依赖项中，在*所有*配置中。忘记满足这些要求将导致链接器错误。
- en: As you can see, we have Windows and Linux operating systems covered here. It
    is up to you to implement versions of the same function for other platforms if
    you want your application to run properly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这里涵盖了Windows和Linux操作系统。如果您希望应用程序能够正常运行，您需要为其他平台实现相同函数的版本。
- en: Using the SFML views
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SFML视图
- en: 'Up until this point, we have only dealt with code that renders things within
    the boundaries of the window that''s open. There hasn''t been an instance where
    we needed the screen to move yet, which would be fine if we lived in the early
    days of the 80s, but games even a decade after that time were a lot more advanced.
    Take, for example, *Super Mario Brothers*, a classic *side-scroller*. Its genre
    alone pinpoints what our first game didn''t have: scrolling. If the scrolling
    effect or any kind of movement, resizing or rotation of the screen is desirable,
    using the `sf::View` is necessary.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理过在打开的窗口边界内渲染内容的代码。还没有需要屏幕移动的实例，如果我们生活在80年代初期，那倒也无可厚非，但即使是十年后的游戏也更为先进。以*超级马里奥兄弟*为例，这是一款经典的*横版卷轴游戏*。仅从其类型就可以看出，我们的第一款游戏没有的东西：滚动。如果需要滚动效果或任何屏幕的移动、调整大小或旋转，使用`sf::View`是必要的。
- en: 'What is `sf::View`? It''s a rectangle. That''s it. If you have ever held your
    fingers in a rectangle shape to "frame" the world you''re observing, you have
    created a view with your hands. By moving it, you are essentially moving through
    the scene beyond the cut-off point of the window. If you''re still not "getting
    the picture," here''s an illustration to lead you in the right direction:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::View`是什么？它是一个矩形。仅此而已。如果您曾经用手指做出矩形形状来“框”您观察的世界，您就用双手创建了一个视图。通过移动它，您实际上是在通过窗口的截止点移动场景。如果您仍然“不理解”，这里有一个插图来引导您走向正确的方向：'
- en: '![Using the SFML views](img/B04284_06_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![使用SFML视图](img/B04284_06_01.jpg)'
- en: 'The `sf::View` is a very lightweight object that essentially holds a few floating
    point variables and a number of methods to retrieve its values. Its constructor
    can take in a `sf::FloatRect` type, which defines a rectangular area of the screen,
    or it can take two `sf::Vector2f` types, the first one being the centre of the
    view and the second one being the size:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::View`是一个非常轻量级的对象，本质上只包含一些浮点变量和一些用于检索其值的方法。它的构造函数可以接受一个`sf::FloatRect`类型，该类型定义了屏幕上的矩形区域，或者它可以接受两个`sf::Vector2f`类型，第一个是视图的中心，第二个是大小：'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, views are mostly manipulated by their centre instead of their
    top-left corner, unlike most of the other shapes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，视图主要是由其中心而不是其左上角来操纵的，这与大多数其他形状不同。
- en: 'Moving the view can be done by manipulating its centre, like so:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过操纵其中心，可以移动视图，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It can also be moved by an offset, via the `move` method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以通过`move`方法移动偏移量：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Resizing the view can be accomplished by either using the `setSize` method
    or zooming by a factor, using the `zoom` method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`setSize`方法或通过`zoom`方法按比例缩放，可以调整视图的大小：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the first case, it resizes a view of 800x600 px down to 640x480 px. The second
    case applies a factor of `0.5f` to its current size, which cuts it down in half,
    making everything on screen larger.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，它将800x600像素的视图大小调整为640x480像素。在第二种情况下，将`0.5f`的因子应用于其当前大小，将其减半，使屏幕上的所有内容都变大。
- en: 'In order to use a specific view, you must call the `setView` method of the
    window instance you''re using:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用特定的视图，你必须调用你正在使用的窗口实例的`setView`方法：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `setView` method does *not* take values in by reference. It simply copies
    the values from the view and stores them in the window object. If the view is
    altered at any point in your code, you must call the `setView` method *again*
    in order to apply those changes and make them reflect.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`setView`方法不通过引用接收值。它只是从视图中复制值并将它们存储在窗口对象中。如果在你的代码中的任何一点改变了视图，你必须再次调用`setView`方法，以便应用这些更改并使其反映出来。'
- en: 'One last thing worthy of mentioning is that two views can be obtained from
    the window object as well. The first kind of view is the current one being used,
    and the second view is the default a window starts with. It''s the same size as
    the window and its left corner is positioned at coordinates (0;0). Retrieving
    these views can be done like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，还可以从窗口对象中获取两个视图。第一种视图是当前正在使用的视图，第二种视图是窗口启动时的默认视图。它与窗口大小相同，其左上角位于坐标（0;0）。获取这些视图的方法如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Preparing application states for views
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备应用程序状态以供视图使用
- en: 'In order to add support for panning around our world, we must adjust the state
    system. The main idea here is that each state has its own view. Something like
    the main menu will most likely never need to move past the default view the window
    provides, unlike the game state, which will be focusing on the character every
    frame. A simple and elegant approach would be to store a view with each state,
    so it can adjust the screen view space if it needs to. Let''s start by modifying
    the `BaseState.h` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持在世界上进行平移，我们必须调整状态系统。这里的主要思想是每个状态都有自己的视图。例如，主菜单很可能永远不会需要移动到窗口提供的默认视图之外，而游戏状态则会在每一帧都聚焦于角色。一个简单而优雅的方法是将视图与每个状态一起存储，以便在需要时调整屏幕视图空间。让我们从修改`BaseState.h`文件开始：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Like most of the classes we''re going to be modifying, we''re only showing
    the relevant parts here, which are fairly conservative size wise in this case.
    All we''ve added is a view data member and a method for obtaining it. Let''s move
    on to putting this view to work in our state manager:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们即将修改的大多数类一样，这里我们只展示相关的部分，在这个例子中，这些部分在尺寸上相当保守。我们添加的只是一个视图数据成员和获取它的方法。让我们继续将这个视图应用到我们的状态管理器中：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because we don''t want the default constructor of `sf::View` to initialize
    our view member to its own default values, it''s necessary to set the view up
    when creating the state. Most of the states we have so far rely on the fact that
    the view never moves, which is why it''s set to default first. If a state wishes
    to define its own view, it can always do so in the `OnCreate` method, as you will
    see shortly. Let''s move on to state switching:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望`sf::View`的默认构造函数将我们的视图成员初始化为其默认值，因此在创建状态时必须设置视图。我们到目前为止的大多数状态都依赖于视图从不移动的事实，这就是为什么它首先被设置为默认值。如果一个状态希望定义自己的视图，它可以在`OnCreate`方法中这样做，正如你很快就会看到的。让我们继续到状态切换：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is fairly straightforward. When switching to a different state, we want
    to change the view space of the window to match the state we're switching to.
    If that's not accomplished and the game state moves the view, switching to another
    state will simply leave you with a blank screen, because the new state's contents
    are rendered outside the window's view space.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接。当切换到不同的状态时，我们希望将窗口的视图空间更改为与我们要切换到的状态相匹配。如果没有完成这一点，并且游戏状态移动了视图，切换到另一个状态将简单地留下一个空白屏幕，因为新状态的内容被渲染在窗口的视图空间之外。
- en: 'Drawing multiple states at once can raise some problems, now that different
    views are introduced. This can be a little bit difficult to understand, so let''s
    illustrate the problem with an example. Let''s say the game is paused. Because
    the paused state is transparent, it needs to draw the state before it first, in
    order to blend them together. Instantly there''s a problem, because the paused
    state positions its elements in window coordinates and it never needs the view
    to move. If the view of the window does move, whatever the state on top draws
    is going to be outside its view space and will therefore be either partially visible
    or not there at all. We could translate window coordinates to world coordinates
    and update positions of these elements each frame to "follow" the screen, but
    that''s not an elegant or efficient solution. Therefore, we must set the window
    view to the state view before it gets rendered, like so:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在引入了不同的视图后，同时绘制多个状态可能会引起一些问题。这可能会有些难以理解，所以让我们用一个例子来说明这个问题。假设游戏处于暂停状态。因为暂停状态是透明的，它需要首先绘制它前面的状态，以便将它们混合在一起。立刻就出现了问题，因为暂停状态将其元素定位在窗口坐标中，并且它永远不需要视图移动。如果窗口的视图移动了，顶部状态所绘制的任何内容都将位于其视图空间之外，因此可能只会部分可见或根本不可见。我们可以将窗口坐标转换为世界坐标，并每帧更新这些元素的坐标以“跟随”屏幕，但这不是一个优雅或高效的解决方案。因此，我们必须在渲染之前将窗口视图设置为状态视图，如下所示：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because of the way views and rendering works, the problem above is resolved.
    Consider the following illustration:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图和渲染的方式，上述问题得到了解决。考虑以下说明：
- en: '![Preparing application states for views](img/B04284_06_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![为视图准备应用程序状态](img/B04284_06_02.jpg)'
- en: First, the window view is set to the view of the game in order to render the
    scene. Let's say it's top-left corner is at position (600;700). The default view
    of the window is then applied. This moves the window view space's top-left corner
    back to (0;0), which matches the local window coordinates. Because the elements
    that are about to be drawn are positioned based on these coordinates, they are
    now in the window's view space again and are drawn on top of the frame buffer.
    The transparent parts are blended, while opaque pixels are overwritten. Finally,
    `window.display();` gets called and the frame buffer is drawn on screen. The result
    is both the scene and the elements being blended together.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将窗口视图设置为游戏视图以渲染场景。假设它的左上角位于位置（600;700）。然后应用窗口的默认视图。这将窗口视图空间的左上角移动回（0;0），这与本地窗口坐标相匹配。因为即将绘制的元素是基于这些坐标定位的，所以它们现在又回到了窗口的视图空间，并绘制在帧缓冲区上。透明部分被混合，不透明像素被覆盖。最后，调用`window.display();`并在屏幕上绘制帧缓冲区。结果是场景和元素都被混合在一起。
- en: 'The last thing we want to add to our existing code-base before moving on is
    a new method in the Window class for obtaining a `sf::FloatRect` type that defines
    the window view space:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，我们想在现有的代码库中添加一个新方法到Window类中，用于获取一个定义窗口视图空间的`sf::FloatRect`类型：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, this method obtains the centre and the size of the current view. Then
    it calculates what half of the size is and subtracts it from the coordinates of
    the view's centre, in order to obtain its top-left corner. Lastly, it constructs
    the rectangle of the view space by passing in the top-left corner of the view
    and its size. This will be useful later on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这种方法获取当前视图的中心和大小。然后它计算大小的一半并从视图中心的坐标中减去，以获得其左上角。最后，它通过传入视图的左上角和大小来构建视图空间的矩形。这将在以后很有用。
- en: Automated resource management
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动资源管理
- en: 'Let''s talk about textures and the way we''ve been using them so far. A texture
    in SFML is something you want to only have one of, since it''s not cheap memory
    wise. Our approach so far was simply storing the textures as data members of relevant
    classes. A scenario that illustrates how horrendous this strategy is would be
    as follows: you need the same texture somewhere else. That''s it. It really doesn''t
    seem like the type of thing that you could just brush off your shoulders, as it
    only happens once in a blue moon. Creating multiple textures that all hold the
    same data is a huge waste of resources, and adding methods for obtaining textures
    from the classes that use them is a disaster. Not only does it clutter the class
    footprint, it would also mean that other classes would have to have access to
    the one that holds this texture. Nobody should subject themselves to such torture.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈纹理以及我们迄今为止使用它们的方式。在SFML中，纹理是一种你只想有一个的东西，因为它在内存方面并不便宜。我们迄今为止的方法只是简单地将纹理存储为相关类的数据成员。以下是一个说明这种策略多么糟糕的场景：你需要在其他地方使用相同的纹理。就是这样。这根本不像是你能轻易放下的事情，因为它毕竟不是经常发生。创建多个包含相同数据的纹理是资源的巨大浪费，为使用它们的类添加获取纹理的方法也是一场灾难。这不仅会弄乱类的轮廓，还意味着其他类必须能够访问持有这个纹理的类。没有人应该让自己承受这样的折磨。
- en: 'How do we remedy this situation then? By creating a class that holds all of
    our textures in the same place and keeps track of how many times they''re used
    in order to manage its resources in a smart way. We also want to give them unique
    identifiers in order to refer to them quickly, which can be done by loading them
    from a file that maps a name to a path. We can name it `Textures.cfg` and it would
    look something like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解决这个问题呢？通过创建一个类，它将所有我们的纹理放在同一个地方，并跟踪它们的使用次数，以便以智能的方式管理其资源。我们还希望给它们唯一的标识符，以便快速引用，这可以通过从将名称映射到路径的文件中加载它们来实现。我们可以将其命名为`Textures.cfg`，它看起来可能像这样：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This approach, of course, can be used for other types of resources, not just
    textures. Later on, we'll be working with fonts and sound files as well, so let's
    design an abstract base class that will take care of all the common tasks first,
    before delving into handling textures specifically.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法可以用于其他类型的资源，而不仅仅是纹理。稍后，我们还将处理字体和声音文件，所以让我们设计一个抽象基类，首先处理所有常见的任务，然后再专门处理纹理。
- en: Designing a resource manager
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计资源管理器
- en: 'All of the resources we''re going to be working with are going to be counted
    and accounted for, so to speak. Whenever we want to use a texture, for example,
    it needs to be requested. If it''s no longer needed, the resource is released.
    It sounds simple enough, so let''s write it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的所有资源都将被计数和记录，换句话说。每当我们要使用一个纹理，例如，它需要被请求。如果它不再需要，资源就会被释放。这听起来很简单，所以让我们写下来：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When dealing with classes that use templates, it's necessary for the implementation
    of the methods to be in the header file, because the compiler needs to have access
    to the implementation in order to instantiate the methods with the template arguments.
    With that being said, let's talk about the `m_resources` data member. It's using
    a map, which is going to tie a string handle to a pair of elements, the first
    of which is the template parameter of a resource and the second is an unsigned
    integer type that will be used as a counter for how many places are currently
    using this particular resource.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理使用模板的类时，方法的实现必须在头文件中，因为编译器需要访问实现才能使用模板参数实例化方法。话虽如此，让我们谈谈`m_resources`数据成员。它使用一个映射，将字符串句柄绑定到一对元素，其中第一个是资源的模板参数，第二个是用于计数当前使用此特定资源的位置的未签名整数类型。
- en: Another data member we have is a map of two strings for the resource paths.
    The constructor calls an internal method in order to load the paths from a specific
    location, while the destructor invokes another internal method to purge and de-allocate
    all of its resources.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个数据成员，是一个用于资源路径的两个字符串的映射。构造函数调用一个内部方法来从特定位置加载路径，而析构函数则调用另一个内部方法来清除和重新分配其所有资源。
- en: 'Let''s begin implementing other methods we''re going to need to use this class,
    starting with the public ones:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现我们将需要使用此类的其他方法，从公共方法开始：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a method for acquiring a resource that's being kept in the manager.
    It uses the string argument as a handle and looks for it in the map, using the
    internal `Find` method that we'll define later. It returns a pointer to the pair
    element of the map if something is found, or `nullptr` if nothing is found.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个获取由管理器保存的资源的方法。它使用字符串参数作为句柄，并在映射中查找它，使用我们稍后定义的内部`Find`方法。如果找到，它返回映射中元素对的指针，如果没有找到，则返回`nullptr`。
- en: 'We also might be interested in retrieving one of the paths to a particular
    resource:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还感兴趣的是检索特定资源的路径之一：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This system would be useless without some way to guarantee that a resource
    doesn''t get de-allocated while it''s still being used. In order to prevent that,
    let''s implement a method that will register the use of a resource:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有某种方式来保证资源在使用过程中不会被重新分配，这个系统将毫无用处。为了防止这种情况，让我们实现一种方法来注册资源的使用：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method serves two purposes. One is simply incrementing the counter of instances
    a resource is being used when it's required. The second purpose of it is to create
    a resource, if the handle is not found in the resource container. It first looks
    as if the resource handle is valid, by checking the path container. If a match
    is found, it tries to acquire a pointer to newly allocated memory, which gets
    returned by the `Load` method. If it hasn't returned a `nullptr` value, the resource
    gets inserted with a counter set to `1`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有两个目的。一个是在需要时简单地增加资源使用实例计数器。它的第二个目的是在资源容器中找不到句柄时创建资源。它首先检查路径容器，以确认资源句柄有效。如果找到匹配项，它尝试获取新分配内存的指针，该指针由`Load`方法返回。如果没有返回`nullptr`值，则将资源插入，计数器设置为`1`。
- en: 'Just like for every yin there must be a yang, for every resource required,
    there must be a point where it''s no longer needed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如阴阳必须相互对应一样，对于每个所需资源，都必须有一个不再需要它的时刻：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method tries to find a resource in the container using the string handle.
    If one is found, its use counter is decremented. If the counter is now at `0`,
    this resource is no longer needed and the memory for it can be de-allocated by
    calling the `Unload` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法尝试使用字符串句柄在容器中查找资源。如果找到，则减少其使用计数器。如果计数器现在是`0`，则此资源不再需要，可以通过调用`Unload`方法来释放其内存。
- en: 'At some point, everything must go. This is the purge method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，一切都必须结束。这是清除方法：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a fairly straightforward method. It loops until there are no more elements
    in the container. Each time it deletes the resource memory and erases the container
    entry by passing in an iterator.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的方法。它循环直到容器中没有更多元素。每次它通过传递迭代器删除资源内存并擦除容器条目。
- en: 'Because of the unique nature of some resources, certain methods aren''t universal.
    For the purposes of expanding this base class to support any resource we want,
    a `Load` method is going to be used in each derived manager. In order to avoid
    run-time polymorphism, a **Curiously Recurring Template Pattern** can be used
    like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些资源的独特性质，某些方法并不是通用的。为了将这个基类扩展到支持我们想要的任何资源，每个派生管理器都将使用`Load`方法。为了避免运行时多态，可以使用**Curiously
    Recurring Template Pattern**（奇特重复模板模式）如下：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Derived classes will implement their own versions of `Load`, but will not rely
    on resolving virtual pointers to functions during run-time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类将实现自己的`Load`版本，但不会在运行时解析虚拟指针到函数。
- en: 'Now that the scratching of the surface is done, let''s dive deep into the private
    methods that make this functionality possible, beginning with `Find`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了表面的工作，让我们深入探讨使这种功能成为可能的私有方法，从`Find`方法开始：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method returns a pointer to a pair structure that includes the actual resource
    and the number of instances using it. If the string handle provided as an argument
    isn't located in the resource container, `nullptr` is returned instead.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个指向包含实际资源和正在使用它的实例数的pair结构的指针。如果提供的字符串句柄在资源容器中未找到，则返回`nullptr`。
- en: 'Unloading a resource doesn''t bring anything new to the table:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载资源并没有带来任何新的东西：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As always, we first look for the element in the container by the string handle.
    If it is found, we free the allocated memory, erase the element from the container
    and return from the method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先通过字符串句柄在容器中查找元素。如果找到，我们释放分配的内存，从容器中擦除元素并从方法中返回。
- en: 'Lastly, we can''t use those string handles without having paths that they map
    to. Let''s load them in:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果没有映射到路径的字符串句柄，我们无法使用它们。让我们将它们加载进来：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you know anything about loading in files in C++, this should raise no eyebrows.
    All it does is set up an input stream called `paths`. It then tries to open it,
    by passing in the full path to the file, thanks to our `GetWorkingDirectory` function
    that was mentioned earlier. If the file is open, it means it was found and can
    be read. A string type is defined for use as a way of holding the current line
    of the file as it reads them one by one sequentially. The method loops while there's
    still a new line in the file we're parsing and passes in that new line to the
    `line` variable. A `stringstream` variable is then set up, which is designed for
    operations with strings. Two `string` variables are defined, one for the path
    identifier and one for the actual path. They get filled from the `keystream` variable
    by using its overloaded `>>` operator, which essentially just grabs everything
    in the line until it encounters a space delimiter. We then insert this information
    into the path container and close the file after the loop is over.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解C++中的文件加载，这应该不会让你感到惊讶。它所做的只是设置一个名为`paths`的输入流。然后它尝试打开它，通过传递文件的完整路径，归功于之前提到的`GetWorkingDirectory`函数。如果文件已打开，这意味着它已被找到并且可以读取。定义了一个字符串类型，用作在读取它们时按顺序存储当前文件行的手段。该方法在解析的文件中仍有新行时循环，并将该新行传递给`line`变量。然后设置了一个`stringstream`变量，它专为字符串操作设计。定义了两个`string`变量，一个用于路径标识符，一个用于实际路径。它们通过使用其重载的`>>`操作符从`keystream`变量中填充，该操作符本质上只是抓取直到遇到空格分隔符的所有内容。然后我们将此信息插入路径容器中，并在循环结束后关闭文件。
- en: Implementing the texture manager
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现纹理管理器
- en: 'With the resource management part done, we can now implement the actual texture
    loading in its own class. Because there''s only one method that we want to implement,
    it might as well be done in the header file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成资源管理部分后，我们现在可以在自己的类中实现实际的纹理加载。因为我们只想实现一个方法，所以它也可以在头文件中完成：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We create the `TextureManager` class and inherit from `ResourceManager` in addition
    to specifying the data types of this manager class and the resource it deals with
    for the template, which is, of course, a `sf::Texture`. The constructor of the
    texture manager is only used to call the base class constructor in the initializer
    list to pass in the file name that contains the bindings of handles and paths.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`TextureManager`类，并从`ResourceManager`继承，同时指定了该管理类处理的数据类型以及模板所使用的资源，当然，这是一个`sf::Texture`。纹理管理器的构造函数仅用于在初始化列表中调用基类构造函数，以传递包含句柄和路径绑定的文件名。
- en: In the `Load` method, we allocate new memory for the texture and attempt to
    load it from the path provided as an argument. If the loading fails, we delete
    the allocated memory and print out a console message to notify the user of the
    failure. That is literally all there is to the texture manager class. Time to
    put it to work!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Load`方法中，我们为纹理分配新的内存，并尝试从提供的路径加载它。如果加载失败，我们将删除分配的内存，并打印出控制台消息来通知用户失败。这就是纹理管理器类的全部内容。现在是时候将其投入使用！
- en: Introducing sprite sheets
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍精灵图集
- en: 'First, let''s whet your appetite by looking into the future of using sprite
    sheets, which allow you to create animations that look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过查看使用精灵图集的未来来激发你的兴趣，这允许你创建看起来像这样的动画：
- en: '![Introducing sprite sheets](img/B04284_06_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![介绍精灵图集](img/B04284_06_03.jpg)'
- en: 'From our previous experience with SFML, we know that a sprite is essentially
    an image that can be moved around, cropped, scaled, and rotated just to mention
    a few options. A sprite sheet, on the other hand, is a texture that contains multiple
    sprites. From the image above, you can see the player is moving left and his animation
    is progressing. Each frame of the player''s animation is stored in a sprite sheet,
    which is being accessed and cropped in order to represent a single sprite. This
    is what a small part of it looks like as a texture:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前使用SFML的经验中，我们知道精灵基本上是一个可以移动、裁剪、缩放和旋转的图像，仅举几个选项。另一方面，精灵图集是一个包含多个精灵的纹理。从上面的图像中，你可以看到玩家正在向左移动，他的动画正在进展。玩家动画的每一帧都存储在精灵图集中，该图集被访问和裁剪以表示单个精灵。这就是它作为纹理看起来的一部分：
- en: '![Introducing sprite sheets](img/B04284_06_04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![介绍精灵图集](img/B04284_06_04.jpg)'
- en: The way sprites are laid out can differ from game to game. It depends on the
    size constraints of a particular project, as well as the specifics of game-play.
    The format of the sprite sheet above is just what works the best here and is by
    no means the "perfect design."
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵的布局方式可能因游戏而异。它取决于特定项目的尺寸限制以及游戏玩法的具体情况。上面精灵图的格式只是在这里效果最好，绝对不是“完美的设计”。
- en: Why would we want to use a sprite sheet? Well, the biggest advantage is that
    it makes accessing sprites easier and faster, not to mention less memory-consuming.
    Animation is also easier to pull off on a sprite sheet. Loading multiple textures
    of different sprites is more expensive than loading a single texture that can
    be cropped. In certain cases, careful packing of a sprite sheet can save a lot
    of resources. If efficiency is what you're after, use of sprite sheets over different
    textures for each sprite definitely takes the cake.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要使用精灵图呢？最大的优势是它使得访问精灵更加容易和快速，而且更节省内存。在精灵图上实现动画也更加容易。加载多个不同精灵的纹理比加载单个可裁剪的纹理要昂贵得多。在某些情况下，精心打包的精灵图可以节省大量资源。如果您追求效率，使用精灵图而不是为每个精灵加载不同的纹理无疑是一个明智的选择。
- en: Implementing a sprite sheet class
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现精灵图类
- en: 'Because we want to be able to modify anything related to sprite sheets on the
    fly, loading them from a file makes the most sense. Let''s start by taking a look
    at what the sprite sheet for a player might look like by making a `Player.sheet`
    file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望能够即时修改与精灵图相关的任何内容，从文件中加载它们是最有意义的。让我们先通过创建一个 `Player.sheet` 文件来看看玩家精灵图的样貌：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It starts by specifying a handle of the texture that will be used. Some additional
    data about the sprite itself is also defined, such as the individual sprite size
    and scale. We then jump to a row that's commented out. It describes the order
    and meaning of values for the rest of the file, which is designated for defining
    sequences of animations in the sprite sheet. After defining the animation type,
    it proceeds in defining all of these different parameters about the animation.
    There's no need to focus on this part for now, as it will be covered in depth
    later.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先指定将要使用的纹理句柄。还定义了一些关于精灵本身的附加数据，例如单个精灵的大小和缩放。然后跳转到一条注释掉的行。它描述了文件其余部分中值的顺序和含义，这部分用于在精灵图中定义动画序列。在定义动画类型之后，它继续定义所有这些关于动画的不同参数。现在不需要关注这部分，因为稍后会有更深入的讲解。
- en: 'With the file format out of the way, let''s get started with the sprite sheet
    class! First, a container type is defined to hold the animations. An unordered
    map is used because it offers faster lookups than its ordered counter-part:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式的问题解决之后，让我们开始编写精灵图类！首先，定义一个容器类型来保存动画。使用无序映射是因为它比其有序对应物提供更快的查找速度：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once again, try not to dwell on this too much, as it will be explained in more
    depth later. Let''s write the header for the sprite sheet class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，尽量不要过多地纠结于此，因为稍后会有更深入的讲解。现在我们来为精灵图类编写标题：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, it offers methods for cropping the texture and updating and
    drawing the sprite sheet. The class holds on to a pointer to a texture manager
    in order to obtain and free up resources. One last thing about this class is that
    it holds a data member of type `Direction`. It''s simply just an enumeration,
    defined in the `Directions.h` file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它提供了裁剪纹理、更新和绘制精灵图的方法。该类保留对纹理管理器的指针，以便获取和释放资源。关于这个类还有一点需要说明，那就是它持有一个 `Direction`
    类型的数据成员。它只是一个枚举，定义在 `Directions.h` 文件中：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It's barely even worth its own header. However, quite a few classes actually
    rely on this, so a separate header is where it needs to be.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至不值得有自己的标题。然而，相当多的类实际上依赖于这个方法，所以需要一个单独的标题来放置它。
- en: 'Let''s begin implementing the actual methods of the sprite sheet class, starting,
    as always, with the constructor and destructor:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现精灵图类的实际方法，从构造函数和析构函数开始：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Apart from initializing its data members to default values, there''s nothing
    else of interest here. The destructor simply calls another method to clean up,
    much like a lot of other classes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将数据成员初始化为默认值之外，这里没有其他有趣的内容。析构函数简单地调用另一个方法来清理，就像很多其他类一样：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `ReleaseSheet` method uses the texture manager to release the resource it
    was using, as well as delete all of the animations it has currently allocated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReleaseSheet` 方法使用纹理管理器来释放它所使用的资源，以及删除它当前分配的所有动画。'
- en: 'When setting the sprite size, it''s important to also reset the origin, so
    it''s always in the middle of the sprite on the *x* axis and down all the way
    on the *y* axis:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置精灵大小时，重要的是也要重置原点，使其始终位于精灵的*x*轴中间和*y*轴的底部：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Naturally, we also need a method for setting the position of the sprite:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们还需要一个设置精灵位置的方法：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Setting a different direction of a sprite will change its sprite, so we need
    to re-crop it afterwards:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 设置精灵的不同方向将改变其精灵，因此我们需要在之后重新裁剪它：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The actual cropping is done through the `setTextureRect` method of a sprite
    class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的裁剪是通过精灵类的`setTextureRect`方法完成的：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It takes in a `sf::IntRect` type, which defines its top-left corner, as well
    as the size of the rectangle. The top-left corner coordinates are local to the
    texture that's being cropped. Let's say we want to obtain the first sprite in
    the sprite sheet. If we know that each sprite is 32px by 32px in size, all we
    need to do is pass in the position (0;0) for the top-left corner and then the
    size (32;32) in order to obtain the sprite.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个`sf::IntRect`类型，该类型定义了其左上角的位置以及矩形的尺寸。左上角坐标是裁剪纹理的局部坐标。假设我们想要获取精灵图中的第一个精灵。如果我们知道每个精灵的大小是32px
    x 32px，我们只需要传递左上角的位置（0;0）以及尺寸（32;32）来获取精灵。
- en: 'Although we haven''t covered animations yet, let''s get the `SetAnimation`
    method out of the way, since it''s not too difficult to understand, even without
    knowing every specific detail about our soon-to-be animation class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有涉及动画，但让我们先了解一下`SetAnimation`方法，因为它即使不了解即将使用的动画类的具体细节，也不难理解：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It takes in three arguments: a string handle and two Boolean flags for playing
    the animation instantly and whether it''s looped or not. The method itself looks
    through the animation container for an animation that matches the string handle.
    If one is found, it checks if any current animation is set because it needs to
    be stopped. Once that is done, it simply changes the pointer to the current animation
    to the animation that was found in the container, as well as calls the respective
    methods in order to loop and play the animation. Nothing too complicated.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受三个参数：一个字符串句柄和两个布尔标志，用于立即播放动画以及是否循环。该方法本身会遍历动画容器以查找与字符串句柄匹配的动画。如果找到了，它会检查是否有任何当前动画被设置，因为需要停止它。一旦完成，它只需将当前动画的指针更改为容器中找到的动画，并调用相应的方法以循环和播放动画。并没有什么太复杂的。
- en: 'We then top off this class with the most run of the mill update and draw methods:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用最普通的更新和绘制方法来完善这个类：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is about as simple as it gets. However, it does leave us with one method
    unaccounted for: `LoadSheet`. Before we can implement that, we need to know more
    about the animation classes we''ll be working with.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单不过了。然而，它确实留下了一个未解释的方法：`LoadSheet`。在我们能够实现它之前，我们需要更多地了解我们将要使用的动画类。
- en: The base animation class
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础动画类
- en: 'Much like with the resource manager, we want to off-load any and all functionality
    that isn''t unique to more specific classes and put it in a base class. This is
    where the base animation class comes in. Let''s take a look at the `Anim_Base.h`
    header file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像资源管理器一样，我们希望将所有非特定于更具体类的功能卸载到基类中。这就是基础动画类发挥作用的地方。让我们看看`Anim_Base.h`头文件：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, notice the forward declaration of class `SpriteSheet`. Because this class
    needs to include `SpriteSheet` and `SpriteSheet` needs to include this class,
    forward declarations are necessary to prevent cross-inclusions. We're also going
    to be using an alias for the unsigned integer type, simply named `Frame`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意类`SpriteSheet`的前向声明。因为这个类需要包含`SpriteSheet`，而`SpriteSheet`也需要包含这个类，所以需要前向声明以防止交叉包含。我们还将使用无符号整型的一个别名，简单地命名为`Frame`。
- en: Most of the data member as well as method names are fairly self-explanatory.
    A few terms might be confusing, such as frame time and action. Frame time is the
    amount of time each frame takes to finish. Action defines a range of frames during
    which a behavior which is specific to that animation can be performed. If it's
    set to negative one, this behavior can be performed throughout the entire animation.
    These are some things that we want to keep track of in order to make the game
    more interactive and responsive. Note that we're overloading the `>>` operator
    in order to ease animation loading from files. More on that later.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据成员以及方法名称都是相当直观的。一些术语可能令人困惑，例如帧时间和动作。帧时间是每个帧完成所需的时间。动作定义了一个帧的范围，在这个范围内可以执行特定于该动画的行为。如果设置为负一，则在整个动画中都可以执行这种行为。这些都是我们想要跟踪以使游戏更具交互性和响应性的东西。注意，我们正在重载
    `>>` 操作符，以便简化从文件中加载动画。关于这一点，稍后会有更多说明。
- en: 'The last thing to point out is the three purely virtual methods: `FrameStep`,
    `CropSprite`, and `ReadIn`. `FrameStep` is the update portion that''s unique to
    different types of animations. `CropSprite` is a unique way different types of
    animations would obtain sprites from a sprite sheet. Lastly, `ReadIn` is the method
    that defines how exactly the stringstream object is used when data is being loaded
    from files. These three methods will only be defined in derived classes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要指出的是三个纯虚方法：`FrameStep`、`CropSprite` 和 `ReadIn`。`FrameStep` 是不同类型动画特有的更新部分。`CropSprite`
    是不同类型动画从精灵表中获取精灵的独特方式。最后，`ReadIn` 是定义在从文件加载数据时如何使用 stringstream 对象的方法。这三个方法只会在派生类中定义。
- en: Implementing the base animation class
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现基本动画类
- en: 'Due to forward declarations, we need to include the actual header files of
    classes that were declared in the `.cpp` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前向声明，我们需要包含在 `.cpp` 文件中声明的类的实际头文件：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we have no more cross-inclusions and we get to use the `SpriteSheet` class.
    Time to implement the actual class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不再有交叉包含，我们可以使用 `SpriteSheet` 类了。是时候实现实际的类了：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The constructor is doing its intended job of initializing default values, while
    the destructor isn't going to be used at all in this class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数正在执行其预期的初始化默认值的工作，而析构函数在这个类中根本不会被使用。
- en: 'Of course, we need a method for setting our sprite sheet data member to something:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要一种方法来设置我们的精灵表数据成员：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The same thing is true for setting the animation frame, although this method
    is slightly more intricate:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 设置动画帧的情况也是一样，尽管这个方法稍微复杂一些：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The argument that is passed to this method is checked for being in two specific
    ranges, which is done in order to add support for types of animation that can
    play backwards in the future.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此方法的参数将被检查是否在两个特定的范围内，这是为了支持未来可以向后播放的动画类型。
- en: 'Here''s a method for checking if this animation is currently able to perform
    its custom behavior:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个检查此动画当前是否能够执行其自定义行为的方法：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If any of the values are `-1`, the "action" is always performed. Otherwise,
    the current frame is checked for being within the designated range that will be
    loaded from the sprite sheet file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何值是 `-1`，则“动作”总是执行。否则，当前帧将检查是否在从精灵表文件加载的指定范围内。
- en: 'We can''t go far without controlling these animations in one way or another.
    It''s a good idea to provide a simple interface to do that:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不控制这些动画，我们将无法走得更远。提供一个简单的接口来做这件事是个好主意：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Play` and `Pause` methods simply manipulate a Boolean flag, while the
    `Stop` method also resets the animation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Play` 和 `Pause` 方法只是简单地操作一个布尔标志，而 `Stop` 方法也会重置动画：'
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After moving the frame back to the beginning and resetting the timer, it crops
    the sprite because of the frame change. We are almost done with this class. All
    that''s missing now is a way to update it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在将帧移回开始并重置计时器后，由于帧的变化，它裁剪了精灵。我们几乎完成了这个类的实现。现在唯一缺少的是更新它的方法：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Update` method, as per usual, takes in an argument that represents the
    elapsed time between frames. It then simply adds it to the elapsed time of the
    animation if it's playing and checks if it has exceeded the frame time. If it
    did, our two virtual methods are called and the timer is reset back to `0`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update` 方法，像往常一样，接收一个参数，表示帧之间的经过时间。然后它简单地将其添加到动画的经过时间中，如果动画正在播放，并检查是否超过了帧时间。如果超过了，我们调用两个虚拟方法，并将计时器重置回
    `0`。'
- en: Directional animation
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方向动画
- en: 'There''s not always a clear dichotomy present between different types of animation
    depending on implementation details. For the purposes of this chapter not dragging
    on with specific subjects, only one type of animation will be implemented, which
    is the directional animation. This type of animation is usually used with any
    kind of moving entities that have a specific animation for each direction. Unlike
    other types of animation, where an increased frame can lead to a jump in rows,
    directional animation will always remain on the row that represents the proper
    type of animation in the proper direction. Consider the following illustration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 根据实现细节，不同类型的动画之间并不总是存在清晰的二分法。为了使本章内容不因特定主题而拖延，我们将只实现一种类型的动画，即方向动画。这种类型的动画通常用于任何具有特定方向动画的移动实体。与其他类型的动画不同，增加帧数可能导致行数跳跃，而方向动画将始终保持在表示正确方向正确类型的动画所在的行上。考虑以下插图：
- en: '![Directional animation](img/B04284_06_05.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![方向动画](img/B04284_06_05.jpg)'
- en: 'In our case, each row contains either the left or the right facing version
    of a specific animation. Knowing that, let''s create the header of the directional
    animation class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，每一行包含特定动画的左侧或右侧版本。了解这一点后，让我们创建方向动画类的标题：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This class doesn''t even require a constructor or a destructor, only the three
    methods from the base class that need to be implemented. Once again, note the
    inclusion of the `SpriteSheet.h` file due to its forward declaration in the header
    of the `Anim_Base` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类甚至不需要构造函数或析构函数，只需要实现基类中的三个方法。再次注意，由于`Anim_Base`类的头文件中存在前向声明，因此包含了`SpriteSheet.h`文件：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now let''s slice through that texture to fashion our sprite:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将纹理切割成我们的精灵：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we construct a rectangle. Its top-left corner position is the sprite
    size multiplied by the current frame on the *x* axis and the sprite size multiplied
    by the sum of the current animation row and the sprite sheet direction on the
    *y* axis. Because the direction enumeration maps the directions to numerical values
    of either `0` or `1`, it makes obtaining the row for the correct direction really
    easy, as shown above. After the top-left corner is set up, we pass in the sprite
    size in pixels and crop the sprite sheet based on the rectangle that was constructed.
    This yields us a sprite!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们构造一个矩形。其左上角位置是精灵大小乘以当前帧在*x*轴上的值，以及精灵大小乘以当前动画行和精灵表方向在*y*轴上的总和。由于方向枚举将方向映射到`0`或`1`的数值，这使得获取正确方向的行变得非常容易，如上图所示。设置好左上角后，我们传入像素单位的精灵大小，并根据构造的矩形裁剪精灵表。这样就得到了一个精灵！
- en: 'The final piece of the puzzle in the animation department is implementing the
    `FrameStep` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 动画领域的最后一部分是实现`FrameStep`方法：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, we check which direction we should roll the frames in, since it could
    be necessary in the future to define backwards-moving animations. If the starting
    frame number is lower than the ending frame number, we're moving in the positive
    direction. We then check if the frame is out of bounds, and based on whether it
    is looping or not, we either reset the current frame to start, or set it to the
    end of the animation and then pause it. The same logic applies if the animation
    is playing backwards, except the direction is reversed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查应该滚动帧的方向，因为将来可能需要定义反向移动的动画。如果起始帧号低于结束帧号，我们正在向正方向移动。然后我们检查帧是否超出范围，并根据它是循环还是非循环，我们将当前帧重置为起始帧，或者将其设置为动画的末尾并暂停它。如果动画是反向播放的，则应用相同的逻辑，只是方向相反。
- en: 'Lastly, the method responsible for reading in data from files:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，负责从文件中读取数据的`readFile`方法：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With that final bit of code, the animation portion is finished! Everything we
    need in order to implement loading the sprite sheet file is now available.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 随着最后一段代码的完成，动画部分就结束了！为了实现加载精灵表文件，我们现在已经拥有了所有需要的东西。
- en: Loading the sprite sheet files
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载精灵表文件
- en: 'The loading method begins, as per usual, by setting up the file, reading it,
    and obtaining the current line. The first identifier from the line is loaded into
    the `type` variable. The rest is fairly typical:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 加载方法通常从设置文件、读取文件和获取当前行开始。从该行中加载的第一个标识符被存入`type`变量。其余部分相当典型：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In order to avoid confusion, the parsing of different types of entries in this
    file has been split up into separate sections. Let''s begin with the texture loading:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，该文件中不同类型条目的解析已被分成单独的部分。让我们从纹理加载开始：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we check if the texture hasn't been initialized already in order to avoid
    duplicate entries. If it hasn't, the `keystream` variable spits out the texture
    handle, which gets passed into the texture manager in an `if` statement. This
    is done to catch errors of invalid handles. If the handle is valid, the texture
    name is kept around for later freeing of resources and the sprite we'll be using
    for drawing is set to point to the texture.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查纹理是否已经被初始化，以避免重复条目。如果没有，`keystream`变量输出纹理句柄，该句柄在`if`语句中传递给纹理管理器。这样做是为了捕获无效句柄的错误。如果句柄有效，纹理名称被保留以供稍后释放资源，我们将用于绘制的精灵设置为指向纹理。
- en: 'Time to read the smaller bits of information in:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是阅读更小的信息块的时候了：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The most dramatic entry has been saved for last. At this moment, we parse the
    animations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最引人注目的条目留到最后。此刻，我们解析动画：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: First, the animation name gets loaded and the animation container is checked
    in order to avoid duplicates. The type of animation that was loaded previously
    is then checked in order to construct a correct animation type. We could use a
    factory method for this, but since we only have one type of animation so far,
    it seems pointless at this time. The animation structure then gets data streamed
    into it from our `stringstream` object, initializing it. Furthermore, the animation
    is reset in order to zero-out its values. Once it gets inserted into the animation
    container, the last thing we check for is whether the current animation member
    has been assigned a value yet. If it hasn't, this is the first animation in the
    sprite sheet file, which we're assuming is the default. It gets assigned to the
    current animation member and set to play.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，加载动画名称并检查动画容器以避免重复。然后检查之前加载的动画类型，以便构建正确的动画类型。我们可以使用工厂方法来做这件事，但由于我们目前只有一种类型的动画，所以现在似乎没有必要。然后，动画结构从我们的`stringstream`对象中接收数据流，初始化它。此外，动画被重置以将其值归零。一旦它被插入到动画容器中，我们最后检查的是当前动画成员是否已经分配了值。如果没有，这是精灵图文件中的第一个动画，我们假设它是默认的。它被分配给当前动画成员并设置为播放。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While having good graphics isn't the most important aspect of a game, going
    from basic shapes to actual sprites being animated on screen can make a world
    of difference in the eyes of a player. Granted, prettifying a product doesn't
    fix whatever flaws it may have, which seems like a popular mentality nowadays.
    Immersing the player into the game world, however, as well as bringing to life
    what seemed like a bunch of squares, is the effect we're after, which, with the
    completion of this chapter, you are now able to achieve with a few basic techniques.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然良好的图形不是游戏最重要的方面，但从基本形状到屏幕上实际动画的精灵可以给玩家带来巨大的差异。当然，美化产品并不能修复它可能存在的任何缺陷，这似乎是现在的流行心态。然而，将玩家沉浸到游戏世界中，以及让看起来像是一堆方块的东西栩栩如生，这是我们追求的效果，而随着本章的完成，你现在可以使用一些基本技巧实现这一点。
- en: In the next chapter, we will be covering common game development elements that
    will unify all of the graphical bits and pieces we built into a fully functional
    game with platforming elements, enemies, and multiple levels. See you there!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍常见的游戏开发元素，这些元素将把我们在游戏中构建的所有图形元素统一成一个具有平台元素、敌人和多个级别的完整游戏。那里见！
