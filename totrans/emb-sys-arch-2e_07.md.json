["```cpp\n#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023830))\n#define GPIOD_AHB1_CLOCK_ER (1 << 3)\n#define GPIOD_BASE 0x40020c00\n#define GPIOD_MODE (*(volatile uint32_t *)(GPIOD_BASE + 0x00))\n#define GPIOD_AFL (*(volatile uint32_t *)(GPIOD_BASE + 0x20))\n#define GPIOD_AFH (*(volatile uint32_t *)(GPIOD_BASE + 0x24))\n#define GPIO_MODE_AF (2)\n#define UART3_PIN_AF (7)\n#define UART3_RX_PIN (9)\n#define UART3_TX_PIN (8)\nstatic void uart3_pins_setup(void)\n{\n  uint32_t reg;\n  AHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;\n  reg = GPIOD_MODE & ~ (0x03 << (UART3_RX_PIN * 2));\n  GPIOD_MODE = reg | (2 << (UART3_RX_PIN * 2));\n  reg = GPIOD_MODE & ~ (0x03 << (UART3_TX_PIN * 2));\n  GPIOD_MODE = reg | (2 << (UART3_TX_PIN * 2));\n  reg = GPIOD_AFH & ~(0xf << ((UART3_TX_PIN - 8) * 4));\n  GPIOD_AFH = reg | (UART3_PIN_AF << ((UART3_TX_PIN - 8) *\n     4));\n  reg = GPIOD_AFH & ~(0xf << ((UART3_RX_PIN - 8) * 4));\n  GPIOD_AFH = reg | (UART3_PIN_AF << ((UART3_RX_PIN - 8) *\n     4));\n}\n```", "```cpp\n#define APB1_CLOCK_ER (*(volatile uint32_t *)(0x40023840))\n#define UART3_APB1_CLOCK_ER_VAL (1 << 18)\n```", "```cpp\n#define UART3 (0x40004800)\n#define UART3_SR (*(volatile uint32_t *)(UART3))\n#define UART3_DR (*(volatile uint32_t *)(UART3 + 0x04))\n#define UART3_BRR (*(volatile uint32_t *)(UART3 + 0x08))\n#define UART3_CR1 (*(volatile uint32_t *)(UART3 + 0x0c))\n#define UART3_CR2 (*(volatile uint32_t *)(UART3 + 0x10))\n```", "```cpp\n#define UART_CR1_UART_ENABLE (1 << 13)\n#define UART_CR1_SYMBOL_LEN (1 << 12)\n#define UART_CR1_PARITY_ENABLED (1 << 10)\n#define UART_CR1_PARITY_ODD (1 << 9)\n#define UART_CR1_TX_ENABLE (1 << 3)\n#define UART_CR1_RX_ENABLE (1 << 2)\n#define UART_CR2_STOPBITS (3 << 12)\n#define UART_SR_TX_EMPTY (1 << 7)\n```", "```cpp\nint uart3_setup(uint32_t bitrate, uint8_t data,\nchar parity, uint8_t stop)\n{\n  uart3_pins_setup();\n```", "```cpp\n  APB1_CLOCK_ER |= UART3_APB1_CLOCK_ER_VAL;\n```", "```cpp\n  UART3_CR1 |= UART_CR1_TX_ENABLE;\n```", "```cpp\n  UART3_BRR = CLOCK_SPEED / bitrate;\n```", "```cpp\n  /* Default: No parity */\n  UART3_CR1 &= ~(UART_CR1_PARITY_ENABLED | \n      UART_CR1_PARITY_ODD);\n   switch (parity) {\n       case 'O':\n           UART3_CR1 |= UART_CR1_PARITY_ODD;\n           /* fall through to enable parity */\n       case 'E':\n           UART3_CR1 |= UART_CR1_PARITY_ENABLED;\n           break;\n}\n```", "```cpp\n  reg = UART3_CR2 & ~UART_CR2_STOPBITS;\n  if (stop > 1)\n    UART3_CR2 = reg | (2 << 12);\n```", "```cpp\n  UART3_CR1 |= UART_CR1_UART_ENABLE;\n  return 0;\n}\n```", "```cpp\nvoid uart3_write(const char *text)\n{\n  const char *p = text;\n  int i;\n  volatile uint32_t reg;\n  while(*p) {\n    do {\n      reg = UART3_SR;\n    } while ((reg & UART_SR_TX_EMPTY) == 0);\n    UART3_DR = *p;\n    p++;\n  }\n}\n```", "```cpp\n#include \"system.h\"\n#include \"uart.h\"\nvoid main(void) {\n  flash_set_waitstates();\n  clock_config();\n  uart3_setup(115200, 8, 'N', 1);\n  uart3_write(\"Hello World!\\r\\n\");\n  while(1)\n    WFI();\n}\n```", "```cpp\nint _write(void *r, uint8_t *text, int len)\n{\n  char *p = (char *)text;\n  int i;\n  volatile uint32_t reg;\n  text[len - 1] = 0;\n  while(*p) {\n    do {\n       reg = UART3_SR;\n    } while ((reg & UART_SR_TX_EMPTY) == 0);\n    UART3_DR = *p;\n    p++;\n  }\n  return len;\n}\n```", "```cpp\n#include <stdio.h>\n#include \"system.h\"\n#include \"uart.h\"\nvoid main(void) {\n  char name[] = \"World\";\n  flash_set_waitstates();\n  clock_config();\n  uart3_setup(115200, 8, 'N', 1);\n  printf(\"Hello %s!\\r\\n\", name);\n  while(1)\n    WFI();\n```", "```cpp\nUART3_CR1 |= UART_CR1_TX_ENABLE | UART_CR1_RX_ENABLE;\n```", "```cpp\nchar uart3_read(void)\n{\n  char c;\n  volatile uint32_t reg;\n  do {\n    reg = UART3_SR;\n  } while ((reg & UART_SR_RX_NOTEMPTY) == 0);\n  c = (char)(UART3_DR & 0xff);\n  return c;\n}\n```", "```cpp\nvoid main(void) {\n  char c[2];\n  flash_set_waitstates();\n  clock_config();\n  uart3_setup(115200, 8, 'N', 1);\n  uart3_write(\"Hello World!\\r\\n\");\n  while(1) {\n    c[0] = uart3_read();\n    c[1] = 0;\n    uart3_write(c);\n    uart3_write(\"\\r\\n\");\n  }\n}\n```", "```cpp\n#define UART_CR1_TXEIE (1 << 7)\n#define UART_CR1_RXNEIE (1 << 5)\nstatic void uart3_tx_interrupt_onoff(int enable)\n{\n  if (enable)\n    UART3_CR1 |= UART_CR1_TXEIE;\n  else\n    UART3_CR1 &= ~UART_CR1_TXEIE;\n}\nstatic void uart3_rx_interrupt_onoff(int enable)\n{\n  if (enable)\n    UART3_CR1 |= UART_CR1_RXNEIE;\n  else\n    UART3_CR1 &= ~UART_CR1_RXNEIE;\n}\n```", "```cpp\nvoid isr_uart3(void)\n{\n  volatile uint32_t reg;\n  reg = UART3_SR;\n  if (reg & UART_SR_RX_NOTEMPTY) {\n     /* Receive a new byte */\n  }\n  if ((reg & UART_SR_TX_EMPTY)\n  {\n     /* resume pending transmission */\n  }\n}\n```", "```cpp\n#define SPI1 (0x40013000)\n#define SPI1_CR1 (*(volatile uint32_t *)(SPI1))\n#define SPI1_CR2 (*(volatile uint32_t *)(SPI1 + 0x04))\n#define SPI1_SR (*(volatile uint32_t *)(SPI1 + 0x08))\n#define SPI1_DR (*(volatile uint32_t *)(SPI1 + 0x0c))\n```", "```cpp\n#define SPI_CR1_MASTER (1 << 2)\n#define SPI_CR1_SPI_EN (1 << 6)\n#define SPI_CR2_SSOE (1 << 2)\n#define SPI_SR_RX_NOTEMPTY (1 << 0)\n#define SPI_SR_TX_EMPTY (1 << 1)\n```", "```cpp\n#define APB2_CLOCK_ER (*(volatile uint32_t *)(0x40023844))\n#define APB2_CLOCK_RST (*(volatile uint32_t\n      *)(0x40023824))\n#define SPI1_APB2_CLOCK_ER_VAL (1 << 12)\n```", "```cpp\nstatic void spi1_reset(void)\n{\n   APB2_CLOCK_RST |= SPI1_APB2_CLOCK_ER_VAL;\n   APB2_CLOCK_RST &= ~SPI1_APB2_CLOCK_ER_VAL;\n}\n```", "```cpp\n#define SPI1_PIN_AF 5\n#define SPI1_CLOCK_PIN 5\n#define SPI1_MOSI_PIN 6\n#define SPI1_MISO_PIN 7\nstatic void spi1_pins_setup(void)\n{\n  uint32_t reg;\n  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;\n  reg = GPIOA_MODE & ~(0x03 << (SPI1_CLOCK_PIN * 2));\n  reg &= ~(0x03 << (SPI1_MOSI_PIN));\n  reg &= ~(0x03 << (SPI1_MISO_PIN));\n  reg |= (2 << (SPI1_CLOCK_PIN * 2));\n  reg |= (2 << (SPI1_MOSI_PIN * 2)) | (2 << (SPI1_MISO_PIN\n      *2))\n  GPIOA_MODE = reg;\n  reg = GPIOA_AFL & ~(0xf << ((SPI1_CLOCK_PIN) * 4));\n  reg &= ~(0xf << ((SPI1_MOSI_PIN) * 4));\n  reg &= ~(0xf << ((SPI1_MISO_PIN) * 4));\n  reg |= SPI1_PIN_AF << ((SPI1_CLOCK_PIN) * 4);\n  reg |= SPI1_PIN_AF << ((SPI1_MOSI_PIN) * 4);\n  reg |= SPI1_PIN_AF << ((SPI1_MISO_PIN) * 4);\n  GPIOA_AFL = reg;\n}\n```", "```cpp\n#define SLAVE_PIN 3\nstatic void slave_pin_setup(void)\n{\n  uint32_t reg;\n  AHB1_CLOCK_ER |= GPIOE_AHB1_CLOCK_ER;\n  reg = GPIOE_MODE & ~(0x03 << (SLAVE_PIN * 2));\n  GPIOE_MODE = reg | (1 << (SLAVE_PIN * 2));\n  reg = GPIOE_PUPD & ~(0x03 << (SLAVE_PIN * 2));\n  GPIOE_PUPD = reg | (0x01 << (SLAVE_PIN * 2));\n  reg = GPIOE_OSPD & ~(0x03 << (SLAVE_PIN * 2));\n  GPIOE_OSPD = reg | (0x03 << (SLAVE_PIN * 2));\n}\n```", "```cpp\nvoid spi1_setup(int polarity, int phase)\n{\n  spi1_pins_setup();\n  slave_pin_setup();\n  APB2_CLOCK_ER |= SPI1_APB2_CLOCK_ER_VAL;\n  spi1_reset();\n```", "```cpp\n  SPI1_CR1 = SPI_CR1_MASTER | (5 << 3) | (polarity << 1) | \n      (phase << 0);\n```", "```cpp\n  SPI1_CR2 |= SPI_CR2_SSOE;\n  SPI1_CR1 |= SPI_CR1_SPI_EN;\n}\n```", "```cpp\nuint8_t spi1_read(void)\n{\n  volatile uint32_t reg;\n  do {\n    reg = SPI1_SR;\n  } while ((reg & SPI_SR_RX_NOTEMPTY) == 0);\n  return (uint8_t)SPI1_DR;\n}\nvoid spi1_write(const char byte)\n{\n  int i;\n  volatile uint32_t reg;\n  SPI1_DR = byte;\n  do {\n    reg = SPI1_SR;\n  } while ((reg & SPI_SR_TX_EMPTY) == 0);\n}\n```", "```cpp\n slave_on();\n spi1_write(0x8F);\n b = spi1_read();\n spi1_write(0xFF);\n b = spi1_read();\n slave_off();\n```", "```cpp\n#define SPI_CR2_TXEIE (1 << 7)\n#define SPI_CR2_RXNEIE (1 << 6)\n```", "```cpp\nvoid isr_spi1(void)\n{\n  volatile uint32_t reg;\n  reg = SPI1_SR;\n  if (reg & SPI_SR_RX_NOTEMPTY) {\n    /* End of transmission: new data available on MISO*/\n  }\n  if ((reg & SPI_SR_TX_EMPTY)\n  {\n    /* End of transmission: the TX FIFO is empty*/\n  }\n}\n```", "```cpp\n#define APB1_CLOCK_ER (*(volatile uint32_t *)(0x40023840))\n#define APB1_CLOCK_RST (*(volatile uint32_t *)(0x40023820))\n#define I2C1_APB1_CLOCK_ER_VAL (1 << 21)\n```", "```cpp\n#define I2C1_PIN_AF 4\n#define I2C1_SCL 6\n#define I2C1_SDA 9\n#define GPIO_MODE_AF (2)\nstatic void i2c1_pins_setup(void)\n{\n  uint32_t reg;\n  AHB1_CLOCK_ER |= GPIOB_AHB1_CLOCK_ER;\n  /* Set mode = AF */\n  reg = GPIOB_MODE & ~(0x03 << (I2C1_SCL * 2));\n  reg &= ~(0x03 << (I2C1_SDA * 2));\n  GPIOB_MODE = reg | (2 << (I2C1_SCL * 2)) | \n      (2 << (I2C_SDA * 2));\n  /* Alternate function: */\n  reg = GPIOB_AFL & ~(0xf << ((I2C1_SCL) * 4));\n  GPIOB_AFL = reg | (I2C1_PIN_AF << ((I2C1_SCL - 8) * 4));\n  reg = GPIOB_AFH & ~(0xf << ((I2C1_SDA - 8) * 4));\n  GPIOB_AFH = reg | (I2C1_PIN_AF << ((I2C1_SDA - 8) * 4));\n}\n```", "```cpp\n#define I2C1 (0x40005400)\n#define APB1_SPEED_IN_MHZ (42)\n#define I2C1_CR1 (*(volatile uint32_t *)(I2C1))\n#define I2C1_CR2 (*(volatile uint32_t *)(I2C1 + 0x04))\n#define I2C1_OAR1 (*(volatile uint32_t *)(I2C1 + 0x08))\n#define I2C1_OAR2 (*(volatile uint32_t *)(I2C1 + 0x0c))\n#define I2C1_DR (*(volatile uint32_t *)(I2C1 + 0x10))\n#define I2C1_SR1 (*(volatile uint32_t *)(I2C1 + 0x14))\n#define I2C1_SR2 (*(volatile uint32_t *)(I2C1 + 0x18))\n#define I2C1_CCR (*(volatile uint32_t *)(I2C1 + 0x1c))\n#define I2C1_TRISE (*(volatile uint32_t *)(I2C1 + 0x20))\n#define I2C_CR2_FREQ_MASK (0x3ff)\n#define I2C_CCR_MASK (0xfff)\n#define I2C_TRISE_MASK (0x3f)\n#define I2C_CR1_ENABLE (1 << 0)\nvoid i2c1_setup(void)\n{\n  uint32_t reg;\n  i2c1_pins_setup();\n  APB1_CLOCK_ER |= I2C1_APB1_CLOCK_ER_VAL;\n  I2C1_CR1 &= ~I2C_CR1_ENABLE;\n  i2c1_reset();\n  reg = I2C1_CR2 & ~(I2C_CR2_FREQ_MASK);\n  I2C1_CR2 = reg | APB1_SPEED_IN_MHZ;\n  reg = I2C1_CCR & ~(I2C_CCR_MASK);\n  I2C1_CCR = reg | (APB1_SPEED_IN_MHZ * 5);\n  reg = I2C1_TRISE & ~(I2C_TRISE_MASK);\n  I2C1_TRISE = reg | APB1_SPEED_IN_MHZ + 1;\n  I2C1_CR1 |= I2C_CR1_ENABLE;\n}\n```", "```cpp\nstatic void i2c1_send_start(void)\n{\n  volatile uint32_t sr1;\n  I2C1_CR1 |= I2C_CR1_START;\n  do {\n    sr1 = I2C1_SR1;\n  } while ((sr1 & I2C_SR1_START) == 0);\n}\nstatic void i2c1_send_stop(void)\n{\n  I2C1_CR1 |= I2C_CR1_STOP;\n}\n```", "```cpp\nvoid i2c1_test_sequence(void)\n{\n  volatile uint32_t sr1, sr2;\n  const uint8_t address = 0x42;\n  I2C1_CR1 &= ~(I2C_CR1_ENABLE | I2C_CR1_STOP |\n      I2C_CR1_ACK);\n  I2C1_CR1 |= I2C_CR1_ENABLE;\n```", "```cpp\n  do {\n    sr2 = I2C1_SR2;\n  } while ((sr2 & I2C_SR2_BUSY) != 0);\n```", "```cpp\n  i2c1_send_start();\n```", "```cpp\n  I2C1_DR = (address << 1);\n  do {\n    sr2 = I2C1_SR2;\n  } while ((sr2 & (I2C_SR2_BUSY | I2C_SR2_MASTER)) !=\n          (I2C_SR2_BUSY | I2C_SR2_MASTER));\n```", "```cpp\n  I2C1_DR = (0x00);\n  do {\n    sr1 = I2C1_SR1;\n  } while ((sr1 & I2C_SR1_TX_EMPTY) != 0);\n  I2C1_DR = (0x01);\n  do {\n    sr1 = I2C1_SR1;\n  } while ((sr1 & I2C_SR1_TX_EMPTY) != 0);\n```", "```cpp\n  i2c1_send_stop();\n}\n```"]