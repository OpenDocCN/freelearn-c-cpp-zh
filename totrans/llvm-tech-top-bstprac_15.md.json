["```cpp\n//Semicolon-separated list of projects to build…\nLLVM_ENABLE_PROJECTS:STRING=\"clang;compiler-rt\"\n```", "```cpp\n$ ninja clang compiler-rt opt llvm-profdata\n```", "```cpp\nint main(int argc, char **argv) {\n  int buffer[3];\n  for (int i = 1; i < argc; ++i)\n    buffer[i-1] = atoi(argv[i]);\n  for (int i = 1; i < argc; ++i)\n    printf(\"%d \", buffer[i-1]);\n  printf(\"\\n\");\n  return 0;\n}\n```", "```cpp\n$ clang -Wall buffer_overflow.c -o buffer_overflow\n$ # No error or warning\n```", "```cpp\n$ ./buffer_overflow 1 2 3\n1 2 3\n$ ./buffer_overflow 1 2 3 4\nSegmentation fault (core dumped)\n$\n```", "```cpp\n$ clang -fsanitize=address buffer_overflow.c -o san_buffer_overflow\n```", "```cpp\n$ ./san_buffer_overflow 1 2 3\n1 2 3\n$ ./san_buffer_overflow 1 2 3 4\n=================================================================\n==137791==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffea06bccac at pc 0x0000004f96df bp 0x7ffea06bcc70…\nWRITE of size 4 at 0x7ffea06bccac thread T0\n…\n  This frame has 1 object(s):\n    [32, 44) 'buffer' <== Memory access at offset 44 overflows this variable\n…\n==137791==ABORTING\n$\n```", "```cpp\nvoid foo(int S, int E, int ST, int *a) {\n  for (int i = S; i < E; i += ST) {\n    a[i] = a[i + 1];\n  }\n}\nint main(int argc, char **argv) {\n  int start = atoi(argv[1]),\n      end = atoi(argv[2]),\n      step = atoi(argv[3]);\n  int a[100];\n  foo(start, end, step, a);\n  return 0;\n}\n```", "```cpp\n$ clang -O1 -fsanitize=loop-counter test_lpcsan.c -o test_lpcsan\n```", "```cpp\n$ ./test_lpcsan 0 100 1\n==143813==INFO: Found a loop with trip count 100\n$ ./test_lpcsan 0 50 2\n==143814==INFO: Found a loop with trip count 25\n$\n```", "```cpp\n    struct LoopCounterSanitizer\n      : public PassInfoMixin<LoopCounterSanitizer> {\n      PreservedAnalyses run(Loop&, LoopAnalysisManager&,\n                            LoopStandardAnalysisResults&, \n                            LPMUpdater&);\n    private:\n      // Sanitizer functions\n      LPCSetStartFn and LPCAtEndFn memory variables – they will store the Function instances that collect loop trip counts (FunctionCallee is a thin wrapper around Function that provides additional function signature information).\n    ```", "```cpp\n    PreservedAnalyses\n    LoopCounterSanitizer::run(Loop &LP, LoopAnalysisManager &LAM, LoopStandardAnalysisResults &LSR, LPMUpdater &U) {\n      initializeSanitizerFuncs method in the preceding code will populate LPCSetStartFn and LPCAtEndFn. Before we go into the details of initializeSanitizerFuncs, let's talk more about LPCSetStartFn and LPCAtEndFn.\n    ```", "```cpp\n    void foo(int S, int E, int ST) {\n      for (int i = S; i < E; i += ST) {\n        …\n      }\n    }\n    ```", "```cpp\n    void foo(int S, int E, int ST) {\n      for (int i = S; i < E; i += ST) {\n        lpc_set_start and lpc_at_end in the preceding code are Function instances that are stored in LPCSetStartFn and LPCAtEndFn, respectively. Here is one of the possible (pseudo) implementations of these two functions:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    void LoopCounterSanitizer::initializeSanitizerFuncs(Loop &LP) {\n      Module &M = *LP.getHeader()->getModule();\n      auto &Ctx = M.getContext();\n      Type *VoidTy = Type::__lpcsan_set_loop_start and __lpcsan_at_loop_end, from the module and storing their Function instances in LPCSetStartFn and LPCAtEndFn, respectively.The `Module::getOrInsertFunction` method either grabs the `Function` instance of the given function name from the module or creates one if it doesn't exist. If it's a newly created instance, it has an empty function body; in other words, it only has a function *declaration*.It is also worth noting that the second argument of `Module::getOrInsertFunction` is the return type of the `Function` inquiry. The rest (the arguments for `getOrInsertFunction`) represent the argument types of that `Function`.With `LPCSetStartFn` and `LPCAtEndFn` set up, let's see how we can insert them into the right place in IR.\n    ```", "```cpp\n    PreservedAnalyses\n    LoopCounterSanitizer::run(Loop &LP, LoopAnalysisManager &LAM, LoopStandardAnalysisResults &LSR, LPMUpdater &U) {\n      initializeSanitizerFuncs(LP);\n      Loop::getBounds from the preceding code returned an Optional<LoopBounds> instance. The Optional<T> class is a useful container that either stores an instance of the T type or is *empty*. You can think of it as a replacement for the T* to represent a computation result where a null pointer means an empty value. However, this has the risk of dereferencing a null pointer if the programmer forgets to check the pointer first. The Optional<T> class doesn't have this problem.With a `LoopBounds` instance, we can retrieve the induction variable's range and store it in the `StartVal`, `EndVal`, and `StepVal` variables.\n    ```", "```cpp\n    BasicBlock *ExitBlock = LP.__lpcsan_at_loop_end at the beginning of the *exit block*. This is because we can always expect the end value and the step value of the induction variable being defined before we leave the loop.These are all the implementation details for the `LoopCounterSanitizer` pass.\n    ```", "```cpp\nvoid foo(int S, int E, int ST, int *a) {\n  for (int i = S; i < E; i += ST) {\n    a[i] = a[i + 1];\n  }\n}\n```", "```cpp\ndefine void @foo(i32 %S, i32 %E, i32 %ST, i32* %a) {\n  %cmp9 = icmp slt i32 %S, %E\n  br i1 %cmp9, label %for.body.preheader, label %for.cond.   cleanup\nfor.body.preheader:  \n  %0 = sext i32 %S to i64\n  %1 = sext i32 %ST to i64\n  %2 = sext i32 %E to i64\n  br label %for.body\n…\nfor.body:                                         \n  %indvars.iv = phi i64 [ %0, %for.body.preheader ], [   %indvars.iv.next, %for.body ]\n  …\n  %indvars.iv.next = add i64 %indvars.iv, %1\n  %cmp = icmp slt i64 %indvars.iv.next, %2\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n}\n```", "```cpp\n$ opt -S –passes=\"loop(lpcsan)\" input.ll -o -\n```", "```cpp\ndeclare void @__lpcsan_set_loop_start(i32)\ndeclare void @__lpcsan_at_loop_end(i32, i32)\ndefine void @foo(i32 %S, i32 %E, i32* %a) {\n  %cmp8 = icmp slt i32 %S, %E\n  br i1 %cmp8, label %for.body.preheader, label %for.cond.cleanup\nfor.body.preheader: \n  %0 = sext i32 %S to i64\n  %wide.trip.count = sext i32 %E to i64\n  br label %for.body\nfor.cond.cleanup.loopexit:                        \n  %1 = trunc i64 %wide.trip.count to i32\n  call void @__lpcsan_at_loop_end(i32 %1, i32 1)\n  br label %for.cond.cleanup\nfor.body:\n  …\n  %3 = trunc i64 %0 to i32\n  call void @__lpcsan_set_loop_start(i32 %3)\n  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label    %for.body\n}\n```", "```cpp\ntypedef int v4si __attribute__((__vector_size__(16)));\nv4si v1 = (v4si){1, 2, 3, 4};\nv4si v2 = (v4si){5, 6, 7, 8};\nv4si v3 = v1 + v2; // = {6, 8, 10, 12}\n```", "```cpp\n    #include \"sanitizer_common/sanitizer_common.h\"\n    #include \"sanitizer_common/sanitizer_internal_defs.h\"\n    using namespace __sanitizer;\n    extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n    void s32 – available under the __sanitizer namespace – for a signed 32-bit integer rather than the normal int. The rationale behind this is that we might need to build Compiler-RT libraries for different hardware architectures or platforms, and the width of int might not be 32 bits on some of them.Second, although we are using C++ to implement our instrumentation functions, we need to expose them as C functions because C functions have a more stable `extern \"C\"` to functions you want to export. The `SANITIZER_INTERFACE_ATTRIBUTE` macro also ensures that the function will be exposed at the library interface correctly, so please add this as well.\n    ```", "```cpp\n    static CurLoopStart is a global variable that memorizes the *initial* induction variable value of the current loop. This is updated by __lpcsan_set_loop_start.Recall that when a loop is complete, `__lpcsan_at_loop_end` will be invoked. When that happens, we use the value stored in `CurLoopStart` and the `end` and `step` arguments to calculate the exact trip count of the current loop, before printing the result.\n    ```", "```cpp\n    …\n    set(LPCSAN_RTL_SOURCES\n        lpcsan.cpp)\n    CMakeLists.txt. Here are some highlights:i. Compiler-RT creates its own set of CMake macros/functions. Here, we are using two of them, `add_compiler_rt_component` and `add_compiler_rt_runtime`, to create a pseudo build target for the entire LPCSan and the real library build target, respectively.ii. Different from a conventional build target, if a sanitizer wants to use supporting/utility libraries in Compiler-RT – for example, `RTSanitizerCommon` in the preceding code – we usually link against their *object files* rather than their library files. More specifically, we can use the `$<TARGET_OBJECTS:…>` directive to import supporting/utility components as one of the input sources.iii. A sanitizer library can support multiple architectures and platforms. In Compiler-RT, we are enumerating all the supported architectures and creating a sanitizer library for each of them.Again, the preceding snippet is just a small part of our build script. Please refer to our sample code folder for the complete `CMakeLists.txt` file.\n    ```", "```cpp\n$ ninja lpcsan\n```", "```cpp\n    …\n    // Shadow Call Stack\n    SANITIZER(\"shadow-call-stack\", ShadowCallStack)\n    // Loop Counter Sanitizer\n    LoopCounter, to the SanitizerKind class.It turns out that the driver will parse the `-fsanitize` command-line option and *automatically* translate `loop-counter` into `SanitizerKind::LoopCounter` based on the information we provided in `Sanitizers.def`.\n    ```", "```cpp\n    bool needsLsanRt() const {…}\n    bool needsLpcsanRt() const {\n      return Sanitizers.has(SanitizerKind::LoopCounter);\n    }\n    ```", "```cpp\n    …\n    if (SanArgs.needsLsanRt() && SanArgs.linkRuntimes())\n      StaticRuntimes.push_back(\"lsan\");\n    if (SanArgs.needsLpcsanRt() && SanArgs.linkRuntimes())\n      StaticRuntimes.push_back(\"lpcsan\");\n    …\n    ```", "```cpp\n    SanitizerMask Res = ToolChain::getSupportedSanitizers();\n    …\n    Res |= SanitizerKind::LoopCounter;\n    …\n    ```", "```cpp\n    …\n    // `PB` has the type of `CodeGen, is a place where the Clang and LLVM libraries meet. Therefore, we will see several LLVM APIs appear in this place. There are primarily two tasks for this CodeGen component:a. Converting the Clang AST into its equivalent LLVM IR `module`b. Constructing an LLVM pass pipeline to optimize the IR and generate machine codeThe previous snippet was trying to customize the second task – that is, customizing the LLVM Pass pipeline. The specific function – `addSanitizers` – we are modifying here is responsible for putting sanitizer passes into the pass pipeline. To have a better understanding of this code, let's focus on two of its components:i. `PassBuilder`: This class provides predefined pass pipeline configurations for each optimization level – that is, the O0 ~ O3 notations (as well as Os and Oz for size optimization) we are familiar with. In addition to these predefined layouts, developers are free to customize the pipeline by leveraging the `PassBuilder` supports several EPs, such as at the *beginning* of the pipeline, at the *end* of the pipeline, or at the end of the vectorization process, to name a few. An example of using EP can be found in the preceding code, where we used the `PassBuilder::registerOptimizerLastEPCallback` method and a lambda function to customize the EP located at the *end* of the Pass pipeline. The lambda function has two arguments: `ModulePassManager` – which represents the pass pipeline – and the current optimization level. Developers can use `ModulePassManager::addPass` to insert arbitrary LLVM passes into this EP.ii. `ModulePassManager`: This class represents a Pass pipeline – or, more specifically, the pipeline for `Module`. There are, of course, other PassManager classes for different IR units, such as `FunctionPassManager` for `Function`. In the preceding code, we were trying to use the `ModulePassManager` instance to insert our `LoopCounterSanitizer` pass whenever `SanitizerKind::LoopCounter` was one of the sanitizers that had been designated by the user. Since `LoopCounterSanitizer` is a loop pass rather than a module pass, we need to add some *adaptors* between the pass and PassManager. The `createFunctionToLoopPassAdaptor` and `createModuleToFunctionPassAdaptor` functions we were using here created a special instance that adapts a pass to a PassManager of a different IR unit.This is all the program logic that supports our LPCSan in the Clang compilation pipeline.\n    ```", "```cpp\n    …\n    set(COMPILER_RT_RUNTIMES effectively imports our LPCSan Compiler-RT libraries into the build.\n    ```", "```cpp\n$ clang -O1 -fsanitize=loop-counter input.c -o input\n```", "```cpp\nvoid foo(int N) {\n  if (N > 100)\n    bar();\n  else\n    zoo();\n}\n```", "```cpp\n__attribute__((noinline))\nvoid foo(int x) {\n  if (get_random() > 5)\n    printf(\"Hello %d\\n\", x * 3);\n}\nint main(int argc, char **argv) {\n  for (int i = 0; i < argc + 10; ++i) {\n    foo(i);\n  }\n  return 0;\n}\n```", "```cpp\n    $ clang -O1 -fprofile-generate option enables instrumentation-based PGO. The path that we added after this flag is the directory where profiling data will be stored.\n    ```", "```cpp\n    $ ./pgo `seq 1 3`\n    Hello 0\n    Hello 6\n    …\n    Hello 36\n    Hello 39\n    $\n    ```", "```cpp\n    $ ls pgo_prof.dir\n    default_10799426541722168222_0.profraw\n    ```", "```cpp\n    $ llvm-profdata llvm-profdata is a powerful tool for inspecting, converting, and merging profiling data files. We will look at it in more detail later. In the preceding command, we are merging and converting all the data files under pgo_prof.dir into a *single* *.profdata file.\n    ```", "```cpp\n    $ clang -O1 -fprofile-use=pgo_prof.profdata pgo.cpp \\\n            -emit-llvm -S -o pgo.after.ll\n    ```", "```cpp\ndefine void @foo(i32 %x) !prof !71 {\nentry:\n  %call = call i32 @get_random()\n  %cmp = icmp sgt i32 %call, 5\n  br i1 %cmp, label %if.then, label %if.end, !prof !72\nif.then:                                          \n  %mul = mul nsw i32 %x, 3\n  …\n}\n```", "```cpp\n!71 = !{!\"function_entry_count\", i64 110}\n!72 = !{!\"branch_weights\", i32 57, i32 54}\n```", "```cpp\n$ llvm-profdata show –-all-functions –-counts pgo_prof.profdata\n…\n  foo:\n    Hash: 0x0ae15a44542b0f02\n    Counters: 2\n    Block counts: [54, 57]\n  main:\n    Hash: 0x0209aa3e1d398548\n    Counters: 2\n    Block counts: [110, 1]\n…\nInstrumentation level: IR  entry_first = 0\nFunctions shown: 9\nTotal functions: 9\nMaximum function count: …\nMaximum internal block count: …\n```", "```cpp\n$ llvm-profdata merge –-text pgo_prof.profdata -o pgo_prof.proftext\n$ cat pgo_prof.proftext\n# IR level Instrumentation Flag\n:ir\n…\nfoo\n# Func Hash:\n784007059655560962\n# Num Counters:\n2\n# Counter Values:\n54\n57\n…\n```", "```cpp\n$ llvm-profdata merge –-binary pgo_prof.proftext -o pgo_prof.profdata\n```", "```cpp\n    void foo(int x) {\n      if (x > 10)\n        puts(\"hello\");\n      else\n        puts(\"world\");\n    }\n    ```", "```cpp\n    define void @foo(i32 %0) {\n      …\n      %4 = icmp sgt i32 %3, 10\n      %5 or %7. Now, let's generate the IR with instrumentation-based PGO enabled with the following command:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    $ clang -fprofile-use=combined_prof.profdata \\\n            foo.c -o optimized_foo\n    ```", "```cpp\n$ opt -pgo-test-profile-file=pgo_prof.profdata \\\n      --passes=\"pgo-instr-use,my-pass…\" pgo.ll …\n```", "```cpp\n// `BB` has the type of `BasicBlock&`\nInstruction *BranchInst = BB.getTerminator();\nMDNode *BrWeightMD = BranchInst->getMetadata(LLVMContext::MD_prof);\n```", "```cpp\nif (BrWeightMD->getNumOperands() > 2) {\n  // Taken counts for true branch\n  MDNode *TrueBranchMD = BrWeightMD->getOperand(1);\n  // Taken counts for false branch\n  MDNode *FalseBranchMD = BrWeightMD->getOperand(2);\n}\n```", "```cpp\nif (BrWeightMD->getNumOperands() > 2) {\n  // Taken counts for true branch\n  MDNode *TrueBranchMD = BrWeightMD->getOperand(1);\n  ConstantInt *NumTrueBrTaken\n    = mdconst::dyn_extract<ConstantInt>(TrueBranchMD);\n  …\n}\n```", "```cpp\n// `F` has the type of `Function&`\nFunction::ProfileCount EntryCount = F.getEntryCount();\nuint64_t EntryCountVal = EntryCount.getCount();\n```", "```cpp\n#include \"llvm/Analysis/BranchProbabilityInfo.h\"\nPreservedAnalyses run(Function &F, FunctionAnalysisManager &FAM) {\n  BranchProbabilityInfo &BPI\n    = FAM.getResult<BranchProbabilityAnalysis>(F);\n  BasicBlock *Entry = F.getEntryBlock();\n  BranchProbability BP = BPI.getEdgeProbability(Entry, 0);\n  …\n}\n```", "```cpp\n#include \"llvm/Analysis/BlockFrequencyInfo.h\"\nPreservedAnalyses run(Function &F, FunctionAnalysisManager &FAM) {\n  BlockFrequencyInfo &BFI\n    = FAM.getResult<BlockFrequencyAnalysis>(F);\n  for (BasicBlock *BB : F) {\n    BlockFrequency BF = BFI.getBlockFreq(BB);\n  }\n  …\n}\n```", "```cpp\n// `BB` has the type of `BasicBlock*`\n// `Entry` has the type of `BasicBlock*` and represents entry // block\nBlockFrequency BBFreq = BFI.getBlockFreq(BB),\n               EntryFreq = BFI.getBlockFreq(Entry);\nauto FreqInPercent\n  = (BBFreq.getFrequency() / EntryFreq.getFrequency()) * 100;\n```", "```cpp\n#include \"llvm/Analysis/ProfileSummaryInfo.h\"\nPreservedAnalyses run(Module &M, ModuleAnalysisManager &MAM) {\n  ProfileSummaryInfo &PSI = MAM.  getResult<ProfileSummaryAnalysis>(M);\n  …\n}\n```"]