- en: Chapter 14. Qt Hat Tips and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter taught you how to package a Qt application on all the major
    desktop and mobile platforms. This was the final step before shipping your application
    to your users. This chapter gathers some tips and tricks that will help you to
    develop your Qt applications with more ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Qt Creator tips - Useful keyboard shortcuts, session management, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining the memory with Qt Creator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Silencing unused variables and compiler warnings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to easily log an object's content to `QDebug`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing `QDebug` formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving logs to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a friendly command-line interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending `HTTP``GET` and `POST` requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing your workspace with sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common for a commercial product to be composed of several Qt projects.
    We regularly encountered this practice in this book-for example, an application
    composed of a core project and a GUI project. The Qt subdirs project is a nice
    way of handling inter-dependent projects within the same application.
  prefs: []
  type: TYPE_NORMAL
- en: However, when your product grows up, you'll want to open some unrelated projects
    in Qt Creator. In this case, you should use a **session**. A session is a complete
    snapshot of your workspace in Qt Creator. You can easily create a new session
    from **File** | **Session Manager** | **New**. Do not forget to switch to the
    new session. For example, you can create a session "Mastering Qt5" and load all
    project examples in a common workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sessions are useful when you need to quickly switch between two different
    workspaces. The following items in Qt Creator will be automatically saved in the
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: Opened projects of the hierarchical view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editor's windows (including the splits)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug breakpoints and expressions views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bookmarks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can change to a different session with **File** | **Session Manager** or
    by using the **Welcome** tab. A session can be destroyed without any impact on
    your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Searching with the Locator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to improve your productivity with Qt Creator is to use keyboard
    shortcuts. Qt Creator provides a lot of great keyboard shortcuts. Here is our
    selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching with the Locator](img/image00455.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'One of our favorites is the Locator. Press *Ctrl* + *K* to activate it. Then
    you can enjoy several features:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a filename (you can even use a partial entry) and press *Enter* to open
    this file. If the Locator suggests multiple files, you can use the arrows up and
    down to navigate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefix your search by `.`  (a dot followed by a space) to search C++ symbols
    in the current document. For example, on the `Task.cpp` file of the first chapter,
    try to use the Locator with `. set` and press *Enter* to go to the  `Task::setName()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter `l`  (*L* followed by a space) to go to a specific line. For example,
    "l 37" will bring us to line 37 of the current file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Locator provides plenty of features; take a look when you press *Ctrl* + *K*
    the next time!
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the compilation speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can speed up the compilation on a multicore computer. By default, when you
    build your project with Qt Creator, you only use one job (and, therefore, one
    core). But `make` supports the compilation with multiple jobs. You can use the `make
    -j N` option to allow N jobs at once. Do not forget to update your packaging scripts!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build your project from Qt Creator, you can set this option from **Projects**
    | **Build Steps** | **Make**. Click on **Details**, then, in the **Make arguments**
    field, put the value `-j 8` to allow eight jobs during the compilation, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Increasing the compilation speed](img/image00456.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Examining the memory with Qt Creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this section, we will use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared three primitive types: `boolean`, `integer`, and `character`. We
    also added a  `integerPointer` pointer that refers to the `integer` variable.
    Put a breakpoint at the last line and start the debugging. On the Debug pane,
    you should have the **Locals and Expressions** view. You can easily add/remove
    it from **Window** | **Views** | **Locals and Expressions**. Here is a screenshot
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the memory with Qt Creator](img/image00457.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that all our local variables are displayed with their values. The
    `character` line even displays three formats (ASCII, integer, and hexadecimal)
    of the letter **''A''**. You may also notice that the `integerPointer` line displays
    the automatically dereferenced value, not the pointer address. You can disable
    it with a right-click on the background of the **Locals and Expressions** window
    and then select **Dereference Pointers automatically**. You can see the pointer
    address and the dereferenced value appearing as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the memory with Qt Creator](img/image00458.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The console output displays the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we retrieve the same information in the console output. The
    **Locals and Expressions** view helps you to save time. You can display a lot
    of information without logging it with a `qDebug()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Creator provides a useful memory editor. You can open it with a right-click
    on a variable name in the **Locals and Expressions** window, and then select **Open
    Memory Editor** | **Open Memory Editor at Object's Address**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the memory editor, look at the value of the `boolean` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the memory with Qt Creator](img/image00459.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A hexadecimal editor appears with three parts (from the left to the right):'
  prefs: []
  type: TYPE_NORMAL
- en: The memory address of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hexadecimal representation of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ASCII representation of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The selection in the hexadecimal representation corresponds to the variable.
    We can confirm that the `boolean` variable is represented in memory by 1 byte.
    Because the value is `true`, the memory representation is **0x01**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `character` memory with the **Memory Editor** tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the memory with Qt Creator](img/image00460.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The character is also stored in memory with 1 byte. The hexadecimal representation
    is **0x41**. The character is encoded with the well-known ASCII format. Note that,
    on the right-hand side, the ASCII representation displays the **'A'**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the **Memory Editor** location of the `integer` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the memory with Qt Creator](img/image00461.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are two interesting facts to note. The integer is stored on 4 bytes. The
    value **05** is stored in hexadecimal as **05 00 00 00**. The byte order depends
    on the endianness of your processor. We are using an Intel CPU that is Little-Endian.
    Another CPU architecture with a Big-Endian memory storage will display the variable
    as **00 00 00 05**.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue to dive into the memory of our application, look at the last
    three screenshots closely. You might notice that, in this case, the three variables
    are contiguous in the stack memory. This behavior is not guaranteed depending
    on the implementation of your OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to open the memory editor on the `integerPointer` variable. The context
    menu offers you two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Open Memory Editor at Object's Address** option dereferences the pointer
    and brings you directly to the pointed value. You get the same result as the integer
    memory view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Open Memory Editor at Pointer's Address** option displays the raw pointer
    data, which is a memory address to where it is pointing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the **Memory Editor** tool showing the pointer''s address of `integerPointer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the memory with Qt Creator](img/image00462.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We are on a 64-bit OS, so our pointer is stored on 8 bytes. The data of this
    pointer is the hexadecimal value `ac 53 11 60 fe 7f 00 00`. This is the Little-Endian
    representation of the memory address `0x7ffe601153ac` displayed by the **Locals
    and Expressions** and by our console output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We display the memory, but we can also change it. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the current breakpoint and add a new one on the first `qDebug()` line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the debugging and look at the **Locals and Expressions**. If you double-click
    a variable's value, you can edit it. Note that the **Memory Editor** window immediately
    updates its representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our case, we set `boolean` value to false, `character` to 68 (that is 'D')
    and `integer` to 9\. When you are confident with your changes, continue the debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the final console output reflecting our modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Memory Editor** is a powerful tool: You can display and change your variable''s
    value, at runtime, without changing your source code and recompiling your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generating real random numbers is quite a difficult task for a computer. Commonly,
    we are using only a **pseudo-random number generation** (**PRNG**). The Qt framework
    provides the function `qrand()`, a thread-safe version of `std::rand()`. This
    function returns an integer between 0 and `RAND_MAX` (defined in `stdlib.h`).
    The following code shows two pseudo-random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using a modulo operator to get a value between 0 and 9\. Try to run
    your application several times. The numbers are always the same, in our case,
    3 then 7\. That is because each time we call `qrand()`, we retrieve the next number
    of the pseudo-random sequence, but the sequence is always the same! Fortunately,
    we can use `qsrand()` to initialize the PRNG with a seed. A seed is an unsigned
    integer that is used to generate a sequence. Try the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are using the seed 3, and we get a different value from
    `qrand()`--on our computer it is 5 and 4\. Great, but if you run this application
    several times, you will always have this sequence. One way of generating a different
    sequence each time you run your application is to use a different seed on each
    run. Run the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are now initializing the PRNG with the epoch time from `QDateTime`.
    You can try to run your application multiple times to see that we get different
    numbers each time! However, this solution is not recommended for cryptography.
    In this case, you should use a stronger random number engine.
  prefs: []
  type: TYPE_NORMAL
- en: Silencing unused variable warnings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your compiler is configured to output its warnings, you will probably sometimes
    see this kind of log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a safety warning to tell the developer to keep their code clean and
    avoid dead variables. It is a good practice to try to minimize this kind of warning.
    However, sometimes you have no choice: You override an existing function and you
    do not use all the parameters. You now face a conundrum: On the one hand you can
    silence the warning for your whole application, and on the other hand, you can
    let these safety warnings pile up in your compile output. There must be a better
    option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, you can silence the warning for your function only. There are two ways
    of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the C/C++ syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Qt macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say you override `myFunction(QString name, QString myVariable)` and
    you do not use `myVariable`. Using the C/C++ syntax, you just have to implement `myFunction()`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By commenting the variable's name, `myVariable`, in the function signature,
    you ensure that you will not (that is, cannot) use the variable in the function
    body. The compiler will also interpret it like this and will not output any warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt also provides a way of marking unused variables with the `Q_UNUSED` macro.
    Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply pass `myVariable` to `Q_UNUSED` and it will remove the warning from
    the compiler output. Behind the curtain, `Q_UNUSED` does not do anything magical
    with the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is a simple trick to fool the compiler; it sees `myVariable` "used", but
    nothing is done with it.
  prefs: []
  type: TYPE_NORMAL
- en: Logging custom objects to QDebug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are debugging complex objects, it is nice to output their current members'
    value to `qDebug()`. In other languages (such as Java), you may have encountered
    the `toString()` method or equivalent, which is very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sure, you could add a function void `toString()` to each object you want to
    log in order to write code with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There must be a more natural way of doing this in C++. Moreover, Qt already
    provides this kind of feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To achieve this, we will rely on a C++ operator overload. This will look very
    similar to what we did with `QDataStream` operators in [Chapter 10](part0097.xhtml#aid-2SG6I2
    "Chapter 10.  Need IPC? Get Your Minions to Work"), *Need IPC? Get Your Minions
    to Work*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a `struct Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the ability to properly output to `QDebug`, you just have to override
    the `<<` operator between `QDebug` and `Person` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `QDebugStateSaver` is a convenience class to save the settings of `QDebug`
    and restore them automatically upon destruction. It is good practice to always
    use it to be sure that you do not break `QDebug` in an `<<` operator overload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the function is the usual way of using `QDebug` and finally returning
    the modified `debug` variable. You can now use `Person` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: No need for a `toString()` function; simply use the person object. For those
    of you who wondered, yes, `Lenna` is really `64` at the time of wrting (2016).
  prefs: []
  type: TYPE_NORMAL
- en: Improving log messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt offers multiple ways of doing this. A good compromise between the result
    and its complexity is to combine the Qt log type with a custom message pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt defines five log types, from the least to the most critical level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qDebug()`: This is used to write custom debug messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qInfo()`: This is used to write informational messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qWarning()`: This is used to write warnings and recoverable errors in your
    applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qCrtitical()`: This is used to write critical error messages and report system
    errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qFatal()`: This is used to write a last message before automatically existing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to always use the most appropriate one!
  prefs: []
  type: TYPE_NORMAL
- en: By default, the message pattern is configured to only display your message without
    any extra data, but you can customize the pattern to display more information.
    This pattern can be changed at runtime by setting the `QT_MESSAGE_PATTERN` environment
    variable. You can also call the `qSetMessagePattern` function from your software
    to change the pattern. The pattern is just a string with some placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most common placeholders you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%{appname}`: This is your application name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%{file}`: This is the path to the source file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%{function}`: This is the function name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%{line}`: This is a line in the source file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%{message}`: This is an original message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%{type}`: This is the Qt log type ("debug", "info", "warning", "critical"
    or "fatal")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%{time [format]}`: This is the system time when the message occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An easy way to use it is to edit your `main.cpp` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get something like this in your application output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Try to play around with the Qt log types and the custom message pattern until
    you find a useful pattern for you.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more complex applications, you can use the `QLoggingCategory` class to define
    categories of logging. Visit [http://doc.qt.io/qt-5/qloggingcategory.html](http://doc.qt.io/qt-5/qloggingcategory.html)
    for more information on this.
  prefs: []
  type: TYPE_NORMAL
- en: Saving your logs to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common need for a developer is to have logs. In some situations, you cannot
    have access to the console output, or you have to study the application state
    afterwards. In both cases, the log has to be outputted to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Qt provides a practical way of redirecting your logs (`qDebug`, `qInfo`, `qWarning`,
    and so on) to any device that is convenient for you: `QtMessageHandler`. To use
    it, you have to register a function that will save the logs to the desired output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in your `main.cpp`, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature of the function must be respected to be properly called by Qt.
    Let''s review the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QtMsgType type`: This is an `enum` that describes the function that generated
    the message (`qDebug()`, `qInfo()`, `qWarning()`, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QMessageLogContext& context`: This contains additional information about the
    log message (source file where the log was produced, name of the function, line
    number, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const QString& message`: This is the actual message that was logged'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the function formats the log message before appending it to a file
    named `app.log`. You can easily add features in this function by adding a rotating
    log file, sending the logs through the network, or anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last missing part is the registration of `messageHandler()`, which is done
    in the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The call to the `qInstallMessageHander()` function is enough to reroute all
    the log messages to `app.log`. Once this is done, the logs will no longer be displayed
    in the console output and will be appended to `app.log` only.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to unregister your custom message handler function, call `qInstallMessageHandler(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a command-line interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command-line interface can be a wonderful way to start your application
    with some specific options. The Qt framework provides an easy way to define your
    options with the `QCommandLineParser` class. You can provide a short (for example, `-t`)
    or a long (for example, `--test`) option name. The application version and help
    menu is automatically generated. You can easily retrieve in your code if an option
    is set or not. An option can take a value and you can define a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a CLI to configure the log files. We want to define
    three options:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-debug` command, if set, enables the log file writing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-f` or `--file` command to define where to write the logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-l` or `--level <level>` command to specify the minimum log level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s talk about each step:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part uses the functions from `QCoreApplication` to set the application
    name and version. This information will be used by the `--version` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate a `QCommandLineParser` class. Then we instruct it to automatically
    add the help (`-h` or `--help`) and version (`-v` or `--version`) options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add our options with the `QCommandLineParser::addOptions()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request the `QCommandLineParser` class to process the command-line arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve and use the options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the parameters to create an option:'
  prefs: []
  type: TYPE_NORMAL
- en: '`optionName`: By using this parameter, you can use a single or multiple names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: In this parameter, the description of the option is displayed
    in the help menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueName` (Optional): This shows the value name if your option expects one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultValue` (Optional): This shows the default value of the option'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can retrieve and use the option using `QCommandLineParser::isSet()`, which
    returns true if the option was set by the user. If your option requires a value,
    you can retrieve it with `QCommandLineParser::value()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the display of the generated help menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following snippet displays the CLI in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Sending and receiving HTTP data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Requesting information to an HTTP server is a common task. Here again, the
    Qt folks prepared some useful classes to make it easy. To achieve this, we will
    rely on three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QNetworkAccessManager`: This class allows your application to send requests
    and receive replies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QNetworkRequest`: This class holds the request to be sent with all the information
    (headers, URL, data, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QNetworkReply`: This class contains the result of a `QNetworkRequest` class
    with the headers and the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QNetworkAccessManager` class is the pivot point of the whole Qt HTTP API.
    It is built around a single `QNetworkAccessManager` object that holds the configuration
    of the client, proxy settings, cache information, and much more. This class is
    designed to be asynchronous, so you do not need to worry about blocking your current
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see it in action in a custom `HttpRequest` class. First, the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QNetworkAccessManager` class works with the signal/slot mechanism, so `HttpRequest`
    inherits from `QObject` and uses the `Q_OBJECT` macro. We declare the following
    functions and member:'
  prefs: []
  type: TYPE_NORMAL
- en: '`executeGet()`: This is used to trigger an `HTTP GET` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replyFinished()`: This is the slot called when the `GET` request has completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mAccessManager`: This is the object that will be used for all our asynchronous
    requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s turn our attention to the constructor of the `HttpRequest` class in
    the `HttpRequest.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the body of the constructor, we connect the `finished()` signal from `mAccessManager`
    to our `replyFinished()` slot. This implies that every request sent through `mAccessManager`
    will trigger this slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough with the preparation; let''s see the request and reply in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `HTTP GET` request is processed using `mAccessManager.get()`. The `QNetworkAccessManager`
    class provides the function for other HTTP verbs (`head()`, `post()`, `put()`, `delete()`,
    and so on. It expects a `QNetworkRequest` access, which takes a URL in its constructor.
    This is the simplest form of an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we did our request using the URL [http://httpbin.org/ip](http://httpbin.org/ip),
    which will respond to the emitter''s IP address in the JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This website is a practical developer resource, where you can send your test
    requests and have useful information sent back to you. It avoids having to launch
    a custom web server to only test a few requests. This website is an open-source
    project freely hosted by Runscope. Of course, you can replace the request URL
    with anything you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take a look at [http://httpbin.org/](http://httpbin.org/) to see all the supported
    request types.
  prefs: []
  type: TYPE_NORMAL
- en: After the `executeGet()` function is completed, the `mAccessManager` object
    executes the request in a separate thread and calls our slot, `replyFinished()`,
    with the resulting `QNetworkReply*` object. In this code snippet, you can see
    how to retrieve the HTTP status code and check if any network error happened,
    as well as how to get the body of the response with `reply->readAll()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `QNetworkReply` class inherits from `QIODevice`, and therefore, you can
    read it all at once with `readAll()`, or by chunks with a loop on `read()`. This
    lets you adapt the reading to your needs using a familiar `QIODevice` API.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you are the owner of the `QNetworkReply*` object. You should not delete
    it by hand (your application might crash if you do so); instead, it's better to
    use the `reply->deleteLater()` function, which will let the Qt event loop pick
    the appropriate moment to delete this object.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see a more complex example of `QNetworkReply` with an `HTTP POST`
    method. There are times where you will need to keep track of the `QNetworkReply`
    class and have a more fine-grained control over its life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of an `HTTP POST` method that also relies on `HttpRequest::mAccessManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a `QNetworkRequest` class with a custom header: `Content-Type`
    is now `application/x-www-form-urlencoded` to respect the HTTP RFC. After that,
    a URL form is built, ready to be sent with the request. You can add as many items
    as you wish to the `urlQuery` object.
  prefs: []
  type: TYPE_NORMAL
- en: The next part gets interesting. When executing `mAccessManager.post()` with
    the request and the URL encoded form, the `QNetworkReply*` object is immediately
    returned to us. From here, we use some lambdas slots connected directly to reply
    rather than using `mAccessManage` slots. This lets you have precise control over
    what happens for each reply.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `QNetworkReploy::readyRead` signal comes from the `QIODevice`
    API and that it does not pass the `QNetworkReply*` object in the parameter. It
    is your job to store the reply in a member field somewhere or retrieve the emitter
    of the signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, this code snippet does not undo our preceding slot, `replyFinished()`,
    which is connected to `mAccessManager`. If you execute this code, you will have
    the following output sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The lambda connected to the `QNetworkReply::readyRead` signal is first called,
    and after that, the `HttpRequest::replyFinished` signal is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last feature we will cover on the Qt HTTP stack is synchronous requests.
    If you happen to need to manage the request threading yourself, the default asynchronous
    work mode of `QNetworkAccessManager` can get in your way. To circumvent this,
    you can use a custom `QEventLoop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we declare another `QNetworkAccessManager` that will not interfere
    with the one declared in `HttpRequest`. Right after, a `QEventLoop` object is
    declared and connected to `localManager`. When `QNetworkAccessManager` emits the `finished()`
    signal, `eventLoop` will quit and the calling function will resume.
  prefs: []
  type: TYPE_NORMAL
- en: The `request` is built as usual, the `reply` object is retrieved, and the function
    becomes blocked with the call to `eventLoop.exec()`. The function is blocked until `localManager`
    has emitted its finished signal. In other words, the request is still done asynchronously;
    the sole difference is that the function is blocked until the request is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `reply` object can be safely read and deleted at the end of the
    function. This `QEventLoop` trick can be used any time a synchronous wait for
    a Qt signal is needed; use it wisely to avoid blocking the UI thread!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned some tips that complete your Qt knowledge. You
    should now have the ability to use Qt Creator with ease and efficiency. The `QDebug`
    format should not hold any secrets now, and you can now save your logs to a file
    without even blinking. You can create a good-looking CLI interface, debug the
    memory of any program without shaking, and execute an HTTP request with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: We sincerely hope that you had as much fun reading this book as we did writing
    it. In our opinion, Qt is a great framework, and it covers many areas that deserve
    to be deepened with a book (or several books!). We hope you keep coding C++ Qt
    code with fun and pleasure by building efficient and beautifully crafted applications.
  prefs: []
  type: TYPE_NORMAL
