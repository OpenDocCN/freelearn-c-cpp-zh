- en: Intertask Communication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务间通信
- en: Now that we're able to create tasks, it's time to start passing data between
    them. After all, you don't often run into systems that have a bunch of parallel
    tasks operating completely independently of one another; normally, you will need
    to pass some data between different tasks in the system. This is where intertask
    communication comes into play.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建任务，是时候开始在它们之间传递数据了。毕竟，你很少会遇到完全独立运行的并行任务系统；通常，你需要在系统中的不同任务之间传递一些数据。这就是任务间通信发挥作用的地方。
- en: In FreeRTOS, intertask communication can be achieved using queues and direct
    task notifications. In this chapter, we'll cover a few different use cases for
    queues using examples and discuss the pros and cons of each. We will look at all
    of the details regarding tasks that block while waiting for an item to appear
    in the queue, as well as timeouts. Once we have looked at queues, we'll move on
    to task notifications and learn why we should use them and when.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeRTOS中，可以使用队列和直接任务通知来实现任务间通信。在本章中，我们将通过示例介绍队列的几个不同用例，并讨论每个用例的优缺点。我们将查看有关在队列中等待项目出现时阻塞的任务的所有细节，以及超时。在查看队列之后，我们将转向任务通知，并了解为什么我们应该使用它们以及何时使用。
- en: 'In a nutshell, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将涵盖以下主题：
- en: Passing data through queues by value
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值传递数据通过队列
- en: Passing data through queues by reference
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用传递数据
- en: Direct task notifications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接任务通知
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the exercises in this chapter, you will require the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，你需要以下内容：
- en: Nucleo F767 development board
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nucleo F767开发板
- en: Micro-USB cable
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro-USB线
- en: STM32CubeIDE and source code (see the instructions in [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml),
    *Selecting an IDE – Setting Up Our IDE*)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32CubeIDE和源代码（见[第5章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)，*选择IDE –
    设置我们的IDE*）
- en: SEGGER JLink, Ozone, and SystemView (see [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml), *Debugging
    Tools for Real-Time Systems*)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEGGER JLink、Ozone和SystemView（见[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*）
- en: 'The easiest way to build the examples is to build all Eclipse configurations
    at once, then load and view them using Ozone:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 构建示例的最简单方法是同时构建所有Eclipse配置，然后使用Ozone加载和查看它们：
- en: In *STM32CubeIDE*, right-click on the project.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*STM32CubeIDE*中，右键单击项目。
- en: Select Build.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“构建”。
- en: Select Build All. All examples will be built into their own named subdirectory
    (this may take a while).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“构建所有”。所有示例都将构建到它们自己的命名子目录中（这可能需要一段时间）。
- en: In Ozone*,* you can now quickly load each `<exampleName>.elf` file—see `Chapter6`
    for instructions on how to do this.  The correct source files that are linked
    into the executable will automatically be displayed.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ozone*中，你现在可以快速加载每个`<exampleName>.elf`文件——见`Chapter6`中的说明，了解如何进行此操作。正确链接到可执行文件中的源文件将自动显示。
- en: All of the example code in this chapter can be downloaded from [https://https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_9](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_9).
    Each `main*.c` has its own Eclipse-based configuration inside the `Chapter_9`
    project, ready to compile and load onto the Nucleo board.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例代码都可以从[https://https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_9](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_9)下载。每个`main*.c`文件都在`Chapter_9`项目内部有自己的基于Eclipse的配置，准备好编译并加载到Nucleo板上。
- en: Passing data through queues by value
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过值传递数据通过队列
- en: Like semaphores and mutexes, queues are among the most widely used (and implemented)
    structures when operating across multiple asynchronously executing tasks. They
    can be found in nearly every operating system, so it is very beneficial to understand
    how to use them. We'll take a look at several different ways of using queues and
    interacting with them to affect a task's state.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像信号量和互斥锁一样，队列是在跨多个异步执行的任务操作时最广泛使用（和实现）的结构之一。它们几乎可以在每个操作系统中找到，因此了解如何使用它们是非常有益的。我们将探讨几种不同的使用队列和与之交互的方法，以影响任务的状态。
- en: In the following examples, we'll learn how to use queues as a means of sending
    *commands* to an LED state machine. First, we'll examine a very simple use case,
    passing a single one-byte value to a queue and operating on it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将学习如何将队列用作向LED状态机发送*命令*的手段。首先，我们将检查一个非常简单的用例，将单个单字节值传递到队列中并对其操作。
- en: Passing one byte by value
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过值传递一个字节
- en: 'In this example, a single `uint8_t` is set up to pass individual enumerations, `(LED_CMDS)`,
    defining the state of one LED at a time or all of the LEDs (on/off).  Here''s
    a summary of what is covered in this example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，设置了一个单个`uint8_t`来传递单个枚举，`(LED_CMDS)`，一次定义一个LED的状态或所有LED的状态（开/关）。以下是本例中涵盖的内容摘要：
- en: '`ledCmdQueue`: A queue of one-byte values (`uint8_t`) representing an enumeration
    defining LED states.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ledCmdQueue`：一个单字节值（`uint8_t`）的队列，表示定义LED状态的枚举。'
- en: '`recvTask`: This task receives a byte from the queue, executes the desired
    action, and immediately attempts to receive the next byte from the queue.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recvTask`：这个任务从队列中接收一个字节，执行所需的操作，然后立即尝试从队列中接收下一个字节。'
- en: '`sendingTask`: This task sends enumerated values to the queue using a simple
    loop, with a 200 ms delay between each send (so the LEDs turning on/off are visible).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendingTask`：这个任务通过一个简单的循环将枚举值发送到队列中，每次发送之间有200毫秒的延迟（这样LED的开关动作就可见了）。'
- en: 'So, let''s begin:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧：
- en: 'Set up an `enum` to help us describe the values that are being passed into
    the queue:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个`enum`来帮助我们描述传递到队列中的值：
- en: 'The following is an excerpt from `mainQueueSimplePassByValue.c`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`mainQueueSimplePassByValue.c`中摘录的内容：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similar to the initialization paradigm of semaphores, queues must first be
    created and their handles stored so they can be used to access the queue later.
    Define a handle to be used to point at a queue that is to be used for passing
    around instances of `uint8_t`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与信号量的初始化范例类似，队列必须首先创建并存储其句柄，以便以后可以使用它来访问队列。定义一个句柄，用于指向用于传递`uint8_t`实例的队列：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the queue (verifying its successful creation before continuing) using
    the `xQueueCreate()` function:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`xQueueCreate()`函数创建队列（在继续之前验证其成功创建）：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s quickly outline what we see here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 快速概述一下我们在这里看到的内容：
- en: '`uxQueueLength`: The maximum number of elements the queue can hold'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uxQueueLength`：队列可以容纳的最大元素数'
- en: '`uxItemSize`: The size (in bytes) of each element in the queue'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uxItemSize`：队列中每个元素的大小（以字节为单位）'
- en: 'Return value: A handle to the queue that is created (or `NULL` upon error)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值：创建的队列的句柄（或错误时返回`NULL`）
- en: 'Our call to `xQueueCreate` will look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`xQueueCreate`的调用将如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s outline what we see here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们概述一下我们在这里看到的内容：
- en: The queue holds up to `2` elements.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列最多可以容纳`2`个元素。
- en: Each element is sized to hold `uint8_t` (a single byte is large enough to store
    the value of any enumeration we have explicitly defined).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个元素的大小足以存储`uint8_t`（一个字节足以存储我们明确定义的任何枚举的值）。
- en: '`xQueueCreate` returns a handle to the queue created, which is stored in `ledCmdQueue`. 
    This "handle" is a global that will be used by various tasks when accessing the
    queue.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xQueueCreate`返回创建的队列的句柄，该句柄存储在`ledCmdQueue`中。这个“句柄”是一个全局变量，将被各种任务在访问队列时使用。'
- en: 'The beginning of our `recvTask()` looks like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`recvTask()`的开始如下所示：'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s have a close look at the actual queue receive line highlighted in the
    preceding code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看前面代码中突出显示的实际队列接收行：
- en: '`if(xQueueReceive(ledCmdQueue, &nextCmd, portMAX_DELAY) == pdTRUE)`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`if(xQueueReceive(ledCmdQueue, &nextCmd, portMAX_DELAY) == pdTRUE)`'
- en: The handle `ledCmdQueue` is used to access the queue.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用句柄`ledCmdQueue`来访问队列。
- en: A local `uint8_t`, `nextCmd`, is defined on the stack. The address of this variable
    (a pointer) is passed. `xQueueReceive` will copy the next `LED_CMD` enumeration
    (stored as a byte in the queue) into `nextCmd`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在栈上定义了一个局部`uint8_t`，`nextCmd`。传递这个变量的地址（一个指针）。`xQueueReceive`将下一个`LED_CMD`枚举（存储在队列中的字节）复制到`nextCmd`中。
- en: An infinite timeout is used for this access—that is, this function will never
    return if nothing is added to the queue (the same as timeouts for mutex and semaphore
    API calls).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于此访问使用无限超时——也就是说，如果队列中没有添加任何内容，此函数将永远不会返回（这与互斥锁和信号量API调用的超时相同）。
- en: The `if( <...> == pdTRUE)` is redundant since the delay time is infinite; however,
    it is a good idea to set up error handling ahead of time so that if a noninfinite
    timeout is later defined, the error state won't be forgotten about down the road.
    It is also possible for `xQueueReceive()` to fail for other reasons (such as an
    invalid queue handle).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于延迟时间是无限的，所以`if( <...> == pdTRUE)`是多余的；然而，提前设置错误处理是一个好主意，这样如果以后定义了非无限超时，就不会忘记错误状态。`xQueueReceive()`也可能因其他原因失败（例如，无效的队列句柄）。
- en: 'The `sendingTask` is a simple `while` loop that uses prior knowledge of the
    enum values to pass different values of `LED_CMDS` into `ledCmdQueue`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendingTask`是一个简单的`while`循环，它使用对枚举值的先验知识将不同的`LED_CMDS`值传递到`ledCmdQueue`中：'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The arguments for the sending side''s `xQueueSend()` are nearly identical to
    the receiving side''s `xQueueReceive()`, the only difference being that we''re
    sending data *to* the queue this time:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方的 `xQueueSend()` 的参数几乎与接收方的 `xQueueReceive()` 相同，唯一的区别是我们这次是向队列发送数据：
- en: '`xQueueSend(ledCmdQueue, &ledCmd, portMAX_DELAY);`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`xQueueSend(ledCmdQueue, &ledCmd, portMAX_DELAY);`'
- en: '`ledCmdQueue`: The handle for the queue to send the data to'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ledCmdQueue`：发送数据的队列句柄'
- en: '`&ledCmd`: The address of the data to pass to the queue'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&ledCmd`：要传递到队列中的数据的地址'
- en: '`portMax_DELAY`: The number of RTOS ticks to wait for the queue space to become
    available (if the queue is full)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`portMax_DELAY`：等待队列空间变为可用（如果队列已满）的 RTOS 指针数'
- en: Similar to timeouts from `xQueueReceive` when nothing is in the queue before
    the timeout value is reached, calls to `xQueueSend` can time out if the queue
    remains full beyond the specified timeout and the item isn't added to the queue.
    If your application has a noninfinite timeout (which in nearly all cases it should),
    you'll need to consider what should happen in this case. Courses of action could
    range from simply dropping the data item (it will be lost forever) to throwing
    an assert and going into some type of emergency/panic state with an emergency
    shutdown. A reboot is also popular in some contexts. The exact behavior will generally
    be dictated by the type of project/product you're working on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于在达到超时值之前队列中没有内容时 `xQueueReceive` 的超时，如果队列在指定的超时时间内仍然满载且项目未添加到队列中，`xQueueSend`
    的调用可能会超时。如果你的应用程序有一个非无限的超时（在几乎所有情况下都应该是这样），你需要考虑在这种情况下应该发生什么。可能的行动方案包括简单地丢弃数据项（它将永远丢失）到抛出一个断言并进入某种紧急/恐慌状态，并执行紧急关闭。在某些情况下，重启也很流行。确切的行为通常将由你正在工作的项目/产品的类型决定。
- en: Feel free to build and download `queueSimplePassByValue` to the Nucleo dev board.
    You'll notice that the LEDs follow the pattern defined by the definition of the
    `LED_CMDS` enum: `ALL_OFF`, `RED_ON`, `RED_OFF`, `BLUE_ON`, `BLUE_OFF`, `GREEN_ON`,
    `GREEN_OFF`, `ALL_ON`, with 200 ms between each transition.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随意构建并下载 `queueSimplePassByValue` 到 Nucleo 开发板上。你会注意到 LED 会遵循由 `LED_CMDS` 枚举定义的模式：`ALL_OFF`、`RED_ON`、`RED_OFF`、`BLUE_ON`、`BLUE_OFF`、`GREEN_ON`、`GREEN_OFF`、`ALL_ON`，每个状态转换之间间隔
    200 毫秒。
- en: But what if we decide we'd like to operate on more than one LED at a time? We *could*
    add more values to the existing `LED_CMDS` enum, such as `RED_ON_BLUE_ON_GREEN_OFF`,
    but that would be a lot of very error-prone typing, especially if we had more
    than 3 LEDs (8 LEDs results in 256 enum values to cover all combinations of each
    LED being on/off). Instead, let's look at how we can use a struct to describe
    the LED command and pass that through our queue.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们决定我们想要同时操作多个 LED，我们可以向现有的 `LED_CMDS` 枚举中添加更多值，例如 `RED_ON_BLUE_ON_GREEN_OFF`，但这将涉及大量的容易出错的输入，特别是如果我们有超过
    3 个 LED（8 个 LED 需要覆盖每个 LED 开/关的所有组合，枚举值达到 256）。相反，让我们看看我们如何使用 struct 来描述 LED 命令并通过我们的队列传递它。
- en: Passing a composite data type by value
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过值传递复合数据类型
- en: FreeRTOS queues (and most other FreeRTOS API functions) take in `void*` as arguments
    for the individual data types that are being operated on. This is done to provide
    flexibility for the application writer as efficiently as possible. Since `void*`
    is simply a pointer to *anything* and the sizes of the elements in the queue is
    defined when it is created, queues can be used to pass anything between tasks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS 队列（以及大多数其他 FreeRTOS API 函数）接受 `void*` 作为操作的数据类型的参数。这样做是为了尽可能高效地为应用程序编写者提供灵活性。由于
    `void*` 只是一个指向 *任何事物* 的指针，并且队列中元素的大小在创建时就已经定义，因此队列可以用来在任务之间传递任何东西。
- en: The use of `void*` for interacting with queues acts as a double-edged sword.
    It provides the ultimate amount of flexibility, but also provides the very real
    possibility for you to pass the *wrong* data type into the queue, potentially
    without a warning from the compiler. You must keep track of the data type that
    is being stored in each queue!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `void*` 与队列交互就像一把双刃剑。它提供了最大的灵活性，但也提供了你将错误的数据类型传递到队列中的真实可能性，而且编译器可能不会发出警告。你必须跟踪每个队列中存储的数据类型！
- en: 'We''ll use this flexibility to pass in a composite data type created from a
    struct of instances of `uint8_t` (each of which is only one bit wide) to describe
    the state of all three LEDs:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用这种灵活性，传递一个由 `uint8_t` 实例的 struct 组成的复合数据类型，每个实例只有一位宽，以描述所有三个 LED 的状态：
- en: 'Excerpt from `mainQueueCompositePassByValue.c`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `mainQueueCompositePassByValue.c` 的摘录：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll also create a queue that is able to hold eight copies of the entire
    `LedStates_t` struct:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个能够容纳整个 `LedStates_t` 结构体八份副本的队列：
- en: '`ledCmdQueue = **xQueueCreate(8, sizeof(LedStates_t)**);`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ledCmdQueue = xQueueCreate(8, sizeof(LedStates_t));`'
- en: 'Like the last example, `recvTask` waits until an item is available from the `ledCmdQueue`
    queue and then operates on it (turning LEDs on/off as required):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例类似，`recvTask` 等待从 `ledCmdQueue` 队列中可用一个项目，然后对其进行操作（根据需要打开/关闭LED）：
- en: '`mainQueueCompositePassByValue.c recvTask`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainQueueCompositePassByValue.c recvTask`：'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here are the responsibilities of the primary loop of `recvTask`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `recvTask` 的主要循环的职责：
- en: Each time an element is available from the queue, each field of the struct is
    evaluated and the appropriate action is taken.  All three LEDs are updated with
    a single command, sent to the queue.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次从队列中可用一个元素时，都会评估结构体的每个字段，并采取适当的操作。所有三个LED都通过发送到队列的单个命令进行更新。
- en: The newly created `msDelayTime` field is also evaluated (it is used to add a
    delay before the task attempts to receive from the queue again). This is what
    slows down the system enough so that the LED states are visible.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新创建的 `msDelayTime` 字段也被评估（它用于在任务再次尝试从队列接收之前添加延迟）。这就是使系统足够慢，以便LED状态可见的原因。
- en: '`mainQueueCompositePassByValue.c sendingTask`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainQueueCompositePassByValue.c sendingTask`：'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The loop of `sendingTask` sends a few commands to `ledCmdQueue` – here are
    the details:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendingTask` 的循环向 `ledCmdQueue` 发送几个命令——以下是详细信息：'
- en: '`sendingTask` looks a bit different from before. Now, since a struct is being
    passed, we can access each field, setting multiple fields before sending `nextStates`
    to the queue.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendingTask` 看起来与之前略有不同。现在，由于传递了一个结构体，我们可以访问每个字段，在将 `nextStates` 发送到队列之前设置多个字段。'
- en: Each time `xQueueSend` is called, the contents of `nextStates` is copied into
    the queue before moving on. As soon as `xQueueSend()` returns successfully, the
    value of `nextStates` is copied into the queue storage; `nextStates` does not
    need to be preserved.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调用 `xQueueSend` 时，都会将 `nextStates` 的内容复制到队列中，然后再继续。一旦 `xQueueSend()` 成功返回，`nextStates`
    的值就会被复制到队列存储中；`nextStates` 不需要保留。
- en: 'To drive home the point that the value of `nextStates` is copied into the queue,
    this example changes the priorities of tasks so that the queue is filled completely
    by `sendingTask` before being emptied by `recvTask`. This is accomplished by giving `sendingTask`
    a higher priority than `revcTask`. Here''s what our task definitions look like
    (`asserts` are present in the code but are not shown here to reduce clutter):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `nextStates` 的值被复制到队列中的这一点，此示例更改了任务的优先级，以便在 `recvTask` 清空队列之前，由 `sendingTask`
    将队列填满。这是通过给 `sendingTask` 比 `revcTask` 更高的优先级来实现的。以下是我们的任务定义的外观（断言在代码中存在但在此处未显示以减少混乱）：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`sendingTask` is configured to have the highest priority in the system. `configMAX_PRIORITIES`
    is defined in `Chapter9/Inc/FreeRTOSConfig.h` and is the number of priorities
    available. FreeRTOS task priorities are set up so that `0` is the lowest priority
    task in the system and the highest priority available in the system is `configMAX_PRIORITIES
    - 1`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendingTask` 被配置为系统中的最高优先级。`configMAX_PRIORITIES` 在 `Chapter9/Inc/FreeRTOSConfig.h`
    中定义，并且是可用的优先级数量。FreeRTOS 任务优先级被设置为 `0` 是系统中的最低优先级任务，而系统中的最高优先级是 `configMAX_PRIORITIES
    - 1`。'
- en: This prioritization setup allows `sendingTask` to repeatedly send data to the
    queue until it is full (because `sendingTask `has a higher priority). After the
    queue has filled, `sendingTask` will block and allow `recvTask` to remove an item
    from the queue.  Let's take a look at how this plays out in more detail.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优先级设置允许 `sendingTask` 重复向队列发送数据，直到它填满（因为 `sendingTask` 具有更高的优先级）。队列填满后，`sendingTask`
    将阻塞，并允许 `recvTask` 从队列中移除一个项目。让我们更详细地看看这是如何实现的。
- en: Understanding how queues affect execution
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解队列如何影响执行
- en: Task priorities work in conjunction with primitives such as queues to define
    the system's behavior. This is especially critical in a preemptive RTOS application
    because context is always given based on priority. Programmed queue interactions
    need to take into account task priorities in order to achieve the desired operation.
    Priorities need to be carefully chosen to work in conjunction with the design
    of individual tasks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 任务优先级与队列等原语协同工作，以定义系统的行为。这在抢占式实时操作系统应用中尤为重要，因为上下文总是基于优先级给出的。程序化的队列交互需要考虑任务优先级以实现所需的操作。优先级需要仔细选择，以便与单个任务的设计协同工作。
- en: In this example, an infinite wait time was chosen for `sendingTask` so that
    it could fill the queue.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为`sendingTask`选择了无限等待时间，以便它可以填满队列。
- en: 'Here''s a diagram depicting the preceding setup in action:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个描述前面设置动作的图示：
- en: '![](img/c0b0fd48-7b98-4823-a855-827f6d308d16.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0b0fd48-7b98-4823-a855-827f6d308d16.png)'
- en: 'Take a look at this example using Ozone to step through the code and understand
    its behavior. We can go through a few iterations of the `sendingTask while` loop
    step by step, watching the `ledCmdQueue` data structure and breakpoint setup in
    each of these tasks:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个使用Ozone逐步执行代码并理解其行为的示例。我们可以逐步通过`sendingTask while`循环的几个迭代，观察每个任务中的`ledCmdQueue`数据结构和断点设置：
- en: Make sure you have built the `queueCompositePassByValue` configuration.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经构建了`queueCompositePassByValue`配置。
- en: Open Ozone by double-clicking Chapter_9\Chapter_9.jdebug.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Chapter_9\Chapter_9.jdebug`打开Ozone。
- en: Go to File | Open | Chapter_9\queueCompositePassByValue\Chapter9_QueuePassCompositeByValue.elf.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往文件 | 打开 | Chapter_9\queueCompositePassByValue\Chapter9_QueuePassCompositeByValue.elf。
- en: Open the global variables view and observe `ledCmdQueue` as you step through
    the code.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开全局变量视图，在逐步执行代码时观察`ledCmdQueue`。
- en: Put a breakpoint in `recvTask` to stop the debugger whenever an item is removed
    from the queue.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recvTask`中设置断点，以便在从队列中移除项目时停止调试器。
- en: 'When `recvTask` runs the first time, you''ll notice that `uxMessagesWaiting`
    will have a value of `8` (the queue is filled):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`recvTask`第一次运行时，你会注意到`uxMessagesWaiting`的值将是`8`（队列已满）：
- en: '![](img/ce2e3d08-4535-4a07-a44a-fa292f887793.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce2e3d08-4535-4a07-a44a-fa292f887793.png)'
- en: Getting comfortable with whatever debugger you are using *before* you run into
    serious problems is always a good idea. A second-nature level of familiarity frees
    your mind to focus on the problem at hand rather than the tools being used.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在遇到严重问题之前熟悉你正在使用的任何调试器总是一个好主意。一种第二本能的熟悉程度可以让你将注意力集中在手头的问题上，而不是使用的工具。
- en: Important notes on the examples
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于示例的重要注意事项
- en: 'The previous example''s main purpose was to illustrate the following points:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例的主要目的是说明以下要点：
- en: Queues can be used to hold arbitrary data.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列可以用来存储任意数据。
- en: Queues interact with task priorities in interesting ways.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列以有趣的方式与任务优先级交互。
- en: 'There were several trade-offs made to simplify behavior and make the example
    easier to understand:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化行为并使示例更容易理解，我们做出了一些权衡：
- en: '**The task receiving from the queue was a low priority**: In practice, you''ll
    need to balance the priority of tasks that are receiving from queues (to keep
    latency low and prevent queues from filling up) against the priority of other
    events in the system.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从队列接收任务的优先级较低**：在实践中，你需要平衡从队列接收任务的优先级（以保持低延迟并防止队列填满）与系统中其他事件的优先级。'
- en: '**A long queue was used for commands**: Deep queues combined with a low-priority
    task receiving from them will create latencyin a system. Because of the combination
    of low task priority and long queue length, this example contains several seconds
    worth of queued commands. Elements were added onto the queue that wouldn''t be
    executed until several seconds after they were added because of the depth/priority
    combination.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用了长队列来执行命令**：深度队列与从其接收的低优先级任务结合将创建系统中的延迟。由于低任务优先级和长队列长度的组合，这个例子包含了几个秒的队列命令。由于深度/优先级的组合，添加到队列中的元素将在添加后几秒钟才执行。'
- en: '**An infinite timeout was used when sending items to the queue**: This will
    cause `sendTask()` to wait indefinitely for a slot to become available. In this
    case, this was the behavior we wanted (for simplicity), but in an actual time-critical
    system, you''ll need to keep in mind exactly how long a task is able to wait before
    an error occurs.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向队列发送项目时使用了无限超时**：这将导致`sendTask()`无限期地等待一个槽位变得可用。在这种情况下，这是我们想要的（为了简单起见），但在实际的时间关键系统中，你需要记住任务在发生错误之前能够等待多长时间。'
- en: We're not quite done exploring the flexibility of queues. Next, we'll take a
    look at a special case of passing data by reference to a queue.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完全探索队列的灵活性。接下来，我们将查看通过引用向队列传递数据的特殊情况。
- en: Passing data through queues by reference
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过引用通过队列传递数据
- en: Since the data type of a queue is arbitrary, we also have the ability to pass
    data by reference instead of by value. This works in a similar way to passing
    arguments to a function by reference.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于队列的数据类型是任意的，我们也有能力通过引用而不是通过值传递数据。这与通过引用传递函数参数的方式类似。
- en: When to pass by reference
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时通过引用传递
- en: 'Since a queue will make a copy of whatever it is holding, if the data structure
    being queued is large, it will be inefficient to pass it around by value:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于队列会复制其持有的任何内容，如果被队列化的数据结构很大，按值传递它将是不高效的：
- en: Sending and receiving from queues forces a copy of the queue element each time.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从队列中发送和接收数据会强制复制队列元素。
- en: The resulting queue gets very large for large data items if large structures
    are queued.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果队列中包含大量结构，则结果队列对于大型数据项会变得非常大。
- en: 'So, when there are large items that need to be queued, passing the items by
    reference is a good idea. Here''s an example of a larger structure. After the
    compiler pads out this struct, it ends up being 264 bytes in size:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当需要队列化大型项目时，通过引用传递项目是一个好主意。以下是一个较大结构体的示例。在编译器填充此结构体后，它最终的大小为264字节：
- en: '`mainQueueCompositePassByReference.c`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainQueueCompositePassByReference.c`:'
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Rather than copy 264 bytes every time an item is added or removed from `ledCmdQueue`,
    we can define `ledCmdQueue` to hold a pointer (4 bytes on Cortex-M) to `LedStates_t` :'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次向`ledCmdQueue`添加或从其中移除项目时都复制264字节，我们可以将`ledCmdQueue`定义为保存指向`LedStates_t`的指针（在Cortex-M上为4字节）：
- en: '`ledCmdQueue = xQueueCreate(8, **sizeof(LedStates_t*****)**);`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`ledCmdQueue = xQueueCreate(8, **sizeof(LedStates_t*****)**);`'
- en: 'Let''s look at the difference between passing by value and passing by reference:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看按值传递和通过引用传递之间的区别：
- en: '**Passing by value:**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**按值传递：**'
- en: '`ledCmdQueue` **size:** ~ 2 KB  (264 bytes * 8 elements).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ledCmdQueue` **大小：** ~ 2 KB（264字节 * 8个元素）。'
- en: 264 bytes copied each time `xQueueSend()` or `xQueueReceive()` is called.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调用`xQueueSend()`或`xQueueReceive()`时，会复制264字节。
- en: The original copy of `LedStates_t` that is added to queue can be discarded immediately
    (a full copy is present inside the queue).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加到队列中的`LedStates_t`原始副本可以立即丢弃（队列内已存在完整的副本）。
- en: '**Passing by reference:**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过引用传递：**'
- en: '`ledCmdQueue` **size:** 32 bytes (4 bytes * 8 elements).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ledCmdQueue` **大小：** 32 字节（4 字节 * 8 个元素）。'
- en: 4 bytes copied (the size of a pointer) each time `xQueueSend()` or `xQueueReceive()` is
    called.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调用`xQueueSend()`或`xQueueReceive()`时，会复制4字节（指针的大小）。
- en: The original copy of `LedStates_t` that is added to the queue *must be kept*
    until it is no longer needed (this is the only copy in the system; only a pointer
    to the original structure was queued).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加到队列中的`LedStates_t`原始副本*必须保留*，直到不再需要（这是系统中的唯一副本；只有原始结构的指针被队列化）。
- en: When passing by reference, we're making a trade-off between increased efficiency,
    (potentially) reduced RAM consumption, and more complex code. The extra complexity
    comes from ensuring that the original value remains valid the entire time it is
    needed. This approach is very similar to passing references to structures as parameters
    to functions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过引用传递时，我们是在提高效率、（可能）减少RAM消耗和更复杂的代码之间做出权衡。额外的复杂性来自于确保原始值在整个需要的时间内保持有效。这种方法与将结构体作为参数传递给函数的引用传递非常相似。
- en: 'A few instances of `LedStates_t` can be created as well:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一些`LedStates_t`的实例：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using Ozone, we can easily look at what we''ve created:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ozone，我们可以轻松查看我们创建的内容：
- en: '`uxItemSize` of `ledCmdQeue` is 4 bytes, exactly as we would expect, because
    the queue is holding pointers to `LedStates_t`.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ledCmdQeue`的`uxItemSize`是4字节，正如我们预期的那样，因为队列正在保存指向`LedStates_t`的指针。'
- en: 'The actual sizes of `ledState1` and `ledState2` are both 264 bytes, as expected:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ledState1`和`ledState2`的实际大小都是264字节，正如预期的那样：'
- en: '![](img/cdf8b1af-61d8-460b-8a37-a1b9fe848914.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdf8b1af-61d8-460b-8a37-a1b9fe848914.png)'
- en: 'To send an item to the queue, go through the following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要向队列发送项目，请按照以下步骤操作：
- en: 'Create a pointer to the variable and pass in the address to the pointer:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建变量的指针并将其地址传递进去：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To receive items from the works, simply define a pointer of the correct data
    type and pass the address to the pointer:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从工作队列接收项目，只需定义正确数据类型的指针并传递指针的地址：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When operating on an item taken out of the queue, remember that you've got a
    pointer that needs to be dereferenced (that is, `nextCmd->redLEDState`).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作从队列中取出的项目时，请记住你有一个需要解引用的指针（即`nextCmd->redLEDState`）。
- en: Now for the catch(es)...
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来说说**注意点**...
- en: Important notes
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: 'Passing by reference can be more efficient than passing by value for moving
    large data structures around, but several things need  to be kept in mind:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递数据结构在移动大数据结构时可能比按值传递更高效，但需要注意以下几点：
- en: '**Keep the datatypes straight**:Because the argument to a queue is of the `void*` data
    type, the compiler won''t be able to warn you that you''re supplying an address
    to a struct instead of to a pointer.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep the queued data around**: Unlike passing data by value, when a queue
    holds pointers to the data, the underlying data passed to the queue needs to stay
    until it is used. This has the following implications:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data must not live on the stack—no local function variables! Although this
    *can* be made to work, it is generally a bad idea to define variables on a stack
    in the *middle* of a call chain and then push a pointer onto a queue. By the time
    the receiving task pulls the pointer off of the queue, the stack of the sending
    task is likely to have changed. Even if you do get this to work under some circumstances
    (such as when the receiving task has a higher priority than the sending task),
    you'll have created a very brittle system that is likely to break in a very subtle
    way in the future.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A stable storage location for the underlying variable is a must. Global and
    statically allocated variables are both acceptable.  If you''d like to limit access
    to a variable, use static allocation inside a function.  This will keep the variable
    in memory, just as if it was a global, but limit access to it:'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should dynamically allocate space for the variable (if dynamic allocation
    is acceptable in your application).  See [Chapter 15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)*, FreeRTOS
    Memory Management*, for details on memory management, including dynamic allocation.
  id: totrans-150
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Who owns the data? **When a queue has a copy of a struct, the queue owns
    that copy. As soon as the item is removed from the queue, it disappears. Contrast
    this with a queue holding a *pointer* to data. When the pointer is removed from
    the queue, the data is still present in its previous location. Data ownership
    needs to be made very clear. Will the task receiving the pointer from the queue
    become the new owner (and be responsible for freeing dynamically allocated memory
    if it was used)? Will the original task that sent the pointer still maintain ownership?
    These are all important questions to consider up front.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've discussed passing around huge amounts of data (avoid it whenever
    possible!), let's talk about an efficient way of passing around small amounts
    of data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Direct task notifications
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queues are an excellent workhorse of an RTOS because of their flexibility. Sometimes,
    all of this flexibility isn't needed and we'd prefer a more lightweight alternative.
    Direct task notifications are similar to the other communication mechanisms discussed,
    except that they do not require the communication object to first be instantiated
    in RAM. They are also faster than semaphores or queues (between 35% and 45% faster).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: They do have some limitations, the largest two being that only one task can
    be notified at a time and notifications can be sent by ISRs but not received.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Direct task notifications have two main components: the notification itself
    (which behaves very much like how a semaphore or queue behaves when unblocking
    a task) and a 32-bit notification value. The notification value is optional and
    has a few different uses. A notifier has the option of overwriting the entire
    value or using the notification value as if it were a bitfield and setting a single
    bit. Setting individual bits can come in handy for signaling different behaviors
    that you''d like the task to be made aware of without resorting to a more complicated
    command-driven implementation based on queues.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 直接任务通知有两个主要组成部分：通知本身（它在解除任务阻塞时的行为非常类似于信号量或队列）和一个32位通知值。通知值是可选的，有几个不同的用途。通知器可以选择覆盖整个值或使用通知值作为位字段并设置单个位。设置单个位对于在不依赖基于队列的更复杂命令驱动实现的情况下，让任务意识到不同的行为非常有用。
- en: Take our LEDs, for example. If we wanted to create a simple LED handler that
    quickly responded to a change request, a multi-element queue wouldn't be necessary;
    we can make use of the built-in 32-bit wide notification value instead.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的LED为例。如果我们想创建一个简单的LED处理程序，它能快速响应更改请求，那么就不需要多元素队列；我们可以利用内置的32位宽通知值。
- en: If you're thinking *task notifications sound a bit like semaphores*, you'd be
    right! Task notifications can also be used as a faster alternative to semaphores.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为*任务通知听起来有点像信号量*，你就对了！任务通知也可以用作比信号量更快的替代品。
- en: Let's see how task notifications can be utilized to issue commands and pass
    information to a task by working through an example.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看看任务通知如何被用来发布命令并将信息传递给一个任务。
- en: Passing simple data using task notifications
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务通知传递简单数据
- en: In this example, our goal is to have `recvTask` set LED states, which it has
    been doing this entire chapter. This time, instead of allowing multiple copies
    of future LED states to pile up and execute some time in the future, `recvTask` will
    execute just one state change at a time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的目标是让`recvTask`设置LED状态，它在这一章的整个过程中一直在做这件事。这次，`recvTask`将一次只执行一个状态更改，而不是允许未来LED状态的多个副本堆积起来并在将来某个时间执行。
- en: Since the notification value is built into the task, no additional queue needs
    to be created—we just need to make sure that we store the task handle of `recvTask`,
    which will be used when we send it notifications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通知值是内置在任务中的，因此不需要创建额外的队列——我们只需要确保我们存储了`recvTask`的任务句柄，这将在我们发送通知时使用。
- en: Let's look at how we do this by looking at some `mainTaskNotifications.c` excerpts***:***
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一些`mainTaskNotifications.c`的摘录来看看我们是如何做到这一点的***：***
- en: 'Outside of `main`, we''ll define some bitmasks and a task handle:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数外部，我们将定义一些位掩码和一个任务句柄：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside `main`, we''ll create the `recvTask` and pass it the handle to populate:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数内部，我们将创建`recvTask`并传递一个句柄来填充：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The task receiving the notification is set up to wait on the next incoming
    notification and then evaluate each LED''s mask, turning LEDs on/off accordingly:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收通知的任务被设置为等待下一个传入的通知，然后评估每个LED的掩码，相应地打开/关闭LED：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The sending task is set up to send a notification, overwriting any existing
    notifications that may be present. This results in `xTaskNotify` always returning
    `pdTRUE`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送任务被设置为发送一个通知，覆盖可能存在的任何现有通知。这导致`xTaskNotify`始终返回`pdTRUE`：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example can be built using the `directTaskNotification` configuration and
    uploaded to the Nucleo. It will sequentially blink each LED as the notifications
    are sent to `recvTask`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以使用`directTaskNotification`配置构建并上传到Nucleo。当通知被发送到`recvTask`时，它将依次闪烁每个LED。
- en: Other options for task notifications
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务通知的其他选项
- en: 'From the `eNotifyAction` enumeration in `task.h`, we can see that the other
    options for notifying the task include the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从`task.h`中的`eNotifyAction`枚举中，我们可以看到通知任务的其他选项包括以下内容：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using these options creates some additional flexibility, such as using notifications
    as binary and counting semaphores. Note that some of these options change how
    `xTaskNotify` returns, so it will be necessary to check the return value in some
    cases.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项可以创建一些额外的灵活性，例如使用通知作为二进制和计数信号量。请注意，这些选项中的一些会改变`xTaskNotify`的返回方式，因此在某些情况下需要检查返回值。
- en: Comparing direct task notifications  to queues
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较直接任务通知与队列
- en: 'Compared to queues, task notifications have the following features:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与队列相比，任务通知具有以下特性：
- en: They always have storage capacity of exactly one 32-bit integer.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们总是有正好一个32位整数的存储容量。
- en: They do not offer a means of waiting to push a notification to a busy task;
    it will either overwrite an existing notification or return immediately without
    writing.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不提供等待将通知推送到忙碌任务的方法；它将覆盖现有的通知或立即返回而不写入。
- en: They can only be used with only one receiver (since the notification value is
    stored inside the receiving task).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只能与一个接收器一起使用（因为通知值存储在接收任务中）。
- en: They are faster.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们更快。
- en: Let's take a look at a real-world example using SystemView to compare the direct
    notification code we just wrote against the first queue implementation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用SystemView的实际例子，比较我们刚刚编写的直接通知代码和第一个队列实现。
- en: 'The queue implementation from `mainQueueSimplePassByValue.c` looks like this
    when performing `xQueueSend`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`xQueueSend`时，`mainQueueSimplePassByValue.c`中的队列实现看起来是这样的：
- en: '![](img/48be5eee-d3e5-4efe-a3a7-55bc0053821e.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48be5eee-d3e5-4efe-a3a7-55bc0053821e.png)'
- en: 'The direct task notification looks like this when calling `xTaskNotify`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`xTaskNotify`时，直接任务通知看起来是这样的：
- en: '![](img/0ceaaee1-65e4-454e-9b56-25f5b965ec78.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ceaaee1-65e4-454e-9b56-25f5b965ec78.png)'
- en: As we can see from the preceding screenshots, the direct task notification is
    in the range of 25–35% faster than using a queue in this particular use case.
    There's also no RAM overhead for storing a queue when using direct task notifications.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图我们可以看出，在特定用例中，直接任务通知比使用队列快25-35%。使用直接任务通知时，存储队列也没有RAM开销。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You've now learned the basics of how to use queues in a variety of scenarios,
    such as passing simple and composite elements by value and reference. You're aware
    of the pros and cons of using queues to store references to objects and when it
    is appropriate to use this method. We also covered some of the detailed interactions
    between queues, tasks, and task priorities. We finished with a simple real-world
    example of how to use task notifications to efficiently drive a small state machine.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何在各种场景下使用队列，例如通过值和引用传递简单和复合元素。你了解使用队列存储对象引用的优缺点，以及何时适合使用这种方法。我们还涵盖了队列、任务和任务优先级之间的一些详细交互。最后，我们通过一个简单的现实世界例子展示了如何使用任务通知来高效地驱动一个小型状态机。
- en: As you become more accustomed to using RTOSes to solve a wide variety of problems,
    you'll find new and creative ways of using queues and task notifications. Tasks,
    queues, semaphores, and mutexes are truly the building blocks of RTOS-based applications
    and will help you go a long way.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你越来越习惯于使用RTOS解决各种问题，你会发现使用队列和任务通知的新颖和创造性的方法。任务、队列、信号量和互斥锁确实是RTOS应用程序的构建块，并将帮助你走得很远。
- en: We're not completely done with any of these elements yet, though—there's still
    a lot of more advanced material to cover related to using all of these primitives
    in the context of ISRs, which is up next!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还没有完全完成这些元素——关于在ISR上下文中使用所有这些原语还有很多更高级的材料要介绍，这正是接下来的内容！
- en: Questions
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之前，这里有一份问题列表，供你测试对本章材料的理解。你将在附录的*评估*部分找到答案：
- en: What data types can be passed to queues?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以将哪些数据类型传递给队列？
- en: What happens to the task attempting to operate on the queue while it is waiting?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当任务在等待时尝试操作队列会发生什么？
- en: Name one consideration that needs to be made when passing by reference to a
    queue?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将引用传递给队列时，需要考虑哪些因素？
- en: 'Task notifications can completely replace queues:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务通知可以完全替代队列：
- en: 'True'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: 'Task notifications can send data of any type:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务通知可以发送任何类型的数据：
- en: 'True'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: What are the advantages of task notifications over queues?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与队列相比，任务通知的优点是什么？
- en: Further reading
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Explanation of all constants of **`FreeRTOSConfig.h`**:** [https://www.freertos.org/a00110.html](https://www.freertos.org/a00110.html)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`FreeRTOSConfig.h`中所有常量的解释**：[https://www.freertos.org/a00110.html](https://www.freertos.org/a00110.html)'
- en: '**FreeRTOS direct task notifications:** [https://www.freertos.org/RTOS-task-notifications.html](https://www.freertos.org/RTOS-task-notifications.html)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FreeRTOS直接任务通知**：[https://www.freertos.org/RTOS-task-notifications.html](https://www.freertos.org/RTOS-task-notifications.html)'
