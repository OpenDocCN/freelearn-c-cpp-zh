- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robustness and Performance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ is often the first choice when it comes to selecting an object-oriented
    programming language with performance and flexibility as key goals. Modern C++
    provides language and library features, such as rvalue references, move semantics,
    and smart pointers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: When combined with good practices for exception handling, constant correctness,
    type-safe conversions, resource allocation, and releasing, C++ enables developers
    to write better, more robust, and performant code. This chapter’s recipes address
    all of these essential topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Using exceptions for error handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `noexcept` for functions that do not throw exceptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring constant correctness for a program
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating compile-time constant expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating immediate functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing code in constant-evaluated contexts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual function calls in constant expressions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing correct type casts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing move semantics
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `unique_ptr` to uniquely own a memory resource
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `shared_ptr` to share a memory resource
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistent comparison with the operator `<=>`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing signed and unsigned integers safely
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start this chapter with a couple of recipes that deal with exceptions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Using exceptions for error handling
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions are responses to exceptional circumstances that can appear when a
    program is running. They enable the transfer of the control flow to another part
    of the program. Exceptions are a mechanism for simpler and more robust error handling,
    as opposed to returning error codes, which could greatly complicate and clutter
    the code. In this recipe, we will look at some key aspects related to throwing
    and handling exceptions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires you to have basic knowledge of the mechanisms of throwing
    exceptions (using the `throw` statement) and catching exceptions (using `try...catch`
    blocks). This recipe is focused on good practices around exceptions and not on
    the details of the exception mechanism in the C++ language.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following practices to deal with exceptions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Throw exceptions by value:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Catch exceptions by reference, or in most cases, by constant reference:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Order `catch` statements from the most derived class to the base class of the
    hierarchy when catching multiple exceptions from a class hierarchy:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use `catch(...)` to catch all exceptions, regardless of their type:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Use `throw;` to rethrow the current exception. This can be used to create a
    single exception-handling function for multiple exceptions.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throw the exception object (for example, `throw e;`) when you want to hide
    the original location of the exception:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most functions have to indicate the success or failure of their execution.
    This can be achieved in different ways. Here are several possibilities:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Return an error code (with a special value for success) to indicate the specific
    reason for failure:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A variation of this is to return a Boolean value to only indicate success or
    failure:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another alternative is to return invalid objects, null pointers, or empty `std::optional<T>`
    objects:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In any case, the return value from the functions should be checked. This can
    lead to complex, cluttered, and hard-to-read and maintain real-world code. Moreover,
    the process of checking the return value of a function is always executed, regardless
    of whether the function was successful or failed. On the other hand, exceptions
    are thrown and handled only when a function fails, which should happen more rarely
    than successful executions. This can actually lead to faster code than code that
    returns and tests error codes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions and error codes are not mutually exclusive. Exceptions should be
    used only for transferring the control flow in exceptional situations, not for
    controlling the data flow in a program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Class constructors are special functions that do not return any value. They
    are supposed to construct an object, but in the case of failure, they will not
    be able to indicate this with a return value. Exceptions should be a mechanism
    that constructors use to indicate failure. Together with the **Resource Acquisition
    Is Initialization** (**RAII**) idiom, this ensures the safe acquisition and release
    of resources in all situations. On the other hand, exceptions are not allowed
    to leave a destructor. When this happens, the program abnormally terminates with
    a call to `std::terminate()`. This is the case for destructors called during stack
    unwinding, due to the occurrence of another exception. When an exception occurs,
    the stack is unwound from the point where the exception was thrown to the block
    where the exception is handled. This process involves the destruction of all local
    objects in all those stack frames.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: If the destructor of an object that is being destroyed during this process throws
    an exception, another stack unwinding process should begin, which conflicts with
    the one already under way. Because of this, the program terminates abnormally.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule of thumb for dealing with exceptions in constructors and destructors
    is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Use exceptions to indicate the errors that occur in constructors.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not throw or let exceptions leave destructors.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to throw any type of exception. However, in most cases, you
    should throw temporaries and catch exceptions by constant reference. The reason
    for catching (constant) references is to avoid slicing the exception types. Let’s
    consider the following snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are throwing a `simple_error` object but catch a `std::exception` object
    by value. This is the base type of `simple_error`. The *slicing* process occurs,
    the derived type information is lost, and only the `std::exception` part of the
    object is kept. Therefore, the printed message is *Unknown exception* and not
    *simple exception* as one would expect. Using a reference avoids the object slicing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some guidelines for exception throwing:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Prefer throwing either standard exceptions or your own exceptions derived from
    `std::exception` or another standard exception. The reason for this is that the
    standard library provides exception classes that are intended to be the first
    choice for representing exceptions. You should use the ones that are available
    already and when these are not good enough, build your own based on the standard
    ones. The main benefits of this are consistency and helping users catch exceptions
    via the base `std::exception` class.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid throwing exceptions of built-in types, such as integers. The reason for
    this is that numbers carry little information to the user, who must know what
    it represents, while an object can provide contextual information. For instance,
    the statement `throw 13;` tells nothing to the user, but `throw access_denied_exception{};`
    carries much more implicit information from the class name alone, and with the
    help of data members, it carries anything useful or necessary about the exceptional
    situation.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using a library or framework that provides its own exception hierarchy,
    prefer throwing exceptions from this hierarchy or your own exceptions derived
    from it, at least in the parts of the code that are tightly related to it. The
    main reason for this is to keep the code that utilizes the library APIs consistent.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the preceding section, when you need to create your own exception
    types, derive them from one of the standard exceptions that are available, unless
    you are using a library or framework with its own exception hierarchy. The C++
    standard defines several categories of exceptions that need to be considered for
    this purpose:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The `std::logic_error` represents an exception that indicates an error in the
    program logic, such as an invalid argument and an index beyond the bounds of a
    range. There are various standard-derived classes, such as `std::invalid_argument`,
    `std::out_of_range`, and `std::length_error`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `std::runtime_error` represents an exception that indicates an error beyond
    the scope of the program or that cannot be predicted due to various factors, including
    external ones, such as overflows and underflows or operating system errors. The
    C++ standard also provides several derived classes from `std::runtime_error`,
    including `std::overflow_error`, `std::underflow_error`, `std::system_error`,
    and `std::format_error` in C++20.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions prefixed with `bad_`, such as `std::bad_alloc`, `std::bad_cast`,
    and `std::bad_function_call`, represent various errors in a program, such as failure
    to allocate memory and failure to dynamically cast or make a function call.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base class for all these exceptions is `std::exception`. It has a non-throwing
    virtual method called `what()` that returns a pointer to an array of characters
    representing the description of the error.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'When you need to derive custom exceptions from a standard exception, use the
    appropriate category, such as logical or runtime error. If none of these categories
    is suitable, then you can derive directly from `std::exception`. The following
    is a list of possible solutions you can use to derive from a standard exception:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to derive from `std::exception`, then override the virtual method
    `what()` to provide a description of the error:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you derive from `std::logic_error` or `std::runtime_error` and you only
    need to provide a static description that does not depend on runtime data, then
    pass the description text to the base class constructor:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you derive from `std::logic_error` or `std::runtime_error` but the description
    message depends on runtime data, provide a constructor with parameters and use
    them to build the description message. You can either pass the description message
    to the base class constructor or return it from the overridden `what()` method:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For a complete list of the standard exception classes, you can visit the [https://en.cppreference.com/w/cpp/error/exception](https://en.cppreference.com/w/cpp/error/exception)
    page.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 8*, *Handling exceptions from thread functions*, to understand how
    to handle exceptions thrown in a worker thread from the main thread or the thread
    where it was joined'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using noexcept for functions that do not throw exceptions*, to see how to
    inform the compiler that a function should not throw exceptions'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using noexcept for functions that do not throw exceptions
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception specification is a language feature that can enable performance improvements,
    but on the other hand, when done incorrectly, it can abnormally terminate the
    program. The exception specification from C++03, which allowed you to indicate
    what types of exceptions a function could throw, was deprecated in C++11 and removed
    in C++17\. It was replaced with the C++11 `noexcept` specifier. Moreover, the
    use of the `throw()` specifier to indicate that a function throws, without indicating
    what exception types have also been deprecated in C++17 and completely removed
    in C++20\. The `noexcept` specifier only allows you to indicate that a function
    does not throw exceptions (as opposed to the old `throw` specifier, which could
    indicate the list of types a function could throw). This recipe provides information
    about the modern exception specifications in C++, as well as guidelines on when
    to use them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following constructs to specify or query exception specifications:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `noexcept` in a function declaration to indicate that the function is not
    throwing any exception:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use `noexcept(expr)` in a function declaration, such as template metaprogramming,
    to indicate that the function may or may not throw an exception based on a condition
    that evaluates to `bool`:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the `noexcept` operator at compile time to check whether an expression
    is declared to not throw any exception:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of C++17, exception specification is part of the function type, but not part
    of the function signature; it may appear as part of any function declarator. Because
    exception specification is not part of the function signature, two function signatures
    cannot differ only in the exception specification.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C++17, exception specification was not part of the function type and
    could only appear as part of lambda declarators or top-level function declarators;
    they could not appear even in `typedef` or type alias declarations. Further discussions
    on exception specification refer solely to the C++17 standard.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways in which the process of throwing an exception can be
    specified:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: If no exception specification is present, then the function could potentially
    throw exceptions.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noexcept(false)` is equivalent to no exception specification.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noexcept(true)` and `noexcept` indicate that a function does not throw any
    exception.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throw()` was equivalent to `noexcept(true)` but was deprecated in C++17 and
    removed altogether in C++20.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using exception specifications must be done with care because if an exception
    (either thrown directly or from another function that is called) leaves a function
    marked as non-throwing, the program is terminated immediately and abnormally with
    a call to `std::terminate()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Pointers to the functions that do not throw exceptions can be implicitly converted
    to pointers to functions that may throw exceptions, but not vice versa. On the
    other hand, if a virtual function has a non-throwing exception specification,
    this indicates that all the declarations of all the overrides must preserve this
    specification unless an overridden function is declared as deleted.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: At compile time, it is possible to check whether a function is declared to be
    non-throwing or not using the operator `noexcept`. This operator takes an expression
    and returns `true` if the expression is declared as either non-throwing or `false`.
    It does not evaluate the expression it checks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The `noexcept` operator, along with the `noexcept` specifier, is particularly
    useful in template metaprogramming to indicate whether a function may throw exceptions
    for some types. It is also used with `static_assert` declarations to check whether
    an expression breaks the non-throwing guarantee of a function, as seen in the
    examples in the *How to do it...* section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code provides more examples of how the `noexcept` operator works:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is important to note that the `noexcept` specifier does not provide compile-time
    checking for exceptions. It only represents a way for users to inform the compiler
    that a function is not expected to throw exceptions. The compiler can use this
    to enable certain optimizations. An example is the `std::vector`, which moves
    elements if their move constructor is `noexcept` and copies them otherwise.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, a function declared with the `noexcept` specifier that
    exits due to an exception causes the program to terminate abnormally. Therefore,
    the `noexcept` specifier should be used with caution. Its presence can enable
    code optimizations, which help increase performance while preserving the *strong
    exception guarantee*. An example of this is library containers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ language provides several levels of exception guarantees:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The first level, *no exception guarantees*, does not provide any guarantees.
    If an exception occurs, there is nothing to indicate whether the program is left
    in a valid state. Resources could be leaked, memory can be corrupted, and object
    invariants may be broken.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *basic exception guarantee* is the simplest level of guarantee, which ensures
    that after an exception is thrown, objects are left in a consistent and usable
    state, no resource leaks occur, and invariants are preserved.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *strong exception guarantee* specifies that either an operation is completed
    successfully, or that it is completed with an exception that leaves the program
    in the same state it was in before the operation started. This ensures commit-or-rollback
    semantics.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *no-throw exception guarantee* is actually the strongest of them all and
    specifies that an operation is guaranteed to not throw any exception and to complete
    successfully.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many standard containers provide some of their operations with a strong exception
    guarantee. An example is vector’s `push_back()` method. This method could be optimized
    by using the move constructor or move assignment operator instead of the copy
    constructor or copy assignment operator of the vector’s element type. However,
    in order to preserve its strong exception guarantee, this can only be done if
    the move constructor or assignment operator does not throw exceptions. If either
    does, then the copy constructor or the assignment operator must be used instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The `std::move_if_noexcept()` utility function does this if the move constructor
    of its type argument is marked with `noexcept`. The ability to indicate that move
    constructors or move assignment operators do not throw exceptions is probably
    the most important scenario where `noexcept` is used.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following rules for the exception specification:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: If a function could potentially throw an exception, then do not use any exception
    specifier.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark only those functions with `noexcept` that are guaranteed not to throw an
    exception.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark only those functions with `noexcept(expression)` that could potentially
    throw exceptions based on a condition.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These rules are important because, as already noted previously, throwing an
    exception from a `noexcept` function will immediately terminate the program with
    a call to `std::terminate()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using exceptions for error handling*, to explore the best practices for using
    exceptions in the C++ language'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring constant correctness for a program
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although there is no formal definition, constant correctness means objects that
    are not supposed to be modified (are immutable) remain unmodified. As a developer,
    you can enforce this by using the `const` keyword for declaring parameters, variables,
    and member functions. In this recipe, we will explore the benefits of constant
    correctness and how to achieve it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To ensure constant correctness for a program, you should always declare the
    following as constants:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters to functions that are not supposed to be modified within the function:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Class data members that do not change:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Class member functions that do not modify the object state, as seen from the
    outside:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Function locals whose values do not change throughout their lifetime:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'References that should be bound to a temporary (an rvalue) in order to extend
    the lifetime of the temporary to the lifetime of the (constant) reference:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declaring objects and member functions as constant has several important benefits:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: You prevent both accidental and intentional changes of the object, which, in
    some cases, can result in incorrect program behavior.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You enable the compiler to perform better optimizations.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You document the semantics of the code for other users.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant correctness is not a matter of personal style but a core principle
    that should guide C++ development.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the importance of constant correctness has not been, and is still
    not, stressed enough in books, C++ communities, and working environments. But
    the rule of thumb is that everything that is not supposed to change should be
    declared as constant. This should be done all the time and not only at later stages
    of development, when you might need to clean up and refactor the code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'When you declare a parameter or variable as constant, you can either put the
    `const` keyword before the type (`const T c`) or after the type (`T const c`).
    These two are equivalent, but regardless of which of the two styles you use, the
    reading of the declaration must be done from the right-hand side. `const T c`
    is read as *c is a T that is constant* and `T const c` as *c is a constant T*.
    This gets a little bit more complicated with pointers. The following table presents
    various pointer declarations and their meanings:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `T* p` | `p` is a non-constant pointer to a non-constant `T`. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `const T* p` | `p` is a non-constant pointer to a `T` that is constant. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `T const * p` | `p` is a non-constant pointer to a constant `T` (same as
    the prior point). |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `const T * const p` | `p` is a constant pointer to a `T` that is constant.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `T const * const p` | `p` is a constant pointer to a constant `T` (same as
    the prior point). |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `T** p` | `p` is a non-constant pointer to a non-constant pointer to a non-constant
    `T`. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| `const T** p` | `p` is a non-constant pointer to a non-constant pointer to
    a constant `T`. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `T const ** p` | Same as `const T** p`. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| `const T* const * p` | `p` is a non-constant pointer to a constant pointer,
    which is a constant `T`. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `T const * const * p` | Same as `const T* const * p`. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: 'Table 9.1: Example of pointer declarations and their meaning'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Placing the `const` keyword after the type is more natural because it is consistent
    with the direction the syntax is interpreted, from right to left. For this reason,
    all the examples in this book use this style.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to references, the situation is similar: `const T & c` and `T
    const & c` are equivalent, which means *c is a reference to a constant T*. However,
    `T const & const c`, which would mean that *c is a constant reference to a constant
    T*, does not make sense because references—aliases of a variable—are implicitly
    constant in the sense that they cannot be modified to represent an alias to another
    variable.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'A non-constant pointer to a non-constant object, that is, `T*`, can be implicitly
    converted to a non-constant pointer to a constant object, `T const *`. However,
    `T**` cannot be implicitly converted to `T const **` (which is the same with `const
    T**`). This is because this could lead to constant objects being modified through
    a pointer to a non-constant object, as shown in the following example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If an object is constant, only the constant functions of its class can be invoked.
    However, declaring a member function as constant does not mean that the function
    can only be called on constant objects; it could also mean that the function does
    not modify the state of the object, as seen from the outside. This is a key aspect,
    but it is usually misunderstood. A class has an internal state that it can expose
    to its clients through its public interface.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: However, not all the internal states might be exposed, and what is visible from
    the public interface might not have a direct representation in the internal state.
    (If you model order lines and have the item quantity and item selling price fields
    in the internal representation, then you might have a public method that exposes
    the order line amount by multiplying the quantity by the price.) Therefore, the
    state of an object, as visible from its public interface, is a logical state.
    Defining a method as constant is a statement that ensures the function does not
    alter the logical state. However, the compiler prevents you from modifying data
    members using such methods. To avoid this problem, data members that are supposed
    to be modified from constant methods should be declared `mutable`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `computation` is a class with the `compute()` method,
    which performs a long-running computation operation. Because it does not affect
    the logical state of the object, this function is declared constant. However,
    to avoid computing the result of the same input again, the computed values are
    stored in a cache. To be able to modify the cache from the constant function,
    it is declared `mutable`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A similar situation is represented by the following class, which implements
    a thread-safe container. Access to shared internal data is protected with `mutex`.
    The class provides methods such as adding and removing values, and also methods
    such as `contains()`, which indicate whether an item exists in the container.
    Because this member function is not intended to modify the logical state of the
    object, it is declared constant. However, access to the shared internal state
    must be protected with the mutex. In order to lock and unlock the mutex, both
    mutable operations (that modify the state of the object) and the mutex must be
    declared `mutable`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `mutable` specifier allows us to modify the class member on which it was
    used, even if the containing object is declared `const`. This is the case of the
    `mt` member of the `std::mutex` type, which is modified even within the `contains()`
    method, which is declared `const`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a method or an operator is overloaded to have both constant and
    non-constant versions. This is often the case with the subscript operator or methods
    that provide direct access to the internal state. The reason for this is that
    the method is supposed to be available for both constant and non-constant objects.
    The behavior should be different, though: for non-constant objects, the method
    should allow the client to modify the data it provides access to, but for constant
    objects, it should not. Therefore, the non-constant subscript operator returns
    a reference to a non-constant object, and the constant subscript operator returns
    a reference to a constant object:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It should be noted that, if a member function is constant, even if an object
    is constant, the data that’s returned by this member function may not be constant.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: An important use case for the use of `const` is to define references to temporary
    objects, as shown in the last bullet in the *How to do it…* section. A temporary
    is an rvalue and a non-`const` lvalue reference cannot be bound to an rvalue.
    However, it is possible by making the lvalue reference `const`. This has the effect
    of extending the lifetime of the temporary object to the lifetime of the constant
    reference. However, this only works for stack-based references but not for references
    that are members of objects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `const` qualifier of an object can be removed with a `const_cast` conversion,
    but this should only be used when you know that the object was not declared constant.
    You can read more about this in the *Performing correct type casts* recipe.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating compile-time constant expressions*, to learn about the `constexpr`
    specifier and how to define variables and functions that can be evaluated at compile
    time'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating immediate functions*, to learn about the C++20 `consteval` specifier,
    which is used to define functions that are guaranteed to be evaluated at compile
    time'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performing correct type casts*, to learn about the best practices for performing
    correct casts in the C++ language'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating compile-time constant expressions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The possibility to evaluate expressions at compile time improves runtime execution
    because there is less code to run and the compiler can perform additional optimizations.
    Compile-time constants can be not only literals (such as a number or string),
    but also the result of a function’s execution. If all the input values of a function
    (regardless of whether they are arguments, locals, or global variables) are known
    at compile time, the compiler can execute the function and have the result available
    at compile time. This is what generalized the constant expressions that were introduced
    in C++11, which were relaxed in C++14 and even further in C++20\. The keyword
    `constexpr` (short for *constant expression*) can be used to declare compile-time
    constant objects and functions. We have seen this in several examples in the previous
    chapters. Now, it’s time to learn how it actually works.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way generalized constant expressions work has been relaxed in C++14 and
    C++20, but this introduced some breaking changes to C++11\. For instance, in C++11,
    a `constexpr` function was implicitly `const`, but this is no longer the case
    in C++14\. In this recipe, we will discuss generalized constant expressions, as
    defined in C++20.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `constexpr` keyword when you want to:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Define non-member functions that can be evaluated at compile time:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Define constructors that can be executed at compile time to initialize `constexpr`
    objects and member functions to be invoked during this period:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define variables that can have their values evaluated at compile time:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `const` keyword is used for declaring variables as constant at runtime;
    this means that, once initialized, they cannot be changed. However, evaluating
    the constant expression may still imply runtime computation. The `constexpr` keyword
    is used for declaring variables that are constant at compile time or functions
    that can be executed at compile time. `constexpr` functions and objects can replace
    macros and hardcoded literals without any performance penalties.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring a function as `constexpr` does not mean that it is always evaluated
    at compile time. It only enables the use of the function in expressions that are
    evaluated during compile time. This only happens if all the input values of the
    function can be evaluated at compile time. However, the function may also be invoked
    at runtime. The following code shows two invocations of the same function, first
    at compile time, and then at runtime:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are some restrictions in regard to where `constexpr` can be used. These
    restrictions have evolved over time, with changes in C++14 and C++20\. To keep
    the list in a reasonable form, only the requirements that need to be satisfied
    in C++20 are shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable that is `constexpr` must satisfy the following requirements:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its type is a literal type.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is initialized upon declaration.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression used for initializing the variable is a constant expression.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have constant destruction. This means that it must not be of a class
    type or an array of a class type; otherwise, the class type must have a `constexpr`
    destructor.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function that is `constexpr` must satisfy the following requirements:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not a coroutine.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type and the type of all its parameters are all literal types.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is at least one set of arguments for which the invocation of the function
    would produce a constant expression.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The function body must not contain `goto` statements, labels (other than `case`
    and `default` in a switch), and local variables that are either of non-literal
    types or of static or thread storage duration. The restrictions mentioned in this
    bullet point were removed in C++23.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A constructor that is `constexpr` must satisfy the following requirements,
    in addition to the preceding ones required for functions:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no virtual base class for the class.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All the constructors that initialize non-static data members, including base
    classes, must also be `constexpr`.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A destructor that is `constexpr`, available only since C++20, must satisfy
    the following requirements, in addition to the preceding ones required for functions:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no virtual base class for the class.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All the destructors that destroy non-static data members, including base classes,
    must also be `constexpr`.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All the restrictions for `constexpr` constructors and destructors mentioned
    here were removed in C++23.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of requirements in different versions of the standard, you
    should read the online documentation available at [https://en.cppreference.com/w/cpp/language/constexpr](https://en.cppreference.com/w/cpp/language/constexpr).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'A function that is `constexpr` is not implicitly `const` (as of C++14), so
    you need to explicitly use the `const` specifier if the function does not alter
    the logical state of the object. However, a function that is `constexpr` is implicitly
    `inline`. On the other hand, an object that is declared `constexpr` is implicitly
    `const`. The following two declarations are equivalent:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are situations when you may need to use both `constexpr` and `const`
    in a declaration, as they would refer to different parts of the declaration. In
    the following example, `p` is a `constexpr` pointer to a constant integer:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Reference variables can also be `constexpr` if, and only if, they alias an
    object with static storage duration or a function. The following snippet provides
    an example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, `r` is a `constexpr` reference that defines an alias for the
    compile-time constant variable `c`, defined in the previous snippet.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can define static `constexpr` variables, doing so in a `constexpr`
    function was not possible until C++23\. The following snippet shows such an example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The declaration of the `symbols` variable would generate a compiler error,
    prior to C++23\. A possible workaround for this problem was to define the variable
    outside of the `constexpr` function, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This problem has been solved in C++23, which relaxed several `constexpr` restrictions,
    making a workaround unnecessary.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'One more aspect that should be mentioned on constexpr functions is related
    to exceptions. Since C++20, try-catch blocks are allowed in constexpr functions
    (their use was not possible prior to this version). However, throwing exceptions
    from constant expressions is not allowed. Although you can have a throw statement
    in a constexpr function, the behavior is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: When executed at runtime, it would behave as if it wasn’t declared constexpr.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When executed at compile time, if the execution path encounters a throw statement,
    a compiler error is emitted.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is exemplified in the following snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The first two calls to `factorial2()` are executed at runtime. The first executes
    successfully and returns `60`. The second throws a `std::invalid_argument` exception
    because the argument is negative.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third call is evaluated at compile time because variable `c` is declared
    `constexpr` and all the function’s inputs are also known at compile time. The
    invocation is successful and the function evaluates to `60`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth call is also evaluated at compile time, but since the argument is
    negative the path that throws an exception should execute. However, this is not
    allowed in constant expressions, and, therefore, the compiler issues an error.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++20, a new specifier was added to the language. This specifier is called
    `constinit` and is used to ensure that variables with static or thread storage
    duration have static initialization. In C++, the initialization of variables can
    be either static or dynamic. Static initialization can be either zero initialization
    (when the initial value of an object is set to zero) or constant initialization
    (when the initial value is set to a compile-time expression). The following snippet
    shows examples of zero and constant initialization:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A variable that has static storage could have either static or dynamic initialization.
    In the latter case, hard-to-find bugs may appear. Imagine two static objects that
    are initialized in different translation units.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: When the initialization of one of the two objects depends on the other object,
    then the order they are initialized in is important. This is because the object
    that depends on the object must be initialized first. However, the order of the
    initialization of the translation units is not deterministic, so there is no guarantee
    of the order of these objects’ initialization. However, variables with static
    storage duration that have static initialization are initialized at compile time.
    This implies that these objects can be safely used when performing dynamic initialization
    of translation units.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the new specifier, `constinit`, is intended for. It ensures that
    a variable with static or thread-local storage has static initialization, and,
    therefore, its initialization is performed at compile time:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It can also be used in a non-initializing declaration to indicate that a variable
    with thread storage duration is already initialized, as shown in the following
    example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You cannot use more than one of the `constexpr`, `constinit`, and `consteval`
    specifiers in the same declaration.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating immediate functions*, to learn about the C++20 `consteval` specifier,
    which is used to define functions that are guaranteed to be evaluated at compile
    time'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating immediate functions
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`constexpr` functions enable the evaluation of functions at compile time, provided
    that all their inputs, if any, are also available at compile time. However, this
    is not a guarantee, and constexpr functions may also execute at runtime, as we
    have seen in the previous recipe, *Creating compile-time constant expressions*.
    In C++20, a new category of functions has been introduced: *immediate functions*.
    These are functions that are guaranteed to always be evaluated at compile time;
    otherwise, they produce errors. Immediate functions are useful as replacements
    for macros and may be important in the possible future development of the language
    with reflection and meta-classes.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `consteval` keyword when you want to:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Define non-member functions or function templates that must be evaluated at
    compile time:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define constructors that must be executed at compile time to initialize `constexpr`
    objects and member functions to be invoked only at compile time:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `consteval` specifier was introduced in C++20\. It can only be applied to
    functions and function templates and defines them as immediate functions. This
    means that any function invocation must be evaluated at compile time and therefore
    produce a compile-time constant expression. If the function cannot be evaluated
    at compile time, the program is ill-formed and the compiler issues an error.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rules apply to immediate functions:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Destructors, allocation, and deallocation functions cannot be immediate functions.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any declaration of a function contains the `consteval` specifier, then all
    the declarations of that function must also include it.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `consteval` specifier cannot be used together with `constexpr` or `constinit`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An immediate function is an inline `constexpr` function. Therefore, immediate
    functions and function templates must satisfy the requirements applicable to `constexpr`
    functions.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how we can use the `factorial()` function and the `point3d` class defined
    in the previous section:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, the following sample produces compiler errors because the immediate
    function `factorial()` and the constructor of `point3d` cannot be evaluated at
    compile time:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is not possible to take the address on an immediate function unless it is
    also in a constant expression:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Because immediate functions are not visible at runtime, their symbols are not
    emitted for them and debuggers will not be able to show them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating compile-time constant expressions*, to learn about the `constexpr`
    specifier and how to define variables and functions that can be evaluated at compile
    time'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing code in constant-evaluated contexts
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two recipes, we learned about *constexpr functions*, which allow
    functions to be evaluated at compile time if all their inputs are available at
    compile time, and *immediate functions* (in C++20), which are guaranteed to always
    be evaluated at compile time (or otherwise, produce an error). An important aspect
    of `constexpr` functions is constant-evaluated contexts; these are code paths
    where all expressions and functions are evaluated at compile time. A constant-evaluated
    context is useful for optimizing code more effectively. On the other hand, the
    invocation of immediate functions from `constexpr` functions is only possible
    in C++23\. In this recipe, we will learn about utilizing constant-evaluated contexts.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To determine whether a function context is constant-evaluated in order to provide
    compile-time implementations use the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++20, the `std::is_constant_evaluated()` library function, available in
    the `<type_traits>` header, with a regular `if` statement:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In C++23, the `if consteval` statement, which is a simplification (with additional
    benefits) of the `if(std::is_constant_evaluated())` statement:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++20 standard provides a library function (in the `<type_traits>` header)
    called `std::is_constant_evaluated()`, which detects whether its call occurs within
    a constant-evaluated context in a `constexpr` function. In this case, it returns
    `true`; otherwise, it returns `false`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is used with a regular `if` statement, as in the example provided
    in the previous section, where we computed the power of a number. The key takeaways
    from this implementation are the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: In a constant-evaluated context, we used an algorithm that can be executed by
    the compiler at compile time, to optimize the code.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a non-constant evaluated context (i.e., at runtime) we invoke the `std::pow()`
    function to compute the power.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are some “gotchas” with this function and the constant-evaluated
    contexts that you must be aware of:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Just because the arguments of a function are known at compile time, it does
    not mean that a context is constant-evaluated. In the following snippet, the first
    invocation of the `constexpr` function `power()` is in a constant-evaluated context,
    but the second is not, even though all its arguments are known at compile time
    and the function is declared `constexpr`:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If used with a `constexpr` if statement, the `std::is_constant_evaluated()`
    function always evaluates to `true` (compilers such as GCC and Clang provide a
    warning for this subtle error):'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is an example of the reported error:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The C++23 standard provides a better alternative to the `std::is_constant_evaluated()`
    function, the `consteval if` statement. This has several benefits:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Does not require the inclusion of a header
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids confusion about the correct form of the `if` statement to use
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the invocation of immediate functions in a constant-evaluated context
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of the power function changes to the following in C++23:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `consteval` `if` statement always requires braces. The negated form is
    also possible, either with `!` or the `not` keyword. In the following snippet,
    each of the two pairs of statements are equivalent:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `consteval` if statement is also important for allowing an immediate function
    to be invoked from a constant-evaluated context in a `constexpr` function. Let’s
    take the following C++20 example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, the function `plus_one()` is an immediate function and can be invoked
    from the `plus_two()` function, which is also an immediate function. However,
    invoking it from the `plus_two_alt()` function is not possible because it is not
    a constant expression, even though this is a `constexpr` function and the context
    where the `plus_one()` function is invoked is constant-evaluated.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem is solved by the C++23 `consteval if` statement. This makes it
    possible for immediate functions to be invoked from a constant-evaluated context,
    as shown in the following example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'With the availability of the `consteval if` statement, the `std::is_constant_evaluated()`
    function becomes obsolete. In fact, it can be implemented with a `consteval if`
    statement as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When using a C++23 compiler, you should always prefer the `consteval if` statement
    over the obsolete `std::is_constant_evaluated()` function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating compile-time constant expressions,* to learn about the `constexpr`
    specifier and how to define variables and functions that can be evaluated at compile
    time'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating immediate functions,* to learn about the C++20 `consteval` specifier,
    which is used to define functions that are guaranteed to be evaluated at compile
    time'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual function calls in constant expressions
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a multi-paradigm programming language, C++ includes support for object-oriented
    programming. Polymorphism, one of the core principles of object-oriented programming,
    has two forms in C++: compile-time polymorphism, with function and operator overloading,
    and runtime-polymorphism, with virtual functions. Virtual functions allow a derived
    class to override the implementation (of a function) in the base class. In C++20,
    however, virtual functions are allowed in constant expressions, meaning they can
    be invoked at compile time. In this recipe, you will learn how that works.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the following structure to represent the dimension
    of a document and, respectively, an envelope, in the ensuing examples:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How to do it…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can move runtime polymorphism to the compile time by doing the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Declare the virtual functions whose invocation you want to move to compile time
    as `constexpr`.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare the destructor of the base class of the hierarchy as `constexpr`.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare the overridden virtual function as `constexpr`.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the `constexpr` virtual function in a constant expression.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example is shown in the following snippet:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works…
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to C++20, virtual functions could not be `constexpr`. However, the dynamic
    type of an object used in a constant expression must be known at compile time.
    As a result, the restriction of making virtual functions `constexpr` has been
    lifted in C++20.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of having `constexpr` virtual functions is that some computations
    can be moved from runtime to compile time. Although this will not impact many
    use cases in practice, an example was given in the previous section. Let’s elaborate
    on it for a better understanding.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: We have a set of various paper sizes for documents. Examples include *A3*, *A4*,
    *A5*, *legal*, *letter*, and *half-letter*. These have different sizes. For instance,
    A5 is 148.5 mm x 210 mm, while letter is 215.9 mm x 279.4 mm.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we have envelopes of different types and sizes. For instance,
    we have an envelope that is 92 mm x 219 mm with a maximum enclosure size of 86
    mm x 213 mm. We want to write a function that determines whether a folded paper
    of a certain type can be placed inside an envelope. Since the sizes are standard,
    they are known at compile time. This means we can perform this check at compile
    time instead of runtime.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, in the *How to do it…* section, we have seen:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'A hierarchy of documents, with the base class called `document_type`. This
    has two members: a virtual destructor and a virtual function called `size()` that
    returns the size of the paper. Both of these functions are also `constexpr`.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A hierarchy of envelopes, with the base class called `envelope_type`. This
    has three members: a virtual destructor, a virtual function called `size()`, which
    returns the size of the envelope, and a virtual function called `max_enclosure_size()`,
    which returns the maximum size of a (folded) paper that can be placed in the envelope.
    All these are `constexpr`.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free function called `document_fits_envelope()` determines whether a given
    document type fits a particular envelope type, by comparing the size of the width
    of the two. This is also a `constexpr` function.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because all these functions mentioned are `constexpr`, the `document_fits_envelope()`
    function can be invoked in a constant expression, such as a `static_assert`, given
    that the objects for which they are invoked are also `constexpr`. In the code
    files that accompany the book you will find an elaborate example with various
    paper and envelope sizes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'You should keep in mind that:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: You can make an overridden virtual function `constexpr`, even though the function
    it overrides in the base class is not defined as `constexpr`.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The opposite is also possible, the overridden virtual function in the derived
    class can be non-`constexpr`, although the function was defined as `constexpr`
    in the base class.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is a hierarchy on multiple levels and a virtual function has some overrides
    defined as `constexpr` and some not, then the final overrider appropriate for
    the object on which the function is invoked is considered to determine whether
    the virtual function is `constexpr` or not.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Using override and final for virtual methods,* to learn how to
    use the override and final specifiers on virtual methods and classes, respectively'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing correct type casts
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often the case that data has to be converted from one type into another
    type. Some conversions are necessary at compile time (such as `double` to `int`);
    others are necessary at runtime (such as upcasting and downcasting pointers to
    the classes in a hierarchy). The language supports compatibility with the C casting
    style in either the `(type)expression` or `type(expression)` form. However, this
    type of casting breaks the type safety of C++.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the language also provides several conversions: `static_cast`, `dynamic_cast`,
    `const_cast`, and `reinterpret_cast`. They are used to better indicate intent
    and write safer code. In this recipe, we’ll look at how these casts can be used.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following casts to perform type conversions:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `static_cast` to perform type casting of non-polymorphic types, including
    the casting of integers to enumerations, from floating-point to integral values,
    or from a pointer type to another pointer type, such as from a base class to a
    derived class (downcasting) or from a derived class to a base class (upcasting),
    but without any runtime checks:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Use `dynamic_cast` to perform type casting of pointers or references of polymorphic
    types from a base class to a derived class or the other way around. These checks
    are performed at runtime and may require that **run-time type information** (**RTTI**)
    is enabled:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use `const_cast` to perform conversion between types with different `const`
    and `volatile` specifiers, such as removing `const` from an object that was not
    declared as `const`:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use `reinterpret_cast` to perform bit reinterpretation, such as conversion
    between integers and pointer types, from pointer types to integers, or from a
    pointer type to any other pointer type, without involving any runtime checks:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The explicit type conversion, sometimes referred to as *C-style casting* or
    *static casting*, is a legacy of the compatibility of C++ with the C language
    and enables you to perform various conversions including the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Between arithmetical types
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between pointer types
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between integral and pointer types
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between const or volatile qualified and unqualified types
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This type of casting does not work well with polymorphic types or in templates.
    Because of this, C++ provides the four casts we saw in the examples earlier. Using
    these casts leads to several important benefits:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: They express user intent better, both to the compiler and others that read the
    code.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They enable safer conversion between various types (except for `reinterpret_cast`).
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be easily searched in the source code.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static_cast` is not a direct equivalent of explicit type conversion, or static
    casting, even though the name might suggest that. This cast is performed at compile
    time and can be used to perform implicit conversions, the reverse of implicit
    conversions, and conversion from pointers to types from a hierarchy of classes.
    It cannot be used to trigger a conversion between unrelated pointer types, though.
    For this reason, in the following example, converting from `int*` to `double*`
    using `static_cast` produces a compiler error:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'However, converting from `base*` to `derived*` (where `base` and `derived`
    are the classes shown in the *How to do it...* section) does not produce a compiler
    error but a runtime error when trying to use the newly obtained pointer:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On the other hand, `static_cast` cannot be used to remove `const` and `volatile`
    qualifiers. The following snippet exemplifies this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Safely typecasting expressions up, down, or sideways along an inheritance hierarchy
    can be performed with `dynamic_cast`. This cast is performed at runtime and requires
    that RTTI is enabled. Because of this, it incurs a runtime overhead. Dynamic casting
    can only be used for pointers and references.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: When `dynamic_cast` is used to convert an expression into a pointer type and
    the operation fails, the result is a null pointer. When it is used to convert
    an expression into a reference type and the operation fails, a `std::bad_cast`
    exception is thrown. Therefore, always put a `dynamic_cast` conversion to a reference
    type within a `try...catch` block.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: RTTI is a mechanism that exposes information about object data types at runtime.
    This is available only for polymorphic types (types that have at least one virtual
    method, including a virtual destructor, which all base classes should have). RTTI
    is usually an optional compiler feature (or might not be supported at all), which
    means using this functionality may require using a compiler switch.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Though dynamic casting is performed at runtime, if you attempt to convert it
    between non-polymorphic types, you’ll get a compiler error:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`reinterpret_cast` is more like a compiler directive. It does not translate
    into any CPU instructions; it only instructs the compiler to interpret the binary
    representation of an expression as it was of another, specified type. This is
    a type-unsafe conversion and should be used with care. It can be used to convert
    expressions between integral types and pointers, pointer types, and function pointer
    types. Because no checks are done, `reinterpret_cast` can be successfully used
    to convert expressions between unrelated types, such as from `int*` to `double*`,
    which produces undefined behavior:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A typical use of `reinterpret_cast` is to convert expressions between types
    in code that uses operating system or vendor-specific APIs. Many APIs store user
    data in the form of a pointer or an integral type. Therefore, if you need to pass
    the address of a user-defined type to such APIs, you need to convert values of
    unrelated pointer types or a pointer type value into an integral type value. A
    similar example was provided in the previous section, where `widget` was a class
    that stored user-defined data in a data member and provided methods for accessing
    it: `set_data()` and `get_data()`. If you need to store a pointer to an object
    in `widget`, then use `reinterpret_cast`, as shown in this example.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '`const_cast` is similar to `reinterpret_cast` in the sense that it is a compiler
    directive and does not translate into CPU instructions. It is used to cast away
    `const` or `volatile` qualifiers, an operation that none of the other three conversions
    discussed here can do.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '`const_cast` should only be used to remove `const` or `volatile` qualifiers
    when the object is not declared `const` or `volatile`. Anything else incurs undefined
    behavior, as shown in the following example:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example, the variable `p` points to an object (the variable `a`) that
    was declared constant. By re­moving the `const` qualifier, the attempt to modify
    the pointed object introduces undefined behavior.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using explicit type conversion in the form `(type)expression`, be aware
    that it will select the first choice from the following list that satisfies specific
    cast requirements:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '`const_cast<type>(expression)`'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`static_cast<type>(expression)`'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`static_cast<type>(expression) + const_cast<type>(expression)`'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reinterpret_cast<type>(expression)`'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reinterpret_cast<type>(expression) + const_cast<type>(expression)`'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moreover, unlike the specific C++ casts, static cast can be used to convert
    between incomplete class types. If both `type` and `expression` are pointers to
    incomplete types, then it is not specified whether `static_cast` or `reinterpret_cast`
    is selected.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing move semantics
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Move semantics is a key feature that drives the performance improvements of
    modern C++. They enable moving, rather than copying, resources, or, in general,
    objects that are expensive to copy. However, it requires that classes implement
    a move constructor and move assignment operator. These are provided by the compiler
    in some circumstances, but in practice, it is often the case that you have to
    explicitly write them. In this recipe, we will see how to implement the move constructor
    and the move assignment operator.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are expected to have basic knowledge of rvalue references and the special
    class functions (constructors, assignment operators, and destructors). We will
    demonstrate how to implement a move constructor and assignment operator using
    the following `Buffer` class:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Let’s move on to the next section, where you’ll learn how to modify this class
    in order to benefit from move semantics.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the move constructor for a class, do the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a constructor that takes an rvalue reference to the class type:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Assign all the data members from the rvalue reference to the current object.
    This can be done either in the body of the constructor, as follows, or in the
    initialization list, which is the preferred way:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Optionally, assign the data members from the rvalue reference to default values
    (to ensure the object that was moved is in a destructible state):'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Put all together, the move constructor for the `Buffer` class looks like this:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To implement the move assignment operator for a class, do the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'Write an assignment operator that takes an rvalue reference to the class type
    and returns a reference to it:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Check that the rvalue reference does not refer to the same object as `this`,
    and if they are different, perform *steps 3* to *5*:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Dispose of all the resources (such as memory, handles, and so on) from the
    current object:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Assign all the data members from the rvalue reference to the current object:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Assign the data members from the rvalue reference to the default values:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Return a reference to the current object, regardless of whether *steps 3* to
    *5* were executed or not:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Put all together, the move assignment operator for the `Buffer` class looks
    like this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works...
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The move constructor and move assignment operator are provided by default by
    the compiler unless a user-defined copy constructor, move constructor, copy assignment
    operator, move assignment operator, or destructor exists already. When provided
    by the compiler, they perform a movement in a member-wise manner. The move constructor
    invokes the move constructors of the class data members recursively; similarly,
    the move assignment operator invokes the move assignment operators of the class
    data members recursively.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Move, in this case, represents a performance benefit for objects that are too
    large to copy (such as a string or container) or for objects that are not supposed
    to be copied (such as the `unique_ptr` smart pointer). Not all classes are supposed
    to implement both copy and move semantics. Some classes should only be movable,
    while others should be both copyable and movable. On the other hand, it does not
    make much sense for a class to be copyable but not moveable, though this can be
    technically achieved.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all types benefit from move semantics. In the case of built-in types (such
    as `bool`, `int`, or `double`), arrays, or PODs, the move is actually a copy operation.
    On the other hand, move semantics provide a performance benefit in the context
    of rvalues, that is, temporary objects. An rvalue is an object that does not have
    a name; it lives temporarily during the evaluation of an expression and is destroyed
    at the next semicolon:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the preceding example, `a`, `b`, and `c` are lvalues; they are objects that
    have a name that can be used to refer to the object at any point throughout its
    lifetime. On the other hand, when you evaluate the expression `a+b`, the compiler
    creates a temporary object (which, in this case, is assigned to `c`), which is
    then destroyed when a semicolon is encountered. These temporary objects are called
    rvalues because they usually appear on the right-hand side of an assignment expression.
    In C++11, we can refer to these objects through rvalue references, expressed with
    `&&`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Move semantics are important in the context of rvalues. This is because they
    allow you to take ownership of the resources from the temporary object that is
    destroyed, without the client being able to use it after the move operation is
    completed. On the other hand, lvalues cannot be moved; they can only be copied.
    This is because they can be accessed after the move operation, and the client
    expects the object to be in the same state. For instance, in the preceding example,
    the expression `b = a` assigns `a` to `b`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: After this operation is complete, the object `a`, which is an lvalue, can still
    be used by the client and should be in the same state as it was before. On the
    other hand, the result of `a+b` is temporary, and its data can be safely moved
    to `c`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: The move constructor is different from a copy constructor because it takes an
    rvalue reference to the class type `T(T&&)`, as opposed to an lvalue reference
    in the case of the copy constructor `T(T const&)`. Similarly, the move assignment
    takes an rvalue reference, namely `T& operator=(T&&)`, as opposed to an lvalue
    reference for the copy assignment operator, namely `T& operator=(T const &)`.
    This is true even though both return a reference to the `T&` class. The compiler
    selects the appropriate constructor or assignment operator based on the type of
    argument, rvalue, or lvalue.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'When a move constructor/assignment operator exists, an rvalue is moved automatically.
    lvalues can also be moved, but this requires an explicit casting to an rvalue
    reference. This can be done using the `std::move()` function, which basically
    performs a `static_cast<T&&>`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: After an object is moved, it must remain in a valid state. However, there is
    no requirement regarding what this state should be. For consistency, you should
    set all member fields to their default value (numerical types to `0`, pointers
    to `nullptr`, Booleans to `false`, and so on).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the different ways in which `Buffer` objects can
    be constructed and assigned:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The constructor or assignment operator involved in the creation or assignment
    of the objects `b1`, `b2`, `b3`, and `b4` is mentioned in the comments on each
    line.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As seen with the `Buffer` example, implementing both the move constructor and
    move assignment operator involves writing similar code (the entire code of the
    move constructor was also present in the move assignment operator). This can actually
    be avoided by calling the move assignment operator in the move constructor (or,
    alternatively, factor the assignment code into a private function that is invoked
    from both the move constructor and move assignment operator):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'There are two points that must be noticed in this example:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Member initialization in the constructor’s initialization list is necessary
    because these members could potentially be used in the move assignment operator
    later on (such as the `ptr` member in this example).
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static casting of `other` to an rvalue reference. Without this explicit conversion,
    the copy assignment operator would be called. This is because even if an rvalue
    is passed to this constructor as an argument, when it is assigned a name, it is
    bound to an lvalue. Therefore, `other` is actually an lvalue, and it must be converted
    to an rvalue reference in order to invoke the move assignment operator.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Defaulted and deleted functions*, to learn about the use of the
    `default` specifier on special member functions and how to define functions as
    deleted with the `delete` specifier'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using unique_ptr to uniquely own a memory resource
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manual handling of heap memory allocation and releasing it (with `new` and `delete`)
    is one of the most controversial features of C++. All allocations must be properly
    paired with a corresponding delete operation in the correct scope. If the memory
    allocation is done in a function and needs to be released before the function
    returns, for instance, then this has to happen on all the return paths, including
    the abnormal situation where a function returns because of an exception. C++11
    features, such as rvalues and move semantics, have enabled the development of
    better smart pointers (since some, such as `auto_ptr`, existed prior to C++11);
    these pointers can manage a memory resource and automatically release it when
    the smart pointer is destroyed. In this recipe, we will look at `std::unique_ptr`,
    a smart pointer that owns and manages another object or an array of objects allocated
    on the heap, and performs the disposal operation when the smart pointer goes out
    of scope.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following examples, we will use the ensuing class:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: For this recipe, you need to be familiar with move semantics and the `std::move()`
    conversion function. The `unique_ptr` class is available in the `std` namespace
    in the `<memory>` header.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of typical operations you need to be aware of when
    working with `std::unique_ptr`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the available overloaded constructors to create a `std::unique_ptr` that
    manages objects or an array of objects through a pointer. The default constructor
    creates a pointer that does not manage any object:'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Alternatively, use the `std::make_unique()` function template, available in
    C++14, to create `std::unique_ptr` objects:'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Use the `std::make_unique_for_overwrite()` function template, available in
    C++20, to create a `std::unique_ptr` to objects or an array of objects that are
    default initialized. These objects should later be overwritten with a determined
    value:'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Use the overloaded constructor, which takes a custom deleter if the default
    `delete` operator is not appropriate for destroying the managed object or array:'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Use `std::move()` to transfer the ownership of an object from one `std::unique_ptr`
    to another:'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To access the raw pointer to the managed object, use `get()` if you want to
    retain ownership of the object or `release()` if you want to release the ownership
    as well:'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Dereference the pointer to the managed object using `operator*` and `operator->`:'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If `std::unique_ptr` manages an array of objects, `operator[]` can be used
    to access individual elements of the array:'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To check whether `std::unique_ptr` can manage an object or not, use the explicit
    operator `bool` or check whether `get() != nullptr` (which is what the operator
    `bool` does):'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`std::unique_ptr` objects can be stored in a container. Objects returned by
    `make_unique()` can be stored directly. An lvalue object could be statically converted
    to an rvalue object with `std::move()` if you want to give up the ownership of
    the managed object to the `std::unique_ptr` object in the container:'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: How it works...
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unique_ptr` is a smart pointer that manages an object or an array allocated
    on the heap through a raw pointer. It performs an appropriate disposal when the
    smart pointer goes out of scope, is assigned a new pointer with `operator=`, or
    gives up ownership using the `release()` method. By default, the operator `delete`
    is used to dispose of the managed object. However, the user may supply a custom
    deleter when constructing the smart pointer. This deleter must be a function object,
    either an lvalue reference to a function object or a function, and this callable
    object must take a single argument of the type `unique_ptr<T, Deleter>::pointer`.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'C++14 has added the `std::make_unique()` utility function template to create
    a `std::unique_ptr`. It avoids memory leaks in some particular contexts, but it
    has some limitations:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: It can only be used to allocate arrays; you cannot use it to initialize them,
    which is possible with a `std::unique_ptr` constructor.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two pieces of sample code are equivalent:'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: It cannot be used to create a `std::unique_ptr` object with a user-defined deleter.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we just mentioned, the great advantage of `make_unique()` is that it helps
    us avoid memory leaks in some contexts where exceptions are being thrown. `make_unique()`
    itself can throw `std::bad_alloc` if the allocation fails or any exception is
    thrown by the constructor of the object it creates. Let’s consider the following
    example:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Regardless of what happens with the allocation and construction of `foo`, there
    will be no memory leaks, irrespective of whether you use `make_unique()` or the
    constructor of `std::unique_ptr`. However, this situation changes in a slightly
    different version of the code:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In this example, `some_other_function()` has an extra parameter: an integer
    value. The integer argument that’s passed to this function is the returned value
    of another function. If this function call throws an exception, using the constructor
    of `std::unique_ptr` to create the smart pointer can produce a memory leak. The
    reason for this is that, upon calling `some_other_function()`, the compiler might
    first call `foo`, then `function_that_throws()`, and then the constructor of `std::unique_ptr`.
    If `function_that_throws()` throws an error, then the allocated `foo` will leak.
    If the calling order is `function_that_throws()` and then `new foo()` and the
    constructor of `unique_ptr`, a memory leak will not happen; this is because the
    stack starts unwinding before the `foo` object is allocated. However, by using
    the `make_unique()` function, this situation is avoided. This is because the only
    calls made are to `make_unique()` and `function_that_throws()`. If `function_that_throws()`
    is called first, then the `foo` object will not be allocated at all. If `make_unique()`
    is called first, the `foo` object is constructed and its ownership is passed to
    `std::unique_ptr`. If a later call to `function_that_throws()` does throw, then
    `std::unique_ptr` will be destroyed when the stack is unwound and the `foo` object
    will be destroyed from the smart pointer’s destructor. C++17 fixed this problem
    by requiring any parameter to be fully evaluated before the next one is started.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: In C++20, a new function, called `std::make_unique_for_overwrite()`, has been
    added. This is similar to `make_unique()` except that its default initializes
    the object or the array of objects. This function can be used in generic code
    where it’s unknown whether the type template parameter is trivially copyable or
    not. This function expresses the intent to create a pointer to an object that
    may not be initialized so that it should be overwritten later.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Constant `std::unique_ptr` objects cannot transfer the ownership of a managed
    object or array to another `std::unique_ptr` object. On the other hand, access
    to the raw pointer to the managed object can be obtained with either `get()` or
    `release()`. The first method only returns the underlying pointer, but the latter
    also releases the ownership of the managed object, hence the name. After a call
    to `release()`, the `std::unique_ptr` object will be empty and a call to `get()`
    will return `nullptr`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'A `std::unique_ptr` that manages the object of a `Derived` class can be implicitly
    converted to a `std::unique_ptr` that manages an object of the class `Base` if
    `Derived` is derived from `Base`. This implicit conversion is safe only if `Base`
    has a virtual destructor (as all base classes should have); otherwise, undefined
    behavior is employed:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output from running this snippet is as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '`std::unique_ptr` can be stored in containers, such as `std::vector`. Because
    only one `std::unique_ptr` object can own the managed object at any point, the
    smart pointer cannot be copied to the container; it has to be moved. This is possible
    with `std::move()`, which performs a `static_cast` to an rvalue reference type.
    This allows the ownership of the managed object to be transferred to the `std::unique_ptr`
    object that is created in the container.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using shared_ptr to share a memory resource*, to learn about the `std::shared_ptr`
    class, which represents a smart pointer that shares ownership of an object or
    array of objects allocated on the heap'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shared_ptr to share a memory resource
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing dynamically allocated objects or arrays with `std::unique_ptr` is not
    possible when the object or array has to be shared. This is because a `std::unique_ptr`
    retains its sole ownership. The C++ standard provides another smart pointer, called
    `std::shared_ptr`; it is similar to `std::unique_ptr` in many ways, but the difference
    is that it can share the ownership of an object or array with other `std::shared_ptr`
    objects. In this recipe, we will see how `std::shared_ptr` works and how it differs
    from `std::uniqueu_ptr`. We will also look at `std::weak_ptr`, which is a non-resource-owning
    smart pointer that holds a reference to an object managed by a `std::shared_ptr`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you read the previous recipe, *Using unique_ptr to uniquely own a
    memory resource*, to become familiar with how `unique_ptr` and `make_unique()`
    work. We will use the `foo`, `foo_deleter`, `Base`, and `Derived` classes defined
    in this recipe, and also make several references to it.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Both the `shared_ptr` and `weak_ptr` classes, as well as the `make_shared()`
    function template, are available in the `std` namespace in the `<memory>` header.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity and readability, we will not use the fully qualified names `std::unique_ptr`,
    `std::shared_ptr`, and `std::weak_ptr` in this recipe, but `unique_ptr`, `shared_ptr`,
    and `weak_ptr`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of the typical operations you need to be aware of when
    working with `shared_ptr` and `weak_ptr`:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'Use one of the available overloaded constructors to create a `shared_ptr` that
    manages an object through a pointer. The default constructor creates an empty
    `shared_ptr`, which does not manage any object:'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Alternatively, use the `std::make_shared()` function template, available since
    C++11, to create `shared_ptr` objects:'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Use the `std::make_shared_for_overwrite()` function template, available in
    C++20, to create `shared_ptr`s to objects or arrays of objects that are default
    initialized. These objects should later be overwritten with a determined value:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Use the overloaded constructor, which takes a custom deleter if the default
    delete operation is not appropriate for destroying the managed object:'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Always specify a deleter when managing an array of objects. The deleter can
    either be a partial specialization of `std::default_delete` for arrays or any
    function that takes a pointer to the template type:'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To access the raw pointer to the managed object, use the `get()` function:'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Dereference the pointer to the managed object using `operator*` and `operator->`:'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If a `shared_ptr` manages an array of objects, `operator[]` can be used to
    access the individual elements of the array. This is only available in C++17:'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To check whether a `shared_ptr` could manage an object or not, use the explicit
    operator `bool` or check whether `get() != nullptr` (which is what the operator
    `bool` does):'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`shared_ptr` objects can be stored in containers, such as `std::vector`:'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Use `weak_ptr` to maintain a non-owning reference to a shared object, which
    can be later accessed through a `shared_ptr` constructed from the `weak_ptr` object:'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Use the `std::enable_shared_from_this` class template as the base class for
    a type when you need to create `shared_ptr` objects for instances that are already
    managed by another `shared_ptr` object:'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: How it works...
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`shared_ptr` is very similar to `unique_ptr` in many aspects; however, it serves
    a different purpose: sharing the ownership of an object or array. Two or more
    `shared_ptr` smart pointers can manage the same dynamically allocated object or
    array, which is automatically destroyed when the last smart pointer goes out of
    scope, is assigned a new pointer with `operator=`, or is reset with the method
    `reset()`. By default, the object is destroyed with `operator delete`; however,
    the user could supply a custom deleter to the constructor, something that is not
    possible using `std::make_shared()`. If `shared_ptr` is used to manage an array
    of objects, a custom deleter must be supplied. In this case, you can use `std::default_delete<T[]>`,
    which is a partial specialization of the `std::default_delete` class template
    that uses `operator delete[]` to delete the dynamically allocated array.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'The utility function `std::make_shared()` (available since C++11), unlike `std::make_unique()`,
    which has only been available since C++14, should be used to create smart pointers
    unless you need to provide a custom deleter. The primary reason for this is the
    same as for `make_unique()`: avoiding potential memory leaks in some contexts
    when an exception is thrown. For more information on this, read the explanation
    provided on `std::make_unique()` in the previous recipe.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: In C++20, a new function, called `std::make_shared_for_overwrite()`, has been
    added. This is similar to `make_shared()` except that it default initializes the
    object or the array of objects. This function can be used in generic code where
    it’s unknown whether the type template parameter is trivially copyable or not.
    This function expresses the intent to create a pointer to an object that may not
    be initialized so that it should be overwritten later.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as in the case of `unique_ptr`, a `shared_ptr` that manages an object
    of a `Derived` class can be implicitly converted to a `shared_ptr` that manages
    an object of the `Base` class. This is possible if the `Derived` class is derived
    from `Base`. This implicit conversion is safe only if `Base` has a virtual destructor
    (as all the base classes should have when objects are supposed to be deleted polymorphically
    through a pointer or reference to the base class); otherwise, undefined behavior
    is employed. In C++17, several new non-member functions have been added: `std::static_pointer_cast()`,
    `std::dynamic_pointer_cast()`, `std::const_pointer_cast()`, and `std::reinterpret_pointer_cast()`.
    These apply `static_cast`, `dynamic_cast`, `const_cast`, and `reinterpret_cast`
    to the stored pointer, returning a new `shared_ptr` to the designated type.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `Base` and `Derived` are the same classes we used
    in the previous recipe:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: There are situations when you need a smart pointer for a shared object but without
    it contributing to the shared ownership. Suppose you model a tree structure where
    a node has references to its children and they are represented by `shared_ptr`
    objects. On the other hand, say a node needs to keep a reference to its parent.
    If this reference were also `shared_ptr`, then it would create circular references
    and no object would ever be automatically destroyed.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '`weak_ptr` is a smart pointer that’s used to break such circular dependencies.
    It holds a non-owning reference to an object or array managed by a `shared_ptr`.
    `weak_ptr` can be created from a `shared_ptr` object. In order to access the managed
    object, you need to get a temporary `shared_ptr` object. To do so, we need to
    use the `lock()` method. This method atomically checks whether the referred object
    still exists and returns either an empty `shared_ptr`, if the object no longer
    exists, or a `shared_ptr` that owns the object, if it still exists. Because `weak_ptr`
    is a non-owning smart pointer, the referred object can be destroyed before `weak_ptr`
    goes out of scope or when all the owning `shared_ptr` objects have been destroyed,
    reset, or assigned to other pointers. The method `expired()` can be used to check
    whether the referenced object has been destroyed or is still available.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: In the *How to do it...* section, the preceding example models a master-apprentice
    relationship. There is a `Master` class and an `Apprentice` class. The `Master`
    class has a reference to an `Apprentice` class and a method called `take_apprentice()`
    to set the `Apprentice` object. The `Apprentice` class has a reference to a `Master`
    class and the method `take_master()` to set the `Master` object. In order to avoid
    circular dependencies, one of these references must be represented by a `weak_ptr`.
    In the proposed example, the `Master` class had a `shared_ptr` to own the `Apprentice`
    object, and the `Apprentice` class had a `weak_ptr` to track a reference to the
    `Master` object. This example, however, is a bit more complex because here, the
    `Apprentice::take_master()` method is called from `Master::take_apprentice()`
    and needs a `weak_ptr<Master>`. In order to call it from within the `Master` class,
    we must be able to create a `shared_ptr<Master>` in the `Master` class, using
    the `this` pointer. The only way to do this in a safe manner is to use `std::enable_shared_from_this`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '`std::enable_shared_from_this` is a class template that must be used as a base
    class for all the classes where you need to create a `shared_ptr` for the current
    object (the `this` pointer) when this object is already managed by another `shared_ptr`.
    Its type template parameter must be the class that derives from it, as in the
    curiously recurring template pattern. It has two methods: `shared_from_this()`,
    which returns a `shared_ptr`, which shares the ownership of the `this` object,
    and `weak_from_this()`, which returns a `weak_ptr`, which shares a non-owning
    reference to the `this` object. The latter method is only available in C++17\.
    These methods can be called only on an object that is managed by an existing `shared_ptr`;
    otherwise, they throw a `std::bad_weak_ptr` exception, as of C++17\. Prior to
    C++17, the behavior was undefined.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Not using `std::enable_shared_from_this` and creating a `shared_ptr<T>(this)`
    directly would lead to having multiple `shared_ptr` objects managing the same
    object independently, without knowing each other. When this happens, the object
    ends up being destroyed multiple times by different `shared_ptr` objects.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using unique_ptr to uniquely own a memory resource*, to learn about the `std::unique_ptr`
    class, which represents a smart pointer that owns and manages another object or
    array of objects allocated on the heap'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistent comparison with the operator <=>
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ language defines six relational operators that perform comparison:
    `==`, `!=`, `<`, `<=`, `>`, and `>=`. Although `!=` can be implemented in terms
    of `==`, and `<=`, `>=`, and `>` in terms of `<`, you still have to implement
    both `==` and `!=` if you want your user-defined type to support equality comparison,
    and `<`, `<=`, `>`, and `>=` if you want it to support ordering.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: That means 6 functions if you want objects of your type—let’s call it `T`—to
    be comparable, 12 if you want them to be comparable with another type, `U`, 18
    if you also want values of a `U` type to be comparable with your `T` type, and
    so on. The new C++20 standard reduces this number to either one or two, or multiple
    of these (depending on the comparison with other types) by introducing a new comparison
    operator, called *the three-way comparison*, which is designated with the symbol
    `<=>`, for which reason it is popularly known as the *spaceship operator*. This
    new operator helps us write less code, better describe the strength of relations,
    and avoid possible performance issues that come from manually implementing comparison
    operators in terms of others.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is necessary to include the header `<compare>` when defining or implementing
    the three-way comparison operator. This new C++20 header is part of the standard
    general utility library and provides classes, functions, and concepts for implementing
    comparison.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To optimally implement comparison in C++20, do the following:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only want your type to support equality comparison (both `==` and `!=`),
    implement only the `==` operator and return a `bool`. You can default the implementation
    so that the compiler performs a member-wise comparison:'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If you want your type to support both equality and ordering and the default
    member-wise comparison will do, then only define the `<=>` operator, returning
    `auto`, and default its implementation:'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'If you want your type to support both equality and ordering and you need to
    perform custom comparison, then implement both the `==` operator (for equality)
    and the `<=>` operator (for ordering):'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'When implementing the three-way comparison operator, follow these guidelines:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Only implement the three-way comparison operator but always use the two-way
    comparison operators `<`, `<=`, `>`, and `>=` when comparing values.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the three-way comparison operator as a member function, even if you
    want the first operand of a comparison to be of a type other than your class.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the three-way comparison operator as non-member functions only if
    you want implicit conversion on both arguments (that means comparing two objects,
    neither of which is of your class).
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new three-way comparison operator is similar to the `memcmp()`/`strcmp()`
    C functions and the `std::string::compare()` method. These functions take two
    arguments and return an integer value that is smaller than zero if the first is
    less than the second, zero if they are equal, or greater than zero if the first
    argument is greater than the second. The three-way comparison operator does not
    return an integer but a value of a comparison category type.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be one of the following:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '`std::strong_ordering` represents the result of a three-way comparison that
    supports all six relational operators, does not allow incomparable values (which
    means that at least one of `a < b`, `a == b`, and `a > b` must be true), and implies
    substitutability. This is a property such that if `a == b` and `f` is a function
    that reads only comparison-salient state (accessible via the argument’s public
    constant members), then `f(a) == f(b)`.'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::weak_ordering` supports all the six relational operators, does not support
    incomparable values (which means that none of `a < b`, `a == b`, and `a > b` could
    be true), but also does not imply substitutability. A typical example of a type
    that defines weak ordering is a case-insensitive string type.'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::partial_ordering` supports all six relational operators but does not
    imply substitutability and has a value that might not be comparable (for instance,
    a floating-point `NaN` cannot be compared to any other value).'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `std::strong_ordering` type is the strongest of all these category types.
    It is not implicitly convertible from any other category, but it implicitly converts
    to both `std::weak_ordering` and `std::partial_ordering`. `std::weak_ordering`
    is also implicitly convertible to `std::partial_ordering`. We’ve summarized all
    these properties in the following table:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Operators** | **Substitutability** | **Comparable values**
    | **Implicit conversion** |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
- en: '| `std::strong_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | Yes | Yes | ![](img/B21549_09_001.png)
    |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
- en: '| `std::weak_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | No | Yes | ![](img/B21549_09_001.png)
    |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
- en: '| `std::partial_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | No | No |  |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
- en: 'Table 9.2: Properties of the category types'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'These comparison categories have values that are implicitly comparable with
    literal zero (but not with an integer variable that is zero). Their values are
    listed in the following table:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Numeric values** | **Non-numeric values** |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
- en: '| -1 | 0 | 1 |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
- en: '| `strong_ordering` | less | equalequivalent | greater |  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
- en: '| `weak_ordering` | less | equivalent | greater |  |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
- en: '| `partial_ordering` | less | equivalent | greater | unordered |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
- en: 'Table 9.3: The values of the comparison categories that are implicitly comparable
    to literal zero'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how this works, let’s look at the following example:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Here, `cost_unit_t` is a base class that contains some (unspecified) data members
    and defines the `<=>` operator, although it is default-implemented by the compiler.
    This means that the compiler will also provide the `==` and `!=` operators, not
    just `<`, `<=`, `>`, and `>=`. This class is derived by `project_t`, which contains
    several data fields: an identifier for the project, a type, and a name. However,
    for this type, we cannot default the implementation of the operators, because
    we do not want to compare the fields member-wise, but in a custom order: first
    the name, then the type, and lastly the identifier. In this case, we implement
    both the `==` operator, which returns a `bool` and tests the member fields for
    equality, and the `<=>` operator, which returns `std::strong_ordering` and uses
    the `<=>` operator itself to compare the values of its two arguments.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The methods `is_same()`, `is_manager_of()`, and `is_managed_by()` return the
    relationship of two employees. However, it is possible there are employees with
    no relationship; for instance, employees in different teams, or a team without
    a manager-subordinate structure. Here, we can implement equality and ordering.
    However, since we cannot compare all employees with each other, the `<=>` operator
    must return a `std::partial_ordering` value. The return value is `partial_ordering::equivalent`
    if the values represent the same employee, `partial_ordering::less` if the current
    employee is managed by the supplied one, `partial_ordering::greater` if the current
    employee is the manager of the supplied one, and `partial_ordering::unorder` in
    all other cases.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see one more example to understand how the three-way comparison operator
    works. In the following sample, the `ipv4` class models an IP version 4 address.
    It supports comparison with both other objects of the `ipv4` type but also `unsigned
    long` values (because there is a `to_unlong()` method that converts the IP address
    into a 32-bit unsigned integral value):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'In this example, we overloaded the `<=>` operator and allowed it to be default
    implemented. But we also explicitly implemented overloads for `operator==` and
    `operator<=>`, which compare an `ipv4` object with an `unsigned long` value. Because
    of these operators, we can write any of the following:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'There are two things to notice here: the first is that although we only overloaded
    the `==` operator, we can also use the `!=` operator, and second, although we
    overloaded the `==` operator and the `<=>` operator to compare `ipv4` values to
    `unsigned long` values, we can also compare `unsigned long` values to `ipv4` values.
    This is because the compiler performs symmetrical overload resolution. That means
    that for an expression `a@b` where `@` is a two-way relational operator, it performs
    name lookup for `a@b`, `a<=>b`, and `b<=>a`. The following table shows the list
    of all possible transformations of the relational operators:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '| `a == b` | `b == a` |  |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
- en: '| `a != b` | `!(a == b)` | `!(b == a)` |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
- en: '| `a <=> b` | `0 <=> (b <=> a)` |  |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
- en: '| `a < b` | `(a <=> b) < 0` | `0 > (b <=> a)` |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
- en: '| `a <= b` | `(a <=> b) <= 0` | `0 >= (b <=> a)` |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
- en: '| `a > b` | `(a <=> b) > 0` | `0 < (b <=> a)` |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
- en: '| `a >= b` | `(a <=> b) >= 0` | `0 <= (b <=> a)` |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
- en: 'Table 9.4: The possible transformations of the relational operators'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: This greatly reduces the number of overloads you must explicitly provide for
    supporting comparison in different forms. The three-way comparison operator can
    be implemented either as a member or as a non-member function. In general, you
    should prefer the member implementation.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'The non-member form should be used only when you want implicit conversion on
    both arguments. The following shows an example:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Although the `<=>` operator is defined for the type `B`, because it is a non-member
    and because `A` can be implicitly converted to `B`, we can perform a comparison
    on objects of the `A` type.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-592
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Simplifying code with class template argument deduction*, to
    learn how to use class templates without explicitly specifying template arguments'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing signed and unsigned integers safely
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ language features a variety of integral types: `short`, `int`, `long`,
    and `long long`, as well as their unsigned counterparts `unsigned short`, `unsigned
    int`, `unsigned long`, and `unsigned long long`. In C++11, fixed-width integer
    types were introduced, such as `int32_t` and `uint32_t`, and many similar others.
    Apart from these, there are also the types `char`, `signed char`, `unsigned char`,
    `wchar_t`, `char8_t`, `char16_t`, and `char32_t`, although these are not supposed
    to store numbers but characters. Moreover, the type `bool` used for storing the
    values `true` or `false` is also an integral type. The comparison of values of
    these types is a common operation but comparing signed and unsigned values is
    error-prone. Without some compiler-specific switches to flag these as warnings
    or errors, you can perform these operations and get unexpected results. For instance,
    the comparison `-1 < 42u` (comparing signed -1 with unsigned 42) would yield `false`.
    The C++20 standard provides a set of functions for performing a safe comparison
    of signed and unsigned values, which we will learn about in this recipe.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform a safe comparison of signed and unsigned integer values that ensures
    negative signed integers always compare less than unsigned values, use one of
    the following comparison functions from the `<utility>` header:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Corresponding comparison operator** |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_equal` | `==` |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_not_equal` | `!=` |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_less` | `<` |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_less_equal` | `<=` |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_greater` | `>` |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_greater_equal` | `>=` |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
- en: 'Table 9.5: New C++20 comparison functions and their corresponding comparison
    operator'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows an example:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: How it works…
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comparing two signed or two unsigned values is straightforward but comparing
    a signed and unsigned integer is error prone. When such a comparison occurs, the
    signed value is converted to unsigned. For instance, integer -1 becomes 4294967295\.
    The reason for this is that signed numbers are stored in memory as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: 'The most significant bit indicates the sign: 0 for positive numbers and 1 for
    negative ones.'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Negative values are stored by inverting the bits of the positive number and
    adding 1.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This representation is known as the **two’s complement**. For instance, assuming
    an 8-bit signed representation, value 1 is stored as `0000001`, but the value
    -1 is stored as `11111111`. This is because the 7 least significant bits of the
    positive number are `0000001`, which inverted are `1111110`. By adding 1, we get
    `1111111`. Together with the sign bit this makes `11111111`. For 32-bit signed
    integers, the value -1 is stored as `11111111'11111111'11111111'11111111`.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This is true for all the six equality (`==`, `!=`) and inequality (`<`, `<=`,
    `>`, `>=`) operators. To get the correct result, we need to check whether the
    signed values are negative. The correct condition for the `if` statement shown
    previously is the following:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: To ease the writing of such expressions, the C++20 standard has introduced the
    six functions listed in *Table 9.5* that should be used as replacements for the
    corresponding operator when comparing signed and unsigned integers.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'A possible implementation for the `std::cmp_less()` function is shown in the
    next snippet:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'What this does is the following:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: If both arguments are signed, it uses the built-in `<` comparison operator to
    compare them.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the first argument is signed and the second is unsigned, then it checks whether
    the first is native (a negative value is always less than a positive one) or compares
    the first argument cast to unsigned with the second argument using the built-in
    operator `<`.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the first argument is unsigned, the second can be either signed or unsigned.
    The first argument can only be less than the second if the second is positive
    and the first is less than the second cast as unsigned.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you use these functions, keep in mind that they only work for:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '`short`, `int`, `long`, `long long`, and their unsigned counterparts'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed-width integer types such as `int32_t`, `int_least32_t`, `int_fast32_t`
    and their unsigned counterparts
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended integer types (which are compiler-specific types such as `__int64`
    or `__int128` and their unsigned counterparts that most compilers support)
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next snippet provides an example for using extended types (in this case
    Microsoft specific) and standard fixed with integer types, respectively.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'However, you cannot use them to compare enums, `std::byte`, `char`, `char8_t`,
    `char16_t`, `char32_t`, `wchar_t`, and `bool`. In this case, you would get a compiler
    error:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: See also
  id: totrans-634
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 2*, *Understanding the various numeric types*, to learn about the
    available integral and floating-point types'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performing correct type casts*, to learn the proper way of performing type
    casts in C++'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行正确的类型转换*，了解在 C++ 中执行类型转换的正确方法'
- en: Learn more on Discord
  id: totrans-637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_09.xhtml)'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_09.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
