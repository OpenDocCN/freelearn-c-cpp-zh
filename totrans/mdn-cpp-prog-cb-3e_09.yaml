- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robustness and Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ is often the first choice when it comes to selecting an object-oriented
    programming language with performance and flexibility as key goals. Modern C++
    provides language and library features, such as rvalue references, move semantics,
    and smart pointers.
  prefs: []
  type: TYPE_NORMAL
- en: When combined with good practices for exception handling, constant correctness,
    type-safe conversions, resource allocation, and releasing, C++ enables developers
    to write better, more robust, and performant code. This chapter’s recipes address
    all of these essential topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using exceptions for error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `noexcept` for functions that do not throw exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring constant correctness for a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating compile-time constant expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating immediate functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing code in constant-evaluated contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual function calls in constant expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing correct type casts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing move semantics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `unique_ptr` to uniquely own a memory resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `shared_ptr` to share a memory resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistent comparison with the operator `<=>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing signed and unsigned integers safely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start this chapter with a couple of recipes that deal with exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Using exceptions for error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions are responses to exceptional circumstances that can appear when a
    program is running. They enable the transfer of the control flow to another part
    of the program. Exceptions are a mechanism for simpler and more robust error handling,
    as opposed to returning error codes, which could greatly complicate and clutter
    the code. In this recipe, we will look at some key aspects related to throwing
    and handling exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires you to have basic knowledge of the mechanisms of throwing
    exceptions (using the `throw` statement) and catching exceptions (using `try...catch`
    blocks). This recipe is focused on good practices around exceptions and not on
    the details of the exception mechanism in the C++ language.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following practices to deal with exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Throw exceptions by value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Catch exceptions by reference, or in most cases, by constant reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Order `catch` statements from the most derived class to the base class of the
    hierarchy when catching multiple exceptions from a class hierarchy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `catch(...)` to catch all exceptions, regardless of their type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use `throw;` to rethrow the current exception. This can be used to create a
    single exception-handling function for multiple exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throw the exception object (for example, `throw e;`) when you want to hide
    the original location of the exception:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most functions have to indicate the success or failure of their execution.
    This can be achieved in different ways. Here are several possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return an error code (with a special value for success) to indicate the specific
    reason for failure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A variation of this is to return a Boolean value to only indicate success or
    failure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another alternative is to return invalid objects, null pointers, or empty `std::optional<T>`
    objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In any case, the return value from the functions should be checked. This can
    lead to complex, cluttered, and hard-to-read and maintain real-world code. Moreover,
    the process of checking the return value of a function is always executed, regardless
    of whether the function was successful or failed. On the other hand, exceptions
    are thrown and handled only when a function fails, which should happen more rarely
    than successful executions. This can actually lead to faster code than code that
    returns and tests error codes.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions and error codes are not mutually exclusive. Exceptions should be
    used only for transferring the control flow in exceptional situations, not for
    controlling the data flow in a program.
  prefs: []
  type: TYPE_NORMAL
- en: Class constructors are special functions that do not return any value. They
    are supposed to construct an object, but in the case of failure, they will not
    be able to indicate this with a return value. Exceptions should be a mechanism
    that constructors use to indicate failure. Together with the **Resource Acquisition
    Is Initialization** (**RAII**) idiom, this ensures the safe acquisition and release
    of resources in all situations. On the other hand, exceptions are not allowed
    to leave a destructor. When this happens, the program abnormally terminates with
    a call to `std::terminate()`. This is the case for destructors called during stack
    unwinding, due to the occurrence of another exception. When an exception occurs,
    the stack is unwound from the point where the exception was thrown to the block
    where the exception is handled. This process involves the destruction of all local
    objects in all those stack frames.
  prefs: []
  type: TYPE_NORMAL
- en: If the destructor of an object that is being destroyed during this process throws
    an exception, another stack unwinding process should begin, which conflicts with
    the one already under way. Because of this, the program terminates abnormally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule of thumb for dealing with exceptions in constructors and destructors
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use exceptions to indicate the errors that occur in constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not throw or let exceptions leave destructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to throw any type of exception. However, in most cases, you
    should throw temporaries and catch exceptions by constant reference. The reason
    for catching (constant) references is to avoid slicing the exception types. Let’s
    consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are throwing a `simple_error` object but catch a `std::exception` object
    by value. This is the base type of `simple_error`. The *slicing* process occurs,
    the derived type information is lost, and only the `std::exception` part of the
    object is kept. Therefore, the printed message is *Unknown exception* and not
    *simple exception* as one would expect. Using a reference avoids the object slicing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some guidelines for exception throwing:'
  prefs: []
  type: TYPE_NORMAL
- en: Prefer throwing either standard exceptions or your own exceptions derived from
    `std::exception` or another standard exception. The reason for this is that the
    standard library provides exception classes that are intended to be the first
    choice for representing exceptions. You should use the ones that are available
    already and when these are not good enough, build your own based on the standard
    ones. The main benefits of this are consistency and helping users catch exceptions
    via the base `std::exception` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid throwing exceptions of built-in types, such as integers. The reason for
    this is that numbers carry little information to the user, who must know what
    it represents, while an object can provide contextual information. For instance,
    the statement `throw 13;` tells nothing to the user, but `throw access_denied_exception{};`
    carries much more implicit information from the class name alone, and with the
    help of data members, it carries anything useful or necessary about the exceptional
    situation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using a library or framework that provides its own exception hierarchy,
    prefer throwing exceptions from this hierarchy or your own exceptions derived
    from it, at least in the parts of the code that are tightly related to it. The
    main reason for this is to keep the code that utilizes the library APIs consistent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the preceding section, when you need to create your own exception
    types, derive them from one of the standard exceptions that are available, unless
    you are using a library or framework with its own exception hierarchy. The C++
    standard defines several categories of exceptions that need to be considered for
    this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: The `std::logic_error` represents an exception that indicates an error in the
    program logic, such as an invalid argument and an index beyond the bounds of a
    range. There are various standard-derived classes, such as `std::invalid_argument`,
    `std::out_of_range`, and `std::length_error`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `std::runtime_error` represents an exception that indicates an error beyond
    the scope of the program or that cannot be predicted due to various factors, including
    external ones, such as overflows and underflows or operating system errors. The
    C++ standard also provides several derived classes from `std::runtime_error`,
    including `std::overflow_error`, `std::underflow_error`, `std::system_error`,
    and `std::format_error` in C++20.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions prefixed with `bad_`, such as `std::bad_alloc`, `std::bad_cast`,
    and `std::bad_function_call`, represent various errors in a program, such as failure
    to allocate memory and failure to dynamically cast or make a function call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base class for all these exceptions is `std::exception`. It has a non-throwing
    virtual method called `what()` that returns a pointer to an array of characters
    representing the description of the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you need to derive custom exceptions from a standard exception, use the
    appropriate category, such as logical or runtime error. If none of these categories
    is suitable, then you can derive directly from `std::exception`. The following
    is a list of possible solutions you can use to derive from a standard exception:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to derive from `std::exception`, then override the virtual method
    `what()` to provide a description of the error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you derive from `std::logic_error` or `std::runtime_error` and you only
    need to provide a static description that does not depend on runtime data, then
    pass the description text to the base class constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you derive from `std::logic_error` or `std::runtime_error` but the description
    message depends on runtime data, provide a constructor with parameters and use
    them to build the description message. You can either pass the description message
    to the base class constructor or return it from the overridden `what()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For a complete list of the standard exception classes, you can visit the [https://en.cppreference.com/w/cpp/error/exception](https://en.cppreference.com/w/cpp/error/exception)
    page.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 8*, *Handling exceptions from thread functions*, to understand how
    to handle exceptions thrown in a worker thread from the main thread or the thread
    where it was joined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using noexcept for functions that do not throw exceptions*, to see how to
    inform the compiler that a function should not throw exceptions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using noexcept for functions that do not throw exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception specification is a language feature that can enable performance improvements,
    but on the other hand, when done incorrectly, it can abnormally terminate the
    program. The exception specification from C++03, which allowed you to indicate
    what types of exceptions a function could throw, was deprecated in C++11 and removed
    in C++17\. It was replaced with the C++11 `noexcept` specifier. Moreover, the
    use of the `throw()` specifier to indicate that a function throws, without indicating
    what exception types have also been deprecated in C++17 and completely removed
    in C++20\. The `noexcept` specifier only allows you to indicate that a function
    does not throw exceptions (as opposed to the old `throw` specifier, which could
    indicate the list of types a function could throw). This recipe provides information
    about the modern exception specifications in C++, as well as guidelines on when
    to use them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following constructs to specify or query exception specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `noexcept` in a function declaration to indicate that the function is not
    throwing any exception:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `noexcept(expr)` in a function declaration, such as template metaprogramming,
    to indicate that the function may or may not throw an exception based on a condition
    that evaluates to `bool`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `noexcept` operator at compile time to check whether an expression
    is declared to not throw any exception:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of C++17, exception specification is part of the function type, but not part
    of the function signature; it may appear as part of any function declarator. Because
    exception specification is not part of the function signature, two function signatures
    cannot differ only in the exception specification.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C++17, exception specification was not part of the function type and
    could only appear as part of lambda declarators or top-level function declarators;
    they could not appear even in `typedef` or type alias declarations. Further discussions
    on exception specification refer solely to the C++17 standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways in which the process of throwing an exception can be
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: If no exception specification is present, then the function could potentially
    throw exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noexcept(false)` is equivalent to no exception specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noexcept(true)` and `noexcept` indicate that a function does not throw any
    exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throw()` was equivalent to `noexcept(true)` but was deprecated in C++17 and
    removed altogether in C++20.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using exception specifications must be done with care because if an exception
    (either thrown directly or from another function that is called) leaves a function
    marked as non-throwing, the program is terminated immediately and abnormally with
    a call to `std::terminate()`.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers to the functions that do not throw exceptions can be implicitly converted
    to pointers to functions that may throw exceptions, but not vice versa. On the
    other hand, if a virtual function has a non-throwing exception specification,
    this indicates that all the declarations of all the overrides must preserve this
    specification unless an overridden function is declared as deleted.
  prefs: []
  type: TYPE_NORMAL
- en: At compile time, it is possible to check whether a function is declared to be
    non-throwing or not using the operator `noexcept`. This operator takes an expression
    and returns `true` if the expression is declared as either non-throwing or `false`.
    It does not evaluate the expression it checks.
  prefs: []
  type: TYPE_NORMAL
- en: The `noexcept` operator, along with the `noexcept` specifier, is particularly
    useful in template metaprogramming to indicate whether a function may throw exceptions
    for some types. It is also used with `static_assert` declarations to check whether
    an expression breaks the non-throwing guarantee of a function, as seen in the
    examples in the *How to do it...* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code provides more examples of how the `noexcept` operator works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the `noexcept` specifier does not provide compile-time
    checking for exceptions. It only represents a way for users to inform the compiler
    that a function is not expected to throw exceptions. The compiler can use this
    to enable certain optimizations. An example is the `std::vector`, which moves
    elements if their move constructor is `noexcept` and copies them otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, a function declared with the `noexcept` specifier that
    exits due to an exception causes the program to terminate abnormally. Therefore,
    the `noexcept` specifier should be used with caution. Its presence can enable
    code optimizations, which help increase performance while preserving the *strong
    exception guarantee*. An example of this is library containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ language provides several levels of exception guarantees:'
  prefs: []
  type: TYPE_NORMAL
- en: The first level, *no exception guarantees*, does not provide any guarantees.
    If an exception occurs, there is nothing to indicate whether the program is left
    in a valid state. Resources could be leaked, memory can be corrupted, and object
    invariants may be broken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *basic exception guarantee* is the simplest level of guarantee, which ensures
    that after an exception is thrown, objects are left in a consistent and usable
    state, no resource leaks occur, and invariants are preserved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *strong exception guarantee* specifies that either an operation is completed
    successfully, or that it is completed with an exception that leaves the program
    in the same state it was in before the operation started. This ensures commit-or-rollback
    semantics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *no-throw exception guarantee* is actually the strongest of them all and
    specifies that an operation is guaranteed to not throw any exception and to complete
    successfully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many standard containers provide some of their operations with a strong exception
    guarantee. An example is vector’s `push_back()` method. This method could be optimized
    by using the move constructor or move assignment operator instead of the copy
    constructor or copy assignment operator of the vector’s element type. However,
    in order to preserve its strong exception guarantee, this can only be done if
    the move constructor or assignment operator does not throw exceptions. If either
    does, then the copy constructor or the assignment operator must be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::move_if_noexcept()` utility function does this if the move constructor
    of its type argument is marked with `noexcept`. The ability to indicate that move
    constructors or move assignment operators do not throw exceptions is probably
    the most important scenario where `noexcept` is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following rules for the exception specification:'
  prefs: []
  type: TYPE_NORMAL
- en: If a function could potentially throw an exception, then do not use any exception
    specifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark only those functions with `noexcept` that are guaranteed not to throw an
    exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark only those functions with `noexcept(expression)` that could potentially
    throw exceptions based on a condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These rules are important because, as already noted previously, throwing an
    exception from a `noexcept` function will immediately terminate the program with
    a call to `std::terminate()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using exceptions for error handling*, to explore the best practices for using
    exceptions in the C++ language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring constant correctness for a program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although there is no formal definition, constant correctness means objects that
    are not supposed to be modified (are immutable) remain unmodified. As a developer,
    you can enforce this by using the `const` keyword for declaring parameters, variables,
    and member functions. In this recipe, we will explore the benefits of constant
    correctness and how to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To ensure constant correctness for a program, you should always declare the
    following as constants:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters to functions that are not supposed to be modified within the function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Class data members that do not change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Class member functions that do not modify the object state, as seen from the
    outside:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Function locals whose values do not change throughout their lifetime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'References that should be bound to a temporary (an rvalue) in order to extend
    the lifetime of the temporary to the lifetime of the (constant) reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declaring objects and member functions as constant has several important benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: You prevent both accidental and intentional changes of the object, which, in
    some cases, can result in incorrect program behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You enable the compiler to perform better optimizations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You document the semantics of the code for other users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant correctness is not a matter of personal style but a core principle
    that should guide C++ development.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the importance of constant correctness has not been, and is still
    not, stressed enough in books, C++ communities, and working environments. But
    the rule of thumb is that everything that is not supposed to change should be
    declared as constant. This should be done all the time and not only at later stages
    of development, when you might need to clean up and refactor the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you declare a parameter or variable as constant, you can either put the
    `const` keyword before the type (`const T c`) or after the type (`T const c`).
    These two are equivalent, but regardless of which of the two styles you use, the
    reading of the declaration must be done from the right-hand side. `const T c`
    is read as *c is a T that is constant* and `T const c` as *c is a constant T*.
    This gets a little bit more complicated with pointers. The following table presents
    various pointer declarations and their meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `T* p` | `p` is a non-constant pointer to a non-constant `T`. |'
  prefs: []
  type: TYPE_TB
- en: '| `const T* p` | `p` is a non-constant pointer to a `T` that is constant. |'
  prefs: []
  type: TYPE_TB
- en: '| `T const * p` | `p` is a non-constant pointer to a constant `T` (same as
    the prior point). |'
  prefs: []
  type: TYPE_TB
- en: '| `const T * const p` | `p` is a constant pointer to a `T` that is constant.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `T const * const p` | `p` is a constant pointer to a constant `T` (same as
    the prior point). |'
  prefs: []
  type: TYPE_TB
- en: '| `T** p` | `p` is a non-constant pointer to a non-constant pointer to a non-constant
    `T`. |'
  prefs: []
  type: TYPE_TB
- en: '| `const T** p` | `p` is a non-constant pointer to a non-constant pointer to
    a constant `T`. |'
  prefs: []
  type: TYPE_TB
- en: '| `T const ** p` | Same as `const T** p`. |'
  prefs: []
  type: TYPE_TB
- en: '| `const T* const * p` | `p` is a non-constant pointer to a constant pointer,
    which is a constant `T`. |'
  prefs: []
  type: TYPE_TB
- en: '| `T const * const * p` | Same as `const T* const * p`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.1: Example of pointer declarations and their meaning'
  prefs: []
  type: TYPE_NORMAL
- en: Placing the `const` keyword after the type is more natural because it is consistent
    with the direction the syntax is interpreted, from right to left. For this reason,
    all the examples in this book use this style.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to references, the situation is similar: `const T & c` and `T
    const & c` are equivalent, which means *c is a reference to a constant T*. However,
    `T const & const c`, which would mean that *c is a constant reference to a constant
    T*, does not make sense because references—aliases of a variable—are implicitly
    constant in the sense that they cannot be modified to represent an alias to another
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A non-constant pointer to a non-constant object, that is, `T*`, can be implicitly
    converted to a non-constant pointer to a constant object, `T const *`. However,
    `T**` cannot be implicitly converted to `T const **` (which is the same with `const
    T**`). This is because this could lead to constant objects being modified through
    a pointer to a non-constant object, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If an object is constant, only the constant functions of its class can be invoked.
    However, declaring a member function as constant does not mean that the function
    can only be called on constant objects; it could also mean that the function does
    not modify the state of the object, as seen from the outside. This is a key aspect,
    but it is usually misunderstood. A class has an internal state that it can expose
    to its clients through its public interface.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all the internal states might be exposed, and what is visible from
    the public interface might not have a direct representation in the internal state.
    (If you model order lines and have the item quantity and item selling price fields
    in the internal representation, then you might have a public method that exposes
    the order line amount by multiplying the quantity by the price.) Therefore, the
    state of an object, as visible from its public interface, is a logical state.
    Defining a method as constant is a statement that ensures the function does not
    alter the logical state. However, the compiler prevents you from modifying data
    members using such methods. To avoid this problem, data members that are supposed
    to be modified from constant methods should be declared `mutable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `computation` is a class with the `compute()` method,
    which performs a long-running computation operation. Because it does not affect
    the logical state of the object, this function is declared constant. However,
    to avoid computing the result of the same input again, the computed values are
    stored in a cache. To be able to modify the cache from the constant function,
    it is declared `mutable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar situation is represented by the following class, which implements
    a thread-safe container. Access to shared internal data is protected with `mutex`.
    The class provides methods such as adding and removing values, and also methods
    such as `contains()`, which indicate whether an item exists in the container.
    Because this member function is not intended to modify the logical state of the
    object, it is declared constant. However, access to the shared internal state
    must be protected with the mutex. In order to lock and unlock the mutex, both
    mutable operations (that modify the state of the object) and the mutex must be
    declared `mutable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `mutable` specifier allows us to modify the class member on which it was
    used, even if the containing object is declared `const`. This is the case of the
    `mt` member of the `std::mutex` type, which is modified even within the `contains()`
    method, which is declared `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a method or an operator is overloaded to have both constant and
    non-constant versions. This is often the case with the subscript operator or methods
    that provide direct access to the internal state. The reason for this is that
    the method is supposed to be available for both constant and non-constant objects.
    The behavior should be different, though: for non-constant objects, the method
    should allow the client to modify the data it provides access to, but for constant
    objects, it should not. Therefore, the non-constant subscript operator returns
    a reference to a non-constant object, and the constant subscript operator returns
    a reference to a constant object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that, if a member function is constant, even if an object
    is constant, the data that’s returned by this member function may not be constant.
  prefs: []
  type: TYPE_NORMAL
- en: An important use case for the use of `const` is to define references to temporary
    objects, as shown in the last bullet in the *How to do it…* section. A temporary
    is an rvalue and a non-`const` lvalue reference cannot be bound to an rvalue.
    However, it is possible by making the lvalue reference `const`. This has the effect
    of extending the lifetime of the temporary object to the lifetime of the constant
    reference. However, this only works for stack-based references but not for references
    that are members of objects.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `const` qualifier of an object can be removed with a `const_cast` conversion,
    but this should only be used when you know that the object was not declared constant.
    You can read more about this in the *Performing correct type casts* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating compile-time constant expressions*, to learn about the `constexpr`
    specifier and how to define variables and functions that can be evaluated at compile
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating immediate functions*, to learn about the C++20 `consteval` specifier,
    which is used to define functions that are guaranteed to be evaluated at compile
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performing correct type casts*, to learn about the best practices for performing
    correct casts in the C++ language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating compile-time constant expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The possibility to evaluate expressions at compile time improves runtime execution
    because there is less code to run and the compiler can perform additional optimizations.
    Compile-time constants can be not only literals (such as a number or string),
    but also the result of a function’s execution. If all the input values of a function
    (regardless of whether they are arguments, locals, or global variables) are known
    at compile time, the compiler can execute the function and have the result available
    at compile time. This is what generalized the constant expressions that were introduced
    in C++11, which were relaxed in C++14 and even further in C++20\. The keyword
    `constexpr` (short for *constant expression*) can be used to declare compile-time
    constant objects and functions. We have seen this in several examples in the previous
    chapters. Now, it’s time to learn how it actually works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way generalized constant expressions work has been relaxed in C++14 and
    C++20, but this introduced some breaking changes to C++11\. For instance, in C++11,
    a `constexpr` function was implicitly `const`, but this is no longer the case
    in C++14\. In this recipe, we will discuss generalized constant expressions, as
    defined in C++20.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `constexpr` keyword when you want to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define non-member functions that can be evaluated at compile time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define constructors that can be executed at compile time to initialize `constexpr`
    objects and member functions to be invoked during this period:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define variables that can have their values evaluated at compile time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `const` keyword is used for declaring variables as constant at runtime;
    this means that, once initialized, they cannot be changed. However, evaluating
    the constant expression may still imply runtime computation. The `constexpr` keyword
    is used for declaring variables that are constant at compile time or functions
    that can be executed at compile time. `constexpr` functions and objects can replace
    macros and hardcoded literals without any performance penalties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring a function as `constexpr` does not mean that it is always evaluated
    at compile time. It only enables the use of the function in expressions that are
    evaluated during compile time. This only happens if all the input values of the
    function can be evaluated at compile time. However, the function may also be invoked
    at runtime. The following code shows two invocations of the same function, first
    at compile time, and then at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some restrictions in regard to where `constexpr` can be used. These
    restrictions have evolved over time, with changes in C++14 and C++20\. To keep
    the list in a reasonable form, only the requirements that need to be satisfied
    in C++20 are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable that is `constexpr` must satisfy the following requirements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its type is a literal type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is initialized upon declaration.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression used for initializing the variable is a constant expression.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have constant destruction. This means that it must not be of a class
    type or an array of a class type; otherwise, the class type must have a `constexpr`
    destructor.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function that is `constexpr` must satisfy the following requirements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not a coroutine.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type and the type of all its parameters are all literal types.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is at least one set of arguments for which the invocation of the function
    would produce a constant expression.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The function body must not contain `goto` statements, labels (other than `case`
    and `default` in a switch), and local variables that are either of non-literal
    types or of static or thread storage duration. The restrictions mentioned in this
    bullet point were removed in C++23.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A constructor that is `constexpr` must satisfy the following requirements,
    in addition to the preceding ones required for functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no virtual base class for the class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All the constructors that initialize non-static data members, including base
    classes, must also be `constexpr`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A destructor that is `constexpr`, available only since C++20, must satisfy
    the following requirements, in addition to the preceding ones required for functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no virtual base class for the class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All the destructors that destroy non-static data members, including base classes,
    must also be `constexpr`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All the restrictions for `constexpr` constructors and destructors mentioned
    here were removed in C++23.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of requirements in different versions of the standard, you
    should read the online documentation available at [https://en.cppreference.com/w/cpp/language/constexpr](https://en.cppreference.com/w/cpp/language/constexpr).
  prefs: []
  type: TYPE_NORMAL
- en: 'A function that is `constexpr` is not implicitly `const` (as of C++14), so
    you need to explicitly use the `const` specifier if the function does not alter
    the logical state of the object. However, a function that is `constexpr` is implicitly
    `inline`. On the other hand, an object that is declared `constexpr` is implicitly
    `const`. The following two declarations are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There are situations when you may need to use both `constexpr` and `const`
    in a declaration, as they would refer to different parts of the declaration. In
    the following example, `p` is a `constexpr` pointer to a constant integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Reference variables can also be `constexpr` if, and only if, they alias an
    object with static storage duration or a function. The following snippet provides
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `r` is a `constexpr` reference that defines an alias for the
    compile-time constant variable `c`, defined in the previous snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can define static `constexpr` variables, doing so in a `constexpr`
    function was not possible until C++23\. The following snippet shows such an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration of the `symbols` variable would generate a compiler error,
    prior to C++23\. A possible workaround for this problem was to define the variable
    outside of the `constexpr` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This problem has been solved in C++23, which relaxed several `constexpr` restrictions,
    making a workaround unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more aspect that should be mentioned on constexpr functions is related
    to exceptions. Since C++20, try-catch blocks are allowed in constexpr functions
    (their use was not possible prior to this version). However, throwing exceptions
    from constant expressions is not allowed. Although you can have a throw statement
    in a constexpr function, the behavior is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When executed at runtime, it would behave as if it wasn’t declared constexpr.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When executed at compile time, if the execution path encounters a throw statement,
    a compiler error is emitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is exemplified in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two calls to `factorial2()` are executed at runtime. The first executes
    successfully and returns `60`. The second throws a `std::invalid_argument` exception
    because the argument is negative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third call is evaluated at compile time because variable `c` is declared
    `constexpr` and all the function’s inputs are also known at compile time. The
    invocation is successful and the function evaluates to `60`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth call is also evaluated at compile time, but since the argument is
    negative the path that throws an exception should execute. However, this is not
    allowed in constant expressions, and, therefore, the compiler issues an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++20, a new specifier was added to the language. This specifier is called
    `constinit` and is used to ensure that variables with static or thread storage
    duration have static initialization. In C++, the initialization of variables can
    be either static or dynamic. Static initialization can be either zero initialization
    (when the initial value of an object is set to zero) or constant initialization
    (when the initial value is set to a compile-time expression). The following snippet
    shows examples of zero and constant initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A variable that has static storage could have either static or dynamic initialization.
    In the latter case, hard-to-find bugs may appear. Imagine two static objects that
    are initialized in different translation units.
  prefs: []
  type: TYPE_NORMAL
- en: When the initialization of one of the two objects depends on the other object,
    then the order they are initialized in is important. This is because the object
    that depends on the object must be initialized first. However, the order of the
    initialization of the translation units is not deterministic, so there is no guarantee
    of the order of these objects’ initialization. However, variables with static
    storage duration that have static initialization are initialized at compile time.
    This implies that these objects can be safely used when performing dynamic initialization
    of translation units.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the new specifier, `constinit`, is intended for. It ensures that
    a variable with static or thread-local storage has static initialization, and,
    therefore, its initialization is performed at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be used in a non-initializing declaration to indicate that a variable
    with thread storage duration is already initialized, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You cannot use more than one of the `constexpr`, `constinit`, and `consteval`
    specifiers in the same declaration.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating immediate functions*, to learn about the C++20 `consteval` specifier,
    which is used to define functions that are guaranteed to be evaluated at compile
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating immediate functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`constexpr` functions enable the evaluation of functions at compile time, provided
    that all their inputs, if any, are also available at compile time. However, this
    is not a guarantee, and constexpr functions may also execute at runtime, as we
    have seen in the previous recipe, *Creating compile-time constant expressions*.
    In C++20, a new category of functions has been introduced: *immediate functions*.
    These are functions that are guaranteed to always be evaluated at compile time;
    otherwise, they produce errors. Immediate functions are useful as replacements
    for macros and may be important in the possible future development of the language
    with reflection and meta-classes.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `consteval` keyword when you want to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define non-member functions or function templates that must be evaluated at
    compile time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define constructors that must be executed at compile time to initialize `constexpr`
    objects and member functions to be invoked only at compile time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `consteval` specifier was introduced in C++20\. It can only be applied to
    functions and function templates and defines them as immediate functions. This
    means that any function invocation must be evaluated at compile time and therefore
    produce a compile-time constant expression. If the function cannot be evaluated
    at compile time, the program is ill-formed and the compiler issues an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rules apply to immediate functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Destructors, allocation, and deallocation functions cannot be immediate functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any declaration of a function contains the `consteval` specifier, then all
    the declarations of that function must also include it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `consteval` specifier cannot be used together with `constexpr` or `constinit`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An immediate function is an inline `constexpr` function. Therefore, immediate
    functions and function templates must satisfy the requirements applicable to `constexpr`
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how we can use the `factorial()` function and the `point3d` class defined
    in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following sample produces compiler errors because the immediate
    function `factorial()` and the constructor of `point3d` cannot be evaluated at
    compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not possible to take the address on an immediate function unless it is
    also in a constant expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Because immediate functions are not visible at runtime, their symbols are not
    emitted for them and debuggers will not be able to show them.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating compile-time constant expressions*, to learn about the `constexpr`
    specifier and how to define variables and functions that can be evaluated at compile
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing code in constant-evaluated contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two recipes, we learned about *constexpr functions*, which allow
    functions to be evaluated at compile time if all their inputs are available at
    compile time, and *immediate functions* (in C++20), which are guaranteed to always
    be evaluated at compile time (or otherwise, produce an error). An important aspect
    of `constexpr` functions is constant-evaluated contexts; these are code paths
    where all expressions and functions are evaluated at compile time. A constant-evaluated
    context is useful for optimizing code more effectively. On the other hand, the
    invocation of immediate functions from `constexpr` functions is only possible
    in C++23\. In this recipe, we will learn about utilizing constant-evaluated contexts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To determine whether a function context is constant-evaluated in order to provide
    compile-time implementations use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++20, the `std::is_constant_evaluated()` library function, available in
    the `<type_traits>` header, with a regular `if` statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In C++23, the `if consteval` statement, which is a simplification (with additional
    benefits) of the `if(std::is_constant_evaluated())` statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++20 standard provides a library function (in the `<type_traits>` header)
    called `std::is_constant_evaluated()`, which detects whether its call occurs within
    a constant-evaluated context in a `constexpr` function. In this case, it returns
    `true`; otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is used with a regular `if` statement, as in the example provided
    in the previous section, where we computed the power of a number. The key takeaways
    from this implementation are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In a constant-evaluated context, we used an algorithm that can be executed by
    the compiler at compile time, to optimize the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a non-constant evaluated context (i.e., at runtime) we invoke the `std::pow()`
    function to compute the power.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are some “gotchas” with this function and the constant-evaluated
    contexts that you must be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just because the arguments of a function are known at compile time, it does
    not mean that a context is constant-evaluated. In the following snippet, the first
    invocation of the `constexpr` function `power()` is in a constant-evaluated context,
    but the second is not, even though all its arguments are known at compile time
    and the function is declared `constexpr`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If used with a `constexpr` if statement, the `std::is_constant_evaluated()`
    function always evaluates to `true` (compilers such as GCC and Clang provide a
    warning for this subtle error):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is an example of the reported error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++23 standard provides a better alternative to the `std::is_constant_evaluated()`
    function, the `consteval if` statement. This has several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Does not require the inclusion of a header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids confusion about the correct form of the `if` statement to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the invocation of immediate functions in a constant-evaluated context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of the power function changes to the following in C++23:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `consteval` `if` statement always requires braces. The negated form is
    also possible, either with `!` or the `not` keyword. In the following snippet,
    each of the two pairs of statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `consteval` if statement is also important for allowing an immediate function
    to be invoked from a constant-evaluated context in a `constexpr` function. Let’s
    take the following C++20 example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, the function `plus_one()` is an immediate function and can be invoked
    from the `plus_two()` function, which is also an immediate function. However,
    invoking it from the `plus_two_alt()` function is not possible because it is not
    a constant expression, even though this is a `constexpr` function and the context
    where the `plus_one()` function is invoked is constant-evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem is solved by the C++23 `consteval if` statement. This makes it
    possible for immediate functions to be invoked from a constant-evaluated context,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'With the availability of the `consteval if` statement, the `std::is_constant_evaluated()`
    function becomes obsolete. In fact, it can be implemented with a `consteval if`
    statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When using a C++23 compiler, you should always prefer the `consteval if` statement
    over the obsolete `std::is_constant_evaluated()` function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating compile-time constant expressions,* to learn about the `constexpr`
    specifier and how to define variables and functions that can be evaluated at compile
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating immediate functions,* to learn about the C++20 `consteval` specifier,
    which is used to define functions that are guaranteed to be evaluated at compile
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual function calls in constant expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a multi-paradigm programming language, C++ includes support for object-oriented
    programming. Polymorphism, one of the core principles of object-oriented programming,
    has two forms in C++: compile-time polymorphism, with function and operator overloading,
    and runtime-polymorphism, with virtual functions. Virtual functions allow a derived
    class to override the implementation (of a function) in the base class. In C++20,
    however, virtual functions are allowed in constant expressions, meaning they can
    be invoked at compile time. In this recipe, you will learn how that works.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the following structure to represent the dimension
    of a document and, respectively, an envelope, in the ensuing examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can move runtime polymorphism to the compile time by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the virtual functions whose invocation you want to move to compile time
    as `constexpr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare the destructor of the base class of the hierarchy as `constexpr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare the overridden virtual function as `constexpr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the `constexpr` virtual function in a constant expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to C++20, virtual functions could not be `constexpr`. However, the dynamic
    type of an object used in a constant expression must be known at compile time.
    As a result, the restriction of making virtual functions `constexpr` has been
    lifted in C++20.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of having `constexpr` virtual functions is that some computations
    can be moved from runtime to compile time. Although this will not impact many
    use cases in practice, an example was given in the previous section. Let’s elaborate
    on it for a better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: We have a set of various paper sizes for documents. Examples include *A3*, *A4*,
    *A5*, *legal*, *letter*, and *half-letter*. These have different sizes. For instance,
    A5 is 148.5 mm x 210 mm, while letter is 215.9 mm x 279.4 mm.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we have envelopes of different types and sizes. For instance,
    we have an envelope that is 92 mm x 219 mm with a maximum enclosure size of 86
    mm x 213 mm. We want to write a function that determines whether a folded paper
    of a certain type can be placed inside an envelope. Since the sizes are standard,
    they are known at compile time. This means we can perform this check at compile
    time instead of runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, in the *How to do it…* section, we have seen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A hierarchy of documents, with the base class called `document_type`. This
    has two members: a virtual destructor and a virtual function called `size()` that
    returns the size of the paper. Both of these functions are also `constexpr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A hierarchy of envelopes, with the base class called `envelope_type`. This
    has three members: a virtual destructor, a virtual function called `size()`, which
    returns the size of the envelope, and a virtual function called `max_enclosure_size()`,
    which returns the maximum size of a (folded) paper that can be placed in the envelope.
    All these are `constexpr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free function called `document_fits_envelope()` determines whether a given
    document type fits a particular envelope type, by comparing the size of the width
    of the two. This is also a `constexpr` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because all these functions mentioned are `constexpr`, the `document_fits_envelope()`
    function can be invoked in a constant expression, such as a `static_assert`, given
    that the objects for which they are invoked are also `constexpr`. In the code
    files that accompany the book you will find an elaborate example with various
    paper and envelope sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should keep in mind that:'
  prefs: []
  type: TYPE_NORMAL
- en: You can make an overridden virtual function `constexpr`, even though the function
    it overrides in the base class is not defined as `constexpr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The opposite is also possible, the overridden virtual function in the derived
    class can be non-`constexpr`, although the function was defined as `constexpr`
    in the base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is a hierarchy on multiple levels and a virtual function has some overrides
    defined as `constexpr` and some not, then the final overrider appropriate for
    the object on which the function is invoked is considered to determine whether
    the virtual function is `constexpr` or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Using override and final for virtual methods,* to learn how to
    use the override and final specifiers on virtual methods and classes, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing correct type casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often the case that data has to be converted from one type into another
    type. Some conversions are necessary at compile time (such as `double` to `int`);
    others are necessary at runtime (such as upcasting and downcasting pointers to
    the classes in a hierarchy). The language supports compatibility with the C casting
    style in either the `(type)expression` or `type(expression)` form. However, this
    type of casting breaks the type safety of C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the language also provides several conversions: `static_cast`, `dynamic_cast`,
    `const_cast`, and `reinterpret_cast`. They are used to better indicate intent
    and write safer code. In this recipe, we’ll look at how these casts can be used.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following casts to perform type conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `static_cast` to perform type casting of non-polymorphic types, including
    the casting of integers to enumerations, from floating-point to integral values,
    or from a pointer type to another pointer type, such as from a base class to a
    derived class (downcasting) or from a derived class to a base class (upcasting),
    but without any runtime checks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `dynamic_cast` to perform type casting of pointers or references of polymorphic
    types from a base class to a derived class or the other way around. These checks
    are performed at runtime and may require that **run-time type information** (**RTTI**)
    is enabled:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `const_cast` to perform conversion between types with different `const`
    and `volatile` specifiers, such as removing `const` from an object that was not
    declared as `const`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `reinterpret_cast` to perform bit reinterpretation, such as conversion
    between integers and pointer types, from pointer types to integers, or from a
    pointer type to any other pointer type, without involving any runtime checks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The explicit type conversion, sometimes referred to as *C-style casting* or
    *static casting*, is a legacy of the compatibility of C++ with the C language
    and enables you to perform various conversions including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Between arithmetical types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between pointer types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between integral and pointer types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between const or volatile qualified and unqualified types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This type of casting does not work well with polymorphic types or in templates.
    Because of this, C++ provides the four casts we saw in the examples earlier. Using
    these casts leads to several important benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: They express user intent better, both to the compiler and others that read the
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They enable safer conversion between various types (except for `reinterpret_cast`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be easily searched in the source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static_cast` is not a direct equivalent of explicit type conversion, or static
    casting, even though the name might suggest that. This cast is performed at compile
    time and can be used to perform implicit conversions, the reverse of implicit
    conversions, and conversion from pointers to types from a hierarchy of classes.
    It cannot be used to trigger a conversion between unrelated pointer types, though.
    For this reason, in the following example, converting from `int*` to `double*`
    using `static_cast` produces a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'However, converting from `base*` to `derived*` (where `base` and `derived`
    are the classes shown in the *How to do it...* section) does not produce a compiler
    error but a runtime error when trying to use the newly obtained pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, `static_cast` cannot be used to remove `const` and `volatile`
    qualifiers. The following snippet exemplifies this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Safely typecasting expressions up, down, or sideways along an inheritance hierarchy
    can be performed with `dynamic_cast`. This cast is performed at runtime and requires
    that RTTI is enabled. Because of this, it incurs a runtime overhead. Dynamic casting
    can only be used for pointers and references.
  prefs: []
  type: TYPE_NORMAL
- en: When `dynamic_cast` is used to convert an expression into a pointer type and
    the operation fails, the result is a null pointer. When it is used to convert
    an expression into a reference type and the operation fails, a `std::bad_cast`
    exception is thrown. Therefore, always put a `dynamic_cast` conversion to a reference
    type within a `try...catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: RTTI is a mechanism that exposes information about object data types at runtime.
    This is available only for polymorphic types (types that have at least one virtual
    method, including a virtual destructor, which all base classes should have). RTTI
    is usually an optional compiler feature (or might not be supported at all), which
    means using this functionality may require using a compiler switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though dynamic casting is performed at runtime, if you attempt to convert it
    between non-polymorphic types, you’ll get a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`reinterpret_cast` is more like a compiler directive. It does not translate
    into any CPU instructions; it only instructs the compiler to interpret the binary
    representation of an expression as it was of another, specified type. This is
    a type-unsafe conversion and should be used with care. It can be used to convert
    expressions between integral types and pointers, pointer types, and function pointer
    types. Because no checks are done, `reinterpret_cast` can be successfully used
    to convert expressions between unrelated types, such as from `int*` to `double*`,
    which produces undefined behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical use of `reinterpret_cast` is to convert expressions between types
    in code that uses operating system or vendor-specific APIs. Many APIs store user
    data in the form of a pointer or an integral type. Therefore, if you need to pass
    the address of a user-defined type to such APIs, you need to convert values of
    unrelated pointer types or a pointer type value into an integral type value. A
    similar example was provided in the previous section, where `widget` was a class
    that stored user-defined data in a data member and provided methods for accessing
    it: `set_data()` and `get_data()`. If you need to store a pointer to an object
    in `widget`, then use `reinterpret_cast`, as shown in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: '`const_cast` is similar to `reinterpret_cast` in the sense that it is a compiler
    directive and does not translate into CPU instructions. It is used to cast away
    `const` or `volatile` qualifiers, an operation that none of the other three conversions
    discussed here can do.'
  prefs: []
  type: TYPE_NORMAL
- en: '`const_cast` should only be used to remove `const` or `volatile` qualifiers
    when the object is not declared `const` or `volatile`. Anything else incurs undefined
    behavior, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the variable `p` points to an object (the variable `a`) that
    was declared constant. By re­moving the `const` qualifier, the attempt to modify
    the pointed object introduces undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using explicit type conversion in the form `(type)expression`, be aware
    that it will select the first choice from the following list that satisfies specific
    cast requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const_cast<type>(expression)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`static_cast<type>(expression)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`static_cast<type>(expression) + const_cast<type>(expression)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reinterpret_cast<type>(expression)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reinterpret_cast<type>(expression) + const_cast<type>(expression)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moreover, unlike the specific C++ casts, static cast can be used to convert
    between incomplete class types. If both `type` and `expression` are pointers to
    incomplete types, then it is not specified whether `static_cast` or `reinterpret_cast`
    is selected.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing move semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Move semantics is a key feature that drives the performance improvements of
    modern C++. They enable moving, rather than copying, resources, or, in general,
    objects that are expensive to copy. However, it requires that classes implement
    a move constructor and move assignment operator. These are provided by the compiler
    in some circumstances, but in practice, it is often the case that you have to
    explicitly write them. In this recipe, we will see how to implement the move constructor
    and the move assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are expected to have basic knowledge of rvalue references and the special
    class functions (constructors, assignment operators, and destructors). We will
    demonstrate how to implement a move constructor and assignment operator using
    the following `Buffer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Let’s move on to the next section, where you’ll learn how to modify this class
    in order to benefit from move semantics.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the move constructor for a class, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a constructor that takes an rvalue reference to the class type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign all the data members from the rvalue reference to the current object.
    This can be done either in the body of the constructor, as follows, or in the
    initialization list, which is the preferred way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Optionally, assign the data members from the rvalue reference to default values
    (to ensure the object that was moved is in a destructible state):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put all together, the move constructor for the `Buffer` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the move assignment operator for a class, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write an assignment operator that takes an rvalue reference to the class type
    and returns a reference to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that the rvalue reference does not refer to the same object as `this`,
    and if they are different, perform *steps 3* to *5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dispose of all the resources (such as memory, handles, and so on) from the
    current object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign all the data members from the rvalue reference to the current object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign the data members from the rvalue reference to the default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return a reference to the current object, regardless of whether *steps 3* to
    *5* were executed or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put all together, the move assignment operator for the `Buffer` class looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The move constructor and move assignment operator are provided by default by
    the compiler unless a user-defined copy constructor, move constructor, copy assignment
    operator, move assignment operator, or destructor exists already. When provided
    by the compiler, they perform a movement in a member-wise manner. The move constructor
    invokes the move constructors of the class data members recursively; similarly,
    the move assignment operator invokes the move assignment operators of the class
    data members recursively.
  prefs: []
  type: TYPE_NORMAL
- en: Move, in this case, represents a performance benefit for objects that are too
    large to copy (such as a string or container) or for objects that are not supposed
    to be copied (such as the `unique_ptr` smart pointer). Not all classes are supposed
    to implement both copy and move semantics. Some classes should only be movable,
    while others should be both copyable and movable. On the other hand, it does not
    make much sense for a class to be copyable but not moveable, though this can be
    technically achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all types benefit from move semantics. In the case of built-in types (such
    as `bool`, `int`, or `double`), arrays, or PODs, the move is actually a copy operation.
    On the other hand, move semantics provide a performance benefit in the context
    of rvalues, that is, temporary objects. An rvalue is an object that does not have
    a name; it lives temporarily during the evaluation of an expression and is destroyed
    at the next semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `a`, `b`, and `c` are lvalues; they are objects that
    have a name that can be used to refer to the object at any point throughout its
    lifetime. On the other hand, when you evaluate the expression `a+b`, the compiler
    creates a temporary object (which, in this case, is assigned to `c`), which is
    then destroyed when a semicolon is encountered. These temporary objects are called
    rvalues because they usually appear on the right-hand side of an assignment expression.
    In C++11, we can refer to these objects through rvalue references, expressed with
    `&&`.
  prefs: []
  type: TYPE_NORMAL
- en: Move semantics are important in the context of rvalues. This is because they
    allow you to take ownership of the resources from the temporary object that is
    destroyed, without the client being able to use it after the move operation is
    completed. On the other hand, lvalues cannot be moved; they can only be copied.
    This is because they can be accessed after the move operation, and the client
    expects the object to be in the same state. For instance, in the preceding example,
    the expression `b = a` assigns `a` to `b`.
  prefs: []
  type: TYPE_NORMAL
- en: After this operation is complete, the object `a`, which is an lvalue, can still
    be used by the client and should be in the same state as it was before. On the
    other hand, the result of `a+b` is temporary, and its data can be safely moved
    to `c`.
  prefs: []
  type: TYPE_NORMAL
- en: The move constructor is different from a copy constructor because it takes an
    rvalue reference to the class type `T(T&&)`, as opposed to an lvalue reference
    in the case of the copy constructor `T(T const&)`. Similarly, the move assignment
    takes an rvalue reference, namely `T& operator=(T&&)`, as opposed to an lvalue
    reference for the copy assignment operator, namely `T& operator=(T const &)`.
    This is true even though both return a reference to the `T&` class. The compiler
    selects the appropriate constructor or assignment operator based on the type of
    argument, rvalue, or lvalue.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a move constructor/assignment operator exists, an rvalue is moved automatically.
    lvalues can also be moved, but this requires an explicit casting to an rvalue
    reference. This can be done using the `std::move()` function, which basically
    performs a `static_cast<T&&>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: After an object is moved, it must remain in a valid state. However, there is
    no requirement regarding what this state should be. For consistency, you should
    set all member fields to their default value (numerical types to `0`, pointers
    to `nullptr`, Booleans to `false`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the different ways in which `Buffer` objects can
    be constructed and assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The constructor or assignment operator involved in the creation or assignment
    of the objects `b1`, `b2`, `b3`, and `b4` is mentioned in the comments on each
    line.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As seen with the `Buffer` example, implementing both the move constructor and
    move assignment operator involves writing similar code (the entire code of the
    move constructor was also present in the move assignment operator). This can actually
    be avoided by calling the move assignment operator in the move constructor (or,
    alternatively, factor the assignment code into a private function that is invoked
    from both the move constructor and move assignment operator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two points that must be noticed in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: Member initialization in the constructor’s initialization list is necessary
    because these members could potentially be used in the move assignment operator
    later on (such as the `ptr` member in this example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static casting of `other` to an rvalue reference. Without this explicit conversion,
    the copy assignment operator would be called. This is because even if an rvalue
    is passed to this constructor as an argument, when it is assigned a name, it is
    bound to an lvalue. Therefore, `other` is actually an lvalue, and it must be converted
    to an rvalue reference in order to invoke the move assignment operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Defaulted and deleted functions*, to learn about the use of the
    `default` specifier on special member functions and how to define functions as
    deleted with the `delete` specifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using unique_ptr to uniquely own a memory resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manual handling of heap memory allocation and releasing it (with `new` and `delete`)
    is one of the most controversial features of C++. All allocations must be properly
    paired with a corresponding delete operation in the correct scope. If the memory
    allocation is done in a function and needs to be released before the function
    returns, for instance, then this has to happen on all the return paths, including
    the abnormal situation where a function returns because of an exception. C++11
    features, such as rvalues and move semantics, have enabled the development of
    better smart pointers (since some, such as `auto_ptr`, existed prior to C++11);
    these pointers can manage a memory resource and automatically release it when
    the smart pointer is destroyed. In this recipe, we will look at `std::unique_ptr`,
    a smart pointer that owns and manages another object or an array of objects allocated
    on the heap, and performs the disposal operation when the smart pointer goes out
    of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following examples, we will use the ensuing class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: For this recipe, you need to be familiar with move semantics and the `std::move()`
    conversion function. The `unique_ptr` class is available in the `std` namespace
    in the `<memory>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of typical operations you need to be aware of when
    working with `std::unique_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the available overloaded constructors to create a `std::unique_ptr` that
    manages objects or an array of objects through a pointer. The default constructor
    creates a pointer that does not manage any object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, use the `std::make_unique()` function template, available in
    C++14, to create `std::unique_ptr` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `std::make_unique_for_overwrite()` function template, available in
    C++20, to create a `std::unique_ptr` to objects or an array of objects that are
    default initialized. These objects should later be overwritten with a determined
    value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the overloaded constructor, which takes a custom deleter if the default
    `delete` operator is not appropriate for destroying the managed object or array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::move()` to transfer the ownership of an object from one `std::unique_ptr`
    to another:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To access the raw pointer to the managed object, use `get()` if you want to
    retain ownership of the object or `release()` if you want to release the ownership
    as well:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dereference the pointer to the managed object using `operator*` and `operator->`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `std::unique_ptr` manages an array of objects, `operator[]` can be used
    to access individual elements of the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether `std::unique_ptr` can manage an object or not, use the explicit
    operator `bool` or check whether `get() != nullptr` (which is what the operator
    `bool` does):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::unique_ptr` objects can be stored in a container. Objects returned by
    `make_unique()` can be stored directly. An lvalue object could be statically converted
    to an rvalue object with `std::move()` if you want to give up the ownership of
    the managed object to the `std::unique_ptr` object in the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unique_ptr` is a smart pointer that manages an object or an array allocated
    on the heap through a raw pointer. It performs an appropriate disposal when the
    smart pointer goes out of scope, is assigned a new pointer with `operator=`, or
    gives up ownership using the `release()` method. By default, the operator `delete`
    is used to dispose of the managed object. However, the user may supply a custom
    deleter when constructing the smart pointer. This deleter must be a function object,
    either an lvalue reference to a function object or a function, and this callable
    object must take a single argument of the type `unique_ptr<T, Deleter>::pointer`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C++14 has added the `std::make_unique()` utility function template to create
    a `std::unique_ptr`. It avoids memory leaks in some particular contexts, but it
    has some limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: It can only be used to allocate arrays; you cannot use it to initialize them,
    which is possible with a `std::unique_ptr` constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two pieces of sample code are equivalent:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It cannot be used to create a `std::unique_ptr` object with a user-defined deleter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we just mentioned, the great advantage of `make_unique()` is that it helps
    us avoid memory leaks in some contexts where exceptions are being thrown. `make_unique()`
    itself can throw `std::bad_alloc` if the allocation fails or any exception is
    thrown by the constructor of the object it creates. Let’s consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of what happens with the allocation and construction of `foo`, there
    will be no memory leaks, irrespective of whether you use `make_unique()` or the
    constructor of `std::unique_ptr`. However, this situation changes in a slightly
    different version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `some_other_function()` has an extra parameter: an integer
    value. The integer argument that’s passed to this function is the returned value
    of another function. If this function call throws an exception, using the constructor
    of `std::unique_ptr` to create the smart pointer can produce a memory leak. The
    reason for this is that, upon calling `some_other_function()`, the compiler might
    first call `foo`, then `function_that_throws()`, and then the constructor of `std::unique_ptr`.
    If `function_that_throws()` throws an error, then the allocated `foo` will leak.
    If the calling order is `function_that_throws()` and then `new foo()` and the
    constructor of `unique_ptr`, a memory leak will not happen; this is because the
    stack starts unwinding before the `foo` object is allocated. However, by using
    the `make_unique()` function, this situation is avoided. This is because the only
    calls made are to `make_unique()` and `function_that_throws()`. If `function_that_throws()`
    is called first, then the `foo` object will not be allocated at all. If `make_unique()`
    is called first, the `foo` object is constructed and its ownership is passed to
    `std::unique_ptr`. If a later call to `function_that_throws()` does throw, then
    `std::unique_ptr` will be destroyed when the stack is unwound and the `foo` object
    will be destroyed from the smart pointer’s destructor. C++17 fixed this problem
    by requiring any parameter to be fully evaluated before the next one is started.'
  prefs: []
  type: TYPE_NORMAL
- en: In C++20, a new function, called `std::make_unique_for_overwrite()`, has been
    added. This is similar to `make_unique()` except that its default initializes
    the object or the array of objects. This function can be used in generic code
    where it’s unknown whether the type template parameter is trivially copyable or
    not. This function expresses the intent to create a pointer to an object that
    may not be initialized so that it should be overwritten later.
  prefs: []
  type: TYPE_NORMAL
- en: Constant `std::unique_ptr` objects cannot transfer the ownership of a managed
    object or array to another `std::unique_ptr` object. On the other hand, access
    to the raw pointer to the managed object can be obtained with either `get()` or
    `release()`. The first method only returns the underlying pointer, but the latter
    also releases the ownership of the managed object, hence the name. After a call
    to `release()`, the `std::unique_ptr` object will be empty and a call to `get()`
    will return `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `std::unique_ptr` that manages the object of a `Derived` class can be implicitly
    converted to a `std::unique_ptr` that manages an object of the class `Base` if
    `Derived` is derived from `Base`. This implicit conversion is safe only if `Base`
    has a virtual destructor (as all base classes should have); otherwise, undefined
    behavior is employed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from running this snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '`std::unique_ptr` can be stored in containers, such as `std::vector`. Because
    only one `std::unique_ptr` object can own the managed object at any point, the
    smart pointer cannot be copied to the container; it has to be moved. This is possible
    with `std::move()`, which performs a `static_cast` to an rvalue reference type.
    This allows the ownership of the managed object to be transferred to the `std::unique_ptr`
    object that is created in the container.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using shared_ptr to share a memory resource*, to learn about the `std::shared_ptr`
    class, which represents a smart pointer that shares ownership of an object or
    array of objects allocated on the heap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shared_ptr to share a memory resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing dynamically allocated objects or arrays with `std::unique_ptr` is not
    possible when the object or array has to be shared. This is because a `std::unique_ptr`
    retains its sole ownership. The C++ standard provides another smart pointer, called
    `std::shared_ptr`; it is similar to `std::unique_ptr` in many ways, but the difference
    is that it can share the ownership of an object or array with other `std::shared_ptr`
    objects. In this recipe, we will see how `std::shared_ptr` works and how it differs
    from `std::uniqueu_ptr`. We will also look at `std::weak_ptr`, which is a non-resource-owning
    smart pointer that holds a reference to an object managed by a `std::shared_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you read the previous recipe, *Using unique_ptr to uniquely own a
    memory resource*, to become familiar with how `unique_ptr` and `make_unique()`
    work. We will use the `foo`, `foo_deleter`, `Base`, and `Derived` classes defined
    in this recipe, and also make several references to it.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `shared_ptr` and `weak_ptr` classes, as well as the `make_shared()`
    function template, are available in the `std` namespace in the `<memory>` header.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity and readability, we will not use the fully qualified names `std::unique_ptr`,
    `std::shared_ptr`, and `std::weak_ptr` in this recipe, but `unique_ptr`, `shared_ptr`,
    and `weak_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of the typical operations you need to be aware of when
    working with `shared_ptr` and `weak_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use one of the available overloaded constructors to create a `shared_ptr` that
    manages an object through a pointer. The default constructor creates an empty
    `shared_ptr`, which does not manage any object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, use the `std::make_shared()` function template, available since
    C++11, to create `shared_ptr` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `std::make_shared_for_overwrite()` function template, available in
    C++20, to create `shared_ptr`s to objects or arrays of objects that are default
    initialized. These objects should later be overwritten with a determined value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the overloaded constructor, which takes a custom deleter if the default
    delete operation is not appropriate for destroying the managed object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Always specify a deleter when managing an array of objects. The deleter can
    either be a partial specialization of `std::default_delete` for arrays or any
    function that takes a pointer to the template type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To access the raw pointer to the managed object, use the `get()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dereference the pointer to the managed object using `operator*` and `operator->`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a `shared_ptr` manages an array of objects, `operator[]` can be used to
    access the individual elements of the array. This is only available in C++17:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether a `shared_ptr` could manage an object or not, use the explicit
    operator `bool` or check whether `get() != nullptr` (which is what the operator
    `bool` does):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`shared_ptr` objects can be stored in containers, such as `std::vector`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `weak_ptr` to maintain a non-owning reference to a shared object, which
    can be later accessed through a `shared_ptr` constructed from the `weak_ptr` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `std::enable_shared_from_this` class template as the base class for
    a type when you need to create `shared_ptr` objects for instances that are already
    managed by another `shared_ptr` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`shared_ptr` is very similar to `unique_ptr` in many aspects; however, it serves
    a different purpose: sharing the ownership of an object or array. Two or more
    `shared_ptr` smart pointers can manage the same dynamically allocated object or
    array, which is automatically destroyed when the last smart pointer goes out of
    scope, is assigned a new pointer with `operator=`, or is reset with the method
    `reset()`. By default, the object is destroyed with `operator delete`; however,
    the user could supply a custom deleter to the constructor, something that is not
    possible using `std::make_shared()`. If `shared_ptr` is used to manage an array
    of objects, a custom deleter must be supplied. In this case, you can use `std::default_delete<T[]>`,
    which is a partial specialization of the `std::default_delete` class template
    that uses `operator delete[]` to delete the dynamically allocated array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The utility function `std::make_shared()` (available since C++11), unlike `std::make_unique()`,
    which has only been available since C++14, should be used to create smart pointers
    unless you need to provide a custom deleter. The primary reason for this is the
    same as for `make_unique()`: avoiding potential memory leaks in some contexts
    when an exception is thrown. For more information on this, read the explanation
    provided on `std::make_unique()` in the previous recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: In C++20, a new function, called `std::make_shared_for_overwrite()`, has been
    added. This is similar to `make_shared()` except that it default initializes the
    object or the array of objects. This function can be used in generic code where
    it’s unknown whether the type template parameter is trivially copyable or not.
    This function expresses the intent to create a pointer to an object that may not
    be initialized so that it should be overwritten later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as in the case of `unique_ptr`, a `shared_ptr` that manages an object
    of a `Derived` class can be implicitly converted to a `shared_ptr` that manages
    an object of the `Base` class. This is possible if the `Derived` class is derived
    from `Base`. This implicit conversion is safe only if `Base` has a virtual destructor
    (as all the base classes should have when objects are supposed to be deleted polymorphically
    through a pointer or reference to the base class); otherwise, undefined behavior
    is employed. In C++17, several new non-member functions have been added: `std::static_pointer_cast()`,
    `std::dynamic_pointer_cast()`, `std::const_pointer_cast()`, and `std::reinterpret_pointer_cast()`.
    These apply `static_cast`, `dynamic_cast`, `const_cast`, and `reinterpret_cast`
    to the stored pointer, returning a new `shared_ptr` to the designated type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `Base` and `Derived` are the same classes we used
    in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: There are situations when you need a smart pointer for a shared object but without
    it contributing to the shared ownership. Suppose you model a tree structure where
    a node has references to its children and they are represented by `shared_ptr`
    objects. On the other hand, say a node needs to keep a reference to its parent.
    If this reference were also `shared_ptr`, then it would create circular references
    and no object would ever be automatically destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: '`weak_ptr` is a smart pointer that’s used to break such circular dependencies.
    It holds a non-owning reference to an object or array managed by a `shared_ptr`.
    `weak_ptr` can be created from a `shared_ptr` object. In order to access the managed
    object, you need to get a temporary `shared_ptr` object. To do so, we need to
    use the `lock()` method. This method atomically checks whether the referred object
    still exists and returns either an empty `shared_ptr`, if the object no longer
    exists, or a `shared_ptr` that owns the object, if it still exists. Because `weak_ptr`
    is a non-owning smart pointer, the referred object can be destroyed before `weak_ptr`
    goes out of scope or when all the owning `shared_ptr` objects have been destroyed,
    reset, or assigned to other pointers. The method `expired()` can be used to check
    whether the referenced object has been destroyed or is still available.'
  prefs: []
  type: TYPE_NORMAL
- en: In the *How to do it...* section, the preceding example models a master-apprentice
    relationship. There is a `Master` class and an `Apprentice` class. The `Master`
    class has a reference to an `Apprentice` class and a method called `take_apprentice()`
    to set the `Apprentice` object. The `Apprentice` class has a reference to a `Master`
    class and the method `take_master()` to set the `Master` object. In order to avoid
    circular dependencies, one of these references must be represented by a `weak_ptr`.
    In the proposed example, the `Master` class had a `shared_ptr` to own the `Apprentice`
    object, and the `Apprentice` class had a `weak_ptr` to track a reference to the
    `Master` object. This example, however, is a bit more complex because here, the
    `Apprentice::take_master()` method is called from `Master::take_apprentice()`
    and needs a `weak_ptr<Master>`. In order to call it from within the `Master` class,
    we must be able to create a `shared_ptr<Master>` in the `Master` class, using
    the `this` pointer. The only way to do this in a safe manner is to use `std::enable_shared_from_this`.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::enable_shared_from_this` is a class template that must be used as a base
    class for all the classes where you need to create a `shared_ptr` for the current
    object (the `this` pointer) when this object is already managed by another `shared_ptr`.
    Its type template parameter must be the class that derives from it, as in the
    curiously recurring template pattern. It has two methods: `shared_from_this()`,
    which returns a `shared_ptr`, which shares the ownership of the `this` object,
    and `weak_from_this()`, which returns a `weak_ptr`, which shares a non-owning
    reference to the `this` object. The latter method is only available in C++17\.
    These methods can be called only on an object that is managed by an existing `shared_ptr`;
    otherwise, they throw a `std::bad_weak_ptr` exception, as of C++17\. Prior to
    C++17, the behavior was undefined.'
  prefs: []
  type: TYPE_NORMAL
- en: Not using `std::enable_shared_from_this` and creating a `shared_ptr<T>(this)`
    directly would lead to having multiple `shared_ptr` objects managing the same
    object independently, without knowing each other. When this happens, the object
    ends up being destroyed multiple times by different `shared_ptr` objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using unique_ptr to uniquely own a memory resource*, to learn about the `std::unique_ptr`
    class, which represents a smart pointer that owns and manages another object or
    array of objects allocated on the heap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistent comparison with the operator <=>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ language defines six relational operators that perform comparison:
    `==`, `!=`, `<`, `<=`, `>`, and `>=`. Although `!=` can be implemented in terms
    of `==`, and `<=`, `>=`, and `>` in terms of `<`, you still have to implement
    both `==` and `!=` if you want your user-defined type to support equality comparison,
    and `<`, `<=`, `>`, and `>=` if you want it to support ordering.'
  prefs: []
  type: TYPE_NORMAL
- en: That means 6 functions if you want objects of your type—let’s call it `T`—to
    be comparable, 12 if you want them to be comparable with another type, `U`, 18
    if you also want values of a `U` type to be comparable with your `T` type, and
    so on. The new C++20 standard reduces this number to either one or two, or multiple
    of these (depending on the comparison with other types) by introducing a new comparison
    operator, called *the three-way comparison*, which is designated with the symbol
    `<=>`, for which reason it is popularly known as the *spaceship operator*. This
    new operator helps us write less code, better describe the strength of relations,
    and avoid possible performance issues that come from manually implementing comparison
    operators in terms of others.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is necessary to include the header `<compare>` when defining or implementing
    the three-way comparison operator. This new C++20 header is part of the standard
    general utility library and provides classes, functions, and concepts for implementing
    comparison.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To optimally implement comparison in C++20, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only want your type to support equality comparison (both `==` and `!=`),
    implement only the `==` operator and return a `bool`. You can default the implementation
    so that the compiler performs a member-wise comparison:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want your type to support both equality and ordering and the default
    member-wise comparison will do, then only define the `<=>` operator, returning
    `auto`, and default its implementation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want your type to support both equality and ordering and you need to
    perform custom comparison, then implement both the `==` operator (for equality)
    and the `<=>` operator (for ordering):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When implementing the three-way comparison operator, follow these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Only implement the three-way comparison operator but always use the two-way
    comparison operators `<`, `<=`, `>`, and `>=` when comparing values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the three-way comparison operator as a member function, even if you
    want the first operand of a comparison to be of a type other than your class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the three-way comparison operator as non-member functions only if
    you want implicit conversion on both arguments (that means comparing two objects,
    neither of which is of your class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new three-way comparison operator is similar to the `memcmp()`/`strcmp()`
    C functions and the `std::string::compare()` method. These functions take two
    arguments and return an integer value that is smaller than zero if the first is
    less than the second, zero if they are equal, or greater than zero if the first
    argument is greater than the second. The three-way comparison operator does not
    return an integer but a value of a comparison category type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::strong_ordering` represents the result of a three-way comparison that
    supports all six relational operators, does not allow incomparable values (which
    means that at least one of `a < b`, `a == b`, and `a > b` must be true), and implies
    substitutability. This is a property such that if `a == b` and `f` is a function
    that reads only comparison-salient state (accessible via the argument’s public
    constant members), then `f(a) == f(b)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::weak_ordering` supports all the six relational operators, does not support
    incomparable values (which means that none of `a < b`, `a == b`, and `a > b` could
    be true), but also does not imply substitutability. A typical example of a type
    that defines weak ordering is a case-insensitive string type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::partial_ordering` supports all six relational operators but does not
    imply substitutability and has a value that might not be comparable (for instance,
    a floating-point `NaN` cannot be compared to any other value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `std::strong_ordering` type is the strongest of all these category types.
    It is not implicitly convertible from any other category, but it implicitly converts
    to both `std::weak_ordering` and `std::partial_ordering`. `std::weak_ordering`
    is also implicitly convertible to `std::partial_ordering`. We’ve summarized all
    these properties in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Operators** | **Substitutability** | **Comparable values**
    | **Implicit conversion** |'
  prefs: []
  type: TYPE_TB
- en: '| `std::strong_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | Yes | Yes | ![](img/B21549_09_001.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `std::weak_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | No | Yes | ![](img/B21549_09_001.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `std::partial_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | No | No |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.2: Properties of the category types'
  prefs: []
  type: TYPE_NORMAL
- en: 'These comparison categories have values that are implicitly comparable with
    literal zero (but not with an integer variable that is zero). Their values are
    listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Numeric values** | **Non-numeric values** |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `strong_ordering` | less | equalequivalent | greater |  |'
  prefs: []
  type: TYPE_TB
- en: '| `weak_ordering` | less | equivalent | greater |  |'
  prefs: []
  type: TYPE_TB
- en: '| `partial_ordering` | less | equivalent | greater | unordered |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.3: The values of the comparison categories that are implicitly comparable
    to literal zero'
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how this works, let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `cost_unit_t` is a base class that contains some (unspecified) data members
    and defines the `<=>` operator, although it is default-implemented by the compiler.
    This means that the compiler will also provide the `==` and `!=` operators, not
    just `<`, `<=`, `>`, and `>=`. This class is derived by `project_t`, which contains
    several data fields: an identifier for the project, a type, and a name. However,
    for this type, we cannot default the implementation of the operators, because
    we do not want to compare the fields member-wise, but in a custom order: first
    the name, then the type, and lastly the identifier. In this case, we implement
    both the `==` operator, which returns a `bool` and tests the member fields for
    equality, and the `<=>` operator, which returns `std::strong_ordering` and uses
    the `<=>` operator itself to compare the values of its two arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The methods `is_same()`, `is_manager_of()`, and `is_managed_by()` return the
    relationship of two employees. However, it is possible there are employees with
    no relationship; for instance, employees in different teams, or a team without
    a manager-subordinate structure. Here, we can implement equality and ordering.
    However, since we cannot compare all employees with each other, the `<=>` operator
    must return a `std::partial_ordering` value. The return value is `partial_ordering::equivalent`
    if the values represent the same employee, `partial_ordering::less` if the current
    employee is managed by the supplied one, `partial_ordering::greater` if the current
    employee is the manager of the supplied one, and `partial_ordering::unorder` in
    all other cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see one more example to understand how the three-way comparison operator
    works. In the following sample, the `ipv4` class models an IP version 4 address.
    It supports comparison with both other objects of the `ipv4` type but also `unsigned
    long` values (because there is a `to_unlong()` method that converts the IP address
    into a 32-bit unsigned integral value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we overloaded the `<=>` operator and allowed it to be default
    implemented. But we also explicitly implemented overloads for `operator==` and
    `operator<=>`, which compare an `ipv4` object with an `unsigned long` value. Because
    of these operators, we can write any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to notice here: the first is that although we only overloaded
    the `==` operator, we can also use the `!=` operator, and second, although we
    overloaded the `==` operator and the `<=>` operator to compare `ipv4` values to
    `unsigned long` values, we can also compare `unsigned long` values to `ipv4` values.
    This is because the compiler performs symmetrical overload resolution. That means
    that for an expression `a@b` where `@` is a two-way relational operator, it performs
    name lookup for `a@b`, `a<=>b`, and `b<=>a`. The following table shows the list
    of all possible transformations of the relational operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `a == b` | `b == a` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `a != b` | `!(a == b)` | `!(b == a)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a <=> b` | `0 <=> (b <=> a)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `a < b` | `(a <=> b) < 0` | `0 > (b <=> a)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a <= b` | `(a <=> b) <= 0` | `0 >= (b <=> a)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a > b` | `(a <=> b) > 0` | `0 < (b <=> a)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a >= b` | `(a <=> b) >= 0` | `0 <= (b <=> a)` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.4: The possible transformations of the relational operators'
  prefs: []
  type: TYPE_NORMAL
- en: This greatly reduces the number of overloads you must explicitly provide for
    supporting comparison in different forms. The three-way comparison operator can
    be implemented either as a member or as a non-member function. In general, you
    should prefer the member implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The non-member form should be used only when you want implicit conversion on
    both arguments. The following shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Although the `<=>` operator is defined for the type `B`, because it is a non-member
    and because `A` can be implicitly converted to `B`, we can perform a comparison
    on objects of the `A` type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Simplifying code with class template argument deduction*, to
    learn how to use class templates without explicitly specifying template arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing signed and unsigned integers safely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ language features a variety of integral types: `short`, `int`, `long`,
    and `long long`, as well as their unsigned counterparts `unsigned short`, `unsigned
    int`, `unsigned long`, and `unsigned long long`. In C++11, fixed-width integer
    types were introduced, such as `int32_t` and `uint32_t`, and many similar others.
    Apart from these, there are also the types `char`, `signed char`, `unsigned char`,
    `wchar_t`, `char8_t`, `char16_t`, and `char32_t`, although these are not supposed
    to store numbers but characters. Moreover, the type `bool` used for storing the
    values `true` or `false` is also an integral type. The comparison of values of
    these types is a common operation but comparing signed and unsigned values is
    error-prone. Without some compiler-specific switches to flag these as warnings
    or errors, you can perform these operations and get unexpected results. For instance,
    the comparison `-1 < 42u` (comparing signed -1 with unsigned 42) would yield `false`.
    The C++20 standard provides a set of functions for performing a safe comparison
    of signed and unsigned values, which we will learn about in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform a safe comparison of signed and unsigned integer values that ensures
    negative signed integers always compare less than unsigned values, use one of
    the following comparison functions from the `<utility>` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Corresponding comparison operator** |'
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_equal` | `==` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_not_equal` | `!=` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_less` | `<` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_less_equal` | `<=` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_greater` | `>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::cmp_greater_equal` | `>=` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.5: New C++20 comparison functions and their corresponding comparison
    operator'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comparing two signed or two unsigned values is straightforward but comparing
    a signed and unsigned integer is error prone. When such a comparison occurs, the
    signed value is converted to unsigned. For instance, integer -1 becomes 4294967295\.
    The reason for this is that signed numbers are stored in memory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most significant bit indicates the sign: 0 for positive numbers and 1 for
    negative ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Negative values are stored by inverting the bits of the positive number and
    adding 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This representation is known as the **two’s complement**. For instance, assuming
    an 8-bit signed representation, value 1 is stored as `0000001`, but the value
    -1 is stored as `11111111`. This is because the 7 least significant bits of the
    positive number are `0000001`, which inverted are `1111110`. By adding 1, we get
    `1111111`. Together with the sign bit this makes `11111111`. For 32-bit signed
    integers, the value -1 is stored as `11111111'11111111'11111111'11111111`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'This is true for all the six equality (`==`, `!=`) and inequality (`<`, `<=`,
    `>`, `>=`) operators. To get the correct result, we need to check whether the
    signed values are negative. The correct condition for the `if` statement shown
    previously is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: To ease the writing of such expressions, the C++20 standard has introduced the
    six functions listed in *Table 9.5* that should be used as replacements for the
    corresponding operator when comparing signed and unsigned integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible implementation for the `std::cmp_less()` function is shown in the
    next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'What this does is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If both arguments are signed, it uses the built-in `<` comparison operator to
    compare them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the first argument is signed and the second is unsigned, then it checks whether
    the first is native (a negative value is always less than a positive one) or compares
    the first argument cast to unsigned with the second argument using the built-in
    operator `<`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the first argument is unsigned, the second can be either signed or unsigned.
    The first argument can only be less than the second if the second is positive
    and the first is less than the second cast as unsigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you use these functions, keep in mind that they only work for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`short`, `int`, `long`, `long long`, and their unsigned counterparts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed-width integer types such as `int32_t`, `int_least32_t`, `int_fast32_t`
    and their unsigned counterparts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended integer types (which are compiler-specific types such as `__int64`
    or `__int128` and their unsigned counterparts that most compilers support)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next snippet provides an example for using extended types (in this case
    Microsoft specific) and standard fixed with integer types, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you cannot use them to compare enums, `std::byte`, `char`, `char8_t`,
    `char16_t`, `char32_t`, `wchar_t`, and `bool`. In this case, you would get a compiler
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 2*, *Understanding the various numeric types*, to learn about the
    available integral and floating-point types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performing correct type casts*, to learn the proper way of performing type
    casts in C++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_09.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2659294082093549796.png)'
  prefs: []
  type: TYPE_IMG
