- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vulkan Core Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal for this chapter is to implement a simple program that displays a shaded
    triangle on screen, with the triangle’s vertices and attributes being sourced
    directly from the shaders. In the process of implementing the code to render this
    triangle, we will cover most of Vulkan’s fundamental objects, the ones you need
    to create a very simple application. Although the code required for this minimal
    example is extensive, the majority of it can be reused and tweaked for other applications.
    By the end of the chapter, you will know how to bootstrap communication with the
    driver, how to create and manage basic Vulkan objects, and how to issue rendering
    commands to the GPU.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, following a brief introduction to the Vulkan API, we will
    cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Calling API functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Vulkan objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Volk to load Vulkan functions and extensions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vulkan extensions correctly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Validation Layer for error checking
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating available instance layers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating available instance extensions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the Vulkan instance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a surface
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating Vulkan physical devices
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching the properties of queue families
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating physical device extensions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserving queue families
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Vulkan logical device
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the queue object handle
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a command pool
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating, recording, and submitting commands
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing command buffers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating render passes
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating framebuffers
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating image views
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vulkan graphics pipeline
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling shaders to SPIR-V
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic states
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a graphics pipeline
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapchain
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding synchronization in the swapchain – fences and semaphores
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populating submission information for presentation
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting images
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a triangle
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To successfully run the code featured in this and rest of chapters, your system
    must meet the following requirements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: A Windows computer equipped with a GPU that supports Vulkan 1.3\. We recommend
    having a machine with at least 16 GB of RAM and a modern graphics card. The code
    for various chapters was tested with GTX 1080, GTX 1060, RTX 3050, and RTX 4060\.
    Please note that [*Chapter 7*](B18491_07.xhtml#_idTextAnchor299)*, Ray Tracing
    and Hybrid Rendering*, requires RTX 3050/4060 series card since it demonstrates
    use of ray tracing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and Install Vulkan SDK 1.3.268: Visit the LunarG website at [https://sdk.lunarg.com/sdk/download/1.3.268.0/windows/VulkanSDK-1.3.268.0-Installer.exe](https://sdk.lunarg.com/sdk/download/1.3.268.0/windows/VulkanSDK-1.3.268.0-Installer.exe)
    and download the Vulkan SDK 1.3.268 installer. Run the installer to complete the
    installation process.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install Python 3.12: Download the latest version of Python 3.12 from the official
    Python website and follow the installation instructions provided.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone the Repository: Ensure you have Git installed on your computer. If not,
    download and install Git from [https://git-scm.com/downloads](https://git-scm.com/downloads).
    Once Git is installed, open a command prompt or terminal and execute git clone
    [https://github.com/PacktPublishing/The-Modern-Vulkan-Cookbook](https://github.com/PacktPublishing/The-Modern-Vulkan-Cookbook)
    to clone the repository.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆仓库：确保你的计算机上已安装 Git。如果没有，请从 [https://git-scm.com/downloads](https://git-scm.com/downloads)
    下载并安装 Git。安装 Git 后，打开命令提示符或终端，并执行 git clone [https://github.com/PacktPublishing/The-Modern-Vulkan-Cookbook](https://github.com/PacktPublishing/The-Modern-Vulkan-Cookbook)
    以克隆仓库。
- en: 'Open the Project in Visual Studio 2022: Launch Visual Studio 2022\. Navigate
    to **File** | **Open** | **Folder** and select the folder where you cloned the
    repository. This action will load the project into Visual Studio.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2022 中打开项目：启动 Visual Studio 2022。导航到 **文件** | **打开** | **文件夹**
    并选择你克隆的仓库所在的文件夹。此操作将项目加载到 Visual Studio 中。
- en: 'Build the Project: Within Visual Studio, you can choose to build the project
    for debugging or release. For learning purposes and when making changes to the
    code, it’s recommended to use the **Debug** build configuration. This allows you
    to step through the code and understand its execution flow. For simply running
    the executables, you can use the **Release** build configuration.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目：在 Visual Studio 中，你可以选择为调试或发布构建项目。出于学习和修改代码的目的，建议使用 **调试** 构建配置。这允许你逐步执行代码并理解其执行流程。如果要简单地运行可执行文件，可以使用
    **发布** 构建配置。
- en: 'The project is structured to facilitate easy navigation and understanding of
    the code examples provided in each chapter. Here’s a detailed guide on how to
    locate and work with the code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构旨在方便导航和理解每章提供的代码示例。以下是如何定位和使用代码的详细指南：
- en: 'The project is organized into several key directories, each serving a specific
    purpose:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 项目组织成几个关键目录，每个目录都服务于特定的目的：
- en: '`source/chapterX`: This directory contains the main source code for each chapter.
    Replace X with the chapter number you are working on. For example, the source
    code for this chapter is located in `source/chapter1`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source/chapterX`: 此目录包含每章的主要源代码。将 X 替换为你正在工作的章节编号。例如，本章的源代码位于 `source/chapter1`。'
- en: '`source/vulkancore`: This directory is dedicated to the Vulkan specific code
    and components. It includes utilities, wrappers, and other Vulkan related functionalities
    that are used throughout the project.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source/vulkancore`: 此目录专门用于存放与 Vulkan 相关的代码和组件。它包括工具、包装器以及其他在整个项目中使用的 Vulkan
    相关功能。'
- en: '`source/enginecore`: This directory houses the core engine components that
    are shared across multiple chapters. These components provide foundational functionality
    that is reused in various parts of the project.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source/enginecore`: 此目录包含多个章节共享的核心引擎组件。这些组件提供基础功能，在项目的各个部分被重复使用。'
- en: The recipe for this chapter can be run by launching `Chapter01_Traingle.exe`
    executable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动 `Chapter01_Traingle.exe` 可执行文件来运行本章的配方。
- en: Getting to know the Vulkan API
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Vulkan API
- en: The Vulkan API, introduced in 2016 by the Khronos Group, is a low-overhead,
    cross-platform computing API that is the successor to OpenGL and its variants
    (WebGL and OpenGL ES). In fact, Vulkan was called **Next Generation OpenGL** (or
    **glNext**) before it was officially named Vulkan. OpenGL has been around since
    1992 and it was the de facto introductory graphics API everyone learned (and learns
    still today). Allied with its simplicity, OpenGL is ubiquitous even today.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan API 由 Khronos Group 于 2016 年推出，是一个低开销、跨平台的计算 API，是 OpenGL 及其变体（WebGL
    和 OpenGL ES）的后继者。实际上，在正式命名为 Vulkan 之前，Vulkan 被称为 **下一代 OpenGL**（或 **glNext**）。OpenGL
    自 1992 年以来一直存在，并且一直是每个人学习（并且至今仍在学习）的事实上的入门级图形 API。与它的简单性相结合，OpenGL 即使在今天也非常普遍。
- en: So, how is Vulkan different from OpenGL? It starts with its complexity. Vulkan
    is intended to provide application authors more control over the graphics hardware
    so that they can implement a solution that caters to their needs. Applications
    can implement solutions as simple as they want or as complex as they need. In
    practice, this means that the application is now responsible for controlling the
    hardware, making it more complex. The drivers, on the other hand, became simpler.
    For instance, if an application is really concerned about resource management,
    it can implement its own resource management algorithms and not rely on the driver’s
    implementation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Vulkan 与 OpenGL 有何不同？它始于其复杂性。Vulkan 的目的是为应用程序作者提供对图形硬件的更多控制，以便他们可以实施满足其需求的解决方案。应用程序可以实现尽可能简单或尽可能复杂的解决方案。在实践中，这意味着应用程序现在负责控制硬件，这使得它更加复杂。另一方面，驱动程序变得简单。例如，如果一个应用程序非常关注资源管理，它可以实现自己的资源管理算法，而不依赖于驱动程序的实现。
- en: In short, Vulkan offers more fine-grained control over the GPU compared to OpenGL
    due to its *lower-level* nature. It empowers applications to handle tasks that
    were traditionally managed by graphics drivers, such as initiating communication
    between the application and the hardware. However, this increased control comes
    with added complexity. Vulkan abstracts a large part of the GPU-specific implementation,
    allowing the same code to run on a wide range of GPUs. While it is possible to
    use device-specific extensions to maximize the computation potential of a particular
    GPU, these are not necessities but optional choices to optimize performance. In
    both desktop and mobile environments, managing this complexity to make optimal
    use of the GPU can be challenging due to the vast array of possibilities.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，由于 Vulkan 的底层特性，与 OpenGL 相比，它对 GPU 的控制更加精细。它赋予应用程序处理传统上由图形驱动程序管理的任务的能力，例如启动应用程序与硬件之间的通信。然而，这种增加的控制也带来了额外的复杂性。Vulkan
    抽象了 GPU 特定实现的大部分内容，使得相同的代码可以在广泛的 GPU 上运行。虽然可以使用特定于设备的扩展来最大化特定 GPU 的计算潜力，但这些不是必需的，而是优化性能的可选选择。在桌面和移动环境中，由于可能性众多，管理这种复杂性以充分利用
    GPU 可能具有挑战性。
- en: Calling API functions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 API 函数
- en: Due to the many knobs Vulkan provides to control every little thing that the
    hardware can do, Vulkan tends to be more verbose than OpenGL. Since the control
    of every single aspect of the rendering process is now exposed to the application,
    there is simply more information that needs to be communicated with the graphics
    driver (mind you, the graphics driver still exists; it’s just simpler than it
    used to be).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Vulkan 提供了众多旋钮来控制硬件可以做的每一件小事，因此 Vulkan 通常比 OpenGL 更冗长。由于渲染过程的每个方面现在都暴露给应用程序，因此需要与图形驱动程序（请注意，图形驱动程序仍然存在；它只是比以前简单）通信的信息更多。
- en: The most prominent pattern used by the Vulkan API is structure-as-parameter.
    It is used for creating and allocating objects, querying their capabilities and
    information, describing layouts, and much more. In this pattern, instead of passing
    all possible values for the creation of an object as parameters of a function,
    you must stick all that information in a structure provided by the Vulkan SDK
    and then pass that structure as a parameter to the function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan API 使用的最显著模式是结构体作为参数。它用于创建和分配对象、查询其功能和信息、描述布局以及更多。在这个模式中，您不需要将创建对象所需的所有可能值作为函数的参数传递，而是将所有这些信息放入由
    Vulkan SDK 提供的结构体中，然后将该结构体作为参数传递给函数。
- en: In this recipe, you will learn how Vulkan functions are expected to be called
    and how to check their return value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何调用 Vulkan 函数以及如何检查它们的返回值。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Creating objects in Vulkan requires you to fill an instance of a special structure
    (there’s one for each object you would like to create) and pass it to the creation
    function, which takes a pointer to a variable that will store the object’s handle
    upon return. Most functions in the API return a result that can be used to detect
    errors, and it’s usually a very good idea to do so to catch errors as soon as
    possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中创建对象需要您填充一个特殊结构体的实例（每个要创建的对象都有一个），并将其传递给创建函数，该函数接收一个指向变量的指针，该变量将在返回时存储对象的句柄。API
    中的大多数函数返回一个结果，可以用来检测错误，通常这是一个非常好的主意，以便尽快捕获错误。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: This recipe will show how to create a Vulkan sampler (`VkSampler`) by calling
    the `vkCreateSampler` function and how you can create a macro that can be used
    to check the return value of Vulkan function calls without repeating the same
    code over and over again.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将展示如何通过调用`vkCreateSampler`函数创建一个Vulkan采样器（`VkSampler`），以及如何创建一个宏，可以用来检查Vulkan函数调用的返回值，而无需重复相同的代码。
- en: The following code demonstrates how to create a `VkSampler` sampler, a Vulkan
    object that dictates how a texture is sampled in a shader.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码演示了如何创建一个`VkSampler`采样器，这是一个Vulkan对象，它决定了在着色器中如何采样纹理。
- en: Before calling the `vkCreateSampler` function that creates the sampler, you
    need to fill a structure called `VkSamplerCreateInfo` with all the parameters
    you’d like the new sampler to have.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用创建采样器的`vkCreateSampler`函数之前，你需要填充一个名为`VkSamplerCreateInfo`的结构，其中包含你希望新采样器拥有的所有参数。
- en: 'In the example, we are setting its minification and magnification filter types,
    how the texture coordinates are treated before sampling the texture, and everything
    else that Vulkan allows to be controlled in an object of this type:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在示例中，我们正在设置其缩小和放大过滤器类型，纹理坐标在采样纹理之前的处理方式，以及Vulkan允许在此类型对象中控制的其它一切：
- en: '[PRE0]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The last thing to notice about the listing is that while creating objects in
    Vulkan, the handle to the object is not returned from the function but is stored
    in a pointer passed to the function. In our preceding example, the handle to the
    new sampler will be stored in the variable sampler (the last parameter to the
    `vkCreateSampler` function). That’s why we’re passing the address of the local
    variable to the function.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于列表的最后一件事是，在Vulkan中创建对象时，对象的句柄不是从函数返回，而是存储在传递给函数的指针中。在我们的前一个例子中，新采样器的句柄将被存储在变量`sampler`（`vkCreateSampler`函数的最后一个参数）中。这就是为什么我们要将局部变量的地址传递给函数的原因。
- en: The reason for that is that most functions in the API return a result denoting
    whether the operation was successful or not. In most cases, checking the return
    value, of type `VkResult`, against `VK_SUCCESS` is fine (and displaying a message
    on screen or terminating), but in a few cases, the result may not represent an
    irrecoverable error but a situation that needs to be rectified before we can continue.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原因是API中的大多数函数返回一个表示操作是否成功的结果。在大多数情况下，将返回值（类型为`VkResult`）与`VK_SUCCESS`进行比较就足够了（并在屏幕上显示消息或终止），但在少数情况下，结果可能并不代表不可恢复的错误，而是一种在我们继续之前需要纠正的情况。
- en: 'This pattern is so common that we use a simple utility macro that checks the
    return value. If the result is anything different than `VK_SUCCESS`, it prints
    a message, along with the stringified error code, and asserts. Check it out:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种模式非常常见，以至于我们使用了一个简单的实用宏来检查返回值。如果结果不是`VK_SUCCESS`，它会打印一条消息，包括字符串化的错误代码，并断言。查看一下：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Vulkan objects are created almost always the same way: by providing their attributes
    in a structure, calling a `create` function, and providing a pointer to store
    the handle to the newly created object. Most functions return a `VkResult` value
    that can be used to check whether the function succeeded or not.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan对象几乎总是以相同的方式创建：通过在结构中提供它们的属性，调用一个`create`函数，并提供一个指针来存储新创建对象的句柄。大多数函数返回一个`VkResult`值，可以用来检查函数是否成功。
- en: Learning about Vulkan objects
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关于Vulkan对象
- en: The Vulkan API is extensive and many times larger than OpenGL (in any way you’d
    like to measure). Nonetheless, only a handful of very important objects are necessary
    to write many types of applications. As mentioned at the beginning of this chapter,
    the Vulkan API was leveled against the most demanding applications, those that
    need to control every single minute detail of the hardware to extract the maximum
    performance. But most applications don’t need all that flexibility and can get
    by with just the *basics*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan API非常广泛，很多时候比OpenGL（以任何你想测量的方式）都要大。尽管如此，只有少数非常重要的对象对于编写许多类型的应用程序是必要的。如本章开头所述，Vulkan
    API是为了应对最苛刻的应用程序而设计的，那些需要控制硬件的每一个细节以提取最大性能的应用程序。但大多数应用程序不需要所有那种灵活性，只需要*基础*即可。
- en: In this recipe, you will learn what Vulkan objects are and how they relate to
    each other.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解Vulkan对象是什么以及它们是如何相互关联的。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Objects in Vulkan are opaque handles, and their types begin with the letters
    `Vk`. A Vulkan instance is called `VkInstance`, a Vulkan device is called `VkDevice`,
    and so on. Some objects need an instance of other objects to be created or allocated
    from. This dependency creates an implicit logical sequence as to object creation.
    A Vulkan physical device, `VkPhysicalDevice`, which represents a GPU on the system,
    can only be created if a Vulkan instance, `VkInstance`, already exists. The next
    section will present a diagram that may be helpful in understanding Vulkan’s capabilities
    and *when* objects may be created.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan中的对象是不透明的句柄，它们的类型以字母`Vk`开头。一个Vulkan实例称为`VkInstance`，一个Vulkan设备称为`VkDevice`，依此类推。一些对象需要其他对象的实例来创建或从其分配。这种依赖关系创建了一个隐式的逻辑顺序，即对象创建的顺序。一个代表系统上GPU的Vulkan物理设备`VkPhysicalDevice`，只有在已经存在一个Vulkan实例`VkInstance`的情况下才能创建。下一节将展示一个可能有助于理解Vulkan功能和*何时*可以创建对象的图。
- en: How to do it…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '*Figure 1**.1* is a summary of what we consider the most important objects
    in Vulkan; the ones that we cover in this book and that will satisfy most graphics
    applications. They are also the bare minimum for a simple – but flexible – program.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.1*是我们认为在Vulkan中最重要对象的总结；我们在这本书中涵盖的对象，以及将满足大多数图形应用程序的对象。它们也是简单但灵活程序的最基本要求。'
- en: '![Figure 1.1 – Object dependency in Vulkan](img/B18491_01_01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – Vulkan中的对象依赖关系](img/B18491_01_01.jpg)'
- en: Figure 1.1 – Object dependency in Vulkan
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Vulkan中的对象依赖关系
- en: In the preceding diagram, each node is a Vulkan object with its name on the
    top half and its Vulkan type in the bottom half. The diagram also encodes the
    dependency between the objects, explicit and implicit. The arrows connecting objects
    denote what an object needs to be created (besides their parameters, which are
    not depicted there).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的图中，每个节点都是一个Vulkan对象，其名称位于上半部分，其Vulkan类型位于下半部分。该图还编码了对象之间的依赖关系，显式和隐式。连接对象的箭头表示对象需要创建的内容（除了它们的参数，这些参数没有在图中表示）。
- en: 'Solid arrows are explicit dependencies: an object needs a reference to all
    objects pointed by the arrows leaving its node. For example, a device needs a
    reference to a physical device to be created; a buffer view needs a reference
    to a buffer and the device. Dashed arrows indicate implicit dependencies: a queue
    object needs a reference to a device, but it doesn’t explicitly need a reference
    to a physical device, only a queue index to a family of queues, which is obtained
    from a physical device. It doesn’t need a physical device, but it needs something
    that is provided by one.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实线箭头是显式依赖关系：一个对象需要引用离开其节点的所有由箭头指向的对象。例如，一个设备需要引用物理设备才能创建；缓冲区视图需要引用缓冲区和设备。虚线箭头表示隐式依赖关系：队列对象需要一个对设备的引用，但它不需要显式地引用物理设备，只需要一个队列索引到一个队列族，这个索引是从物理设备获得的。它不需要物理设备，但它需要由物理设备提供的东西。
- en: Solid lines with an open arrow at the end denote objects that are allocated
    from others, generally a pool of those types of objects. A command buffer isn’t
    created; it is allocated from a command pool (which in turn needs to be created
    at some point).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有末端开放箭头的实线表示从其他对象分配的对象，通常是这些类型对象的池。命令缓冲区不是创建的；它是从命令池（反过来，在某个时候需要创建）分配的。
- en: 'This diagram is useful for the beginner because it helps visualize multiple
    dependencies that aren’t exactly obvious. The descriptor set is one of those objects:
    to obtain one, you need a reference to a descriptor set layout. They are not created
    by the application; they are allocated from a descriptor pool. Finally, a descriptor
    set references buffers, image views, and samplers. They are not required, and
    that’s why that type of relation in the diagram represents an optional reference.
    We’ll talk more about descriptor sets in [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*,
    Working with* *Modern Vulkan.*'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此图对初学者很有用，因为它有助于可视化那些并不完全明显的多个依赖关系。描述符集就是那些对象之一：要获得一个描述符集，你需要一个描述符集布局的引用。它们不是由应用程序创建的；它们是从描述符池中分配的。最后，描述符集引用缓冲区、图像视图和采样器。它们不是必需的，这就是为什么图中那种类型的关联表示一个可选引用。我们将在[*第2章*](B18491_02.xhtml#_idTextAnchor126)*，使用现代Vulkan*中更多地讨论描述符集。
- en: In the remainder of this chapter and the next chapter, we will cover the creation
    of all objects in the diagram in the order that they would usually be implemented.
    That means starting at the top with the Vulkan instance and moving downward, fulfilling
    the dependencies represented in the diagram.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分和下一章中，我们将按照通常实现它们的顺序介绍图中所有对象的创建。这意味着从顶部开始，即 Vulkan 实例，然后向下移动，满足图中表示的依赖关系。
- en: Using Volk to load Vulkan functions and extensions
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Volk 加载 Vulkan 函数和扩展
- en: Volk is an open source library created by Arseny Kapoulkine that provides simple
    cross-platform support for loading Vulkan functions. The library provides several
    key features, the most important ones being automatically loading Vulkan’s function
    pointers and providing cross-platform support.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Volk 是由阿列克谢·卡波卢金（Arseny Kapoulkine）创建的开源库，它为加载 Vulkan 函数提供了简单的跨平台支持。该库提供了一些关键特性，其中最重要的包括自动加载
    Vulkan 的函数指针并提供跨平台支持。
- en: In this recipe, you will learn how to use Volk to load Vulkan functions and
    their extensions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何使用 Volk 加载 Vulkan 函数及其扩展。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download Volk from [https://github.com/zeux/volk](https://github.com/zeux/volk)
    and add `volk.c` to your project and enable the preprocessor defines for your
    platform, `VK_USE_PLATFORM_WIN32_KHR`, `VK_USE_PLATFORM_XLIB_KHR`, `VK_USE_PLATFORM_MACOS_MVK`,
    and so on, before including `volk.h`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://github.com/zeux/volk](https://github.com/zeux/volk) 下载 Volk，并将 `volk.c`
    添加到您的项目中，在包含 `volk.h` 之前，启用您平台的预处理器定义，例如 `VK_USE_PLATFORM_WIN32_KHR`、`VK_USE_PLATFORM_XLIB_KHR`、`VK_USE_PLATFORM_MACOS_MVK`
    等。
- en: How to do it…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Volk automatically loads Vulkan’s function pointers, so you don’t have to manually
    handle the details of loading them and checking for available extensions. If you
    use Volk in your application, do not link against the static version of the Vulkan
    library (`VKstatic.1.lib` on Windows) or load the shared library directly (such
    as `vulkan-1.dll` on Windows). Volk will do that for you.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Volk 自动加载 Vulkan 的函数指针，因此您不需要手动处理加载它们的细节以及检查可用的扩展。如果您在您的应用程序中使用 Volk，请不要链接到
    Vulkan 库的静态版本（例如 Windows 上的 `VKstatic.1.lib`）或直接加载共享库（例如 Windows 上的 `vulkan-1.dll`）。Volk
    会为您完成这些操作。
- en: Call `volkInitialize()` during the application’s startup process, before any
    other Vulkan functions are used.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用任何其他 Vulkan 函数之前，在应用程序启动过程中调用 `volkInitialize()`。
- en: Call `volkLoadInstance` after the creation of the Vulkan instance. It replaces
    global function pointers with functions retrieved with `vkGetInstanceProcAddr`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 Vulkan 实例之后调用 `volkLoadInstance`。它用通过 `vkGetInstanceProcAddr` 获取的函数替换全局函数指针。
- en: Call `volkLoadDevice` after the creation of the Vulkan logical device. It replaces
    global function pointers with functions retrieved with `vkGetDeviceProcAddr`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 Vulkan 逻辑设备之后调用 `volkLoadDevice`。它用通过 `vkGetDeviceProcAddr` 获取的函数替换全局函数指针。
- en: Using Vulkan extensions correctly
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确使用 Vulkan 扩展
- en: Vulkan relies heavily on extensions. Extensions are functions and types that
    are part of the *Vulkan Specification*; they are provided in addition to the core
    API but aren’t guaranteed to exist for a particular version of the API. Either
    they are experimental or vendor- and card-specific and are not guaranteed to be
    present, either at compile time or runtime. Official extensions are registered
    with the Khronos Group and are part of the spec, so you can find their documentation
    there.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 严重依赖于扩展。扩展是 *Vulkan 规范* 的一部分，它们除了核心 API 之外还提供，但并不保证在特定版本的 API 中存在。它们可能是实验性的，或者是供应商和卡特定的，并且不能保证在编译时或运行时都存在。官方扩展已在
    Khronos Group 注册，并成为规范的一部分，因此您可以在那里找到它们的文档。
- en: 'Extensions may be introduced to a *Vulkan Specification* version and later
    promoted to the core set of functionalities on a newer version. Or not at all!
    The functionality to present rendering results to a surface (such as a window
    on a GUI), for example, is still an extension even in Vulkan 1.3 (the most recent
    version as of the writing of this book). If you are curious, here’s a link to
    it, the `VK_KHR_surface` device extension: [https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展可能被引入到 *Vulkan 规范* 版本，并在较新版本中提升为核心功能集。或者根本不提升！例如，将渲染结果呈现到表面（如 GUI 上的窗口）的功能，即使在
    Vulkan 1.3（本书撰写时的最新版本）中仍然是一个扩展。如果您对此好奇，这里有一个链接，即 `VK_KHR_surface` 设备扩展：[https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html)。
- en: '*Figure 1**.2* offers a high-level overview of the process:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.2* 提供了该过程的概述：'
- en: '![Figure 1.2 – Vulkan extensions](img/B18491_01_02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – Vulkan 扩展](img/B18491_01_02.jpg)'
- en: Figure 1.2 – Vulkan extensions
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Vulkan 扩展
- en: 'Vulkan version 1.1, for example, contains its core functionality – functions
    and types present in that version – plus extensions. Some, all, or none of those
    extensions may be promoted to the core set of functionalities in Vulkan 1.2\.
    Some might be considered deprecated and removed. The same thing happens when the
    specification is updated to version 1.3: some, all, or none of those extensions
    may be promoted from version 1.2 to the new version, and some might be deprecated.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Vulkan 版本 1.1 包含其核心功能——该版本中存在的函数和类型——以及扩展。其中一些、所有或没有任何这些扩展可能被提升到 Vulkan 1.2
    的核心功能集中。一些可能被认为已过时并被删除。当规范更新到 1.3 版本时，发生同样的情况：其中一些、所有或没有任何这些扩展可能从 1.2 版本提升到新版本，一些可能被过时。
- en: In this recipe, we will present the right way to deal with extensions during
    compile time and during runtime.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示在编译时和运行时处理扩展的正确方法。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are two types of extensions in Vulkan: instance- and device-level extensions.
    Before using an extension, you need to check if it is available during compile
    time and only add code that uses the extension if the extension is available.
    Generally speaking, you don’t need to check extensions at runtime. You also need
    to request the instance or device to enable the extensions by providing the name
    of the extension as a string.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 有两种类型的扩展：实例级和设备级扩展。在使用扩展之前，您需要检查它在编译时是否可用，并且只有当扩展可用时才添加使用该扩展的代码。一般来说，您不需要在运行时检查扩展。您还需要通过提供扩展的名称作为字符串来请求实例或设备启用扩展。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In addition to an extension being present at compile time, you need to enable
    it at the right level (instance or device) and check if it has been enabled just
    before using it at runtime.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在编译时存在扩展之外，您还需要在正确的级别（实例或设备）上启用它，并在运行时使用它之前检查它是否已启用。
- en: 'The pattern of checking whether a particular extension can be used at compile
    time and runtime is shown next:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查特定扩展在编译时和运行时是否可用的模式如下：
- en: '[PRE2]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Besides new functions and types, the Vulkan SDK offers macros for each extension.
    Those macros can be used to check whether they are present, their name, and version.
    In the preceding listing, a `VK_KHR_win32_surface` macro is defined and set to
    `1` if the extension is available. The `VK_KHR_WIN32_SURFACE_EXTENSION_NAME` macro
    defines a `const char *` as the name of the extension (in this case, it is `VK_KHR_win32_surface`)
    and a `VK_KHR_WIN32_SURFACE_SPEC_VERSION` macro, defined as an integer, that specifies
    its version number.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了新的功能和类型之外，Vulkan SDK 为每个扩展提供了宏。这些宏可以用来检查它们是否存在，它们的名称和版本。在先前的列表中，定义了一个 `VK_KHR_win32_surface`
    宏，并将其设置为 `1`，如果扩展可用。`VK_KHR_WIN32_SURFACE_EXTENSION_NAME` 宏定义了一个 `const char *`
    作为扩展的名称（在这种情况下，它是 `VK_KHR_win32_surface`），以及一个 `VK_KHR_WIN32_SURFACE_SPEC_VERSION`
    宏，它被定义为整数，指定了其版本号。
- en: Before creating an instance of `VkWin32SurfaceCreateInfoKHR`, we check if the
    `VK_KHR_win32_surface` device extension is present and enabled. The code is guarded
    by an `+#if+` directive, and if the extension is present, we proceed to check
    if it’s enabled at runtime using the `VK_KHR_WIN32_SURFACE_EXTENSION_NAME` macro.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 `VkWin32SurfaceCreateInfoKHR` 实例之前，我们检查 `VK_KHR_win32_surface` 设备扩展是否存在并已启用。代码由
    `+#if+` 指令保护，如果扩展存在，我们继续检查它在运行时是否已启用，使用 `VK_KHR_WIN32_SURFACE_EXTENSION_NAME`
    宏。
- en: This check is especially important if you are writing cross-platform code. While
    it may seem obvious that some extensions should be available, they may not be
    available for all platforms or graphics cards you are planning to support.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编写跨平台代码，这个检查尤为重要。虽然可能很明显某些扩展应该可用，但它们可能不是你计划支持的 所有平台或显卡上都有。
- en: Using the Validation Layer for error checking
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用验证层进行错误检查
- en: In the spirit of a high-performant, low-overhead API, Vulkan does not perform
    error-checking by default. Doing so would incur a performance penalty, which may
    be unacceptable for some applications. On the other hand, due to Vulkan’s complexity,
    it is very easy for the application to make mistakes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在高性能、低开销API的精神下，Vulkan默认不执行错误检查。这样做可能会造成性能损失，这可能对某些应用程序来说是无法接受的。另一方面，由于Vulkan的复杂性，应用程序很容易出错。
- en: To help application authors detect errors, Vulkan provides layers, which can
    be enabled during development and later disabled for shipping. That combination
    isn’t mandatory, as developers don’t have to enable error-detecting layers for
    testing nor disable them for shipping, although that is the most common scenario.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助应用程序作者检测错误，Vulkan提供了层，这些层可以在开发期间启用，并在以后禁用以进行发布。这种组合不是强制性的，因为开发者不需要启用错误检测层进行测试，也不需要禁用它们以进行发布，尽管这是最常见的情况。
- en: In this recipe, we will introduce what Vulkan layers are and how their messages
    are presented, as well as offer tips on how to learn more about the meaning of
    those messages.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将介绍Vulkan层是什么以及它们的消息是如何呈现的，并提供有关如何了解更多关于这些消息含义的技巧。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Layers are provided with the Vulkan SDK, so if you are using Vulkan, chances
    are you also have access to layers by default.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 层由Vulkan SDK提供，所以如果你在使用Vulkan，那么你默认也有权访问层。
- en: How to do it…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Layers are implementations of Vulkan functions that can be inserted in the call
    chain, intercepting entry points into the API. Those implementations can then
    perform error checking, performance measurements, or even detect possible optimizations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 层是Vulkan函数的实现，可以在调用链中插入，拦截进入API的入口点。这些实现可以执行错误检查、性能测量，甚至检测可能的优化。
- en: The Vulkan SDK provides a few layers that are **Plug and Play** (**PnP**). The
    only work you need to do is find which layers are present and enable them for
    the Vulkan instance. After that, at runtime, layers should start doing their jobs
    as soon as you start calling Vulkan functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan SDK提供了一些**即插即用**（**PnP**）的层。你需要做的唯一工作就是找到哪些层存在，并启用它们以用于Vulkan实例。之后，在运行时，层应该在你开始调用Vulkan函数时立即开始执行它们的工作。
- en: The most important layer available in the SDK is the Validation Layer. This
    layer will validate all Vulkan function calls and their parameters. It also maintains
    an internal state – which Vulkan does not – to ensure that your application is
    not missing a synchronization step or using the wrong layouts for images.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SDK中可用的最重要的层是验证层。这个层将验证所有Vulkan函数调用及其参数。它还维护一个内部状态——这是Vulkan所不具备的——以确保你的应用程序没有缺少同步步骤或使用错误的图像布局。
- en: 'As an example, the following message shows a real message displayed by the
    Validation Layer. Although somewhat cryptic, the message is very useful: it starts
    by displaying the error ID (`VUID-VkSamplerCreateInfo-sType-sType`), which you
    can use to search for it on the web; it also displays the device associated with
    the error; and finally, it displays the message ID and text, which informs us,
    in this example, that the structure we used to create a sampler (`VkSamplerCreateInfo`)
    needs to have its `sType` member equal to `VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，以下消息显示了验证层显示的真实消息。尽管有些晦涩难懂，但这个消息非常有用：它首先显示错误ID（`VUID-VkSamplerCreateInfo-sType-sType`），你可以用它在网上搜索；它还显示了与错误关联的设备；最后，它显示了消息ID和文本，告诉我们在这个例子中，我们用来创建采样器（`VkSamplerCreateInfo`）的结构需要其`sType`成员等于`VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO`：
- en: '[PRE3]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even the most experienced graphics programmers will face Validation Layer errors.
    Getting used to how they look and how to figure out what they mean is the first
    step in writing a Vulkan application that is Validation Layer error-free.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最有经验的图形程序员也会遇到验证层错误。习惯于它们的外观以及如何弄清楚它们的含义是编写无验证层错误的Vulkan应用程序的第一步。
- en: Enumerating available instance layers
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出可用的实例层
- en: Enabling an instance layer is as easy as providing its name as a `const char
    *` to the instance creation function. Unfortunately, not all layers exist in all
    implementations, and we need to check the available ones before trying to enable
    them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 启用实例层就像将其名称作为`const char *`提供给实例创建函数一样简单。不幸的是，并非所有层在所有实现中都存在，在尝试启用它们之前，我们需要检查可用的层。
- en: In this recipe, you will learn how to enumerate the available instance layers
    and how to transform them into strings so that they are easier to manage.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何枚举可用实例层，以及如何将它们转换为字符串，以便更容易管理。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code snippets shown in this section are part of our `Context` class.. It
    encapsulates most of the initialization and object creation functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的代码片段是`Context`类的一部分。它封装了大多数初始化和对象创建函数。
- en: How to do it…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Checking the available extensions is easy to do:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 检查可用扩展很容易做到：
- en: 'First, you need to query the number of extensions using the `vkEnumerateInstanceLayerProperties`
    function, create an array of `VkLayerProperties` big enough to store all extensions,
    and request their data by issuing a call to the same function again, like this:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要使用`vkEnumerateInstanceLayerProperties`函数查询扩展的数量，创建一个足够大的`VkLayerProperties`数组来存储所有扩展，并通过再次调用同一函数来请求它们的数据，如下所示：
- en: '[PRE4]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The second call to `vkEnumerateInstanceLayerProperties` will store all available
    layers in the `layers` vector, which then can be used for querying, diagnostics,
    and so on.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二次调用`vkEnumerateInstanceLayerProperties`将所有可用层存储在`layers`向量中，然后可以用于查询、诊断等。
- en: 'With that information in hand, it’s always a good idea to verify whether the
    layers you are trying to enable are available. Since the instance creation function
    accepts the name of the layers in `const char *` format, we need to convert the
    extension names to strings:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拥有这些信息后，始终验证您试图启用的层是否可用是个好主意。由于实例创建函数接受以`const char *`格式表示的层名，我们需要将扩展名转换为字符串：
- en: '[PRE5]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, the requested layers need to be filtered according to the available
    ones. With two vectors of strings, one for the available layers and one for the
    requested layers, we can use the following utility function to perform filtering:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，需要根据可用的层对请求的层进行过滤。使用两个字符串向量，一个用于可用层，一个用于请求层，我们可以使用以下实用函数来执行过滤：
- en: '[PRE6]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function is very handy because instance layers and instance and device
    extensions are all referred to by their names as `const char*`. This function
    can be applied to filter all layers and extensions you need in Vulkan.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常方便，因为实例层、实例和设备扩展都通过它们的名称作为`const char*`来引用。这个函数可以应用于过滤Vulkan中所需的所有层和扩展。
- en: Enumerating available instance extensions
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列举可用实例扩展
- en: The same process of filtering requested layers against available ones should
    be repeated for instance extensions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对请求的层与可用的层进行过滤的过程应该重复应用于实例扩展。
- en: In this recipe, you will learn how to obtain available instance extensions,
    how to store them as strings, and how to convert them to pointers to characters
    so that they can be passed to the Vulkan API.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何获取可用实例扩展，如何将它们存储为字符串，以及如何将它们转换为字符指针，以便可以将它们传递给Vulkan API。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The process is very similar to the one described in the previous recipe, which
    also includes a utility function to perform an intersection of the available layers
    and the requested ones.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与之前描述的过程非常相似，也包括一个实用函数来执行可用层和请求层的交集。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Obtaining a list of extensions is as easy as obtaining the available layers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 获取扩展列表与获取可用层一样简单。
- en: 'First, call `vkEnumerateInstanceExtensionProperties` twice, once to determine
    how many extensions are available and then one more time to fetch the extensions:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，调用`vkEnumerateInstanceExtensionProperties`两次，一次确定有多少扩展可用，然后再次调用以获取扩展：
- en: '[PRE7]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can filter the requested layers and extensions using the list of
    available layers and extensions from the previous steps. Notice that we are requesting
    the Validation Layer and guarding all extensions with a conditional preprocessor
    block:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用之前步骤中的可用层和扩展列表来过滤请求的层和扩展。注意，我们正在请求验证层，并使用条件预处理器块保护所有扩展：
- en: '[PRE8]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To pass the vectors of strings to the API, we need to convert them to vectors
    of `const char*` because the API only accepts `const char*` parameters. We also
    need to perform the same conversion for the vector of instance layers (which is
    omitted here for brevity):'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将字符串向量传递给 API，我们需要将它们转换为 `const char*` 向量，因为 API 只接受 `const char*` 参数。我们还需要对实例层的向量执行相同的转换（这里为了简洁省略）：
- en: '[PRE9]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `instanceExtensions` vector must *not* outlive the `enabledInstanceExtensions`
    vector. As `instanceExtensions` contains pointers to the strings in `enabledInstanceExtensions`,
    once the latter is destroyed, the pointers in `instanceExtensions` would all be
    dangling.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceExtensions` 向量不能比 `enabledInstanceExtensions` 向量存在时间更长。因为 `instanceExtensions`
    包含指向 `enabledInstanceExtensions` 中字符串的指针，一旦后者被销毁，`instanceExtensions` 中的所有指针都将悬空。'
- en: Initializing the Vulkan instance
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化 Vulkan 实例
- en: To start using Vulkan, we need to create a Vulkan instance. One can think of
    a Vulkan instance as a way of initializing the Vulkan library. To create one,
    you need to provide a set of required and optional information such as application
    name, engine name, version, and a list of desired layers and extensions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Vulkan，我们需要创建一个 Vulkan 实例。可以将 Vulkan 实例视为初始化 Vulkan 库的一种方式。要创建一个实例，你需要提供一组所需和可选信息，例如应用程序名称、引擎名称、版本以及所需层和扩展的列表。
- en: In this recipe, you will learn how to create a Vulkan instance.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何创建 Vulkan 实例。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Instantiating the `VkApplicationInfo` structure used to create an instance requires
    the version of the application and the Vulkan API version. The former can be created
    using the `VK_MAKE_VERSION` macro, while the latter can be provided as one of
    the preprocessor definitions available in the SDK.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于创建实例的 `VkApplicationInfo` 结构体需要应用程序版本和 Vulkan API 版本。前者可以使用 `VK_MAKE_VERSION`
    宏创建，而后者可以作为 SDK 中可用的预处理器定义之一提供。
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'With all of those in hand, all we need to do is create a Vulkan instance:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有所有这些，我们只需要创建一个 Vulkan 实例：
- en: 'Create an instance of the `VkApplicationInfo` structure first:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建 `VkApplicationInfo` 结构体的实例：
- en: '[PRE10]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will also need an instance of the `VkInstanceCreateInfo` structure with
    the requested instance layers and extensions. Then, call `vkCreateInstance`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要一个包含所需实例层和扩展的 `VkInstanceCreateInfo` 结构体实例。然后，调用 `vkCreateInstance`：
- en: '[PRE11]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the Vulkan instance has been created, you should keep it stored safely,
    as it will need to be destroyed before your application exits.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 Vulkan 实例，你应该安全地存储它，因为在你应用程序退出之前需要销毁它。
- en: Creating a surface
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表面
- en: Just as in OpenGL, presenting the final render output to the screen needs support
    from the windowing system and is platform-dependent. For this reason, the Vulkan
    Core API does not contain functions to render the final image to the screen. Those
    functions and types are extensions. For this recipe, we’ll use the `VK_KHR_surface`
    and `VK_KHR_swapchain` extensions. We will cover only the Windows case here and
    use the `VK_KHR_win32_surface` extension.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 OpenGL 一样，将最终渲染输出呈现到屏幕上需要窗口系统的支持，并且依赖于平台。因此，Vulkan 核心API不包含将最终图像渲染到屏幕上的函数。这些函数和类型是扩展。对于这个菜谱，我们将使用
    `VK_KHR_surface` 和 `VK_KHR_swapchain` 扩展。在这里，我们只涵盖 Windows 的情况，并使用 `VK_KHR_win32_surface`
    扩展。
- en: In this recipe, you will learn how to create a surface for presenting the final
    output of your rendering.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何创建一个用于呈现渲染最终输出的表面。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The first step in the process of rendering an image onto the screen starts with
    the creation of a `VkSurfaceKHR` object. Since this object is needed while reserving
    queues from a physical device, this step is done after the instance has been created
    but before the physical devices are enumerated and before the device is created,
    as the device needs information about which queue families we will use.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像渲染到屏幕上的过程的第一步是创建一个 `VkSurfaceKHR` 对象。由于在从物理设备预留队列时需要此对象，因此此步骤是在创建实例之后、枚举物理设备之前以及创建设备之前完成的，因为设备需要有关我们将使用哪些队列家族的信息。
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Creating a `VkSurfaceKHR` object is simple but needs support from the windowing
    system.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `VkSurfaceKHR` 对象很简单，但需要窗口系统的支持。
- en: 'On Windows, you need an instance handle to the executable a (`HINSTANCE)` and
    a window handle (`HWND`) for where to present the image. We’re using GLFW, so
    the window used by the `VkWin32SurfaceCreateInfoKHR` structure can be obtained
    with `glfwGetWin32Window(GLFWwindow*)`. The handle to the `VkSurfaceKHR` object
    is stored in `Context::surface_`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 上，你需要可执行文件的实例句柄（`HINSTANCE`）和用于显示图像的窗口句柄（`HWND`）。我们使用 GLFW，因此可以通过
    `glfwGetWin32Window(GLFWwindow*)` 获取 `VkWin32SurfaceCreateInfoKHR` 结构体所使用的窗口。`VkSurfaceKHR`
    对象的句柄存储在 `Context::surface_` 中：
- en: '[PRE12]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The surface creation varies slightly between platforms, but the process is very
    similar.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 表面创建在不同平台之间略有不同，但过程非常相似。
- en: Enumerating Vulkan physical devices
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举 Vulkan 物理设备
- en: Before we can create a device in Vulkan, we need to select a suitable physical
    device, as a system may have multiple Vulkan-capable GPUs and we want to choose
    one with the capabilities required by our application. To do this, we need to
    enumerate all available physical devices on the system. This can be achieved by
    calling the `vkEnumeratePhysicalDevices` function, which returns a list of all
    physical devices on the system that support the Vulkan API. Once we have the list
    of physical devices, we can inspect their properties and features using the `vkGetPhysicalDeviceProperties`
    and `vkGetPhysicalDeviceFeatures` functions to determine if they have the required
    capabilities. Finally, we can choose the most suitable physical device and use
    it to create a logical device through the `vkCreateDevice` function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够创建 Vulkan 设备之前，我们需要选择一个合适的物理设备，因为一个系统可能拥有多个支持 Vulkan 的 GPU，而我们希望选择一个符合我们应用程序所需功能的
    GPU。为此，我们需要枚举系统上所有可用的物理设备。这可以通过调用 `vkEnumeratePhysicalDevices` 函数来实现，该函数返回系统上支持
    Vulkan API 的所有物理设备的列表。一旦我们有了物理设备的列表，我们可以使用 `vkGetPhysicalDeviceProperties` 和 `vkGetPhysicalDeviceFeatures`
    函数来检查它们的属性和功能，以确定它们是否具有所需的功能。最后，我们可以选择最合适的物理设备，并通过 `vkCreateDevice` 函数使用它来创建逻辑设备。
- en: In this recipe, you will learn how to enumerate all Vulkan-capable devices present
    in the system so that you can choose one that best fits your needs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何枚举系统中所有具有 Vulkan 功能的设备，以便你可以选择最适合你需求的设备。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In our code, we encapsulate a physical device in a class called `VulkanCore::PhysicalDevice`,
    which retrieves a physical device’s properties and stores them for later use.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们使用一个名为 `VulkanCore::PhysicalDevice` 的类封装物理设备，该类检索物理设备的属性并将它们存储以供以后使用。
- en: Also, make sure to check out the `Context::choosePhysicalDevice()` method if
    you’d like to use a better heuristic to choose one physical device on systems
    that have multiple devices that support Vulkan.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想在拥有多个支持 Vulkan 的设备上使用更好的启发式方法来选择一个物理设备，请确保查看 `Context::choosePhysicalDevice()`
    方法。
- en: How to do it…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Enumerating physical devices employs the same pattern used throughout the API,
    which requires us to first request the number of items available and then fetch
    and store them into a vector:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举物理设备使用的是 API 中通用的模式，这要求我们首先请求可用项的数量，然后获取并将它们存储到一个向量中：
- en: '`vkEnumeratePhysicalDevices` is called twice, first to query how many objects
    are available, and a second time to fetch the handles to `VkPhysicalDevice` objects:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vkEnumeratePhysicalDevices` 被调用两次，第一次是为了查询有多少对象可用，第二次是为了获取 `VkPhysicalDevice`
    对象的句柄：'
- en: '[PRE13]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method returns a vector of `PhysicalDevice` objects. In the code, this
    list is passed to the `Context::choosePhysicalDevice()` helper method, which can
    be used to select an appropriate physical device based on the requested extensions
    and other GPU capabilities you may need. For the sake of simplicity, we always
    choose the first physical device from the list.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个 `PhysicalDevice` 对象的向量。在代码中，此列表被传递给 `Context::choosePhysicalDevice()`
    辅助方法，该方法可以根据请求的扩展和其他可能需要的 GPU 功能来选择一个合适的物理设备。为了简化，我们始终从列表中选择第一个物理设备。
- en: Caching the properties of queue families
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存队列家族的属性
- en: 'In Vulkan, a physical device can have one or more queue families, where each
    queue family represents a set of command queues that share certain properties,
    such as capabilities or usage. *Figure 1**.3* depicts a fictional set of families
    and their queues:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，一个物理设备可以有一个或多个队列家族，其中每个队列家族代表一组具有某些属性（如功能或用途）的命令队列。*图 1**.3* 描述了一个虚构的家族集合及其队列：
- en: '![Figure 1.3 – Queue families and their queues](img/B18491_01_03.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 队列家族及其队列](img/B18491_01_03.jpg)'
- en: Figure 1.3 – Queue families and their queues
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 队列家族及其队列
- en: Each queue family supports a specific set of operations and commands that can
    be executed in parallel. For example, there may be a graphics queue family, a
    compute queue family, and a transfer queue family, each optimized for different
    types of operations.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个队列家族支持一组特定的操作和命令，这些操作和命令可以并行执行。例如，可能有一个图形队列家族、一个计算队列家族和一个传输队列家族，每个家族针对不同类型的操作进行了优化。
- en: In this recipe, you will learn how to retrieve the properties of a queue family
    and where they are stored in the code in the repository.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何检索队列家族的属性以及它们在代码存储库中的存储位置。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository provided with this book, queue families and their properties
    are stored and managed by the `VulkanCore::PhysicalDevice` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书提供的存储库中，队列家族及其属性由`VulkanCore::PhysicalDevice`类存储和管理。
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Each queue family has its own set of properties, such as the number of queues,
    the type of operations it can perform, and the priority of the queues. When creating
    a logical device, we must specify which queue families and how many queues of
    each type we want to use.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 每个队列家族都有自己的属性集，例如队列数量、它可以执行的操作类型以及队列的优先级。当创建逻辑设备时，我们必须指定我们想要使用的队列家族以及每种类型的队列数量。
- en: 'To query the queue families available and their properties, use the `vkGetPhysicalDeviceQueueFamilyProperties`
    function:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查询可用的队列家族及其属性，请使用`vkGetPhysicalDeviceQueueFamilyProperties`函数：
- en: '[PRE14]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The properties of the families are stored in `std::vector<VkQueueFamilyProperties>
    PhysicalDevice::queueFamilyProperties_`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 家族的属性存储在`std::vector<VkQueueFamilyProperties>` `PhysicalDevice::queueFamilyProperties_`中。
- en: Enumerating physical device extensions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举物理设备扩展
- en: Physical device extensions must be explicitly enabled by the application and
    may only be available on specific physical devices or device drivers. It’s important
    to check for the availability of required extensions and to gracefully handle
    situations where extensions are not supported.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 物理设备扩展必须由应用程序显式启用，并且可能仅在特定的物理设备或设备驱动程序上可用。检查所需扩展的可用性以及优雅地处理不支持扩展的情况非常重要。
- en: In this recipe, you will learn how to enumerate all physical device extensions
    and how to convert and store them to strings for later use.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何枚举所有物理设备扩展以及如何将它们转换为字符串以便以后使用。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Enumerating physical device extensions is managed by the `VulkanCore::PhysicalDevice`
    class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 物理设备扩展的枚举由`VulkanCore::PhysicalDevice`类管理。
- en: How to do it…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Obtaining all physical device extensions for a physical device is simple. Here,
    we also provide code to store them as strings so that they are easier to work
    with.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 获取物理设备的所有物理设备扩展很简单。在这里，我们还提供了将它们作为字符串存储的代码，以便更容易处理。
- en: 'Enumerating all physical device extensions is done by using the `vkEnumerateDeviceExtensionProperties`
    function. The result is an array of `VkExtensionProperties`. This structure contains
    information such as the extension name, version, and a brief description of the
    extension’s purpose:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举所有物理设备扩展是通过使用`vkEnumerateDeviceExtensionProperties`函数完成的。结果是`VkExtensionProperties`结构体的数组。此结构体包含有关扩展名称、版本以及扩展用途的简要描述：
- en: '[PRE15]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Convert the extension’s name to `std::string`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将扩展的名称转换为`std::string`：
- en: '[PRE16]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This array is processed so that we end up with only the names of the extensions
    as strings. Further processing filters the requested extensions against the available
    ones using our `filterExtensions` utility function and stores them in `std::unordered_set<std::string>`
    `PhysicalDevice::enabledExtensions_`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此数组经过处理，最终我们只得到扩展名称的字符串。进一步处理使用我们的`filterExtensions`实用函数将请求的扩展与可用的扩展进行筛选，并将它们存储在`std::unordered_set<std::string>`
    `PhysicalDevice::enabledExtensions_`中：
- en: '[PRE17]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In summary, mastering the enumeration of physical device extensions is an important
    aspect of Vulkan. It ensures optimal utilization of your device’s capabilities.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，掌握物理设备扩展的枚举是Vulkan的一个重要方面。它确保了设备能力的最佳利用。
- en: Reserving queue families
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预留队列家族
- en: In Vulkan, a queue family is a group of one or more queues that share common
    properties, such as the type of operations they can perform. When creating a Vulkan
    device, we must specify which queue families we want to use and how many queues
    of each family we need.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，队列家族是一组一个或多个共享共同属性（例如它们可以执行的操作类型）的队列。当创建Vulkan设备时，我们必须指定我们想要使用的队列家族以及每个家族需要多少个队列。
- en: For rendering and presentation, we typically need at least one graphics queue
    family, which is responsible for executing graphics commands. Additionally, we
    may require a compute queue family for executing compute workloads and a transfer
    queue family for handling data transfers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渲染和展示，我们通常需要一个至少包含一个图形队列家族，该家族负责执行图形命令。此外，我们可能需要一个计算队列家族来执行计算工作负载，以及一个传输队列家族来处理数据传输。
- en: In this recipe, you will learn how to find queue families based on their properties
    and how to select a queue family that supports presentation, which can be used
    to present the final render output on the screen.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何根据队列的特性找到队列家族，以及如何选择一个支持展示的队列家族，这可以用于在屏幕上展示最终的渲染输出。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository, reserving queues is encapsulated by the `VulkanCore::PhysicalDevice`
    class.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中，预留队列被 `VulkanCore::PhysicalDevice` 类封装。
- en: How to do it…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: One additional step necessary before creating a Vulkan device is to gather the
    indices to the queue families we’d like to use. For that, we created a `PhysicalDevice::reserveQueues()`
    method in the `PhysicalDevice` class to handle the process, which takes the type
    of queues we’d like to reserve as a parameter. It also takes a handle to a Vulkan
    surface (`VkSurfaceKHR`), which we will use later to verify whether a queue supports
    presentation, necessary to display the final render on the screen.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Vulkan 设备之前，一个必要的额外步骤是收集我们想要使用的队列家族的索引。为此，我们在 `PhysicalDevice` 类中创建了一个 `reserveQueues()`
    方法来处理这个过程，它接受我们想要预留的队列类型作为参数。它还接受一个指向 Vulkan 表面（`VkSurfaceKHR`）的句柄，我们将在以后使用它来验证队列是否支持展示，这是在屏幕上显示最终渲染所必需的。
- en: 'We iterate over the queue families properties, stored in `queueFamilyProperties_`,
    and store the index to the queue family index if its type has been requested:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历存储在 `queueFamilyProperties_` 中的队列家族属性，如果其类型已被请求，则存储队列家族的索引：
- en: '[PRE18]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To detect if a queue family supports presentation, we use the `vkGetPhysicalDeviceSurfaceSupportKHR`
    function, guarded by the preprocessor macros:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检测一个队列家族是否支持展示，我们使用 `vkGetPhysicalDeviceSurfaceSupportKHR` 函数，该函数由预处理宏保护：
- en: '[PRE19]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The indices of other types of queue families may be obtained in a similar manner.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型队列家族的索引可以通过类似的方式获得。
- en: Creating a Vulkan logical device
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Vulkan 逻辑设备
- en: A Vulkan device is a logical representation of a physical GPU. It’s an object
    that is associated with a selected physical device (an existing GPU in the system)
    and is used to perform all graphics and compute operations. The device also provides
    access to physical GPU capabilities through queues. Queues are used to submit
    commands to the GPU, such as draw calls or memory transfers. The device also provides
    access to other Vulkan objects, such as pipelines, buffers, and images.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 设备是物理 GPU 的逻辑表示。它是一个与所选物理设备（系统中的现有 GPU）相关联的对象，用于执行所有图形和计算操作。设备还通过队列提供对物理
    GPU 功能的访问。队列用于向 GPU 提交命令，例如绘制调用或内存传输。设备还提供对其他 Vulkan 对象的访问，例如管线、缓冲区和图像。
- en: In this recipe, you will learn how to create a Vulkan logical device.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何创建一个 Vulkan 逻辑设备。
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code in this recipe is available as part of the `VulkanCore::Context` class
    in the repository. The `Context` class represents a Vulkan logical device.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱中的代码作为 `VulkanCore::Context` 类的一部分在仓库中可用。`Context` 类代表一个 Vulkan 逻辑设备。
- en: How to do it…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: To create a Vulkan device, we need to provide a physical device and the indices
    of the queue families we want to use. Using this information, we can create a
    vector of `VkDeviceQueueCreateInfo` structures, which determines the number of
    queues we want to use from each family and their respective priorities.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Vulkan 设备，我们需要提供一个物理设备和我们想要使用的队列家族的索引。使用这些信息，我们可以创建一个 `VkDeviceQueueCreateInfo`
    结构体的向量，这决定了我们想要从每个家族中使用的队列数量及其相应的优先级。
- en: 'The most common use case for creating a device is to use one queue per family
    and set its priority to `1`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建设备的最常见的用例是每个家族使用一个队列，并将其优先级设置为 `1`：
- en: '[PRE20]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The list of requested device extensions is converted from strings to `const
    char*`, filtered against the available extensions, and added to the `VkDeviceCreateInfo`
    structure, along with the index of the families we’d like to use and the layers
    we’d like to enable:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求的设备扩展列表被转换为 `const char*`，与可用的扩展进行过滤，并添加到 `VkDeviceCreateInfo` 结构中，包括我们想要使用的队列家族的索引和想要启用的层：
- en: '[PRE21]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A Vulkan device is one of the most important objects you need, as it’s needed
    to create almost every other Vulkan object there is.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan设备是你需要的最重要的对象之一，因为它几乎需要创建所有其他Vulkan对象。
- en: Retrieving the queue object handle
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取队列对象句柄
- en: Once the logical device has been created, we need to obtain the handle to queues.
    That is accomplished with the `vkGetDeviceQueue` function. This handle will be
    used to submit command buffers for processing on the GPU.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了逻辑设备，我们需要获取队列的句柄。这是通过`vkGetDeviceQueue`函数实现的。这个句柄将用于将命令缓冲区提交到GPU进行处理。
- en: In this recipe, you will learn how to obtain the handle to a Vulkan queue.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，你将学习如何获取Vulkan队列的句柄。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the repository, all queues are retrieved and stored by the `VulkanCore::Context`
    class. That class maintains a list for each type of queue: graphics, compute,
    transfer, and sparse, along with a special queue for presentation.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，所有队列都是通过`VulkanCore::Context`类检索和存储的。该类为每种类型的队列维护一个列表：图形、计算、传输和稀疏，以及一个用于演示的特殊队列。
- en: How to do it…
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To retrieve the handle to a queue, just call the `vkGetDeviceQueue` function
    with the queue family index and the queue index:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取队列的句柄，只需使用队列家族索引和队列索引调用`vkGetDeviceQueue`函数：
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Knowing which queue families are available is not enough. Once we determine
    which queues are available and the queues we need, we request the handle to one
    of the queues from the family using the API presented in this recipe.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 仅知道哪些队列家族可用是不够的。一旦我们确定了哪些队列可用以及我们需要的队列，我们将使用本配方中介绍的API从家族中请求一个队列的句柄。
- en: Creating a command pool
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令池
- en: '**Command buffers** provide the ability to record graphics and compute commands,
    while command queues allow those buffers to be submitted to the hardware. Commands
    recorded in the command buffers are then executed by the GPU.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令缓冲区**提供了记录图形和计算命令的能力，而命令队列允许将这些缓冲区提交到硬件。记录在命令缓冲区中的命令随后将由GPU执行。'
- en: Each queue is associated with a specific queue family, which defines the capabilities
    of the queue. For example, a queue family may only support graphics operations,
    or it may support both graphics and compute operations. The number of families
    and their capabilities can be retrieved using the `vkGetPhysicalDeviceQueueFamilyProperties`
    function, discussed in the *Caching the properties of queue families* recipe.
    A queue family may contain one or more queues.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每个队列都与一个特定的队列家族相关联，这定义了队列的能力。例如，一个队列家族可能只支持图形操作，或者它可能同时支持图形和计算操作。可以使用`vkGetPhysicalDeviceQueueFamilyProperties`函数检索家族的数量及其能力，该函数在*缓存队列家族属性*配方中进行了讨论。一个队列家族可能包含一个或多个队列。
- en: Command buffers are containers for the actual commands that are executed by
    the GPU. To record commands, you allocate a command buffer, then use the `vkCmd*`
    family of functions to record the commands into them. Once the commands have been
    recorded, the command buffer can be submitted to a command queue for execution.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区是GPU实际执行的命令的容器。要记录命令，你需要分配一个命令缓冲区，然后使用`vkCmd*`函数系列将命令记录到其中。一旦命令被记录，命令缓冲区就可以提交到命令队列以执行。
- en: Command buffers are allocated from a command pool, which in turn is created
    from a device and is associated with a specific queue family.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区是从命令池中分配的，该命令池又是由设备和特定的队列家族创建的。
- en: In this recipe, you will learn how to create a command pool.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，你将学习如何创建命令池。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Command pools and allocating and submitting command buffers is managed by the
    `VulkanCore::` `CommandQueueManager` class.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 命令池以及分配和提交命令缓冲区的管理由`VulkanCore::CommandQueueManager`类负责。
- en: How to do it…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Creating a command pool is easy. All you need is the queue family index and
    a creation flag. The `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` flag is
    enough for our purposes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命令池非常简单。你只需要队列家族索引和一个创建标志。对于我们的目的，`VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    标志就足够了。
- en: 'To create a command pool, use the `vkCreateCommandPool` function. The `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    flag means that each command buffer allocated from this pool may be reset individually
    or implicitly by calling `vkCmdBeginCommandBuffer`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建命令池，请使用`vkCreateCommandPool`函数。`VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`标志意味着从这个池中分配的每个命令缓冲区都可以单独或隐式地通过调用`vkCmdBeginCommandBuffer`来重置：
- en: '[PRE23]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With a command pool object, you can start allocating command buffers for recording
    commands.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令池对象，你可以开始为记录命令分配命令缓冲区。
- en: Allocating, recording, and submitting commands
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配、记录和提交命令
- en: Command buffers are allocated from command pools using the `vkAllocateCommandBuffers`
    function. Command buffers must be initialized with the `vkBeginCommandBuffer`
    function before being recorded into the buffer and prepared for submission with
    `vkEndCommandBuffer`. Commands are recorded into the buffer between those function
    calls and are executed only after the command buffer is submitted to the device
    with `vkQueueSubmit`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区是通过使用 `vkAllocateCommandBuffers` 函数从命令池中分配的。在将命令记录到缓冲区并准备提交给 `vkEndCommandBuffer`
    之前，必须使用 `vkBeginCommandBuffer` 函数初始化命令缓冲区。命令在那些函数调用之间记录，并且只有在命令缓冲区通过 `vkQueueSubmit`
    提交到设备后才会执行。
- en: In this recipe, you will learn how to allocate command buffers, how to record
    commands in the command buffer, and how to submit them for execution on the GPU.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何分配命令缓冲区，如何在命令缓冲区中记录命令，以及如何提交它们以在 GPU 上执行。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Command buffers are allocated from the `VulkanCore::CommandQueueManager` class
    and submitted using the same class. `VulkanCore::CommandQueueManager` provides
    basic functions to maintain a set of command buffers for processing.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区是从 `VulkanCore::CommandQueueManager` 类中分配的，并使用相同的类提交。`VulkanCore::CommandQueueManager`
    提供了基本功能来维护一组用于处理的命令缓冲区。
- en: How to do it…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'A command buffer’s life cycle starts with its allocation from a command pool.
    Once it has started, commands can be recorded into it. Before submission, you
    need to explicitly message them that recording has ended. They can then be submitted
    for execution:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区的生命周期始于从命令池中分配它。一旦开始，就可以将命令记录到其中。在提交之前，需要明确地通知它们记录已结束。然后可以提交它们以执行：
- en: 'To allocate command buffers, you call `vkAllocateCommandBuffers`, passing in
    the command pool, the number of buffers you want to allocate, and a pointer to
    a structure that specifies the properties of the command buffers:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要分配命令缓冲区，你调用 `vkAllocateCommandBuffers`，传入命令池、你想要分配的缓冲区数量以及指向一个指定命令缓冲区属性的结构的指针：
- en: '[PRE24]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After successfully allocating a command buffer, the recording of Vulkan commands
    can begin. The recording process is initiated through a call to the `vkBeginCommandBuffer`
    function, with parameters including the command buffer and a pointer to a structure
    that defines recording properties. Once recording is completed, the `vkEndCommandBuffer`
    function is called to finalize the process:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功分配命令缓冲区后，可以开始记录 Vulkan 命令。记录过程通过调用 `vkBeginCommandBuffer` 函数启动，该函数的参数包括命令缓冲区和指向一个定义记录属性的结构的指针。一旦记录完成，就调用
    `vkEndCommandBuffer` 函数来最终化这个过程：
- en: '[PRE25]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here are some examples of commonly used commands that can be recorded in a
    Vulkan command buffer:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一些可以在 Vulkan 命令缓冲区中记录的常用命令的示例：
- en: '`vkCmdBindPipeline`: Binds a pipeline to the command buffer. This command sets
    the current pipeline state for subsequent draw calls.'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vkCmdBindPipeline`：将管道绑定到命令缓冲区。此命令设置后续绘制调用的当前管道状态。'
- en: '`vkCmdBindDescriptorSets`: Binds descriptor sets to the command buffer. Descriptor
    sets hold references to buffer and image resources that can be used by shaders.'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vkCmdBindDescriptorSets`：将描述符集绑定到命令缓冲区。描述符集持有可以由着色器使用的缓冲区和图像资源的引用。'
- en: '`vkCmdBindVertexBuffers`: Binds vertex buffers to the command buffer. Vertex
    buffers contain the vertex data for a mesh.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vkCmdBindVertexBuffers`：将顶点缓冲区绑定到命令缓冲区。顶点缓冲区包含网格的顶点数据。'
- en: '`vkCmdDraw`: Executes a draw call, which processes vertices and rasterizes
    the resulting pixels.'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vkCmdDraw`：执行绘制调用，处理顶点并将生成的像素进行光栅化。'
- en: '`vkCmdDispatch`: Executes a compute shader.'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vkCmdDispatch`：执行计算着色器。'
- en: '`vkCmdCopyBuffer`: Copies data from one buffer to another.'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vkCmdCopyBuffer`：将数据从一个缓冲区复制到另一个缓冲区。'
- en: '`vkCmdCopyImage`: Copies data from one image to another.'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vkCmdCopyImage`：将数据从一个图像复制到另一个图像。'
- en: 'Once you are done recording commands, you must call `vkEndCommandBuffer`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成命令的记录，你必须调用 `vkEndCommandBuffer`：
- en: '[PRE26]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once a command buffer has been recorded, it still lives in your application
    and needs to be submitted to the GPU for processing. That is accomplished by the
    `vkQueueSubmit` function:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦命令缓冲区被记录，它仍然存在于你的应用程序中，需要提交给 GPU 进行处理。这是通过 `vkQueueSubmit` 函数完成的：
- en: '[PRE27]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, the fence is a specific Vulkan object that facilitates
    synchronization between the GPU and the CPU. The `vkQueueSubmit` function is an
    asynchronous operation that does not block the application. Therefore, once a
    command buffer is submitted, we can only determine whether it has been processed
    by checking the status of the fence using functions such as `vkGetFenceStatus`
    or `vkWaitForFences`. See the *Understanding synchronization in the swapchain
    – fences and semaphores* recipe to understand how fences can be used to synchronize
    your application and the execution of commands submitted to the GPU.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Reusing command buffers
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command buffers can be recorded once and submitted multiple times. They can
    also be used once and reset before the next use or just recorded, submitted, and
    discarded.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to reuse a command buffer without creating
    a race condition between your application and the GPU.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code provided in `VulkanCore::CommandQueueManager` doesn’t synchronize command
    buffers but provides functions to help you do so, such as `goToNextCmdBuffer`,
    `waitUntilSubmitIsComplete`, and `waitUntilAllSubmitsAreComplete`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using command buffers can be accomplished in two ways:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a command buffer and reuse it indefinitely. In this case, once the command
    buffer is submitted, you must wait for it to be processed before starting to record
    new commands. One way to guarantee that the buffer has finished being processed
    is by checking the status of the fences associated with it. If the fence is to
    be reused, you need to reset its state as well:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Figure 1**.4* shows the case where the command buffer submitted for processing
    is reused immediately after being submitted for processing on the GPU. Without
    any form of synchronization, reusing the command buffer will result in a race
    condition, as it may be still processing in the GPU:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Recording and submitting command buffers without using fences](img/B18491_01_04.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Recording and submitting command buffers without using fences
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'By using fences, as depicted in *Figure 1**.5*, it’s possible to prevent a
    race condition by checking the state of the fence associated with a command buffer
    before reusing it. If the fence has been signaled, no wait is necessary, but if
    the fence has not been signaled before reusing a command buffer, the application
    must wait for it to be signaled before continuing:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Recording and submitting command buffers using fences](img/B18491_01_05.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Recording and submitting command buffers using fences
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Allocate command buffers as needed. This is the easiest approach. Whenever you
    need to record and submit commands, just allocate a new command buffer from the
    pool, record commands, submit it, and forget about it. In this case, you need
    to pass the `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT` flag when creating the command
    pool. You might still need a fence associated with the buffer if you need to track
    the state of resources used by the commands in that buffer.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按需分配命令缓冲区。这是一种最简单的方法。每次你需要记录和提交命令时，只需从池中分配一个新的命令缓冲区，记录命令，提交它，然后忘记它。在这种情况下，你需要在创建命令池时传递`VK_COMMAND_POOL_CREATE_TRANSIENT_BIT`标志。如果你需要跟踪该缓冲区中命令使用的资源的状态，你可能仍然需要一个与该缓冲区关联的栅栏。
- en: Limiting the number of command buffers your application uses is a good practice
    that can help reduce the amount of memory your program needs.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 限制你的应用程序使用的命令缓冲区数量是一种良好的实践，这有助于减少程序所需的内存量。
- en: Creating render passes
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建渲染通道
- en: 'A render pass object represents a series of rendering operations that read
    from and write to images. It’s a high-level abstraction that helps the GPU optimize
    the rendering process. An attachment in Vulkan is a reference to an image that
    is used as a target during a render pass. Attachments can be color attachments
    (for storing color information) or depth or stencil attachments (for storing depth/stencil
    information). *Figure 1**.6* shows an overview of what a render pass object consists
    of:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染通道对象代表一系列读取和写入图像的渲染操作。它是一个高级抽象，有助于GPU优化渲染过程。在Vulkan中，附加物是用于渲染通道期间作为目标的图像的引用。附加物可以是颜色附加物（用于存储颜色信息）或深度或模板附加物（用于存储深度/模板信息）。*图1.6*展示了渲染通道对象包含的概述：
- en: '![Figure 1.6 – Render pass and framebuffer composition](img/B18491_01_06.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 渲染通道和帧缓冲区组成](img/B18491_01_06.jpg)'
- en: Figure 1.6 – Render pass and framebuffer composition
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 渲染通道和帧缓冲区组成
- en: The `VkAttachmentDescription` structure is used when creating a render pass
    in Vulkan to define the properties of each attachment. The `initialLayout` and
    `finalLayout` fields play a crucial role in optimizing the usage of attachments
    and layout transitions during the render pass execution. By setting the initial
    and final layouts correctly, you can avoid using additional pipeline barriers
    to transition image layouts, as these transitions are automatically managed by
    the render pass execution. For example, if you can have a color attachment that
    is initially in the `VK_IMAGE_LAYOUT_UNDEFINED` layout and should transition to
    the `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` layout at the end of the render pass, you
    can set the `initialLayout` and `finalLayout` fields accordingly. This eliminates
    the need for an explicit pipeline barrier to handle the transition, as the render
    pass will automatically perform the layout transition as part of its execution.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中创建渲染通道时，`VkAttachmentDescription`结构用于定义每个附加物的属性。`initialLayout`和`finalLayout`字段在优化渲染通道执行期间附加物使用和布局转换方面起着至关重要的作用。通过正确设置初始和最终布局，你可以避免使用额外的管道屏障来转换图像布局，因为这些转换将由渲染通道执行自动管理。例如，如果你有一个初始布局为`VK_IMAGE_LAYOUT_UNDEFINED`的颜色附加物，并且应该在渲染通道结束时转换为`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`布局，你可以相应地设置`initialLayout`和`finalLayout`字段。这消除了显式管道屏障处理转换的需要，因为渲染通道将自动在其执行过程中执行布局转换。
- en: A subpass is a part of a render pass that performs a specific rendering operation.
    Attachments are loaded for each subpass, read and/or written to, and finally stored
    at the end of the subpass. Load and store operations define whether an attachment’s
    contents should be loaded, cleared, or not cared about (which means the driver/hardware
    is free to choose what to do – or what not to do) while being loaded and whether
    they should be stored or not cared about when stored at the end of the pass. They
    have a significant impact on performance, especially on mobile GPUs. For mobile
    GPUs, minimizing the number of load/store operations can lead to significant performance
    improvements. By using `VK_ATTACHMENT_LOAD_OP_DONT_CARE` and `VK_ATTACHMENT_STORE_OP_DONT_CARE`
    when possible, we can avoid unnecessary memory bandwidth usage, which is a common
    bottleneck on mobile devices.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 子通道是渲染通道的一部分，它执行特定的渲染操作。每个子通道都会加载附件，读取和/或写入，并在子通道结束时存储。加载和存储操作定义了在加载时附件的内容是否应该被加载、清除或无需关注（这意味着驱动器/硬件可以自由选择要做什么——或不要做什么），以及当存储在通道结束时是否应该存储或无需关注。它们对性能有重大影响，尤其是在移动GPU上。对于移动GPU，最小化加载/存储操作的数量可以导致显著的性能提升。在可能的情况下，使用`VK_ATTACHMENT_LOAD_OP_DONT_CARE`和`VK_ATTACHMENT_STORE_OP_DONT_CARE`，我们可以避免不必要的内存带宽使用，这在移动设备上是一个常见的瓶颈。
- en: A subpass dependency describes the order in which subpasses should be executed
    and the synchronization required between them. On mobile GPUs, using multiple
    subpasses can help reduce memory bandwidth usage by keeping intermediate data
    in on-chip memory (tile-based rendering). This avoids the need to write and read
    back data from the main memory, which can be expensive in terms of power consumption
    and performance.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 子通道依赖关系描述了子通道应该执行的顺序以及它们之间所需的同步。在移动GPU上，使用多个子通道可以通过保持中间数据在片上内存（基于瓦片的渲染）中，从而帮助减少内存带宽使用。这避免了从主内存中写入和读取数据的需求，这在功耗和性能方面可能是昂贵的。
- en: Vulkan also supports render pass compatibility, which allows a framebuffer created
    for one render pass to be used with another compatible render pass, enhancing
    resource utilization and performance. Compatibility requires matching attachment
    counts, formats, load/store operations, sample counts, and compatible layouts;
    however, subpass structures can differ.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan还支持渲染通道兼容性，允许为某个渲染通道创建的帧缓冲区与另一个兼容的渲染通道一起使用，从而提高资源利用率和性能。兼容性要求匹配附件数量、格式、加载/存储操作、样本数量和兼容布局；然而，子通道结构可以不同。
- en: In this recipe, you will learn how to create render passes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何创建渲染通道。
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The creation of a render pass isn’t complicated but requires an assortment of
    information that is easier to manage if encapsulated in its own class. This way,
    the destructor of the class can take care of destroying the object at the right
    time, without us having to add code to deal with its destruction.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '创建渲染通道并不复杂，但需要一系列信息，如果封装在其自己的类中，则更容易管理。这样，类的析构函数可以在适当的时候处理对象的销毁，而无需我们添加代码来处理其销毁。 '
- en: Render passes are wrapped by the `VulkanCore::RenderPass` class in the code
    provided with the book.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书提供的代码中，渲染通道由`VulkanCore::RenderPass`类封装。
- en: How to do it…
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Creating a render pass needs a list of all attachments that will be used in
    that pass, along with their load and store operations and the final layout desired
    for each one of the attachments. A render pass must be associated with a type
    of pipeline (graphics, compute, and so on), so the constructor also takes a value
    of type `VkPipelineBindPoint`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 创建渲染通道需要一个列表，其中包含在该通道中将使用的所有附件，以及它们的加载和存储操作以及每个附件期望的最终布局。渲染通道必须与某种类型的管道（图形、计算等）相关联，因此构造函数还接受一个类型为`VkPipelineBindPoint`的值。
- en: The following code sample shows one of the constructors of the `VulkanCore::RenderPass`
    class. Be aware that we have not yet introduced Vulkan images (which are encapsulated
    in the `Texture` class in the code). We will discuss images in more detail in
    [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*, Working with Modern Vulkan,*
    in the *Creating images (**textures)* recipe.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了`VulkanCore::RenderPass`类的一个构造函数。请注意，我们尚未介绍Vulkan图像（在代码中封装在`Texture`类中）。我们将在[*第2章*](B18491_02.xhtml#_idTextAnchor126)*，*使用现代Vulkan*，*的*创建图像（**纹理）*食谱中更详细地讨论图像。
- en: 'The constructor iterates over all attachments that will be used in the render
    pass and creates a `VkAttachmentDescription` structure for each one. This structure
    contains basic information that is extracted from the attachments themselves (such
    as format and initial layout), but it also records what to do with each attachment
    when it is loaded and stored. While iterating over all the attachments used in
    the render pass, we create two other auxiliary variables: one list with the indices
    of attachments that are of type color (`colorAttachmentReferences`) and a variable
    that stores the index of the attachment that is depth and/or stencil (`depthStencilAttachmentReference`),
    since render passes only support one depth/stencil attachment:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数会遍历所有将在渲染通道中使用的附件，并为每个附件创建一个`VkAttachmentDescription`结构体。这个结构体包含了从附件本身提取的基本信息（例如格式和初始布局），同时也记录了在加载和存储每个附件时应该做什么。在遍历渲染通道中使用的所有附件时，我们创建了另外两个辅助变量：一个包含颜色附件索引的列表（`colorAttachmentReferences`）和一个存储深度/模板附件索引的变量（`depthStencilAttachmentReference`），因为渲染通道只支持一个深度/模板附件：
- en: '[PRE29]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For each attachment, create a `VkAttachmentDescription` structure and append
    it to the `attachmentDescriptors` vector:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个附件，创建一个`VkAttachmentDescription`结构体并将其追加到`attachmentDescriptors`向量中：
- en: '[PRE30]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the attachment is a depth or a stencil texture, create a `VkAttachmentReference`
    structure for it and store it in the `depthStencilAttachmentReference` auxiliary
    variable. Otherwise, the attachment is a color attachment, and we create and store
    a `VkAttachmentReference` structure to the `colorAttachmentReferences` vector:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果附件是深度或模板纹理，为它创建一个`VkAttachmentReference`结构体并将其存储在`depthStencilAttachmentReference`辅助变量中。否则，附件是一个颜色附件，我们创建并存储一个`VkAttachmentReference`结构体到`colorAttachmentReferences`向量中：
- en: '[PRE31]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `RenderPass` class only creates one subpass, which stores the color attachment
    references and the depth/stencil attachment reference:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RenderPass`类只创建一个子通道，该子通道存储颜色附件引用和深度/模板附件引用：'
- en: '[PRE32]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The only subpass we use for this recipe depends on an external subpass (since
    there’s only one subpass, it must depend on an external one):'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用的唯一子通道依赖于一个外部子通道（因为只有一个子通道，它必须依赖于外部的一个）：
- en: '[PRE33]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, all this information is stored in a structure of type `VkRenderPassCreateInfo`,
    which is passed, along with the device, to create a render pass with `vkCreateRenderPass`.
    The handle is stored in the `RenderPass::renderPass_` member variable:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，所有这些信息都存储在类型为`VkRenderPassCreateInfo`的结构体中，该结构体与设备一起传递，以使用`vkCreateRenderPass`创建渲染通道。句柄存储在`RenderPass::renderPass_`成员变量中：
- en: '[PRE34]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Destroying the render pass happens in the destructor, by calling the `vkDestroyRenderPass`
    function:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁渲染通道发生在析构函数中，通过调用`vkDestroyRenderPass`函数：
- en: '[PRE35]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Render passes store information on *what to do* with attachments (loaded, cleared,
    stored) and describe subpass dependencies. They also describe which attachments
    are resolve attachments (see the *Enabling and using Vulkan’s MSAA* recipe in
    [*Chapter 6*](B18491_06.xhtml#_idTextAnchor283)*, Anti-Aliasing Techniques*, to
    know more about resolve attachments and how they are used to implement MSAA in
    Vulkan).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染通道存储有关如何处理附件（加载、清除、存储）的信息，并描述子通道依赖关系。它们还描述了哪些附件是解析附件（参见[*第6章*](B18491_06.xhtml#_idTextAnchor283)*，抗锯齿技术*中的“启用和使用Vulkan的MSAA”配方，了解更多关于解析附件及其在Vulkan中如何用于实现MSAA的信息）。
- en: Creating framebuffers
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建帧缓冲区
- en: While the render pass object contains information about what to do with each
    attachment and their initial and final layouts, a framebuffer contains actual
    references to the attachments used in the render pass, which are provided in the
    form of `VkImageViews`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然渲染通道对象包含了关于每个附件及其初始和最终布局应该做什么的信息，但帧缓冲区包含实际用于渲染通道的附件的引用，这些引用以`VkImageViews`的形式提供。
- en: In this recipe, you will learn how to create a framebuffer object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将学习如何创建帧缓冲区对象。
- en: Getting ready
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository, Vulkan framebuffers are encapsulated by the `VulkanCore::Framebuffer`
    class.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，Vulkan帧缓冲区被`VulkanCore::Framebuffer`类封装。
- en: How to do it…
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Framebuffers refer to attachments (it answers the question “Which attachments
    will we be using for this render pass?”).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲区引用附件（它回答了“我们将为这个渲染通道使用哪些附件？”的问题）。
- en: 'The references are image views and are passed as a list, along with the handle
    of the render pass, to the `vkCreateFramebuffer` framebuffer creation function:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些引用是图像视图，并以列表的形式传递，包括渲染通道的句柄，到`vkCreateFramebuffer`帧缓冲区创建函数：
- en: '[PRE36]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating framebuffers is straightforward, and they are not strictly necessary
    anymore if you use dynamic rendering.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 创建帧缓冲区很简单，如果你使用动态渲染，它们就不再是严格必要的了。
- en: Creating image views
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像视图
- en: In Vulkan, an image view is a way to specify how an image should be interpreted
    and accessed by the GPU. It provides a view into an image’s memory and defines
    its format, dimensions, and data layout.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，图像视图是一种指定 GPU 如何解释和访问图像的方式。它提供了对图像内存的视图，并定义了其格式、尺寸和数据布局。
- en: An image view can be thought of as a window into an image’s memory that describes
    how the image should be accessed. It allows the image to be used in a variety
    of ways, such as a source or destination for rendering commands, or as a texture
    in a shader.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将图像视图视为一个窗口，它描述了如何访问图像的内存。它允许以多种方式使用图像，例如作为渲染命令的源或目标，或作为着色器中的纹理。
- en: Image views are created by specifying the image they will be associated with,
    along with a set of parameters that define the image’s format, aspect ratio, and
    range. Once created, an image view can be bound to a pipeline or shader to be
    used in rendering or other operations. They are represented by the `VkImage` type.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图像视图通过指定它们将要关联的图像以及一组定义图像格式、纵横比和范围的参数来创建。一旦创建，图像视图就可以绑定到管线或着色器，用于渲染或其他操作。它们由
    `VkImage` 类型表示。
- en: In this recipe, you will learn how to create image views.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何创建图像视图。
- en: Getting ready
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository, image views are stored by the `VulkanCore::Texture` class
    and don’t have a dedicated wrapper.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，图像视图由 `VulkanCore::Texture` 类存储，没有专门的包装器。
- en: How to do it…
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before creating an image view, you need the handle a Vulkan image object:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建图像视图之前，你需要一个指向 Vulkan 图像对象的句柄：
- en: 'Creating an image view is simple; all you need is the handle to a Vulkan image
    object (`VkImage`) and a few parameters that dictate how to access the underlying
    image:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建图像视图很简单；你只需要一个指向 Vulkan 图像对象（`VkImage`）的句柄以及一些参数，这些参数决定了如何访问底层的图像：
- en: '[PRE37]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Image views can span an entire image (mip levels and layers), just one element
    (mip level or layer), or even just a portion of the image.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图像视图可以跨越整个图像（mip 级别和层）、仅一个元素（mip 级别或层），甚至只是图像的一部分。
- en: The Vulkan graphics pipeline
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vulkan 图形管线
- en: 'The graphics pipeline is a crucial concept that describes the process of rendering
    graphics in a Vulkan application. The pipeline consists of a series of stages,
    each with a specific purpose, that take raw data and transform it into a fully
    rendered image on the screen. While some stages of the pipeline are more obvious,
    such as the viewport or rasterization, other stages such as the shader stage,
    vertex input, and dynamic states are less apparent but equally important. In the
    following recipes, we will explore some of the less obvious stages of the pipeline
    and explain their importance in the rendering process. *Figure 1**.7* shows an
    overview of all structures you may need to populate to create a graphics pipeline
    and their properties:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图形管线是 Vulkan 应用程序中渲染图形的关键概念。管线由一系列阶段组成，每个阶段都有特定的目的，它将原始数据转换成屏幕上完全渲染的图像。虽然管线的一些阶段比较明显，例如视口或光栅化，但其他阶段如着色器阶段、顶点输入和动态状态则不那么明显，但同样重要。在接下来的菜谱中，我们将探讨一些不太明显的管线阶段，并解释它们在渲染过程中的重要性。*图
    1.7* 展示了创建图形管线所需填充的所有结构及其属性：
- en: '![Figure 1.7 – Vulkan graphics pipeline](img/B18491_01_07.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – Vulkan 图形管线](img/B18491_01_07.jpg)'
- en: Figure 1.7 – Vulkan graphics pipeline
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – Vulkan 图形管线
- en: In this recipe, you will learn a little more about pipelines in Vulkan and their
    most important characteristics.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解 Vulkan 中管线的一些更多知识和它们最重要的特性。
- en: How to do it...
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here are the most important characteristics of pipelines in Vulkan:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Vulkan 中管线最重要的特性：
- en: In Vulkan, graphics pipelines are mostly immutable objects, meaning that once
    they are created, they cannot be modified except in certain instances. This is
    why it is necessary to create a new pipeline with a different topology if you
    wish to reuse a pipeline to draw different shapes. However, some pipeline properties
    can be changed dynamically at runtime, such as the viewport and scissor rectangles,
    which are referred to as dynamic states.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Vulkan中，图形管线主要是不可变对象，这意味着一旦创建，除非在特定情况下，否则不能修改。这就是为什么如果你希望重用管线来绘制不同的形状，需要创建一个新的具有不同拓扑的管线。然而，某些管线属性可以在运行时动态更改，例如视口和裁剪矩形，这些被称为动态状态。
- en: One important exception to the pipeline stages that won’t be covered in this
    book is the vertex input state. Although it is not entirely straightforward to
    create, we will not discuss it here since we exclusively utilize the **Programmable
    Vertex Pulling** (**PVP**) method to access indices and vertices at the vertex
    shader stage. For additional information about PVP, please refer to the *Implementing
    Programmable Vertex Pulling and Multi-Draw Indirect* recipe in [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*,
    Working with* *Modern Vulkan.*
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书不会涵盖的一个重要的管线阶段例外是顶点输入状态。尽管创建它并不完全直接，但我们不会在这里讨论它，因为我们专门使用**可编程顶点提取**（**PVP**）方法在顶点着色器阶段访问索引和顶点。有关PVP的更多信息，请参阅[*第2章*](B18491_02.xhtml#_idTextAnchor126)*，使用现代Vulkan*中的*实现可编程顶点提取和多绘制间接*配方。
- en: Similarly, the pipeline layout, a property of the graphics pipeline (and not
    a stage), is a data structure that outlines the anticipated layout of resources
    utilized by the shaders, including their location, quantity, and type, as well
    as pertinent details regarding push constants. Since this chapter does not provide
    any resources to the shaders, the pipeline layout is initialized with default
    values. Descriptor sets and push constants will be covered in [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*,
    Working with* *Modern Vulkan.*
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，管线布局，是图形管线的一个属性（而不是一个阶段），是一个数据结构，概述了着色器预期使用的资源的布局，包括它们的位置、数量和类型，以及与推送常量相关的详细信息。由于本章没有向着色器提供任何资源，因此管线布局使用默认值初始化。描述符集和推送常量将在[*第2章*](B18491_02.xhtml#_idTextAnchor126)*，使用现代Vulkan*中介绍。
- en: Compiling shaders to SPIR-V
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将着色器编译成SPIR-V
- en: In contrast to OpenGL, which typically compiles shaders from high-level languages
    into binary format during runtime, Vulkan only supports an intermediate representation
    called SPIR-V. SPIR-V is a cross-platform, low-level intermediate representation
    that can be produced from various shading languages.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 与OpenGL不同，OpenGL通常在运行时将着色器从高级语言编译成二进制格式，而Vulkan只支持一种称为SPIR-V的中间表示形式。SPIR-V是一种跨平台的低级中间表示形式，可以从各种着色语言生成。
- en: In this recipe, you will learn how to compile GLSL to SPIR-V using the `glslang`
    library.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将学习如何使用`glslang`库将GLSL编译成SPIR-V。
- en: Getting ready
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we use a third-party library that compiles GLSL code into SPIR-V
    at runtime called `glslang`. It can be downloaded from [https://github.com/KhronosGroup/glslang.git](https://github.com/KhronosGroup/glslang.git).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用一个第三方库，该库在运行时将GLSL代码编译成SPIR-V，称为`glslang`。可以从[https://github.com/KhronosGroup/glslang.git](https://github.com/KhronosGroup/glslang.git)下载。
- en: In our code, we provide the `VulkanCore::ShaderModule` class that encapsulates
    shaders. It provides the `ShaderModule::glslToSpirv` method (and overloads) that
    compiles shader source code from GLSL to SPIR-V.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们提供了`VulkanCore::ShaderModule`类，它封装了着色器。它提供了`ShaderModule::glslToSpirv`方法（及其重载），可以将着色器源代码从GLSL编译成SPIR-V。
- en: How to do it…
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps presented here are part of the `ShaderModule::glslToSpirv()` method.
    Here’s how it works:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的步骤是`ShaderModule::glslToSpirv()`方法的一部分。以下是它是如何工作的：
- en: 'The `glslang` library needs to be initialized once by calling `glslang::InitializeProcess()`,
    so its initialization is guarded by a static Boolean variable:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`glslang`库需要通过调用`glslang::InitializeProcess()`进行一次初始化，因此其初始化被一个静态布尔变量保护：'
- en: '[PRE38]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `TShader` object is instantiated by a function to contain shaders and various
    other parameters that are necessary for generating SPIR-V bytecode. These parameters
    include the input client and GLSL versions, as well as entry points into the shaders:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TShader`对象由一个函数实例化，用于包含着色器和生成SPIR-V字节码所必需的各种其他参数。这些参数包括输入客户端和GLSL版本，以及着色器的入口点：'
- en: '[PRE39]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Afterward, we collect constraints on resources that are typically available
    for shaders in the system, such as the maximum number of textures or vertex attributes,
    and establish messages that the compiler should present. Lastly, we compile the
    shader into SPIR-V and verify the result:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们收集系统中对着色器通常可用的资源约束，例如最大纹理数量或顶点属性数量，并建立编译器应呈现的消息。最后，我们将着色器编译成SPIR-V并验证结果：
- en: '[PRE40]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the last phase, linking options are established for both debug and release
    builds. In debug builds, regular debugging information is enabled while optimizations
    and debug information stripping are disabled. Conversely, in release builds, the
    optimizer is enabled, which may result in the removal of unused shader variables,
    including structure members. However, because discrepancies in structure sizes
    may cause problems if the same optimizations are not applied to the C++ code,
    optimizations are also disabled in release builds:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一个阶段，为调试和发布构建都建立了链接选项。在调试构建中，启用了常规的调试信息，同时禁用了优化和调试信息剥离。相反，在发布构建中，启用了优化器，这可能会导致未使用着色器变量的移除，包括结构体成员。然而，由于结构体大小的不一致可能会导致如果不对C++代码应用相同的优化，则会出现问题，因此在发布构建中优化也被禁用：
- en: '[PRE41]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For truly performant applications, shaders are not compiled from GLSL at runtime.
    They are compiled at build time and loaded from disk in the SPIR-V format when
    the application starts.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真正高性能的应用程序，着色器不是在运行时从GLSL编译的。它们是在构建时编译的，并在应用程序启动时从磁盘加载SPIR-V格式。
- en: Dynamic states
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态状态
- en: While **pipeline state objects** (**PSOs**) include immutable states, such as
    shader programs and vertex input bindings, some properties of a pipeline state
    can be changed dynamically at draw time using dynamic state objects. This feature
    provides greater flexibility and can minimize the necessity to recreate pipelines.
    Dynamic state objects can be used to change properties such as viewport and scissor
    rectangles, line width, blend constants, and stencil reference values. However,
    not all properties of a pipeline can be changed dynamically, and the use of dynamic
    states can have a small performance overhead.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**管道状态对象**（**PSOs**）包括不可变状态，如着色器程序和顶点输入绑定，但管道状态的一些属性可以在绘制时使用动态状态对象动态更改。这个特性提供了更大的灵活性，并可以最小化重新创建管道的必要性。动态状态对象可以用来更改属性，如视口和剪裁矩形、线宽、混合常数和模板参考值。然而，并非所有管道属性都可以动态更改，使用动态状态可能会产生轻微的性能开销。
- en: 'Without using dynamic states, the application has a few alternatives available:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用动态状态的情况下，应用程序有一些可用的替代方案：
- en: Create pipelines during the application startup. If you are aware of which pipelines
    will be required, they can be created beforehand at the expense of a higher startup
    cost.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序启动时创建管道。如果你知道需要哪些管道，它们可以在更高的启动成本下预先创建。
- en: Utilize pipeline caches. The graphics driver features a built-in mechanism for
    pipeline caching that can automatically generate a cache for you.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用管道缓存。图形驱动程序具有内置的管道缓存机制，可以自动为你生成缓存。
- en: Several parameters, such as the viewport, line width, and depth bias, can be
    dynamically modified. While some dynamic states were included in Vulkan 1.0, others
    were added as extensions or included as part of Vulkan 1.3\. If a parameter is
    marked as dynamic (using the appropriate structure), its value is ignored during
    pipeline creation.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数，如视口、线宽和深度偏移，可以动态修改。虽然一些动态状态包含在Vulkan 1.0中，但其他一些作为扩展添加或包含在Vulkan 1.3中。如果一个参数被标记为动态（使用适当的结构），则在管道创建期间忽略其值。
- en: In this recipe, you will learn about dynamic states, which allow some pipeline
    parameters to be dynamically set after a pipeline has been created.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这道菜谱中，你将了解动态状态，它允许在创建管道后动态设置一些管道参数。
- en: Getting ready
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Dynamic states are created using the `VkPipelineDynamicStateCreateInfo` structure.
    An instance of this structure is filled with states you would like to be dynamic
    and is later plugged into the creation of a pipeline, which we’ll cover in the
    next recipe.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 动态状态是通过使用`VkPipelineDynamicStateCreateInfo`结构体创建的。这个结构体的一个实例被填充了你希望设置为动态的状态，随后被插入到管道的创建过程中，我们将在下一道菜谱中介绍。
- en: How to do it…
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To allow parameters to be dynamically set, we need to create an instance of
    the `VkPipelineDynamicStateCreateInfo` structure.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许参数动态设置，我们需要创建一个`VkPipelineDynamicStateCreateInfo`结构体的实例。
- en: 'The next code fragment shows how to enable the dynamic state for the viewport
    parameter:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了如何启用视口参数的动态状态：
- en: '[PRE42]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The previously created instance will be used in the next recipe.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 之前创建的实例将在下一个菜谱中使用。
- en: Creating a graphics pipeline
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图形管线
- en: Once all the required states and pipeline properties have been gathered and
    instantiated, creating a graphics pipeline in Vulkan is a straightforward process.
    This involves populating the `VkGraphicsPipelineCreateInfo` structure and calling
    `vkCreateGraphicsPipelines`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集并实例化了所有必需的状态和管线属性，在Vulkan中创建图形管线就是一个简单的过程。这涉及到填充`VkGraphicsPipelineCreateInfo`结构并调用`vkCreateGraphicsPipelines`。
- en: In this recipe, you will learn how to create a graphics pipeline object in Vulkan.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何在Vulkan中创建图形管线对象。
- en: Getting ready
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For more information, please refer to the constructor of the `VulkanCore::Pipeline`
    class in the repository.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参阅存储库中`VulkanCore::Pipeline`类的构造函数。
- en: How to do it…
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Populating the structures referenced by `VkGraphicsPipelineCreateInfo` is not
    complicated, but a tedious task.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 填充由`VkGraphicsPipelineCreateInfo`引用的结构并不复杂，但是一项繁琐的任务。
- en: 'Once all structures of all states have been instantiated, all we need to do
    is create an instance of `VkGraphicsPipelineCreateInfo` and call `vkCreateGraphicsPipelines`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有状态的所有结构都已实例化，我们只需要创建一个`VkGraphicsPipelineCreateInfo`实例并调用`vkCreateGraphicsPipelines`：
- en: '[PRE43]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Creating a graphics pipeline is an expensive operation. One way to avoid the
    penalty of creating pipelines is to cache them and reuse them the next time your
    application runs.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图形管线是一个昂贵的操作。避免创建管线惩罚的一种方法是在应用程序下次运行时缓存并重用它们。
- en: Swapchain
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swapchain
- en: A swapchain in Vulkan mimics the functionality of double and triple buffering
    from OpenGL but with a more explicit role for the application in managing swapchain
    buffers. This approach provides better control over the configuration, synchronization,
    and presentation of images.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan中的swapchain模仿了OpenGL中的双缓冲和三缓冲功能，但应用在管理swapchain缓冲区方面有更明确的作用。这种方法提供了更好的控制，可以配置、同步和呈现图像。
- en: A Vulkan swapchain is a collection of images associated with a surface (`VkSurfaceKHR`)
    that are used to display rendering outputs in a window. Even though it is a key
    part of the Vulkan API, the functions and types used to create and manage a swapchain
    are part of the `VK_KHR_swapchain` extension.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan swapchain是与表面（`VkSurfaceKHR`）相关联的图像集合，用于在窗口中显示渲染输出。尽管它是Vulkan API的关键部分，但用于创建和管理swapchain的函数和类型是`VK_KHR_swapchain`扩展的一部分。
- en: The number of images in a swapchain object must be determined during its construction
    but must fall between the minimum (`minImageCount`) and maximum (`maxImageCount`)
    possible values provided by the device. Those values can be retrieved from the
    `VkSurfaceCapabilitiesKHR` structure of the Vulkan physical device.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: swapchain对象中的图像数量必须在构造时确定，但必须介于设备提供的最小（`minImageCount`）和最大（`maxImageCount`）可能值之间。这些值可以从Vulkan物理设备的`VkSurfaceCapabilitiesKHR`结构中检索。
- en: Swapchain images (`VkImage`) are created and owned by the swapchain object and,
    as a result, their memory isn’t provided or allocated by the application. Image
    views (`VkImageView`) are not created by the swapchain object and thus must be
    created separately.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Swapchain图像（`VkImage`）由swapchain对象创建和拥有，因此它们的内存不由应用程序提供或分配。图像视图（`VkImageView`）不是由swapchain对象创建的，因此必须单独创建。
- en: In this recipe, you will learn how to create, manage, and destroy swapchain
    images.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何创建、管理和销毁swapchain图像。
- en: Getting ready
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The swapchain is managed by the `VulkanCore::Swapchain` class in the code.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中由`VulkanCore::Swapchain`类管理swapchain。
- en: How to do it…
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The swapchain extension provides a set of functions and types to create, manage,
    and destroy swapchains. Some key functions and types include the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: swapchain扩展提供了一组用于创建、管理和销毁swapchain的函数和类型。一些关键函数和类型包括以下内容：
- en: '`vkCreateSwapchainKHR`: This function is used to create a swapchain. You need
    to provide a `VkSwapchainCreateInfoKHR` structure that contains details about
    the surface, the number of images, their format, dimensions, usage flags, and
    other swapchain properties.'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vkCreateSwapchainKHR`：此函数用于创建swapchain。你需要提供一个包含有关表面、图像数量、格式、尺寸、使用标志和其他swapchain属性的`VkSwapchainCreateInfoKHR`结构。'
- en: '`vkGetSwapchainImagesKHR`: After creating a swapchain, this function is used
    to retrieve handles to the images in the swapchain. You can then create image
    views and framebuffers for rendering and presentation.'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vkGetSwapchainImagesKHR`: 在创建交换链之后，此函数用于检索交换链中图像的句柄。然后，您可以创建用于渲染和展示的图像视图和帧缓冲区。'
- en: '`vkAcquireNextImageKHR`: This function is used to acquire an available image
    from the swapchain for rendering. It also requires providing a semaphore or fence
    to signal when the image is ready for rendering.'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vkAcquireNextImageKHR`: 此函数用于从交换链中获取一个可用的图像进行渲染。它还需要提供一个信号量或栅栏来指示图像何时准备好进行渲染。'
- en: '`vkQueuePresentKHR`: Once rendering is complete, this function is used to submit
    the swapchain image for presentation on the display device.'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vkQueuePresentKHR`: 一旦渲染完成，此函数用于将交换链图像提交到显示设备进行展示。'
- en: '`vkDestroySwapchainKHR`: This function is responsible for destroying the swapchain
    and cleaning up resources associated with it.'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vkDestroySwapchainKHR`: 此函数负责销毁交换链并清理与其相关的资源。'
- en: Understanding synchronization in the swapchain – fences and semaphores
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解交换链中的同步——栅栏和信号量
- en: 'The application and the GPU processes run in parallel; unless specified otherwise,
    the command buffers and their commands also run in parallel on the GPU. To enforce
    an order between the CPU and the GPU, and between command buffers being processed
    in the GPU, Vulkan provides two mechanisms: **fences** and **semaphores**. Fences
    are used to synchronize work between the GPU and the CPU, while semaphores are
    used to synchronize workloads executed in the GPU.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序和GPU进程是并行运行的；除非另有说明，否则命令缓冲区和它们的命令也在GPU上并行运行。为了在CPU和GPU之间以及GPU中处理的命令缓冲区之间强制执行顺序，Vulkan提供了两种机制：**栅栏**和**信号量**。栅栏用于在GPU和CPU之间同步工作，而信号量用于同步在GPU上执行的工作负载。
- en: 'In this recipe, you will learn about fences and semaphores: why they are necessary,
    how they are used (and when), and how to use semaphores with a swapchain.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将了解栅栏和信号量：为什么它们是必要的，如何使用（以及何时使用），以及如何使用信号量与交换链一起使用。
- en: Getting ready
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Examples of semaphores can be found in the `VulkanCore::Swapchain` class, while
    examples of fences can be found in the `VulkanCore::CommandQueueManager` class.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的示例可以在`VulkanCore::Swapchain`类中找到，而栅栏的示例可以在`VulkanCore::CommandQueueManager`类中找到。
- en: How to do it…
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Fences and semaphores have different uses. Let’s explore each one of those elements
    and how to use semaphores with swapchains.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 栅栏和信号量有不同的用途。让我们探索这些元素中的每一个，以及如何使用信号量与交换链一起使用。
- en: '*Figure 1**.8* shows how an application, running on the CPU, may submit commands
    to the GPU and proceed with its work right after submission (without synchronization).
    This may be intended, but if you wish to wait for commands on the GPU to finish
    being processed before continuing, you may use a fence to signal when work on
    the GPU has been completed. Once commands on the GPU are finished processing,
    the fence is signaled, and the application may proceed:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*图1**.8* 展示了一个在CPU上运行的应用程序如何提交命令到GPU，并在提交后立即继续其工作（无需同步）。这可能是预期的，但如果您希望在GPU上的命令处理完成后再继续，可以使用栅栏来指示GPU上的工作已完成。一旦GPU上的命令处理完成，栅栏被触发，应用程序可以继续：'
- en: '![Figure 1.8 – Command buffer recording and execution on the device without
    synchronization](img/B18491_01_08.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 在设备上无同步的命令缓冲区记录和执行](img/B18491_01_08.jpg)'
- en: Figure 1.8 – Command buffer recording and execution on the device without synchronization
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 在设备上无同步的命令缓冲区记录和执行
- en: 'Semaphores work in a similar manner but are used between commands or jobs running
    on the GPU. *Figure 1**.10* illustrates using a semaphore to synchronize commands
    being processed on the GPU. The application is responsible for creating semaphores
    and adding dependencies between command buffers and semaphores itself before submitting
    the buffers for processing. Once a task is processed on the GPU, the semaphore
    is signaled, and the next task can continue. This enforces an ordering between
    commands:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信号量以类似的方式工作，但用于GPU上运行的命令或作业之间。*图1**.10* 说明了使用信号量来同步GPU上正在处理的命令。应用程序负责在提交缓冲区进行处理之前创建信号量，并在命令缓冲区和信号量之间添加依赖关系。一旦GPU上处理了一个任务，信号量被触发，下一个任务可以继续。这强制命令之间有一个顺序：
- en: '![Figure 1.9 – Fences](img/B18491_01_09.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 栅栏](img/B18491_01_09.jpg)'
- en: Figure 1.9 – Fences
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 栅栏
- en: 'The process of acquiring an image, rendering, and presenting are all asynchronous
    and need to be synchronized. In this recipe, we will use two semaphores for the
    synchronization: `imageAvailable` and `imageRendered`. *Figure 1**.10* illustrates
    how semaphores affect the execution of commands on the device:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 获取图像、渲染和展示的过程都是异步的，需要同步。在这个菜谱中，我们将使用两个信号量进行同步：`imageAvailable` 和 `imageRendered`。*图
    1**.10* 说明了信号量如何影响设备上命令的执行：
- en: '![Figure 1.10 – Semaphores](img/B18491_01_10.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – 信号量](img/B18491_01_10.jpg)'
- en: Figure 1.10 – Semaphores
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 信号量
- en: '`imageAvailable_` is signaled once the image acquired is available, prompting
    the command queue that will render into the image to start processing. Once the
    command buffer finishes, it signals the other semaphore, `imageRendered`, which
    in turn allows the presentation of that image to start. *Figure 1**.11* demonstrates
    how synchronization is implemented using two semaphores:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取到的图像可用时，`imageAvailable_` 会发出信号，提示将要渲染到图像中的命令队列开始处理。一旦命令缓冲区完成，它将发出另一个信号量，即
    `imageRendered`，这反过来又允许开始展示该图像。*图 1**.11* 展示了如何使用两个信号量实现同步：
- en: '![Figure 1.11 – Synchronization of the swapchain](img/B18491_01_11.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – 交换链的同步](img/B18491_01_11.jpg)'
- en: Figure 1.11 – Synchronization of the swapchain
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 交换链的同步
- en: Fences and semaphores aren’t difficult to understand, but they are crucial for
    synchronization in Vulkan. Make sure you understand how they are used before continuing.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 栅栏和信号量并不难理解，但在 Vulkan 中它们对于同步至关重要。在继续之前，请确保您理解它们是如何被使用的。
- en: Populating submission information for presentation
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充展示的提交信息
- en: Submitting a command buffer requires an instance of the `VkSubmitInfo` structure,
    which allows specifying semaphores for waiting (to start processing) and signaling
    (once the command buffer finishes executing). Those semaphores are optional and
    usually not needed. But when submitting a command buffer for presenting images
    onto the screen, those semaphores allow Vulkan to synchronize the execution of
    the buffer with the presentation engine.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 提交命令缓冲区需要一个 `VkSubmitInfo` 结构的实例，这允许指定用于等待（以开始处理）和信号（一旦命令缓冲区执行完成）的信号量。这些信号量是可选的，通常不需要。但当提交命令缓冲区以在屏幕上展示图像时，这些信号量允许
    Vulkan 将缓冲区的执行与显示引擎同步。
- en: In this recipe, you will learn how to submit a command buffer for processing
    by the GPU after it has been recorded.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何在记录后提交命令缓冲区以供 GPU 处理。
- en: Getting ready
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `VulkanCore::Swapchain` class in the repository provides a utility function
    to fill the `VkSubmitInfo` structure for you since the semaphores used to synchronize
    the execution with the presentation engine are stored in the swapchain. If no
    semaphores are needed in the structure, the `waitForImageAvailable` and the `signalImagePresented`
    parameters should be set to `false`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库中的 `VulkanCore::Swapchain` 类提供了一个实用函数来为您填充 `VkSubmitInfo` 结构，因为用于与显示引擎同步执行的分发信号量存储在交换链中。如果结构中不需要信号量，则
    `waitForImageAvailable` 和 `signalImagePresented` 参数应设置为 `false`。
- en: How to do it…
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The synchronization information used to submit command buffers that need to
    be synchronized with the presentation engine is provided by an instance of the
    `VkSubmitInfo` structure and contains references to the semaphores that will be
    used for synchronization in the device. It also contains the command buffer that
    will be submitted.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 用于提交需要与显示引擎同步的命令缓冲区的同步信息由 `VkSubmitInfo` 结构的实例提供，并包含用于设备中同步的信号量的引用。它还包含将要提交的命令缓冲区。
- en: 'The fence is associated with the command buffer and is not a specific one for
    synchronizing the swapchain:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 栅栏与命令缓冲区相关联，并不是用于同步交换链的特定栅栏：
- en: '[PRE44]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once a command buffer has been submitted for processing, it’s up to the driver
    and the GPU to execute the commands recorded there. The only way to know whether
    the command buffer has finished processing is by checking the fence provided to
    `vkQueueSubmit`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提交了用于处理的命令缓冲区，驱动程序和 GPU 就会执行其中记录的命令。唯一知道命令缓冲区是否已处理完成的方法是检查提供给 `vkQueueSubmit`
    的栅栏。
- en: Presenting images
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示图像
- en: Presenting an image onto the screen isn’t automatic in Vulkan. You need to call
    the `vkQueuePresentKHR` function along with an instance of the `VkPresentInfoKHR`
    structure.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中将图像展示到屏幕上不是自动的。您需要调用 `vkQueuePresentKHR` 函数以及 `VkPresentInfoKHR` 结构的实例。
- en: In this recipe, you will learn how to queue an image for presentation once it
    has finished rendering.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何在图像渲染完成后将其排队以供展示。
- en: Getting ready
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The presentation in our code is done in the `VulkanCore::Swapchain::present()`
    method.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中的展示是通过`VulkanCore::Swapchain::present()`方法完成的。
- en: How to do it…
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Requesting an acquired image to be presented is done by calling `vkQueuePresentKHR`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`vkQueuePresentKHR`请求展示获取的图像。
- en: 'This time, we need to provide the `imageRendered` semaphore, which indicates
    when the rendering process has finished using the image:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们需要提供`imageRendered`信号量，它表示渲染过程何时完成对图像的使用：
- en: '[PRE45]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The image won’t be presented right away once `VkQueuePresentKHR` is called.
    This call merely sets up the synchronization mechanism so that Vulkan knows when
    the image can be sent for display.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用`VkQueuePresentKHR`，图像不会立即展示。这个调用仅仅设置了同步机制，以便Vulkan知道何时可以将图像发送进行显示。
- en: Rendering a triangle
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制三角形
- en: Now that we’ve learned about all basic Vulkan objects and how they work, we
    can finally create a small example application that displays a static shaded triangle
    on the screen.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了所有基本Vulkan对象及其工作原理，我们最终可以创建一个小型示例应用程序，在屏幕上显示静态着色三角形。
- en: In this recipe, we will present a full example that renders a static triangle
    on the screen. The vertex data and attributes are statically provided in the vertex
    shader.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示一个完整的示例，该示例在屏幕上绘制静态三角形。顶点数据和属性在顶点着色器中静态提供。
- en: Getting ready
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code in this recipe can be found in the repository in `source/chapter1/main.cpp`.
    The vertex and fragment shaders are located in `source/chapter1/resources/shaders`,
    in the `triangle.vert` and `triangle.frag` files.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱中的代码可以在存储库中的`source/chapter1/main.cpp`找到。顶点和片段着色器位于`source/chapter1/resources/shaders`目录下的`triangle.vert`和`triangle.frag`文件中。
- en: How to do it…
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The code presented here is an unabridged version of the code in the repository.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的代码是存储库中代码的完整版本。
- en: 'For this recipe, we will use two shaders: `triangle.vert` and `triangle.frag`.
    The vertex shader does not accept any inputs, as all the data it needs is defined
    right there in the shader itself as two arrays: one for vertex data (`positions`)
    and the other for color data (`colors`).'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用两个着色器：`triangle.vert`和`triangle.frag`。顶点着色器不接受任何输入，因为它所需的所有数据都定义在着色器本身中，作为两个数组：一个用于顶点数据（`positions`）和一个用于颜色数据（`colors`）。
- en: 'Both sets of data are sent to the output as-is without any transformations,
    as they are already in their respective output spaces (screen space for the position
    data and the output color space for the color data). The position is output through
    the built-in `gl_VertexIndex` variable, while the color is written to the `outColor`
    variable at location `0`:'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两套数据都直接以原始形式发送到输出，没有任何转换，因为它们已经处于各自输出空间中（位置数据为屏幕空间，颜色数据为输出颜色空间）。位置通过内置的`gl_VertexIndex`变量输出，而颜色则写入位置`0`的`outColor`变量：
- en: '[PRE46]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The fragment shader accepts the color data from the vertex stage and directly
    outputs it as the fragment color through the `outColor` variable at location `0`:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器接受来自顶点阶段的颜色数据，并通过位置`0`的`outColor`变量直接将其输出为片段颜色：
- en: '[PRE47]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We only need one render pass that will output the render result to a framebuffer
    with only one attachment, color attachment 0\. The color attachment’s load operation
    is *clear* as we will clear it for rendering, whereas the store operation is *store*
    as we want the output to be recorded into the attachment. The output will go straight
    into the swapchain, so the acquired swapchain image is the color attachment 0\.
    Since each render pass outputs directly onto the swapchain image, and a framebuffer
    is associated with an attachment and is immutable, we need the number of framebuffers
    to match the number of swapchain images. Each framebuffer will be associated with
    one swapchain image as the color attachment 0\. The shaders don’t need access
    to external buffers, such as vertex and index, or textures.
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只需要一个渲染通道，它将渲染结果输出到只有一个附件的帧缓冲区，即颜色附件0。颜色附件的加载操作是*清除*，因为我们将在渲染时清除它，而存储操作是*存储*，因为我们希望输出被记录到附件中。输出将直接进入交换链，因此获取的交换链图像是颜色附件0。由于每个渲染通道直接输出到交换链图像，并且帧缓冲区与附件相关联且不可变，我们需要帧缓冲区的数量与交换链图像的数量相匹配。每个帧缓冲区将与一个交换链图像相关联，作为颜色附件0。着色器不需要访问外部缓冲区，如顶点和索引或纹理。
- en: 'The first step is to initialize a window and create a context with the features
    we will use by default in this book. For more details, please refer to the `VulkanCore::VulkanFeatureChain`
    class in the repo. The context, which encapsulates the instance and the physical
    and logical devices, is initialized with a few useful extensions, one graphics
    queue, and the default features:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是初始化一个窗口并创建一个上下文，我们将使用此书中的默认功能。有关更多详细信息，请参阅存储库中的 `VulkanCore::VulkanFeatureChain`
    类。该上下文封装了实例以及物理和逻辑设备，并使用一些有用的扩展、一个图形队列和默认功能进行初始化：
- en: '[PRE48]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The swapchain is initialized with a common format and color space, along with
    the extensions from the physical device. In this example, we use the **First In
    First Out** (**FIFO**) presentation mode because it’s the only mode that is supported
    by default:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换链使用一个常见的格式和颜色空间以及物理设备的扩展进行初始化。在这个例子中，我们使用 **先进先出** (**FIFO**) 展示模式，因为它默认支持的唯一模式：
- en: '[PRE49]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Both shaders are initialized from the resources in the repo, along with a vector
    of framebuffers. The number of framebuffers matches the number of swapchain images,
    as we’ll need one framebuffer for each acquired image later:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个着色器都是从存储库中的资源初始化的，以及一个帧缓冲区向量。帧缓冲区的数量与交换链图像的数量相匹配，因为我们稍后需要为每个获取的图像使用一个帧缓冲区：
- en: '[PRE50]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We only need one render pass with one subpass. A render pass isn’t associated
    with any resources. It only specifies the load and store operations of each framebuffer’s
    color attachment and their use by the subpasses. For this reason, we don’t need
    multiple render passes, like framebuffers do. One is enough, and it is reused
    for all swapchain images. The final layout of the color attachment 0, the swapchain
    image, is `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`, as it will be presented:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要一个渲染通道和一个子通道。渲染通道不关联任何资源。它只指定每个帧缓冲区颜色附件的加载和存储操作以及子通道的使用。因此，我们不需要多个渲染通道，就像帧缓冲区那样。一个就足够了，并且它被用于所有交换链图像。颜色附件
    0，即交换链图像的最终布局是 `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`，因为它将被展示：
- en: '[PRE51]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we create a pipeline that contains mostly the default parameters.
    Besides the two shaders compiled before, we set the viewport to be the size of
    the output and disable depth testing. We then create a Command Queue Manager instance
    to manage the command buffers and their fences:'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们创建一个包含大多数默认参数的管道。除了之前编译的两个着色器之外，我们将视口设置为输出的大小并禁用深度测试。然后我们创建一个命令队列管理器实例来管理命令缓冲区和它们的栅栏：
- en: '[PRE52]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The main render loop executes until the `GLFW` window is closed. On each iteration,
    we first acquire a swapchain image and its index. If a framebuffer for this swapchain
    image doesn’t exist yet, we create one. We then obtain a command buffer for rendering:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主渲染循环执行，直到 `GLFW` 窗口关闭。在每次迭代中，我们首先获取一个交换链图像及其索引。如果此交换链图像的帧缓冲区尚不存在，我们创建一个。然后我们获取一个用于渲染的命令缓冲区：
- en: '[PRE53]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Before starting rendering, we begin the render pass by providing a clear color
    (black), and the render pass and framebuffer handles. We then bind the pipeline
    to the current command buffer, and we are ready to start rendering:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始渲染之前，我们通过提供一个清除颜色（黑色）和渲染通道以及帧缓冲区句柄来开始渲染通道。然后我们将管道绑定到当前命令缓冲区，我们就可以开始渲染了：
- en: '[PRE54]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we issue the draw call with three vertices and one instance. This
    call will invoke the vertex shader three times (one for each vertex), instantiating
    the `gl_VertexIndex` variable in the shader to 0, 1, and 2\. We use this variable
    to index into the position and color arrays in the shader itself. We then submit
    the command buffer and present the swapchain image:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用三个顶点和实例发出绘制调用。此调用将调用顶点着色器三次（每个顶点一次），在着色器中实例化 `gl_VertexIndex` 变量到 0、1
    和 2。我们使用此变量在着色器本身中索引位置和颜色数组。然后我们提交命令缓冲区并展示交换链图像：
- en: '[PRE55]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After the render loop ends, and before exiting the program, we wait for all
    queues to finish processing before destroying all Vulkan objects in the opposite
    order in which they were created:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染循环结束后，在退出程序之前，我们等待所有队列完成处理，然后以它们创建的相反顺序销毁所有 Vulkan 对象：
- en: '[PRE56]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The result of this recipe should look like *Figure 1**.12*:'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此菜谱的结果应类似于 *图 1**.12*：
- en: '![Figure 1.12 – Recipe result](img/B18491_01_12.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – 菜谱结果](img/B18491_01_12.jpg)'
- en: Figure 1.12 – Recipe result
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 菜谱结果
- en: Vulkan is verbose and, as mentioned before, provides many ways to customize
    your graphics application. A simple example such as this needed around 1,000 lines
    of code! But there is no reason for panic. Most of that code can be reused (and
    will be reused) for the remainder of the book to explain all techniques and recipes
    in the text.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan语言较为冗长，正如之前提到的，它提供了许多自定义图形应用程序的方法。一个简单的例子就需要大约1,000行代码！但无需恐慌。其中大部分代码可以重用（并且将被重用）来解释本书中剩余部分的所有技术和食谱。
