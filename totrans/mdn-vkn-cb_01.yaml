- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vulkan Core Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal for this chapter is to implement a simple program that displays a shaded
    triangle on screen, with the triangle’s vertices and attributes being sourced
    directly from the shaders. In the process of implementing the code to render this
    triangle, we will cover most of Vulkan’s fundamental objects, the ones you need
    to create a very simple application. Although the code required for this minimal
    example is extensive, the majority of it can be reused and tweaked for other applications.
    By the end of the chapter, you will know how to bootstrap communication with the
    driver, how to create and manage basic Vulkan objects, and how to issue rendering
    commands to the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, following a brief introduction to the Vulkan API, we will
    cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling API functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Vulkan objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Volk to load Vulkan functions and extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vulkan extensions correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Validation Layer for error checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating available instance layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating available instance extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the Vulkan instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a surface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating Vulkan physical devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching the properties of queue families
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating physical device extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserving queue families
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Vulkan logical device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the queue object handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a command pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating, recording, and submitting commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing command buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating render passes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating framebuffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating image views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vulkan graphics pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling shaders to SPIR-V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a graphics pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding synchronization in the swapchain – fences and semaphores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populating submission information for presentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a triangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To successfully run the code featured in this and rest of chapters, your system
    must meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: A Windows computer equipped with a GPU that supports Vulkan 1.3\. We recommend
    having a machine with at least 16 GB of RAM and a modern graphics card. The code
    for various chapters was tested with GTX 1080, GTX 1060, RTX 3050, and RTX 4060\.
    Please note that [*Chapter 7*](B18491_07.xhtml#_idTextAnchor299)*, Ray Tracing
    and Hybrid Rendering*, requires RTX 3050/4060 series card since it demonstrates
    use of ray tracing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and Install Vulkan SDK 1.3.268: Visit the LunarG website at [https://sdk.lunarg.com/sdk/download/1.3.268.0/windows/VulkanSDK-1.3.268.0-Installer.exe](https://sdk.lunarg.com/sdk/download/1.3.268.0/windows/VulkanSDK-1.3.268.0-Installer.exe)
    and download the Vulkan SDK 1.3.268 installer. Run the installer to complete the
    installation process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install Python 3.12: Download the latest version of Python 3.12 from the official
    Python website and follow the installation instructions provided.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone the Repository: Ensure you have Git installed on your computer. If not,
    download and install Git from [https://git-scm.com/downloads](https://git-scm.com/downloads).
    Once Git is installed, open a command prompt or terminal and execute git clone
    [https://github.com/PacktPublishing/The-Modern-Vulkan-Cookbook](https://github.com/PacktPublishing/The-Modern-Vulkan-Cookbook)
    to clone the repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Project in Visual Studio 2022: Launch Visual Studio 2022\. Navigate
    to **File** | **Open** | **Folder** and select the folder where you cloned the
    repository. This action will load the project into Visual Studio.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the Project: Within Visual Studio, you can choose to build the project
    for debugging or release. For learning purposes and when making changes to the
    code, it’s recommended to use the **Debug** build configuration. This allows you
    to step through the code and understand its execution flow. For simply running
    the executables, you can use the **Release** build configuration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The project is structured to facilitate easy navigation and understanding of
    the code examples provided in each chapter. Here’s a detailed guide on how to
    locate and work with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The project is organized into several key directories, each serving a specific
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`source/chapterX`: This directory contains the main source code for each chapter.
    Replace X with the chapter number you are working on. For example, the source
    code for this chapter is located in `source/chapter1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source/vulkancore`: This directory is dedicated to the Vulkan specific code
    and components. It includes utilities, wrappers, and other Vulkan related functionalities
    that are used throughout the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source/enginecore`: This directory houses the core engine components that
    are shared across multiple chapters. These components provide foundational functionality
    that is reused in various parts of the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipe for this chapter can be run by launching `Chapter01_Traingle.exe`
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the Vulkan API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Vulkan API, introduced in 2016 by the Khronos Group, is a low-overhead,
    cross-platform computing API that is the successor to OpenGL and its variants
    (WebGL and OpenGL ES). In fact, Vulkan was called **Next Generation OpenGL** (or
    **glNext**) before it was officially named Vulkan. OpenGL has been around since
    1992 and it was the de facto introductory graphics API everyone learned (and learns
    still today). Allied with its simplicity, OpenGL is ubiquitous even today.
  prefs: []
  type: TYPE_NORMAL
- en: So, how is Vulkan different from OpenGL? It starts with its complexity. Vulkan
    is intended to provide application authors more control over the graphics hardware
    so that they can implement a solution that caters to their needs. Applications
    can implement solutions as simple as they want or as complex as they need. In
    practice, this means that the application is now responsible for controlling the
    hardware, making it more complex. The drivers, on the other hand, became simpler.
    For instance, if an application is really concerned about resource management,
    it can implement its own resource management algorithms and not rely on the driver’s
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In short, Vulkan offers more fine-grained control over the GPU compared to OpenGL
    due to its *lower-level* nature. It empowers applications to handle tasks that
    were traditionally managed by graphics drivers, such as initiating communication
    between the application and the hardware. However, this increased control comes
    with added complexity. Vulkan abstracts a large part of the GPU-specific implementation,
    allowing the same code to run on a wide range of GPUs. While it is possible to
    use device-specific extensions to maximize the computation potential of a particular
    GPU, these are not necessities but optional choices to optimize performance. In
    both desktop and mobile environments, managing this complexity to make optimal
    use of the GPU can be challenging due to the vast array of possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Calling API functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the many knobs Vulkan provides to control every little thing that the
    hardware can do, Vulkan tends to be more verbose than OpenGL. Since the control
    of every single aspect of the rendering process is now exposed to the application,
    there is simply more information that needs to be communicated with the graphics
    driver (mind you, the graphics driver still exists; it’s just simpler than it
    used to be).
  prefs: []
  type: TYPE_NORMAL
- en: The most prominent pattern used by the Vulkan API is structure-as-parameter.
    It is used for creating and allocating objects, querying their capabilities and
    information, describing layouts, and much more. In this pattern, instead of passing
    all possible values for the creation of an object as parameters of a function,
    you must stick all that information in a structure provided by the Vulkan SDK
    and then pass that structure as a parameter to the function.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how Vulkan functions are expected to be called
    and how to check their return value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating objects in Vulkan requires you to fill an instance of a special structure
    (there’s one for each object you would like to create) and pass it to the creation
    function, which takes a pointer to a variable that will store the object’s handle
    upon return. Most functions in the API return a result that can be used to detect
    errors, and it’s usually a very good idea to do so to catch errors as soon as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will show how to create a Vulkan sampler (`VkSampler`) by calling
    the `vkCreateSampler` function and how you can create a macro that can be used
    to check the return value of Vulkan function calls without repeating the same
    code over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: The following code demonstrates how to create a `VkSampler` sampler, a Vulkan
    object that dictates how a texture is sampled in a shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before calling the `vkCreateSampler` function that creates the sampler, you
    need to fill a structure called `VkSamplerCreateInfo` with all the parameters
    you’d like the new sampler to have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the example, we are setting its minification and magnification filter types,
    how the texture coordinates are treated before sampling the texture, and everything
    else that Vulkan allows to be controlled in an object of this type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last thing to notice about the listing is that while creating objects in
    Vulkan, the handle to the object is not returned from the function but is stored
    in a pointer passed to the function. In our preceding example, the handle to the
    new sampler will be stored in the variable sampler (the last parameter to the
    `vkCreateSampler` function). That’s why we’re passing the address of the local
    variable to the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The reason for that is that most functions in the API return a result denoting
    whether the operation was successful or not. In most cases, checking the return
    value, of type `VkResult`, against `VK_SUCCESS` is fine (and displaying a message
    on screen or terminating), but in a few cases, the result may not represent an
    irrecoverable error but a situation that needs to be rectified before we can continue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This pattern is so common that we use a simple utility macro that checks the
    return value. If the result is anything different than `VK_SUCCESS`, it prints
    a message, along with the stringified error code, and asserts. Check it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Vulkan objects are created almost always the same way: by providing their attributes
    in a structure, calling a `create` function, and providing a pointer to store
    the handle to the newly created object. Most functions return a `VkResult` value
    that can be used to check whether the function succeeded or not.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Vulkan objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Vulkan API is extensive and many times larger than OpenGL (in any way you’d
    like to measure). Nonetheless, only a handful of very important objects are necessary
    to write many types of applications. As mentioned at the beginning of this chapter,
    the Vulkan API was leveled against the most demanding applications, those that
    need to control every single minute detail of the hardware to extract the maximum
    performance. But most applications don’t need all that flexibility and can get
    by with just the *basics*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn what Vulkan objects are and how they relate to
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects in Vulkan are opaque handles, and their types begin with the letters
    `Vk`. A Vulkan instance is called `VkInstance`, a Vulkan device is called `VkDevice`,
    and so on. Some objects need an instance of other objects to be created or allocated
    from. This dependency creates an implicit logical sequence as to object creation.
    A Vulkan physical device, `VkPhysicalDevice`, which represents a GPU on the system,
    can only be created if a Vulkan instance, `VkInstance`, already exists. The next
    section will present a diagram that may be helpful in understanding Vulkan’s capabilities
    and *when* objects may be created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 1**.1* is a summary of what we consider the most important objects
    in Vulkan; the ones that we cover in this book and that will satisfy most graphics
    applications. They are also the bare minimum for a simple – but flexible – program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Object dependency in Vulkan](img/B18491_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Object dependency in Vulkan
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, each node is a Vulkan object with its name on the
    top half and its Vulkan type in the bottom half. The diagram also encodes the
    dependency between the objects, explicit and implicit. The arrows connecting objects
    denote what an object needs to be created (besides their parameters, which are
    not depicted there).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Solid arrows are explicit dependencies: an object needs a reference to all
    objects pointed by the arrows leaving its node. For example, a device needs a
    reference to a physical device to be created; a buffer view needs a reference
    to a buffer and the device. Dashed arrows indicate implicit dependencies: a queue
    object needs a reference to a device, but it doesn’t explicitly need a reference
    to a physical device, only a queue index to a family of queues, which is obtained
    from a physical device. It doesn’t need a physical device, but it needs something
    that is provided by one.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solid lines with an open arrow at the end denote objects that are allocated
    from others, generally a pool of those types of objects. A command buffer isn’t
    created; it is allocated from a command pool (which in turn needs to be created
    at some point).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This diagram is useful for the beginner because it helps visualize multiple
    dependencies that aren’t exactly obvious. The descriptor set is one of those objects:
    to obtain one, you need a reference to a descriptor set layout. They are not created
    by the application; they are allocated from a descriptor pool. Finally, a descriptor
    set references buffers, image views, and samplers. They are not required, and
    that’s why that type of relation in the diagram represents an optional reference.
    We’ll talk more about descriptor sets in [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*,
    Working with* *Modern Vulkan.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the remainder of this chapter and the next chapter, we will cover the creation
    of all objects in the diagram in the order that they would usually be implemented.
    That means starting at the top with the Vulkan instance and moving downward, fulfilling
    the dependencies represented in the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Using Volk to load Vulkan functions and extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Volk is an open source library created by Arseny Kapoulkine that provides simple
    cross-platform support for loading Vulkan functions. The library provides several
    key features, the most important ones being automatically loading Vulkan’s function
    pointers and providing cross-platform support.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use Volk to load Vulkan functions and
    their extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download Volk from [https://github.com/zeux/volk](https://github.com/zeux/volk)
    and add `volk.c` to your project and enable the preprocessor defines for your
    platform, `VK_USE_PLATFORM_WIN32_KHR`, `VK_USE_PLATFORM_XLIB_KHR`, `VK_USE_PLATFORM_MACOS_MVK`,
    and so on, before including `volk.h`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Volk automatically loads Vulkan’s function pointers, so you don’t have to manually
    handle the details of loading them and checking for available extensions. If you
    use Volk in your application, do not link against the static version of the Vulkan
    library (`VKstatic.1.lib` on Windows) or load the shared library directly (such
    as `vulkan-1.dll` on Windows). Volk will do that for you.
  prefs: []
  type: TYPE_NORMAL
- en: Call `volkInitialize()` during the application’s startup process, before any
    other Vulkan functions are used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `volkLoadInstance` after the creation of the Vulkan instance. It replaces
    global function pointers with functions retrieved with `vkGetInstanceProcAddr`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `volkLoadDevice` after the creation of the Vulkan logical device. It replaces
    global function pointers with functions retrieved with `vkGetDeviceProcAddr`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Vulkan extensions correctly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vulkan relies heavily on extensions. Extensions are functions and types that
    are part of the *Vulkan Specification*; they are provided in addition to the core
    API but aren’t guaranteed to exist for a particular version of the API. Either
    they are experimental or vendor- and card-specific and are not guaranteed to be
    present, either at compile time or runtime. Official extensions are registered
    with the Khronos Group and are part of the spec, so you can find their documentation
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extensions may be introduced to a *Vulkan Specification* version and later
    promoted to the core set of functionalities on a newer version. Or not at all!
    The functionality to present rendering results to a surface (such as a window
    on a GUI), for example, is still an extension even in Vulkan 1.3 (the most recent
    version as of the writing of this book). If you are curious, here’s a link to
    it, the `VK_KHR_surface` device extension: [https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.2* offers a high-level overview of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Vulkan extensions](img/B18491_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Vulkan extensions
  prefs: []
  type: TYPE_NORMAL
- en: 'Vulkan version 1.1, for example, contains its core functionality – functions
    and types present in that version – plus extensions. Some, all, or none of those
    extensions may be promoted to the core set of functionalities in Vulkan 1.2\.
    Some might be considered deprecated and removed. The same thing happens when the
    specification is updated to version 1.3: some, all, or none of those extensions
    may be promoted from version 1.2 to the new version, and some might be deprecated.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will present the right way to deal with extensions during
    compile time and during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of extensions in Vulkan: instance- and device-level extensions.
    Before using an extension, you need to check if it is available during compile
    time and only add code that uses the extension if the extension is available.
    Generally speaking, you don’t need to check extensions at runtime. You also need
    to request the instance or device to enable the extensions by providing the name
    of the extension as a string.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to an extension being present at compile time, you need to enable
    it at the right level (instance or device) and check if it has been enabled just
    before using it at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern of checking whether a particular extension can be used at compile
    time and runtime is shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Besides new functions and types, the Vulkan SDK offers macros for each extension.
    Those macros can be used to check whether they are present, their name, and version.
    In the preceding listing, a `VK_KHR_win32_surface` macro is defined and set to
    `1` if the extension is available. The `VK_KHR_WIN32_SURFACE_EXTENSION_NAME` macro
    defines a `const char *` as the name of the extension (in this case, it is `VK_KHR_win32_surface`)
    and a `VK_KHR_WIN32_SURFACE_SPEC_VERSION` macro, defined as an integer, that specifies
    its version number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before creating an instance of `VkWin32SurfaceCreateInfoKHR`, we check if the
    `VK_KHR_win32_surface` device extension is present and enabled. The code is guarded
    by an `+#if+` directive, and if the extension is present, we proceed to check
    if it’s enabled at runtime using the `VK_KHR_WIN32_SURFACE_EXTENSION_NAME` macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This check is especially important if you are writing cross-platform code. While
    it may seem obvious that some extensions should be available, they may not be
    available for all platforms or graphics cards you are planning to support.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Validation Layer for error checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the spirit of a high-performant, low-overhead API, Vulkan does not perform
    error-checking by default. Doing so would incur a performance penalty, which may
    be unacceptable for some applications. On the other hand, due to Vulkan’s complexity,
    it is very easy for the application to make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: To help application authors detect errors, Vulkan provides layers, which can
    be enabled during development and later disabled for shipping. That combination
    isn’t mandatory, as developers don’t have to enable error-detecting layers for
    testing nor disable them for shipping, although that is the most common scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will introduce what Vulkan layers are and how their messages
    are presented, as well as offer tips on how to learn more about the meaning of
    those messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layers are provided with the Vulkan SDK, so if you are using Vulkan, chances
    are you also have access to layers by default.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layers are implementations of Vulkan functions that can be inserted in the call
    chain, intercepting entry points into the API. Those implementations can then
    perform error checking, performance measurements, or even detect possible optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: The Vulkan SDK provides a few layers that are **Plug and Play** (**PnP**). The
    only work you need to do is find which layers are present and enable them for
    the Vulkan instance. After that, at runtime, layers should start doing their jobs
    as soon as you start calling Vulkan functions.
  prefs: []
  type: TYPE_NORMAL
- en: The most important layer available in the SDK is the Validation Layer. This
    layer will validate all Vulkan function calls and their parameters. It also maintains
    an internal state – which Vulkan does not – to ensure that your application is
    not missing a synchronization step or using the wrong layouts for images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an example, the following message shows a real message displayed by the
    Validation Layer. Although somewhat cryptic, the message is very useful: it starts
    by displaying the error ID (`VUID-VkSamplerCreateInfo-sType-sType`), which you
    can use to search for it on the web; it also displays the device associated with
    the error; and finally, it displays the message ID and text, which informs us,
    in this example, that the structure we used to create a sampler (`VkSamplerCreateInfo`)
    needs to have its `sType` member equal to `VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Even the most experienced graphics programmers will face Validation Layer errors.
    Getting used to how they look and how to figure out what they mean is the first
    step in writing a Vulkan application that is Validation Layer error-free.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating available instance layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enabling an instance layer is as easy as providing its name as a `const char
    *` to the instance creation function. Unfortunately, not all layers exist in all
    implementations, and we need to check the available ones before trying to enable
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to enumerate the available instance layers
    and how to transform them into strings so that they are easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code snippets shown in this section are part of our `Context` class.. It
    encapsulates most of the initialization and object creation functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checking the available extensions is easy to do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to query the number of extensions using the `vkEnumerateInstanceLayerProperties`
    function, create an array of `VkLayerProperties` big enough to store all extensions,
    and request their data by issuing a call to the same function again, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second call to `vkEnumerateInstanceLayerProperties` will store all available
    layers in the `layers` vector, which then can be used for querying, diagnostics,
    and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With that information in hand, it’s always a good idea to verify whether the
    layers you are trying to enable are available. Since the instance creation function
    accepts the name of the layers in `const char *` format, we need to convert the
    extension names to strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the requested layers need to be filtered according to the available
    ones. With two vectors of strings, one for the available layers and one for the
    requested layers, we can use the following utility function to perform filtering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function is very handy because instance layers and instance and device
    extensions are all referred to by their names as `const char*`. This function
    can be applied to filter all layers and extensions you need in Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating available instance extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same process of filtering requested layers against available ones should
    be repeated for instance extensions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to obtain available instance extensions,
    how to store them as strings, and how to convert them to pointers to characters
    so that they can be passed to the Vulkan API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process is very similar to the one described in the previous recipe, which
    also includes a utility function to perform an intersection of the available layers
    and the requested ones.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obtaining a list of extensions is as easy as obtaining the available layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, call `vkEnumerateInstanceExtensionProperties` twice, once to determine
    how many extensions are available and then one more time to fetch the extensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can filter the requested layers and extensions using the list of
    available layers and extensions from the previous steps. Notice that we are requesting
    the Validation Layer and guarding all extensions with a conditional preprocessor
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To pass the vectors of strings to the API, we need to convert them to vectors
    of `const char*` because the API only accepts `const char*` parameters. We also
    need to perform the same conversion for the vector of instance layers (which is
    omitted here for brevity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `instanceExtensions` vector must *not* outlive the `enabledInstanceExtensions`
    vector. As `instanceExtensions` contains pointers to the strings in `enabledInstanceExtensions`,
    once the latter is destroyed, the pointers in `instanceExtensions` would all be
    dangling.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Vulkan instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start using Vulkan, we need to create a Vulkan instance. One can think of
    a Vulkan instance as a way of initializing the Vulkan library. To create one,
    you need to provide a set of required and optional information such as application
    name, engine name, version, and a list of desired layers and extensions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create a Vulkan instance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instantiating the `VkApplicationInfo` structure used to create an instance requires
    the version of the application and the Vulkan API version. The former can be created
    using the `VK_MAKE_VERSION` macro, while the latter can be provided as one of
    the preprocessor definitions available in the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all of those in hand, all we need to do is create a Vulkan instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an instance of the `VkApplicationInfo` structure first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will also need an instance of the `VkInstanceCreateInfo` structure with
    the requested instance layers and extensions. Then, call `vkCreateInstance`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the Vulkan instance has been created, you should keep it stored safely,
    as it will need to be destroyed before your application exits.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a surface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as in OpenGL, presenting the final render output to the screen needs support
    from the windowing system and is platform-dependent. For this reason, the Vulkan
    Core API does not contain functions to render the final image to the screen. Those
    functions and types are extensions. For this recipe, we’ll use the `VK_KHR_surface`
    and `VK_KHR_swapchain` extensions. We will cover only the Windows case here and
    use the `VK_KHR_win32_surface` extension.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create a surface for presenting the final
    output of your rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in the process of rendering an image onto the screen starts with
    the creation of a `VkSurfaceKHR` object. Since this object is needed while reserving
    queues from a physical device, this step is done after the instance has been created
    but before the physical devices are enumerated and before the device is created,
    as the device needs information about which queue families we will use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a `VkSurfaceKHR` object is simple but needs support from the windowing
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, you need an instance handle to the executable a (`HINSTANCE)` and
    a window handle (`HWND`) for where to present the image. We’re using GLFW, so
    the window used by the `VkWin32SurfaceCreateInfoKHR` structure can be obtained
    with `glfwGetWin32Window(GLFWwindow*)`. The handle to the `VkSurfaceKHR` object
    is stored in `Context::surface_`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The surface creation varies slightly between platforms, but the process is very
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Vulkan physical devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can create a device in Vulkan, we need to select a suitable physical
    device, as a system may have multiple Vulkan-capable GPUs and we want to choose
    one with the capabilities required by our application. To do this, we need to
    enumerate all available physical devices on the system. This can be achieved by
    calling the `vkEnumeratePhysicalDevices` function, which returns a list of all
    physical devices on the system that support the Vulkan API. Once we have the list
    of physical devices, we can inspect their properties and features using the `vkGetPhysicalDeviceProperties`
    and `vkGetPhysicalDeviceFeatures` functions to determine if they have the required
    capabilities. Finally, we can choose the most suitable physical device and use
    it to create a logical device through the `vkCreateDevice` function.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to enumerate all Vulkan-capable devices present
    in the system so that you can choose one that best fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our code, we encapsulate a physical device in a class called `VulkanCore::PhysicalDevice`,
    which retrieves a physical device’s properties and stores them for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Also, make sure to check out the `Context::choosePhysicalDevice()` method if
    you’d like to use a better heuristic to choose one physical device on systems
    that have multiple devices that support Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enumerating physical devices employs the same pattern used throughout the API,
    which requires us to first request the number of items available and then fetch
    and store them into a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vkEnumeratePhysicalDevices` is called twice, first to query how many objects
    are available, and a second time to fetch the handles to `VkPhysicalDevice` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns a vector of `PhysicalDevice` objects. In the code, this
    list is passed to the `Context::choosePhysicalDevice()` helper method, which can
    be used to select an appropriate physical device based on the requested extensions
    and other GPU capabilities you may need. For the sake of simplicity, we always
    choose the first physical device from the list.
  prefs: []
  type: TYPE_NORMAL
- en: Caching the properties of queue families
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Vulkan, a physical device can have one or more queue families, where each
    queue family represents a set of command queues that share certain properties,
    such as capabilities or usage. *Figure 1**.3* depicts a fictional set of families
    and their queues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Queue families and their queues](img/B18491_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Queue families and their queues
  prefs: []
  type: TYPE_NORMAL
- en: Each queue family supports a specific set of operations and commands that can
    be executed in parallel. For example, there may be a graphics queue family, a
    compute queue family, and a transfer queue family, each optimized for different
    types of operations.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to retrieve the properties of a queue family
    and where they are stored in the code in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the repository provided with this book, queue families and their properties
    are stored and managed by the `VulkanCore::PhysicalDevice` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each queue family has its own set of properties, such as the number of queues,
    the type of operations it can perform, and the priority of the queues. When creating
    a logical device, we must specify which queue families and how many queues of
    each type we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To query the queue families available and their properties, use the `vkGetPhysicalDeviceQueueFamilyProperties`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The properties of the families are stored in `std::vector<VkQueueFamilyProperties>
    PhysicalDevice::queueFamilyProperties_`.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating physical device extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physical device extensions must be explicitly enabled by the application and
    may only be available on specific physical devices or device drivers. It’s important
    to check for the availability of required extensions and to gracefully handle
    situations where extensions are not supported.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to enumerate all physical device extensions
    and how to convert and store them to strings for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enumerating physical device extensions is managed by the `VulkanCore::PhysicalDevice`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obtaining all physical device extensions for a physical device is simple. Here,
    we also provide code to store them as strings so that they are easier to work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enumerating all physical device extensions is done by using the `vkEnumerateDeviceExtensionProperties`
    function. The result is an array of `VkExtensionProperties`. This structure contains
    information such as the extension name, version, and a brief description of the
    extension’s purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the extension’s name to `std::string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This array is processed so that we end up with only the names of the extensions
    as strings. Further processing filters the requested extensions against the available
    ones using our `filterExtensions` utility function and stores them in `std::unordered_set<std::string>`
    `PhysicalDevice::enabledExtensions_`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In summary, mastering the enumeration of physical device extensions is an important
    aspect of Vulkan. It ensures optimal utilization of your device’s capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Reserving queue families
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vulkan, a queue family is a group of one or more queues that share common
    properties, such as the type of operations they can perform. When creating a Vulkan
    device, we must specify which queue families we want to use and how many queues
    of each family we need.
  prefs: []
  type: TYPE_NORMAL
- en: For rendering and presentation, we typically need at least one graphics queue
    family, which is responsible for executing graphics commands. Additionally, we
    may require a compute queue family for executing compute workloads and a transfer
    queue family for handling data transfers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to find queue families based on their properties
    and how to select a queue family that supports presentation, which can be used
    to present the final render output on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the repository, reserving queues is encapsulated by the `VulkanCore::PhysicalDevice`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One additional step necessary before creating a Vulkan device is to gather the
    indices to the queue families we’d like to use. For that, we created a `PhysicalDevice::reserveQueues()`
    method in the `PhysicalDevice` class to handle the process, which takes the type
    of queues we’d like to reserve as a parameter. It also takes a handle to a Vulkan
    surface (`VkSurfaceKHR`), which we will use later to verify whether a queue supports
    presentation, necessary to display the final render on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We iterate over the queue families properties, stored in `queueFamilyProperties_`,
    and store the index to the queue family index if its type has been requested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To detect if a queue family supports presentation, we use the `vkGetPhysicalDeviceSurfaceSupportKHR`
    function, guarded by the preprocessor macros:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The indices of other types of queue families may be obtained in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Vulkan logical device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Vulkan device is a logical representation of a physical GPU. It’s an object
    that is associated with a selected physical device (an existing GPU in the system)
    and is used to perform all graphics and compute operations. The device also provides
    access to physical GPU capabilities through queues. Queues are used to submit
    commands to the GPU, such as draw calls or memory transfers. The device also provides
    access to other Vulkan objects, such as pipelines, buffers, and images.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create a Vulkan logical device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in this recipe is available as part of the `VulkanCore::Context` class
    in the repository. The `Context` class represents a Vulkan logical device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a Vulkan device, we need to provide a physical device and the indices
    of the queue families we want to use. Using this information, we can create a
    vector of `VkDeviceQueueCreateInfo` structures, which determines the number of
    queues we want to use from each family and their respective priorities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common use case for creating a device is to use one queue per family
    and set its priority to `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The list of requested device extensions is converted from strings to `const
    char*`, filtered against the available extensions, and added to the `VkDeviceCreateInfo`
    structure, along with the index of the families we’d like to use and the layers
    we’d like to enable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A Vulkan device is one of the most important objects you need, as it’s needed
    to create almost every other Vulkan object there is.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the queue object handle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the logical device has been created, we need to obtain the handle to queues.
    That is accomplished with the `vkGetDeviceQueue` function. This handle will be
    used to submit command buffers for processing on the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to obtain the handle to a Vulkan queue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the repository, all queues are retrieved and stored by the `VulkanCore::Context`
    class. That class maintains a list for each type of queue: graphics, compute,
    transfer, and sparse, along with a special queue for presentation.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To retrieve the handle to a queue, just call the `vkGetDeviceQueue` function
    with the queue family index and the queue index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Knowing which queue families are available is not enough. Once we determine
    which queues are available and the queues we need, we request the handle to one
    of the queues from the family using the API presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a command pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Command buffers** provide the ability to record graphics and compute commands,
    while command queues allow those buffers to be submitted to the hardware. Commands
    recorded in the command buffers are then executed by the GPU.'
  prefs: []
  type: TYPE_NORMAL
- en: Each queue is associated with a specific queue family, which defines the capabilities
    of the queue. For example, a queue family may only support graphics operations,
    or it may support both graphics and compute operations. The number of families
    and their capabilities can be retrieved using the `vkGetPhysicalDeviceQueueFamilyProperties`
    function, discussed in the *Caching the properties of queue families* recipe.
    A queue family may contain one or more queues.
  prefs: []
  type: TYPE_NORMAL
- en: Command buffers are containers for the actual commands that are executed by
    the GPU. To record commands, you allocate a command buffer, then use the `vkCmd*`
    family of functions to record the commands into them. Once the commands have been
    recorded, the command buffer can be submitted to a command queue for execution.
  prefs: []
  type: TYPE_NORMAL
- en: Command buffers are allocated from a command pool, which in turn is created
    from a device and is associated with a specific queue family.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create a command pool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command pools and allocating and submitting command buffers is managed by the
    `VulkanCore::` `CommandQueueManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a command pool is easy. All you need is the queue family index and
    a creation flag. The `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` flag is
    enough for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a command pool, use the `vkCreateCommandPool` function. The `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    flag means that each command buffer allocated from this pool may be reset individually
    or implicitly by calling `vkCmdBeginCommandBuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With a command pool object, you can start allocating command buffers for recording
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating, recording, and submitting commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command buffers are allocated from command pools using the `vkAllocateCommandBuffers`
    function. Command buffers must be initialized with the `vkBeginCommandBuffer`
    function before being recorded into the buffer and prepared for submission with
    `vkEndCommandBuffer`. Commands are recorded into the buffer between those function
    calls and are executed only after the command buffer is submitted to the device
    with `vkQueueSubmit`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to allocate command buffers, how to record
    commands in the command buffer, and how to submit them for execution on the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command buffers are allocated from the `VulkanCore::CommandQueueManager` class
    and submitted using the same class. `VulkanCore::CommandQueueManager` provides
    basic functions to maintain a set of command buffers for processing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A command buffer’s life cycle starts with its allocation from a command pool.
    Once it has started, commands can be recorded into it. Before submission, you
    need to explicitly message them that recording has ended. They can then be submitted
    for execution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To allocate command buffers, you call `vkAllocateCommandBuffers`, passing in
    the command pool, the number of buffers you want to allocate, and a pointer to
    a structure that specifies the properties of the command buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After successfully allocating a command buffer, the recording of Vulkan commands
    can begin. The recording process is initiated through a call to the `vkBeginCommandBuffer`
    function, with parameters including the command buffer and a pointer to a structure
    that defines recording properties. Once recording is completed, the `vkEndCommandBuffer`
    function is called to finalize the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are some examples of commonly used commands that can be recorded in a
    Vulkan command buffer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`vkCmdBindPipeline`: Binds a pipeline to the command buffer. This command sets
    the current pipeline state for subsequent draw calls.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vkCmdBindDescriptorSets`: Binds descriptor sets to the command buffer. Descriptor
    sets hold references to buffer and image resources that can be used by shaders.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vkCmdBindVertexBuffers`: Binds vertex buffers to the command buffer. Vertex
    buffers contain the vertex data for a mesh.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vkCmdDraw`: Executes a draw call, which processes vertices and rasterizes
    the resulting pixels.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vkCmdDispatch`: Executes a compute shader.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vkCmdCopyBuffer`: Copies data from one buffer to another.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vkCmdCopyImage`: Copies data from one image to another.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you are done recording commands, you must call `vkEndCommandBuffer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once a command buffer has been recorded, it still lives in your application
    and needs to be submitted to the GPU for processing. That is accomplished by the
    `vkQueueSubmit` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, the fence is a specific Vulkan object that facilitates
    synchronization between the GPU and the CPU. The `vkQueueSubmit` function is an
    asynchronous operation that does not block the application. Therefore, once a
    command buffer is submitted, we can only determine whether it has been processed
    by checking the status of the fence using functions such as `vkGetFenceStatus`
    or `vkWaitForFences`. See the *Understanding synchronization in the swapchain
    – fences and semaphores* recipe to understand how fences can be used to synchronize
    your application and the execution of commands submitted to the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing command buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command buffers can be recorded once and submitted multiple times. They can
    also be used once and reset before the next use or just recorded, submitted, and
    discarded.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to reuse a command buffer without creating
    a race condition between your application and the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code provided in `VulkanCore::CommandQueueManager` doesn’t synchronize command
    buffers but provides functions to help you do so, such as `goToNextCmdBuffer`,
    `waitUntilSubmitIsComplete`, and `waitUntilAllSubmitsAreComplete`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using command buffers can be accomplished in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a command buffer and reuse it indefinitely. In this case, once the command
    buffer is submitted, you must wait for it to be processed before starting to record
    new commands. One way to guarantee that the buffer has finished being processed
    is by checking the status of the fences associated with it. If the fence is to
    be reused, you need to reset its state as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Figure 1**.4* shows the case where the command buffer submitted for processing
    is reused immediately after being submitted for processing on the GPU. Without
    any form of synchronization, reusing the command buffer will result in a race
    condition, as it may be still processing in the GPU:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Recording and submitting command buffers without using fences](img/B18491_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Recording and submitting command buffers without using fences
  prefs: []
  type: TYPE_NORMAL
- en: 'By using fences, as depicted in *Figure 1**.5*, it’s possible to prevent a
    race condition by checking the state of the fence associated with a command buffer
    before reusing it. If the fence has been signaled, no wait is necessary, but if
    the fence has not been signaled before reusing a command buffer, the application
    must wait for it to be signaled before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Recording and submitting command buffers using fences](img/B18491_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Recording and submitting command buffers using fences
  prefs: []
  type: TYPE_NORMAL
- en: Allocate command buffers as needed. This is the easiest approach. Whenever you
    need to record and submit commands, just allocate a new command buffer from the
    pool, record commands, submit it, and forget about it. In this case, you need
    to pass the `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT` flag when creating the command
    pool. You might still need a fence associated with the buffer if you need to track
    the state of resources used by the commands in that buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limiting the number of command buffers your application uses is a good practice
    that can help reduce the amount of memory your program needs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating render passes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A render pass object represents a series of rendering operations that read
    from and write to images. It’s a high-level abstraction that helps the GPU optimize
    the rendering process. An attachment in Vulkan is a reference to an image that
    is used as a target during a render pass. Attachments can be color attachments
    (for storing color information) or depth or stencil attachments (for storing depth/stencil
    information). *Figure 1**.6* shows an overview of what a render pass object consists
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Render pass and framebuffer composition](img/B18491_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Render pass and framebuffer composition
  prefs: []
  type: TYPE_NORMAL
- en: The `VkAttachmentDescription` structure is used when creating a render pass
    in Vulkan to define the properties of each attachment. The `initialLayout` and
    `finalLayout` fields play a crucial role in optimizing the usage of attachments
    and layout transitions during the render pass execution. By setting the initial
    and final layouts correctly, you can avoid using additional pipeline barriers
    to transition image layouts, as these transitions are automatically managed by
    the render pass execution. For example, if you can have a color attachment that
    is initially in the `VK_IMAGE_LAYOUT_UNDEFINED` layout and should transition to
    the `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` layout at the end of the render pass, you
    can set the `initialLayout` and `finalLayout` fields accordingly. This eliminates
    the need for an explicit pipeline barrier to handle the transition, as the render
    pass will automatically perform the layout transition as part of its execution.
  prefs: []
  type: TYPE_NORMAL
- en: A subpass is a part of a render pass that performs a specific rendering operation.
    Attachments are loaded for each subpass, read and/or written to, and finally stored
    at the end of the subpass. Load and store operations define whether an attachment’s
    contents should be loaded, cleared, or not cared about (which means the driver/hardware
    is free to choose what to do – or what not to do) while being loaded and whether
    they should be stored or not cared about when stored at the end of the pass. They
    have a significant impact on performance, especially on mobile GPUs. For mobile
    GPUs, minimizing the number of load/store operations can lead to significant performance
    improvements. By using `VK_ATTACHMENT_LOAD_OP_DONT_CARE` and `VK_ATTACHMENT_STORE_OP_DONT_CARE`
    when possible, we can avoid unnecessary memory bandwidth usage, which is a common
    bottleneck on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: A subpass dependency describes the order in which subpasses should be executed
    and the synchronization required between them. On mobile GPUs, using multiple
    subpasses can help reduce memory bandwidth usage by keeping intermediate data
    in on-chip memory (tile-based rendering). This avoids the need to write and read
    back data from the main memory, which can be expensive in terms of power consumption
    and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Vulkan also supports render pass compatibility, which allows a framebuffer created
    for one render pass to be used with another compatible render pass, enhancing
    resource utilization and performance. Compatibility requires matching attachment
    counts, formats, load/store operations, sample counts, and compatible layouts;
    however, subpass structures can differ.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create render passes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creation of a render pass isn’t complicated but requires an assortment of
    information that is easier to manage if encapsulated in its own class. This way,
    the destructor of the class can take care of destroying the object at the right
    time, without us having to add code to deal with its destruction.
  prefs: []
  type: TYPE_NORMAL
- en: Render passes are wrapped by the `VulkanCore::RenderPass` class in the code
    provided with the book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a render pass needs a list of all attachments that will be used in
    that pass, along with their load and store operations and the final layout desired
    for each one of the attachments. A render pass must be associated with a type
    of pipeline (graphics, compute, and so on), so the constructor also takes a value
    of type `VkPipelineBindPoint`.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample shows one of the constructors of the `VulkanCore::RenderPass`
    class. Be aware that we have not yet introduced Vulkan images (which are encapsulated
    in the `Texture` class in the code). We will discuss images in more detail in
    [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*, Working with Modern Vulkan,*
    in the *Creating images (**textures)* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor iterates over all attachments that will be used in the render
    pass and creates a `VkAttachmentDescription` structure for each one. This structure
    contains basic information that is extracted from the attachments themselves (such
    as format and initial layout), but it also records what to do with each attachment
    when it is loaded and stored. While iterating over all the attachments used in
    the render pass, we create two other auxiliary variables: one list with the indices
    of attachments that are of type color (`colorAttachmentReferences`) and a variable
    that stores the index of the attachment that is depth and/or stencil (`depthStencilAttachmentReference`),
    since render passes only support one depth/stencil attachment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each attachment, create a `VkAttachmentDescription` structure and append
    it to the `attachmentDescriptors` vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the attachment is a depth or a stencil texture, create a `VkAttachmentReference`
    structure for it and store it in the `depthStencilAttachmentReference` auxiliary
    variable. Otherwise, the attachment is a color attachment, and we create and store
    a `VkAttachmentReference` structure to the `colorAttachmentReferences` vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `RenderPass` class only creates one subpass, which stores the color attachment
    references and the depth/stencil attachment reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only subpass we use for this recipe depends on an external subpass (since
    there’s only one subpass, it must depend on an external one):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, all this information is stored in a structure of type `VkRenderPassCreateInfo`,
    which is passed, along with the device, to create a render pass with `vkCreateRenderPass`.
    The handle is stored in the `RenderPass::renderPass_` member variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Destroying the render pass happens in the destructor, by calling the `vkDestroyRenderPass`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Render passes store information on *what to do* with attachments (loaded, cleared,
    stored) and describe subpass dependencies. They also describe which attachments
    are resolve attachments (see the *Enabling and using Vulkan’s MSAA* recipe in
    [*Chapter 6*](B18491_06.xhtml#_idTextAnchor283)*, Anti-Aliasing Techniques*, to
    know more about resolve attachments and how they are used to implement MSAA in
    Vulkan).
  prefs: []
  type: TYPE_NORMAL
- en: Creating framebuffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the render pass object contains information about what to do with each
    attachment and their initial and final layouts, a framebuffer contains actual
    references to the attachments used in the render pass, which are provided in the
    form of `VkImageViews`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create a framebuffer object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the repository, Vulkan framebuffers are encapsulated by the `VulkanCore::Framebuffer`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Framebuffers refer to attachments (it answers the question “Which attachments
    will we be using for this render pass?”).
  prefs: []
  type: TYPE_NORMAL
- en: 'The references are image views and are passed as a list, along with the handle
    of the render pass, to the `vkCreateFramebuffer` framebuffer creation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating framebuffers is straightforward, and they are not strictly necessary
    anymore if you use dynamic rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Creating image views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vulkan, an image view is a way to specify how an image should be interpreted
    and accessed by the GPU. It provides a view into an image’s memory and defines
    its format, dimensions, and data layout.
  prefs: []
  type: TYPE_NORMAL
- en: An image view can be thought of as a window into an image’s memory that describes
    how the image should be accessed. It allows the image to be used in a variety
    of ways, such as a source or destination for rendering commands, or as a texture
    in a shader.
  prefs: []
  type: TYPE_NORMAL
- en: Image views are created by specifying the image they will be associated with,
    along with a set of parameters that define the image’s format, aspect ratio, and
    range. Once created, an image view can be bound to a pipeline or shader to be
    used in rendering or other operations. They are represented by the `VkImage` type.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create image views.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the repository, image views are stored by the `VulkanCore::Texture` class
    and don’t have a dedicated wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before creating an image view, you need the handle a Vulkan image object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an image view is simple; all you need is the handle to a Vulkan image
    object (`VkImage`) and a few parameters that dictate how to access the underlying
    image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Image views can span an entire image (mip levels and layers), just one element
    (mip level or layer), or even just a portion of the image.
  prefs: []
  type: TYPE_NORMAL
- en: The Vulkan graphics pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The graphics pipeline is a crucial concept that describes the process of rendering
    graphics in a Vulkan application. The pipeline consists of a series of stages,
    each with a specific purpose, that take raw data and transform it into a fully
    rendered image on the screen. While some stages of the pipeline are more obvious,
    such as the viewport or rasterization, other stages such as the shader stage,
    vertex input, and dynamic states are less apparent but equally important. In the
    following recipes, we will explore some of the less obvious stages of the pipeline
    and explain their importance in the rendering process. *Figure 1**.7* shows an
    overview of all structures you may need to populate to create a graphics pipeline
    and their properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Vulkan graphics pipeline](img/B18491_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Vulkan graphics pipeline
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn a little more about pipelines in Vulkan and their
    most important characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the most important characteristics of pipelines in Vulkan:'
  prefs: []
  type: TYPE_NORMAL
- en: In Vulkan, graphics pipelines are mostly immutable objects, meaning that once
    they are created, they cannot be modified except in certain instances. This is
    why it is necessary to create a new pipeline with a different topology if you
    wish to reuse a pipeline to draw different shapes. However, some pipeline properties
    can be changed dynamically at runtime, such as the viewport and scissor rectangles,
    which are referred to as dynamic states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One important exception to the pipeline stages that won’t be covered in this
    book is the vertex input state. Although it is not entirely straightforward to
    create, we will not discuss it here since we exclusively utilize the **Programmable
    Vertex Pulling** (**PVP**) method to access indices and vertices at the vertex
    shader stage. For additional information about PVP, please refer to the *Implementing
    Programmable Vertex Pulling and Multi-Draw Indirect* recipe in [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*,
    Working with* *Modern Vulkan.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, the pipeline layout, a property of the graphics pipeline (and not
    a stage), is a data structure that outlines the anticipated layout of resources
    utilized by the shaders, including their location, quantity, and type, as well
    as pertinent details regarding push constants. Since this chapter does not provide
    any resources to the shaders, the pipeline layout is initialized with default
    values. Descriptor sets and push constants will be covered in [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*,
    Working with* *Modern Vulkan.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiling shaders to SPIR-V
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to OpenGL, which typically compiles shaders from high-level languages
    into binary format during runtime, Vulkan only supports an intermediate representation
    called SPIR-V. SPIR-V is a cross-platform, low-level intermediate representation
    that can be produced from various shading languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to compile GLSL to SPIR-V using the `glslang`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use a third-party library that compiles GLSL code into SPIR-V
    at runtime called `glslang`. It can be downloaded from [https://github.com/KhronosGroup/glslang.git](https://github.com/KhronosGroup/glslang.git).
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we provide the `VulkanCore::ShaderModule` class that encapsulates
    shaders. It provides the `ShaderModule::glslToSpirv` method (and overloads) that
    compiles shader source code from GLSL to SPIR-V.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps presented here are part of the `ShaderModule::glslToSpirv()` method.
    Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `glslang` library needs to be initialized once by calling `glslang::InitializeProcess()`,
    so its initialization is guarded by a static Boolean variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `TShader` object is instantiated by a function to contain shaders and various
    other parameters that are necessary for generating SPIR-V bytecode. These parameters
    include the input client and GLSL versions, as well as entry points into the shaders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterward, we collect constraints on resources that are typically available
    for shaders in the system, such as the maximum number of textures or vertex attributes,
    and establish messages that the compiler should present. Lastly, we compile the
    shader into SPIR-V and verify the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the last phase, linking options are established for both debug and release
    builds. In debug builds, regular debugging information is enabled while optimizations
    and debug information stripping are disabled. Conversely, in release builds, the
    optimizer is enabled, which may result in the removal of unused shader variables,
    including structure members. However, because discrepancies in structure sizes
    may cause problems if the same optimizations are not applied to the C++ code,
    optimizations are also disabled in release builds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For truly performant applications, shaders are not compiled from GLSL at runtime.
    They are compiled at build time and loaded from disk in the SPIR-V format when
    the application starts.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While **pipeline state objects** (**PSOs**) include immutable states, such as
    shader programs and vertex input bindings, some properties of a pipeline state
    can be changed dynamically at draw time using dynamic state objects. This feature
    provides greater flexibility and can minimize the necessity to recreate pipelines.
    Dynamic state objects can be used to change properties such as viewport and scissor
    rectangles, line width, blend constants, and stencil reference values. However,
    not all properties of a pipeline can be changed dynamically, and the use of dynamic
    states can have a small performance overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without using dynamic states, the application has a few alternatives available:'
  prefs: []
  type: TYPE_NORMAL
- en: Create pipelines during the application startup. If you are aware of which pipelines
    will be required, they can be created beforehand at the expense of a higher startup
    cost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Utilize pipeline caches. The graphics driver features a built-in mechanism for
    pipeline caching that can automatically generate a cache for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Several parameters, such as the viewport, line width, and depth bias, can be
    dynamically modified. While some dynamic states were included in Vulkan 1.0, others
    were added as extensions or included as part of Vulkan 1.3\. If a parameter is
    marked as dynamic (using the appropriate structure), its value is ignored during
    pipeline creation.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn about dynamic states, which allow some pipeline
    parameters to be dynamically set after a pipeline has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dynamic states are created using the `VkPipelineDynamicStateCreateInfo` structure.
    An instance of this structure is filled with states you would like to be dynamic
    and is later plugged into the creation of a pipeline, which we’ll cover in the
    next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To allow parameters to be dynamically set, we need to create an instance of
    the `VkPipelineDynamicStateCreateInfo` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code fragment shows how to enable the dynamic state for the viewport
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The previously created instance will be used in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a graphics pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once all the required states and pipeline properties have been gathered and
    instantiated, creating a graphics pipeline in Vulkan is a straightforward process.
    This involves populating the `VkGraphicsPipelineCreateInfo` structure and calling
    `vkCreateGraphicsPipelines`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create a graphics pipeline object in Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information, please refer to the constructor of the `VulkanCore::Pipeline`
    class in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Populating the structures referenced by `VkGraphicsPipelineCreateInfo` is not
    complicated, but a tedious task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all structures of all states have been instantiated, all we need to do
    is create an instance of `VkGraphicsPipelineCreateInfo` and call `vkCreateGraphicsPipelines`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a graphics pipeline is an expensive operation. One way to avoid the
    penalty of creating pipelines is to cache them and reuse them the next time your
    application runs.
  prefs: []
  type: TYPE_NORMAL
- en: Swapchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A swapchain in Vulkan mimics the functionality of double and triple buffering
    from OpenGL but with a more explicit role for the application in managing swapchain
    buffers. This approach provides better control over the configuration, synchronization,
    and presentation of images.
  prefs: []
  type: TYPE_NORMAL
- en: A Vulkan swapchain is a collection of images associated with a surface (`VkSurfaceKHR`)
    that are used to display rendering outputs in a window. Even though it is a key
    part of the Vulkan API, the functions and types used to create and manage a swapchain
    are part of the `VK_KHR_swapchain` extension.
  prefs: []
  type: TYPE_NORMAL
- en: The number of images in a swapchain object must be determined during its construction
    but must fall between the minimum (`minImageCount`) and maximum (`maxImageCount`)
    possible values provided by the device. Those values can be retrieved from the
    `VkSurfaceCapabilitiesKHR` structure of the Vulkan physical device.
  prefs: []
  type: TYPE_NORMAL
- en: Swapchain images (`VkImage`) are created and owned by the swapchain object and,
    as a result, their memory isn’t provided or allocated by the application. Image
    views (`VkImageView`) are not created by the swapchain object and thus must be
    created separately.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create, manage, and destroy swapchain
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The swapchain is managed by the `VulkanCore::Swapchain` class in the code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The swapchain extension provides a set of functions and types to create, manage,
    and destroy swapchains. Some key functions and types include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vkCreateSwapchainKHR`: This function is used to create a swapchain. You need
    to provide a `VkSwapchainCreateInfoKHR` structure that contains details about
    the surface, the number of images, their format, dimensions, usage flags, and
    other swapchain properties.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`vkGetSwapchainImagesKHR`: After creating a swapchain, this function is used
    to retrieve handles to the images in the swapchain. You can then create image
    views and framebuffers for rendering and presentation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`vkAcquireNextImageKHR`: This function is used to acquire an available image
    from the swapchain for rendering. It also requires providing a semaphore or fence
    to signal when the image is ready for rendering.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`vkQueuePresentKHR`: Once rendering is complete, this function is used to submit
    the swapchain image for presentation on the display device.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`vkDestroySwapchainKHR`: This function is responsible for destroying the swapchain
    and cleaning up resources associated with it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding synchronization in the swapchain – fences and semaphores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application and the GPU processes run in parallel; unless specified otherwise,
    the command buffers and their commands also run in parallel on the GPU. To enforce
    an order between the CPU and the GPU, and between command buffers being processed
    in the GPU, Vulkan provides two mechanisms: **fences** and **semaphores**. Fences
    are used to synchronize work between the GPU and the CPU, while semaphores are
    used to synchronize workloads executed in the GPU.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn about fences and semaphores: why they are necessary,
    how they are used (and when), and how to use semaphores with a swapchain.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Examples of semaphores can be found in the `VulkanCore::Swapchain` class, while
    examples of fences can be found in the `VulkanCore::CommandQueueManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fences and semaphores have different uses. Let’s explore each one of those elements
    and how to use semaphores with swapchains.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.8* shows how an application, running on the CPU, may submit commands
    to the GPU and proceed with its work right after submission (without synchronization).
    This may be intended, but if you wish to wait for commands on the GPU to finish
    being processed before continuing, you may use a fence to signal when work on
    the GPU has been completed. Once commands on the GPU are finished processing,
    the fence is signaled, and the application may proceed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Command buffer recording and execution on the device without
    synchronization](img/B18491_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Command buffer recording and execution on the device without synchronization
  prefs: []
  type: TYPE_NORMAL
- en: 'Semaphores work in a similar manner but are used between commands or jobs running
    on the GPU. *Figure 1**.10* illustrates using a semaphore to synchronize commands
    being processed on the GPU. The application is responsible for creating semaphores
    and adding dependencies between command buffers and semaphores itself before submitting
    the buffers for processing. Once a task is processed on the GPU, the semaphore
    is signaled, and the next task can continue. This enforces an ordering between
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Fences](img/B18491_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Fences
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of acquiring an image, rendering, and presenting are all asynchronous
    and need to be synchronized. In this recipe, we will use two semaphores for the
    synchronization: `imageAvailable` and `imageRendered`. *Figure 1**.10* illustrates
    how semaphores affect the execution of commands on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – Semaphores](img/B18491_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – Semaphores
  prefs: []
  type: TYPE_NORMAL
- en: '`imageAvailable_` is signaled once the image acquired is available, prompting
    the command queue that will render into the image to start processing. Once the
    command buffer finishes, it signals the other semaphore, `imageRendered`, which
    in turn allows the presentation of that image to start. *Figure 1**.11* demonstrates
    how synchronization is implemented using two semaphores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Synchronization of the swapchain](img/B18491_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Synchronization of the swapchain
  prefs: []
  type: TYPE_NORMAL
- en: Fences and semaphores aren’t difficult to understand, but they are crucial for
    synchronization in Vulkan. Make sure you understand how they are used before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Populating submission information for presentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Submitting a command buffer requires an instance of the `VkSubmitInfo` structure,
    which allows specifying semaphores for waiting (to start processing) and signaling
    (once the command buffer finishes executing). Those semaphores are optional and
    usually not needed. But when submitting a command buffer for presenting images
    onto the screen, those semaphores allow Vulkan to synchronize the execution of
    the buffer with the presentation engine.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to submit a command buffer for processing
    by the GPU after it has been recorded.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `VulkanCore::Swapchain` class in the repository provides a utility function
    to fill the `VkSubmitInfo` structure for you since the semaphores used to synchronize
    the execution with the presentation engine are stored in the swapchain. If no
    semaphores are needed in the structure, the `waitForImageAvailable` and the `signalImagePresented`
    parameters should be set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The synchronization information used to submit command buffers that need to
    be synchronized with the presentation engine is provided by an instance of the
    `VkSubmitInfo` structure and contains references to the semaphores that will be
    used for synchronization in the device. It also contains the command buffer that
    will be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fence is associated with the command buffer and is not a specific one for
    synchronizing the swapchain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once a command buffer has been submitted for processing, it’s up to the driver
    and the GPU to execute the commands recorded there. The only way to know whether
    the command buffer has finished processing is by checking the fence provided to
    `vkQueueSubmit`.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Presenting an image onto the screen isn’t automatic in Vulkan. You need to call
    the `vkQueuePresentKHR` function along with an instance of the `VkPresentInfoKHR`
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to queue an image for presentation once it
    has finished rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The presentation in our code is done in the `VulkanCore::Swapchain::present()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Requesting an acquired image to be presented is done by calling `vkQueuePresentKHR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we need to provide the `imageRendered` semaphore, which indicates
    when the rendering process has finished using the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The image won’t be presented right away once `VkQueuePresentKHR` is called.
    This call merely sets up the synchronization mechanism so that Vulkan knows when
    the image can be sent for display.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a triangle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve learned about all basic Vulkan objects and how they work, we
    can finally create a small example application that displays a static shaded triangle
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will present a full example that renders a static triangle
    on the screen. The vertex data and attributes are statically provided in the vertex
    shader.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in this recipe can be found in the repository in `source/chapter1/main.cpp`.
    The vertex and fragment shaders are located in `source/chapter1/resources/shaders`,
    in the `triangle.vert` and `triangle.frag` files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code presented here is an unabridged version of the code in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we will use two shaders: `triangle.vert` and `triangle.frag`.
    The vertex shader does not accept any inputs, as all the data it needs is defined
    right there in the shader itself as two arrays: one for vertex data (`positions`)
    and the other for color data (`colors`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Both sets of data are sent to the output as-is without any transformations,
    as they are already in their respective output spaces (screen space for the position
    data and the output color space for the color data). The position is output through
    the built-in `gl_VertexIndex` variable, while the color is written to the `outColor`
    variable at location `0`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The fragment shader accepts the color data from the vertex stage and directly
    outputs it as the fragment color through the `outColor` variable at location `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We only need one render pass that will output the render result to a framebuffer
    with only one attachment, color attachment 0\. The color attachment’s load operation
    is *clear* as we will clear it for rendering, whereas the store operation is *store*
    as we want the output to be recorded into the attachment. The output will go straight
    into the swapchain, so the acquired swapchain image is the color attachment 0\.
    Since each render pass outputs directly onto the swapchain image, and a framebuffer
    is associated with an attachment and is immutable, we need the number of framebuffers
    to match the number of swapchain images. Each framebuffer will be associated with
    one swapchain image as the color attachment 0\. The shaders don’t need access
    to external buffers, such as vertex and index, or textures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first step is to initialize a window and create a context with the features
    we will use by default in this book. For more details, please refer to the `VulkanCore::VulkanFeatureChain`
    class in the repo. The context, which encapsulates the instance and the physical
    and logical devices, is initialized with a few useful extensions, one graphics
    queue, and the default features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The swapchain is initialized with a common format and color space, along with
    the extensions from the physical device. In this example, we use the **First In
    First Out** (**FIFO**) presentation mode because it’s the only mode that is supported
    by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Both shaders are initialized from the resources in the repo, along with a vector
    of framebuffers. The number of framebuffers matches the number of swapchain images,
    as we’ll need one framebuffer for each acquired image later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We only need one render pass with one subpass. A render pass isn’t associated
    with any resources. It only specifies the load and store operations of each framebuffer’s
    color attachment and their use by the subpasses. For this reason, we don’t need
    multiple render passes, like framebuffers do. One is enough, and it is reused
    for all swapchain images. The final layout of the color attachment 0, the swapchain
    image, is `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`, as it will be presented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we create a pipeline that contains mostly the default parameters.
    Besides the two shaders compiled before, we set the viewport to be the size of
    the output and disable depth testing. We then create a Command Queue Manager instance
    to manage the command buffers and their fences:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main render loop executes until the `GLFW` window is closed. On each iteration,
    we first acquire a swapchain image and its index. If a framebuffer for this swapchain
    image doesn’t exist yet, we create one. We then obtain a command buffer for rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before starting rendering, we begin the render pass by providing a clear color
    (black), and the render pass and framebuffer handles. We then bind the pipeline
    to the current command buffer, and we are ready to start rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we issue the draw call with three vertices and one instance. This
    call will invoke the vertex shader three times (one for each vertex), instantiating
    the `gl_VertexIndex` variable in the shader to 0, 1, and 2\. We use this variable
    to index into the position and color arrays in the shader itself. We then submit
    the command buffer and present the swapchain image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the render loop ends, and before exiting the program, we wait for all
    queues to finish processing before destroying all Vulkan objects in the opposite
    order in which they were created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of this recipe should look like *Figure 1**.12*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Recipe result](img/B18491_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – Recipe result
  prefs: []
  type: TYPE_NORMAL
- en: Vulkan is verbose and, as mentioned before, provides many ways to customize
    your graphics application. A simple example such as this needed around 1,000 lines
    of code! But there is no reason for panic. Most of that code can be reused (and
    will be reused) for the remainder of the book to explain all techniques and recipes
    in the text.
  prefs: []
  type: TYPE_NORMAL
