<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Porting a Game with Emscripten</h1>
                </header>
            
            <article>
                
<p class="mce-root">As demonstrated in <a href="79019325-2d3e-452c-b680-ac90522aa4bf.xhtml">Chapter 7</a>, <em>Creating an Application from Scratch</em>, WebAssembly is still relatively limited in its current form. Emscripten provides powerful APIs for extending WebAssembly's capabilities to add functionality to your application. Compiling to a WebAssembly module and JavaScript glue code (instead of an executable) can, in some cases, only require minor changes to the existing C or C++ source.</p>
<p class="mce-root">In this chapter, we're going to take a code base written in C++ that gets compiled to a traditional executable, and update the code so that it can be compiled to Wasm/JavaScript. We'll also add some additional features for tighter integration with the browser.</p>
<p class="mce-root">By the end of this chapter, you'll know how to do the following:</p>
<ul>
<li class="mce-root">Update a C++ code base to compile to a Wasm module/JavaScript glue code (instead of a native executable)</li>
<li class="mce-root">Use Emscripten's APIs to add browser integration to a C++ application</li>
<li class="mce-root">Build a multi-file C++ project with the proper <kbd>emcc</kbd> flags</li>
<li class="mce-root">Run and test a C++ application in the browser using <kbd>emrun</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of the game</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we're taking a Tetris clone written in C++ and updating the code to integrate Emscripten and compile to Wasm/JS. The code base in its original form compiled to an executable utilizes SDL2 and can be loaded from the command line. In this section, we're going to briefly review what Tetris is, how to get the code (without having to write it from scratch), and how to get it running.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is Tetris?</h1>
                </header>
            
            <article>
                
<p class="mce-root">In Tetris, the main objective of the game is to rotate and move pieces (<em>Tetriminos</em>) of various shapes within a playing field (<em>well</em> or <em>matrix</em>) to create a row of blocks without gaps. When a full row is created, it is deleted from the playing field and your score is increased by one. In our version of the game, there won't be a win condition (although it would be simple to add it).</p>
<p class="mce-root">It's important to understand the rules and mechanics of the game because the code uses algorithms for concepts such as collision detection and scoring. Understanding the goal of a function helps you understand the code within. I recommend you give it a try online if you need to brush up on your Tetris skills. You can play it at <a href="https://emulatoronline.com/nes-games/classic-tetris/">https://emulatoronline.com/nes-games/classic-tetris/</a> without having to install Adobe Flash. It looks just like the original Nintendo Version:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/60566c17-a951-44f8-a3f4-a1e2bf8c6115.png" style="width:32.00em;height:24.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Classic Tetris at EmulatorOnline.com</div>
<p class="mce-root">The version we'll be working with won't contain the piece counters, levels, or points (we're sticking to line counts), but it will operate in the same way.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The source of the source</h1>
                </header>
            
            <article>
                
<p class="mce-root">It turns out that a search for Tetris C++ provides a multitude of tutorials and example repositories to choose from. In the interest of sticking to the formatting and naming conventions that I've been using up to this point, I combined these resources to create my own version of the game. The <em>Further reading</em> section at the end of this chapter has links to these resources if you're interested in learning more. The concepts and process for porting a code base are applicable, regardless of the source. On that note, let's take a brief step-aside to discuss porting in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A note about porting</h1>
                </header>
            
            <article>
                
<p class="mce-root">Porting an existing code base to Emscripten is not always a simple task. There are several variables to take into account when evaluating whether a C, C++, or Rust application is amenable to conversion. For example, games that make use of several third-party libraries or even a few third-party libraries that are of considerable complexity may require a significant amount of effort. Emscripten provides the following commonly used libraries out of the box:</p>
<ul>
<li class="mce-root"><kbd>asio</kbd>: A network and low-level I/O programming library</li>
<li class="mce-root"><kbd>Bullet</kbd>: A real-time collision detection and multi-physics simulation library</li>
<li class="mce-root"><kbd>Cocos2d</kbd>: A suite of open source, cross-platform, game development tools</li>
<li class="mce-root"><kbd>FreeType</kbd>: A library used to render fonts</li>
<li class="mce-root"><kbd>HarfBuzz</kbd>: An OpenType text shaping engine</li>
<li class="mce-root"><kbd>libpng</kbd>: The official PNG reference library</li>
<li class="mce-root"><kbd>Ogg</kbd>: A multimedia container format</li>
<li class="mce-root"><kbd>SDL2</kbd>: A library designed to provide low-level access to audio, a keyboard, a mouse, a joystick, and graphics hardware</li>
<li class="mce-root"><kbd>SDL2_image</kbd>: An image file loading library</li>
<li class="mce-root"><kbd>SDL2_mixer</kbd>: A sample multi-channel audio mixer library</li>
<li class="mce-root"><kbd>SDL2_net</kbd>: A small sample cross-platform networking library</li>
<li class="mce-root"><kbd>SDL2_ttf</kbd>: A sample library that allows you to use TrueType fonts in your SDL applications</li>
<li class="mce-root"><kbd>Vorbis</kbd>: A general purpose audio and music encoding format</li>
<li class="mce-root"><kbd>zlib</kbd>: A lossless data compression library</li>
</ul>
<p class="mce-root">If the library isn't already ported, you will need to do it yourself. This would benefit the community, but requires a significant investment of time and resources. Our Tetris example only uses SDL2, which makes the porting process relatively simple.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting the code</h1>
                </header>
            
            <article>
                
<p class="mce-root">The code for this chapter is located in the <kbd>/chapter-08-tetris</kbd> folder of the <kbd>learn-webassembly</kbd> repository. There are two directories within <kbd>/chapter-08-tetris</kbd>: the <kbd>/output-native</kbd> folder, which contains the original (pre-ported) code and the <kbd>/output-wasm</kbd> folder, which contains the ported code.</p>
<div class="packt_infobox">If you want to use VS Code's <span class="packt_screen">Task</span> feature for the native build step, you'll need to open the <kbd>/chapter-08-tetris/output-native</kbd> folder in VS Code, not the top-level <kbd>/learn-webassembly</kbd> folder.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the native project</h1>
                </header>
            
            <article>
                
<p>The <kbd>/cmake</kbd> folder and <kbd>CMakeLists.txt</kbd> file within the <kbd>/output-native</kbd> folder are required to build the project. The <kbd>README.md</kbd> file contains instructions to get the code up and running on each platform. Building the project isn't necessary to work through the porting process. The process for installing the required dependencies and getting the project to build successfully on your platform can be time-consuming and complex. If you still wish to proceed, you can build the executable through VS Code's <span class="packt_screen">Task</span> feature by selecting <span class="packt_screen">Tasks</span> | <span class="packt_screen">Run Task...</span> from the menu and selecting <span class="packt_screen">Build Executable</span> from the list after following the instructions in the <kbd>README.md</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The game in action</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you were successful in building the project, you should be able to run it by selecting <strong><span class="packt_screen">Tasks</span></strong> | <strong><span class="packt_screen">Run Task...</span></strong> from the VS Code menu and selecting the <span class="packt_screen">Start Executable</span> task from the list. If everything was successful, you should see something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/34e1026f-bd47-4209-a611-671d81f98ede.png" style="width:19.42em;height:43.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Compiled game running natively</div>
<p class="mce-root">Our version of the game doesn't have a losing condition; it just increments the <span class="packt_screen">ROWS</span> count by one for each row you clear. If one of the Tetriminos touches the top of the board, the game is over and the board resets. It's a rudimentary implementation of the game, but additional features increase the complexity and amount of code required. Let's review the code base in more detail.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The code base in depth</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that you have the code available, you'll need to familiarize yourself with the code base. Without having a good understanding of the code you want to port, you'll have a much harder time porting it successfully. In this chapter, we're going to walk through each of the C++ class and header files and describe their roles in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breaking the code into objects</h1>
                </header>
            
            <article>
                
<p class="mce-root">C++ was designed around an object-oriented paradigm, which is what the Tetris code base uses to simplify management of the application. The code base consists of C++ class files</p>
<p class="mce-root">(<kbd>.cpp</kbd>) and header files (<kbd>.h</kbd>) that represent objects within the context of the game. I used the gameplay summary from the <em>What is Tetris?</em> section to extrapolate which objects I needed.</p>
<p class="mce-root">The game pieces (Tetriminos) and playing field (referred to as a well or matrix) are good candidates for classes. Maybe less intuitively, but still just as valid, is the <em>game</em> itself. Classes don't necessarily need to be as concrete as actual objects — they're excellent for storing shared code. I'm a big fan of less typing, so I opted to use <kbd>Piece</kbd> to represent a Tetrimino and <kbd>Board</kbd> for the playing field (although the word <em>well </em>is shorter, it just doesn't quite fit). I created a header file to store global variables (<kbd>constants.h</kbd>), a <kbd>Game</kbd> class to manage gameplay, and a <kbd>main.cpp</kbd> file, which acts as the entry point for the game. Here's the contents of the <kbd>/src</kbd> folder:</p>
<pre>├── board.cpp<br/>├── board.h<br/>├── constants.h<br/>├── game.cpp<br/>├── game.h<br/>├── main.cpp<br/>├── piece.cpp<br/>└── piece.h</pre>
<p>Each file (with the exception of <kbd>main.cpp</kbd> and <kbd>constants.h</kbd>) has a class (<kbd>.cpp</kbd>) and header (<kbd>.h</kbd>) file. Header files allow you to reuse code across multiple files and prevent code duplication. The <em>Further reading</em> section contains resources for you to learn more about header files if you're interested. The <kbd>constants.h</kbd> file is used in almost all of the other files within the application, so let's review that first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The constants file</h1>
                </header>
            
            <article>
                
<p>Rather than have confusing <em>magic numbers</em> sprinkled throughout the code base, I opted for a header file containing the constants we'll be using (<kbd>constants.h</kbd>). The contents of this file are shown here:</p>
<pre>#ifndef TETRIS_CONSTANTS_H<br/>#define TETRIS_CONSTANTS_H<br/><br/>namespace Constants {<br/>    const int BoardColumns = 10;<br/>    const int BoardHeight = 720;<br/>    const int BoardRows = 20;<br/>    const int BoardWidth = 360;<br/>    const int Offset = BoardWidth / BoardColumns;<br/>    const int PieceSize = 4;<br/>    const int ScreenHeight = BoardHeight + 50;<br/>}<br/><br/>#endif // TETRIS_CONSTANTS_H</pre>
<p class="mce-root">The <kbd>#ifndef</kbd> statement in the first line of the file is an <kbd>#include</kbd> guard, which prevents the header file from being included multiple times during compilation. These guards are used in all of the application's header files. The purpose of each of these constants will become clear when we step through each of the classes. I included it first to provide context around the various element sizes and how they relate to each other.</p>
<p class="mce-root">Let's move on to the various classes that represent aspects of the game. The <kbd>Piece</kbd> class represents an object at the lowest level, so we'll start there and work our way up to the <kbd>Board</kbd> and <kbd>Game</kbd> classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The piece class</h1>
                </header>
            
            <article>
                
<p class="mce-root">The piece, or <em>Tetrimino</em>, is the element that can be moved and rotated on the board. There are seven kinds of Tetriminos — each is represented by a letter and has a corresponding color:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc6eabd2-b522-4990-9973-6d5432055b3d.png" style="width:8.75em;height:20.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Tetrimino colors, taken from Wikipedia</div>
<p class="mce-root">We need a way to define each piece in terms of shape, color, and current orientation. Each piece has four different orientations (at 90 degree increments), which results in 28 total variations for all pieces. The color doesn't change, so that only needs to be assigned once. With that in mind, let's first take a look at the header file (<kbd>piece.h</kbd>):</p>
<pre class="mce-root">#ifndef TETRIS_PIECE_H<br/>#define TETRIS_PIECE_H<br/><br/>#include &lt;SDL2/SDL.h&gt;<br/>#include "constants.h"<br/><br/>class Piece {<br/> public:<br/>  enum Kind { I = 0, J, L, O, S, T, Z };<br/><br/>  explicit Piece(Kind kind);<br/><br/>  void draw(SDL_Renderer *renderer);<br/>  void move(int columnDelta, int rowDelta);<br/>  void rotate();<br/>  bool isBlock(int column, int row) const;<br/>  int getColumn() const;<br/>  int getRow() const;<br/><br/> private:<br/>  Kind kind_;<br/>  int column_;<br/>  int row_;<br/>  int angle_;<br/>};<br/><br/>#endif // TETRIS_PIECE_H</pre>
<p class="mce-root">The game uses SDL2 to render the various graphical elements and handle keyboard input, which is why we're passing a <kbd>SDL_Renderer</kbd> into the <kbd>draw()</kbd> function. You'll see how SDL2 is used in the <kbd>Game</kbd> class, but for now just be aware of its inclusion. The header file defines the interface for the <kbd>Piece</kbd> class; let's review the implementation in <kbd>piece.cpp</kbd>. We'll walk through each section of code and describe the functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The constructor and draw() function</h1>
                </header>
            
            <article>
                
<p>The first section of code defines the constructor of the <kbd>Piece</kbd> class and the <kbd>draw()</kbd> function:</p>
<pre class="mce-root">#include "piece.h"<br/><br/>using namespace Constants;<br/><br/>Piece::Piece(Piece::Kind kind) :<br/>    kind_(kind),<br/>    column_(BoardColumns / 2 - PieceSize / 2),<br/>    row_(0),<br/>    angle_(0) {<br/>}<br/><br/>void Piece::draw(SDL_Renderer *renderer) {<br/>    switch (kind_) {<br/>        case I:<br/>            SDL_SetRenderDrawColor(renderer,<br/>                /* Cyan: */ 45, 254, 254, 255);<br/>            break;<br/>        case J:<br/>            SDL_SetRenderDrawColor(renderer,<br/>                /* Blue: */ 11, 36, 251, 255);<br/>            break;<br/>        case L:<br/>            SDL_SetRenderDrawColor(renderer,<br/>                /* Orange: */ 253, 164, 41, 255);<br/>            break;<br/>        case O:<br/>            SDL_SetRenderDrawColor(renderer,<br/>                /* Yellow: */ 255, 253, 56, 255);<br/>            break;<br/>       case S:<br/>            SDL_SetRenderDrawColor(renderer,<br/>                /* Green: */ 41, 253, 47, 255);<br/>            break;<br/>        case T:<br/>            SDL_SetRenderDrawColor(renderer,<br/>                /* Purple: */ 126, 15, 126, 255);<br/>            break;<br/>        case Z:<br/>            SDL_SetRenderDrawColor(renderer,<br/>                /* Red: */ 252, 13, 28, 255);<br/>            break;<br/>        }<br/><br/>        for (int column = 0; column &lt; PieceSize; ++column) {<br/>            for (int row = 0; row &lt; PieceSize; ++row) {<br/>                if (isBlock(column, row)) {<br/>                    SDL_Rect rect{<br/>                        (column + column_) * Offset + 1,<br/>                        (row + row_) * Offset + 1,<br/>                        Offset - 2,<br/>                        Offset - 2<br/>                    };<br/>                SDL_RenderFillRect(renderer, &amp;rect);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">The constructor initializes the class with default values. The <kbd>BoardColumns</kbd> and <kbd>PieceSize</kbd> values are constants from the <kbd>constants.h</kbd> file. <kbd>BoardColumns</kbd> represents the amount of columns that can fit on a board, which is <kbd>10</kbd> in this case. The <kbd>PieceSize</kbd> constant represents the area or block that a piece takes up in columns, which is <kbd>4</kbd>. The initial value assigned to the private <kbd>columns_</kbd> variable represents the center of the board.</p>
<p class="mce-root">The <kbd>draw()</kbd> function loops through all of the possible rows and columns on the board and fills in any cells that are populated by a piece with the color that corresponds to its kind. The determination for whether a cell is populated by a piece is performed in the <kbd>isBlock()</kbd> function, which we'll discuss next.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The move(), rotate(), and isBlock() functions</h1>
                </header>
            
            <article>
                
<p>The second section contains the logic to move or rotate the piece and determine its current location:</p>
<pre class="mce-root">void Piece::move(int columnDelta, int rowDelta) {<br/>    column_ += columnDelta;<br/>    row_ += rowDelta;<br/>}<br/><br/>void Piece::rotate() {<br/>    angle_ += 3;<br/>    angle_ %= 4;<br/>}<br/><br/>bool Piece::isBlock(int column, int row) const {<br/>    static const char *Shapes[][4] = {<br/>        // I<br/>        {<br/>            " *  "<br/>            " *  "<br/>            " *  "<br/>            " *  ",<br/>            "    "<br/>            "****"<br/>            "    "<br/>            "    ",<br/>            " *  "<br/>            " *  "<br/>            " *  "<br/>            " *  ",<br/>            "    "<br/>            "****"<br/>            "    "<br/>            "    ",<br/>        },<br/>        // J<br/>        {<br/>            "  * "<br/>            "  * "<br/>            " ** "<br/>            "    ",<br/>            "    "<br/>            "*   "<br/>            "*** "<br/>            "    ",<br/>            " ** "<br/>            " *  "<br/>            " *  "<br/>            "    ",<br/>            "    "<br/>            "    "<br/>            "*** "<br/>            " *  ",<br/>        },<br/>        ...<br/>    };<br/>    return Shapes[kind_][angle_][column + row * PieceSize] == '*';<br/>}<br/><br/>int Piece::getColumn() const {<br/> return column_;<br/>}<br/>int Piece::getRow() const {<br/> return row_;<br/>}</pre>
<p class="mce-root">The <kbd>move()</kbd> function updates the values of the private <kbd>column_</kbd> and <kbd>row_</kbd> variables, which dictates the piece's location on the board. The <kbd>rotate()</kbd> function sets the value of the private <kbd>angle_</kbd> variable to either <kbd>0</kbd>, <kbd>1</kbd>, <kbd>2</kbd>, or <kbd>3</kbd> (which is why <kbd>%= 4</kbd> is used).</p>
<p class="mce-root">Determination for which kind of piece is shown, its location, and rotation is performed in the <kbd>isBlock()</kbd> function. I omitted all but the first two elements of the <kbd>Shapes</kbd> multi-dimensional array to avoid cluttering up the file, but the remaining five piece kinds are present in the actual code. I will admit that this isn't the most elegant implementation, but it suits our purposes just fine.</p>
<p class="mce-root">The private <kbd>kind_</kbd> and <kbd>angle_</kbd> values are specified as dimensions in the <kbd>Shapes</kbd> array to pick the four corresponding <kbd>char*</kbd> elements. These four elements represent the four possible orientations of the piece. If the index of <kbd>column + row * PieceSize</kbd> in the string is an asterisk, the piece is present in the specified row and column. If you decide to work through one of the Tetris tutorials available on the web (or look at one of the many Tetris repositories on GitHub), you'll find that there are several different ways to calculate whether a cell is populated by a piece. I chose this method because it's easier to visualize the pieces.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The getColumn() and getRow() functions</h1>
                </header>
            
            <article>
                
<p>The final section of code contains functions to get the row and column of the piece:</p>
<pre class="mce-root">int Piece::getColumn() const {<br/>    return column_;<br/>}<br/><br/>int Piece::getRow() const {<br/>    return row_;<br/>}</pre>
<p class="mce-root">These functions simply return the value of the private <kbd>column_</kbd> or <kbd>row_</kbd> variable. Now that you have a better understanding of the <kbd>Piece</kbd> class, let's move on to the <kbd>Board</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Board class</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>Board</kbd> contains instances of the <kbd>Piece</kbd> class and needs to detect collisions among the pieces, when rows are filled, and when the game is over. Let's start with the contents of the header file (<kbd>board.h</kbd>):</p>
<pre class="mce-root">#ifndef TETRIS_BOARD_H<br/>#define TETRIS_BOARD_H<br/><br/>#include &lt;SDL2/SDL.h&gt;<br/>#include &lt;SDL2/SDL2_ttf.h&gt;<br/>#include "constants.h"<br/>#include "piece.h"<br/><br/>using namespace Constants;<br/><br/>class Board {<br/> public:<br/>  Board();<br/>  void draw(SDL_Renderer *renderer, TTF_Font *font);<br/>  bool isCollision(const Piece &amp;piece) const;<br/>  void unite(const Piece &amp;piece);<br/><br/> private:<br/>  bool isRowFull(int row);<br/>  bool areFullRowsPresent();<br/>  void updateOffsetRow(int fullRow);<br/>  void displayScore(SDL_Renderer *renderer, TTF_Font *font);<br/><br/>  bool cells_[BoardColumns][BoardRows];<br/>  int currentScore_;<br/>};<br/><br/>#endif // TETRIS_BOARD_H</pre>
<p class="mce-root">The <kbd>Board</kbd> has a <kbd>draw()</kbd> function like the <kbd>Piece</kbd> class as well as several other functions for managing rows and keeping track of which cells are populated on the board. The <kbd>SDL2_ttf</kbd> library is used to render the <span class="packt_screen">ROWS:</span> text at the bottom of the window with the current score (count of rows cleared). Now, let's take a look at each section of the implementation file (<kbd>board.cpp</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The constructor and draw() function</h1>
                </header>
            
            <article>
                
<p>The first section of code defines the constructor of the <kbd>Board</kbd> class and the <kbd>draw()</kbd> function:</p>
<pre class="mce-root">#include &lt;sstream&gt;<br/>#include "board.h"<br/><br/>using namespace Constants;<br/><br/>Board::Board() : cells_{{ false }}, currentScore_(0) {}<br/><br/>void Board::draw(SDL_Renderer *renderer, TTF_Font *font) {<br/>    displayScore(renderer, font);<br/>    SDL_SetRenderDrawColor(<br/>        renderer,<br/>        /* Light Gray: */ 140, 140, 140, 255);<br/>    for (int column = 0; column &lt; BoardColumns; ++column) {<br/>        for (int row = 0; row &lt; BoardRows; ++row) {<br/>            if (cells_[column][row]) {<br/>                SDL_Rect rect{<br/>                    column * Offset + 1,<br/>                    row * Offset + 1,<br/>                    Offset - 2,<br/>                    Offset - 2<br/>                };<br/>                SDL_RenderFillRect(renderer, &amp;rect);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root">The <kbd>Board</kbd> constructor initializes the values of the private <kbd>cells_</kbd> and <kbd>currentScore_</kbd> variables to default values. The <kbd>cells_</kbd> variable is a two-dimensional array of Booleans, with the first dimension representing columns and the second rows. If a piece occupies a specific column and row, the corresponding value in the array is <kbd>true</kbd>. The <kbd>draw()</kbd> function behaves similarly to the <kbd>draw()</kbd> function of <kbd><span>Piece</span></kbd> in that it fills cells that contain pieces with color. However, this function only fills in cells that are occupied by pieces that have reached the bottom of the board with a light gray color, regardless of what kind of piece it is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The isCollision() function</h1>
                </header>
            
            <article>
                
<p>The second section of code contains logic to detect collisions:</p>
<pre class="mce-root">bool Board::isCollision(const Piece &amp;piece) const {<br/>    for (int column = 0; column &lt; PieceSize; ++column) {<br/>        for (int row = 0; row &lt; PieceSize; ++row) {<br/>            if (piece.isBlock(column, row)) {<br/>                int columnTarget = piece.getColumn() + column;<br/>                int rowTarget = piece.getRow() + row;<br/>                if (<br/>                    columnTarget &lt; 0<br/>                    || columnTarget &gt;= BoardColumns<br/>                    || rowTarget &lt; 0<br/>                    || rowTarget &gt;= BoardRows<br/>                ) {<br/>                    return true;<br/>                }<br/>                if (cells_[columnTarget][rowTarget]) return true;<br/>            }<br/>        }<br/>    }<br/>    return false;<br/>}</pre>
<p class="mce-root">The <kbd>isCollision()</kbd> function loops through each cell on the board until it reaches one populated by the <kbd>&amp;piece</kbd> passed as an argument. If the piece is about to collide with either side of the board or it has reached the bottom, the function returns <kbd>true</kbd>, otherwise it returns <kbd>false</kbd>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The unite() function</h1>
                </header>
            
            <article>
                
<p>The third section of code contains logic to unite a piece with the top row when it comes to rest:</p>
<pre class="mce-root">void Board::unite(const Piece &amp;piece) {<br/>    for (int column = 0; column &lt; PieceSize; ++column) {<br/>        for (int row = 0; row &lt; PieceSize; ++row) {<br/>            if (piece.isBlock(column, row)) {<br/>                int columnTarget = piece.getColumn() + column;<br/>                int rowTarget = piece.getRow() + row;<br/>                cells_[columnTarget][rowTarget] = true;<br/>            }<br/>        }<br/>    }<br/><br/>    // Continuously loops through each of the rows until no full rows are<br/>    // detected and ensures the full rows are collapsed and non-full rows<br/>    // are shifted accordingly:<br/>    while (areFullRowsPresent()) {<br/>        for (int row = BoardRows - 1; row &gt;= 0; --row) {<br/>            if (isRowFull(row)) {<br/>                updateOffsetRow(row);<br/>                currentScore_ += 1;<br/>                for (int column = 0; column &lt; BoardColumns; ++column) {<br/>                    cells_[column][0] = false;<br/>                }<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>bool Board::isRowFull(int row) {<br/>    for (int column = 0; column &lt; BoardColumns; ++column) {<br/>        if (!cells_[column][row]) return false;<br/>    }<br/>    return true;<br/>}<br/><br/>bool Board::areFullRowsPresent() {<br/>    for (int row = BoardRows - 1; row &gt;= 0; --row) {<br/>        if (isRowFull(row)) return true;<br/>    }<br/>    return false;<br/>}<br/><br/>void Board::updateOffsetRow(int fullRow) {<br/>    for (int column = 0; column &lt; BoardColumns; ++column) {<br/>        for (int rowOffset = fullRow - 1; rowOffset &gt;= 0; --rowOffset) {<br/>            cells_[column][rowOffset + 1] =<br/>            cells_[column][rowOffset];<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">The <kbd>unite()</kbd> function and the corresponding <kbd>isRowFull()</kbd>, <kbd>areFullRowsPresent()</kbd>, and <kbd>updateOffsetRow()</kbd> functions perform several operations. It updates the private <kbd>cells_</kbd> variable with the rows and columns that the specified <kbd>&amp;piece</kbd> argument occupies by setting the appropriate array location to <kbd>true</kbd>. It also clears any full rows (all columns filled) from the board by setting the corresponding <kbd>cells_</kbd> array locations to <kbd>false</kbd> and increments the <kbd>currentScore_</kbd>. After the row is cleared, the <kbd>cells_</kbd> array is updated to shift the row above the cleared row down by <kbd>1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The displayScore() function</h1>
                </header>
            
            <article>
                
<p>The final section of code displays the score at the bottom of the game window:</p>
<pre class="mce-root">void Board::displayScore(SDL_Renderer *renderer, TTF_Font *font) {<br/>    std::stringstream message;<br/>    message &lt;&lt; "ROWS: " &lt;&lt; currentScore_;<br/>    SDL_Color white = { 255, 255, 255 };<br/>    SDL_Surface *surface = TTF_RenderText_Blended(<br/>        font,<br/>        message.str().c_str(),<br/>        white);<br/>    SDL_Texture *texture = SDL_CreateTextureFromSurface(<br/>        renderer,<br/>        surface);<br/>    SDL_Rect messageRect{ 20, BoardHeight + 15, surface-&gt;w, surface-&gt;h };<br/>    SDL_FreeSurface(surface);<br/>    SDL_RenderCopy(renderer, texture, nullptr, &amp;messageRect);<br/>    SDL_DestroyTexture(texture);<br/>}</pre>
<p class="mce-root">The <kbd>displayScore()</kbd> function uses the <kbd>SDL2_ttf</kbd> library to display the current score at the bottom of the window (underneath the board). The <kbd>TTF_Font *font</kbd> argument is passed in from the <kbd>Game</kbd> class to avoid initializing the font every time the score is updated. The <kbd>stringstream message</kbd> variable is used to create the text value and set it to a C <kbd>char*</kbd> within the <kbd>TTF_RenderText_Blended()</kbd> function. The rest of the code draws the text on a <kbd>SDL_Rect</kbd> to ensure that it's properly displayed.</p>
<p class="mce-root">That's it for the <kbd>Board</kbd> class; let's move on to the <kbd>Game</kbd> to see how it all fits together.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Game class</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>Game</kbd> class contains the looping function that enables you to move pieces around the board with key presses. Here's the contents of the header file (<kbd>game.h</kbd>):</p>
<pre class="mce-root">#ifndef TETRIS_GAME_H<br/>#define TETRIS_GAME_H<br/><br/>#include &lt;SDL2/SDL.h&gt;<br/>#include &lt;SDL2/SDL2_ttf.h&gt;<br/>#include "constants.h"<br/>#include "board.h"<br/>#include "piece.h"<br/><br/>class Game {<br/> public:<br/>  Game();<br/>  ~Game();<br/>  bool loop();<br/><br/> private:<br/>  Game(const Game &amp;);<br/>  Game &amp;operator=(const Game &amp;);<br/><br/>  void checkForCollision(const Piece &amp;newPiece);<br/>  void handleKeyEvents(SDL_Event &amp;event);<br/><br/>  SDL_Window *window_;<br/>  SDL_Renderer *renderer_;<br/>  TTF_Font *font_;<br/>  Board board_;<br/>  Piece piece_;<br/>  uint32_t moveTime_;<br/>};<br/><br/>#endif // TETRIS_GAME_H</pre>
<p class="mce-root">The <kbd>loop()</kbd> function contains the game logic and manages state based on events. The first two lines under the <kbd>private:</kbd> header prevent more than one instance of the game from being created, which could cause a memory leak. The private methods reduce the amount of code lines in the <kbd>loop()</kbd> function, which simplifies maintenance and debugging. Let's move on to the implementation in <kbd>game.cpp</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The constructor and destructor</h1>
                </header>
            
            <article>
                
<p>The first section of code defines the actions to perform when the class instance is loaded (constructor) and unloaded (destructor):</p>
<pre class="mce-root">#include &lt;cstdlib&gt;<br/>#include &lt;iostream&gt;<br/>#include &lt;stdexcept&gt;<br/>#include "game.h"<br/><br/>using namespace std;<br/>using namespace Constants;<br/><br/>Game::Game() :<br/>    // Create a new random piece:<br/>    piece_{ static_cast&lt;Piece::Kind&gt;(rand() % 7) },<br/>    moveTime_(SDL_GetTicks())<br/>{<br/>    if (SDL_Init(SDL_INIT_VIDEO) != 0) {<br/>        throw runtime_error(<br/>            "SDL_Init(SDL_INIT_VIDEO): " + string(SDL_GetError()));<br/>        }<br/>        SDL_CreateWindowAndRenderer(<br/>            BoardWidth,<br/>            ScreenHeight,<br/>            SDL_WINDOW_OPENGL,<br/>            &amp;window_,<br/>            &amp;renderer_);<br/>        SDL_SetWindowPosition(<br/>            window_,<br/>            SDL_WINDOWPOS_CENTERED,<br/>            SDL_WINDOWPOS_CENTERED);<br/>        SDL_SetWindowTitle(window_, "Tetris");<br/><br/>    if (TTF_Init() != 0) {<br/>        throw runtime_error("TTF_Init():" + string(TTF_GetError()));<br/>    }<br/>    font_ = TTF_OpenFont("PressStart2P.ttf", 18);<br/>    if (font_ == nullptr) {<br/>        throw runtime_error("TTF_OpenFont: " + string(TTF_GetError()));<br/>    }<br/>}<br/><br/>Game::~Game() {<br/>    TTF_CloseFont(font_);<br/>    TTF_Quit();<br/>    SDL_DestroyRenderer(renderer_);<br/>    SDL_DestroyWindow(window_);<br/>    SDL_Quit();<br/>}</pre>
<p class="mce-root">The constructor represents the entry point for the application, so all of the required resources are allocated and initialized within it. The <kbd>TTF_OpenFont()</kbd> function is referencing a TrueType font file downloaded from Google Fonts named Press Start 2P. You can view the font at <a href="https://fonts.google.com/specimen/Press+Start+2P">https://fonts.google.com/specimen/Press+Start+2P</a>. It's present in the <kbd>/resources</kbd> folder of the repository and gets copied into the same folder as the executable when the project is built. If at any point an error occurs when initializing the SDL2 resources, a <kbd>runtime_error</kbd> is thrown with details of the error. The destructor (<kbd>~Game()</kbd>) frees up the resources we allocated for SDL2 and <kbd>SDL2_ttf</kbd> before the application exits. This is done to avoid a memory leak.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The loop() function</h1>
                </header>
            
            <article>
                
<p>The final section of code represents the <kbd>Game::loop</kbd>:</p>
<pre class="mce-root">bool Game::loop() {<br/>    SDL_Event event;<br/>    while (SDL_PollEvent(&amp;event)) {<br/>        switch (event.type) {<br/>            case SDL_KEYDOWN:<br/>                handleKeyEvents(event);<br/>                break;<br/>            case SDL_QUIT:<br/>                return false;<br/>            default:<br/>                return true;<br/>        }<br/>    }<br/><br/>    SDL_SetRenderDrawColor(renderer_, /* Dark Gray: */ 58, 58, 58, 255);<br/>    SDL_RenderClear(renderer_);<br/>    board_.draw(renderer_, font_);<br/>    piece_.draw(renderer_);<br/><br/>    if (SDL_GetTicks() &gt; moveTime_) {<br/>        moveTime_ += 1000;<br/>        Piece newPiece = piece_;<br/>        newPiece.move(0, 1);<br/>        checkForCollision(newPiece);<br/>    }<br/>    SDL_RenderPresent(renderer_);<br/>    return true;<br/>}<br/><br/>void Game::checkForCollision(const Piece &amp;newPiece) {<br/>    if (board_.isCollision(newPiece)) {<br/>        board_.unite(piece_);<br/>        piece_ = Piece{ static_cast&lt;Piece::Kind&gt;(rand() % 7) };<br/>        if (board_.isCollision(piece_)) board_ = Board();<br/>    } else {<br/>        piece_ = newPiece;<br/>    }<br/>}<br/><br/>void Game::handleKeyEvents(SDL_Event &amp;event) {<br/>    Piece newPiece = piece_;<br/>    switch (event.key.keysym.sym) {<br/>        case SDLK_DOWN:<br/>            newPiece.move(0, 1);<br/>            break;<br/>        case SDLK_RIGHT:<br/>            newPiece.move(1, 0);<br/>            break;<br/>        case SDLK_LEFT:<br/>            newPiece.move(-1, 0);<br/>            break;<br/>        case SDLK_UP:<br/>            newPiece.rotate();<br/>            break;<br/>        default:<br/>            break;<br/>     }<br/>     if (!board_.isCollision(newPiece)) piece_ = newPiece;<br/>}</pre>
<p class="mce-root">The <kbd>loop()</kbd> function returns a Boolean as long as the <kbd>SDL_QUIT</kbd> event hasn't fired. Every <kbd>1</kbd> second, the <kbd>draw()</kbd> functions for the <kbd>Piece</kbd> and <kbd>Board</kbd> instances are executed, and the piece locations on the board are updated accordingly. The left, right, and down arrow keys control the piece's movement while the up arrow key rotates the piece by 90 degrees. Appropriate responses to key presses are handled in the <kbd>handleKeyEvents()</kbd> function. The <kbd>checkForCollision()</kbd> function determines if a new instance of the active piece collided with either side of the board or came to rest on top of the other pieces. If it did, a new piece is created. The logic for clearing the rows (via the <kbd>unite()</kbd> function of <kbd><span>Board</span></kbd>) is also handled in this function. We're almost done! Let's move on to the <kbd>main.cpp</kbd> file.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main file</h1>
                </header>
            
            <article>
                
<p class="mce-root">There's no header file associated with <kbd>main.cpp</kbd> because its only purpose is to act as an entry point to the application. In fact, the file is only seven lines long:</p>
<pre class="mce-root">#include "game.h"<br/><br/>int main() {<br/>    Game game;<br/>    while (game.loop());<br/>    return 0;<br/>}</pre>
<p class="mce-root">The <kbd>while</kbd> statement is exited when the <kbd>loop()</kbd> function returns <kbd>false</kbd>, which occurs when the <kbd>SDL_QUIT</kbd> event fires. All this file is doing is creating a new instance of <kbd>Game</kbd> and starting the loop. That's it for the codebase; let's start porting!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Porting to Emscripten</h1>
                </header>
            
            <article>
                
<p class="mce-root">You have a good understanding of the code base, so now it's time to start porting it over with Emscripten. Fortunately, we're able to leverage some of the browser's features to simplify the code and completely remove a third-party library. In this section, we're going to update the code to compile to a Wasm module and JavaScript <em>glue</em> file and update some of the functionality to utilize the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing for porting</h1>
                </header>
            
            <article>
                
<p>The <kbd>/output-wasm</kbd> folder contains the end result, but I recommend that you create a copy of the <kbd>/output-native</kbd> folder so that you can follow along with the porting process. There are VS Code <span class="packt_screen">Tasks</span> set up for both native compilation and Emscripten compilation. If you get stuck, you can always reference the <kbd>/output-wasm</kbd> contents. Make sure you open your copied folder in VS Code (<span class="packt_screen">File</span> | <span class="packt_screen">Open</span> and select your copied folder), otherwise you won't be able to use the Tasks feature.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What's changing?</h1>
                </header>
            
            <article>
                
<p class="mce-root">This game is an ideal candidate for porting because it uses SDL2, a widely used library with an existing Emscripten port. Including SDL2 in the compilation step requires only one additional argument passed to the <kbd>emcc</kbd> command. An Emscripten port of the <kbd>SDL2_ttf</kbd> library also exists, but keeping it in the code base doesn't make much sense. Its sole purpose is to render the score (amount of rows cleared) as text. We would need to include the TTF file with the application and complicate the build process. Emscripten provides the means for using JavaScript code within our C++, so we're going to take a much simpler route: show the score in the DOM.</p>
<p class="mce-root">In addition to changing the existing code, we'll need to create an HTML and CSS file for displaying and styling the game in the browser. The JavaScript code we write will be minimal — we just need to load the Emscripten module and all our functionality is handled in the C++ code base. We'll also need to add a few <kbd>&lt;div&gt;</kbd> elements and lay them out accordingly to display the score. Let's start porting!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the web assets</h1>
                </header>
            
            <article>
                
<p>Create a folder in your project folder named <kbd>/public</kbd>. Add a new file named <kbd>index.html</kbd> to the <kbd>/public</kbd> folder and populate it with the following contents:</p>
<pre class="mce-root">&lt;!doctype html&gt;<br/>&lt;html lang="en-us"&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Tetris&lt;/title&gt;<br/>  &lt;link rel="stylesheet" type="text/css" href="styles.css" /&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;div class="wrapper"&gt;<br/>    &lt;h1&gt;Tetris&lt;/h1&gt;<br/>    &lt;div&gt;<br/>      &lt;canvas id="canvas"&gt;&lt;/canvas&gt;<br/>      &lt;div class="scoreWrapper"&gt;<br/>        &lt;span&gt;ROWS:&lt;/span&gt;&lt;span id="score"&gt;&lt;/span&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>  &lt;script type="application/javascript" src="index.js"&gt;&lt;/script&gt;<br/>  &lt;script type="application/javascript"&gt;<br/>    Module({ canvas: (() =&gt; document.getElementById('canvas'))() })<br/>  &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root"/>
<p class="mce-root">The <kbd>index.js</kbd> file being loaded in the first <kbd>&lt;script&gt;</kbd> tag doesn't exist yet; that'll be generated in the compilation step. Let's add some styles to the elements. Create a <kbd>styles.css</kbd> file in the <kbd>/public</kbd> folder and populate it with the following contents:</p>
<pre class="mce-root">@import url("https://fonts.googleapis.com/css?family=Press+Start+2P");<br/><br/>* {<br/>  font-family: "Press Start 2P", sans-serif;<br/>}<br/><br/>body {<br/>  margin: 24px;<br/>}<br/><br/>h1 {<br/>  font-size: 36px;<br/>}<br/><br/>span {<br/>  color: white;<br/>  font-size: 24px;<br/>}<br/><br/>.wrapper {<br/>  display: flex;<br/>  align-items: center;<br/>  flex-direction: column;<br/>}<br/><br/>.titleWrapper {<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: center;<br/>}<br/><br/>.header {<br/>  font-size: 24px;<br/>  margin-left: 16px;<br/>}<br/><br/>.scoreWrapper {<br/>  background-color: #3A3A3A;<br/>  border-top: 1px solid white;<br/>  padding: 16px 0;<br/>  width: 360px;<br/>}<br/><br/>span:first-child {<br/>  margin-left: 16px;<br/>  margin-right: 8px;<br/>}</pre>
<p class="mce-root">Since the Press Start 2P font we're using is hosted on Google Fonts, we can import it for use on the site. The CSS rules in this file handle simple layout and styling. That's it for the web-related files we needed to create. Now, it's time to update the C++ code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Porting the existing code</h1>
                </header>
            
            <article>
                
<p class="mce-root">We only need to edit a few files to get Emscripten working correctly. For the sake of simplicity and compactness, only the affected sections of code will be included (rather than the entire file). Let's work through the files in the same order as the previous section and start with <kbd>constants.h</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the constants file</h1>
                </header>
            
            <article>
                
<p class="mce-root">We'll display the rows cleared count on the DOM instead of in the game window itself, so you can delete the <kbd>ScreenHeight</kbd> constant from the file. We no longer need additional space to accommodate for the score text:</p>
<pre class="mce-root">namespace Constants {<br/>    const int BoardColumns = 10;<br/>    const int BoardHeight = 720;<br/>    const int BoardRows = 20;<br/>    const int BoardWidth = 360;<br/>    const int Offset = BoardWidth / BoardColumns;<br/>    const int PieceSize = 4;<br/>    // const int ScreenHeight = BoardHeight + 50; &lt;----- Delete this line<br/>}</pre>
<p class="mce-root">No changes need to be made to the <kbd>Piece</kbd> class files (<kbd>piece.cpp</kbd>/<kbd>piece.h</kbd>). However, we will need to update the <kbd>Board</kbd> class. Let's start with the header file (<kbd>board.h</kbd>). Starting with the bottom and working our way up, let's update the <kbd>displayScore()</kbd> function. In the <kbd>&lt;body&gt;</kbd> section of the <kbd>index.html</kbd> file, there's a <kbd>&lt;span&gt;</kbd> element with <kbd>id="score"</kbd>. We're going to update this element using the <kbd>emscripten_run_script</kbd> command to display the current score. As a result, the <kbd>displayScore()</kbd> function becomes much shorter. The before and after is shown as follows.</p>
<p class="mce-root"/>
<p class="mce-root">Here is the original version of the Board class's <kbd>displayScore()</kbd> function:</p>
<pre class="mce-root">void Board::displayScore(SDL_Renderer *renderer, TTF_Font *font) {<br/>    std::stringstream message;<br/>    message &lt;&lt; "ROWS: " &lt;&lt; currentScore_;<br/>    SDL_Color white = { 255, 255, 255 };<br/>    SDL_Surface *surface = TTF_RenderText_Blended(<br/>        font,<br/>        message.str().c_str(),<br/>        white);<br/>    SDL_Texture *texture = SDL_CreateTextureFromSurface(<br/>        renderer,<br/>        surface);<br/>    SDL_Rect messageRect{ 20, BoardHeight + 15, surface-&gt;w, surface-&gt;h };<br/>    SDL_FreeSurface(surface);<br/>    SDL_RenderCopy(renderer, texture, nullptr, &amp;messageRect);<br/>    SDL_DestroyTexture(texture);<br/> }</pre>
<p class="mce-root">Here is the ported version of the <kbd>displayScore()</kbd> function:</p>
<pre class="mce-root">void Board::displayScore(int newScore) {<br/>    std::stringstream action;<br/>    action &lt;&lt; "document.getElementById('score').innerHTML =" &lt;&lt; newScore;<br/>    emscripten_run_script(action.str().c_str());<br/> }</pre>
<p class="mce-root">The <kbd>emscripten_run_script</kbd> action simply finds the <kbd>&lt;span&gt;</kbd> element on the DOM and sets the <kbd>innerHTML</kbd> to the current score. We can't use the <kbd>EM_ASM()</kbd> function here because Emscripten doesn't recognize the <kbd>document</kbd> object. Since we have access to the private <kbd>currentScore_</kbd> variable in the class, we're going to move the <kbd>displayScore()</kbd> call in the <kbd>draw()</kbd> function into the <kbd>unite()</kbd> function. This limits the amount of calls to <kbd>displayScore()</kbd> to ensure that the function is called only when the score has actually changed. We only need to add one line of code to accomplish this. Here's what the <kbd>unite()</kbd> function looks like now:</p>
<pre class="mce-root">void Board::unite(const Piece &amp;piece) {<br/>    for (int column = 0; column &lt; PieceSize; ++column) {<br/>        for (int row = 0; row &lt; PieceSize; ++row) {<br/>            if (piece.isBlock(column, row)) {<br/>                int columnTarget = piece.getColumn() + column;<br/>                int rowTarget = piece.getRow() + row;<br/>                cells_[columnTarget][rowTarget] = true;<br/>            }<br/>        }<br/>    }<br/><br/>    // Continuously loops through each of the rows until no full rows are<br/>    // detected and ensures the full rows are collapsed and non-full rows<br/>    // are shifted accordingly:<br/>    while (areFullRowsPresent()) {<br/>        for (int row = BoardRows - 1; row &gt;= 0; --row) {<br/>            if (isRowFull(row)) {<br/>                updateOffsetRow(row);<br/>                currentScore_ += 1;<br/>                for (int column = 0; column &lt; BoardColumns; ++column) {<br/>                    cells_[column][0] = false;<br/>                }<br/>            }<br/>        }<br/>        displayScore(currentScore_); // &lt;----- Add this line<br/>    }<br/>}</pre>
<p class="mce-root">Since we're no longer using the <kbd>SDL2_ttf</kbd> library, we can update the <kbd>draw()</kbd> function signature and remove the <kbd>displayScore()</kbd> function call. Here's the updated <kbd>draw()</kbd> function:</p>
<pre class="mce-root">void Board::draw(SDL_Renderer *renderer/*, TTF_Font *font */) {<br/>                                        // ^^^^^^^^^^^^^^ &lt;-- Remove this argument<br/>    // displayScore(renderer, font); &lt;----- Delete this line<br/>    SDL_SetRenderDrawColor(<br/>        renderer,<br/>        /* Light Gray: */ 140, 140, 140, 255);<br/>    for (int column = 0; column &lt; BoardColumns; ++column) {<br/>        for (int row = 0; row &lt; BoardRows; ++row) {<br/>            if (cells_[column][row]) {<br/>                SDL_Rect rect{<br/>                    column * Offset + 1,<br/>                    row * Offset + 1,<br/>                    Offset - 2,<br/>                    Offset - 2<br/>                };<br/>                SDL_RenderFillRect(renderer, &amp;rect);<br/>            }<br/>        }<br/>    }<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root">The <kbd>displayScore()</kbd> function call was removed from the first line of the function and the <kbd>TTF_Font *font</kbd> argument was removed as well. Let's add a call to <kbd>displayScore()</kbd> in the constructor to ensure that the initial value is set to <kbd>0</kbd> when the game ends and a new one begins:</p>
<pre class="mce-root">Board::Board() : cells_{{ false }}, currentScore_(0) {<br/>    displayScore(0); // &lt;----- Add this line<br/>}</pre>
<p class="mce-root">That's it for the class file. Since we changed the signatures for the <kbd>displayScore()</kbd> and <kbd>draw()</kbd> functions, and removed the dependency for <kbd>SDL2_ttf</kbd>, we'll need to update the header file. Remove the following lines from <kbd>board.h</kbd>:</p>
<pre class="mce-root">#ifndef TETRIS_BOARD_H<br/>#define TETRIS_BOARD_H<br/><br/>#include &lt;SDL2/SDL.h&gt;<br/>// #include &lt;SDL2/SDL2_ttf.h&gt; &lt;----- Delete this line<br/>#include "constants.h"<br/>#include "piece.h"<br/><br/>using namespace Constants;<br/><br/>class Board {<br/> public:<br/>  Board();<br/>  void draw(SDL_Renderer *renderer /*, TTF_Font *font */);<br/>                                    // ^^^^^^^^^^^^^^ &lt;-- Remove this<br/>  bool isCollision(const Piece &amp;piece) const;<br/>  void unite(const Piece &amp;piece);<br/><br/> private:<br/>  bool isRowFull(int row);<br/>  bool areFullRowsPresent();<br/>  void updateOffsetRow(int fullRow);<br/>  void displayScore(SDL_Renderer *renderer, TTF_Font *font);<br/>                                         // ^^^^^^^^^^^^^^ &lt;-- Remove this<br/>  bool cells_[BoardColumns][BoardRows];<br/>  int currentScore_;<br/>};<br/><br/>#endif // TETRIS_BOARD_H</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">We're moving right along! The final change we need to make is the also the biggest one. The existing code base has a <kbd>Game</kbd> class that manages the application logic and a <kbd>main.cpp</kbd> file that calls the <kbd>Game.loop()</kbd> function in the <kbd>main()</kbd> function. The looping mechanism is a while loop that continues to run as long as the <kbd>SDL_QUIT</kbd> event hasn't fired. We need to change our approach to accommodate for Emscripten.</p>
<p class="mce-root">Emscripten provides an <kbd>emscripten_set_main_loop</kbd> function that accepts an <kbd>em_callback_func</kbd> looping function, <kbd><span>fps</span></kbd>, and a <kbd>simulate_infinite_loop</kbd> flag. We can't include the <kbd>Game</kbd> class and pass <kbd>Game.loop()</kbd> as the <kbd>em_callback_func</kbd> argument, because the build will fail. Instead, we're going to eliminate the <kbd>Game</kbd> class completely and move the logic into the <kbd>main.cpp</kbd> file. Copy the contents of <kbd>game.cpp</kbd> into <kbd>main.cpp</kbd> (overwriting the existing contents) and delete the <kbd>Game</kbd> class files (<kbd>game.cpp</kbd>/<kbd>game.h</kbd>). Since we're not declaring a class for <kbd>Game</kbd>, remove the <kbd>Game::</kbd> prefixes from the functions. The constructor and destructor are no longer valid (they're no longer part of a class), so we need to move that logic to a different location. We also need to reorder the file to ensure that our called functions come before the calling functions. The final result looks like this:</p>
<pre class="mce-root">#include &lt;emscripten/emscripten.h&gt;<br/>#include &lt;SDL2/SDL.h&gt;<br/>#include &lt;stdexcept&gt;<br/>#include "constants.h"<br/>#include "board.h"<br/>#include "piece.h"<br/><br/>using namespace std;<br/>using namespace Constants;<br/><br/>static SDL_Window *window = nullptr;<br/>static SDL_Renderer *renderer = nullptr;<br/>static Piece currentPiece{ static_cast&lt;Piece::Kind&gt;(rand() % 7) };<br/>static Board board;<br/>static int moveTime;<br/><br/>void checkForCollision(const Piece &amp;newPiece) {<br/>    if (board.isCollision(newPiece)) {<br/>        board.unite(currentPiece);<br/>        currentPiece = Piece{ static_cast&lt;Piece::Kind&gt;(rand() % 7) };<br/>        if (board.isCollision(currentPiece)) board = Board();<br/>    } else {<br/>        currentPiece = newPiece;<br/>    }<br/>}<br/><br/>void handleKeyEvents(SDL_Event &amp;event) {<br/>    Piece newPiece = currentPiece;<br/>    switch (event.key.keysym.sym) {<br/>        case SDLK_DOWN:<br/>            newPiece.move(0, 1);<br/>            break;<br/>        case SDLK_RIGHT:<br/>            newPiece.move(1, 0);<br/>            break;<br/>        case SDLK_LEFT:<br/>            newPiece.move(-1, 0);<br/>            break;<br/>        case SDLK_UP:<br/>            newPiece.rotate();<br/>            break;<br/>        default:<br/>            break;<br/>    }<br/>    if (!board.isCollision(newPiece)) currentPiece = newPiece;<br/>}<br/><br/>void loop() {<br/>    SDL_Event event;<br/>    while (SDL_PollEvent(&amp;event)) {<br/>        switch (event.type) {<br/>            case SDL_KEYDOWN:<br/>                handleKeyEvents(event);<br/>                break;<br/>            case SDL_QUIT:<br/>                break;<br/>            default:<br/>                break;<br/>        }<br/>    }<br/><br/>    SDL_SetRenderDrawColor(renderer, /* Dark Gray: */ 58, 58, 58, 255);<br/>    SDL_RenderClear(renderer);<br/>    board.draw(renderer);<br/>    currentPiece.draw(renderer);<br/><br/>    if (SDL_GetTicks() &gt; moveTime) {<br/>        moveTime += 1000;<br/>        Piece newPiece = currentPiece;<br/>        newPiece.move(0, 1);<br/>        checkForCollision(newPiece);<br/>    }<br/>    SDL_RenderPresent(renderer);<br/>}<br/><br/>int main() {<br/>    moveTime = SDL_GetTicks();<br/>    if (SDL_Init(SDL_INIT_VIDEO) != 0) {<br/>        throw std::runtime_error("SDL_Init(SDL_INIT_VIDEO)");<br/>    }<br/>    SDL_CreateWindowAndRenderer(<br/>        BoardWidth,<br/>        BoardHeight,<br/>        SDL_WINDOW_OPENGL,<br/>        &amp;window,<br/>        &amp;renderer);<br/><br/>    emscripten_set_main_loop(loop, 0, 1);<br/><br/>    SDL_DestroyRenderer(renderer);<br/>    renderer = nullptr;<br/>    SDL_DestroyWindow(window);<br/>    window = nullptr;<br/>    SDL_Quit();<br/>    return 0;<br/>}</pre>
<p class="mce-root">The <kbd>handleKeyEvents()</kbd> and <kbd>checkForCollision()</kbd> functions haven't changed; we simply moved them to the top of the file. The <kbd>loop()</kbd> function return type was changed from <kbd>bool</kbd> to <kbd>void</kbd> as required by <kbd>emscripten_set_main_loop</kbd>. Finally, the code from the constructor and destructor was moved into the <kbd>main()</kbd> function and any references to <kbd>SDL2_ttf</kbd> were removed. Instead of the while statement that called the <kbd>loop()</kbd> function of <kbd><span>Game</span></kbd>, we have the <kbd>emscripten_set_main_loop(loop, 0, 1)</kbd> call. We changed the <kbd>#include</kbd> statements at the top of the file to accommodate for Emscripten, SDL2, and our <kbd>Board</kbd> and <kbd>Piece</kbd> classes. That's it for changes — now it's time to configure the build and test out the game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building and running the game</h1>
                </header>
            
            <article>
                
<p>With the code updated and the required web assets present, it's time to build and test out the game. The compilation step is similar to the previous examples in this book, but we're going to use a different technique to run the game. In this section, we're going to configure the build task to accommodate for the C++ files and run the application using a feature provided by Emscripten.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building with VS Code tasks</h1>
                </header>
            
            <article>
                
<p>We're going to configure the build in two ways: with VS Code tasks and a Makefile. Makefiles are nice if you prefer to use a different editor than VS Code. The <kbd>/.vscode/tasks.json</kbd> file already contains the tasks you'll need to build the project. The Emscripten build step is the default (a set of native build tasks is also present). Let's walk through each task in the <kbd>tasks</kbd> array and review what's taking place. The first task deletes any existing compiled output files prior to building:</p>
<pre>{<br/>  "label": "Remove Existing Web Files",<br/>  "type": "shell",<br/>  "command": "rimraf",<br/>  "options": {<br/>    "cwd": "${workspaceRoot}/public"<br/>  },<br/>  "args": [<br/>    "index.js",<br/>    "index.wasm"<br/>  ]<br/>}</pre>
<p>The second task performs the build with the <kbd>emcc</kbd> command:</p>
<pre>{<br/>  "label": "Build WebAssembly",<br/>  "type": "shell",<br/>  "command": "emcc",<br/>  "args": [<br/>    "--bind", "src/board.cpp", "src/piece.cpp", "src/main.cpp",<br/>    "-std=c++14",<br/>    "-O3",<br/>    "-s", "WASM=1",<br/>    "-s", "USE_SDL=2",<br/>    "-s", "MODULARIZE=1",<br/>    "-o", "public/index.js"<br/>  ],<br/>  "group": {<br/>    "kind": "build",<br/>    "isDefault": true<br/>  },<br/>  "problemMatcher": [],<br/>  "dependsOn": ["Remove Existing Web Files"]<br/>}</pre>
<p class="mce-root"/>
<p>The related arguments are placed on the same line. The only new and unfamiliar addition to the <kbd>args</kbd> array is the <kbd>--bind</kbd> argument with the corresponding <kbd>.cpp</kbd> files. This tells Emscripten that all the files after <kbd>--bind</kbd> are required to build the project. Test out the build by selecting <span class="packt_screen">Tasks</span> | <span class="packt_screen">Run Build Task...</span> from the menu or using the keyboard shortcut <em>Cmd</em>/<em>Ctrl + Shift + B</em>. It takes a few seconds to build, but the terminal will let you know when the compilation process is complete. If successful, you should see an <kbd>index.js</kbd> and <kbd>index.wasm</kbd> file in the <kbd>/public</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building with a Makefile</h1>
                </header>
            
            <article>
                
<p>If you prefer not to use VS Code, you can use a Makefile to accomplish the same goal as the VS Code tasks. Create a file named <kbd>Makefile</kbd> in your project folder and populate it with the following contents (make sure that the file is using tabs, not spaces):</p>
<pre># This allows you to just run the "make" command without specifying<br/># arguments:<br/>.DEFAULT_GOAL := build<br/><br/># Specifies which files to compile as part of the project:<br/>CPP_FILES = $(wildcard src/*.cpp)<br/><br/># Flags to use for Emscripten emcc compile command:<br/>FLAGS = -std=c++14 -O3 -s WASM=1 -s USE_SDL=2 -s MODULARIZE=1 \<br/>        --bind $(CPP_FILES)<br/><br/># Name of output (the .wasm file is created automatically):<br/>OUTPUT_FILE = public/index.js<br/><br/># This is the target that compiles our executable<br/>compile: $(CPP_FILES)<br/>    emcc  $(FLAGS) -o $(OUTPUT_FILE)<br/><br/># Removes the existing index.js and index.wasm files:<br/>clean:<br/>    rimraf $(OUTPUT_FILE)<br/>    rimraf public/index.wasm<br/><br/># Removes the existing files and builds the project:<br/>build: clean compile<br/>    @echo "Build Complete!"</pre>
<p>The operations being performed are identical to the VS Code tasks, just in a different format using more universal tooling. The default build step is set in the file, so you can run the following command within your project folder to compile the project:</p>
<pre class="mce-root"><strong>make</strong></pre>
<p class="mce-root">Now that you have a compiled Wasm file and JavaScript glue code, let's try running the game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the game</h1>
                </header>
            
            <article>
                
<p class="mce-root">Instead of using serve or <kbd>browser-sync</kbd>, we're going to use a built-in feature of Emscripten's toolchain, <kbd>emrun</kbd>. It provides the added benefit of capturing <kbd>stdout</kbd> and <kbd>stderr</kbd> (if you pass the <kbd>--emrun</kbd> linker flag to the <kbd>emcc</kbd> command) and printing them to the terminal if desired. We're not going to use the <kbd>--emrun</kbd> flag, but having a local web server available without having to install any additional dependencies is a nice added feature to be aware of. Open up a terminal instance within your project folder and run the following command to start the game:</p>
<pre class="mce-root"><strong>emrun --browser chrome --no_emrun_detect public/index.html</strong></pre>
<p class="mce-root">You can specify <kbd>firefox</kbd> for the browser if that's what you're using for development. The <kbd>--no_emrun_detect</kbd> flag hides a message in the terminal stating that the HTML page is not <kbd>emrun</kbd> capable. If you navigate to <kbd>http://localhost:6931/index.html</kbd>, you should see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/700df992-90f3-4452-84da-49e770e1a1c7.png" style="width:31.25em;height:45.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Tetris running in the browser</div>
<p class="mce-root">Try rotating and moving the pieces to ensure that everything is working correctly. The <span class="packt_screen">ROWS</span> count should increment by one when you've successfully cleared a row. You may also notice that if you're too close to the edge of the board, you won't be able to rotate some of the pieces. Congratulations, you've successfully ported a C++ game over to Emscripten!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we ported a Tetris clone written in C++ that used SDL2 to Emscripten so it could be run in the browser with WebAssembly. We covered the rules of Tetris and how they map to the logic within the existing codebase. We also reviewed each file in the existing code base individually and which changes had to be made to successfully compile to a Wasm file and JavaScript glue code. After updating the existing code, we created the required HTML and CSS files, then configured a build step with the appropriate <kbd>emcc</kbd> flags. Once built, the game was run using Emscripten's <kbd>emrun</kbd> command.</p>
<p class="mce-root">In <a href="52c9bfe6-6178-4795-8316-09aee11e8e28.xhtml">Chapter 9</a>, <em>Integrating with Node.js</em>, we're going to discuss how to integrate WebAssembly into Node.js and the benefits this integration provides.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">What are the pieces called in Tetris?</li>
<li class="mce-root">What is one reason for choosing not to port an existing C++ code base to Emscripten?</li>
<li class="mce-root">What tool did we use to compile the game natively (for example, to an executable)?</li>
<li class="mce-root">What is the purpose of the <kbd>constants.h</kbd> file?</li>
<li class="mce-root">Why were we able to eliminate the SDL2_ttf library?</li>
<li class="mce-root">Which Emscripten function did we use to start running the game?</li>
<li class="mce-root">Which argument did we add to the <kbd>emcc</kbd> command to build the game and what purpose does it serve?</li>
<li class="mce-root">What advantage does <kbd>emrun</kbd> offer over a tool like <kbd>serve</kbd> and Browsersync?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Header Files in C++: <a href="https://www.sitesbay.com/cpp/cpp-header-files">https://www.sitesbay.com/cpp/cpp-header-files</a></li>
<li>SDL2 Tetris on GitHub: <a href="https://github.com/andwn/sdl2-tetris">https://github.com/andwn/sdl2-tetris</a></li>
<li>Tetris on GitHub: <a href="https://github.com/abesary/tetris">https://github.com/abesary/tetris</a></li>
<li>Tetris - Linux on GitHub: <a href="https://github.com/abesary/tetris-linux">https://github.com/abesary/tetris-linux</a></li>
</ul>


            </article>

            
        </section>
    </body></html>