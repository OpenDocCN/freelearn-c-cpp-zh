- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use **Open Graphics Library** (**OpenGL**),
    a powerful rendering **application program interface** (**API**), and combine
    it with **Qt**. OpenGL is a cross-language, cross-platform API for drawing 2D
    and 3D graphics on screen through the **graphics processing unit** (**GPU**) within
    our computer’s graphics chip. In this chapter, we will be learning about OpenGL
    3 instead of 2 because, even though the fixed-function pipeline is easier for
    beginners to grasp compared to the newer programmable pipeline, it is considered
    legacy code and has been deprecated by most modern 3D rendering software. Qt 6
    supports both versions, so there should be no problem switching over to OpenGL
    2 if you need backward compatibility for your software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up OpenGL in Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hello World!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering 2D shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering 3D shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texturing in OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic lighting in OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving an object using keyboard controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Quick 3D in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter include Qt 6.6.1 MinGW 64-bit and
    Qt Creator 12.0.2\. All the code used in this chapter can be downloaded from the
    following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter05](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up OpenGL in Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to set up OpenGL in Qt 6.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to set up OpenGL in Qt:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `mainwindow.ui`, `mainwindow.h`, and `mainwindow.cpp` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up your project file (`.pro`) and add the OpenGL module to your project
    by adding an `opengl` keyword behind `QT +=`; after that, run `qmake` to reload
    the project modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You also need to add another line in your project file so that it will load
    both the OpenGL and **OpenGL Utilities** (**GLU**) libraries during startup. Without
    these two libraries, your program will not be able to run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open up `main.cpp` and replace `mainwindow.h` with the `QtOpenGL` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove all of the code related to the `MainWindow` class from your `main.cpp`
    file and replace it with the code that’s highlighted in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you compile and run the project now, you will see an empty window with a
    black background. Don’t worry about it—your program is now running on OpenGL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 - An empty OpenGL window](img/B20976_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 - An empty OpenGL window
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OpenGL` module must be added to the project file (`.pro`) in order to access
    header files that are related to OpenGL, such as `QtOpenGL` and `QOpenGLFunctions`.
    We used the `QOpenGLWindow` class instead of `QMainWindow` for the main window
    because it is designed to easily create windows that perform OpenGL rendering,
    and it offers better performance compared to `QOpenGLWidget` due to the fact that
    it has no dependencies in its widget module.
  prefs: []
  type: TYPE_NORMAL
- en: We must call `setSurfaceType(QWindow::OpenGLSurface)` to tell Qt we would prefer
    to use OpenGL to render the images to screen instead of `QPainter`. The `QOpenGLWindow`
    class provides several virtual functions (`initializeGL()`, `resizeGL()`, `paintGL()`,
    and so on) for us to conveniently set up OpenGL and perform graphics rendering.
    We will be learning how to use these functions in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenGL is a cross-language, cross-platform API for drawing 2D and 3D graphics
    on screen through the GPU within our computer’s graphics chip. Computer graphics
    technology has been evolving rapidly over the years—so rapidly that the software
    industry can hardly keep up with its pace.
  prefs: []
  type: TYPE_NORMAL
- en: In 2008, the Khronos Group, the company that maintains and develops OpenGL,
    announced the release of the OpenGL 3.0 specification, which created a huge uproar
    and controversy throughout the industry. That was mainly because OpenGL 3.0 was
    supposed to deprecate the entire fixed-function pipeline from the OpenGL API,
    and it was simply an impossible task for the big players to make the sudden switch
    overnight from a fixed-function pipeline to a programmable pipeline. This resulted
    in two different major versions of OpenGL being maintained.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the newer OpenGL 3 instead of the older, deprecated
    OpenGL 2\. The coding style and syntax are very different between these two versions,
    which makes the switchover very troublesome. However, the performance improvement
    will make it worth the time it takes to switch over to OpenGL 3.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use OpenGL 3 with Qt 6\. Common OpenGL
    functions such as `glBegin`, `glVertex2f`, `glColor3f`, `glMatrixMode`, and `glLoadIdentity`
    have all been removed from OpenGL 3\. OpenGL 3 uses `glVertex2f()`, which slows
    down the rendering while waiting for the CPU to submit the data one by one. Therefore,
    we will pack all of the data into VBOs and send it all in one huge package to
    the GPU and instruct the GPU to calculate the resulting pixels through shader
    programming. We will also be learning how to create simple **shader programs**
    through a C-like programming language called **OpenGL Shading** **Language** (**GLSL**).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new class called `RenderWindow`, which inherits from the `QOpenGLWindow`
    class. Go to `RenderWindow` and set its base class as `QOpenGLWindow`. Then, proceed
    to create the C++ class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Defining your custom render window class](img/B20976_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Defining your custom render window class
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `renderwindow.h` file we just created and add the following headers
    at the top of the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to create several functions and variables that look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will continue and add some private variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open up `renderwindow.cpp` and define the class constructor as follows. We
    must tell the render window to use the OpenGL surface type; enable **core profile**
    (rather than **compatibility profile**) that runs version 3.2; create an OpenGL
    context; and, finally, apply the profile we just created into the context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to define the `initializeGL()` function as follows. This function will
    be called before the rendering starts. First, we define the **vertex shader**
    and the **fragment shader**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We initiate `shaderProgram` and declare a vertices array. Then, we also create
    a `QOpenGLVertexArrayObject` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s continue to write our code by defining `vbo_vertices`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will start by adding some code to the `paintEvent()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then bind the VAO and shader program before calling `glDrawArrays()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can refresh the viewport whenever the render window is being resized by
    adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you compile and run the project now, you should be able to see a red rectangle
    being drawn in front of a blue background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 - Our first triangle rendered in OpenGL](img/B20976_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 - Our first triangle rendered in OpenGL
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must set the OpenGL version to 3.x and the surface format to the core profile
    so that we can access the newer shader pipeline, which is completely different
    from the older, deprecated compatibility profile. OpenGL 2.x still exists in the
    compatibility profile, solely for the sake of allowing OpenGL programs to run
    on old hardware. The profile that’s created must be applied to the OpenGL context
    before it will work.
  prefs: []
  type: TYPE_NORMAL
- en: In OpenGL 3 and the later versions, most of the calculations are done in the
    GPU through shader programs, since all of the common fixed functions have now
    been completely deprecated. Therefore, we created a very simple vertex shader
    and fragment shader in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'A shader program consists of three different parts: **geometry shader** (optional),
    vertex shader, and fragment shader. The geometry shader calculates the creation
    of geometry before passing the data to the vertex shader; the vertex shader handles
    the position and motion of the vertices before passing the data to the fragment
    shader; and finally, the fragment shader calculates and displays the resulting
    pixels on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we only used vertex and fragment shaders and excluded
    the geometry shader since it is optional. You can save the GLSL code in a text
    file and load it into your Qt 6 program by calling `addShaderFromFile()`, but
    since our shaders are very simple and short, we just define it directly in our
    C++ source code.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we use the VBO to store the vertex positions in bulk before sending
    it to the GPU. We can also use the VBO to store other information such as normals,
    texture coordinates, and vertex colors. You can send anything you want to the
    GPU as long as it matches the input inside your shader code. Then, we add the
    VBO into a **vertex array object** (**VAO**) and send the whole VAO to the GPU
    for processing. You can add many different VBOs into the VAO since the VAO is
    just like any ordinary C++ array.
  prefs: []
  type: TYPE_NORMAL
- en: Just like what we have learned in the previous chapters, all drawings happen
    within the `paintEvent()` function, and it will only be called by Qt when it thinks
    it is necessary to refresh the screen. To force Qt to update the screen, call
    `update()` manually. Also, we must update the viewport whenever the window screen
    has been resized by calling `glViewport(x, y ,``width, height)`.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering 2D shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have already learned how to draw our first rectangle on screen, we
    will further enhance it in this section. We will take the previous example and
    continue from there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `renderwindow.h` and add two more VBOs, one called `vbo_vertices2`
    and another called `vbo_colors`, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: static const char *vertexShaderSource =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"#version 330 core\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"layout(location = 0) in vec2 posAttr;\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"layout(location = 1) in vec3 colAttr;\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"out vec3 fragCol;\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"void main() {\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"fragCol = colAttr;\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"gl_Position = vec4(posAttr, 1.0, 1.0); }";'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the highlighted code to the fragment shader, which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the vertices array to something like the following code. What we’re
    doing here is creating three arrays that keep the vertices of two triangles and
    their colors so that we can pass them to the fragment shader at a later stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we already initialized `vbo_vertices` in the previous example, this time,
    we only need to initialize two other VBOs, namely `vbo_vertices` and `vbo_colors`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we start drawing the triangle using `glDrawArrays()`, we must also add
    the data of `vbo_colors` into our shader’s `colAttr` attribute. Make sure you
    call `bind()` to set the VBO as the current active VBO, before sending the data
    to the shader. The location ID (in this case, `0` and `1`) must match the location
    ID that’s used in your shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right after the preceding code, we will send `vbo_vertices2` and `vbo_colors`
    to the shader attribute and call `glDrawArrays()` again to draw the second triangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you build the program now, you should be able to see two triangles on screen,
    and one of the triangles sitting on top of the other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Two colorful triangles overlapping each other](img/B20976_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Two colorful triangles overlapping each other
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The geometric primitive types supported by OpenGL are points, lines, line strips,
    line loops, polygons, quads, quad strips, triangles, triangle strips, and triangle
    fans. In this example, we drew two triangles, where each of the shapes is provided
    with a set of vertices and colors so that OpenGL knows how the shapes should be
    rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The rainbow color effect is created by giving a different color to each of the
    vertices. OpenGL will automatically interpolate the colors between each vertex
    and display it on screen. Currently, the shape that gets rendered first will appear
    at the back of other shapes that get rendered later. This is because we are rendering
    the shapes in a 2D space and no depth information is involved to check which shape
    is located at the front and so on. We will learn how to do depth checking in the
    following example.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering 3D shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to draw simple 2D shapes onscreen in the previous section. However,
    to fully utilize the OpenGL API, we also need to learn how to use it to render
    3D images. In a nutshell, 3D images are simply illusions that are created using
    2D shapes, stacked in such a way that it makes them look like they’re 3D.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main ingredient here is the depth value, which determines which shapes
    should appear in front of or behind the other shapes. The primitive shape that
    is positioned behind another surface (with a shallower depth than another shape)
    will not be rendered (or will be partially rendered). OpenGL provides a simple
    way to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue our project from the previous 2D example. Enable depth testing
    by adding `glEnable(GL_DEPTH_TEST)` to the `initializeGL()` function in `renderwindow.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: QSurfaceFormat format;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: format.setProfile(QSurfaceFormat::CoreProfile);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: format.setVersion(3, 2);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'vbo_colors VBO for the same reason:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `paintEvent()` function, we must add `GL_DEPTH_BUFFER_BIT` to the `glClear()`
    function since we enabled depth checking in `initializeGL()` in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we need to send a piece of matrix information to the shader called
    **ModelView-Projection** (**MVP**) so that the GPU knows how to render the 3D
    shapes on a 2D screen. The MVP matrix is the result of multiplication between
    the projection matrix, view matrix, and model matrix. The multiplication order
    is very important so that you get the correct result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the last value in `glDrawArrays()` to `36` since we now have 36 triangles
    in the cube shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have to go back to our shader code and change some parts of it, as highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you build and run the project now, you should see a colorful cube appear
    on the screen. We use the same vertices array for the color, which gives this
    colorful result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Colorful 3D cube rendered with OpenGL](img/B20976_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Colorful 3D cube rendered with OpenGL
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the result looks pretty good, if we want to really show off the
    3D effect, it would be by animating the cube. To do that, first, we need to open
    up `renderwindow.h` and include the following header to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following variables to `renderwindow.h`. Note that you are allowed
    to initialize variables in the header file in modern C++ standard, which was not
    the case back in the older C++ standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open up `renderwindow.cpp` and add the following highlighted code to the class
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: void RenderWindow::paintEvent(QPaintEvent *event) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Q_UNUSED(event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Delta time for each frame
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: currentTime = time->elapsed();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: deltaTime = (float)(currentTime - oldTime) / 1000.0f;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'rotation variable to the rotate() function, like so:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `update()` function at the end of the `paintEvent()` function so that
    `paintEvent()` will be called again and again at the end of each draw call. Since
    we are changing the rotation value in the `paintEvent()` function, we can give
    the viewer the illusion of a rotating cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you compile and run the program now, you should see a spinning cube in your
    render window!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any 3D rendering, depth is very important and hence we need to enable the
    depth testing feature in OpenGL by calling `glEnable(GL_DEPTH_TEST)`. When we
    clear the buffer, we must also specify `GL_DEPH_BUFFER_BIT` so that the depth
    information is also being cleared, in order for the next image to be rendered
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We use the MVP matrix in OpenGL so that the GPU knows how to render the 3D graphics
    correctly. In OpenGL 3 and later versions, OpenGL no longer handles this automatically
    through fixed functions. Programmers are given the freedom and flexibility to
    define their own matrices based on their use cases, and then simply supply it
    to the GPU through a shader for rendering the final image. The model matrix contains
    the transformation data of the 3D object, namely the position, rotation, and scale
    of the object. The view matrix, on the other hand, is the camera or view information.
    Lastly, the projection matrix tells the GPU which projection method to use when
    projecting the 3D world onto the 2D screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we used the perspective projection method, which gives a better
    perception of distance and depth. The opposite of perspective projection is **orthographic
    projection**, which makes everything look flat and parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Differences between perspective and orthographic views](img/B20976_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Differences between perspective and orthographic views
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used a timer to increase the rotation value by 50 by multiplying
    it with the `deltaTime` value. The `deltaTime` value varies, depending on your
    rendering frame rate. However, it makes the resulting animation speed consistent
    across different hardware that renders at a different frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to call `update()` manually so that the screen gets refreshed, otherwise
    the cube will not be animated.
  prefs: []
  type: TYPE_NORMAL
- en: Texturing in OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL allows us to map an image (also referred to as a `BMP`, `JPEG`, `PNG`,
    `TARGA`, `TIFF`, and so on), and you do not have to implement it by yourself.
    We will use the previous example with a spinning cube and try to map it with a
    texture!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s follow these steps to learn how to use textures in OpenGL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `renderwindow.h` and add the variables that are highlighted in the
    following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: void RenderWindow::initializeGL()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: openGLFunctions = openGLContext->functions();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: glEnable(GL_DEPTH_TEST);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'texture variable under the QOpenGLTexture class. We will load a texture called
    brick.jpg from our application folder and flip the image by calling mirrored().
    OpenGL uses a different coordinate system, which is why we need to flip our texture
    before passing it to the shader. We will also set the min and max filters to Nearest
    and Linear accordingly, like so:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another array called `uvs`. This is where we save the texture coordinates
    for our `cube` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have to amend our vertex shader so that it takes in the texture coordinates
    for calculating where the texture will be applied to the object’s surface. Here,
    we simply pass the texture coordinate to the fragment shader without modifying:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the fragment shader, we create a texture by calling the `texture()` function,
    which receives the texture coordinate information from `fragUV` and the image
    sampler from `tex`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have to initialize the VBO for the texture coordinate as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `paintEvent()` function, we must send the texture coordinate information
    to the shader and then bind the texture before calling `glDrawArrays()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you compile and run the program now, you should see a brick cube rotating
    on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Our 3D cube now looks like it was created from bricks](img/B20976_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Our 3D cube now looks like it was created from bricks
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt 6 makes loading textures a really easy job. All it takes is just a single
    line of code to load an image file, flip it, and convert it into an OpenGL-compatible
    texture. The texture coordinates are pieces of information that let OpenGL know
    how to stick the texture onto the object’s surface before displaying it on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `min` and `max` filters are filters that make the texture look better when
    it is applied on a surface that is bigger than what its resolution can cover.
    The default setting for this is `GL_NEAREST`, which stands for `GL_LINEAR`, which
    stands for `GL_NEAREST`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 - Differences between GL_NEAREST and GL_LINEAR](img/B20976_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 - Differences between GL_NEAREST and GL_LINEAR
  prefs: []
  type: TYPE_NORMAL
- en: Basic lighting in OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to add a simple point light to our 3D scene
    by using OpenGL and Qt 6.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we will use the previous example and add a point light near the spinning
    cube. Open up `renderwindow.h` and add another variable called `vbo_normals` to
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `renderwindow.cpp` and add another array called `normals` to the `initializeGL()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the `vbo_normals` VBO in `initializeGL()` by adding the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the shader we will be writing this time will be much longer than what
    we used in the previous examples, let’s move the shader code over to text files
    and load them into the program by calling `addShaderFromSourceFile()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are done with that, add the following code to the `paintEvent()` function
    to pass the `normals` VBO over to the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s open up the two text files we just created that contain the shader code.
    First, we need to make some changes to the vertex shader, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also make some changes to the fragment shader. We will create a function
    called `calcPointLight()` in the shader code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: // Diffuse
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: float diffuseStrength = 1.0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: float diff = clamp(dot(fragNormal, lightDir), 0.0, 1.0);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: vec4 diffuse = diffuseStrength * diff * texCol * lightColor * lightIntensity;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return diffuse;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void main() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: vec4 finalColor = calcPointLight();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: col = finalColor;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you compile and run the program now, you should see the lighting in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Our 3D cube now has shading](img/B20976_05_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Our 3D cube now has shading
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In OpenGL 3 and later versions, fixed-function lighting no longer exists. You
    can no longer call `glEnable(GL_LIGHT1)` to add light to your 3D scene. The new
    method for adding light is to calculate your own lighting in the shader. This
    gives you the flexibility of creating all types of lights, depending on your needs.
    The old method has a limitation of up to 16 lights in most hardware but, with
    the new programmable pipeline, you can have any number of lights in the scene;
    however, the lighting model will need to be coded entirely by you in the shaders,
    which is not an easy task.
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, we also need to add a surface normal value to every surface
    of the cube. Surface normal indicates where the surface is facing and is used
    for lighting calculations. The preceding example is very simplified to let you
    understand how lighting works in OpenGL. In actual use cases, you may need to
    pass some variables such as light intensity, light color, and light position from
    C++ or load it from a material file instead of hardcoding it in the shader code.
  prefs: []
  type: TYPE_NORMAL
- en: Moving an object using keyboard controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be looking at how to move an object in OpenGL using
    keyboard controls. Qt provides an easy way to detect keyboard events using virtual
    functions, namely `keyPressEvent()` and `keyReleaseEvent()`. We will be using
    the previous example and adding to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To move an object using keyboard controls, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `renderwindow.h` and declare two floating-point numbers called `moveX`
    and `moveZ`. Then, declare a `QVector3D` variable called `movement`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'protected:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void initializeGL();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void paintEvent(QPaintEvent *event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void resizeEvent(QResizeEvent *event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void keyPressEvent(QKeyEvent *event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void keyReleaseEvent(QKeyEvent *event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will implement the `keyPressEvent()` function in `renderwindow.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also implement the `keyReleaseEvent()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we will comment out the rotation code in `paintEvent()` and add
    the movement code, as highlighted in the following snippet. We do not want to
    get distracted by the rotation and just want to focus on the movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you compile and run the program now, you should be able to move the cube
    around by pressing *W*, *A*, *S*, and *D*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we did here was constantly add the `moveX` and `moveZ` values’ `movement`
    vector’s `x` and `z` values. When a key is pressed, `moveX` and `moveZ` will become
    a positive or negative number, depending on which button is pressed; otherwise,
    it will be zero. In the `keyPressEvent()` function, we checked whether the keyboard
    button that was pressed was *W*, *A*, *S*, or *D*; we then set the variables accordingly.
    To get the full list of key names that are used by Qt, visit [http://doc.qt.io/qt-6/qt.html#Key-enum](http://doc.qt.io/qt-6/qt.html#Key-enum).
  prefs: []
  type: TYPE_NORMAL
- en: One way we can create movement input is by holding down the same key and not
    releasing it. Qt 6 will repeat the key press event after an interval, but it is
    not very fluid as modern operating systems limit the key press event to prevent
    double typing. The keyboard input interval varies between different operating
    systems. You can set the interval by calling `QApplication::setKeyboardInterval()`,
    but this may not work on every operating system. Therefore, we did not go for
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we only set `moveX` and `moveZ` once when the key was pressed or released,
    and then we constantly apply the value to the movement vector in our game loop
    so that it is moving continuously without being affected by the input interval.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick 3D in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to render 3D images using Qt 6.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s learn how to use a 3D canvas in QML by following this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start this example by creating a new project in Qt Creator. This time
    around, we will go for **Qt Quick Application** and not the other options that
    we chose in the previous examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Creating a new Qt Quick Application project](img/B20976_05_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Creating a new Qt Quick Application project
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project is created, you are required to create a resource file by
    going to `resource.qrc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Creating a Qt resource file](img/B20976_05_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Creating a Qt resource file
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an image file to our project resources—we will be using it in this example.
    Open up `resource.qrc` with Qt Creator by right-clicking on it in the `brick.jpg`
    image, which will be used as the surface texture for our 3D object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Adding brick texture into the resource file](img/B20976_05_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Adding brick texture into the resource file
  prefs: []
  type: TYPE_NORMAL
- en: After that, open up `main.qml` using Qt Creator. You will see that there are
    already a few lines of code written in the file. What it does is basically open
    up an empty window and nothing else. Let’s start adding our own code to the `Window`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, import the `QtQuick3D` module to our project and create a `View3D` object
    under the `Window` object, which we will be using to render a 3D scene on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, set the `environment` variable of the `View3D` object as a new
    `SceneEnvironment` object. We use this to set the background color of our 3D view
    to sky blue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we re-create the 3D cube from our previous OpenGL example by declaring
    a `Model` object inside our 3D view and setting its source as `Cube`. We then
    rotate it by `-30` units along the y-axis and apply a material to it. After that,
    we set the texture of the material as `brick.jpg`. The keyword `qrc:` here means
    we are taking the texture from the resource file we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we’re able to see our 3D cube clearly, we must create a light source
    as well as a camera, which helps to render our scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are done, build and run the project. You should be able to see a 3D
    cube with a brick texture on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Re-creating the 3D demo in QtQuick3D](img/B20976_05_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Re-creating the 3D demo in QtQuick3D
  prefs: []
  type: TYPE_NORMAL
- en: 'To re-create the spinning animation, let’s add `NumberAnimation` to our cube
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally, Qt 5 used something called `three.js` library/API that used WebGL
    technology to display animated 3D computer graphics in a Qt Quick window. However,
    this feature has been completely deprecated in Qt 6 and has been since replaced
    by another module called **Qt** **Quick 3D**.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick 3D works a lot better than Qt Canvas 3D as it uses native methods for
    rendering 3D scenes without depending on a third-party library such as `three.js`.
    It also produces better performance and integrates well with any existing Qt Quick
    components.
  prefs: []
  type: TYPE_NORMAL
