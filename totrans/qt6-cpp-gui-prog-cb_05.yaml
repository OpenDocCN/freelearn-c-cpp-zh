- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: OpenGL Implementation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL 实现
- en: In this chapter, we will learn how to use **Open Graphics Library** (**OpenGL**),
    a powerful rendering **application program interface** (**API**), and combine
    it with **Qt**. OpenGL is a cross-language, cross-platform API for drawing 2D
    and 3D graphics on screen through the **graphics processing unit** (**GPU**) within
    our computer’s graphics chip. In this chapter, we will be learning about OpenGL
    3 instead of 2 because, even though the fixed-function pipeline is easier for
    beginners to grasp compared to the newer programmable pipeline, it is considered
    legacy code and has been deprecated by most modern 3D rendering software. Qt 6
    supports both versions, so there should be no problem switching over to OpenGL
    2 if you need backward compatibility for your software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 **开放图形库** (**OpenGL**)，一个强大的渲染 **应用程序程序接口** (**API**)，并将其与 **Qt**
    结合使用。OpenGL 是一个跨语言、跨平台的 API，它通过我们计算机图形芯片内的 **图形处理单元** (**GPU**) 在屏幕上绘制 2D 和 3D
    图形。在本章中，我们将学习 OpenGL 3 而不是 2，因为尽管与较新的可编程管道相比，固定功能管道对初学者来说更容易理解，但它被认为是遗留代码，并且已被大多数现代
    3D 渲染软件弃用。Qt 6 支持这两个版本，因此如果你需要软件的向后兼容性，切换到 OpenGL 2 应该没有问题。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Setting up OpenGL in Qt
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Qt 中设置 OpenGL
- en: Hello World!
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hello World!
- en: Rendering 2D shapes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染 2D 形状
- en: Rendering 3D shapes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染 3D 形状
- en: Texturing in OpenGL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL 中的纹理
- en: Basic lighting in OpenGL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL 中的基本光照
- en: Moving an object using keyboard controls
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键盘控制移动对象
- en: Qt Quick 3D in QML
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick 3D 在 QML 中
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter include Qt 6.6.1 MinGW 64-bit and
    Qt Creator 12.0.2\. All the code used in this chapter can be downloaded from the
    following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter05](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter05).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括 Qt 6.6.1 MinGW 64 位和 Qt Creator 12.0.2。本章中使用的所有代码都可以从以下 GitHub 仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter05](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter05)。
- en: Setting up OpenGL in Qt
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Qt 中设置 OpenGL
- en: In this recipe, we will learn how to set up OpenGL in Qt 6.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在 Qt 6 中设置 OpenGL。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to learn how to set up OpenGL in Qt:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何在 Qt 中设置 OpenGL：
- en: Create a new `mainwindow.ui`, `mainwindow.h`, and `mainwindow.cpp` files.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `mainwindow.ui`、`mainwindow.h` 和 `mainwindow.cpp` 文件。
- en: 'Open up your project file (`.pro`) and add the OpenGL module to your project
    by adding an `opengl` keyword behind `QT +=`; after that, run `qmake` to reload
    the project modules:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的项目文件（`.pro`）并在 `QT +=` 后面添加 `opengl` 关键字，然后运行 `qmake` 重新加载项目模块：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You also need to add another line in your project file so that it will load
    both the OpenGL and **OpenGL Utilities** (**GLU**) libraries during startup. Without
    these two libraries, your program will not be able to run:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要在项目文件中添加另一行，以便在启动时加载 OpenGL 和 **OpenGL 实用工具** (**GLU**) 库。没有这两个库，你的程序将无法运行：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open up `main.cpp` and replace `mainwindow.h` with the `QtOpenGL` header:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `main.cpp` 并将 `mainwindow.h` 替换为 `QtOpenGL` 头文件：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remove all of the code related to the `MainWindow` class from your `main.cpp`
    file and replace it with the code that’s highlighted in the following snippet:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的 `main.cpp` 文件中删除所有与 `MainWindow` 类相关的代码，并用以下片段中突出显示的代码替换：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you compile and run the project now, you will see an empty window with a
    black background. Don’t worry about it—your program is now running on OpenGL:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行项目，你将看到一个背景为黑色的空窗口。不要担心——你的程序现在正在 OpenGL 上运行：
- en: '![Figure 5.1 - An empty OpenGL window](img/B20976_05_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 - 一个空的 OpenGL 窗口](img/B20976_05_001.jpg)'
- en: Figure 5.1 - An empty OpenGL window
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 - 一个空的 OpenGL 窗口
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `OpenGL` module must be added to the project file (`.pro`) in order to access
    header files that are related to OpenGL, such as `QtOpenGL` and `QOpenGLFunctions`.
    We used the `QOpenGLWindow` class instead of `QMainWindow` for the main window
    because it is designed to easily create windows that perform OpenGL rendering,
    and it offers better performance compared to `QOpenGLWidget` due to the fact that
    it has no dependencies in its widget module.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问与OpenGL相关的头文件，例如`QtOpenGL`和`QOpenGLFunctions`，必须在项目文件（`.pro`）中添加`OpenGL`模块。我们使用`QOpenGLWindow`类而不是`QMainWindow`作为主窗口，因为它旨在轻松创建执行OpenGL渲染的窗口，并且由于它在其小部件模块中没有依赖项，因此与`QOpenGLWidget`相比提供了更好的性能。
- en: We must call `setSurfaceType(QWindow::OpenGLSurface)` to tell Qt we would prefer
    to use OpenGL to render the images to screen instead of `QPainter`. The `QOpenGLWindow`
    class provides several virtual functions (`initializeGL()`, `resizeGL()`, `paintGL()`,
    and so on) for us to conveniently set up OpenGL and perform graphics rendering.
    We will be learning how to use these functions in the following example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须调用`setSurfaceType(QWindow::OpenGLSurface)`来告诉Qt我们更愿意使用OpenGL将图像渲染到屏幕上而不是使用`QPainter`。`QOpenGLWindow`类提供了几个虚拟函数（`initializeGL()`、`resizeGL()`、`paintGL()`等），使我们能够方便地设置OpenGL并执行图形渲染。我们将在下面的示例中学习如何使用这些函数。
- en: There’s more…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: OpenGL is a cross-language, cross-platform API for drawing 2D and 3D graphics
    on screen through the GPU within our computer’s graphics chip. Computer graphics
    technology has been evolving rapidly over the years—so rapidly that the software
    industry can hardly keep up with its pace.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL是我们计算机图形芯片内通过GPU绘制2D和3D图形的跨语言、跨平台API。计算机图形技术多年来一直在快速发展——发展如此之快，以至于软件行业几乎跟不上其步伐。
- en: In 2008, the Khronos Group, the company that maintains and develops OpenGL,
    announced the release of the OpenGL 3.0 specification, which created a huge uproar
    and controversy throughout the industry. That was mainly because OpenGL 3.0 was
    supposed to deprecate the entire fixed-function pipeline from the OpenGL API,
    and it was simply an impossible task for the big players to make the sudden switch
    overnight from a fixed-function pipeline to a programmable pipeline. This resulted
    in two different major versions of OpenGL being maintained.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在2008年，维护和开发OpenGL的Khronos Group公司宣布发布了OpenGL 3.0规范，这在整个行业中引起了巨大的骚动和争议。这主要是因为OpenGL
    3.0本应从OpenGL API中废弃整个固定功能管道，对于大玩家来说，从固定功能管道突然一夜之间切换到可编程管道几乎是不可能的任务。这导致了维护两个不同主要版本的OpenGL。
- en: In this chapter, we will use the newer OpenGL 3 instead of the older, deprecated
    OpenGL 2\. The coding style and syntax are very different between these two versions,
    which makes the switchover very troublesome. However, the performance improvement
    will make it worth the time it takes to switch over to OpenGL 3.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用较新的OpenGL 3而不是较旧的已废弃的OpenGL 2。这两个版本之间的编码风格和语法非常不同，这使得切换非常麻烦。然而，性能提升将使切换到OpenGL
    3所花费的时间变得值得。
- en: Hello World!
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World!
- en: In this chapter, we will learn how to use OpenGL 3 with Qt 6\. Common OpenGL
    functions such as `glBegin`, `glVertex2f`, `glColor3f`, `glMatrixMode`, and `glLoadIdentity`
    have all been removed from OpenGL 3\. OpenGL 3 uses `glVertex2f()`, which slows
    down the rendering while waiting for the CPU to submit the data one by one. Therefore,
    we will pack all of the data into VBOs and send it all in one huge package to
    the GPU and instruct the GPU to calculate the resulting pixels through shader
    programming. We will also be learning how to create simple **shader programs**
    through a C-like programming language called **OpenGL Shading** **Language** (**GLSL**).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Qt 6的OpenGL 3。常见的OpenGL函数，如`glBegin`、`glVertex2f`、`glColor3f`、`glMatrixMode`和`glLoadIdentity`，都已从OpenGL
    3中删除。OpenGL 3使用`glVertex2f()`，这会减慢渲染速度，因为需要等待CPU逐个提交数据。因此，我们将所有数据打包到VBO中，一次性发送给GPU，并指导GPU通过着色器编程计算结果像素。我们还将学习如何通过类似于C的编程语言**OpenGL着色器语言**（**GLSL**）创建简单的**着色器程序**。
- en: How to do it…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s get started by following these steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始：
- en: 'We will create a new class called `RenderWindow`, which inherits from the `QOpenGLWindow`
    class. Go to `RenderWindow` and set its base class as `QOpenGLWindow`. Then, proceed
    to create the C++ class:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的类`RenderWindow`，它继承自`QOpenGLWindow`类。转到`RenderWindow`并设置其基类为`QOpenGLWindow`。然后，继续创建C++类：
- en: '![Figure 5.2 – Defining your custom render window class](img/B20976_05_002.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 定义你的自定义渲染窗口类](img/B20976_05_002.jpg)'
- en: Figure 5.2 – Defining your custom render window class
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 定义你的自定义渲染窗口类
- en: 'Go to the `renderwindow.h` file we just created and add the following headers
    at the top of the source code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往我们刚刚创建的`renderwindow.h`文件，并在源代码顶部添加以下头文件：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to create several functions and variables that look like this:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建几个看起来像这样的函数和变量：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will continue and add some private variables:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续并添加一些私有变量：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open up `renderwindow.cpp` and define the class constructor as follows. We
    must tell the render window to use the OpenGL surface type; enable **core profile**
    (rather than **compatibility profile**) that runs version 3.2; create an OpenGL
    context; and, finally, apply the profile we just created into the context:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`renderwindow.cpp`文件，并按如下定义类构造函数。我们必须告诉渲染窗口使用OpenGL表面类型；启用**核心配置文件**（而不是**兼容性配置文件**），运行3.2版本；创建OpenGL上下文；最后，将我们刚刚创建的配置文件应用到上下文中：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to define the `initializeGL()` function as follows. This function will
    be called before the rendering starts. First, we define the **vertex shader**
    and the **fragment shader**:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要按如下定义`initializeGL()`函数。这个函数将在渲染开始之前被调用。首先，我们定义**顶点着色器**和**片段着色器**：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We initiate `shaderProgram` and declare a vertices array. Then, we also create
    a `QOpenGLVertexArrayObject` object:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化`shaderProgram`并声明一个顶点数组。然后，我们创建一个`QOpenGLVertexArrayObject`对象：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s continue to write our code by defining `vbo_vertices`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续编写我们的代码，通过定义`vbo_vertices`：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will start by adding some code to the `paintEvent()` function:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先向`paintEvent()`函数添加一些代码：
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will then bind the VAO and shader program before calling `glDrawArrays()`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在调用`glDrawArrays()`之前绑定VAO和着色器程序：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can refresh the viewport whenever the render window is being resized by
    adding the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过添加以下代码在渲染窗口被调整大小时刷新视口：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you compile and run the project now, you should be able to see a red rectangle
    being drawn in front of a blue background:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行项目，你应该能够看到在蓝色背景前绘制的一个红色矩形：
- en: '![Figure 5.3 - Our first triangle rendered in OpenGL](img/B20976_05_003.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 - 使用OpenGL渲染的第一个三角形](img/B20976_05_003.jpg)'
- en: Figure 5.3 - Our first triangle rendered in OpenGL
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 使用OpenGL渲染的第一个三角形
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We must set the OpenGL version to 3.x and the surface format to the core profile
    so that we can access the newer shader pipeline, which is completely different
    from the older, deprecated compatibility profile. OpenGL 2.x still exists in the
    compatibility profile, solely for the sake of allowing OpenGL programs to run
    on old hardware. The profile that’s created must be applied to the OpenGL context
    before it will work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将OpenGL版本设置为3.x，并将表面格式设置为核心配置文件，以便我们可以访问全新的着色器管道，这与旧的、已弃用的兼容性配置文件完全不同。OpenGL
    2.x仍然存在于兼容性配置文件中，仅为了允许OpenGL程序在旧硬件上运行。创建的配置文件必须在它生效之前应用到OpenGL上下文中。
- en: In OpenGL 3 and the later versions, most of the calculations are done in the
    GPU through shader programs, since all of the common fixed functions have now
    been completely deprecated. Therefore, we created a very simple vertex shader
    and fragment shader in the preceding example.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL 3及其后续版本中，大多数计算都是在GPU通过着色器程序完成的，因为所有常见的固定功能函数现在都已完全弃用。因此，我们在前面的例子中创建了一个非常简单的顶点着色器和片段着色器。
- en: 'A shader program consists of three different parts: **geometry shader** (optional),
    vertex shader, and fragment shader. The geometry shader calculates the creation
    of geometry before passing the data to the vertex shader; the vertex shader handles
    the position and motion of the vertices before passing the data to the fragment
    shader; and finally, the fragment shader calculates and displays the resulting
    pixels on the screen.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器程序由三个不同的部分组成：**几何着色器**（可选）、顶点着色器和片段着色器。几何着色器在将数据传递给顶点着色器之前计算几何体的创建；顶点着色器在将数据传递给片段着色器之前处理顶点的位置和运动；最后，片段着色器计算并显示屏幕上的最终像素。
- en: In the preceding example, we only used vertex and fragment shaders and excluded
    the geometry shader since it is optional. You can save the GLSL code in a text
    file and load it into your Qt 6 program by calling `addShaderFromFile()`, but
    since our shaders are very simple and short, we just define it directly in our
    C++ source code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只使用了顶点和片段着色器，并排除了几何着色器，因为它是可选的。你可以将GLSL代码保存到文本文件中，并通过调用`addShaderFromFile()`将其加载到你的Qt
    6程序中，但由于我们的着色器非常简单且简短，我们只是在C++源代码中直接定义它。
- en: After that, we use the VBO to store the vertex positions in bulk before sending
    it to the GPU. We can also use the VBO to store other information such as normals,
    texture coordinates, and vertex colors. You can send anything you want to the
    GPU as long as it matches the input inside your shader code. Then, we add the
    VBO into a **vertex array object** (**VAO**) and send the whole VAO to the GPU
    for processing. You can add many different VBOs into the VAO since the VAO is
    just like any ordinary C++ array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用VBO批量存储顶点位置，然后将其发送到GPU。我们还可以使用VBO存储其他信息，例如法线、纹理坐标和顶点颜色。只要它与你的着色器代码中的输入匹配，你就可以将任何东西发送到GPU。然后，我们将VBO添加到**顶点数组对象**（**VAO**）中，并将整个VAO发送到GPU进行处理。由于VAO就像任何普通的C++数组一样，你可以将许多不同的VBO添加到VAO中。
- en: Just like what we have learned in the previous chapters, all drawings happen
    within the `paintEvent()` function, and it will only be called by Qt when it thinks
    it is necessary to refresh the screen. To force Qt to update the screen, call
    `update()` manually. Also, we must update the viewport whenever the window screen
    has been resized by calling `glViewport(x, y ,``width, height)`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前面的章节中学到的，所有的绘图都发生在`paintEvent()`函数中，并且只有当Qt认为有必要刷新屏幕时，它才会被调用。要强制Qt更新屏幕，请手动调用`update()`。此外，每次窗口屏幕被调整大小时，我们必须通过调用`glViewport(x,
    y, width, height)`来更新视口。
- en: Rendering 2D shapes
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染2D形状
- en: Since we have already learned how to draw our first rectangle on screen, we
    will further enhance it in this section. We will take the previous example and
    continue from there.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经学会了如何在屏幕上绘制第一个矩形，我们将在本节中进一步改进它。我们将从上一个例子继续进行。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s get started by following this example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例开始：
- en: 'Open up `renderwindow.h` and add two more VBOs, one called `vbo_vertices2`
    and another called `vbo_colors`, as highlighted in the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`renderwindow.h`并添加两个额外的VBO，一个称为`vbo_vertices2`，另一个称为`vbo_colors`，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: static const char *vertexShaderSource =
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: static const char *vertexShaderSource =
- en: '"#version 330 core\n"'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"#version 330 core\n"'
- en: '"layout(location = 0) in vec2 posAttr;\n"'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"layout(location = 0) in vec2 posAttr;\n"'
- en: '"layout(location = 1) in vec3 colAttr;\n"'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"layout(location = 1) in vec3 colAttr;\n"'
- en: '"out vec3 fragCol;\n"'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"out vec3 fragCol;\n"'
- en: '"void main() {\n"'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"void main() {\n"'
- en: '"fragCol = colAttr;\n"'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"fragCol = colAttr;\n"'
- en: '"gl_Position = vec4(posAttr, 1.0, 1.0); }";'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"gl_Position = vec4(posAttr, 1.0, 1.0); }";'
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the highlighted code to the fragment shader, which looks like this:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将高亮显示的代码添加到片段着色器中，如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Change the vertices array to something like the following code. What we’re
    doing here is creating three arrays that keep the vertices of two triangles and
    their colors so that we can pass them to the fragment shader at a later stage:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点数组更改为以下代码类似的内容。我们在这里做的是创建三个数组，它们保存两个三角形的顶点和它们的颜色，以便我们可以在稍后的阶段将它们传递给片段着色器：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since we already initialized `vbo_vertices` in the previous example, this time,
    we only need to initialize two other VBOs, namely `vbo_vertices` and `vbo_colors`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在前面的例子中已经初始化了`vbo_vertices`，这次我们只需要初始化另外两个VBO，即`vbo_vertices`和`vbo_colors`：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before we start drawing the triangle using `glDrawArrays()`, we must also add
    the data of `vbo_colors` into our shader’s `colAttr` attribute. Make sure you
    call `bind()` to set the VBO as the current active VBO, before sending the data
    to the shader. The location ID (in this case, `0` and `1`) must match the location
    ID that’s used in your shader:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始使用`glDrawArrays()`绘制三角形之前，我们还必须将`vbo_colors`的数据添加到我们的着色器的`colAttr`属性中。确保在将数据发送到着色器之前调用`bind()`来设置VBO为当前活动VBO。位置ID（在这种情况下，`0`和`1`）必须与你的着色器中使用的位置ID匹配：
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Right after the preceding code, we will send `vbo_vertices2` and `vbo_colors`
    to the shader attribute and call `glDrawArrays()` again to draw the second triangle:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码之后，我们将发送`vbo_vertices2`和`vbo_colors`到着色器属性，并再次调用`glDrawArrays()`来绘制第二个三角形：
- en: '[PRE20]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you build the program now, you should be able to see two triangles on screen,
    and one of the triangles sitting on top of the other:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在构建程序，你应该能在屏幕上看到两个三角形，其中一个三角形位于另一个三角形之上：
- en: '![Figure 5.4 – Two colorful triangles overlapping each other](img/B20976_05_004.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 两个相互重叠的有色三角形](img/B20976_05_004.jpg)'
- en: Figure 5.4 – Two colorful triangles overlapping each other
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 两个相互重叠的有色三角形
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The geometric primitive types supported by OpenGL are points, lines, line strips,
    line loops, polygons, quads, quad strips, triangles, triangle strips, and triangle
    fans. In this example, we drew two triangles, where each of the shapes is provided
    with a set of vertices and colors so that OpenGL knows how the shapes should be
    rendered.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 支持的几何原语类型包括点、线、线段、线环、多边形、四边形、四边形带、三角形、三角形带和三角形扇。在这个例子中，我们画了两个三角形，每个形状都提供了一组顶点和颜色，这样
    OpenGL 就知道如何渲染这些形状。
- en: The rainbow color effect is created by giving a different color to each of the
    vertices. OpenGL will automatically interpolate the colors between each vertex
    and display it on screen. Currently, the shape that gets rendered first will appear
    at the back of other shapes that get rendered later. This is because we are rendering
    the shapes in a 2D space and no depth information is involved to check which shape
    is located at the front and so on. We will learn how to do depth checking in the
    following example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 彩虹色效果是通过给每个顶点赋予不同的颜色来创建的。OpenGL 将自动在每两个顶点之间插值颜色，并在屏幕上显示。目前，首先渲染的形状将出现在后来渲染的其他形状的后面。这是因为我们正在
    2D 空间中渲染形状，没有涉及深度信息来检查哪个形状位于前面等等。我们将在下面的例子中学习如何进行深度检查。
- en: Rendering 3D shapes
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染 3D 形状
- en: We learned how to draw simple 2D shapes onscreen in the previous section. However,
    to fully utilize the OpenGL API, we also need to learn how to use it to render
    3D images. In a nutshell, 3D images are simply illusions that are created using
    2D shapes, stacked in such a way that it makes them look like they’re 3D.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何在屏幕上绘制简单的 2D 形状。然而，为了充分利用 OpenGL API，我们还需要学习如何使用它来渲染 3D 图像。简而言之，3D
    图像只是使用 2D 形状创建的幻觉，这些形状堆叠在一起，使得它们看起来像是 3D 的。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The main ingredient here is the depth value, which determines which shapes
    should appear in front of or behind the other shapes. The primitive shape that
    is positioned behind another surface (with a shallower depth than another shape)
    will not be rendered (or will be partially rendered). OpenGL provides a simple
    way to achieve this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要成分是深度值，它决定了哪些形状应该出现在其他形状的前面或后面。位于另一个表面后面（深度比另一个形状浅）的原始形状将不会被渲染（或只会部分渲染）。OpenGL
    提供了一种简单的方法来实现这一点：
- en: 'Let’s continue our project from the previous 2D example. Enable depth testing
    by adding `glEnable(GL_DEPTH_TEST)` to the `initializeGL()` function in `renderwindow.cpp`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续我们的上一个 2D 示例项目。通过在 `renderwindow.cpp` 中的 `initializeGL()` 函数中添加 `glEnable(GL_DEPTH_TEST)`
    来启用深度测试：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: QSurfaceFormat format;
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QSurfaceFormat format;
- en: format.setProfile(QSurfaceFormat::CoreProfile);
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: format.setProfile(QSurfaceFormat::CoreProfile);
- en: format.setVersion(3, 2);
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: format.setVersion(3, 2);
- en: 'vbo_colors VBO for the same reason:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vbo_colors VBO 同样的原因：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `paintEvent()` function, we must add `GL_DEPTH_BUFFER_BIT` to the `glClear()`
    function since we enabled depth checking in `initializeGL()` in the previous step:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `paintEvent()` 函数中，我们必须在 `glClear()` 函数中添加 `GL_DEPTH_BUFFER_BIT`，因为我们已经在上一步骤中的
    `initializeGL()` 中启用了深度测试：
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, we need to send a piece of matrix information to the shader called
    **ModelView-Projection** (**MVP**) so that the GPU knows how to render the 3D
    shapes on a 2D screen. The MVP matrix is the result of multiplication between
    the projection matrix, view matrix, and model matrix. The multiplication order
    is very important so that you get the correct result:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要向一个称为 **模型视图-投影** (**MVP**) 的着色器发送一段矩阵信息，这样 GPU 就知道如何在 2D 屏幕上渲染 3D 形状。MVP
    矩阵是投影矩阵、视图矩阵和模型矩阵相乘的结果。乘法顺序非常重要，以确保你得到正确的结果：
- en: '[PRE25]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Change the last value in `glDrawArrays()` to `36` since we now have 36 triangles
    in the cube shape:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `glDrawArrays()` 中的最后一个值更改为 `36`，因为我们现在在立方体形状中有 36 个三角形：
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have to go back to our shader code and change some parts of it, as highlighted
    in the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须回到我们的着色器代码，并更改其中的一些部分，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you build and run the project now, you should see a colorful cube appear
    on the screen. We use the same vertices array for the color, which gives this
    colorful result:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行项目，你应该在屏幕上看到一个多彩的立方体出现。我们使用相同的顶点数组来着色，这给出了这个多彩的结果：
- en: '![Figure 5.5 – Colorful 3D cube rendered with OpenGL](img/B20976_05_005.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 使用 OpenGL 渲染的有色 3D 立方体](img/B20976_05_005.jpg)'
- en: Figure 5.5 – Colorful 3D cube rendered with OpenGL
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 使用OpenGL渲染的彩色3D立方体
- en: 'Even though the result looks pretty good, if we want to really show off the
    3D effect, it would be by animating the cube. To do that, first, we need to open
    up `renderwindow.h` and include the following header to it:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使结果看起来相当不错，如果我们真的想展示3D效果，那就需要通过动画化立方体来实现。要做到这一点，首先，我们需要打开`renderwindow.h`并将其包含以下头文件：
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, add the following variables to `renderwindow.h`. Note that you are allowed
    to initialize variables in the header file in modern C++ standard, which was not
    the case back in the older C++ standard:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下变量添加到`renderwindow.h`中。请注意，在现代C++标准中，您可以在头文件中初始化变量，这在旧的C++标准中是不允许的：
- en: '[PRE29]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Open up `renderwindow.cpp` and add the following highlighted code to the class
    constructor:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`renderwindow.cpp`并将以下高亮代码添加到类构造函数中：
- en: '[PRE30]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: void RenderWindow::paintEvent(QPaintEvent *event) {
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`void RenderWindow::paintEvent(QPaintEvent *event) {`'
- en: Q_UNUSED(event);
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Q_UNUSED(event);`'
- en: // Delta time for each frame
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 每帧的Delta时间
- en: currentTime = time->elapsed();
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`currentTime = time->elapsed();`'
- en: deltaTime = (float)(currentTime - oldTime) / 1000.0f;
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`deltaTime = (float)(currentTime - oldTime) / 1000.0f;`'
- en: 'rotation variable to the rotate() function, like so:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将旋转变量传递给rotate()函数，如下所示：
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Call the `update()` function at the end of the `paintEvent()` function so that
    `paintEvent()` will be called again and again at the end of each draw call. Since
    we are changing the rotation value in the `paintEvent()` function, we can give
    the viewer the illusion of a rotating cube:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`paintEvent()`函数的末尾调用`update()`函数，这样`paintEvent()`就会在每次绘制调用的末尾被反复调用。由于我们在`paintEvent()`函数中改变了旋转值，我们可以给观众一个旋转立方体的错觉：
- en: '[PRE33]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you compile and run the program now, you should see a spinning cube in your
    render window!
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在编译并运行程序，你应该能在渲染窗口中看到一个旋转的立方体！
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In any 3D rendering, depth is very important and hence we need to enable the
    depth testing feature in OpenGL by calling `glEnable(GL_DEPTH_TEST)`. When we
    clear the buffer, we must also specify `GL_DEPH_BUFFER_BIT` so that the depth
    information is also being cleared, in order for the next image to be rendered
    correctly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何3D渲染中，深度都非常重要，因此我们需要通过调用`glEnable(GL_DEPTH_TEST)`在OpenGL中启用深度测试功能。当我们清除缓冲区时，还必须指定`GL_DEPTH_BUFFER_BIT`，以便深度信息也被清除，以便正确渲染下一个图像。
- en: We use the MVP matrix in OpenGL so that the GPU knows how to render the 3D graphics
    correctly. In OpenGL 3 and later versions, OpenGL no longer handles this automatically
    through fixed functions. Programmers are given the freedom and flexibility to
    define their own matrices based on their use cases, and then simply supply it
    to the GPU through a shader for rendering the final image. The model matrix contains
    the transformation data of the 3D object, namely the position, rotation, and scale
    of the object. The view matrix, on the other hand, is the camera or view information.
    Lastly, the projection matrix tells the GPU which projection method to use when
    projecting the 3D world onto the 2D screen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用OpenGL中的MVP矩阵，这样GPU就知道如何正确渲染3D图形。在OpenGL 3及更高版本中，OpenGL不再通过固定函数自动处理这一点。程序员被赋予了根据他们的用例定义自己的矩阵的自由和灵活性，然后只需通过着色器将其提供给GPU以渲染最终图像。模型矩阵包含3D对象的变换数据，即对象的位置、旋转和缩放。另一方面，视图矩阵是相机或视图信息。最后，投影矩阵告诉GPU在将3D世界投影到2D屏幕时使用哪种投影方法。
- en: 'In our example, we used the perspective projection method, which gives a better
    perception of distance and depth. The opposite of perspective projection is **orthographic
    projection**, which makes everything look flat and parallel:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用了透视投影方法，这能更好地感知距离和深度。与透视投影相反的是**正交投影**，它使一切看起来都扁平且平行：
- en: '![Figure 5.6 – Differences between perspective and orthographic views](img/B20976_05_006.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – 透视视图和正交视图之间的差异](img/B20976_05_006.jpg)'
- en: Figure 5.6 – Differences between perspective and orthographic views
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 透视视图和正交视图之间的差异
- en: In this example, we used a timer to increase the rotation value by 50 by multiplying
    it with the `deltaTime` value. The `deltaTime` value varies, depending on your
    rendering frame rate. However, it makes the resulting animation speed consistent
    across different hardware that renders at a different frame rate.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用计时器通过将`deltaTime`值乘以50来增加旋转值。`deltaTime`值会根据您的渲染帧率而变化。然而，它使得不同硬件在不同帧率渲染时的动画速度保持一致。
- en: Remember to call `update()` manually so that the screen gets refreshed, otherwise
    the cube will not be animated.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记得手动调用 `update()` 以刷新屏幕，否则立方体将不会动画化。
- en: Texturing in OpenGL
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL 中的纹理化
- en: OpenGL allows us to map an image (also referred to as a `BMP`, `JPEG`, `PNG`,
    `TARGA`, `TIFF`, and so on), and you do not have to implement it by yourself.
    We will use the previous example with a spinning cube and try to map it with a
    texture!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 允许我们将图像（也称为 `BMP`、`JPEG`、`PNG`、`TARGA`、`TIFF` 等）映射到纹理上，而且你不必自己实现它。我们将使用之前的旋转立方体示例，并尝试使用纹理来映射它！
- en: How to do it…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s follow these steps to learn how to use textures in OpenGL:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤学习如何在 OpenGL 中使用纹理：
- en: 'Open up `renderwindow.h` and add the variables that are highlighted in the
    following code block:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `renderwindow.h` 并添加以下代码块中突出显示的变量：
- en: '[PRE34]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: void RenderWindow::initializeGL()
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void RenderWindow::initializeGL()
- en: '{'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: openGLFunctions = openGLContext->functions();
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: openGLFunctions = openGLContext->functions();
- en: glEnable(GL_DEPTH_TEST);
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: glEnable(GL_DEPTH_TEST);
- en: 'texture variable under the QOpenGLTexture class. We will load a texture called
    brick.jpg from our application folder and flip the image by calling mirrored().
    OpenGL uses a different coordinate system, which is why we need to flip our texture
    before passing it to the shader. We will also set the min and max filters to Nearest
    and Linear accordingly, like so:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 QOpenGLTexture 类下的纹理变量。我们将从应用程序文件夹中加载一个名为 brick.jpg 的纹理，并通过调用 mirrored() 来翻转图像。OpenGL
    使用不同的坐标系，因此我们需要在将纹理传递给着色器之前翻转我们的纹理。我们还将设置最小和最大过滤器为最近邻和线性，如下所示：
- en: '[PRE35]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add another array called `uvs`. This is where we save the texture coordinates
    for our `cube` object:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个名为 `uvs` 的数组。这是我们保存 `cube` 对象纹理坐标的地方：
- en: '[PRE37]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have to amend our vertex shader so that it takes in the texture coordinates
    for calculating where the texture will be applied to the object’s surface. Here,
    we simply pass the texture coordinate to the fragment shader without modifying:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须修改我们的顶点着色器，以便它接受纹理坐标来计算纹理将应用到对象表面的位置。在这里，我们只是将纹理坐标传递到片段着色器而不进行修改：
- en: '[PRE38]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the fragment shader, we create a texture by calling the `texture()` function,
    which receives the texture coordinate information from `fragUV` and the image
    sampler from `tex`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们通过调用 `texture()` 函数创建一个纹理，该函数接收来自 `fragUV` 的纹理坐标信息和来自 `tex` 的图像采样器：
- en: '[PRE39]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have to initialize the VBO for the texture coordinate as well:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须初始化纹理坐标的 VBO：
- en: '[PRE40]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `paintEvent()` function, we must send the texture coordinate information
    to the shader and then bind the texture before calling `glDrawArrays()`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `paintEvent()` 函数中，我们必须将纹理坐标信息发送到着色器，然后在调用 `glDrawArrays()` 之前绑定纹理：
- en: '[PRE41]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you compile and run the program now, you should see a brick cube rotating
    on the screen:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行程序，你应该会在屏幕上看到一个旋转的砖块立方体：
- en: '![Figure 5.7 – Our 3D cube now looks like it was created from bricks](img/B20976_05_007.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 我们的三维立方体现在看起来像是用砖块创建的](img/B20976_05_007.jpg)'
- en: Figure 5.7 – Our 3D cube now looks like it was created from bricks
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 我们的三维立方体现在看起来像是用砖块创建的
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Qt 6 makes loading textures a really easy job. All it takes is just a single
    line of code to load an image file, flip it, and convert it into an OpenGL-compatible
    texture. The texture coordinates are pieces of information that let OpenGL know
    how to stick the texture onto the object’s surface before displaying it on screen.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6 使得加载纹理变得非常简单。只需一行代码就可以加载图像文件，翻转它，并将其转换为 OpenGL 兼容的纹理。纹理坐标是让 OpenGL 知道在屏幕上显示之前如何将纹理粘贴到对象表面的信息。
- en: 'The `min` and `max` filters are filters that make the texture look better when
    it is applied on a surface that is bigger than what its resolution can cover.
    The default setting for this is `GL_NEAREST`, which stands for `GL_LINEAR`, which
    stands for `GL_NEAREST`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`min` 和 `max` 过滤器是当纹理应用于其分辨率无法覆盖的表面时使纹理看起来更好的过滤器。此设置的默认值为 `GL_NEAREST`，代表 `GL_LINEAR`，代表
    `GL_NEAREST`：'
- en: '![Figure 5.8 - Differences between GL_NEAREST and GL_LINEAR](img/B20976_05_008.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 - GL_NEAREST 和 GL_LINEAR 之间的差异](img/B20976_05_008.jpg)'
- en: Figure 5.8 - Differences between GL_NEAREST and GL_LINEAR
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 - GL_NEAREST 和 GL_LINEAR 之间的差异
- en: Basic lighting in OpenGL
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL 中的基本光照
- en: In this example, we will learn how to add a simple point light to our 3D scene
    by using OpenGL and Qt 6.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何通过使用 OpenGL 和 Qt 6 在我们的 3D 场景中添加一个简单的点光源。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s get started by following these steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始：
- en: 'Again, we will use the previous example and add a point light near the spinning
    cube. Open up `renderwindow.h` and add another variable called `vbo_normals` to
    the file:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们将使用之前的示例，并在旋转的立方体附近添加一个点光源。打开 `renderwindow.h` 文件，并向文件中添加一个名为 `vbo_normals`
    的变量：
- en: '[PRE42]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open `renderwindow.cpp` and add another array called `normals` to the `initializeGL()`
    function:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `renderwindow.cpp` 文件，并在 `initializeGL()` 函数中添加一个名为 `normals` 的数组：
- en: '[PRE43]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Initialize the `vbo_normals` VBO in `initializeGL()` by adding the following
    code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initializeGL()` 中初始化 `vbo_normals` VBO，添加以下代码：
- en: '[PRE44]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since the shader we will be writing this time will be much longer than what
    we used in the previous examples, let’s move the shader code over to text files
    and load them into the program by calling `addShaderFromSourceFile()`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这次我们将编写的着色器将比之前示例中的更长，让我们将着色器代码移动到文本文件中，并通过调用 `addShaderFromSourceFile()`
    将它们加载到程序中：
- en: '[PRE45]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once you are done with that, add the following code to the `paintEvent()` function
    to pass the `normals` VBO over to the shader:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，将以下代码添加到 `paintEvent()` 函数中，将 `normals` VBO 传递给着色器：
- en: '[PRE46]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let’s open up the two text files we just created that contain the shader code.
    First, we need to make some changes to the vertex shader, like so:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开我们刚刚创建的两个包含着色器代码的文本文件。首先，我们需要对顶点着色器进行一些修改，如下所示：
- en: '[PRE47]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will also make some changes to the fragment shader. We will create a function
    called `calcPointLight()` in the shader code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将对片段着色器进行一些修改。在着色器代码中，我们将创建一个名为 `calcPointLight()` 的函数：
- en: '[PRE48]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: // Diffuse
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 漫反射
- en: float diffuseStrength = 1.0;
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: float diffuseStrength = 1.0;
- en: float diff = clamp(dot(fragNormal, lightDir), 0.0, 1.0);
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: float diff = clamp(dot(fragNormal, lightDir), 0.0, 1.0);
- en: vec4 diffuse = diffuseStrength * diff * texCol * lightColor * lightIntensity;
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vec4 diffuse = diffuseStrength * diff * texCol * lightColor * lightIntensity;
- en: return diffuse;
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return diffuse;
- en: '}'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: void main() {
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void main() {
- en: vec4 finalColor = calcPointLight();
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vec4 finalColor = calcPointLight();
- en: col = finalColor;
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: col = finalColor;
- en: '}'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE49]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you compile and run the program now, you should see the lighting in action:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在编译并运行程序，您应该能看到光照效果：
- en: '![Figure 5.9 – Our 3D cube now has shading](img/B20976_05_009.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 我们的三维立方体现在有了着色](img/B20976_05_009.jpg)'
- en: Figure 5.9 – Our 3D cube now has shading
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 我们的三维立方体现在有了着色
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In OpenGL 3 and later versions, fixed-function lighting no longer exists. You
    can no longer call `glEnable(GL_LIGHT1)` to add light to your 3D scene. The new
    method for adding light is to calculate your own lighting in the shader. This
    gives you the flexibility of creating all types of lights, depending on your needs.
    The old method has a limitation of up to 16 lights in most hardware but, with
    the new programmable pipeline, you can have any number of lights in the scene;
    however, the lighting model will need to be coded entirely by you in the shaders,
    which is not an easy task.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL 3及更高版本中，固定功能光照已不再存在。您不能再通过调用 `glEnable(GL_LIGHT1)` 来向您的3D场景添加光照。添加光照的新方法是自己在着色器中计算光照。这为您提供了根据需要创建所有类型光照的灵活性。旧方法在大多数硬件中最多只能支持16个光照，但使用新的可编程管道，您可以在场景中拥有任意数量的光照；然而，光照模型将需要您在着色器中完全编码，这并非易事。
- en: Other than that, we also need to add a surface normal value to every surface
    of the cube. Surface normal indicates where the surface is facing and is used
    for lighting calculations. The preceding example is very simplified to let you
    understand how lighting works in OpenGL. In actual use cases, you may need to
    pass some variables such as light intensity, light color, and light position from
    C++ or load it from a material file instead of hardcoding it in the shader code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要为立方体的每个表面添加一个表面法线值。表面法线指示表面朝向何处，并用于光照计算。前面的示例非常简化，以便您了解OpenGL中光照的工作原理。在实际应用中，您可能需要从C++传递一些变量，如光照强度、光照颜色和光照位置，或者从材质文件中加载它们，而不是在着色器代码中硬编码。
- en: Moving an object using keyboard controls
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用键盘控制移动对象
- en: In this section, we will be looking at how to move an object in OpenGL using
    keyboard controls. Qt provides an easy way to detect keyboard events using virtual
    functions, namely `keyPressEvent()` and `keyReleaseEvent()`. We will be using
    the previous example and adding to it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用键盘控制移动OpenGL中的对象。Qt通过使用虚拟函数，如 `keyPressEvent()` 和 `keyReleaseEvent()`，提供了一个简单的方法来检测键盘事件。我们将使用之前的示例并在此基础上进行添加。
- en: How to do it…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To move an object using keyboard controls, follow these steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键盘控制移动对象，请按照以下步骤操作：
- en: 'Open up `renderwindow.h` and declare two floating-point numbers called `moveX`
    and `moveZ`. Then, declare a `QVector3D` variable called `movement`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `renderwindow.h` 并声明两个名为 `moveX` 和 `moveZ` 的浮点数。然后，声明一个名为 `movement` 的 `QVector3D`
    变量：
- en: '[PRE50]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'protected:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'protected:'
- en: void initializeGL();
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void initializeGL();
- en: void paintEvent(QPaintEvent *event);
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void paintEvent(QPaintEvent *event);
- en: void resizeEvent(QResizeEvent *event);
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void resizeEvent(QResizeEvent *event);
- en: void keyPressEvent(QKeyEvent *event);
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void keyPressEvent(QKeyEvent *event);
- en: void keyReleaseEvent(QKeyEvent *event);
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void keyReleaseEvent(QKeyEvent *event);
- en: '[PRE51]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We will implement the `keyPressEvent()` function in `renderwindow.cpp`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 `renderwindow.cpp` 中实现 `keyPressEvent()` 函数：
- en: '[PRE52]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will also implement the `keyReleaseEvent()` function:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将实现 `keyReleaseEvent()` 函数：
- en: '[PRE53]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After that, we will comment out the rotation code in `paintEvent()` and add
    the movement code, as highlighted in the following snippet. We do not want to
    get distracted by the rotation and just want to focus on the movement:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将注释掉 `paintEvent()` 中的旋转代码，并添加运动代码，如下面的片段所示。我们不想被旋转分散注意力，只想专注于运动：
- en: '[PRE54]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you compile and run the program now, you should be able to move the cube
    around by pressing *W*, *A*, *S*, and *D*.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行程序，你应该能够通过按*W*、*A*、*S*和*D*来移动立方体。
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we did here was constantly add the `moveX` and `moveZ` values’ `movement`
    vector’s `x` and `z` values. When a key is pressed, `moveX` and `moveZ` will become
    a positive or negative number, depending on which button is pressed; otherwise,
    it will be zero. In the `keyPressEvent()` function, we checked whether the keyboard
    button that was pressed was *W*, *A*, *S*, or *D*; we then set the variables accordingly.
    To get the full list of key names that are used by Qt, visit [http://doc.qt.io/qt-6/qt.html#Key-enum](http://doc.qt.io/qt-6/qt.html#Key-enum).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是不断向 `moveX` 和 `moveZ` 的 `movement` 向量的 `x` 和 `z` 值添加。当按键被按下时，`moveX`
    和 `moveZ` 将成为正数或负数，具体取决于哪个按钮被按下；否则，它将是零。在 `keyPressEvent()` 函数中，我们检查按下的键盘按钮是否是
    *W*、*A*、*S* 或 *D*；然后相应地设置变量。要获取 Qt 使用的所有键名的完整列表，请访问 [http://doc.qt.io/qt-6/qt.html#Key-enum](http://doc.qt.io/qt-6/qt.html#Key-enum)。
- en: One way we can create movement input is by holding down the same key and not
    releasing it. Qt 6 will repeat the key press event after an interval, but it is
    not very fluid as modern operating systems limit the key press event to prevent
    double typing. The keyboard input interval varies between different operating
    systems. You can set the interval by calling `QApplication::setKeyboardInterval()`,
    but this may not work on every operating system. Therefore, we did not go for
    this method.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一种创建运动输入的方法是按住相同的键而不释放它。Qt 6 将在间隔后重复按键事件，但这并不流畅，因为现代操作系统限制按键事件以防止双击。键盘输入间隔在不同操作系统之间有所不同。你可以通过调用
    `QApplication::setKeyboardInterval()` 来设置间隔，但这可能不是每个操作系统都有效。因此，我们没有采用这种方法。
- en: Instead, we only set `moveX` and `moveZ` once when the key was pressed or released,
    and then we constantly apply the value to the movement vector in our game loop
    so that it is moving continuously without being affected by the input interval.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们只在按键按下或释放时设置一次 `moveX` 和 `moveZ`，然后在游戏循环中持续应用这个值到运动向量，这样它就可以连续移动而不会受到输入间隔的影响。
- en: Qt Quick 3D in QML
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML 中的 Qt Quick 3D
- en: In this recipe, we will learn how to render 3D images using Qt 6.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 Qt 6 渲染 3D 图像。
- en: How to do it…
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s learn how to use a 3D canvas in QML by following this example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例学习如何在 QML 中使用 3D 画布：
- en: 'Let’s start this example by creating a new project in Qt Creator. This time
    around, we will go for **Qt Quick Application** and not the other options that
    we chose in the previous examples:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在 Qt Creator 中创建一个新项目开始这个示例。这次，我们将选择**Qt Quick 应用程序**而不是之前示例中选择的其它选项：
- en: '![Figure 5.10 – Creating a new Qt Quick Application project](img/B20976_05_010.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 创建新的 Qt Quick 应用程序项目](img/B20976_05_010.jpg)'
- en: Figure 5.10 – Creating a new Qt Quick Application project
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 创建新的 Qt Quick 应用程序项目
- en: 'Once the project is created, you are required to create a resource file by
    going to `resource.qrc`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建项目，你需要通过访问 `resource.qrc` 来创建一个资源文件：
- en: '![Figure 5.11 – Creating a Qt resource file](img/B20976_05_011.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 创建 Qt 资源文件](img/B20976_05_011.jpg)'
- en: Figure 5.11 – Creating a Qt resource file
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 创建 Qt 资源文件
- en: 'Add an image file to our project resources—we will be using it in this example.
    Open up `resource.qrc` with Qt Creator by right-clicking on it in the `brick.jpg`
    image, which will be used as the surface texture for our 3D object:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像文件添加到我们的项目资源中——我们将在本例中使用它。通过在`brick.jpg`图像上右键单击，使用Qt Creator打开`resource.qrc`，该图像将被用作我们3D对象的表面纹理：
- en: '![Figure 5.12 – Adding brick texture into the resource file](img/B20976_05_012.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12 – 将砖纹理添加到资源文件中](img/B20976_05_012.jpg)'
- en: Figure 5.12 – Adding brick texture into the resource file
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – 将砖纹理添加到资源文件中
- en: After that, open up `main.qml` using Qt Creator. You will see that there are
    already a few lines of code written in the file. What it does is basically open
    up an empty window and nothing else. Let’s start adding our own code to the `Window`
    object.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用Qt Creator打开`main.qml`。你会看到文件中已经写了几行代码。它的基本功能是打开一个空窗口，没有其他功能。让我们开始向`Window`对象添加我们自己的代码。
- en: 'First, import the `QtQuick3D` module to our project and create a `View3D` object
    under the `Window` object, which we will be using to render a 3D scene on it:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`QtQuick3D`模块导入到我们的项目中，并在`Window`对象下创建一个`View3D`对象，我们将使用它来在3D场景上渲染：
- en: '[PRE55]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After that, set the `environment` variable of the `View3D` object as a new
    `SceneEnvironment` object. We use this to set the background color of our 3D view
    to sky blue:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将`View3D`对象的`environment`变量设置为一个新的`SceneEnvironment`对象。我们使用它来设置3D视图的背景颜色为天蓝色：
- en: '[PRE56]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After that, we re-create the 3D cube from our previous OpenGL example by declaring
    a `Model` object inside our 3D view and setting its source as `Cube`. We then
    rotate it by `-30` units along the y-axis and apply a material to it. After that,
    we set the texture of the material as `brick.jpg`. The keyword `qrc:` here means
    we are taking the texture from the resource file we created earlier:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们通过在3D视图中声明一个`Model`对象并设置其源为`Cube`来重新创建我们之前的OpenGL示例中的3D立方体。然后我们沿y轴旋转它`-30`单位，并给它应用一个材质。之后，我们将材质的纹理设置为`brick.jpg`。这里的`qrc:`关键字意味着我们从我们之前创建的资源文件中获取纹理：
- en: '[PRE57]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Before we’re able to see our 3D cube clearly, we must create a light source
    as well as a camera, which helps to render our scene:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够清楚地看到我们的3D立方体之前，我们必须创建一个光源以及一个相机，这有助于渲染我们的场景：
- en: '[PRE58]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once you are done, build and run the project. You should be able to see a 3D
    cube with a brick texture on the screen:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，构建并运行项目。你应该能在屏幕上看到一个带有砖纹理的3D立方体：
- en: '![Figure 5.13 – Re-creating the 3D demo in QtQuick3D](img/B20976_05_013.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13 – 在QtQuick3D中重新创建3D演示](img/B20976_05_013.jpg)'
- en: Figure 5.13 – Re-creating the 3D demo in QtQuick3D
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 在QtQuick3D中重新创建3D演示
- en: 'To re-create the spinning animation, let’s add `NumberAnimation` to our cube
    model:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重新创建旋转动画，让我们在我们的立方体模型中添加`NumberAnimation`：
- en: '[PRE59]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Originally, Qt 5 used something called `three.js` library/API that used WebGL
    technology to display animated 3D computer graphics in a Qt Quick window. However,
    this feature has been completely deprecated in Qt 6 and has been since replaced
    by another module called **Qt** **Quick 3D**.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Qt 5使用一个名为`three.js`库/API的东西，它使用WebGL技术来在Qt Quick窗口中显示动画3D计算机图形。然而，这个特性在Qt
    6中已被完全弃用，并已被另一个名为**Qt Quick 3D**的模块所取代。
- en: Qt Quick 3D works a lot better than Qt Canvas 3D as it uses native methods for
    rendering 3D scenes without depending on a third-party library such as `three.js`.
    It also produces better performance and integrates well with any existing Qt Quick
    components.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 3D比Qt Canvas 3D工作得更好，因为它使用本地方法来渲染3D场景，而不依赖于第三方库如`three.js`。它还产生更好的性能，并与任何现有的Qt
    Quick组件很好地集成。
