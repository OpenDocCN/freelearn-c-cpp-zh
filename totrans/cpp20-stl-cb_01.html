<html><head></head><body>
		<div id="_idContainer007">
			<h1 id="_idParaDest-28"><em class="italic"><a id="_idTextAnchor027"/>Chaper 1</em>: New C++20 Features</h1>
			<p>This chapter concentrates on some of the more compelling features that C++20 adds to the STL. You can use some of these right away. Others may need to wait for implementation in your favorite compiler. But in the long run, I expect you'll want to know about most of these features.</p>
			<p>There are a lot of new additions to the C++20 standard, far more than we could cover here. These are a few that I think will have long-term impact.</p>
			<p>In this chapter we will cover the following recipes: </p>
			<ul>
				<li>Format text with the new <strong class="source-inline">format</strong> library</li>
				<li>Use compile-time vectors and strings with <strong class="source-inline">constexpr</strong></li>
				<li>Safely compare integers of different types</li>
				<li>Use the "spaceship" operator <strong class="source-inline">&lt;=&gt;</strong> for three-way comparisons</li>
				<li>Easily find feature test macros with the <strong class="source-inline">&lt;version&gt;</strong> header</li>
				<li>Create safer templates with concepts and constraints</li>
				<li>Avoid re-compiling template libraries with modules</li>
				<li>Create views into containers with ranges</li>
			</ul>
			<p>This chapter aims to familiarize you with these new features in C++20, so you may use them in your own projects and understand them when you encounter them. </p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Technical requirements</h1>
			<p>The code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap01">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap01</a>.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Format text with the new format library</h1>
			<p>Until now, if you <a id="_idIndexMarker000"/>wanted to format text, you could use either<a id="_idIndexMarker001"/> the legacy <strong class="source-inline">printf</strong> functions or the STL <strong class="source-inline">iostream</strong> library. Both have their strengths and flaws. </p>
			<p>The <strong class="source-inline">printf</strong>-based functions are inherited from C and have proven efficient, flexible, and convenient for over 50 years. The formatting syntax can look a bit cryptic, but it's simple enough once you get used to it.</p>
			<p class="source-code">printf("Hello, %s\n", c_string);</p>
			<p>The main weakness in <strong class="source-inline">printf</strong> is its lack of type safety. The common <strong class="source-inline">printf()</strong> function (and its relatives) use C's <em class="italic">variadic arguments</em> model to pass parameters to a formatter. This works great when it works, but it can cause serious problems when a parameter type doesn't match its corresponding format specifier. Modern compilers do as much type-checking as they can, but the model is inherently flawed and the protection can only go so far.</p>
			<p>The STL <strong class="source-inline">iostream</strong> library brings type safety at the expense of readability and run-time performance. The <strong class="source-inline">iostream</strong> syntax is unusual, yet familiar. It overloads the <em class="italic">bitwise left-shift operator</em> (<strong class="source-inline">&lt;&lt;</strong>) to allow a chain of objects, operands, and <em class="italic">formatting manipulators</em>, which produce the formatted output.</p>
			<p class="source-code">cout &lt;&lt; "Hello, " &lt;&lt; str &lt;&lt; endl;</p>
			<p>The weakness of <strong class="source-inline">iostream</strong> is its complexity, in both syntax and implementation. Building a formatted string can be verbose and obscure. Many of the formatting manipulators must be reset after use, or they create cascading formatting errors that can be difficult to debug. The library itself is vast and complex, resulting in code significantly larger and slower than its <strong class="source-inline">printf</strong> equivalent.</p>
			<p>This dismal situation has left C++ programmers with little option but to choose between two flawed systems, until now.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>How to do it…</h2>
			<p>The new <strong class="source-inline">format</strong> library is in the <strong class="source-inline">&lt;format&gt;</strong> header. As of this writing, <strong class="source-inline">format</strong> is implemented only in the <em class="italic">MSVC</em> (Microsoft) compiler. By the time you read this, it should be available on more systems. Otherwise, you may use its reference implementation as a third-party library from <strong class="source-inline">fmt.dev</strong> (<a href="http://j.bw.org/fmt">j.bw.org/fmt</a>).</p>
			<p>The <strong class="source-inline">format</strong> library is modeled on the <strong class="source-inline">str.format()</strong> method from Python 3. <em class="italic">Format strings</em> are substantially the same as those in Python and, for most purposes, they should be interchangeable. Let's examine some simple examples: </p>
			<ul>
				<li>In its simplest form, the <strong class="source-inline">format()</strong> function takes a <strong class="source-inline">string_view</strong> format string and a <em class="italic">variadic parameter pack</em> of arguments. It returns a <strong class="source-inline">string</strong>. Its function signature looks like this:<p class="source-code">template&lt;typename... Args&gt;</p><p class="source-code">string format(string_view fmt, const Args&amp;... args);</p></li>
				<li>The <strong class="source-inline">format()</strong> function<a id="_idIndexMarker002"/> returns a <strong class="source-inline">string</strong> representation<a id="_idIndexMarker003"/> of virtually any type or value. For example:<p class="source-code">string who{ "everyone" };</p><p class="source-code">int ival{ 42 };</p><p class="source-code">double pi{ std::numbers::pi };</p><p class="source-code">format("Hello, {}!\n ", who);   // Hello, everyone!</p><p class="source-code">format("Integer: {}\n ", ival); // Integer: 42</p><p class="source-code">format("π: {}\n", pi);          // π: 3.141592653589793</p></li>
			</ul>
			<p>The <em class="italic">format string</em> uses braces <strong class="source-inline">{}</strong> as a placeholder. With no <em class="italic">format specifiers</em>, the braces are effectively a type-safe <em class="italic">placeholder</em> which will convert a value of any compatible type to a reasonable string representation. </p>
			<ul>
				<li>You can include multiple placeholders in your format string, like this:<p class="source-code">format("Hello {} {}", ival, who);  // Hello 42 </p><p class="source-code">                                   // everyone</p></li>
				<li>You can specify the order of the replacement values. This could be useful for internationalization:<p class="source-code">format("Hello {1} {0}", ival, who); // Hello everyone 42</p><p class="source-code">format("Hola {0} {1}", ival, who);  // Hola 42 everyone</p></li>
				<li>You can align values, left (<strong class="source-inline">&lt;</strong>), right (<strong class="source-inline">&gt;</strong>), or center (<strong class="source-inline">^</strong>), with or without a fill character:<p class="source-code">format("{:.&lt;10}", ival);  // 42........</p><p class="source-code">format("{:.&gt;10}", ival);  // ........42</p><p class="source-code">format("{:.^10}", ival);  // ....42....</p></li>
				<li>You can set the decimal precision of values:<p class="source-code">format("π: {:.5}", pi);  // π: 3.1416</p></li>
				<li>And much, much more.</li>
			</ul>
			<p>It's a rich and complete<a id="_idIndexMarker004"/> formatting specification that provides <a id="_idIndexMarker005"/>the type-safety of <strong class="source-inline">iostream</strong> with the performance and simplicity of <strong class="source-inline">printf</strong>, for the best of both worlds.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>How it works…</h2>
			<p>The <strong class="source-inline">format</strong> library does not yet include a <strong class="source-inline">print()</strong> function, which is planned for <em class="italic">C++23</em>. The <strong class="source-inline">format()</strong> function itself returns a <strong class="source-inline">string</strong> object. So, if you want to print the string, you'll need to use either <strong class="source-inline">iostream</strong> or <strong class="source-inline">cstdio</strong>. (Sad face.)</p>
			<p>You can print the string using <strong class="source-inline">iostream</strong>:</p>
			<p class="source-code">cout &lt;&lt; format("Hello, {}", who) &lt;&lt; "\n";</p>
			<p>Or you may use <strong class="source-inline">cstdio</strong>:</p>
			<p class="source-code">puts(format("Hello, {}", who).c_str());</p>
			<p>Neither is ideal, but it's not very hard to write a simple <strong class="source-inline">print()</strong> function. And we can use this process to understand a bit of the <strong class="source-inline">format</strong> library's inner workings.</p>
			<p>Here's a simple implementation of a <strong class="source-inline">print()</strong> function using the <strong class="source-inline">format</strong> library:</p>
			<p class="source-code">#include &lt;format&gt;</p>
			<p class="source-code">#include &lt;string_view&gt;</p>
			<p class="source-code">#include &lt;cstdio&gt;</p>
			<p class="source-code">template&lt;typename... Args&gt;</p>
			<p class="source-code">void print(const string_view fmt_str, Args&amp;&amp;... args) {</p>
			<p class="source-code">    auto fmt_args{ <strong class="bold">make_format_args</strong>(args...) };</p>
			<p class="source-code">    string outstr{ <strong class="bold">vformat</strong>(fmt_str, fmt_args) };</p>
			<p class="source-code">    fputs(outstr.c_str(), stdout);</p>
			<p class="source-code">} </p>
			<p>This uses the same arguments as the <strong class="source-inline">format()</strong> function. The first argument is a <strong class="source-inline">string_view</strong> object for the format string. This is followed by a variadic parameter pack for the arguments.</p>
			<p>The <strong class="source-inline">make_format_args()</strong> function takes the parameter pack and returns an object that contains <em class="italic">type-erased values</em> suitable for formatting. This object is then passed to <strong class="source-inline">vformat()</strong>, which returns a <strong class="source-inline">string</strong> suitable for printing. We use <strong class="source-inline">fputs()</strong> to print the value to the <a id="_idIndexMarker006"/>console because it's far more efficient<a id="_idIndexMarker007"/> than <strong class="source-inline">cout</strong>. </p>
			<p>We can now use this <strong class="source-inline">print()</strong> function in place of the <strong class="source-inline">cout &lt;&lt; format()</strong> combination:</p>
			<p class="source-code">print("Hello, {}!\n", who);</p>
			<p class="source-code">print("π: {}\n", pi);</p>
			<p class="source-code">print("Hello {1} {0}\n", ival, who);</p>
			<p class="source-code">print("{:.^10}\n", ival);</p>
			<p class="source-code">print("{:.5}\n", pi);</p>
			<p>Output:</p>
			<p class="source-code">Hello, everyone!</p>
			<p class="source-code">π: 3.141592653589793</p>
			<p class="source-code">Hello everyone 42</p>
			<p class="source-code">....42....</p>
			<p class="source-code">3.1416</p>
			<p>When you eventually get a C++23 complier with <strong class="source-inline">print()</strong> support, you should be able to simply<a id="_idIndexMarker008"/> replace the above <strong class="source-inline">print()</strong> template function <a id="_idIndexMarker009"/>definition with <strong class="source-inline">using std::print;</strong> and all the <strong class="source-inline">print()</strong> calls should continue to work.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>There's more…</h2>
			<p>It's nice to have the<a id="_idIndexMarker010"/> ability to format strings and primitives, but for the <strong class="source-inline">format</strong> library to be fully functional, it needs customization to work with your own classes.</p>
			<p>For example, here's a simple <strong class="source-inline">struct</strong> with two members: a <em class="italic">numerator</em> and <em class="italic">denominator</em>. We would like this to print as a fraction:</p>
			<p class="source-code">struct Frac {</p>
			<p class="source-code">    long n;</p>
			<p class="source-code">    long d;</p>
			<p class="source-code">};</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    Frac f{ 5, 3 };</p>
			<p class="source-code">    print("Frac: {}\n", f);    </p>
			<p class="source-code">}</p>
			<p>When I compile this, it leads to a cascade of errors to the effect of, "No user-defined conversion operator…". Cool. So, let's fix it!</p>
			<p>When the <strong class="source-inline">format</strong> system encounters an object for <em class="italic">conversion</em>, it looks for a <em class="italic">specialization</em> of a <strong class="source-inline">formatter</strong> object with the corresponding type. Standard specializations are included for common objects such as strings and numbers and such.</p>
			<p>It's quite simple to create a specialization for our <strong class="source-inline">Frac</strong> type:</p>
			<p class="source-code">template&lt;&gt;</p>
			<p class="source-code">struct std::formatter&lt;Frac&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    template&lt;typename ParseContext&gt;</p>
			<p class="source-code">    constexpr auto parse(ParseContext&amp; ctx) {</p>
			<p class="source-code">        return ctx.begin();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    template&lt;typename FormatContext&gt;</p>
			<p class="source-code">    auto format(const Frac&amp; f, FormatContext&amp; ctx) {</p>
			<p class="source-code">        return format_to(ctx.out(), "{0:d}/{1:d}", </p>
			<p class="source-code">            f.n, f.d);</p>
			<p class="source-code">    }</p>
			<p class="source-code">};</p>
			<p>This <strong class="source-inline">formatter</strong> specialization<a id="_idIndexMarker011"/> is a class with two short template functions:</p>
			<ul>
				<li>The <strong class="source-inline">parse()</strong> function parses the <em class="italic">format string</em> from after the colon (or, if there is no colon, after the opening brace) up to but not including the closing brace. (In other words, the part that specifies the type of the object.) It takes a <strong class="source-inline">ParseContext</strong> object and returns an iterator. For our purposes, we can just return the <strong class="source-inline">begin()</strong> iterator because we don't need any new syntax for our <em class="italic">type</em>. You will rarely need to put anything else here.</li>
				<li>The <strong class="source-inline">format()</strong> function takes a <strong class="source-inline">Frac</strong> object and a <strong class="source-inline">FormatContext</strong> object. It returns an <em class="italic">end iterator</em>. The <strong class="source-inline">format_to()</strong> function makes this easy. It takes an iterator, a format string, and a parameter pack. In this case, the parameter pack is the two properties of our <strong class="source-inline">Frac</strong> class, the numerator and denominator.</li>
			</ul>
			<p>All we need to do here is provide a simple format string <strong class="source-inline">"{0}/{1}"</strong> and the numerator and denominator values. (The <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong> indicate the position of the parameters. They're not strictly necessary but they could come in handy later.)</p>
			<p>Now that we have a specialization for <strong class="source-inline">Frac</strong>, we can pass our object to <strong class="source-inline">print()</strong> to get a readable result:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    Frac f{ 5, 3 };</p>
			<p class="source-code">    print("Frac: {}\n", f);    </p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">Frac: 5/3</p>
			<p>The C++20 <strong class="source-inline">format</strong> library<a id="_idIndexMarker012"/> solves a long-standing problem by providing a type-safe text formatting library that is both efficient and convenient.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Use compile-time vectors and strings with constexpr</h1>
			<p>C++20 allows<a id="_idIndexMarker013"/> the use of <strong class="source-inline">constexpr</strong> in several new <a id="_idIndexMarker014"/>contexts. This provides improved efficiency, in<a id="_idIndexMarker015"/> that <a id="_idIndexMarker016"/>these things may be evaluated at compile time, instead of run time.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>How to do it…</h2>
			<p>The specification includes the ability to use <strong class="source-inline">string</strong> and <strong class="source-inline">vector</strong> objects in <strong class="source-inline">constexpr</strong> context. It's important to note that these objects may not themselves be declared <strong class="source-inline">constexpr</strong>, but they may be used in a compile-time context:</p>
			<p class="source-code">constexpr auto use_string() {</p>
			<p class="source-code">    string str{"string"};</p>
			<p class="source-code">    return str.size();</p>
			<p class="source-code">}</p>
			<p>You can also use algorithms in <strong class="source-inline">constexpr</strong> context:</p>
			<p class="source-code">constexpr auto use_vector() {</p>
			<p class="source-code">    vector&lt;int&gt; vec{ 1, 2, 3, 4, 5};</p>
			<p class="source-code">    return accumulate(begin(vec), end(vec), 0);</p>
			<p class="source-code">}</p>
			<p>The result of the <strong class="source-inline">accumulate</strong> algorithm is available at compile time and in <strong class="source-inline">constexpr</strong> context.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>How it works…</h2>
			<p>The <strong class="source-inline">constexpr</strong> specifier declares a variable or function that may be <em class="italic">evaluated at compile time. </em>Before C++20, this was limited to objects initialized with a literal value, or a function within<a id="_idIndexMarker017"/> limited constraints. C++17 allowed a somewhat expanded use and C++20<a id="_idIndexMarker018"/> expands<a id="_idIndexMarker019"/> it<a id="_idIndexMarker020"/> further.</p>
			<p>As of C++20, the STL <strong class="source-inline">string</strong> and <strong class="source-inline">vector</strong> classes now have <strong class="source-inline">constexpr</strong>-qualified constructors and destructors, which allow them to be invoked at compile time. This also means that the memory allocated for the <strong class="source-inline">string</strong> or <strong class="source-inline">vector</strong> object <em class="italic">must be freed at compile time.</em></p>
			<p>For example, this <strong class="source-inline">constexpr</strong> function, which returns a <strong class="source-inline">vector</strong>, will compile without error:</p>
			<p class="source-code">constexpr auto use_vector() {</p>
			<p class="source-code">    vector&lt;int&gt; vec{ 1, 2, 3, 4, 5};</p>
			<p class="source-code">    return vec;</p>
			<p class="source-code">}</p>
			<p>But if you try to use the result in a run-time context, you will get an error about memory that was allocated during constant evaluation:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    constexpr auto vec = use_vector();</p>
			<p class="source-code">    return vec[0];</p>
			<p class="source-code">}</p>
			<p>This is because the <strong class="source-inline">vector</strong> object was allocated <em class="italic">and freed</em> during compilation. So, the object is no longer available at run time.</p>
			<p>On the other hand, you can use some <strong class="source-inline">constexpr</strong>-qualified methods from the <strong class="source-inline">vector</strong> object, such as <strong class="source-inline">size()</strong>, at run time:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    constexpr auto value = use_vector().size();</p>
			<p class="source-code">    return value;</p>
			<p class="source-code">}</p>
			<p>Because<a id="_idIndexMarker021"/> the <strong class="source-inline">size()</strong> method<a id="_idIndexMarker022"/> is <strong class="source-inline">constexpr</strong>-qualified, the<a id="_idIndexMarker023"/> expression<a id="_idIndexMarker024"/> can be evaluated at compile time.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Safely compare integers of different types</h1>
			<p>Comparing different<a id="_idIndexMarker025"/> types of integers may not always produce the expected results. For example:</p>
			<p class="source-code">int x{ -3 };</p>
			<p class="source-code">unsigned y{ 7 };</p>
			<p class="source-code">if(x &lt; y) puts("true");</p>
			<p class="source-code">else puts("false");</p>
			<p>You may expect this code to print <strong class="source-inline">true</strong>, and that's understandable. -3 is usually less than 7. But it will print <strong class="source-inline">false</strong>.</p>
			<p>The problem is that <strong class="source-inline">x</strong> is signed and <strong class="source-inline">y</strong> is unsigned. The standardized behavior is to convert the signed type to unsigned for the comparison. That seems counterintuitive, doesn't it? Indeed, you cannot reliably convert an unsigned value to a signed value of the same size, because a signed integer uses <em class="italic">two's complement</em> representation (which uses the most significant bit as a sign). Given the same sized integer, the maximum signed value is half that of an unsigned value. Using this example, if your integers are 32-bits, -3 (signed) becomes <strong class="source-inline">FFFF FFFD</strong> (hexadecimal), or 4,294,967,293 (unsigned decimal), which is <em class="italic">not less than 7</em>.</p>
			<p>Some compilers may issue a warning when you try to compare signed with unsigned integer values, but most do not.</p>
			<p>The C++20 standard includes a set of integer-safe comparison functions in the <strong class="source-inline">&lt;utility&gt;</strong> header. </p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>How to do it…</h2>
			<p>The new integer <a id="_idIndexMarker026"/>comparison functions are found in the <strong class="source-inline">&lt;utility&gt;</strong> header. They each take two arguments, which correspond with the left- and right-hand sides of the operator.</p>
			<p class="source-code">#include &lt;utility&gt;</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    int x{ -3 };</p>
			<p class="source-code">    unsigned y{ 7 };</p>
			<p class="source-code">    if(<strong class="bold">cmp_less(x, y)</strong>) puts("true");</p>
			<p class="source-code">    else puts("false");</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">cmp_less()</strong> function gives us the result we expect. -3 is less than 7 and the program now prints <strong class="source-inline">true</strong>.</p>
			<p>The <strong class="source-inline">&lt;utility&gt;</strong> header provides a full complement of integer comparison functions. Assuming our values for <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>, we get these comparisons:</p>
			<p class="source-code">cmp_equal(x, y)          // x == y is false</p>
			<p class="source-code">cmp_not_equal(x, y)      // x != y is true</p>
			<p class="source-code">cmp_less(x, y)           // x &lt; y is true</p>
			<p class="source-code">cmp_less_equal(x, y)     // x &lt;= y is true</p>
			<p class="source-code">cmp_greater(x, y)        // x &gt; y is false</p>
			<p class="source-code">cmp_greater_equal(x, y)  // x &gt;= y is false</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>How it works…</h2>
			<p>Here's the sample implementation of the <strong class="source-inline">cmp_less()</strong> function from the C++20 standard, to give <a id="_idIndexMarker027"/>you a more complete picture of how it works:</p>
			<p class="source-code">template&lt; class T, class U &gt;</p>
			<p class="source-code">constexpr bool cmp_less( T t, U u ) noexcept</p>
			<p class="source-code">{</p>
			<p class="source-code">    using UT = make_unsigned_t&lt;T&gt;;</p>
			<p class="source-code">    using UU = make_unsigned_t&lt;U&gt;;</p>
			<p class="source-code">    if constexpr (is_signed_v&lt;T&gt; == is_signed_v&lt;U&gt;)</p>
			<p class="source-code">        return t &lt; u;</p>
			<p class="source-code">    else if constexpr (is_signed_v&lt;T&gt;)</p>
			<p class="source-code">        return t &lt; 0 ? true : UT(t) &lt; u;</p>
			<p class="source-code">    else</p>
			<p class="source-code">        return u &lt; 0 ? false : t &lt; UU(u);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">UT</strong> and <strong class="source-inline">UU</strong> aliases are declared as <strong class="source-inline">make_unsigned_t</strong>, a useful helper type introduced with C++17. This allows safe conversions of signed to unsigned types.</p>
			<p>The function first tests if both arguments are either signed or unsigned. If so, it returns a simple comparison.</p>
			<p>It then tests if either side is signed. If that signed value is less than zero, it can return <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> without performing a comparison. Otherwise, it converts the signed value to unsigned and returns the comparison.</p>
			<p>Similar logic is<a id="_idIndexMarker028"/> applied to each of the other comparison functions.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Use the "spaceship" operator &lt;=&gt; for three-way comparisons</h1>
			<p>The <em class="italic">three-way comparison</em> operator (<strong class="source-inline">&lt;=&gt;</strong>), commonly called the <em class="italic">spaceship</em> operator because it looks <a id="_idIndexMarker029"/>like a flying saucer in profile, is<a id="_idIndexMarker030"/> new in C++20. You may wonder, what's wrong with the existing six comparison operators? Nothing at all, and you will continue using them. The purpose of the spaceship is to provide a unified comparison operator for objects.</p>
			<p>The common two-way comparison operators return one of two states, <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>, according to the result of the comparison. For example:</p>
			<p class="source-code">const int a = 7;</p>
			<p class="source-code">const int b = 42;</p>
			<p class="source-code">static_assert(a &lt; b);</p>
			<p>The <strong class="source-inline">a &lt; b</strong> expression uses the <em class="italic">less-than comparison</em> operator (<strong class="source-inline">&lt;</strong>) to test if <strong class="source-inline">a</strong> is less than <strong class="source-inline">b</strong>. The comparison operator returns <strong class="source-inline">true</strong> if the condition is satisfied, or <strong class="source-inline">false</strong> if not. In this case it returns <strong class="source-inline">true</strong> because 7 is less than 42.</p>
			<p>The three-way comparison works differently. It returns one of three states. The spaceship operator will return a value equal to <strong class="source-inline">0</strong> if the operands are equal, <em class="italic">negative</em> if the left-hand operand is less than the right-hand operand, or <em class="italic">positive</em> if the left-hand operand is greater than the right-hand operator.</p>
			<p class="source-code">const int a = 7;</p>
			<p class="source-code">const int b = 42;</p>
			<p class="source-code">static_assert((a &lt;=&gt; b) &lt; 0);</p>
			<p>The returned value is <em class="italic">not an integer</em>. It's an object from the <strong class="source-inline">&lt;compare&gt;</strong> header that compares with <strong class="source-inline">0</strong>.</p>
			<p>If the operands have an integral type, the operator returns a <strong class="source-inline">strong_ordering</strong> object from the <strong class="source-inline">&lt;compare&gt;</strong> library.</p>
			<p class="source-code">strong_ordering::equal    // operands are equal</p>
			<p class="source-code">strong_ordering::less     // lhs is less than rhs</p>
			<p class="source-code">strong_ordering::greater  // lhs is greater than rhs</p>
			<p>If the operands have a floating-point type, the operator returns a <strong class="source-inline">partial_ordering</strong> object:</p>
			<p class="source-code">partial_ordering::equivalent  // operands are equivelant</p>
			<p class="source-code">partial_ordering::less        // lhs is less than rhs</p>
			<p class="source-code">partial_ordering::greater     // lhs is greater than rhs</p>
			<p class="source-code">partial_ordering::unordered   // if an operand is unordered</p>
			<p>These objects are designed to compare against a literal zero (<strong class="source-inline">0</strong>) with conventional comparison operators (for example, <strong class="source-inline">(a &lt;=&gt; b) &lt; 0</strong>). This allows the results of the three-way comparison to be more precise than conventional comparisons.</p>
			<p>If all of that seems a bit complicated, that's okay. For most applications you will never use the spaceship <a id="_idIndexMarker031"/>operator directly. Its real power is in its application as a unified comparison <a id="_idIndexMarker032"/>operator for objects. Let's dig a bit deeper.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>How to do it…</h2>
			<p>Let's look at a simple class that encapsulates an integer and provides comparison operators:</p>
			<p class="source-code">struct Num {</p>
			<p class="source-code">    int a;</p>
			<p class="source-code">    constexpr bool operator==(const Num&amp; rhs) const </p>
			<p class="source-code">        { return a == rhs.a; }</p>
			<p class="source-code">    constexpr bool operator!=(const Num&amp; rhs) const</p>
			<p class="source-code">        { return !(a == rhs.a); }</p>
			<p class="source-code">    constexpr bool operator&lt;(const Num&amp; rhs) const</p>
			<p class="source-code">        { return a &lt; rhs.a; }</p>
			<p class="source-code">    constexpr bool operator&gt;(const Num&amp; rhs) const</p>
			<p class="source-code">        { return rhs.a &lt; a; }</p>
			<p class="source-code">    constexpr bool operator&lt;=(const Num&amp; rhs) const</p>
			<p class="source-code">        { return !(rhs.a &lt; a); }</p>
			<p class="source-code">    constexpr bool operator&gt;=(const Num&amp; rhs) const</p>
			<p class="source-code">        { return !(a &lt; rhs.a); }</p>
			<p class="source-code">};</p>
			<p>It's not uncommon to see a list of comparison operator overloads like this. In fact, it should be even more complicated with <em class="italic">non-member friends</em> that work with objects on either side of the operator.</p>
			<p>With the new <a id="_idIndexMarker033"/>spaceship operator, all of this can be <a id="_idIndexMarker034"/>accomplished with one overload:</p>
			<p class="source-code">#include &lt;compare&gt;</p>
			<p class="source-code">struct Num {</p>
			<p class="source-code">    int a;</p>
			<p class="source-code">    constexpr Num(int a) : a{a} {}</p>
			<p class="source-code">    auto operator&lt;=&gt;(const Num&amp;) const = default;</p>
			<p class="source-code">};</p>
			<p>Notice that we need to include the <strong class="source-inline">&lt;compare&gt;</strong> header for the three-way operator return types. Now we can declare some variables and test them with comparisons:</p>
			<p class="source-code">constexpr Num a{ 7 };</p>
			<p class="source-code">constexpr Num b{ 7 };</p>
			<p class="source-code">constexpr Num c{ 42 };</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    static_assert(a &lt; c);</p>
			<p class="source-code">    static_assert(c &gt; a);</p>
			<p class="source-code">    static_assert(a == b);</p>
			<p class="source-code">    static_assert(a &lt;= b);</p>
			<p class="source-code">    static_assert(a &lt;= c);</p>
			<p class="source-code">    static_assert(c &gt;= a);</p>
			<p class="source-code">    static_assert(a != c);</p>
			<p class="source-code">    puts("done.");</p>
			<p class="source-code">}</p>
			<p>The compiler will automatically favor the <strong class="source-inline">&lt;=&gt;</strong> operator for each of the comparisons.</p>
			<p>Because the default <strong class="source-inline">&lt;=&gt;</strong> operator is already <strong class="source-inline">constexpr</strong> safe, we don't need to declare it as such in our member function.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>How it works…</h2>
			<p>The <strong class="source-inline">operator&lt;=&gt;</strong> overload takes advantage of a new C++20 concept, <em class="italic">rewritten expressions</em>. During<a id="_idIndexMarker035"/> overload resolution, the compiler <a id="_idIndexMarker036"/>rewrites the expression according to a set of rules. For example, if we write <strong class="source-inline">a &lt; b</strong>, the compiler will rewrite it to <strong class="source-inline">(a &lt;=&gt; b &lt; 0)</strong> so that it works with our member operator. The compiler will rewrite every relevant comparison expression for the <strong class="source-inline">&lt;=&gt;</strong> operator, where we haven't included a more specific operator.</p>
			<p>In fact, we no longer need a non-member function to handle comparisons with a compatible type on the left-hand side. The compiler will <em class="italic">synthesize</em> an expression that works with the member operator. For example, if we write <strong class="source-inline">42 &gt; a</strong>, the compiler will synthesize an expression with the operators reversed <strong class="source-inline">(a &lt;=&gt; 42 &lt; 0)</strong> so that it works with our member operator.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">&lt;=&gt;</strong> operator has <em class="italic">higher precedence</em> than the other comparison operators so it will always evaluate first. All comparison operators evaluate left-to-right.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>There's more…</h2>
			<p>The default operator will <a id="_idIndexMarker037"/>work just fine with a wide variety of classes, including classes with multiple numeric members of different types:</p>
			<p class="source-code">struct Nums {</p>
			<p class="source-code">  int i;</p>
			<p class="source-code">  char c;</p>
			<p class="source-code">  float f;</p>
			<p class="source-code">  double d;</p>
			<p class="source-code">  auto operator&lt;=&gt;(const Nums&amp;) const = default;</p>
			<p class="source-code">};</p>
			<p>But what if you have a <a id="_idIndexMarker038"/>more complex type? Here's <a id="_idIndexMarker039"/>an example of a simple fraction class:</p>
			<p class="source-code">struct Frac {</p>
			<p class="source-code">    long n;</p>
			<p class="source-code">    long d;</p>
			<p class="source-code">    constexpr Frac(int a, int b) : n{a}, d{b} {}</p>
			<p class="source-code">    constexpr double dbl() const {</p>
			<p class="source-code">        return static_cast&lt;double&gt;(n) / </p>
			<p class="source-code">          static_cast&lt;double&gt;(d);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    constexpr auto operator&lt;=&gt;(const Frac&amp; rhs) const {</p>
			<p class="source-code">        return dbl() &lt;=&gt; rhs.dbl();</p>
			<p class="source-code">    };</p>
			<p class="source-code">    constexpr auto operator==(const Frac&amp; rhs) const {</p>
			<p class="source-code">        return dbl() &lt;=&gt; rhs.dbl() == 0;</p>
			<p class="source-code">    };</p>
			<p class="source-code">};</p>
			<p>In this case we need to define the <strong class="source-inline">operator&lt;=&gt;</strong> overload because our data members are not stand-alone scalar values. It's still quite simple and it works just as well.</p>
			<p>Notice that we also needed an <strong class="source-inline">operator==</strong> overload. This is because the expression rewrite rules will not rewrite <strong class="source-inline">==</strong> and <strong class="source-inline">!=</strong> with a custom <strong class="source-inline">operator&lt;=&gt;</strong> overload. You only need to define <strong class="source-inline">operator==</strong>. The compiler will rewrite the <strong class="source-inline">!=</strong> expression as needed.</p>
			<p>Now we can define some objects:</p>
			<p class="source-code">constexpr Frac a(10,15);  // compares equal with 2/3</p>
			<p class="source-code">constexpr Frac b(2,3);</p>
			<p class="source-code">constexpr Frac c(5,3);</p>
			<p>And we can test <a id="_idIndexMarker040"/>them with normal comparison<a id="_idIndexMarker041"/> operators, as expected:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    static_assert(a &lt; c);</p>
			<p class="source-code">    static_assert(c &gt; a);</p>
			<p class="source-code">    static_assert(a == b);</p>
			<p class="source-code">    static_assert(a &lt;= b);</p>
			<p class="source-code">    static_assert(a &lt;= c);</p>
			<p class="source-code">    static_assert(c &gt;= a);</p>
			<p class="source-code">    static_assert(a != c);</p>
			<p class="source-code">}</p>
			<p>The power of the spaceship operator is in its ability to streamline comparison overloads in your classes. It improves both simplicity and efficiency when compared to overloading each <a id="_idIndexMarker042"/>operator <a id="_idIndexMarker043"/>independently.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Easily find feature test macros with the &lt;version&gt; header</h1>
			<p>C++ has provided<a id="_idIndexMarker044"/> some form of feature test<a id="_idIndexMarker045"/> macros for as long as new features have been added. Beginning with C++20, the process is standardized, and all <em class="italic">library feature</em> test macros have been added to the <strong class="source-inline">&lt;version&gt;</strong> header. This will make it much easier to test for a new feature in your code.</p>
			<p>This is a useful feature and it's very simple to use.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>How to do it…</h2>
			<p>All feature test macros begin with the prefix <strong class="source-inline">__cpp_</strong>. Library features begin with <strong class="source-inline">__cpp_lib_</strong>. Language feature test macros are typically defined by the compiler. Library feature test macros are defined in the new <strong class="source-inline">&lt;version&gt;</strong> header. Use them as you would any other preprocessor macro:</p>
			<p class="source-code">#include &lt;version&gt;</p>
			<p class="source-code">#ifdef __cpp_lib_three_way_comparison</p>
			<p class="source-code">#   include &lt;compare&gt;</p>
			<p class="source-code">#else</p>
			<p class="source-code">#   error Spaceship has not yet landed</p>
			<p class="source-code">#endif</p>
			<p>In some cases, you can use the <strong class="source-inline">__has_include</strong> preprocessor operator (introduced in C++17) to test for the existence of an include file.</p>
			<p class="source-code">#if __has_include(&lt;compare&gt;)</p>
			<p class="source-code">#   include &lt;compare&gt;</p>
			<p class="source-code">#else</p>
			<p class="source-code">#   error Spaceship has not yet landed</p>
			<p class="source-code">#endif</p>
			<p>You can use <strong class="source-inline">__has_include</strong> to test for the existence of any header file. Because it's a preprocessor directive, it doesn't require a header of its own to work.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>How it works…</h2>
			<p>Generally, you can use the feature test macros by testing for a non-zero value using <strong class="source-inline">#ifdef</strong> or <strong class="source-inline">#if defined</strong>. Each of the feature test macros has a non-zero value that corresponds to the year and month it was accepted by the standards committee. For example, the <strong class="source-inline">__cpp_lib_three_way_comparison</strong> macro has a value of <strong class="source-inline">201907</strong>. This<a id="_idIndexMarker046"/> means that it was accepted in <a id="_idIndexMarker047"/>July 2019.</p>
			<p class="source-code">#include &lt;version&gt;</p>
			<p class="source-code">#ifdef __cpp_lib_three_way_comparison</p>
			<p class="source-code">    cout &lt;&lt; "value is " &lt;&lt; __cpp_lib_three_way_comparison </p>
			<p class="source-code">        &lt;&lt; "\n"</p>
			<p class="source-code">#endif</p>
			<p>Output:</p>
			<p class="source-code">$ ./working</p>
			<p class="source-code">value is 201907</p>
			<p>The value of the macro may be useful in some obscure cases where a feature has changed and you're dependent upon the changes. For most purposes, you can safely ignore the value and just test for non-zero with <strong class="source-inline">#ifdef</strong>.</p>
			<p>Several websites <a id="_idIndexMarker048"/>maintain a complete list of feature test macros. I tend to use <em class="italic">cppreference</em> (<a href="https://j.bw.org/cppfeature">https://j.bw.org/cppfeature</a>) but there are others.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Create safer templates with concepts and constraints</h1>
			<p>Templates are great<a id="_idIndexMarker049"/> for writing code that works<a id="_idIndexMarker050"/> with different types. For example, this function will work with any numeric type:</p>
			<p class="source-code">template &lt;typename T&gt;</p>
			<p class="source-code">T arg42(const T &amp; arg) {</p>
			<p class="source-code">    return arg + 42;</p>
			<p class="source-code">}</p>
			<p>But what happens when you try to call it with a non-numeric type?</p>
			<p class="source-code">const char * n = "7";</p>
			<p class="source-code">cout &lt;&lt; "result is " &lt;&lt; arg42(n) &lt;&lt; "\n";</p>
			<p>Output:</p>
			<p class="source-code">Result is ion</p>
			<p>This compiles and runs without error, but the result is unpredictable. In fact, the call is dangerous and it could easily crash or become a vulnerability. I would much prefer the compiler generate an error message so I can fix the code.</p>
			<p>Now, with concepts, I can write it like this:</p>
			<p class="source-code">template &lt;typename T&gt;</p>
			<p class="source-code"><strong class="bold">requires</strong> Numeric&lt;T&gt;</p>
			<p class="source-code">T arg42(const T &amp; arg) {</p>
			<p class="source-code">    return arg + 42;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">requires</strong> keyword is new for C++20. It applies constraints to a template. <strong class="source-inline">Numeric</strong> is the name of a <em class="italic">concept</em> that only accepts integer and floating-point types. Now, when I compile this code with a non-numeric parameter, I get a reasonable compiler error:</p>
			<p class="source-code">error: 'arg42': no matching overloaded function found</p>
			<p class="source-code">error: 'arg42': the associated constraints are not satisfied</p>
			<p>Error messages like this are far more useful than most compiler errors.</p>
			<p>Let's take a closer look at how to use concepts and constraints in your code.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>How to do it…</h2>
			<p>A concept is simply a named constraint. The <strong class="source-inline">Numeric</strong> concept from above looks like this:</p>
			<p class="source-code">#include &lt;concepts&gt;</p>
			<p class="source-code">template &lt;typename T&gt;</p>
			<p class="source-code"><strong class="bold">concept</strong> Numeric = integral&lt;T&gt; || floating_point&lt;T&gt;;</p>
			<p>This <em class="italic">concept</em> requires a type <strong class="source-inline">T</strong>, which satisfies either the <strong class="source-inline">std::integral</strong> or <strong class="source-inline">std::floating_point</strong> predefined concepts. These concepts are included in the <strong class="source-inline">&lt;concepts&gt;</strong> header.</p>
			<p>Concepts and <a id="_idIndexMarker051"/>constraints may be used in class<a id="_idIndexMarker052"/> templates, function templates, or variable templates. We've seen a constrained function template, now here's a simple constrained class template example:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">requires Numeric&lt;T&gt;</p>
			<p class="source-code">struct Num {</p>
			<p class="source-code">    T n;</p>
			<p class="source-code">    Num(T n) : n{n} {}</p>
			<p class="source-code">};</p>
			<p>And here's a simple variable template example:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">requires floating_point&lt;T&gt;</p>
			<p class="source-code">T pi{3.1415926535897932385L};</p>
			<p>You can use concepts and constraints on any template. Let's consider some further examples. We'll be using function templates in these examples for simplicity.</p>
			<ul>
				<li>A constraint may use concepts or <em class="italic">type traits</em> to evaluate the characteristics of a type. You may use any of the type traits found in the <strong class="source-inline">&lt;type_traits&gt;</strong> header, so long as it returns a <strong class="source-inline">bool</strong>.</li>
			</ul>
			<p>For example:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code"><strong class="bold">requires</strong> is_integral&lt;T&gt;::value  // value is bool</p>
			<p class="source-code">constexpr double avg(vector&lt;T&gt; const&amp; vec) {</p>
			<p class="source-code">    double sum{ accumulate(vec.begin(), vec.end(), </p>
			<p class="source-code">      0.0)</p>
			<p class="source-code">    };</p>
			<p class="source-code">    return sum / vec.size();</p>
			<p class="source-code">}</p>
			<ul>
				<li>The <strong class="source-inline">requires</strong> keyword<a id="_idIndexMarker053"/> is <a id="_idIndexMarker054"/>new in C++20. It introduces a constraint for the template arguments. In this example, the constraint expression tests the template argument against the type trait <strong class="source-inline">is_integral</strong>. </li>
				<li>You can use one of the pre-defined traits found in the <strong class="source-inline">&lt;type_traits&gt;</strong> header, or you can define your own, just as you would a template variable. For use in constraints, the variable must return <strong class="source-inline">constexpr bool</strong>. For example:<p class="source-code">template&lt;typename T&gt;</p><p class="source-code">constexpr bool is_gt_byte{ sizeof(T) &gt; 1 };</p></li>
			</ul>
			<p>This defines a type trait called <strong class="source-inline">is_gt_byte</strong>. This trait uses the <strong class="source-inline">sizeof</strong> operator to test if the type <strong class="source-inline">T</strong> is larger than 1 byte.</p>
			<ul>
				<li>A <em class="italic">concept</em> is simply a named set of constraints. For example:<p class="source-code">template&lt;typename T&gt;</p><p class="source-code"><strong class="bold">concept</strong> Numeric = is_gt_byte&lt;T&gt; &amp;&amp;</p><p class="source-code">    (integral&lt;T&gt; || floating_point&lt;T&gt;);</p></li>
			</ul>
			<p>This defines a concept named <strong class="source-inline">Numeric</strong>. It uses our <strong class="source-inline">is_gt_byte</strong> constraint, along with the <strong class="source-inline">floating_point</strong> and <strong class="source-inline">integral</strong> concepts from the <strong class="source-inline">&lt;concepts&gt;</strong> header. We can use it to constrain a template to only accept numeric types that are greater than 1 byte in size.</p>
			<p class="source-code">template&lt;<strong class="bold">Numeric</strong> T&gt;</p>
			<p class="source-code">T arg42(const T &amp; arg) {</p>
			<p class="source-code">    return arg + 42;</p>
			<p class="source-code">}</p>
			<p>You'll notice that I've applied the constraint in the template declaration, rather than on a separate line in a <strong class="source-inline">requires</strong> expression. There are a few ways to apply a<a id="_idIndexMarker055"/> concept. Let's look at how<a id="_idIndexMarker056"/> this works.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>How it works…</h2>
			<p>There are several different ways you can apply a concept or constraint:</p>
			<ul>
				<li>You can apply a concept or constraint with the <strong class="source-inline">requires</strong> keyword: <p class="source-code">template&lt;typename T&gt;</p><p class="source-code">requires Numeric&lt;T&gt;</p><p class="source-code">T arg42(const T &amp; arg) {</p><p class="source-code">    return arg + 42;</p><p class="source-code">}</p></li>
				<li>You can apply a concept in the template declaration:<p class="source-code">template&lt;Numeric T&gt;</p><p class="source-code">T arg42(const T &amp; arg) {</p><p class="source-code">    return arg + 42;</p><p class="source-code">}</p></li>
				<li>You can use the <strong class="source-inline">requires</strong> keyword in a function signature:<p class="source-code">template&lt;typename T&gt;</p><p class="source-code">T arg42(const T &amp; arg) requires Numeric&lt;T&gt; {</p><p class="source-code">    return arg + 42;</p><p class="source-code">}</p></li>
				<li>Or you can use a concept in a parameter list for an abbreviated function template:<p class="source-code">auto arg42(Numeric auto &amp; arg) {</p><p class="source-code">    return arg + 42;</p><p class="source-code">}</p></li>
			</ul>
			<p>For many purposes, choosing one of these strategies may be a matter of style. And there are <a id="_idIndexMarker057"/>circumstances where one may be a <a id="_idIndexMarker058"/>better option than another.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>There's more…</h2>
			<p>The standard uses the terms <em class="italic">conjunction</em>, <em class="italic">disjunction</em>, and <em class="italic">atomic</em>, to describe types of expressions<a id="_idIndexMarker059"/> that can be used to construct a constraint. Let's define these terms.</p>
			<p>You can combine concepts and constraints using the <strong class="source-inline">&amp;&amp;</strong> and <strong class="source-inline">||</strong> operators. These combinations are called <em class="italic">conjunctions</em> and <em class="italic">disjunctions</em>, respectively. You can think of them as logical <em class="italic">AND</em> and <em class="italic">OR</em>.</p>
			<p>A <em class="italic">constraint conjunction</em> is formed by using the <strong class="source-inline">&amp;&amp;</strong> operator with two constraints:</p>
			<p class="source-code">Template &lt;typename T&gt;</p>
			<p class="source-code">concept Integral_s = Integral&lt;T&gt; &amp;&amp; is_signed&lt;T&gt;::value;</p>
			<p>A conjunction is satisfied only if both sides of the <strong class="source-inline">&amp;&amp;</strong> operator are satisfied. It is evaluated left-to-right. The operands of a conjunction are short-circuited, that is, if the left side constraint is not satisfied the right side will not be evaluated.</p>
			<p>A <em class="italic">constraint disjunction</em> is<a id="_idIndexMarker060"/> formed by using the <strong class="source-inline">||</strong> operator with two constraints:</p>
			<p class="source-code">Template &lt;typename T&gt;</p>
			<p class="source-code">concept Numeric = integral&lt;T&gt; || floating_point&lt;T&gt;;</p>
			<p>A disjunction is satisfied if either side of the <strong class="source-inline">||</strong> operator is satisfied. It is evaluated left-to-right. The operands of a conjunction are short-circuited, that is, if the left side constraint is satisfied the right side will not be evaluated.</p>
			<p>An <em class="italic">atomic constraint</em> is an expression that returns a <strong class="source-inline">bool</strong> type, which<a id="_idIndexMarker061"/> cannot be further decomposed. In other words, it is not a <a id="_idIndexMarker062"/>conjunction or a disjunction.</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">concept is_gt_byte = sizeof(T) &gt; 1;</p>
			<p>You can also use the logical<strong class="source-inline">!</strong> (<em class="italic">NOT</em>) operator in an atomic constraint:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">concept is_byte = !is_gt_byte&lt;T&gt;;</p>
			<p>As expected, the <strong class="source-inline">!</strong> operator inverts the value of the <strong class="source-inline">bool</strong> expression to the right of the <strong class="source-inline">!</strong>.</p>
			<p>Of course, we can combine all these expression types into a larger expression. We see examples of each of these constraint expressions in the following example:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">concept Numeric = is_gt_byte&lt;T&gt; &amp;&amp; </p>
			<p class="source-code">    (integral&lt;T&gt; || floating_point&lt;T&gt;);</p>
			<p>Let's break this down. The sub-expression, <strong class="source-inline">(integral&lt;T&gt; </strong><strong class="bold">||</strong><strong class="source-inline"> floating_point&lt;T&gt;)</strong> is a <em class="italic">disjunction</em>. The sub-expression, <strong class="source-inline">is_gt_byte&lt;T&gt; </strong><strong class="bold">&amp;&amp;</strong><strong class="source-inline"> (</strong>…<strong class="source-inline">)</strong> is a <em class="italic">conjunction</em>. And each of the sub-expressions <strong class="source-inline">integral&lt;T&gt;</strong>, <strong class="source-inline">floating_point&lt;T&gt;</strong>, and <strong class="source-inline">is_gt_byte&lt;T&gt;</strong>, are <em class="italic">atomic</em>.</p>
			<p>These distinctions are mostly for descriptive purposes. While it's good to understand the details, as you write your code, it's safe to think of them as simple logical <strong class="source-inline">||</strong>, <strong class="source-inline">&amp;&amp;</strong>, and <strong class="source-inline">!</strong> operators.</p>
			<p>Concepts and constraints are a welcome addition to the C++ standard and I'm looking forward to using <a id="_idIndexMarker063"/>them in my future projects.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Avoid re-compiling template libraries with modules</h1>
			<p>Header files have <a id="_idIndexMarker064"/>been around since the<a id="_idIndexMarker065"/> very beginning of the C language. Originally, they were mainly used for <em class="italic">text substitution macros</em> and linking <em class="italic">external symbols</em> between translation units. With the introduction of templates, C++ leveraged header files to carry actual code. Because templates need to be recompiled for changes in specializations, we've been carrying them around in header files for many years. As the STL continues to grow over the years, these header files have grown as well. The situation has become unwieldy and is no longer scalable for the future.</p>
			<p>Header files typically contain a lot more than templates. They often contain configuration macros and other symbols that are required for system purposes, but not useful for the application. As the number of headers grows, the number of opportunities for symbol collisions grows as well. This is even more problematic when you consider the abundance of macros, which are not subject to namespace restrictions nor any form of type safety.</p>
			<p>C++20 addresses this problem with <em class="italic">modules</em>. </p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>How to do it…</h2>
			<p>You may be used to creating header files like this:</p>
			<p class="source-code">#ifndef BW_MATH</p>
			<p class="source-code">#define BW_MATH</p>
			<p class="source-code">namespace bw {</p>
			<p class="source-code">    template&lt;typename T&gt;</p>
			<p class="source-code">    T add(T lhs, T rhs) {</p>
			<p class="source-code">        return lhs + rhs;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">#endif // BW_MATH</p>
			<p>This minimalist example illustrates several of the problems that modules address. The <strong class="source-inline">BW_MATH</strong> symbol is used as an <em class="italic">include guard</em>. Its only purpose is to prevent the header file from being included more than once, yet its symbol is carried throughout the translation unit. When you include this header in your source file, it may look like this:</p>
			<p class="source-code">#include "bw-math.h"</p>
			<p class="source-code">#include &lt;format&gt;</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p>Now that <strong class="source-inline">BW_MATH</strong> symbol is available to every other header you've included, and every header <a id="_idIndexMarker066"/>included by the other <a id="_idIndexMarker067"/>headers, and on and on. That's a lot of opportunities for collision. And keep in mind, the compiler cannot check for these collisions. They're macros. That means they're translated by the preprocessor before the compiler ever has a chance to see them.</p>
			<p>Now we get to the actual point of the header, the template function:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">T add(T lhs, T rhs) {</p>
			<p class="source-code">    return lhs + rhs;</p>
			<p class="source-code">}</p>
			<p>Because it's a template, every time you use the <strong class="source-inline">add()</strong> function the compiler must create a separate specialization. This means that the template function must be parsed and specialized each time it's invoked. That's why templates go in header files; the source must be available at compile time. As the STL grows and evolves, with its many large template classes and functions, this becomes a significant scalability problem.</p>
			<p><em class="italic">Modules</em> solve these problems and more.</p>
			<p>As a module, <strong class="source-inline">bw-math.h</strong> becomes <strong class="source-inline">bw-math.ixx</strong> (in the MSVC naming convention) and it looks like this:</p>
			<p class="source-code"><strong class="bold">export</strong> module bw_math;</p>
			<p class="source-code"><strong class="bold">export</strong> template&lt;typename T&gt;</p>
			<p class="source-code">T add(T lhs, T rhs) {</p>
			<p class="source-code">    return lhs + rhs;</p>
			<p class="source-code">}</p>
			<p>Notice that the only symbols exported are the name of the module, <strong class="source-inline">bw_math</strong>, and the name of the function, <strong class="source-inline">add()</strong>. This keeps the namespace clean.</p>
			<p>The usage is<a id="_idIndexMarker068"/> cleaner as well. When <a id="_idIndexMarker069"/>we use it in <strong class="source-inline">module-test.cpp</strong>, it looks like this:</p>
			<p class="source-code"><strong class="bold">import</strong> bw_math;</p>
			<p class="source-code"><strong class="bold">import</strong> std.core;</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    double f = add(1.23, 4.56);</p>
			<p class="source-code">    int i = add(7, 42);</p>
			<p class="source-code">    string s = add&lt;string&gt;("one ", "two");</p>
			<p class="source-code">    cout &lt;&lt; </p>
			<p class="source-code">        "double: " &lt;&lt; f &lt;&lt; "\n" &lt;&lt;</p>
			<p class="source-code">        "int: " &lt;&lt; i &lt;&lt; "\n" &lt;&lt;</p>
			<p class="source-code">        "string: " &lt;&lt; s &lt;&lt; "\n";</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">import</strong> declarations are used where we might otherwise use <strong class="source-inline">#include</strong> preprocessor directives. These import the symbol tables from the modules for linkage.</p>
			<p>The output of our example looks like this:</p>
			<p class="source-code">$ ./module-test</p>
			<p class="source-code">double: 5.79</p>
			<p class="source-code">int: 49</p>
			<p class="source-code">string: one two</p>
			<p>The module version works exactly as it did in a header file, only cleaner and more efficiently.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The compiled <a id="_idIndexMarker070"/>module includes a separate <em class="italic">metadata file</em> (<em class="italic">module-name</em><strong class="source-inline">.ifc</strong> in the MSVC naming convention), which describes the module interface. This allows the module to support templates. The metadata includes sufficient information for the compiler to create template specializations.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>How it works…</h2>
			<p>The <strong class="source-inline">import</strong> and <strong class="source-inline">export</strong> declarations are at the core of the <em class="italic">Modules</em> implementation. Let's take<a id="_idIndexMarker071"/> another look at<a id="_idIndexMarker072"/> the <strong class="source-inline">bw-math.ixx</strong> module:</p>
			<p class="source-code">export module bw_math;</p>
			<p class="source-code">export template&lt;typename T&gt;</p>
			<p class="source-code">T add(T lhs, T rhs) {</p>
			<p class="source-code">    return lhs + rhs;</p>
			<p class="source-code">}</p>
			<p>Notice the two <strong class="source-inline">export</strong> declarations. The first exports the module itself with <strong class="source-inline">export module bw_math</strong>. This declares the translation unit as a module. There must be a module declaration at the top of every module file, and before any other statements. The second <strong class="source-inline">export</strong> makes the function name <strong class="source-inline">add()</strong> available to the <em class="italic">module consumer</em>. </p>
			<p>If your module requires <strong class="source-inline">#include</strong> directives, or other global fragments, you will need to first declare your module with a simple module declaration like this:</p>
			<p class="source-code">module;</p>
			<p class="source-code">#define SOME_MACRO 42</p>
			<p class="source-code">#include &lt;stdlib.h&gt;</p>
			<p class="source-code">export module bw_math;</p>
			<p class="source-code">...</p>
			<p>The <strong class="source-inline">module;</strong> declaration, on a line by itself at the top of the file, introduces a <em class="italic">global module fragment</em>. Only preprocessor directives may appear in the global module fragment. This must be immediately followed by a standard module declaration (<strong class="source-inline">export module bw_math;</strong>) and <a id="_idIndexMarker073"/>the rest of the module content. Let's look closer at how this works:</p>
			<ul>
				<li>An <strong class="source-inline">export</strong> declaration makes a symbol visible to the <em class="italic">module consumer</em>, that is, the code that imports the module. Symbols default to private.<p class="source-code"><strong class="bold">export</strong> int a{7};  // visible to consumer</p><p class="source-code">int b{42};        // not visible</p></li>
				<li>You can <a id="_idIndexMarker074"/>export a block, like<a id="_idIndexMarker075"/> this:<p class="source-code"><strong class="bold">export</strong> {</p><p class="source-code">    int a() { return 7; };     // visible </p><p class="source-code">    int b() { return 42; };    // also visible</p><p class="source-code">}</p></li>
				<li>You can export a namespace:<p class="source-code"><strong class="bold">export</strong> namespace bw {  // all of the bw namespace is visible</p><p class="source-code">    template&lt;typename T&gt;</p><p class="source-code">    T add(T lhs, T rhs) {  // visible as bw::add()</p><p class="source-code">        return lhs + rhs;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Or, you can export individual symbols from a namespace:<p class="source-code">namespace bw {  // all of the bw namespace is visible</p><p class="source-code">    <strong class="bold">export</strong> template&lt;typename T&gt;</p><p class="source-code">    T add(T lhs, T rhs) {  // visible as bw::add()</p><p class="source-code">        return lhs + rhs;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>An <strong class="source-inline">import</strong> <a id="_idIndexMarker076"/>declaration imports a module in the <em class="italic">consumer</em>:<p class="source-code"><strong class="bold">import</strong> bw_math;</p><p class="source-code">int main() {</p><p class="source-code">    double f = bw::add(1.23, 4.56);</p><p class="source-code">    int i = bw::add(7, 42);</p><p class="source-code">    string s = bw::add&lt;string&gt;("one ", "two");</p><p class="source-code">}</p></li>
				<li>You can even<a id="_idIndexMarker077"/> import a<a id="_idIndexMarker078"/> module and export it to the consumer to pass it along:<p class="source-code">export module bw_math;</p><p class="source-code"><strong class="bold">export</strong> <strong class="bold">import</strong> std.core;</p></li>
			</ul>
			<p>The <strong class="source-inline">export</strong> keyword must precede the <strong class="source-inline">import</strong> keyword.</p>
			<p>The <strong class="source-inline">std.core</strong> module is now available for the consumer:</p>
			<p class="source-code">import bw_math;</p>
			<p class="source-code">using std::cout, std::string, std::format;</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    double f = bw::add(1.23, 4.56);</p>
			<p class="source-code">    int i = bw::add(7, 42);</p>
			<p class="source-code">    string s = bw::add&lt;string&gt;("one ", "two");</p>
			<p class="source-code">    cout &lt;&lt; </p>
			<p class="source-code">        format("double {} \n", f) &lt;&lt;</p>
			<p class="source-code">        format("int {} \n", i) &lt;&lt;</p>
			<p class="source-code">        format("string {} \n", s);</p>
			<p class="source-code">}</p>
			<p>As you can see, modules are a simple, straightforward alternative to header files. I know a lot of us are looking forward to the broad availability of modules. I can see this greatly reducing our dependency on header files.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of writing, the only complete implementation of modules is in a <em class="italic">preview release</em> of MSVC. The module filename extension (<strong class="source-inline">.ixx</strong>) may be different for other compilers. Also, the amalgamated <strong class="source-inline">std.core</strong> module is part of how MSVC implements the STL as modules in this release. Other compilers may not use this convention. Some details may change when fully compliant implementations are released.</p>
			<p>In the example<a id="_idIndexMarker079"/> files, I've included a module version of my <strong class="source-inline">format</strong>-based <strong class="source-inline">print()</strong> function. This <a id="_idIndexMarker080"/>works on the current preview release of MSVC. It may require some small modifications to make it work on other systems, once they support enough of the modules specification.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Create views into containers with ranges</h1>
			<p>The new <strong class="source-inline">ranges</strong> library <a id="_idIndexMarker081"/>is one of the more significant <a id="_idIndexMarker082"/>additions to C++20. It provides a new paradigm for filtering and processing containers. Ranges provide clean and intuitive building blocks for more effective and readable code.</p>
			<p>Let's start by defining a few terms:</p>
			<ul>
				<li>A <strong class="bold">Range</strong> is a <a id="_idIndexMarker083"/>collection of objects which can be iterated. In other words, any structure that supports the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators is a range. This includes most STL containers.</li>
				<li>A <strong class="bold">View</strong> is a range<a id="_idIndexMarker084"/> that transforms another underlying range. Views are lazy, meaning they only operate as the range iterates. A view returns data from the underlying range and does not own any data itself. Views operate in <em class="italic">O(1)</em> constant time.</li>
				<li>A <strong class="bold">View Adapter</strong> is an <a id="_idIndexMarker085"/>object that takes a range and returns a view <a id="_idIndexMarker086"/>object. A view adapter may be chained with other view adapters using the <strong class="source-inline">|</strong> operator.<p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">&lt;ranges&gt;</strong> library uses the <strong class="source-inline">std::ranges</strong> and the <strong class="source-inline">std::ranges::view</strong> namespaces. Recognizing that this is cumbersome, the standard includes an alias for <strong class="source-inline">std::ranges::view</strong> as the simply, <strong class="source-inline">std::view</strong>. I still find that cumbersome. For this recipe I will use the following aliases, to save space and because I find it more elegant: </p><p class="callout"><strong class="source-inline">namespace ranges = std::ranges;  // save the fingers!</strong></p><p class="callout"><strong class="source-inline">namespace views = std::ranges::views;  </strong></p><p class="callout">This applies to all the code in this recipe.</p></li>
			</ul>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>How to do it…</h2>
			<p>The <strong class="source-inline">ranges</strong> and <strong class="source-inline">views</strong> classes are in the <strong class="source-inline">&lt;ranges&gt;</strong> header. Let's look at how you can use them:</p>
			<ul>
				<li>A <em class="italic">View</em> is applied to a <em class="italic">Range</em>, like this:<p class="source-code">const vector&lt;int&gt; nums{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</p><p class="source-code">auto result = ranges::<strong class="bold">take_view</strong>(nums, 5);</p><p class="source-code">for (auto v: result) cout &lt;&lt; v &lt;&lt; " ";</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1 2 3 4 5</strong> </p>
			<p><strong class="source-inline">ranges::take_view(range, n)</strong> is a view that returns the first <em class="italic">n</em> elements.</p>
			<p>You may<a id="_idIndexMarker087"/> also use the <em class="italic">view adapter</em> version<a id="_idIndexMarker088"/> of <strong class="source-inline">take_view()</strong>:</p>
			<p class="source-code">auto result = nums | views::take(5);</p>
			<p class="source-code">for (auto v: result) cout &lt;&lt; v &lt;&lt; " ";</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1 2 3 4 5</strong> </p>
			<p><em class="italic">View adapters</em> are in the <strong class="source-inline">std::ranges::views</strong> namespace. A <em class="italic">view adapter </em>takes the <em class="italic">range operand</em> from the left-hand side of the <strong class="source-inline">|</strong> operator, much like the <strong class="source-inline">iostreams</strong> usage of the <strong class="source-inline">&lt;&lt;</strong> operator. The <strong class="source-inline">|</strong> operands are evaluated left-to-right.</p>
			<ul>
				<li>Because a view adapter is <em class="italic">iterable</em>, it also qualifies as a range. This allows them to be applied serially, like this:<p class="source-code">const vector&lt;int&gt; nums{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</p><p class="source-code">auto result = nums | views::take(5) | </p><p class="source-code">   views::reverse;</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">5 4 3 2 1</strong></p>
			<ul>
				<li>The <strong class="source-inline">filter()</strong> view uses a predicate function:<p class="source-code">auto result = nums | </p><p class="source-code">    views::filter([](int i){ return 0 == i % 2; });</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">2 4 6 8 10</strong></p>
			<ul>
				<li>The <strong class="source-inline">transform()</strong> view uses a transformation function:<p class="source-code">auto result = nums | </p><p class="source-code">    views::transform([](int i){ return i * i; });</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1 4 9 16 25 36 49 64 81 100</strong></p>
			<ul>
				<li>Of course, these <a id="_idIndexMarker089"/>views and adapters <a id="_idIndexMarker090"/>work on ranges of any type:<p class="source-code">cosnt vector&lt;string&gt;</p><p class="source-code">words{ "one", "two", "three", "four", "five" };</p><p class="source-code">auto result = words | views::reverse;</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">five four three two one</strong></p>
			<ul>
				<li>The <strong class="source-inline">ranges</strong> library also includes a few <em class="italic">range factories</em>. The <strong class="source-inline">iota</strong> factory will generate an incrementing series of values:<p class="source-code">auto rnums = views::iota(1, 10);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1 2 3 4 5 6 7 8 9</strong></p>
			<p>The <strong class="source-inline">iota(value, bound)</strong> function generates a sequence starting with <strong class="source-inline">value</strong> and ending <em class="italic">before</em> <strong class="source-inline">bound</strong>. If <strong class="source-inline">bound</strong> is omitted, the sequence is infinite:</p>
			<p class="source-code">auto rnums = views::iota(1) | views::take(200);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1 2 3 4 5 6 7 8 9 10 11 12 […] 196 197 198 199 200</strong></p>
			<p><em class="italic">Ranges</em>, <em class="italic">Views</em>, and <em class="italic">View Adapters</em> are incredibly flexible and useful. Let's take a deeper look for a better understanding.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>How it works…</h2>
			<p>To satisfy the basic requirements for a <em class="italic">Range</em>, an object must have at least two iterators, <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong>, where the <strong class="source-inline">end()</strong> iterator is a sentinel, used to determine the end point of a range. Most STL containers qualify as ranges, including <strong class="source-inline">string</strong>, <strong class="source-inline">vector</strong>, <strong class="source-inline">array</strong>, <strong class="source-inline">map</strong>, and others, with the notable exception of container-adapters, like <strong class="source-inline">stack</strong> and <strong class="source-inline">queue</strong>, which don't have <strong class="source-inline">begin</strong> and <strong class="source-inline">end</strong> iterators.</p>
			<p>A <em class="italic">View</em> is an object which operates on a range and returns a modified range. A view operates lazily, and contains no data of its own. Instead of keeping a copy of the underlying<a id="_idIndexMarker091"/> data, it simply returns iterators to <a id="_idIndexMarker092"/>underlying elements as needed. Let's examine this code snippet:</p>
			<p class="source-code">vector&lt;int&gt; vi { 0, 1, 2, 3, 4, 5 };</p>
			<p class="source-code"><strong class="bold">ranges::take_view</strong> tv{vi, 2};</p>
			<p class="source-code">for(int i : tv) {</p>
			<p class="source-code">    cout &lt;&lt; i &lt;&lt; " ";</p>
			<p class="source-code">}</p>
			<p class="source-code">cout &lt;&lt; "\n";</p>
			<p>Output:</p>
			<p class="source-code">0 1</p>
			<p>In this example, the <strong class="source-inline">take_view</strong> object takes two parameters, a <em class="italic">range</em> (in this case, a <strong class="source-inline">vector&lt;int&gt;</strong> object), and a <em class="italic">count</em>. The result is a <em class="italic">view</em> with the first <em class="italic">count</em> objects from the <strong class="source-inline">vector</strong>. At evaluation time, during the iteration of the <strong class="source-inline">for</strong> loop, the <strong class="source-inline">take_view</strong> object simply returns iterators that point to elements of the <strong class="source-inline">vector</strong> object, as needed. The <strong class="source-inline">vector</strong> object is not modified in this process.</p>
			<p>Many of the views in the <strong class="source-inline">ranges</strong> namespace have corresponding <em class="italic">range adapters</em> in the <strong class="source-inline">views</strong> namespace. These adapters may be used with the <em class="italic">bitwise or</em> (<strong class="source-inline">|</strong>) operator, as a pipe, like this:</p>
			<p class="source-code">vector&lt;int&gt; vi { 0, 1, 2, 3, 4, 5 };</p>
			<p class="source-code">auto tview = vi | <strong class="bold">views::take</strong>(2);</p>
			<p class="source-code">for(int i : tview) {</p>
			<p class="source-code">    cout &lt;&lt; i &lt;&lt; " ";</p>
			<p class="source-code">}</p>
			<p class="source-code">cout &lt;&lt; "\n";</p>
			<p>Output:</p>
			<p class="source-code">0 1</p>
			<p>As expected, the <strong class="source-inline">|</strong> operator evaluates left to right. And because the result of the range adapter is <a id="_idIndexMarker093"/>another range, these adapter expressions may <a id="_idIndexMarker094"/>be chained:</p>
			<p class="source-code">vector&lt;int&gt; vi { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</p>
			<p class="source-code">auto tview = vi | views::reverse | views::take(5);</p>
			<p class="source-code">for(int i : tview) {</p>
			<p class="source-code">    cout &lt;&lt; i &lt;&lt; " ";</p>
			<p class="source-code">}</p>
			<p class="source-code">cout &lt;&lt; "\n";</p>
			<p>Output:</p>
			<p class="source-code">9 8 7 6 5</p>
			<p>The library includes a <strong class="source-inline">filter</strong> view that is used with a <em class="italic">predicate</em>, for defining simple filters:</p>
			<p class="source-code">vector&lt;int&gt; vi { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</p>
			<p class="source-code">auto even = [](long i) { return 0 == i % 2; };</p>
			<p class="source-code">auto tview = vi | views::filter(even);</p>
			<p>Output:</p>
			<p class="source-code">0 2 4 6 8</p>
			<p>Also included, is a <strong class="source-inline">transform</strong> view that is used with a <em class="italic">transform function</em> for transforming results:</p>
			<p class="source-code">vector&lt;int&gt; vi { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</p>
			<p class="source-code">auto even = [](int i) { return 0 == i % 2; };</p>
			<p class="source-code">auto x2 = [](auto i) { return i * 2; };</p>
			<p class="source-code">auto tview = vi | views::filter(even) | views::transform(x2);</p>
			<p>Output:</p>
			<p class="source-code">0 4 8 12 16</p>
			<p>There are <a id="_idIndexMarker095"/>quite a few useful views and view adapters in the library. Please <a id="_idIndexMarker096"/>check your favorite <a id="_idIndexMarker097"/>reference site, or (<a href="https://j.bw.org/ranges">https://j.bw.org/ranges</a>) for a complete list.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>There's more…</h2>
			<p>Beginning with C++20, most of the algorithms in the <strong class="source-inline">&lt;algorithm&gt;</strong> header include versions for use with <strong class="source-inline">ranges</strong>. These versions are still in the <strong class="source-inline">&lt;algorithm&gt;</strong> header, but in the <strong class="source-inline">std::ranges</strong> namespace. This distinguishes them from the legacy algorithms.</p>
			<p>This means that, instead of calling an algorithm with two iterators:</p>
			<p class="source-code">sort(v.begin(), v.end());</p>
			<p>You can now call it with just a range, like this:</p>
			<p class="source-code">ranges::sort(v);</p>
			<p>That's certainly more convenient, but how does it really help?</p>
			<p>Consider the case where you want to sort part of a vector, you could do that the old way, like this:</p>
			<p class="source-code">sort(v.begin() + 5, v.end());</p>
			<p>This would sort the elements of the vector after the first 5. With the <strong class="source-inline">ranges</strong> version, you can use a view to skip the first 5 elements:</p>
			<p class="source-code">ranges::sort(views::drop(v, 5));</p>
			<p>You can even combine views:</p>
			<p class="source-code">ranges::sort(views::drop(views::reverse(v), 5));</p>
			<p>In fact, you can <a id="_idIndexMarker098"/>even use range adapters as the argument<a id="_idIndexMarker099"/> to <strong class="source-inline">ranges::sort</strong>:</p>
			<p class="source-code">ranges::sort(v | views::reverse | views::drop(5));</p>
			<p>In contrast, if you wanted to do this with the traditional <strong class="source-inline">sort</strong> algorithm and vector iterators, it would look something like this:</p>
			<p class="source-code">sort(v.rbegin() + 5, v.rend());</p>
			<p>While that's certainly shorter, and not impossible to understand, I find the range adapters version far more intuitive. </p>
			<p>You can find a complete list of algorithms that have been constrained to work with ranges on <a id="_idIndexMarker100"/>the <em class="italic">cppreference</em> site (https://j.bw.org/algoranges).</p>
			<p>In this recipe, we've only scratched the surface of <em class="italic">Ranges</em> and <em class="italic">Views</em>. This feature is the culmination of over a decade of work by many different teams, and I expect it to fundamentally change the way we use containers in the STL.</p>
		</div>
	</body></html>