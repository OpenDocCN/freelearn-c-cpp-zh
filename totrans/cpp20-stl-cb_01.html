<html><head></head><body>
		<div><h1 id="_idParaDest-28"><em class="italic"><a id="_idTextAnchor027"/>Chaper 1</em>: New C++20 Features</h1>
			<p>This chapter concentrates on some of the more compelling features that C++20 adds to the STL. You can use some of these right away. Others may need to wait for implementation in your favorite compiler. But in the long run, I expect you'll want to know about most of these features.</p>
			<p>There are a lot of new additions to the C++20 standard, far more than we could cover here. These are a few that I think will have long-term impact.</p>
			<p>In this chapter we will cover the following recipes: </p>
			<ul>
				<li>Format text with the new <code>format</code> library</li>
				<li>Use compile-time vectors and strings with <code>constexpr</code></li>
				<li>Safely compare integers of different types</li>
				<li>Use the "spaceship" operator <code>&lt;=&gt;</code> for three-way comparisons</li>
				<li>Easily find feature test macros with the <code>&lt;version&gt;</code> header</li>
				<li>Create safer templates with concepts and constraints</li>
				<li>Avoid re-compiling template libraries with modules</li>
				<li>Create views into containers with ranges</li>
			</ul>
			<p>This chapter aims to familiarize you with these new features in C++20, so you may use them in your own projects and understand them when you encounter them. </p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Technical requirements</h1>
			<p>The code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap01">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap01</a>.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Format text with the new format library</h1>
			<p>Until now, if you <a id="_idIndexMarker000"/>wanted to format text, you could use either<a id="_idIndexMarker001"/> the legacy <code>printf</code> functions or the STL <code>iostream</code> library. Both have their strengths and flaws. </p>
			<p>The <code>printf</code>-based functions are inherited from C and have proven efficient, flexible, and convenient for over 50 years. The formatting syntax can look a bit cryptic, but it's simple enough once you get used to it.</p>
			<pre>printf("Hello, %s\n", c_string);</pre>
			<p>The main weakness in <code>printf</code> is its lack of type safety. The common <code>printf()</code> function (and its relatives) use C's <em class="italic">variadic arguments</em> model to pass parameters to a formatter. This works great when it works, but it can cause serious problems when a parameter type doesn't match its corresponding format specifier. Modern compilers do as much type-checking as they can, but the model is inherently flawed and the protection can only go so far.</p>
			<p>The STL <code>iostream</code> library brings type safety at the expense of readability and run-time performance. The <code>iostream</code> syntax is unusual, yet familiar. It overloads the <em class="italic">bitwise left-shift operator</em> (<code>&lt;&lt;</code>) to allow a chain of objects, operands, and <em class="italic">formatting manipulators</em>, which produce the formatted output.</p>
			<pre>cout &lt;&lt; "Hello, " &lt;&lt; str &lt;&lt; endl;</pre>
			<p>The weakness of <code>iostream</code> is its complexity, in both syntax and implementation. Building a formatted string can be verbose and obscure. Many of the formatting manipulators must be reset after use, or they create cascading formatting errors that can be difficult to debug. The library itself is vast and complex, resulting in code significantly larger and slower than its <code>printf</code> equivalent.</p>
			<p>This dismal situation has left C++ programmers with little option but to choose between two flawed systems, until now.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>How to do it…</h2>
			<p>The new <code>format</code> library is in the <code>&lt;format&gt;</code> header. As of this writing, <code>format</code> is implemented only in the <em class="italic">MSVC</em> (Microsoft) compiler. By the time you read this, it should be available on more systems. Otherwise, you may use its reference implementation as a third-party library from <code>fmt.dev</code> (<a href="http://j.bw.org/fmt">j.bw.org/fmt</a>).</p>
			<p>The <code>format</code> library is modeled on the <code>str.format()</code> method from Python 3. <em class="italic">Format strings</em> are substantially the same as those in Python and, for most purposes, they should be interchangeable. Let's examine some simple examples: </p>
			<ul>
				<li>In its simplest form, the <code>format()</code> function takes a <code>string_view</code> format string and a <em class="italic">variadic parameter pack</em> of arguments. It returns a <code>string</code>. Its function signature looks like this:<pre>template&lt;typename... Args&gt;
string format(string_view fmt, const Args&amp;... args);</pre></li>
				<li>The <code>format()</code> function<a id="_idIndexMarker002"/> returns a <code>string</code> representation<a id="_idIndexMarker003"/> of virtually any type or value. For example:<pre>string who{ "everyone" };
int ival{ 42 };
double pi{ std::numbers::pi };
format("Hello, {}!\n ", who);   // Hello, everyone!
format("Integer: {}\n ", ival); // Integer: 42
format("π: {}\n", pi);          // π: 3.141592653589793</pre></li>
			</ul>
			<p>The <em class="italic">format string</em> uses braces <code>{}</code> as a placeholder. With no <em class="italic">format specifiers</em>, the braces are effectively a type-safe <em class="italic">placeholder</em> which will convert a value of any compatible type to a reasonable string representation. </p>
			<ul>
				<li>You can include multiple placeholders in your format string, like this:<pre>format("Hello {} {}", ival, who);  // Hello 42 
                                   // everyone</pre></li>
				<li>You can specify the order of the replacement values. This could be useful for internationalization:<pre>format("Hello {1} {0}", ival, who); // Hello everyone 42
format("Hola {0} {1}", ival, who);  // Hola 42 everyone</pre></li>
				<li>You can align values, left (<code>&lt;</code>), right (<code>&gt;</code>), or center (<code>^</code>), with or without a fill character:<pre>format("{:.&lt;10}", ival);  // 42........
format("{:.&gt;10}", ival);  // ........42
format("{:.^10}", ival);  // ....42....</pre></li>
				<li>You can set the decimal precision of values:<pre>format("π: {:.5}", pi);  // π: 3.1416</pre></li>
				<li>And much, much more.</li>
			</ul>
			<p>It's a rich and complete<a id="_idIndexMarker004"/> formatting specification that provides <a id="_idIndexMarker005"/>the type-safety of <code>iostream</code> with the performance and simplicity of <code>printf</code>, for the best of both worlds.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>How it works…</h2>
			<p>The <code>format</code> library does not yet include a <code>print()</code> function, which is planned for <em class="italic">C++23</em>. The <code>format()</code> function itself returns a <code>string</code> object. So, if you want to print the string, you'll need to use either <code>iostream</code> or <code>cstdio</code>. (Sad face.)</p>
			<p>You can print the string using <code>iostream</code>:</p>
			<pre>cout &lt;&lt; format("Hello, {}", who) &lt;&lt; "\n";</pre>
			<p>Or you may use <code>cstdio</code>:</p>
			<pre>puts(format("Hello, {}", who).c_str());</pre>
			<p>Neither is ideal, but it's not very hard to write a simple <code>print()</code> function. And we can use this process to understand a bit of the <code>format</code> library's inner workings.</p>
			<p>Here's a simple implementation of a <code>print()</code> function using the <code>format</code> library:</p>
			<pre>#include &lt;format&gt;
#include &lt;string_view&gt;
#include &lt;cstdio&gt;
template&lt;typename... Args&gt;
void print(const string_view fmt_str, Args&amp;&amp;... args) {
    auto fmt_args{ <strong class="bold">make_format_args</strong>(args...) };
    string outstr{ <strong class="bold">vformat</strong>(fmt_str, fmt_args) };
    fputs(outstr.c_str(), stdout);
} </pre>
			<p>This uses the same arguments as the <code>format()</code> function. The first argument is a <code>string_view</code> object for the format string. This is followed by a variadic parameter pack for the arguments.</p>
			<p>The <code>make_format_args()</code> function takes the parameter pack and returns an object that contains <em class="italic">type-erased values</em> suitable for formatting. This object is then passed to <code>vformat()</code>, which returns a <code>string</code> suitable for printing. We use <code>fputs()</code> to print the value to the <a id="_idIndexMarker006"/>console because it's far more efficient<a id="_idIndexMarker007"/> than <code>cout</code>. </p>
			<p>We can now use this <code>print()</code> function in place of the <code>cout &lt;&lt; format()</code> combination:</p>
			<pre>print("Hello, {}!\n", who);
print("π: {}\n", pi);
print("Hello {1} {0}\n", ival, who);
print("{:.^10}\n", ival);
print("{:.5}\n", pi);</pre>
			<p>Output:</p>
			<pre>Hello, everyone!
π: 3.141592653589793
Hello everyone 42
....42....
3.1416</pre>
			<p>When you eventually get a C++23 complier with <code>print()</code> support, you should be able to simply<a id="_idIndexMarker008"/> replace the above <code>print()</code> template function <a id="_idIndexMarker009"/>definition with <code>using std::print;</code> and all the <code>print()</code> calls should continue to work.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>There's more…</h2>
			<p>It's nice to have the<a id="_idIndexMarker010"/> ability to format strings and primitives, but for the <code>format</code> library to be fully functional, it needs customization to work with your own classes.</p>
			<p>For example, here's a simple <code>struct</code> with two members: a <em class="italic">numerator</em> and <em class="italic">denominator</em>. We would like this to print as a fraction:</p>
			<pre>struct Frac {
    long n;
    long d;
};
int main() {
    Frac f{ 5, 3 };
    print("Frac: {}\n", f);    
}</pre>
			<p>When I compile this, it leads to a cascade of errors to the effect of, "No user-defined conversion operator…". Cool. So, let's fix it!</p>
			<p>When the <code>format</code> system encounters an object for <em class="italic">conversion</em>, it looks for a <em class="italic">specialization</em> of a <code>formatter</code> object with the corresponding type. Standard specializations are included for common objects such as strings and numbers and such.</p>
			<p>It's quite simple to create a specialization for our <code>Frac</code> type:</p>
			<pre>template&lt;&gt;
struct std::formatter&lt;Frac&gt;
{
    template&lt;typename ParseContext&gt;
    constexpr auto parse(ParseContext&amp; ctx) {
        return ctx.begin();
    }
    template&lt;typename FormatContext&gt;
    auto format(const Frac&amp; f, FormatContext&amp; ctx) {
        return format_to(ctx.out(), "{0:d}/{1:d}", 
            f.n, f.d);
    }
};</pre>
			<p>This <code>formatter</code> specialization<a id="_idIndexMarker011"/> is a class with two short template functions:</p>
			<ul>
				<li>The <code>parse()</code> function parses the <em class="italic">format string</em> from after the colon (or, if there is no colon, after the opening brace) up to but not including the closing brace. (In other words, the part that specifies the type of the object.) It takes a <code>ParseContext</code> object and returns an iterator. For our purposes, we can just return the <code>begin()</code> iterator because we don't need any new syntax for our <em class="italic">type</em>. You will rarely need to put anything else here.</li>
				<li>The <code>format()</code> function takes a <code>Frac</code> object and a <code>FormatContext</code> object. It returns an <em class="italic">end iterator</em>. The <code>format_to()</code> function makes this easy. It takes an iterator, a format string, and a parameter pack. In this case, the parameter pack is the two properties of our <code>Frac</code> class, the numerator and denominator.</li>
			</ul>
			<p>All we need to do here is provide a simple format string <code>"{0}/{1}"</code> and the numerator and denominator values. (The <code>0</code> and <code>1</code> indicate the position of the parameters. They're not strictly necessary but they could come in handy later.)</p>
			<p>Now that we have a specialization for <code>Frac</code>, we can pass our object to <code>print()</code> to get a readable result:</p>
			<pre>int main() {
    Frac f{ 5, 3 };
    print("Frac: {}\n", f);    
}</pre>
			<p>Output:</p>
			<pre>Frac: 5/3</pre>
			<p>The C++20 <code>format</code> library<a id="_idIndexMarker012"/> solves a long-standing problem by providing a type-safe text formatting library that is both efficient and convenient.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Use compile-time vectors and strings with constexpr</h1>
			<p>C++20 allows<a id="_idIndexMarker013"/> the use of <code>constexpr</code> in several new <a id="_idIndexMarker014"/>contexts. This provides improved efficiency, in<a id="_idIndexMarker015"/> that <a id="_idIndexMarker016"/>these things may be evaluated at compile time, instead of run time.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>How to do it…</h2>
			<p>The specification includes the ability to use <code>string</code> and <code>vector</code> objects in <code>constexpr</code> context. It's important to note that these objects may not themselves be declared <code>constexpr</code>, but they may be used in a compile-time context:</p>
			<pre>constexpr auto use_string() {
    string str{"string"};
    return str.size();
}</pre>
			<p>You can also use algorithms in <code>constexpr</code> context:</p>
			<pre>constexpr auto use_vector() {
    vector&lt;int&gt; vec{ 1, 2, 3, 4, 5};
    return accumulate(begin(vec), end(vec), 0);
}</pre>
			<p>The result of the <code>accumulate</code> algorithm is available at compile time and in <code>constexpr</code> context.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>How it works…</h2>
			<p>The <code>constexpr</code> specifier declares a variable or function that may be <em class="italic">evaluated at compile time. </em>Before C++20, this was limited to objects initialized with a literal value, or a function within<a id="_idIndexMarker017"/> limited constraints. C++17 allowed a somewhat expanded use and C++20<a id="_idIndexMarker018"/> expands<a id="_idIndexMarker019"/> it<a id="_idIndexMarker020"/> further.</p>
			<p>As of C++20, the STL <code>string</code> and <code>vector</code> classes now have <code>constexpr</code>-qualified constructors and destructors, which allow them to be invoked at compile time. This also means that the memory allocated for the <code>string</code> or <code>vector</code> object <em class="italic">must be freed at compile time.</em></p>
			<p>For example, this <code>constexpr</code> function, which returns a <code>vector</code>, will compile without error:</p>
			<pre>constexpr auto use_vector() {
    vector&lt;int&gt; vec{ 1, 2, 3, 4, 5};
    return vec;
}</pre>
			<p>But if you try to use the result in a run-time context, you will get an error about memory that was allocated during constant evaluation:</p>
			<pre>int main() {
    constexpr auto vec = use_vector();
    return vec[0];
}</pre>
			<p>This is because the <code>vector</code> object was allocated <em class="italic">and freed</em> during compilation. So, the object is no longer available at run time.</p>
			<p>On the other hand, you can use some <code>constexpr</code>-qualified methods from the <code>vector</code> object, such as <code>size()</code>, at run time:</p>
			<pre>int main() {
    constexpr auto value = use_vector().size();
    return value;
}</pre>
			<p>Because<a id="_idIndexMarker021"/> the <code>size()</code> method<a id="_idIndexMarker022"/> is <code>constexpr</code>-qualified, the<a id="_idIndexMarker023"/> expression<a id="_idIndexMarker024"/> can be evaluated at compile time.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Safely compare integers of different types</h1>
			<p>Comparing different<a id="_idIndexMarker025"/> types of integers may not always produce the expected results. For example:</p>
			<pre>int x{ -3 };
unsigned y{ 7 };
if(x &lt; y) puts("true");
else puts("false");</pre>
			<p>You may expect this code to print <code>true</code>, and that's understandable. -3 is usually less than 7. But it will print <code>false</code>.</p>
			<p>The problem is that <code>x</code> is signed and <code>y</code> is unsigned. The standardized behavior is to convert the signed type to unsigned for the comparison. That seems counterintuitive, doesn't it? Indeed, you cannot reliably convert an unsigned value to a signed value of the same size, because a signed integer uses <em class="italic">two's complement</em> representation (which uses the most significant bit as a sign). Given the same sized integer, the maximum signed value is half that of an unsigned value. Using this example, if your integers are 32-bits, -3 (signed) becomes <code>FFFF FFFD</code> (hexadecimal), or 4,294,967,293 (unsigned decimal), which is <em class="italic">not less than 7</em>.</p>
			<p>Some compilers may issue a warning when you try to compare signed with unsigned integer values, but most do not.</p>
			<p>The C++20 standard includes a set of integer-safe comparison functions in the <code>&lt;utility&gt;</code> header. </p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>How to do it…</h2>
			<p>The new integer <a id="_idIndexMarker026"/>comparison functions are found in the <code>&lt;utility&gt;</code> header. They each take two arguments, which correspond with the left- and right-hand sides of the operator.</p>
			<pre>#include &lt;utility&gt;
int main() {
    int x{ -3 };
    unsigned y{ 7 };
    if(<strong class="bold">cmp_less(x, y)</strong>) puts("true");
    else puts("false");
}</pre>
			<p>The <code>cmp_less()</code> function gives us the result we expect. -3 is less than 7 and the program now prints <code>true</code>.</p>
			<p>The <code>&lt;utility&gt;</code> header provides a full complement of integer comparison functions. Assuming our values for <code>x</code> and <code>y</code>, we get these comparisons:</p>
			<pre>cmp_equal(x, y)          // x == y is false
cmp_not_equal(x, y)      // x != y is true
cmp_less(x, y)           // x &lt; y is true
cmp_less_equal(x, y)     // x &lt;= y is true
cmp_greater(x, y)        // x &gt; y is false
cmp_greater_equal(x, y)  // x &gt;= y is false</pre>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>How it works…</h2>
			<p>Here's the sample implementation of the <code>cmp_less()</code> function from the C++20 standard, to give <a id="_idIndexMarker027"/>you a more complete picture of how it works:</p>
			<pre>template&lt; class T, class U &gt;
constexpr bool cmp_less( T t, U u ) noexcept
{
    using UT = make_unsigned_t&lt;T&gt;;
    using UU = make_unsigned_t&lt;U&gt;;
    if constexpr (is_signed_v&lt;T&gt; == is_signed_v&lt;U&gt;)
        return t &lt; u;
    else if constexpr (is_signed_v&lt;T&gt;)
        return t &lt; 0 ? true : UT(t) &lt; u;
    else
        return u &lt; 0 ? false : t &lt; UU(u);
}</pre>
			<p>The <code>UT</code> and <code>UU</code> aliases are declared as <code>make_unsigned_t</code>, a useful helper type introduced with C++17. This allows safe conversions of signed to unsigned types.</p>
			<p>The function first tests if both arguments are either signed or unsigned. If so, it returns a simple comparison.</p>
			<p>It then tests if either side is signed. If that signed value is less than zero, it can return <code>true</code> or <code>false</code> without performing a comparison. Otherwise, it converts the signed value to unsigned and returns the comparison.</p>
			<p>Similar logic is<a id="_idIndexMarker028"/> applied to each of the other comparison functions.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Use the "spaceship" operator &lt;=&gt; for three-way comparisons</h1>
			<p>The <em class="italic">three-way comparison</em> operator (<code>&lt;=&gt;</code>), commonly called the <em class="italic">spaceship</em> operator because it looks <a id="_idIndexMarker029"/>like a flying saucer in profile, is<a id="_idIndexMarker030"/> new in C++20. You may wonder, what's wrong with the existing six comparison operators? Nothing at all, and you will continue using them. The purpose of the spaceship is to provide a unified comparison operator for objects.</p>
			<p>The common two-way comparison operators return one of two states, <code>true</code> or <code>false</code>, according to the result of the comparison. For example:</p>
			<pre>const int a = 7;
const int b = 42;
static_assert(a &lt; b);</pre>
			<p>The <code>a &lt; b</code> expression uses the <em class="italic">less-than comparison</em> operator (<code>&lt;</code>) to test if <code>a</code> is less than <code>b</code>. The comparison operator returns <code>true</code> if the condition is satisfied, or <code>false</code> if not. In this case it returns <code>true</code> because 7 is less than 42.</p>
			<p>The three-way comparison works differently. It returns one of three states. The spaceship operator will return a value equal to <code>0</code> if the operands are equal, <em class="italic">negative</em> if the left-hand operand is less than the right-hand operand, or <em class="italic">positive</em> if the left-hand operand is greater than the right-hand operator.</p>
			<pre>const int a = 7;
const int b = 42;
static_assert((a &lt;=&gt; b) &lt; 0);</pre>
			<p>The returned value is <em class="italic">not an integer</em>. It's an object from the <code>&lt;compare&gt;</code> header that compares with <code>0</code>.</p>
			<p>If the operands have an integral type, the operator returns a <code>strong_ordering</code> object from the <code>&lt;compare&gt;</code> library.</p>
			<pre>strong_ordering::equal    // operands are equal
strong_ordering::less     // lhs is less than rhs
strong_ordering::greater  // lhs is greater than rhs</pre>
			<p>If the operands have a floating-point type, the operator returns a <code>partial_ordering</code> object:</p>
			<pre>partial_ordering::equivalent  // operands are equivelant
partial_ordering::less        // lhs is less than rhs
partial_ordering::greater     // lhs is greater than rhs
partial_ordering::unordered   // if an operand is unordered</pre>
			<p>These objects are designed to compare against a literal zero (<code>0</code>) with conventional comparison operators (for example, <code>(a &lt;=&gt; b) &lt; 0</code>). This allows the results of the three-way comparison to be more precise than conventional comparisons.</p>
			<p>If all of that seems a bit complicated, that's okay. For most applications you will never use the spaceship <a id="_idIndexMarker031"/>operator directly. Its real power is in its application as a unified comparison <a id="_idIndexMarker032"/>operator for objects. Let's dig a bit deeper.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>How to do it…</h2>
			<p>Let's look at a simple class that encapsulates an integer and provides comparison operators:</p>
			<pre>struct Num {
    int a;
    constexpr bool operator==(const Num&amp; rhs) const 
        { return a == rhs.a; }
    constexpr bool operator!=(const Num&amp; rhs) const
        { return !(a == rhs.a); }
    constexpr bool operator&lt;(const Num&amp; rhs) const
        { return a &lt; rhs.a; }
    constexpr bool operator&gt;(const Num&amp; rhs) const
        { return rhs.a &lt; a; }
    constexpr bool operator&lt;=(const Num&amp; rhs) const
        { return !(rhs.a &lt; a); }
    constexpr bool operator&gt;=(const Num&amp; rhs) const
        { return !(a &lt; rhs.a); }
};</pre>
			<p>It's not uncommon to see a list of comparison operator overloads like this. In fact, it should be even more complicated with <em class="italic">non-member friends</em> that work with objects on either side of the operator.</p>
			<p>With the new <a id="_idIndexMarker033"/>spaceship operator, all of this can be <a id="_idIndexMarker034"/>accomplished with one overload:</p>
			<pre>#include &lt;compare&gt;
struct Num {
    int a;
    constexpr Num(int a) : a{a} {}
    auto operator&lt;=&gt;(const Num&amp;) const = default;
};</pre>
			<p>Notice that we need to include the <code>&lt;compare&gt;</code> header for the three-way operator return types. Now we can declare some variables and test them with comparisons:</p>
			<pre>constexpr Num a{ 7 };
constexpr Num b{ 7 };
constexpr Num c{ 42 };
int main() {
    static_assert(a &lt; c);
    static_assert(c &gt; a);
    static_assert(a == b);
    static_assert(a &lt;= b);
    static_assert(a &lt;= c);
    static_assert(c &gt;= a);
    static_assert(a != c);
    puts("done.");
}</pre>
			<p>The compiler will automatically favor the <code>&lt;=&gt;</code> operator for each of the comparisons.</p>
			<p>Because the default <code>&lt;=&gt;</code> operator is already <code>constexpr</code> safe, we don't need to declare it as such in our member function.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>How it works…</h2>
			<p>The <code>operator&lt;=&gt;</code> overload takes advantage of a new C++20 concept, <em class="italic">rewritten expressions</em>. During<a id="_idIndexMarker035"/> overload resolution, the compiler <a id="_idIndexMarker036"/>rewrites the expression according to a set of rules. For example, if we write <code>a &lt; b</code>, the compiler will rewrite it to <code>(a &lt;=&gt; b &lt; 0)</code> so that it works with our member operator. The compiler will rewrite every relevant comparison expression for the <code>&lt;=&gt;</code> operator, where we haven't included a more specific operator.</p>
			<p>In fact, we no longer need a non-member function to handle comparisons with a compatible type on the left-hand side. The compiler will <em class="italic">synthesize</em> an expression that works with the member operator. For example, if we write <code>42 &gt; a</code>, the compiler will synthesize an expression with the operators reversed <code>(a &lt;=&gt; 42 &lt; 0)</code> so that it works with our member operator.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>&lt;=&gt;</code> operator has <em class="italic">higher precedence</em> than the other comparison operators so it will always evaluate first. All comparison operators evaluate left-to-right.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>There's more…</h2>
			<p>The default operator will <a id="_idIndexMarker037"/>work just fine with a wide variety of classes, including classes with multiple numeric members of different types:</p>
			<pre>struct Nums {
  int i;
  char c;
  float f;
  double d;
  auto operator&lt;=&gt;(const Nums&amp;) const = default;
};</pre>
			<p>But what if you have a <a id="_idIndexMarker038"/>more complex type? Here's <a id="_idIndexMarker039"/>an example of a simple fraction class:</p>
			<pre>struct Frac {
    long n;
    long d;
    constexpr Frac(int a, int b) : n{a}, d{b} {}
    constexpr double dbl() const {
        return static_cast&lt;double&gt;(n) / 
          static_cast&lt;double&gt;(d);
    }
    constexpr auto operator&lt;=&gt;(const Frac&amp; rhs) const {
        return dbl() &lt;=&gt; rhs.dbl();
    };
    constexpr auto operator==(const Frac&amp; rhs) const {
        return dbl() &lt;=&gt; rhs.dbl() == 0;
    };
};</pre>
			<p>In this case we need to define the <code>operator&lt;=&gt;</code> overload because our data members are not stand-alone scalar values. It's still quite simple and it works just as well.</p>
			<p>Notice that we also needed an <code>operator==</code> overload. This is because the expression rewrite rules will not rewrite <code>==</code> and <code>!=</code> with a custom <code>operator&lt;=&gt;</code> overload. You only need to define <code>operator==</code>. The compiler will rewrite the <code>!=</code> expression as needed.</p>
			<p>Now we can define some objects:</p>
			<pre>constexpr Frac a(10,15);  // compares equal with 2/3
constexpr Frac b(2,3);
constexpr Frac c(5,3);</pre>
			<p>And we can test <a id="_idIndexMarker040"/>them with normal comparison<a id="_idIndexMarker041"/> operators, as expected:</p>
			<pre>int main() {
    static_assert(a &lt; c);
    static_assert(c &gt; a);
    static_assert(a == b);
    static_assert(a &lt;= b);
    static_assert(a &lt;= c);
    static_assert(c &gt;= a);
    static_assert(a != c);
}</pre>
			<p>The power of the spaceship operator is in its ability to streamline comparison overloads in your classes. It improves both simplicity and efficiency when compared to overloading each <a id="_idIndexMarker042"/>operator <a id="_idIndexMarker043"/>independently.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Easily find feature test macros with the &lt;version&gt; header</h1>
			<p>C++ has provided<a id="_idIndexMarker044"/> some form of feature test<a id="_idIndexMarker045"/> macros for as long as new features have been added. Beginning with C++20, the process is standardized, and all <em class="italic">library feature</em> test macros have been added to the <code>&lt;version&gt;</code> header. This will make it much easier to test for a new feature in your code.</p>
			<p>This is a useful feature and it's very simple to use.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>How to do it…</h2>
			<p>All feature test macros begin with the prefix <code>__cpp_</code>. Library features begin with <code>__cpp_lib_</code>. Language feature test macros are typically defined by the compiler. Library feature test macros are defined in the new <code>&lt;version&gt;</code> header. Use them as you would any other preprocessor macro:</p>
			<pre>#include &lt;version&gt;
#ifdef __cpp_lib_three_way_comparison
#   include &lt;compare&gt;
#else
#   error Spaceship has not yet landed
#endif</pre>
			<p>In some cases, you can use the <code>__has_include</code> preprocessor operator (introduced in C++17) to test for the existence of an include file.</p>
			<pre>#if __has_include(&lt;compare&gt;)
#   include &lt;compare&gt;
#else
#   error Spaceship has not yet landed
#endif</pre>
			<p>You can use <code>__has_include</code> to test for the existence of any header file. Because it's a preprocessor directive, it doesn't require a header of its own to work.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>How it works…</h2>
			<p>Generally, you can use the feature test macros by testing for a non-zero value using <code>#ifdef</code> or <code>#if defined</code>. Each of the feature test macros has a non-zero value that corresponds to the year and month it was accepted by the standards committee. For example, the <code>__cpp_lib_three_way_comparison</code> macro has a value of <code>201907</code>. This<a id="_idIndexMarker046"/> means that it was accepted in <a id="_idIndexMarker047"/>July 2019.</p>
			<pre>#include &lt;version&gt;
#ifdef __cpp_lib_three_way_comparison
    cout &lt;&lt; "value is " &lt;&lt; __cpp_lib_three_way_comparison 
        &lt;&lt; "\n"
#endif</pre>
			<p>Output:</p>
			<pre>$ ./working
value is 201907</pre>
			<p>The value of the macro may be useful in some obscure cases where a feature has changed and you're dependent upon the changes. For most purposes, you can safely ignore the value and just test for non-zero with <code>#ifdef</code>.</p>
			<p>Several websites <a id="_idIndexMarker048"/>maintain a complete list of feature test macros. I tend to use <em class="italic">cppreference</em> (<a href="https://j.bw.org/cppfeature">https://j.bw.org/cppfeature</a>) but there are others.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Create safer templates with concepts and constraints</h1>
			<p>Templates are great<a id="_idIndexMarker049"/> for writing code that works<a id="_idIndexMarker050"/> with different types. For example, this function will work with any numeric type:</p>
			<pre>template &lt;typename T&gt;
T arg42(const T &amp; arg) {
    return arg + 42;
}</pre>
			<p>But what happens when you try to call it with a non-numeric type?</p>
			<pre>const char * n = "7";
cout &lt;&lt; "result is " &lt;&lt; arg42(n) &lt;&lt; "\n";</pre>
			<p>Output:</p>
			<pre>Result is ion</pre>
			<p>This compiles and runs without error, but the result is unpredictable. In fact, the call is dangerous and it could easily crash or become a vulnerability. I would much prefer the compiler generate an error message so I can fix the code.</p>
			<p>Now, with concepts, I can write it like this:</p>
			<pre>template &lt;typename T&gt;
<strong class="bold">requires</strong> Numeric&lt;T&gt;
T arg42(const T &amp; arg) {
    return arg + 42;
}</pre>
			<p>The <code>requires</code> keyword is new for C++20. It applies constraints to a template. <code>Numeric</code> is the name of a <em class="italic">concept</em> that only accepts integer and floating-point types. Now, when I compile this code with a non-numeric parameter, I get a reasonable compiler error:</p>
			<pre>error: 'arg42': no matching overloaded function found
error: 'arg42': the associated constraints are not satisfied</pre>
			<p>Error messages like this are far more useful than most compiler errors.</p>
			<p>Let's take a closer look at how to use concepts and constraints in your code.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>How to do it…</h2>
			<p>A concept is simply a named constraint. The <code>Numeric</code> concept from above looks like this:</p>
			<pre>#include &lt;concepts&gt;
template &lt;typename T&gt;
<strong class="bold">concept</strong> Numeric = integral&lt;T&gt; || floating_point&lt;T&gt;;</pre>
			<p>This <em class="italic">concept</em> requires a type <code>T</code>, which satisfies either the <code>std::integral</code> or <code>std::floating_point</code> predefined concepts. These concepts are included in the <code>&lt;concepts&gt;</code> header.</p>
			<p>Concepts and <a id="_idIndexMarker051"/>constraints may be used in class<a id="_idIndexMarker052"/> templates, function templates, or variable templates. We've seen a constrained function template, now here's a simple constrained class template example:</p>
			<pre>template&lt;typename T&gt;
requires Numeric&lt;T&gt;
struct Num {
    T n;
    Num(T n) : n{n} {}
};</pre>
			<p>And here's a simple variable template example:</p>
			<pre>template&lt;typename T&gt;
requires floating_point&lt;T&gt;
T pi{3.1415926535897932385L};</pre>
			<p>You can use concepts and constraints on any template. Let's consider some further examples. We'll be using function templates in these examples for simplicity.</p>
			<ul>
				<li>A constraint may use concepts or <em class="italic">type traits</em> to evaluate the characteristics of a type. You may use any of the type traits found in the <code>&lt;type_traits&gt;</code> header, so long as it returns a <code>bool</code>.</li>
			</ul>
			<p>For example:</p>
			<pre>template&lt;typename T&gt;
<strong class="bold">requires</strong> is_integral&lt;T&gt;::value  // value is bool
constexpr double avg(vector&lt;T&gt; const&amp; vec) {
    double sum{ accumulate(vec.begin(), vec.end(), 
      0.0)
    };
    return sum / vec.size();
}</pre>
			<ul>
				<li>The <code>requires</code> keyword<a id="_idIndexMarker053"/> is <a id="_idIndexMarker054"/>new in C++20. It introduces a constraint for the template arguments. In this example, the constraint expression tests the template argument against the type trait <code>is_integral</code>. </li>
				<li>You can use one of the pre-defined traits found in the <code>&lt;type_traits&gt;</code> header, or you can define your own, just as you would a template variable. For use in constraints, the variable must return <code>constexpr bool</code>. For example:<pre>template&lt;typename T&gt;
constexpr bool is_gt_byte{ sizeof(T) &gt; 1 };</pre></li>
			</ul>
			<p>This defines a type trait called <code>is_gt_byte</code>. This trait uses the <code>sizeof</code> operator to test if the type <code>T</code> is larger than 1 byte.</p>
			<ul>
				<li>A <em class="italic">concept</em> is simply a named set of constraints. For example:<pre>template&lt;typename T&gt;
<strong class="bold">concept</strong> Numeric = is_gt_byte&lt;T&gt; &amp;&amp;
    (integral&lt;T&gt; || floating_point&lt;T&gt;);</pre></li>
			</ul>
			<p>This defines a concept named <code>Numeric</code>. It uses our <code>is_gt_byte</code> constraint, along with the <code>floating_point</code> and <code>integral</code> concepts from the <code>&lt;concepts&gt;</code> header. We can use it to constrain a template to only accept numeric types that are greater than 1 byte in size.</p>
			<pre>template&lt;<strong class="bold">Numeric</strong> T&gt;
T arg42(const T &amp; arg) {
    return arg + 42;
}</pre>
			<p>You'll notice that I've applied the constraint in the template declaration, rather than on a separate line in a <code>requires</code> expression. There are a few ways to apply a<a id="_idIndexMarker055"/> concept. Let's look at how<a id="_idIndexMarker056"/> this works.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>How it works…</h2>
			<p>There are several different ways you can apply a concept or constraint:</p>
			<ul>
				<li>You can apply a concept or constraint with the <code>requires</code> keyword: <pre>template&lt;typename T&gt;
requires Numeric&lt;T&gt;
T arg42(const T &amp; arg) {
    return arg + 42;
}</pre></li>
				<li>You can apply a concept in the template declaration:<pre>template&lt;Numeric T&gt;
T arg42(const T &amp; arg) {
    return arg + 42;
}</pre></li>
				<li>You can use the <code>requires</code> keyword in a function signature:<pre>template&lt;typename T&gt;
T arg42(const T &amp; arg) requires Numeric&lt;T&gt; {
    return arg + 42;
}</pre></li>
				<li>Or you can use a concept in a parameter list for an abbreviated function template:<pre>auto arg42(Numeric auto &amp; arg) {
    return arg + 42;
}</pre></li>
			</ul>
			<p>For many purposes, choosing one of these strategies may be a matter of style. And there are <a id="_idIndexMarker057"/>circumstances where one may be a <a id="_idIndexMarker058"/>better option than another.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>There's more…</h2>
			<p>The standard uses the terms <em class="italic">conjunction</em>, <em class="italic">disjunction</em>, and <em class="italic">atomic</em>, to describe types of expressions<a id="_idIndexMarker059"/> that can be used to construct a constraint. Let's define these terms.</p>
			<p>You can combine concepts and constraints using the <code>&amp;&amp;</code> and <code>||</code> operators. These combinations are called <em class="italic">conjunctions</em> and <em class="italic">disjunctions</em>, respectively. You can think of them as logical <em class="italic">AND</em> and <em class="italic">OR</em>.</p>
			<p>A <em class="italic">constraint conjunction</em> is formed by using the <code>&amp;&amp;</code> operator with two constraints:</p>
			<pre>Template &lt;typename T&gt;
concept Integral_s = Integral&lt;T&gt; &amp;&amp; is_signed&lt;T&gt;::value;</pre>
			<p>A conjunction is satisfied only if both sides of the <code>&amp;&amp;</code> operator are satisfied. It is evaluated left-to-right. The operands of a conjunction are short-circuited, that is, if the left side constraint is not satisfied the right side will not be evaluated.</p>
			<p>A <em class="italic">constraint disjunction</em> is<a id="_idIndexMarker060"/> formed by using the <code>||</code> operator with two constraints:</p>
			<pre>Template &lt;typename T&gt;
concept Numeric = integral&lt;T&gt; || floating_point&lt;T&gt;;</pre>
			<p>A disjunction is satisfied if either side of the <code>||</code> operator is satisfied. It is evaluated left-to-right. The operands of a conjunction are short-circuited, that is, if the left side constraint is satisfied the right side will not be evaluated.</p>
			<p>An <em class="italic">atomic constraint</em> is an expression that returns a <code>bool</code> type, which<a id="_idIndexMarker061"/> cannot be further decomposed. In other words, it is not a <a id="_idIndexMarker062"/>conjunction or a disjunction.</p>
			<pre>template&lt;typename T&gt;
concept is_gt_byte = sizeof(T) &gt; 1;</pre>
			<p>You can also use the logical<code>!</code> (<em class="italic">NOT</em>) operator in an atomic constraint:</p>
			<pre>template&lt;typename T&gt;
concept is_byte = !is_gt_byte&lt;T&gt;;</pre>
			<p>As expected, the <code>!</code> operator inverts the value of the <code>bool</code> expression to the right of the <code>!</code>.</p>
			<p>Of course, we can combine all these expression types into a larger expression. We see examples of each of these constraint expressions in the following example:</p>
			<pre>template&lt;typename T&gt;
concept Numeric = is_gt_byte&lt;T&gt; &amp;&amp; 
    (integral&lt;T&gt; || floating_point&lt;T&gt;);</pre>
			<p>Let's break this down. The sub-expression, <code>(integral&lt;T&gt; </code><code> floating_point&lt;T&gt;)</code> is a <em class="italic">disjunction</em>. The sub-expression, <code>is_gt_byte&lt;T&gt; </code><code> (</code>…<code>)</code> is a <em class="italic">conjunction</em>. And each of the sub-expressions <code>integral&lt;T&gt;</code>, <code>floating_point&lt;T&gt;</code>, and <code>is_gt_byte&lt;T&gt;</code>, are <em class="italic">atomic</em>.</p>
			<p>These distinctions are mostly for descriptive purposes. While it's good to understand the details, as you write your code, it's safe to think of them as simple logical <code>||</code>, <code>&amp;&amp;</code>, and <code>!</code> operators.</p>
			<p>Concepts and constraints are a welcome addition to the C++ standard and I'm looking forward to using <a id="_idIndexMarker063"/>them in my future projects.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Avoid re-compiling template libraries with modules</h1>
			<p>Header files have <a id="_idIndexMarker064"/>been around since the<a id="_idIndexMarker065"/> very beginning of the C language. Originally, they were mainly used for <em class="italic">text substitution macros</em> and linking <em class="italic">external symbols</em> between translation units. With the introduction of templates, C++ leveraged header files to carry actual code. Because templates need to be recompiled for changes in specializations, we've been carrying them around in header files for many years. As the STL continues to grow over the years, these header files have grown as well. The situation has become unwieldy and is no longer scalable for the future.</p>
			<p>Header files typically contain a lot more than templates. They often contain configuration macros and other symbols that are required for system purposes, but not useful for the application. As the number of headers grows, the number of opportunities for symbol collisions grows as well. This is even more problematic when you consider the abundance of macros, which are not subject to namespace restrictions nor any form of type safety.</p>
			<p>C++20 addresses this problem with <em class="italic">modules</em>. </p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>How to do it…</h2>
			<p>You may be used to creating header files like this:</p>
			<pre>#ifndef BW_MATH
#define BW_MATH
namespace bw {
    template&lt;typename T&gt;
    T add(T lhs, T rhs) {
        return lhs + rhs;
    }
}
#endif // BW_MATH</pre>
			<p>This minimalist example illustrates several of the problems that modules address. The <code>BW_MATH</code> symbol is used as an <em class="italic">include guard</em>. Its only purpose is to prevent the header file from being included more than once, yet its symbol is carried throughout the translation unit. When you include this header in your source file, it may look like this:</p>
			<pre>#include "bw-math.h"
#include &lt;format&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;</pre>
			<p>Now that <code>BW_MATH</code> symbol is available to every other header you've included, and every header <a id="_idIndexMarker066"/>included by the other <a id="_idIndexMarker067"/>headers, and on and on. That's a lot of opportunities for collision. And keep in mind, the compiler cannot check for these collisions. They're macros. That means they're translated by the preprocessor before the compiler ever has a chance to see them.</p>
			<p>Now we get to the actual point of the header, the template function:</p>
			<pre>template&lt;typename T&gt;
T add(T lhs, T rhs) {
    return lhs + rhs;
}</pre>
			<p>Because it's a template, every time you use the <code>add()</code> function the compiler must create a separate specialization. This means that the template function must be parsed and specialized each time it's invoked. That's why templates go in header files; the source must be available at compile time. As the STL grows and evolves, with its many large template classes and functions, this becomes a significant scalability problem.</p>
			<p><em class="italic">Modules</em> solve these problems and more.</p>
			<p>As a module, <code>bw-math.h</code> becomes <code>bw-math.ixx</code> (in the MSVC naming convention) and it looks like this:</p>
			<pre><strong class="bold">export</strong> module bw_math;
<strong class="bold">export</strong> template&lt;typename T&gt;
T add(T lhs, T rhs) {
    return lhs + rhs;
}</pre>
			<p>Notice that the only symbols exported are the name of the module, <code>bw_math</code>, and the name of the function, <code>add()</code>. This keeps the namespace clean.</p>
			<p>The usage is<a id="_idIndexMarker068"/> cleaner as well. When <a id="_idIndexMarker069"/>we use it in <code>module-test.cpp</code>, it looks like this:</p>
			<pre><strong class="bold">import</strong> bw_math;
<strong class="bold">import</strong> std.core;
int main() {
    double f = add(1.23, 4.56);
    int i = add(7, 42);
    string s = add&lt;string&gt;("one ", "two");
    cout &lt;&lt; 
        "double: " &lt;&lt; f &lt;&lt; "\n" &lt;&lt;
        "int: " &lt;&lt; i &lt;&lt; "\n" &lt;&lt;
        "string: " &lt;&lt; s &lt;&lt; "\n";
}</pre>
			<p>The <code>import</code> declarations are used where we might otherwise use <code>#include</code> preprocessor directives. These import the symbol tables from the modules for linkage.</p>
			<p>The output of our example looks like this:</p>
			<pre>$ ./module-test
double: 5.79
int: 49
string: one two</pre>
			<p>The module version works exactly as it did in a header file, only cleaner and more efficiently.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The compiled <a id="_idIndexMarker070"/>module includes a separate <em class="italic">metadata file</em> (<em class="italic">module-name</em><code>.ifc</code> in the MSVC naming convention), which describes the module interface. This allows the module to support templates. The metadata includes sufficient information for the compiler to create template specializations.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>How it works…</h2>
			<p>The <code>import</code> and <code>export</code> declarations are at the core of the <em class="italic">Modules</em> implementation. Let's take<a id="_idIndexMarker071"/> another look at<a id="_idIndexMarker072"/> the <code>bw-math.ixx</code> module:</p>
			<pre>export module bw_math;
export template&lt;typename T&gt;
T add(T lhs, T rhs) {
    return lhs + rhs;
}</pre>
			<p>Notice the two <code>export</code> declarations. The first exports the module itself with <code>export module bw_math</code>. This declares the translation unit as a module. There must be a module declaration at the top of every module file, and before any other statements. The second <code>export</code> makes the function name <code>add()</code> available to the <em class="italic">module consumer</em>. </p>
			<p>If your module requires <code>#include</code> directives, or other global fragments, you will need to first declare your module with a simple module declaration like this:</p>
			<pre>module;
#define SOME_MACRO 42
#include &lt;stdlib.h&gt;
export module bw_math;
...</pre>
			<p>The <code>module;</code> declaration, on a line by itself at the top of the file, introduces a <em class="italic">global module fragment</em>. Only preprocessor directives may appear in the global module fragment. This must be immediately followed by a standard module declaration (<code>export module bw_math;</code>) and <a id="_idIndexMarker073"/>the rest of the module content. Let's look closer at how this works:</p>
			<ul>
				<li>An <code>export</code> declaration makes a symbol visible to the <em class="italic">module consumer</em>, that is, the code that imports the module. Symbols default to private.<pre><strong class="bold">export</strong> int a{7};  // visible to consumer
int b{42};        // not visible</pre></li>
				<li>You can <a id="_idIndexMarker074"/>export a block, like<a id="_idIndexMarker075"/> this:<pre><strong class="bold">export</strong> {
    int a() { return 7; };     // visible 
    int b() { return 42; };    // also visible
}</pre></li>
				<li>You can export a namespace:<pre><strong class="bold">export</strong> namespace bw {  // all of the bw namespace is visible
    template&lt;typename T&gt;
    T add(T lhs, T rhs) {  // visible as bw::add()
        return lhs + rhs;
    }
}</pre></li>
				<li>Or, you can export individual symbols from a namespace:<pre>namespace bw {  // all of the bw namespace is visible
    <strong class="bold">export</strong> template&lt;typename T&gt;
    T add(T lhs, T rhs) {  // visible as bw::add()
        return lhs + rhs;
    }
}</pre></li>
				<li>An <code>import</code> <a id="_idIndexMarker076"/>declaration imports a module in the <em class="italic">consumer</em>:<pre><strong class="bold">import</strong> bw_math;
int main() {
    double f = bw::add(1.23, 4.56);
    int i = bw::add(7, 42);
    string s = bw::add&lt;string&gt;("one ", "two");
}</pre></li>
				<li>You can even<a id="_idIndexMarker077"/> import a<a id="_idIndexMarker078"/> module and export it to the consumer to pass it along:<pre>export module bw_math;
<strong class="bold">export</strong> <strong class="bold">import</strong> std.core;</pre></li>
			</ul>
			<p>The <code>export</code> keyword must precede the <code>import</code> keyword.</p>
			<p>The <code>std.core</code> module is now available for the consumer:</p>
			<pre>import bw_math;
using std::cout, std::string, std::format;
int main() {
    double f = bw::add(1.23, 4.56);
    int i = bw::add(7, 42);
    string s = bw::add&lt;string&gt;("one ", "two");
    cout &lt;&lt; 
        format("double {} \n", f) &lt;&lt;
        format("int {} \n", i) &lt;&lt;
        format("string {} \n", s);
}</pre>
			<p>As you can see, modules are a simple, straightforward alternative to header files. I know a lot of us are looking forward to the broad availability of modules. I can see this greatly reducing our dependency on header files.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of writing, the only complete implementation of modules is in a <em class="italic">preview release</em> of MSVC. The module filename extension (<code>.ixx</code>) may be different for other compilers. Also, the amalgamated <code>std.core</code> module is part of how MSVC implements the STL as modules in this release. Other compilers may not use this convention. Some details may change when fully compliant implementations are released.</p>
			<p>In the example<a id="_idIndexMarker079"/> files, I've included a module version of my <code>format</code>-based <code>print()</code> function. This <a id="_idIndexMarker080"/>works on the current preview release of MSVC. It may require some small modifications to make it work on other systems, once they support enough of the modules specification.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Create views into containers with ranges</h1>
			<p>The new <code>ranges</code> library <a id="_idIndexMarker081"/>is one of the more significant <a id="_idIndexMarker082"/>additions to C++20. It provides a new paradigm for filtering and processing containers. Ranges provide clean and intuitive building blocks for more effective and readable code.</p>
			<p>Let's start by defining a few terms:</p>
			<ul>
				<li>A <code>begin()</code> and <code>end()</code> iterators is a range. This includes most STL containers.</li>
				<li>A <strong class="bold">View</strong> is a range<a id="_idIndexMarker084"/> that transforms another underlying range. Views are lazy, meaning they only operate as the range iterates. A view returns data from the underlying range and does not own any data itself. Views operate in <em class="italic">O(1)</em> constant time.</li>
				<li>A <code>|</code> operator.<p class="callout-heading">Note</p><p class="callout">The <code>&lt;ranges&gt;</code> library uses the <code>std::ranges</code> and the <code>std::ranges::view</code> namespaces. Recognizing that this is cumbersome, the standard includes an alias for <code>std::ranges::view</code> as the simply, <code>std::view</code>. I still find that cumbersome. For this recipe I will use the following aliases, to save space and because I find it more elegant: </p><p class="callout"><code>namespace ranges = std::ranges;  // save the fingers!</code></p><p class="callout"><code>namespace views = std::ranges::views;  </code></p><p class="callout">This applies to all the code in this recipe.</p></li>
			</ul>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>How to do it…</h2>
			<p>The <code>ranges</code> and <code>views</code> classes are in the <code>&lt;ranges&gt;</code> header. Let's look at how you can use them:</p>
			<ul>
				<li>A <em class="italic">View</em> is applied to a <em class="italic">Range</em>, like this:<pre>const vector&lt;int&gt; nums{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
auto result = ranges::<strong class="bold">take_view</strong>(nums, 5);
for (auto v: result) cout &lt;&lt; v &lt;&lt; " ";</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">1 2 3 4 5</strong> </pre>
			<p><code>ranges::take_view(range, n)</code> is a view that returns the first <em class="italic">n</em> elements.</p>
			<p>You may<a id="_idIndexMarker087"/> also use the <em class="italic">view adapter</em> version<a id="_idIndexMarker088"/> of <code>take_view()</code>:</p>
			<pre>auto result = nums | views::take(5);
for (auto v: result) cout &lt;&lt; v &lt;&lt; " ";</pre>
			<p>Output:</p>
			<pre><strong class="bold">1 2 3 4 5</strong> </pre>
			<p><em class="italic">View adapters</em> are in the <code>std::ranges::views</code> namespace. A <em class="italic">view adapter </em>takes the <em class="italic">range operand</em> from the left-hand side of the <code>|</code> operator, much like the <code>iostreams</code> usage of the <code>&lt;&lt;</code> operator. The <code>|</code> operands are evaluated left-to-right.</p>
			<ul>
				<li>Because a view adapter is <em class="italic">iterable</em>, it also qualifies as a range. This allows them to be applied serially, like this:<pre>const vector&lt;int&gt; nums{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
auto result = nums | views::take(5) | 
   views::reverse;</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">5 4 3 2 1</strong></pre>
			<ul>
				<li>The <code>filter()</code> view uses a predicate function:<pre>auto result = nums | 
    views::filter([](int i){ return 0 == i % 2; });</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">2 4 6 8 10</strong></pre>
			<ul>
				<li>The <code>transform()</code> view uses a transformation function:<pre>auto result = nums | 
    views::transform([](int i){ return i * i; });</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">1 4 9 16 25 36 49 64 81 100</strong></pre>
			<ul>
				<li>Of course, these <a id="_idIndexMarker089"/>views and adapters <a id="_idIndexMarker090"/>work on ranges of any type:<pre>cosnt vector&lt;string&gt;
words{ "one", "two", "three", "four", "five" };
auto result = words | views::reverse;</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">five four three two one</strong></pre>
			<ul>
				<li>The <code>ranges</code> library also includes a few <em class="italic">range factories</em>. The <code>iota</code> factory will generate an incrementing series of values:<pre>auto rnums = views::iota(1, 10);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">1 2 3 4 5 6 7 8 9</strong></pre>
			<p>The <code>iota(value, bound)</code> function generates a sequence starting with <code>value</code> and ending <em class="italic">before</em> <code>bound</code>. If <code>bound</code> is omitted, the sequence is infinite:</p>
			<pre>auto rnums = views::iota(1) | views::take(200);</pre>
			<p>Output:</p>
			<pre><strong class="bold">1 2 3 4 5 6 7 8 9 10 11 12 […] 196 197 198 199 200</strong></pre>
			<p><em class="italic">Ranges</em>, <em class="italic">Views</em>, and <em class="italic">View Adapters</em> are incredibly flexible and useful. Let's take a deeper look for a better understanding.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>How it works…</h2>
			<p>To satisfy the basic requirements for a <em class="italic">Range</em>, an object must have at least two iterators, <code>begin()</code> and <code>end()</code>, where the <code>end()</code> iterator is a sentinel, used to determine the end point of a range. Most STL containers qualify as ranges, including <code>string</code>, <code>vector</code>, <code>array</code>, <code>map</code>, and others, with the notable exception of container-adapters, like <code>stack</code> and <code>queue</code>, which don't have <code>begin</code> and <code>end</code> iterators.</p>
			<p>A <em class="italic">View</em> is an object which operates on a range and returns a modified range. A view operates lazily, and contains no data of its own. Instead of keeping a copy of the underlying<a id="_idIndexMarker091"/> data, it simply returns iterators to <a id="_idIndexMarker092"/>underlying elements as needed. Let's examine this code snippet:</p>
			<pre>vector&lt;int&gt; vi { 0, 1, 2, 3, 4, 5 };
<strong class="bold">ranges::take_view</strong> tv{vi, 2};
for(int i : tv) {
    cout &lt;&lt; i &lt;&lt; " ";
}
cout &lt;&lt; "\n";</pre>
			<p>Output:</p>
			<pre>0 1</pre>
			<p>In this example, the <code>take_view</code> object takes two parameters, a <em class="italic">range</em> (in this case, a <code>vector&lt;int&gt;</code> object), and a <em class="italic">count</em>. The result is a <em class="italic">view</em> with the first <em class="italic">count</em> objects from the <code>vector</code>. At evaluation time, during the iteration of the <code>for</code> loop, the <code>take_view</code> object simply returns iterators that point to elements of the <code>vector</code> object, as needed. The <code>vector</code> object is not modified in this process.</p>
			<p>Many of the views in the <code>ranges</code> namespace have corresponding <em class="italic">range adapters</em> in the <code>views</code> namespace. These adapters may be used with the <em class="italic">bitwise or</em> (<code>|</code>) operator, as a pipe, like this:</p>
			<pre>vector&lt;int&gt; vi { 0, 1, 2, 3, 4, 5 };
auto tview = vi | <strong class="bold">views::take</strong>(2);
for(int i : tview) {
    cout &lt;&lt; i &lt;&lt; " ";
}
cout &lt;&lt; "\n";</pre>
			<p>Output:</p>
			<pre>0 1</pre>
			<p>As expected, the <code>|</code> operator evaluates left to right. And because the result of the range adapter is <a id="_idIndexMarker093"/>another range, these adapter expressions may <a id="_idIndexMarker094"/>be chained:</p>
			<pre>vector&lt;int&gt; vi { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
auto tview = vi | views::reverse | views::take(5);
for(int i : tview) {
    cout &lt;&lt; i &lt;&lt; " ";
}
cout &lt;&lt; "\n";</pre>
			<p>Output:</p>
			<pre>9 8 7 6 5</pre>
			<p>The library includes a <code>filter</code> view that is used with a <em class="italic">predicate</em>, for defining simple filters:</p>
			<pre>vector&lt;int&gt; vi { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
auto even = [](long i) { return 0 == i % 2; };
auto tview = vi | views::filter(even);</pre>
			<p>Output:</p>
			<pre>0 2 4 6 8</pre>
			<p>Also included, is a <code>transform</code> view that is used with a <em class="italic">transform function</em> for transforming results:</p>
			<pre>vector&lt;int&gt; vi { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
auto even = [](int i) { return 0 == i % 2; };
auto x2 = [](auto i) { return i * 2; };
auto tview = vi | views::filter(even) | views::transform(x2);</pre>
			<p>Output:</p>
			<pre>0 4 8 12 16</pre>
			<p>There are <a id="_idIndexMarker095"/>quite a few useful views and view adapters in the library. Please <a id="_idIndexMarker096"/>check your favorite <a id="_idIndexMarker097"/>reference site, or (<a href="https://j.bw.org/ranges">https://j.bw.org/ranges</a>) for a complete list.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>There's more…</h2>
			<p>Beginning with C++20, most of the algorithms in the <code>&lt;algorithm&gt;</code> header include versions for use with <code>ranges</code>. These versions are still in the <code>&lt;algorithm&gt;</code> header, but in the <code>std::ranges</code> namespace. This distinguishes them from the legacy algorithms.</p>
			<p>This means that, instead of calling an algorithm with two iterators:</p>
			<pre>sort(v.begin(), v.end());</pre>
			<p>You can now call it with just a range, like this:</p>
			<pre>ranges::sort(v);</pre>
			<p>That's certainly more convenient, but how does it really help?</p>
			<p>Consider the case where you want to sort part of a vector, you could do that the old way, like this:</p>
			<pre>sort(v.begin() + 5, v.end());</pre>
			<p>This would sort the elements of the vector after the first 5. With the <code>ranges</code> version, you can use a view to skip the first 5 elements:</p>
			<pre>ranges::sort(views::drop(v, 5));</pre>
			<p>You can even combine views:</p>
			<pre>ranges::sort(views::drop(views::reverse(v), 5));</pre>
			<p>In fact, you can <a id="_idIndexMarker098"/>even use range adapters as the argument<a id="_idIndexMarker099"/> to <code>ranges::sort</code>:</p>
			<pre>ranges::sort(v | views::reverse | views::drop(5));</pre>
			<p>In contrast, if you wanted to do this with the traditional <code>sort</code> algorithm and vector iterators, it would look something like this:</p>
			<pre>sort(v.rbegin() + 5, v.rend());</pre>
			<p>While that's certainly shorter, and not impossible to understand, I find the range adapters version far more intuitive. </p>
			<p>You can find a complete list of algorithms that have been constrained to work with ranges on <a id="_idIndexMarker100"/>the <em class="italic">cppreference</em> site (https://j.bw.org/algoranges).</p>
			<p>In this recipe, we've only scratched the surface of <em class="italic">Ranges</em> and <em class="italic">Views</em>. This feature is the culmination of over a decade of work by many different teams, and I expect it to fundamentally change the way we use containers in the STL.</p>
		</div>
	</body></html>