<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer037">
<h1 class="chapter-number" id="_idParaDest-62"><a id="_idTextAnchor060"/>4</h1>
<h1 id="_idParaDest-63"><a id="_idTextAnchor061"/> Diving Deep into the C++ Object</h1>
<p>In this chapter, we will pay special attention to the object in the C++ language. But what makes the object in C++ so special that we should pay so much attention to it? Well, considering the fact that C++ supports the object-oriented programming paradigm, it is assumed that the object itself takes a central position in the structure of the language. You will see that there are many specifics around objects <span class="No-Break">in C++.</span></p>
<p>In this chapter, we will delve into the fundamental aspects of objects in C++. We will start by examining how the C++ standard specifies the definition of an object. Moving on from there, we will take a closer look at the different types of object initializations, such as aggregate, direct, and copy initialization, and their <span class="No-Break">use cases.</span></p>
<p>We will also explore the concept of storage duration for objects. Additionally, we will take a look at the scope and lifetime of objects in C++. We will also see what references are and how they correlate <span class="No-Break">to objects.</span></p>
<p>As we progress further, we will learn about temporary objects and why it is important to handle them with care, and the concept of function objects and lambdas in C++. We will explore an example of how to use lambdas with a <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) algorithm, which<a id="_idIndexMarker323"/> will help us gain a comprehensive understanding of how to leverage these powerful features to create more efficient and <span class="No-Break">optimized code.</span></p>
<p>By the end of this chapter, you will have a clear understanding of the fundamental concepts of objects in C++, and you will be familiar with some techniques you can use to create more robust and <span class="No-Break">efficient code.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>The C++ <span class="No-Break">object model</span></li>
<li>Scope, storage duration, <span class="No-Break">and lifetimes</span></li>
<li>Functors and lambdas <span class="No-Break">in C++</span></li>
</ul>
<p>Alright, it’s time <span class="No-Break">to begin!</span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor062"/>Technical requirements</h1>
<p>All examples in this chapter have been tested in an environment with the <span class="No-Break">following configuration:</span></p>
<ul>
<li>Linux Mint 21 <span class="No-Break">Cinnamon edition</span></li>
<li>GCC 12.2 with compiler flags – <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">std=c++20</strong></span></li>
<li>A stable <span class="No-Break">internet connection</span></li>
<li>Please make sure your environment uses these versions or later. For all the examples you can alternatively <span class="No-Break">use </span><a href="https://godbolt.org/"><span class="No-Break">https://godbolt.org/</span></a><span class="No-Break">.</span></li>
<li>All code examples in this chapter are available for download <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%204"><span class="No-Break">https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%204</span></a><span class="No-Break">.</span></li>
</ul>
<h1 id="_idParaDest-65"><a id="_idTextAnchor063"/>Understanding the C++ object model</h1>
<p>C++ programs<a id="_idIndexMarker324"/> involve the creation, manipulation, and destruction of various entities known as <em class="italic">objects</em>. An <a id="_idIndexMarker325"/>object in C++ possesses several attributes such as <em class="italic">type</em>, <em class="italic">size</em>, <em class="italic">storage duration</em>, <em class="italic">lifetime</em>, <em class="italic">alignment requirements</em>, and <em class="italic">value</em>. The <em class="italic">name</em> of the object <span class="No-Break">is </span><span class="No-Break"><em class="italic">optional</em></span><span class="No-Break">.</span></p>
<p>The lifetime of the named object is bounded by its storage duration, and if the object doesn’t have a name, it is considered <a id="_idIndexMarker326"/>a <em class="italic">temporary</em> object. However, not all entities in C++ are considered objects. For example, the reference is one <span class="No-Break">such non-object.</span></p>
<p>First, let’s take a brief look at the terminology because it is important to be aware of it, as it will help us in our daily work with the <span class="No-Break">C++ language.</span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor064"/>Declaration versus definition</h2>
<p>In C++, the terms <em class="italic">declaration</em> and <em class="italic">definition</em> are often used to refer to different aspects of a variable, function, or class. Here’s what each <span class="No-Break">term means:</span></p>
<ul>
<li><strong class="bold">Declaration</strong>: A<a id="_idIndexMarker327"/> declaration introduces a name into a program and specifies the type of the variable, function, or class, such as <span class="No-Break">the following:</span><pre class="source-code">
extern int x;
void foo(int arg);
struct Point;</pre><p class="list-inset">In the preceding example, <strong class="source-inline">x</strong>, <strong class="source-inline">foo</strong>, and <strong class="source-inline">Point</strong> are all <em class="italic">declared</em> but not defined. The <strong class="source-inline">extern</strong> keyword in the variable declaration indicates that <strong class="source-inline">x</strong> is defined elsewhere in the program. In declaration, no memory <span class="No-Break">is allocated.</span></p></li> <li><strong class="bold">Definition</strong>: A definition <a id="_idIndexMarker328"/>provides the actual implementation for a name that has been declared. It reserves memory for variables, allocates code space for functions, and defines the layout of classes, such as <span class="No-Break">the following:</span><pre class="source-code">
int x;
void foo(int arg) {
   // function body
}
struct Point {
   // struct members and methods
};</pre><p class="list-inset">In the preceding example, <strong class="source-inline">x</strong>, <strong class="source-inline">foo</strong>, and <strong class="source-inline">Point</strong> are <span class="No-Break">all </span><span class="No-Break"><em class="italic">defined</em></span><span class="No-Break">.</span></p></li> </ul>
<p>So, the <em class="italic">declaration</em> introduces a name and specifies its type, while the <em class="italic">definition</em> provides the actual implementation and allocates memory for <span class="No-Break">the object.</span></p>
<p>Now that we are familiar with the terminology, let’s dive deep into the specifics of the objects <span class="No-Break">in C++.</span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor065"/>Scope, storage duration, and lifetimes</h2>
<p>Each object or reference in a C++ program has a specific region in the program where it is visible and accessible, a specific lifetime, and a specific type of memory it occupies. Let’s take a closer look at each <span class="No-Break">of them.</span></p>
<h3>Scope</h3>
<p>In C++, the<a id="_idIndexMarker329"/> scope<a id="_idIndexMarker330"/> of a variable, function, or class refers to the region of the program where the name of the entity is visible and can be accessed without qualification. The scope rules determine which identifiers are visible and accessible in different parts of the program. The standard defines several types of scopes in C++. Some of them are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="bold">Global</strong>: Variables, functions, and classes declared outside any function or class have global scope. They <a id="_idIndexMarker331"/>can be accessed from any part of the program, such as <span class="No-Break">the following:</span><pre class="source-code">
int x = 1; // global variable
void foo() {
    std::cout &lt;&lt; x &lt;&lt; std::endl; // access global
      variable
}</pre></li> <li><strong class="bold">Function</strong>: Variables<a id="_idIndexMarker332"/> declared inside a function have function scope. They can be accessed only within the function where they are declared, such as <span class="No-Break">the following:</span><pre class="source-code">
void foo() {
    int x = 1; // local variable
    std::cout &lt;&lt; x &lt;&lt; std::endl; // access local
      variable
}</pre></li> <li><strong class="bold">Block</strong>: Variables <a id="_idIndexMarker333"/>declared inside a block, which is a sequence of statements enclosed in curly braces (<strong class="source-inline">{}</strong>), have block scope. They can be accessed only within the block where they are declared, or in inner blocks if there are any, such as <span class="No-Break">the following:</span><pre class="source-code">
void foo() {
    int x = 2; // local variable with function scope
    {
        int y = 4; // local variable with block scope
    }
}</pre></li> </ul>
<p>These are some of the scopes we use in C++. Now, let’s see what storage duration means <span class="No-Break">in C++.</span></p>
<h3>Storage duration</h3>
<p>In C++, <em class="italic">storage duration</em> refers <a id="_idIndexMarker334"/>to the lifetime of an object, or <a id="_idIndexMarker335"/>how long it exists in memory. There are four types of <span class="No-Break">storage duration:</span></p>
<ul>
<li><strong class="bold">Automatic</strong>: These <a id="_idIndexMarker336"/>objects are created when a program enters the block in which they are declared, and they are destroyed when the block is exited. Examples include local variables declared <em class="italic">without</em> the <strong class="source-inline">static</strong> keyword and <span class="No-Break">function parameters.</span></li>
<li><strong class="bold">Static</strong>: These <a id="_idIndexMarker337"/>objects are created either when a program starts or when the program execution reaches this stage for the first time. Also, they are destroyed when the program terminates. They are stored in a global memory area and persist throughout the program’s lifetime. Examples include global variables and variables declared <em class="italic">with</em> the <strong class="source-inline">static</strong> keyword inside <span class="No-Break">a function.</span></li>
<li><strong class="bold">Dynamic</strong>: These <a id="_idIndexMarker338"/>objects are created with the <strong class="source-inline">new</strong> operator and destroyed with the <strong class="source-inline">delete</strong> operator. They exist on the heap and can be accessed by multiple parts of <span class="No-Break">a program.</span></li>
<li><strong class="bold">Thread-local</strong>: These<a id="_idIndexMarker339"/> objects are created when a thread is created and destroyed when the thread terminates. They are like objects with static storage duration, but they are specific to a <span class="No-Break">particular thread.</span></li>
</ul>
<p>Here is an example <a id="_idIndexMarker340"/>that illustrates the different types of <span class="No-Break">storage duration:</span></p>
<pre class="source-code">
#include &lt;iostream&gt;
int global_var = 1; // Static storage duration
void foo() {
    int automatic_var = 2;
    static int static_var = 3;
    int* dynamic_var = new int(4);
    std::cout &lt;&lt; "Automatic var: " &lt;&lt; automatic_var &lt;&lt;
      '\n';
    std::cout &lt;&lt; "Static var: " &lt;&lt; static_var &lt;&lt; '\n';
    std::cout &lt;&lt; "Dynamic var: " &lt;&lt; *dynamic_var &lt;&lt; '\n';
    delete dynamic_var;
}
int main() {
    foo();
    std::cout &lt;&lt; "Global var: " &lt;&lt; global_var &lt;&lt; '\n';
    return 0;
}</pre> <p>In this example, <strong class="source-inline">global_var</strong> has static storage duration because it is a global variable. <strong class="source-inline">automatic_var</strong> has automatic <a id="_idIndexMarker341"/>storage duration because it is declared inside the <strong class="source-inline">foo</strong> function. <strong class="source-inline">static_var</strong> also has static storage duration, but it retains its value between calls to <strong class="source-inline">foo</strong> because of the <strong class="source-inline">static</strong> keyword. <strong class="source-inline">dynamic_var</strong> itself has an automatic storage duration, but the allocated memory that it points to has dynamic storage duration because it is allocated with the <strong class="source-inline">new</strong> operator. When <strong class="source-inline">foo</strong> returns, <strong class="source-inline">automatic_var</strong> is automatically destroyed, <strong class="source-inline">dynamic_var</strong> is destroyed with the help of the <strong class="source-inline">delete</strong> operator, while <strong class="source-inline">static_var</strong> and <strong class="source-inline">global_var</strong> persist throughout a <span class="No-Break">program’s lifetime.</span></p>
<h3>Lifetime</h3>
<p>The<a id="_idIndexMarker342"/> term <em class="italic">lifetime</em> refers<a id="_idIndexMarker343"/> to the duration of the existence of an object or a reference within a program. Every object and reference in C++ has <a id="_idTextAnchor066"/>a specific lifetime. The lifetime of an object begins when memory is allocated for it, and it is initialized. If the object’s type has a constructor, then the lifetime begins when the constructor is successfully completed. The lifetime of an object ends either when its destructor is called or, if no destructor exists, when it is destroyed. Thus, an object’s lifetime is equivalent to or smaller than the dura<a id="_idTextAnchor067"/>tion of its storage. Similarly, the lifetime of a reference begins when its initialization is completed and ends up like a <span class="No-Break">scalar object.</span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>The object</h2>
<p>Each<a id="_idIndexMarker344"/> object is<a id="_idIndexMarker345"/> created by a definition statement that introduces, creates, and optionally initializes a <em class="italic">variable</em>. A <a id="_idIndexMarker346"/>variable is an <em class="italic">object</em> or a <em class="italic">reference</em> that is not a non-static data member, and it is introduced by a declaration (Object - <a href="http://cppreference.com"><span class="No-Break">cppreference.com</span></a><span class="No-Break">).</span></p>
<p>Let’s define a simple variable and create an object <span class="No-Break">from it:</span></p>
<pre class="source-code">
void foo() {
    int x;
}</pre> <p>We have defined and, at the same time, instantiated an object from an integer type on the stack of the <strong class="source-inline">foo()</strong> function. Each object in C++ occupies a certain amount of memory at a specific memory region. Being on the stack, this object has an automatic storage duration. In our example, it means that the object will be created when the function starts and will be automatically destroyed when the function ends. When it is instantiated, it uses some amount of memory. This amount is a compile-time known value, and it can be acquired with the <strong class="source-inline">sizeof</strong> operator. Keep in mind that the size of some types can vary depending on the underlying hardware where your program runs, so if you need to be sure of the size, always use the operator to calculate it. Such an example is the fundamental <strong class="source-inline">int</strong> type. The standard says that the size of the <strong class="source-inline">int</strong> type can’t be less than 16 bits. For Linux Mint 21 with GCC 12.2, in which the examples of this chapter are run, the used underlying data model is LP64. This means that <strong class="source-inline">int</strong> is 4 bytes, and <strong class="source-inline">long</strong> and <strong class="source-inline">pointer</strong> are 8 bytes. In the next example, we demonstrate the size of the types <a id="_idIndexMarker347"/>mentioned earlier. In order to compile and run this code, you have to pass it in <span class="No-Break">a function:</span></p>
<pre class="source-code">
int i;
long l;
char* p;
std::cout &lt;&lt; "sizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; "; sizeof(i) = " &lt;&lt; sizeof(i) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(long) = " &lt;&lt; sizeof(long) &lt;&lt; "; sizeof(l) = " &lt;&lt; sizeof(l) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(char*) = " &lt;&lt; sizeof(char*) &lt;&lt; "; sizeof(p) = " &lt;&lt; sizeof(p) &lt;&lt; '\n';</pre> <p>Here is the output of <span class="No-Break">the example:</span></p>
<pre class="console">
sizeof(int) = 4; sizeof(i) = 4
sizeof(long) = 8; sizeof(l) = 8
sizeof(char*) = 8; sizeof(p) = 8</pre> <p>Nothing surprising so far. <strong class="source-inline">int</strong> is 4 bytes, but the pointer, no matter which type it points to, is <span class="No-Break">8 bytes.</span></p>
<p>Now, let’s define several structures and check their <span class="No-Break">memory footprint:</span></p>
<pre class="source-code">
struct Empty {};
struct Padding {
    long test;
    char m;
};
struct Virt {
    virtual char GetChar() const { return ch; }
    char ch;
};
void foo() {
    std::cout &lt;&lt; "Empty: " &lt;&lt; sizeof(Empty) &lt;&lt; '\n';
    std::cout &lt;&lt; "Padding: " &lt;&lt; sizeof(Padding) &lt;&lt; '\n';
    std::cout &lt;&lt; "Virt: " &lt;&lt; sizeof(Virt) &lt;&lt; '\n';
}</pre> <p>We have <a id="_idIndexMarker348"/>defined three structures – <strong class="source-inline">Empty</strong>, <strong class="source-inline">Padding</strong>, and <strong class="source-inline">Virt</strong>. The <strong class="source-inline">Empty</strong> structure, as <a id="_idIndexMarker349"/>the name suggests, is just an empty structure without any members in it. The <strong class="source-inline">Padding</strong> structure <a id="_idIndexMarker350"/>contains two members – <strong class="source-inline">long</strong> and <strong class="source-inline">char</strong>. As we saw from the previous example, in my testing environment, <strong class="source-inline">long</strong> is 8 bytes and <strong class="source-inline">char</strong> is 1 byte. Finally, the <strong class="source-inline">Virt</strong> structure<a id="_idIndexMarker351"/> has only one member of type <strong class="source-inline">char</strong> and one virtual method. Structure and class methods are not part of the object itself. They reside in the text segment rather than in the memory occupied by the object. Let’s execute the earlier code and see <span class="No-Break">the result:</span></p>
<pre class="console">
Empty: 1
Padding: 16
Virt: 16</pre> <p>We can see that all the objects occupy memory. Even the empty one! This is guaranteed by the standard because any object in the system has to have an address on which it resides. If it doesn’t occupy any memory, then no address can be assigned to it. Therefore, at least 1 byte is reserved for every object in <span class="No-Break">the program.</span></p>
<p>The <strong class="source-inline">Padding</strong> structure<a id="_idIndexMarker352"/> occupies more memory than the sum of its members’ memory. This is because the compilers are free to place the objects on an address, which requires less instruction arithmetic in order to be accessed faster. Therefore, they add padding bytes to the size of the type if this <span class="No-Break">is required.</span></p>
<p>Finally, the <strong class="source-inline">Virt</strong> structure<a id="_idIndexMarker353"/> contains only one member, which has type <strong class="source-inline">char</strong>. However, the structure occupies the same amount of memory as the <strong class="source-inline">Padding</strong> structure. This is a result of how the mechanics of the polymorphism are implemented in C++. The <a id="_idIndexMarker354"/>structure contains a virtual method that notifies the compiler that this user-defined type will be used polymorphically. As a result, the compiler injects in every instantiated object from this type a pointer to a table, with the addresses of all the virtual methods of <span class="No-Break">the class.</span></p>
<p>As a result of <a id="_idIndexMarker355"/>all these examples, we can conclude that each object occupies memory once it is instantiated, and the size of the memory can vary depending on the underlying system and the definition of <span class="No-Break">the type.</span></p>
<p>Next, we will get familiar with references in C++ and how they differ from objects in <span class="No-Break">the language.</span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>The reference</h2>
<p>In the<a id="_idIndexMarker356"/> previous section, we found out that we can declare a variable not only from an object but also from a reference. But what is a <em class="italic">reference</em> in terms of C++? According to the standard, a reference variable is an <em class="italic">alias</em> to an already-existing object or function. This means that we can use aliases to work with objects without having a difference in the syntax, rather than working with pointers to objects where the syntax is quite different. Let’s have a look in the following example. In order to compile and run it, you need to invoke it from <span class="No-Break">a function:</span></p>
<pre class="source-code">
char c;
char&amp; r_c{c};
char* p_c;
std::cout &lt;&lt; "sizeof(char) = " &lt;&lt; sizeof(char) &lt;&lt; "; sizeof(c) = " &lt;&lt; sizeof(c) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(char&amp;) = " &lt;&lt; sizeof(char&amp;) &lt;&lt; "; sizeof(r_c) = " &lt;&lt; sizeof(r_c) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(char*) = " &lt;&lt; sizeof(char*) &lt;&lt; "; sizeof(p_c) = " &lt;&lt; sizeof(p_c) &lt;&lt; '\n';</pre> <p>In this example, we declare three variables – a character, a reference to a character, and a pointer to a character. An important detail when working with reference variables is that at the point of its declaration, we must also initialize it with the object it will refer to. From this moment on, every operation invoked on the reference variable is actually invoked on the aliased object. But what indeed is an alias? Does it occupy memory just like the pointer does? Well, this is a gray area. The standard says that the references, unlike objects, do not always occupy storage. However, the compiler may allocate storage if required to implement the intended semantics. As a result of this, you <em class="italic">can’t use</em> the <strong class="source-inline">sizeof</strong> operator to get the size of <span class="No-Break">a reference:</span></p>
<pre class="console">
sizeof(char) = 1; sizeof(c) = 1
sizeof(char&amp;) = 1; sizeof(r_c) = 1
sizeof(char*) = 8; sizeof(p_c) = 8</pre> <p>You can see<a id="_idIndexMarker357"/> that the pointer size matches the expectation rather than the size of the reference type, where it matches the size of the type to which it has <span class="No-Break">an alias.</span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Understanding why initialization matters</h2>
<p><em class="italic">Initialization</em> is <a id="_idIndexMarker358"/>the process of setting the initial value of an object during its construction. In C++, there are several types of initializations depending mostly on <span class="No-Break">the following:</span></p>
<ul>
<li>The storage duration which the object <span class="No-Break">belongs to</span></li>
<li>The definition of <span class="No-Break">the object</span></li>
</ul>
<p>Knowing the different types of initializations and exactly when they happen will certainly make you more confident in writing <span class="No-Break">predictable code.</span></p>
<p>Let’s look at a few examples of various types of initializations that the C++ language supports. This will make it clearer when <span class="No-Break">initialization occurs.</span></p>
<h3>Default initialization</h3>
<p>In the next example, you<a id="_idIndexMarker359"/> can see a <em class="italic">default initialization</em>. In order to run and test this code, you <a id="_idIndexMarker360"/>have to invoke the <span class="No-Break"><strong class="source-inline">foo()</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
struct Point {
    double x;
    double y;
};
void foo() {
    long a; // {1}
    Point p1; // {2}
    std::cout &lt;&lt; "{1}: " &lt;&lt; a &lt;&lt; '\n';
    std::cout &lt;&lt; "{2}: " &lt;&lt; p1.x &lt;&lt; ", " &lt;&lt; p1.y &lt;&lt; '\n';
}</pre> <p>In marker <strong class="source-inline">{1}</strong>, we have declared a stack variable from type <strong class="source-inline">long</strong>. The type of initialization that will apply on an object depends mainly on <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">The storage duration it occupies</strong>: This means that different initialization policies may apply, depending on whether the object lives on the stack, in the global space, and <span class="No-Break">so on</span></li>
<li><strong class="bold">The type of declaration</strong>: This means that different initialization policies may apply, depending on how syntactically we have declared a variable – whether we have specified an <strong class="source-inline">init</strong> value, how exactly we have passed that <strong class="source-inline">init</strong> value, and <span class="No-Break">so on</span></li>
</ul>
<p>The <strong class="source-inline">long a;</strong> variable in our example has automatic storage duration, meaning it lives on the function’s stack. In its declaration, we haven’t specified any initialization value. For such objects, we will apply <em class="italic">default initialization</em>. When an object is default-initialized, the C++ compiler will generate code that calls the default constructor of the object’s type if one exists. However, since <strong class="source-inline">long</strong> is a fundamental C++ type that lacks a default constructor, the C++ runtime <em class="italic">does not perform any initialization on it</em>, resulting in an <em class="italic">unpredictable value</em>. This means that the value that will be used for initialization is not specified and could be literally any. This is also the case with the <strong class="source-inline">Point p1;</strong> object, which is a user-defined type, but we did not specify a default constructor for it. The <strong class="source-inline">Point</strong> structure is a <a id="_idIndexMarker361"/>so-called <strong class="bold">Plain Old Data</strong> (<strong class="bold">POD</strong>) type because it is fully <a id="_idIndexMarker362"/>compatible with the structures from the C language. For<a id="_idIndexMarker363"/> such types, the compiler will generate a <em class="italic">trivial default constructor</em> for you, which effectively does nothing <span class="No-Break">when called.</span></p>
<p>The output of the earlier example will look <span class="No-Break">like this:</span></p>
<pre class="console">
{1}: 1
{2}: 4.19164e-318, 4.3211e-320</pre> <p>In my environment, the <strong class="source-inline">a</strong> and <strong class="source-inline">p1</strong> objects both have indeterministic values. If you run the example of your own, you will possibly get <span class="No-Break">different values.</span></p>
<h3>Direct initialization</h3>
<p>In our next <a id="_idIndexMarker364"/>example, we will learn about C++ <em class="italic">direct initialization</em>. In<a id="_idIndexMarker365"/> order to run and test this code, you have to invoke the <strong class="source-inline">foo()</strong> method again. Bear in mind that the <strong class="source-inline">int c_warn{2.2};</strong><strong class="source-inline"> // {4.2}</strong> statement from this example should be commented out in order to <span class="No-Break">compile successfully:</span></p>
<pre class="source-code">
void foo() {
    int b(1);         // {3.1}
    int b_trunc(1.2); // {3.2}
    int c{2};         // {4.1}
    int c_warn{2.2};  // {4.2}
    std::cout &lt;&lt; "{3.1}: " &lt;&lt; b &lt;&lt; '\n';
    std::cout &lt;&lt; "{3.2}: " &lt;&lt; b_trunc &lt;&lt; '\n';
    std::cout &lt;&lt; "{4.1}: " &lt;&lt; c &lt;&lt; '\n';
}</pre> <p>In the first statement from the example, <strong class="source-inline">int b(1);</strong>, we have defined a variable of type <strong class="source-inline">int</strong>, and we have explicitly initialized it with a value of <strong class="source-inline">1</strong>. This is the <em class="italic">direct initialization</em> that we have known since the dawn of the C++ language. In order to invoke it, you have to specify the initialization value in parentheses, and that value has to match some of the <a id="_idIndexMarker366"/>conversion constructors of the object’s type. These conversion constructors can be compiler-generated. In our example, we use <strong class="source-inline">int</strong>, which is a fundamental C++ type and supports direct initialization with integer values. As a result, the <strong class="source-inline">b</strong> object will be initialized with a value of <strong class="source-inline">1</strong>, so nothing new <span class="No-Break">so far.</span></p>
<p>With the<a id="_idIndexMarker367"/> next statement, we declare an <strong class="source-inline">int b_trunc(1.2);</strong> variable, but this time, we initialize it with a floating-point value of <strong class="source-inline">1.2</strong>. This statement works fine and declares a variable of type <strong class="source-inline">int</strong> and initializes it with a value of… <strong class="source-inline">1</strong>! Yes, according to the C++ standard, which tries to be as compatible as possible with the C language for features that are present in both languages, the value is <em class="italic">truncated down</em> to its mantissa. In some cases, it could be useful to initialize an integer object with a floating-point value, but in others, this could be an inadvertent error. In such a case, we will expect the compiler to warn us that we are potentially doing something wrong. Therefore, C++11 introduced the<a id="_idIndexMarker368"/> so-called <span class="No-Break"><em class="italic">uniform initialization</em></span><span class="No-Break">.</span></p>
<p>In the next statement from the example, <strong class="source-inline">int c{2};</strong>, we again declare a variable of type <strong class="source-inline">int</strong>, but we initialize it using curly braces rather than parentheses. This notifies the compiler to<a id="_idIndexMarker369"/> invoke <em class="italic">direct list initialization</em>, which is a kind of uniform initialization. It is a named list initialization because it can be used as an initialization list of values of different types to initialize <span class="No-Break">complex objects.</span></p>
<p>One reason to prefer using uniform initialization wherever this is possible is visible in the next statement from <span class="No-Break">the example:</span></p>
<pre class="source-code">
int c_warn{2.2};  // {4.2}</pre> <p>As we just saw, using direct initialization to initialize an object of a specific type with a value of a wider type leads to a silently truncated initialized value. In some situations, this can lead to bugs. One way to avoid this potential side effect is to use uniform initialization instead. In our example, we defined a variable of type <strong class="source-inline">int</strong> and again initialized it with a floating-point value. However, this time, the compiler will not silently initialize <strong class="source-inline">c_warn</strong> with a value of <strong class="source-inline">2</strong>, but it will generate an error similar <span class="No-Break">to this:</span></p>
<pre class="console">
error: narrowing conversion of '2.2000000000000002e+0' from 'double' to 'int' [-Wnarrowing]</pre> <p>The error is produced because we try to perform a narrowing conversion in the initialization of an <strong class="source-inline">int</strong> variable with a <strong class="source-inline">double</strong> value. Therefore, it is safer to use uniform initialization over a direct one because it protects you from narrowing conversions <span class="No-Break">during initialization.</span></p>
<h3>Zero and aggregate initialization</h3>
<p>Let’s <a id="_idIndexMarker370"/>see another initialization example. We will initialize <a id="_idIndexMarker371"/>an object that holds the personal data for <strong class="source-inline">Person</strong> and a few <span class="No-Break">integer objects:</span></p>
<pre class="source-code">
struct Person {
    std::string name;
    int age;
};
void init() {
    int zero1{}; // {1}
    int zero2 = int(); // {2}
    int zero3 = int{}; // {3}
    Person nick{"Nick L.", 42}; // {4}
    Person john{.name{"John M."}, .age{24}}; // {5}
}</pre> <p>As we already explained, the objects with automatic storage duration and without explicit initialization get random initialization values. In this example, from markers <strong class="source-inline">{1}</strong> to <strong class="source-inline">{3}</strong>, we have initialized the objects using <em class="italic">zero initialization</em>, which effectively sets their values to zero. Zero initialization happens for non-class, built-in types and for the members of user-defined types that have no constructors. Preferably use curly brace notation and uniform initialization, such as marker <strong class="source-inline">{1}</strong>, when you need to zero-initialize your objects, rather than copying zero initialization, such as markers <strong class="source-inline">{2}</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">{3}</strong></span><span class="No-Break">.</span></p>
<p>Statement <strong class="source-inline">{4}</strong> demonstrates another method of initialization called <em class="italic">aggregate initialization</em>. It allows <a id="_idIndexMarker372"/>us to initialize an aggregate object using uniform initialization notation. An aggregate is considered any object that is an array or a class type that has no user-declared <a id="_idIndexMarker373"/>or inherited constructors; all of its non-static members are publicly visible, and it has no virtual base classes and no virtual methods. Statement <strong class="source-inline">{5}</strong> performs another way of <em class="italic">aggregate initialization</em> but using <em class="italic">designators</em>. The designators <a id="_idIndexMarker374"/>explicitly specify the members being initialized, and the order of the designators in the initialization should follow the order of the declaration of the members in <span class="No-Break">the structure.</span></p>
<h3>Copy initialization</h3>
<p>Copy initialization<a id="_idIndexMarker375"/> occurs when an object of a specific type<a id="_idIndexMarker376"/> is initialized by another object of the same type. Let’s look at the following examples of syntax that triggers copy initialization. In order to run and test this code, you have to invoke the <span class="No-Break"><strong class="source-inline">foo()</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
void foo() {
    int c{2};
    int d(c);     // {1}
    int e{d};     // {2}
    int f = e;    // {3}
    int f1 = {d}; // {4}
}</pre> <p>Markers <strong class="source-inline">{1}</strong> and <strong class="source-inline">{3}</strong> from this example demonstrate the well-known copy initialization present in the language even before C++11. An object of type <strong class="source-inline">int</strong> is initialized by another object of the same type. As we already saw, this kind of initialization doesn’t give any protection against types narrowing. This means that our <strong class="source-inline">int</strong> objects can be silently initialized by <strong class="source-inline">double</strong> objects, which will lead to narrowing. Fortunately, this is not the case with markers <strong class="source-inline">{2}</strong> and <strong class="source-inline">{4}</strong>. They use uniform copy initialization, which forces the compiler to verify that the initialization object is from the same type as the object <span class="No-Break">being initialized.</span></p>
<p>Now, let’s look at several scenarios of copy initialization for user-defined types. We have defined two classes – <strong class="source-inline">Person</strong> and <strong class="source-inline">Employee</strong>. The <strong class="source-inline">Person</strong> class has one user-defined constructor that receives a reference to the <strong class="source-inline">std::string</strong> parameter, used to initialize the name of the person. The constructor is marked as <strong class="source-inline">explicit</strong>. This means that it will be used only as a non-converting constructor. The <em class="italic">converting constructor</em> is a <a id="_idIndexMarker377"/>constructor that<a id="_idIndexMarker378"/> makes an implicit conversion from its argument types to its <span class="No-Break">class types.</span></p>
<p>The <a id="_idIndexMarker379"/>other class, <strong class="source-inline">Employee</strong>, has two constructors, one of which gets a reference to a <strong class="source-inline">Person</strong> object, while the other is a copy constructor. The copy constructor is also marked <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">explicit</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
class Person {
public:
    explicit Person(const std::string&amp;  the_name) : name{
      the_name} {}
private:
    std::string name;
};
class Employee {
public:
    Employee(const Person&amp; p) : p{p} {}
    explicit Employee(const Employee&amp; e) : p{e.p} {}
private:
    Person p;
};</pre> <p>Let’s use these two classes in different initialization scenarios. In order to run and test this code, you have to rework and invoke the <strong class="source-inline">foo()</strong> <span class="No-Break">method again:</span></p>
<pre class="source-code">
void foo() {
    Person john{"John M."};
    Employee staff1{john};          // {1}
    // Employee staff2{std::string{"George"}};   // {2}
    Employee staff3{staff1};        // {3}
    // Employee staff4 = staff1;    // {4}
    // Employee staff5 = {staff1};  // {5}
}</pre> <p>We first <a id="_idIndexMarker380"/>defined a <strong class="source-inline">Person</strong> object named <strong class="source-inline">john</strong>, and in marker <strong class="source-inline">{1}</strong>, we initialize an <strong class="source-inline">Employee</strong> object using <strong class="source-inline">john</strong>. This is actually valid because the <strong class="source-inline">Employee</strong> class has a constructor that accepts the <strong class="source-inline">Person</strong> objects. The next statement, marker <strong class="source-inline">{2}</strong>, which is commented out, gets as an argument an object of type <strong class="source-inline">std::string</strong>, but the compiler will generate an error. This is because the <strong class="source-inline">Employee</strong> class doesn’t have a constructor that gets a string object. It has a converting constructor from the <strong class="source-inline">Person</strong> object. However, the <strong class="source-inline">Person</strong> constructor is marked as <strong class="source-inline">explicit</strong>, and it is not allowed to be used in implicit type conversions, so the compilation <span class="No-Break">will fail.</span></p>
<p>The <a id="_idIndexMarker381"/>next statement, marker <strong class="source-inline">{3}</strong>, will compile successfully because <strong class="source-inline">Employee</strong> is copy-constructed and initialized by another <strong class="source-inline">Employee</strong> object without any implicit <span class="No-Break">type conversions.</span></p>
<p>The final two statements from the example – markers <strong class="source-inline">{4}</strong> and <strong class="source-inline">{5}</strong> – are also commented out to avoid compilation errors. The reason for the compiler error is that the copy constructor of the <strong class="source-inline">Employee</strong> class is also marked as <strong class="source-inline">explicit</strong>. This means that copy construction and initialization using equal<strong class="source-inline"> "="</strong> sign is not allowed for explicit copy constructors. Only direct copy initialization <span class="No-Break">is permitted.</span></p>
<p>Now that we are familiar with what the scope, storage duration, and lifetime of the object are, we can have a look at some slightly different kinds of objects, which behave more like functions rather than objects – functors <span class="No-Break">and lambdas.</span></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/>Functors and lambdas</h1>
<p>This section will delve into functional objects – their definition, usefulness, and proper usage. We’ll begin by examining an example of a functional object used with an STL algorithm and discuss potential issues, such as the creation of temporary objects and dangling references. After that, we’ll move on to exploring lambda expressions – what they are, how to use them, and specific situations where they can be <span class="No-Break">especially advantageous.</span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>Exploring functional objects</h2>
<p>In the <em class="italic">Scope, storage duration, and lifetimes</em> section, we looked at various types of object <a id="_idIndexMarker382"/>initialization in C++, but our focus was mostly on objects that represent data, such as integers or coordinates. In this section, we’ll shift our attention to another type of object – those designed to <a id="_idIndexMarker383"/>be <em class="italic">callable</em>, such as a function, but with a crucial difference: they can maintain a state between different function calls. These objects are <a id="_idIndexMarker384"/>known as <em class="italic">functional objects</em> or <em class="italic">functors</em>. We’ll start by defining a functor and then use it to compute the mean value of a vector containing <span class="No-Break">floating-point numbers:</span></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;<strong class="bold">source_location</strong>&gt;
struct Mean {
    Mean() = default;
    void operator()(const double&amp; val) {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " of " &lt;&lt; this &lt;&lt; '\n';
        sum += val;
        ++count;
    }
private:
    double sum{};
    int count{};
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const
      Mean&amp; a);
};
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Mean&amp; a) {
    double mean{std::nan("")};
    if (a.count &gt; 0) {
        mean = a.sum / a.count;
    }
    os &lt;&lt; mean;
    return os;
}
int main() {
    Mean calc_mean;
    std::vector v1{1.0, 2.5, 4.0, 5.5};
    std::for_each(v1.begin(), v1.end(), calc_mean);
    std::cout &lt;&lt; "The mean value is: " &lt;&lt; calc_mean &lt;&lt;
      '\n';
    return 0;
}</pre> <p>The functor is an object like any other. It has a type, storage duration, and scope. In order to define a functor, you have to either define a struct or class of a user-defined type, and this type must have<a id="_idIndexMarker385"/> implemented a <em class="italic">function </em><span class="No-Break"><em class="italic">call operator</em></span><span class="No-Break">:</span></p>
<pre class="source-code">
operator()</pre> <p>In our <a id="_idIndexMarker386"/>example, we defined <strong class="source-inline">struct Mean</strong> with two members in it, which are zero-initialized. The first one, <strong class="source-inline">sum</strong>, will be used to accumulate the input data that this object receives during the function call operator invocations, preserving it between different invocations. And the other member, <strong class="source-inline">count</strong>, will be used to count the number of invocations of the function <span class="No-Break">call operator.</span></p>
<p>The definition of the function call operator gets one parameter of a <strong class="source-inline">double</strong> type, and then the method prints its name and adds the input value to the already accumulated value from the previous invocations. Finally, it increments the <span class="No-Break">invocation counter.</span></p>
<p>The function call operator doesn’t return any type and is not defined as a <strong class="source-inline">const</strong> method because it mutates the state of the <strong class="source-inline">Mean</strong> object. We also overloaded the stream extraction operator, which will be used to report the calculated mean value to the standard output. If there is no accumulated value, then <strong class="source-inline">nan</strong> (“not a number”) will <span class="No-Break">be printed:</span></p>
<pre class="source-code">
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Mean&amp; a)</pre> <p>Please keep in mind that the operator is overloaded outside of the <strong class="source-inline">Mean</strong> structure, and it is declared as a <em class="italic">friend</em> method to it. This is because it needs to get <strong class="source-inline">std::ostream</strong> as a left-hand argument and the <strong class="source-inline">Mean</strong> parameter as the right argument, and therefore, it can’t be implemented as a member method. It’s defined as <em class="italic">friend</em> because it has to have access to the <em class="italic">private</em> members of the <span class="No-Break"><strong class="source-inline">Mean</strong></span><span class="No-Break"> structure.</span></p>
<p>In order to calculate the mean value, our algorithm iterates over all values in the vector using the <strong class="source-inline">std::for_each</strong> STL algorithm. <strong class="source-inline">std::for_each</strong> expects to receive a container on which to operate and function, which will be invoked with each of the elements from the container; therefore, this function must accept one parameter as an <span class="No-Break">input argument.</span></p>
<p>In the main method, we define an object of type <strong class="source-inline">Mean calc_mean;</strong>, which will be used to calculate the mean value of <strong class="source-inline">std::vector v1{1.0, 2.5, 4.0, 5.5};</strong>. As you can see, we don’t need to explicitly specify the template argument type of the <strong class="source-inline">std::vector</strong> class because it is automatically deduced by the type of the initializer list values it is initialized with. In our case, these are <span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break"> values.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Please note that since C++17, the automatic class template argument deduction is already supported, based on the type of <span class="No-Break">its initializer.</span></p>
<p>We expect <a id="_idIndexMarker387"/>that the program will invoke the function operator of the <strong class="source-inline">Mean</strong> object for each element in the vector. The function operator will accumulate all values, and when the result is printed out, it will be <strong class="source-inline">3.25</strong>. Let’s see the output of <span class="No-Break">the program:</span></p>
<pre class="console">
void Mean::operator()(const double&amp;) of 0x7ffc571a64e0
void Mean::operator()(const double&amp;) of 0x7ffc571a64e0
void Mean::operator()(const double&amp;) of 0x7ffc571a64e0
void Mean::operator()(const double&amp;) of 0x7ffc571a64e0
The mean value is: nan</pre> <p>As we expected, the operator function call is invoked for each of the elements from the vector, but surprisingly, there is no calculated mean value. In order to get a better understanding of what went wrong with the calculation, we need to see what has happened with the <strong class="source-inline">calc_mean</strong> object, which has been used by the <span class="No-Break"><strong class="source-inline">std::for_each</strong></span><span class="No-Break"> algorithm.</span></p>
<h3>Beware of temporaries</h3>
<p>For the sake <a id="_idIndexMarker388"/>of investigation, in the <strong class="source-inline">Mean</strong> structure, we need to define the <strong class="source-inline">copy</strong> and <strong class="source-inline">move</strong> constructors, the <strong class="source-inline">move</strong> operator, and a destructor, whose only goal will be to print whether they are invoked and the address of the object that they belong to. We also need to add markers for when the calculation starts and when it finishes. Let’s see the <span class="No-Break">reworked example:</span></p>
<pre class="source-code">
struct Mean {
    Mean() noexcept {
        std::cout &lt;&lt;  std::source_location::current()
         .function_name() &lt;&lt; " of " &lt;&lt; this &lt;&lt; '\n';
    }
    Mean(Mean&amp;&amp; a) noexcept : sum{a.sum}, count{a.count} {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " from: " &lt;&lt; &amp;a &lt;&lt; " to: " &lt;&lt;
             this &lt;&lt; '\n';
        a.sum = 0;
        a.count = -1;
    }
    Mean&amp; operator=(Mean&amp;&amp; a) noexcept {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " from: " &lt;&lt; &amp;a &lt;&lt; " to: " &lt;&lt;
            this &lt;&lt; '\n';
        sum = a.sum;
        count = a.count;
        return *this;
    }
    Mean(const Mean&amp; a) noexcept : sum{a.sum},
      count{a.count} {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " from: " &lt;&lt; &amp;a &lt;&lt; " to: " &lt;&lt;
            this &lt;&lt; '\n';
    }
    ~Mean() noexcept {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " of " &lt;&lt; this &lt;&lt; '\n';
    }
    void operator()(const double&amp; val) {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " of " &lt;&lt; this &lt;&lt; '\n';
        sum += val;
        ++count;
    }
private:
    double sum{};
    int count{};
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const
      Mean&amp; a);
};</pre> <p>We also <a id="_idIndexMarker389"/>need to slightly change the <strong class="source-inline">main()</strong> <span class="No-Break">method implementation:</span></p>
<pre class="source-code">
int main() {
    Mean calc_mean;
    std::vector v1{1.0, 2.5, 4.0, 5.5};
    std::cout &lt;&lt; "Start calculation\n";
    std::for_each(v1.begin(), v1.end(), calc_mean);
    std::cout &lt;&lt; "Finish calculation\n";
    std::cout &lt;&lt; "The mean value is: " &lt;&lt; calc_mean &lt;&lt;
      '\n';
    return 0;
}</pre> <p>When we re-execute the already reworked program, we get the <span class="No-Break">following output:</span></p>
<pre class="console">
Mean::Mean() of 0x7ffef7956c50
Start calculation
Mean::Mean(const Mean&amp;) from: 0x7ffef7956c50 to: 0x7ffef7956ca0
void Mean::operator()(const double&amp;) of 0x7ffef7956ca0
void Mean::operator()(const double&amp;) of 0x7ffef7956ca0
void Mean::operator()(const double&amp;) of 0x7ffef7956ca0
void Mean::operator()(const double&amp;) of 0x7ffef7956ca0
Mean::Mean(Mean&amp;&amp;) from: 0x7ffef7956ca0 to: 0x7ffef7956c90
Mean::~Mean() of 0x7ffef7956c90
Mean::~Mean() of 0x7ffef7956ca0
Finish calculation
The mean value is: nan
Mean::~Mean() of 0x7ffef7956c50</pre> <p>As we<a id="_idIndexMarker390"/> expected, the program starts with the construction of the object with the address <strong class="source-inline">0x7ffef7956c50</strong>, then the calculation is started, and we can see that a copy constructor is invoked. This is because <strong class="source-inline">std::for_each</strong>, like many other algorithms in the standard library, is a template method that gets its functor by value. Here is what the standard says about <span class="No-Break">its prototype:</span></p>
<pre class="source-code">
template&lt; class InputIt, class UnaryFunction &gt;
constexpr UnaryFunction for_each( InputIt first, InputIt
  last, UnaryFunction f );</pre> <p>This means that no matter what calculation it does, all the accumulated values will be stored in the copied object rather than the original. Actually, the object created by this copy constructor is just a <em class="italic">temporary object</em>. Temporary objects<a id="_idIndexMarker391"/> are unnamed objects that are automatically created and destroyed by the compiler. They often lead to side effects that are not trivially recognizable by the developers. Temporary objects are most <a id="_idIndexMarker392"/>frequently created as a result of implicit conversions of arguments and functions’ returned values. They frequently have a limited lifetime, till the end of the statement they are created by, if they are not bound to some named reference. So, be careful with them because they can impact the performance of your program, but more importantly, they can lead to unexpected behavior, as in <span class="No-Break">our example.</span></p>
<p>From the<a id="_idIndexMarker393"/> preceding code, we can see that all the accumulations are done in the newly created temporary object. Once the <strong class="source-inline">std::for_each</strong> method finishes its execution, a move constructor of a new temporary object is invoked. This happens because, according to the definition of <strong class="source-inline">std::for_each</strong>, the passed-by value input functor is returned back as a result of the operation. So, if we need to get the accumulated value back to the original object, we need to assign the return value of <strong class="source-inline">std::for_each</strong> back to the original object – <span class="No-Break"><strong class="source-inline">calc_mean</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
calc_mean = std::for_each(v1.begin(), v1.end(), calc_mean);</pre> <p>Finally, the result is what we expected but at the price of creating several <span class="No-Break">temporary objects:</span></p>
<pre class="console">
Finish calculation
The mean value is: 3.25</pre> <p>In our example, this is not a problem, but for really complex objects where temporary object creation involves expensive and potentially slow operations, such as resource acquisition, this could <span class="No-Break">be problematic.</span></p>
<p>Next, let’s have a look at how we can improve our example by avoiding unnecessary <span class="No-Break">copy operations.</span></p>
<h3>Passing by reference</h3>
<p>One <a id="_idIndexMarker394"/>way to improve the earlier example is to pass the functor not by value but by reference. This will avoid the creation of unnecessary <span class="No-Break">temporary objects:</span></p>
<pre class="source-code">
using VecCIter = std::vector&lt;double&gt;::const_iterator;
std::for_each&lt;VecCIter, Mean&amp;&gt;(v1.begin(), v1.end(),
  calc_mean);</pre> <p>In order to pass by reference the <strong class="source-inline">Mean</strong> object, you have to explicitly state your intention to the compiler by explicitly specifying that the <strong class="source-inline">Mean</strong> template parameter is a reference. Otherwise, the automatic template argument deduction will deduce that you are passing by <a id="_idIndexMarker395"/>value. As a result, this forces you to avoid using automatic class template argument deduction and makes your code harder to read. Fortunately, the standard provides a solution <span class="No-Break">for this:</span></p>
<pre class="source-code">
std::for_each(v1.begin(), v1.end(), std::ref(calc_mean));</pre> <p>We need to use the factory method, <strong class="source-inline">std::ref</strong>, for the creation of the <strong class="source-inline">std::reference_wrapper</strong> objects. <strong class="source-inline">std::reference_wrapper</strong> is a class template that wraps a reference inside an assignable, copyable object. It’s commonly used to store references within standard containers that can’t typically hold them. The usage of <strong class="source-inline">std::ref</strong>, in our example, eliminates the need to explicitly specify that the functor template parameter of <strong class="source-inline">std::for_each</strong> is a reference type rather than a value. Here is the result of <span class="No-Break">our refactoring:</span></p>
<pre class="console">
Mean::Mean() of 0x7ffe7415a180
Start calculation
void Mean::operator()(const double&amp;) of 0x7ffe7415a180
void Mean::operator()(const double&amp;) of 0x7ffe7415a180
void Mean::operator()(const double&amp;) of 0x7ffe7415a180
void Mean::operator()(const double&amp;) of 0x7ffe7415a180
Finish calculation
The mean value is: 3.25
Mean::~Mean() of 0x7ffe7415a180</pre> <p>As you can see, there is no additional creation and destruction of temporary objects because the algorithm works directly with the reference of the <span class="No-Break"><strong class="source-inline">calc_mean</strong></span><span class="No-Break"> object.</span></p>
<p class="callout-heading">Beware of dangling references</p>
<p class="callout">Always make sure that the references you pass across the program will refer to live objects until they are <span class="No-Break">in use!</span></p>
<p>Functors are just one option that we can use in our example. There is also another approach here that <a id="_idIndexMarker396"/>can make our code even more expressive. These are lambda expressions. Let’s have a look <span class="No-Break">at them.</span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Lambda expressions</h2>
<p>The <em class="italic">lambda expression</em>, or just <em class="italic">lambda</em> in C++, is a<a id="_idIndexMarker397"/> concise way to define<a id="_idIndexMarker398"/> an <em class="italic">anonymous function</em> or <em class="italic">functor</em> inline, which can be used immediately or assigned to a variable for later use. It allows programmers to write small, throwaway functions on the fly without having to define a named function or a <strong class="source-inline">functor</strong> class. Lambdas are commonly used with algorithms and containers from the standard library, allowing for more concise and <span class="No-Break">expressive code.</span></p>
<p>Let’s define a simple lambda that just prints to the <span class="No-Break">standard output:</span></p>
<pre class="source-code">
auto min_lambda = [](const auto&amp; name) -&gt; void {
    std::cout &lt;&lt; name &lt;&lt; " lambda.\n";
};
min_lambda("Simple");</pre> <p>Each lambda expression is an <em class="italic">object</em>, which means that it has a lifetime and occupies memory. Every defined lambda is a de facto functor class definition, and as such, it has a <em class="italic">unique type</em>. There<a id="_idIndexMarker399"/> can’t be two or more lambdas with the same <em class="italic">type</em> in a program. This <em class="italic">type</em> name is platform-specific, and therefore, if you need to assign a lambda to a variable, you have to define this variable with the <span class="No-Break"><strong class="source-inline">auto</strong></span><span class="No-Break"> specifier.</span></p>
<p>The syntax of a lambda consists of the <strong class="source-inline">[ ]</strong> symbol, which is followed by an optional capture list, an optional parameter list, an optional return type, an optional <em class="italic">mutable</em> specifier, and <a id="_idIndexMarker400"/>a function body. Lambdas can capture variables from the outer scope by value or by reference, and they can also have a return type deduction or an explicit return type, which we will <span class="No-Break">see next.</span></p>
<h3>Capturing the outer scope</h3>
<p>Lambdas can gain <a id="_idIndexMarker401"/>access to other objects in the scope where they’re defined by <a id="_idIndexMarker402"/>utilizing a <em class="italic">capture list</em>. If the capture list is empty, then no objects are captured. Global objects are always visible in lambdas without needing to be explicitly captured. When defining the capture list, you can choose to capture objects by <em class="italic">value</em> or by <em class="italic">reference</em>, or even a mixture <span class="No-Break">of both.</span></p>
<p>When capturing variables by value in a lambda expression, the variables are <em class="italic">copied</em> into the lambda object at the <em class="italic">moment of its definition</em>. Any modifications made to the original variables after the lambda is defined won’t affect the copies stored inside it. All captured objects are, by default, <em class="italic">read-only</em>, and to modify them, you must explicitly specify the lambda <span class="No-Break">as </span><span class="No-Break"><em class="italic">mutable</em></span><span class="No-Break">.</span></p>
<p>Another option to capture variables is by reference, which creates a reference to every captured object inside the lambda. This allows the lambda to communicate with the outer scope, but it’s crucial to ensure that the lifetime of all captured objects by reference exceeds the lifetime of the lambda to prevent <span class="No-Break"><em class="italic">dangling references</em></span><span class="No-Break">.</span></p>
<p>Now, let’s refactor the example from the previous section to calculate the mean value of a vector with floating-point numbers, using a lambda instead of a functor. In order to run the following code, you have to invoke the <strong class="source-inline">foo()</strong> method from <span class="No-Break">your program:</span></p>
<pre class="source-code">
void foo() {
    double mean{};
    std::vector v1{1.0, 2.5, 4.0, 5.5};
    std::string_view text{"calculating ..."};
    std::for_each(v1.begin(), v1.end(),
                  <strong class="bold">[&amp;mean, sum{0.0}, count{0}, text](const</strong>
<strong class="bold">                     double&amp; val) mutable</strong> {
        std::cout &lt;&lt; text &lt;&lt; '\n';
        sum += val;
        ++count;
        mean = sum / count;
    });
    std::cout &lt;&lt; mean &lt;&lt; '\n';
}</pre> <p>One of the<a id="_idIndexMarker403"/> key advantages of lambdas compared to named functions and functors is that they can be inlined in the place of their invocation. In our example, we have defined the lambda directly inside the <strong class="source-inline">std::for_each</strong> invocation statement. This approach explicitly highlights that this lambda has no other reason to exist except to serve the <span class="No-Break">preceding case.</span></p>
<p>Let’s get a closer look at the <span class="No-Break">lambda prototype:</span></p>
<pre class="source-code">
[&amp;mean, sum{0.0}, count{0}, text](const double&amp; val)
  mutable { … }</pre> <p>In the capture list, we have captured four objects. The first one, <strong class="source-inline">mean</strong>, is captured by reference. Putting <strong class="source-inline">&amp;</strong> before the variable name specifies that it is captured by reference. We will use <strong class="source-inline">mean</strong> to report outside of the lambda the calculated mean value. The next two variables in the capture list, <strong class="source-inline">sum</strong> and <strong class="source-inline">count</strong>, are captured by value. If <strong class="source-inline">&amp;</strong> doesn’t precede the name of the variable, it means that it is captured by value. The only exception to this rule is when capturing the <strong class="source-inline">this</strong> pointer of a class, which will be captured by value, but the access to the class members will be by reference. As you can see, the captures, <strong class="source-inline">sum</strong> and <strong class="source-inline">count</strong>, are not defined in the outer scope; they are defined only in the scope of the lambda for the purpose of our example. Just like the functor example, they are used to store the accumulated sum and the count of the iterations. This is a convenient way to explicitly add state into your lambda for use in further calculations. Of course, you need to initialize them by passing initializers to the captures for two reasons – in order to allow the compiler to deduce their type and to get the expected result in the calculations. The implementation logic will update the values of <strong class="source-inline">sum</strong> and <strong class="source-inline">count</strong> during its execution, but as stated previously, these captures are read-only in the context of the lambda. Therefore, we cannot just mutate them without explicitly stating our intention during the lambda definition. This is done by appending the <strong class="source-inline">mutable</strong> keyword after the argument list and before the body of <span class="No-Break">the lambda.</span></p>
<p>The last captured object is <strong class="source-inline">text</strong>. It is also captured by value, but this time, it is captured from the outer scope in the <span class="No-Break"><strong class="source-inline">foo()</strong></span><span class="No-Break"> method.</span></p>
<p>Once the program is executed, we have the <span class="No-Break">following output:</span></p>
<pre class="console">
calculating ...
calculating ...
calculating ...
calculating ...
3.25</pre> <p>As we expected, our <a id="_idIndexMarker404"/>lambda has been called four times, and the calculated mean value is exactly the same as the value calculated by the functor in the <span class="No-Break">previous section.</span></p>
<p>There are many ways to capture objects in the capture list. The following list shows some rules <span class="No-Break">that apply:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<img alt="Figure 4.1 – Ways to capture objects in a capture list" height="506" src="image/Figure_4.1_B20833.jpg" width="1330"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Ways to capture objects in a capture list</p>
<p>Now that we know how to properly capture the outer scope, let’s get familiar with a lambda’s <span class="No-Break">parameter list.</span></p>
<h3>Parameter list</h3>
<p>The <a id="_idIndexMarker405"/>parameter list of a lambda is just like any other function parameter list. This is because the lambda’s parameter list is effectively the parameter list of the function call operator in a functor class. You can define your lambda to accept an arbitrary list of parameters, depending on the use case <span class="No-Break">you have.</span></p>
<p>Using the <strong class="source-inline">auto</strong> specifier as a parameter type of one or more of the parameters in the lambda parameter lists makes it a <em class="italic">generic lambda</em>. A<a id="_idIndexMarker406"/> generic lambda acts as a template function <span class="No-Break">call operator:</span></p>
<pre class="source-code">
auto sum = [](auto a, auto b) {
    return a*b;
}</pre> <p>This effectively<a id="_idIndexMarker407"/> acts <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class platform_specific_name {
public:
    template&lt;typename T1, typename T2&gt;
    auto operator()(T1 a, T2 b) const {
        return a*b;
    }
};</pre> <p>With the C++20 release, if you wish you can explicitly specify the template parameters that your lambda can get. The preceding example could be rewritten <span class="No-Break">as follows:</span></p>
<pre class="source-code">
auto sum = []&lt;typename T1, typename T2&gt;(T1 a, T2 b) {
    return a*b;
}</pre> <p>Another important characteristic of lambdas is the return type. Let’s see <span class="No-Break">its specifics.</span></p>
<h3>The return type</h3>
<p>Specifying the<a id="_idIndexMarker408"/> return type of the lambda is <em class="italic">optional</em>. If you<a id="_idIndexMarker409"/> don’t explicitly specify it, the compiler will try to deduce it for you. If it doesn’t succeed, then a compiler error in type deduction will be generated. Then, you have to either change your code to allow automatic return type deduction or explicitly specify the return type of <span class="No-Break">the lambda.</span></p>
<p>Here is a compiler error in return <span class="No-Break">type deduction:</span></p>
<pre class="source-code">
auto div = [](double x, double y) {
    if (y &lt; 0) { return 0; }
    return x / y;
};</pre> <p>This code will not compile because the compiler will fail to automatically deduce the return type <a id="_idIndexMarker410"/>of the lambda. It’s implementation logic has two execution branches. The first one returns an <strong class="source-inline">integer</strong> literal, <strong class="source-inline">0</strong>, but the other one returns<a id="_idIndexMarker411"/> the result of a division, the quotient, which is a <span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break"> number.</span></p>
<p>In order to fix this, we need to explicitly specify that the return type of the lambda <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break">.</span></p>
<p>Here is an explicitly specified <span class="No-Break">return type:</span></p>
<pre class="source-code">
auto div = [](double x, double y) -&gt; double {
    if (y &lt; 0) { return 0; }
    return x / y;
};</pre> <p>Now, for the compiler, it is clear that the return result is always converted <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>Summary</h1>
<p>In this chapter, we explored various aspects of objects in C++, including storage duration, scope, and lifetimes. We distinguished between objects and references and discussed different ways of initializing objects and when these initializations occur. Additionally, we delved into the world of functors, gaining an understanding of what they are and how to use them effectively. Building on that knowledge, we also learned about lambda expressions and their advantages over functors. We covered how to properly use both lambdas and functors with STL algorithms. Armed with this knowledge of object specifics, we can now move on to discussing error handling in C++ in the <span class="No-Break">next chapter.</span></p>
</div>
</div></body></html>