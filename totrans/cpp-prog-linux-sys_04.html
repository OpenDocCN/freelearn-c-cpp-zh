<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-62"><a id="_idTextAnchor060"/>4</h1>
<h1 id="_idParaDest-63"><a id="_idTextAnchor061"/> Diving Deep into the C++ Object</h1>
<p>In this chapter, we will pay special attention to the object in the C++ language. But what makes the object in C++ so special that we should pay so much attention to it? Well, considering the fact that C++ supports the object-oriented programming paradigm, it is assumed that the object itself takes a central position in the structure of the language. You will see that there are many specifics around objects in C++.</p>
<p>In this chapter, we will delve into the fundamental aspects of objects in C++. We will start by examining how the C++ standard specifies the definition of an object. Moving on from there, we will take a closer look at the different types of object initializations, such as aggregate, direct, and copy initialization, and their use cases.</p>
<p>We will also explore the concept of storage duration for objects. Additionally, we will take a look at the scope and lifetime of objects in C++. We will also see what references are and how they correlate to objects.</p>
<p>As we progress further, we will learn about temporary objects and why it is important to handle them with care, and the concept of function objects and lambdas in C++. We will explore an example of how to use lambdas with a <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) algorithm, which<a id="_idIndexMarker323"/> will help us gain a comprehensive understanding of how to leverage these powerful features to create more efficient and optimized code.</p>
<p>By the end of this chapter, you will have a clear understanding of the fundamental concepts of objects in C++, and you will be familiar with some techniques you can use to create more robust and efficient code.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The C++ object model</li>
<li>Scope, storage duration, and lifetimes</li>
<li>Functors and lambdas in C++</li>
</ul>
<p>Alright, it’s time to begin!</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor062"/>Technical requirements</h1>
<p>All examples in this chapter have been tested in an environment with the following configuration:</p>
<ul>
<li>Linux Mint 21 Cinnamon edition</li>
<li>GCC 12.2 with compiler flags – <code>-</code><code>std=c++20</code></li>
<li>A stable internet connection</li>
<li>Please make sure your environment uses these versions or later. For all the examples you can alternatively use <a href="https://godbolt.org/">https://godbolt.org/</a>.</li>
<li>All code examples in this chapter are available for download from <a href="https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%204">https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%204</a>.</li>
</ul>
<h1 id="_idParaDest-65"><a id="_idTextAnchor063"/>Understanding the C++ object model</h1>
<p>C++ programs<a id="_idIndexMarker324"/> involve the creation, manipulation, and destruction of various entities known as <em class="italic">objects</em>. An <a id="_idIndexMarker325"/>object in C++ possesses several attributes such as <em class="italic">type</em>, <em class="italic">size</em>, <em class="italic">storage duration</em>, <em class="italic">lifetime</em>, <em class="italic">alignment requirements</em>, and <em class="italic">value</em>. The <em class="italic">name</em> of the object is <em class="italic">optional</em>.</p>
<p>The lifetime of the named object is bounded by its storage duration, and if the object doesn’t have a name, it is considered <a id="_idIndexMarker326"/>a <em class="italic">temporary</em> object. However, not all entities in C++ are considered objects. For example, the reference is one such non-object.</p>
<p>First, let’s take a brief look at the terminology because it is important to be aware of it, as it will help us in our daily work with the C++ language.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor064"/>Declaration versus definition</h2>
<p>In C++, the terms <em class="italic">declaration</em> and <em class="italic">definition</em> are often used to refer to different aspects of a variable, function, or class. Here’s what each term means:</p>
<ul>
<li><strong class="bold">Declaration</strong>: A<a id="_idIndexMarker327"/> declaration introduces a name into a program and specifies the type of the variable, function, or class, such as the following:<pre class="source-code">
extern int x;
void foo(int arg);
struct Point;</pre><p class="list-inset">In the preceding example, <code>x</code>, <code>foo</code>, and <code>Point</code> are all <em class="italic">declared</em> but not defined. The <code>extern</code> keyword in the variable declaration indicates that <code>x</code> is defined elsewhere in the program. In declaration, no memory is allocated.</p></li> <li><strong class="bold">Definition</strong>: A definition <a id="_idIndexMarker328"/>provides the actual implementation for a name that has been declared. It reserves memory for variables, allocates code space for functions, and defines the layout of classes, such as the following:<pre class="source-code">
int x;
void foo(int arg) {
   // function body
}
struct Point {
   // struct members and methods
};</pre><p class="list-inset">In the preceding example, <code>x</code>, <code>foo</code>, and <code>Point</code> are all <em class="italic">defined</em>.</p></li> </ul>
<p>So, the <em class="italic">declaration</em> introduces a name and specifies its type, while the <em class="italic">definition</em> provides the actual implementation and allocates memory for the object.</p>
<p>Now that we are familiar with the terminology, let’s dive deep into the specifics of the objects in C++.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor065"/>Scope, storage duration, and lifetimes</h2>
<p>Each object or reference in a C++ program has a specific region in the program where it is visible and accessible, a specific lifetime, and a specific type of memory it occupies. Let’s take a closer look at each of them.</p>
<h3>Scope</h3>
<p>In C++, the<a id="_idIndexMarker329"/> scope<a id="_idIndexMarker330"/> of a variable, function, or class refers to the region of the program where the name of the entity is visible and can be accessed without qualification. The scope rules determine which identifiers are visible and accessible in different parts of the program. The standard defines several types of scopes in C++. Some of them are as follows:</p>
<ul>
<li><strong class="bold">Global</strong>: Variables, functions, and classes declared outside any function or class have global scope. They <a id="_idIndexMarker331"/>can be accessed from any part of the program, such as the following:<pre class="source-code">
int x = 1; // global variable
void foo() {
    std::cout &lt;&lt; x &lt;&lt; std::endl; // access global
      variable
}</pre></li> <li><strong class="bold">Function</strong>: Variables<a id="_idIndexMarker332"/> declared inside a function have function scope. They can be accessed only within the function where they are declared, such as the following:<pre class="source-code">
void foo() {
    int x = 1; // local variable
    std::cout &lt;&lt; x &lt;&lt; std::endl; // access local
      variable
}</pre></li> <li><code>{}</code>), have block scope. They can be accessed only within the block where they are declared, or in inner blocks if there are any, such as the following:<pre class="source-code">
void foo() {
    int x = 2; // local variable with function scope
    {
        int y = 4; // local variable with block scope
    }
}</pre></li> </ul>
<p>These are some of the scopes we use in C++. Now, let’s see what storage duration means in C++.</p>
<h3>Storage duration</h3>
<p>In C++, <em class="italic">storage duration</em> refers <a id="_idIndexMarker334"/>to the lifetime of an object, or <a id="_idIndexMarker335"/>how long it exists in memory. There are four types of storage duration:</p>
<ul>
<li><code>static</code> keyword and function parameters.</li>
<li><code>static</code> keyword inside a function.</li>
<li><code>new</code> operator and destroyed with the <code>delete</code> operator. They exist on the heap and can be accessed by multiple parts of a program.</li>
<li><strong class="bold">Thread-local</strong>: These<a id="_idIndexMarker339"/> objects are created when a thread is created and destroyed when the thread terminates. They are like objects with static storage duration, but they are specific to a particular thread.</li>
</ul>
<p>Here is an example <a id="_idIndexMarker340"/>that illustrates the different types of storage duration:</p>
<pre class="source-code">
#include &lt;iostream&gt;
int global_var = 1; // Static storage duration
void foo() {
    int automatic_var = 2;
    static int static_var = 3;
    int* dynamic_var = new int(4);
    std::cout &lt;&lt; "Automatic var: " &lt;&lt; automatic_var &lt;&lt;
      '\n';
    std::cout &lt;&lt; "Static var: " &lt;&lt; static_var &lt;&lt; '\n';
    std::cout &lt;&lt; "Dynamic var: " &lt;&lt; *dynamic_var &lt;&lt; '\n';
    delete dynamic_var;
}
int main() {
    foo();
    std::cout &lt;&lt; "Global var: " &lt;&lt; global_var &lt;&lt; '\n';
    return 0;
}</pre> <p>In this example, <code>global_var</code> has static storage duration because it is a global variable. <code>automatic_var</code> has automatic <a id="_idIndexMarker341"/>storage duration because it is declared inside the <code>foo</code> function. <code>static_var</code> also has static storage duration, but it retains its value between calls to <code>foo</code> because of the <code>static</code> keyword. <code>dynamic_var</code> itself has an automatic storage duration, but the allocated memory that it points to has dynamic storage duration because it is allocated with the <code>new</code> operator. When <code>foo</code> returns, <code>automatic_var</code> is automatically destroyed, <code>dynamic_var</code> is destroyed with the help of the <code>delete</code> operator, while <code>static_var</code> and <code>global_var</code> persist throughout a program’s lifetime.</p>
<h3>Lifetime</h3>
<p>The<a id="_idIndexMarker342"/> term <em class="italic">lifetime</em> refers<a id="_idIndexMarker343"/> to the duration of the existence of an object or a reference within a program. Every object and reference in C++ has <a id="_idTextAnchor066"/>a specific lifetime. The lifetime of an object begins when memory is allocated for it, and it is initialized. If the object’s type has a constructor, then the lifetime begins when the constructor is successfully completed. The lifetime of an object ends either when its destructor is called or, if no destructor exists, when it is destroyed. Thus, an object’s lifetime is equivalent to or smaller than the dura<a id="_idTextAnchor067"/>tion of its storage. Similarly, the lifetime of a reference begins when its initialization is completed and ends up like a scalar object.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>The object</h2>
<p>Each<a id="_idIndexMarker344"/> object is<a id="_idIndexMarker345"/> created by a definition statement that introduces, creates, and optionally initializes a <em class="italic">variable</em>. A <a id="_idIndexMarker346"/>variable is an <em class="italic">object</em> or a <em class="italic">reference</em> that is not a non-static data member, and it is introduced by a declaration (Object - <a href="http://cppreference.com">cppreference.com</a>).</p>
<p>Let’s define a simple variable and create an object from it:</p>
<pre class="source-code">
void foo() {
    int x;
}</pre> <p>We have defined and, at the same time, instantiated an object from an integer type on the stack of the <code>foo()</code> function. Each object in C++ occupies a certain amount of memory at a specific memory region. Being on the stack, this object has an automatic storage duration. In our example, it means that the object will be created when the function starts and will be automatically destroyed when the function ends. When it is instantiated, it uses some amount of memory. This amount is a compile-time known value, and it can be acquired with the <code>sizeof</code> operator. Keep in mind that the size of some types can vary depending on the underlying hardware where your program runs, so if you need to be sure of the size, always use the operator to calculate it. Such an example is the fundamental <code>int</code> type. The standard says that the size of the <code>int</code> type can’t be less than 16 bits. For Linux Mint 21 with GCC 12.2, in which the examples of this chapter are run, the used underlying data model is LP64. This means that <code>int</code> is 4 bytes, and <code>long</code> and <code>pointer</code> are 8 bytes. In the next example, we demonstrate the size of the types <a id="_idIndexMarker347"/>mentioned earlier. In order to compile and run this code, you have to pass it in a function:</p>
<pre class="source-code">
int i;
long l;
char* p;
std::cout &lt;&lt; "sizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; "; sizeof(i) = " &lt;&lt; sizeof(i) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(long) = " &lt;&lt; sizeof(long) &lt;&lt; "; sizeof(l) = " &lt;&lt; sizeof(l) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(char*) = " &lt;&lt; sizeof(char*) &lt;&lt; "; sizeof(p) = " &lt;&lt; sizeof(p) &lt;&lt; '\n';</pre> <p>Here is the output of the example:</p>
<pre class="console">
sizeof(int) = 4; sizeof(i) = 4
sizeof(long) = 8; sizeof(l) = 8
sizeof(char*) = 8; sizeof(p) = 8</pre> <p>Nothing surprising so far. <code>int</code> is 4 bytes, but the pointer, no matter which type it points to, is 8 bytes.</p>
<p>Now, let’s define several structures and check their memory footprint:</p>
<pre class="source-code">
struct Empty {};
struct Padding {
    long test;
    char m;
};
struct Virt {
    virtual char GetChar() const { return ch; }
    char ch;
};
void foo() {
    std::cout &lt;&lt; "Empty: " &lt;&lt; sizeof(Empty) &lt;&lt; '\n';
    std::cout &lt;&lt; "Padding: " &lt;&lt; sizeof(Padding) &lt;&lt; '\n';
    std::cout &lt;&lt; "Virt: " &lt;&lt; sizeof(Virt) &lt;&lt; '\n';
}</pre> <p>We have <a id="_idIndexMarker348"/>defined three structures – <code>Empty</code>, <code>Padding</code>, and <code>Virt</code>. The <code>Empty</code> structure, as <a id="_idIndexMarker349"/>the name suggests, is just an empty structure without any members in it. The <code>Padding</code> structure <a id="_idIndexMarker350"/>contains two members – <code>long</code> and <code>char</code>. As we saw from the previous example, in my testing environment, <code>long</code> is 8 bytes and <code>char</code> is 1 byte. Finally, the <code>Virt</code> structure<a id="_idIndexMarker351"/> has only one member of type <code>char</code> and one virtual method. Structure and class methods are not part of the object itself. They reside in the text segment rather than in the memory occupied by the object. Let’s execute the earlier code and see the result:</p>
<pre class="console">
Empty: 1
Padding: 16
Virt: 16</pre> <p>We can see that all the objects occupy memory. Even the empty one! This is guaranteed by the standard because any object in the system has to have an address on which it resides. If it doesn’t occupy any memory, then no address can be assigned to it. Therefore, at least 1 byte is reserved for every object in the program.</p>
<p>The <code>Padding</code> structure<a id="_idIndexMarker352"/> occupies more memory than the sum of its members’ memory. This is because the compilers are free to place the objects on an address, which requires less instruction arithmetic in order to be accessed faster. Therefore, they add padding bytes to the size of the type if this is required.</p>
<p>Finally, the <code>Virt</code> structure<a id="_idIndexMarker353"/> contains only one member, which has type <code>char</code>. However, the structure occupies the same amount of memory as the <code>Padding</code> structure. This is a result of how the mechanics of the polymorphism are implemented in C++. The <a id="_idIndexMarker354"/>structure contains a virtual method that notifies the compiler that this user-defined type will be used polymorphically. As a result, the compiler injects in every instantiated object from this type a pointer to a table, with the addresses of all the virtual methods of the class.</p>
<p>As a result of <a id="_idIndexMarker355"/>all these examples, we can conclude that each object occupies memory once it is instantiated, and the size of the memory can vary depending on the underlying system and the definition of the type.</p>
<p>Next, we will get familiar with references in C++ and how they differ from objects in the language.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>The reference</h2>
<p>In the<a id="_idIndexMarker356"/> previous section, we found out that we can declare a variable not only from an object but also from a reference. But what is a <em class="italic">reference</em> in terms of C++? According to the standard, a reference variable is an <em class="italic">alias</em> to an already-existing object or function. This means that we can use aliases to work with objects without having a difference in the syntax, rather than working with pointers to objects where the syntax is quite different. Let’s have a look in the following example. In order to compile and run it, you need to invoke it from a function:</p>
<pre class="source-code">
char c;
char&amp; r_c{c};
char* p_c;
std::cout &lt;&lt; "sizeof(char) = " &lt;&lt; sizeof(char) &lt;&lt; "; sizeof(c) = " &lt;&lt; sizeof(c) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(char&amp;) = " &lt;&lt; sizeof(char&amp;) &lt;&lt; "; sizeof(r_c) = " &lt;&lt; sizeof(r_c) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(char*) = " &lt;&lt; sizeof(char*) &lt;&lt; "; sizeof(p_c) = " &lt;&lt; sizeof(p_c) &lt;&lt; '\n';</pre> <p>In this example, we declare three variables – a character, a reference to a character, and a pointer to a character. An important detail when working with reference variables is that at the point of its declaration, we must also initialize it with the object it will refer to. From this moment on, every operation invoked on the reference variable is actually invoked on the aliased object. But what indeed is an alias? Does it occupy memory just like the pointer does? Well, this is a gray area. The standard says that the references, unlike objects, do not always occupy storage. However, the compiler may allocate storage if required to implement the intended semantics. As a result of this, you <em class="italic">can’t use</em> the <code>sizeof</code> operator to get the size of a reference:</p>
<pre class="console">
sizeof(char) = 1; sizeof(c) = 1
sizeof(char&amp;) = 1; sizeof(r_c) = 1
sizeof(char*) = 8; sizeof(p_c) = 8</pre> <p>You can see<a id="_idIndexMarker357"/> that the pointer size matches the expectation rather than the size of the reference type, where it matches the size of the type to which it has an alias.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Understanding why initialization matters</h2>
<p><em class="italic">Initialization</em> is <a id="_idIndexMarker358"/>the process of setting the initial value of an object during its construction. In C++, there are several types of initializations depending mostly on the following:</p>
<ul>
<li>The storage duration which the object belongs to</li>
<li>The definition of the object</li>
</ul>
<p>Knowing the different types of initializations and exactly when they happen will certainly make you more confident in writing predictable code.</p>
<p>Let’s look at a few examples of various types of initializations that the C++ language supports. This will make it clearer when initialization occurs.</p>
<h3>Default initialization</h3>
<p>In the next example, you<a id="_idIndexMarker359"/> can see a <em class="italic">default initialization</em>. In order to run and test this code, you <a id="_idIndexMarker360"/>have to invoke the <code>foo()</code> method:</p>
<pre class="source-code">
struct Point {
    double x;
    double y;
};
void foo() {
    long a; // {1}
    Point p1; // {2}
    std::cout &lt;&lt; "{1}: " &lt;&lt; a &lt;&lt; '\n';
    std::cout &lt;&lt; "{2}: " &lt;&lt; p1.x &lt;&lt; ", " &lt;&lt; p1.y &lt;&lt; '\n';
}</pre> <p>In marker <code>{1}</code>, we have declared a stack variable from type <code>long</code>. The type of initialization that will apply on an object depends mainly on the following:</p>
<ul>
<li><strong class="bold">The storage duration it occupies</strong>: This means that different initialization policies may apply, depending on whether the object lives on the stack, in the global space, and so on</li>
<li><code>init</code> value, how exactly we have passed that <code>init</code> value, and so on</li>
</ul>
<p>The <code>long a;</code> variable in our example has automatic storage duration, meaning it lives on the function’s stack. In its declaration, we haven’t specified any initialization value. For such objects, we will apply <em class="italic">default initialization</em>. When an object is default-initialized, the C++ compiler will generate code that calls the default constructor of the object’s type if one exists. However, since <code>long</code> is a fundamental C++ type that lacks a default constructor, the C++ runtime <em class="italic">does not perform any initialization on it</em>, resulting in an <em class="italic">unpredictable value</em>. This means that the value that will be used for initialization is not specified and could be literally any. This is also the case with the <code>Point p1;</code> object, which is a user-defined type, but we did not specify a default constructor for it. The <code>Point</code> structure is a <a id="_idIndexMarker361"/>so-called <strong class="bold">Plain Old Data</strong> (<strong class="bold">POD</strong>) type because it is fully <a id="_idIndexMarker362"/>compatible with the structures from the C language. For<a id="_idIndexMarker363"/> such types, the compiler will generate a <em class="italic">trivial default constructor</em> for you, which effectively does nothing when called.</p>
<p>The output of the earlier example will look like this:</p>
<pre class="console">
{1}: 1
{2}: 4.19164e-318, 4.3211e-320</pre> <p>In my environment, the <code>a</code> and <code>p1</code> objects both have indeterministic values. If you run the example of your own, you will possibly get different values.</p>
<h3>Direct initialization</h3>
<p>In our next <a id="_idIndexMarker364"/>example, we will learn about C++ <em class="italic">direct initialization</em>. In<a id="_idIndexMarker365"/> order to run and test this code, you have to invoke the <code>foo()</code> method again. Bear in mind that the <code>int c_warn{2.2};</code><code> // {4.2}</code> statement from this example should be commented out in order to compile successfully:</p>
<pre class="source-code">
void foo() {
    int b(1);         // {3.1}
    int b_trunc(1.2); // {3.2}
    int c{2};         // {4.1}
    int c_warn{2.2};  // {4.2}
    std::cout &lt;&lt; "{3.1}: " &lt;&lt; b &lt;&lt; '\n';
    std::cout &lt;&lt; "{3.2}: " &lt;&lt; b_trunc &lt;&lt; '\n';
    std::cout &lt;&lt; "{4.1}: " &lt;&lt; c &lt;&lt; '\n';
}</pre> <p>In the first statement from the example, <code>int b(1);</code>, we have defined a variable of type <code>int</code>, and we have explicitly initialized it with a value of <code>1</code>. This is the <em class="italic">direct initialization</em> that we have known since the dawn of the C++ language. In order to invoke it, you have to specify the initialization value in parentheses, and that value has to match some of the <a id="_idIndexMarker366"/>conversion constructors of the object’s type. These conversion constructors can be compiler-generated. In our example, we use <code>int</code>, which is a fundamental C++ type and supports direct initialization with integer values. As a result, the <code>b</code> object will be initialized with a value of <code>1</code>, so nothing new so far.</p>
<p>With the<a id="_idIndexMarker367"/> next statement, we declare an <code>int b_trunc(1.2);</code> variable, but this time, we initialize it with a floating-point value of <code>1.2</code>. This statement works fine and declares a variable of type <code>int</code> and initializes it with a value of… <code>1</code>! Yes, according to the C++ standard, which tries to be as compatible as possible with the C language for features that are present in both languages, the value is <em class="italic">truncated down</em> to its mantissa. In some cases, it could be useful to initialize an integer object with a floating-point value, but in others, this could be an inadvertent error. In such a case, we will expect the compiler to warn us that we are potentially doing something wrong. Therefore, C++11 introduced the<a id="_idIndexMarker368"/> so-called <em class="italic">uniform initialization</em>.</p>
<p>In the next statement from the example, <code>int c{2};</code>, we again declare a variable of type <code>int</code>, but we initialize it using curly braces rather than parentheses. This notifies the compiler to<a id="_idIndexMarker369"/> invoke <em class="italic">direct list initialization</em>, which is a kind of uniform initialization. It is a named list initialization because it can be used as an initialization list of values of different types to initialize complex objects.</p>
<p>One reason to prefer using uniform initialization wherever this is possible is visible in the next statement from the example:</p>
<pre class="source-code">
int c_warn{2.2};  // {4.2}</pre> <p>As we just saw, using direct initialization to initialize an object of a specific type with a value of a wider type leads to a silently truncated initialized value. In some situations, this can lead to bugs. One way to avoid this potential side effect is to use uniform initialization instead. In our example, we defined a variable of type <code>int</code> and again initialized it with a floating-point value. However, this time, the compiler will not silently initialize <code>c_warn</code> with a value of <code>2</code>, but it will generate an error similar to this:</p>
<pre class="console">
error: narrowing conversion of '2.2000000000000002e+0' from 'double' to 'int' [-Wnarrowing]</pre> <p>The error is produced because we try to perform a narrowing conversion in the initialization of an <code>int</code> variable with a <code>double</code> value. Therefore, it is safer to use uniform initialization over a direct one because it protects you from narrowing conversions during initialization.</p>
<h3>Zero and aggregate initialization</h3>
<p>Let’s <a id="_idIndexMarker370"/>see another initialization example. We will initialize <a id="_idIndexMarker371"/>an object that holds the personal data for <code>Person</code> and a few integer objects:</p>
<pre class="source-code">
struct Person {
    std::string name;
    int age;
};
void init() {
    int zero1{}; // {1}
    int zero2 = int(); // {2}
    int zero3 = int{}; // {3}
    Person nick{"Nick L.", 42}; // {4}
    Person john{.name{"John M."}, .age{24}}; // {5}
}</pre> <p>As we already explained, the objects with automatic storage duration and without explicit initialization get random initialization values. In this example, from markers <code>{1}</code> to <code>{3}</code>, we have initialized the objects using <em class="italic">zero initialization</em>, which effectively sets their values to zero. Zero initialization happens for non-class, built-in types and for the members of user-defined types that have no constructors. Preferably use curly brace notation and uniform initialization, such as marker <code>{1}</code>, when you need to zero-initialize your objects, rather than copying zero initialization, such as markers <code>{2}</code> and <code>{3}</code>.</p>
<p>Statement <code>{4}</code> demonstrates another method of initialization called <em class="italic">aggregate initialization</em>. It allows <a id="_idIndexMarker372"/>us to initialize an aggregate object using uniform initialization notation. An aggregate is considered any object that is an array or a class type that has no user-declared <a id="_idIndexMarker373"/>or inherited constructors; all of its non-static members are publicly visible, and it has no virtual base classes and no virtual methods. Statement <code>{5}</code> performs another way of <em class="italic">aggregate initialization</em> but using <em class="italic">designators</em>. The designators <a id="_idIndexMarker374"/>explicitly specify the members being initialized, and the order of the designators in the initialization should follow the order of the declaration of the members in the structure.</p>
<h3>Copy initialization</h3>
<p>Copy initialization<a id="_idIndexMarker375"/> occurs when an object of a specific type<a id="_idIndexMarker376"/> is initialized by another object of the same type. Let’s look at the following examples of syntax that triggers copy initialization. In order to run and test this code, you have to invoke the <code>foo()</code> method:</p>
<pre class="source-code">
void foo() {
    int c{2};
    int d(c);     // {1}
    int e{d};     // {2}
    int f = e;    // {3}
    int f1 = {d}; // {4}
}</pre> <p>Markers <code>{1}</code> and <code>{3}</code> from this example demonstrate the well-known copy initialization present in the language even before C++11. An object of type <code>int</code> is initialized by another object of the same type. As we already saw, this kind of initialization doesn’t give any protection against types narrowing. This means that our <code>int</code> objects can be silently initialized by <code>double</code> objects, which will lead to narrowing. Fortunately, this is not the case with markers <code>{2}</code> and <code>{4}</code>. They use uniform copy initialization, which forces the compiler to verify that the initialization object is from the same type as the object being initialized.</p>
<p>Now, let’s look at several scenarios of copy initialization for user-defined types. We have defined two classes – <code>Person</code> and <code>Employee</code>. The <code>Person</code> class has one user-defined constructor that receives a reference to the <code>std::string</code> parameter, used to initialize the name of the person. The constructor is marked as <code>explicit</code>. This means that it will be used only as a non-converting constructor. The <em class="italic">converting constructor</em> is a <a id="_idIndexMarker377"/>constructor that<a id="_idIndexMarker378"/> makes an implicit conversion from its argument types to its class types.</p>
<p>The <a id="_idIndexMarker379"/>other class, <code>Employee</code>, has two constructors, one of which gets a reference to a <code>Person</code> object, while the other is a copy constructor. The copy constructor is also marked as <code>explicit</code>:</p>
<pre class="source-code">
class Person {
public:
    explicit Person(const std::string&amp;  the_name) : name{
      the_name} {}
private:
    std::string name;
};
class Employee {
public:
    Employee(const Person&amp; p) : p{p} {}
    explicit Employee(const Employee&amp; e) : p{e.p} {}
private:
    Person p;
};</pre> <p>Let’s use these two classes in different initialization scenarios. In order to run and test this code, you have to rework and invoke the <code>foo()</code> method again:</p>
<pre class="source-code">
void foo() {
    Person john{"John M."};
    Employee staff1{john};          // {1}
    // Employee staff2{std::string{"George"}};   // {2}
    Employee staff3{staff1};        // {3}
    // Employee staff4 = staff1;    // {4}
    // Employee staff5 = {staff1};  // {5}
}</pre> <p>We first <a id="_idIndexMarker380"/>defined a <code>Person</code> object named <code>john</code>, and in marker <code>{1}</code>, we initialize an <code>Employee</code> object using <code>john</code>. This is actually valid because the <code>Employee</code> class has a constructor that accepts the <code>Person</code> objects. The next statement, marker <code>{2}</code>, which is commented out, gets as an argument an object of type <code>std::string</code>, but the compiler will generate an error. This is because the <code>Employee</code> class doesn’t have a constructor that gets a string object. It has a converting constructor from the <code>Person</code> object. However, the <code>Person</code> constructor is marked as <code>explicit</code>, and it is not allowed to be used in implicit type conversions, so the compilation will fail.</p>
<p>The <a id="_idIndexMarker381"/>next statement, marker <code>{3}</code>, will compile successfully because <code>Employee</code> is copy-constructed and initialized by another <code>Employee</code> object without any implicit type conversions.</p>
<p>The final two statements from the example – markers <code>{4}</code> and <code>{5}</code> – are also commented out to avoid compilation errors. The reason for the compiler error is that the copy constructor of the <code>Employee</code> class is also marked as <code>explicit</code>. This means that copy construction and initialization using equal<code> "="</code> sign is not allowed for explicit copy constructors. Only direct copy initialization is permitted.</p>
<p>Now that we are familiar with what the scope, storage duration, and lifetime of the object are, we can have a look at some slightly different kinds of objects, which behave more like functions rather than objects – functors and lambdas.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/>Functors and lambdas</h1>
<p>This section will delve into functional objects – their definition, usefulness, and proper usage. We’ll begin by examining an example of a functional object used with an STL algorithm and discuss potential issues, such as the creation of temporary objects and dangling references. After that, we’ll move on to exploring lambda expressions – what they are, how to use them, and specific situations where they can be especially advantageous.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>Exploring functional objects</h2>
<p>In the <em class="italic">Scope, storage duration, and lifetimes</em> section, we looked at various types of object <a id="_idIndexMarker382"/>initialization in C++, but our focus was mostly on objects that represent data, such as integers or coordinates. In this section, we’ll shift our attention to another type of object – those designed to <a id="_idIndexMarker383"/>be <em class="italic">callable</em>, such as a function, but with a crucial difference: they can maintain a state between different function calls. These objects are <a id="_idIndexMarker384"/>known as <em class="italic">functional objects</em> or <em class="italic">functors</em>. We’ll start by defining a functor and then use it to compute the mean value of a vector containing floating-point numbers:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;<strong class="bold">source_location</strong>&gt;
struct Mean {
    Mean() = default;
    void operator()(const double&amp; val) {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " of " &lt;&lt; this &lt;&lt; '\n';
        sum += val;
        ++count;
    }
private:
    double sum{};
    int count{};
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const
      Mean&amp; a);
};
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Mean&amp; a) {
    double mean{std::nan("")};
    if (a.count &gt; 0) {
        mean = a.sum / a.count;
    }
    os &lt;&lt; mean;
    return os;
}
int main() {
    Mean calc_mean;
    std::vector v1{1.0, 2.5, 4.0, 5.5};
    std::for_each(v1.begin(), v1.end(), calc_mean);
    std::cout &lt;&lt; "The mean value is: " &lt;&lt; calc_mean &lt;&lt;
      '\n';
    return 0;
}</pre> <p>The functor is an object like any other. It has a type, storage duration, and scope. In order to define a functor, you have to either define a struct or class of a user-defined type, and this type must have<a id="_idIndexMarker385"/> implemented a <em class="italic">function </em><em class="italic">call operator</em>:</p>
<pre class="source-code">
operator()</pre> <p>In our <a id="_idIndexMarker386"/>example, we defined <code>struct Mean</code> with two members in it, which are zero-initialized. The first one, <code>sum</code>, will be used to accumulate the input data that this object receives during the function call operator invocations, preserving it between different invocations. And the other member, <code>count</code>, will be used to count the number of invocations of the function call operator.</p>
<p>The definition of the function call operator gets one parameter of a <code>double</code> type, and then the method prints its name and adds the input value to the already accumulated value from the previous invocations. Finally, it increments the invocation counter.</p>
<p>The function call operator doesn’t return any type and is not defined as a <code>const</code> method because it mutates the state of the <code>Mean</code> object. We also overloaded the stream extraction operator, which will be used to report the calculated mean value to the standard output. If there is no accumulated value, then <code>nan</code> (“not a number”) will be printed:</p>
<pre class="source-code">
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Mean&amp; a)</pre> <p>Please keep in mind that the operator is overloaded outside of the <code>Mean</code> structure, and it is declared as a <em class="italic">friend</em> method to it. This is because it needs to get <code>std::ostream</code> as a left-hand argument and the <code>Mean</code> parameter as the right argument, and therefore, it can’t be implemented as a member method. It’s defined as <em class="italic">friend</em> because it has to have access to the <em class="italic">private</em> members of the <code>Mean</code> structure.</p>
<p>In order to calculate the mean value, our algorithm iterates over all values in the vector using the <code>std::for_each</code> STL algorithm. <code>std::for_each</code> expects to receive a container on which to operate and function, which will be invoked with each of the elements from the container; therefore, this function must accept one parameter as an input argument.</p>
<p>In the main method, we define an object of type <code>Mean calc_mean;</code>, which will be used to calculate the mean value of <code>std::vector v1{1.0, 2.5, 4.0, 5.5};</code>. As you can see, we don’t need to explicitly specify the template argument type of the <code>std::vector</code> class because it is automatically deduced by the type of the initializer list values it is initialized with. In our case, these are <code>double</code> values.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Please note that since C++17, the automatic class template argument deduction is already supported, based on the type of its initializer.</p>
<p>We expect <a id="_idIndexMarker387"/>that the program will invoke the function operator of the <code>Mean</code> object for each element in the vector. The function operator will accumulate all values, and when the result is printed out, it will be <code>3.25</code>. Let’s see the output of the program:</p>
<pre class="console">
void Mean::operator()(const double&amp;) of 0x7ffc571a64e0
void Mean::operator()(const double&amp;) of 0x7ffc571a64e0
void Mean::operator()(const double&amp;) of 0x7ffc571a64e0
void Mean::operator()(const double&amp;) of 0x7ffc571a64e0
The mean value is: nan</pre> <p>As we expected, the operator function call is invoked for each of the elements from the vector, but surprisingly, there is no calculated mean value. In order to get a better understanding of what went wrong with the calculation, we need to see what has happened with the <code>calc_mean</code> object, which has been used by the <code>std::for_each</code> algorithm.</p>
<h3>Beware of temporaries</h3>
<p>For the sake <a id="_idIndexMarker388"/>of investigation, in the <code>Mean</code> structure, we need to define the <code>copy</code> and <code>move</code> constructors, the <code>move</code> operator, and a destructor, whose only goal will be to print whether they are invoked and the address of the object that they belong to. We also need to add markers for when the calculation starts and when it finishes. Let’s see the reworked example:</p>
<pre class="source-code">
struct Mean {
    Mean() noexcept {
        std::cout &lt;&lt;  std::source_location::current()
         .function_name() &lt;&lt; " of " &lt;&lt; this &lt;&lt; '\n';
    }
    Mean(Mean&amp;&amp; a) noexcept : sum{a.sum}, count{a.count} {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " from: " &lt;&lt; &amp;a &lt;&lt; " to: " &lt;&lt;
             this &lt;&lt; '\n';
        a.sum = 0;
        a.count = -1;
    }
    Mean&amp; operator=(Mean&amp;&amp; a) noexcept {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " from: " &lt;&lt; &amp;a &lt;&lt; " to: " &lt;&lt;
            this &lt;&lt; '\n';
        sum = a.sum;
        count = a.count;
        return *this;
    }
    Mean(const Mean&amp; a) noexcept : sum{a.sum},
      count{a.count} {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " from: " &lt;&lt; &amp;a &lt;&lt; " to: " &lt;&lt;
            this &lt;&lt; '\n';
    }
    ~Mean() noexcept {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " of " &lt;&lt; this &lt;&lt; '\n';
    }
    void operator()(const double&amp; val) {
        std::cout &lt;&lt;  std::source_location::current()
          .function_name() &lt;&lt; " of " &lt;&lt; this &lt;&lt; '\n';
        sum += val;
        ++count;
    }
private:
    double sum{};
    int count{};
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const
      Mean&amp; a);
};</pre> <p>We also <a id="_idIndexMarker389"/>need to slightly change the <code>main()</code> method implementation:</p>
<pre class="source-code">
int main() {
    Mean calc_mean;
    std::vector v1{1.0, 2.5, 4.0, 5.5};
    std::cout &lt;&lt; "Start calculation\n";
    std::for_each(v1.begin(), v1.end(), calc_mean);
    std::cout &lt;&lt; "Finish calculation\n";
    std::cout &lt;&lt; "The mean value is: " &lt;&lt; calc_mean &lt;&lt;
      '\n';
    return 0;
}</pre> <p>When we re-execute the already reworked program, we get the following output:</p>
<pre class="console">
Mean::Mean() of 0x7ffef7956c50
Start calculation
Mean::Mean(const Mean&amp;) from: 0x7ffef7956c50 to: 0x7ffef7956ca0
void Mean::operator()(const double&amp;) of 0x7ffef7956ca0
void Mean::operator()(const double&amp;) of 0x7ffef7956ca0
void Mean::operator()(const double&amp;) of 0x7ffef7956ca0
void Mean::operator()(const double&amp;) of 0x7ffef7956ca0
Mean::Mean(Mean&amp;&amp;) from: 0x7ffef7956ca0 to: 0x7ffef7956c90
Mean::~Mean() of 0x7ffef7956c90
Mean::~Mean() of 0x7ffef7956ca0
Finish calculation
The mean value is: nan
Mean::~Mean() of 0x7ffef7956c50</pre> <p>As we<a id="_idIndexMarker390"/> expected, the program starts with the construction of the object with the address <code>0x7ffef7956c50</code>, then the calculation is started, and we can see that a copy constructor is invoked. This is because <code>std::for_each</code>, like many other algorithms in the standard library, is a template method that gets its functor by value. Here is what the standard says about its prototype:</p>
<pre class="source-code">
template&lt; class InputIt, class UnaryFunction &gt;
constexpr UnaryFunction for_each( InputIt first, InputIt
  last, UnaryFunction f );</pre> <p>This means that no matter what calculation it does, all the accumulated values will be stored in the copied object rather than the original. Actually, the object created by this copy constructor is just a <em class="italic">temporary object</em>. Temporary objects<a id="_idIndexMarker391"/> are unnamed objects that are automatically created and destroyed by the compiler. They often lead to side effects that are not trivially recognizable by the developers. Temporary objects are most <a id="_idIndexMarker392"/>frequently created as a result of implicit conversions of arguments and functions’ returned values. They frequently have a limited lifetime, till the end of the statement they are created by, if they are not bound to some named reference. So, be careful with them because they can impact the performance of your program, but more importantly, they can lead to unexpected behavior, as in our example.</p>
<p>From the<a id="_idIndexMarker393"/> preceding code, we can see that all the accumulations are done in the newly created temporary object. Once the <code>std::for_each</code> method finishes its execution, a move constructor of a new temporary object is invoked. This happens because, according to the definition of <code>std::for_each</code>, the passed-by value input functor is returned back as a result of the operation. So, if we need to get the accumulated value back to the original object, we need to assign the return value of <code>std::for_each</code> back to the original object – <code>calc_mean</code>:</p>
<pre class="source-code">
calc_mean = std::for_each(v1.begin(), v1.end(), calc_mean);</pre> <p>Finally, the result is what we expected but at the price of creating several temporary objects:</p>
<pre class="console">
Finish calculation
The mean value is: 3.25</pre> <p>In our example, this is not a problem, but for really complex objects where temporary object creation involves expensive and potentially slow operations, such as resource acquisition, this could be problematic.</p>
<p>Next, let’s have a look at how we can improve our example by avoiding unnecessary copy operations.</p>
<h3>Passing by reference</h3>
<p>One <a id="_idIndexMarker394"/>way to improve the earlier example is to pass the functor not by value but by reference. This will avoid the creation of unnecessary temporary objects:</p>
<pre class="source-code">
using VecCIter = std::vector&lt;double&gt;::const_iterator;
std::for_each&lt;VecCIter, Mean&amp;&gt;(v1.begin(), v1.end(),
  calc_mean);</pre> <p>In order to pass by reference the <code>Mean</code> object, you have to explicitly state your intention to the compiler by explicitly specifying that the <code>Mean</code> template parameter is a reference. Otherwise, the automatic template argument deduction will deduce that you are passing by <a id="_idIndexMarker395"/>value. As a result, this forces you to avoid using automatic class template argument deduction and makes your code harder to read. Fortunately, the standard provides a solution for this:</p>
<pre class="source-code">
std::for_each(v1.begin(), v1.end(), std::ref(calc_mean));</pre> <p>We need to use the factory method, <code>std::ref</code>, for the creation of the <code>std::reference_wrapper</code> objects. <code>std::reference_wrapper</code> is a class template that wraps a reference inside an assignable, copyable object. It’s commonly used to store references within standard containers that can’t typically hold them. The usage of <code>std::ref</code>, in our example, eliminates the need to explicitly specify that the functor template parameter of <code>std::for_each</code> is a reference type rather than a value. Here is the result of our refactoring:</p>
<pre class="console">
Mean::Mean() of 0x7ffe7415a180
Start calculation
void Mean::operator()(const double&amp;) of 0x7ffe7415a180
void Mean::operator()(const double&amp;) of 0x7ffe7415a180
void Mean::operator()(const double&amp;) of 0x7ffe7415a180
void Mean::operator()(const double&amp;) of 0x7ffe7415a180
Finish calculation
The mean value is: 3.25
Mean::~Mean() of 0x7ffe7415a180</pre> <p>As you can see, there is no additional creation and destruction of temporary objects because the algorithm works directly with the reference of the <code>calc_mean</code> object.</p>
<p class="callout-heading">Beware of dangling references</p>
<p class="callout">Always make sure that the references you pass across the program will refer to live objects until they are in use!</p>
<p>Functors are just one option that we can use in our example. There is also another approach here that <a id="_idIndexMarker396"/>can make our code even more expressive. These are lambda expressions. Let’s have a look at them.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Lambda expressions</h2>
<p>The <em class="italic">lambda expression</em>, or just <em class="italic">lambda</em> in C++, is a<a id="_idIndexMarker397"/> concise way to define<a id="_idIndexMarker398"/> an <em class="italic">anonymous function</em> or <em class="italic">functor</em> inline, which can be used immediately or assigned to a variable for later use. It allows programmers to write small, throwaway functions on the fly without having to define a named function or a <code>functor</code> class. Lambdas are commonly used with algorithms and containers from the standard library, allowing for more concise and expressive code.</p>
<p>Let’s define a simple lambda that just prints to the standard output:</p>
<pre class="source-code">
auto min_lambda = [](const auto&amp; name) -&gt; void {
    std::cout &lt;&lt; name &lt;&lt; " lambda.\n";
};
min_lambda("Simple");</pre> <p>Each lambda expression is an <em class="italic">object</em>, which means that it has a lifetime and occupies memory. Every defined lambda is a de facto functor class definition, and as such, it has a <em class="italic">unique type</em>. There<a id="_idIndexMarker399"/> can’t be two or more lambdas with the same <em class="italic">type</em> in a program. This <em class="italic">type</em> name is platform-specific, and therefore, if you need to assign a lambda to a variable, you have to define this variable with the <code>auto</code> specifier.</p>
<p>The syntax of a lambda consists of the <code>[ ]</code> symbol, which is followed by an optional capture list, an optional parameter list, an optional return type, an optional <em class="italic">mutable</em> specifier, and <a id="_idIndexMarker400"/>a function body. Lambdas can capture variables from the outer scope by value or by reference, and they can also have a return type deduction or an explicit return type, which we will see next.</p>
<h3>Capturing the outer scope</h3>
<p>Lambdas can gain <a id="_idIndexMarker401"/>access to other objects in the scope where they’re defined by <a id="_idIndexMarker402"/>utilizing a <em class="italic">capture list</em>. If the capture list is empty, then no objects are captured. Global objects are always visible in lambdas without needing to be explicitly captured. When defining the capture list, you can choose to capture objects by <em class="italic">value</em> or by <em class="italic">reference</em>, or even a mixture of both.</p>
<p>When capturing variables by value in a lambda expression, the variables are <em class="italic">copied</em> into the lambda object at the <em class="italic">moment of its definition</em>. Any modifications made to the original variables after the lambda is defined won’t affect the copies stored inside it. All captured objects are, by default, <em class="italic">read-only</em>, and to modify them, you must explicitly specify the lambda as <em class="italic">mutable</em>.</p>
<p>Another option to capture variables is by reference, which creates a reference to every captured object inside the lambda. This allows the lambda to communicate with the outer scope, but it’s crucial to ensure that the lifetime of all captured objects by reference exceeds the lifetime of the lambda to prevent <em class="italic">dangling references</em>.</p>
<p>Now, let’s refactor the example from the previous section to calculate the mean value of a vector with floating-point numbers, using a lambda instead of a functor. In order to run the following code, you have to invoke the <code>foo()</code> method from your program:</p>
<pre class="source-code">
void foo() {
    double mean{};
    std::vector v1{1.0, 2.5, 4.0, 5.5};
    std::string_view text{"calculating ..."};
    std::for_each(v1.begin(), v1.end(),
                  <strong class="bold">[&amp;mean, sum{0.0}, count{0}, text](const</strong>
<strong class="bold">                     double&amp; val) mutable</strong> {
        std::cout &lt;&lt; text &lt;&lt; '\n';
        sum += val;
        ++count;
        mean = sum / count;
    });
    std::cout &lt;&lt; mean &lt;&lt; '\n';
}</pre> <p>One of the<a id="_idIndexMarker403"/> key advantages of lambdas compared to named functions and functors is that they can be inlined in the place of their invocation. In our example, we have defined the lambda directly inside the <code>std::for_each</code> invocation statement. This approach explicitly highlights that this lambda has no other reason to exist except to serve the preceding case.</p>
<p>Let’s get a closer look at the lambda prototype:</p>
<pre class="source-code">
[&amp;mean, sum{0.0}, count{0}, text](const double&amp; val)
  mutable { … }</pre> <p>In the capture list, we have captured four objects. The first one, <code>mean</code>, is captured by reference. Putting <code>&amp;</code> before the variable name specifies that it is captured by reference. We will use <code>mean</code> to report outside of the lambda the calculated mean value. The next two variables in the capture list, <code>sum</code> and <code>count</code>, are captured by value. If <code>&amp;</code> doesn’t precede the name of the variable, it means that it is captured by value. The only exception to this rule is when capturing the <code>this</code> pointer of a class, which will be captured by value, but the access to the class members will be by reference. As you can see, the captures, <code>sum</code> and <code>count</code>, are not defined in the outer scope; they are defined only in the scope of the lambda for the purpose of our example. Just like the functor example, they are used to store the accumulated sum and the count of the iterations. This is a convenient way to explicitly add state into your lambda for use in further calculations. Of course, you need to initialize them by passing initializers to the captures for two reasons – in order to allow the compiler to deduce their type and to get the expected result in the calculations. The implementation logic will update the values of <code>sum</code> and <code>count</code> during its execution, but as stated previously, these captures are read-only in the context of the lambda. Therefore, we cannot just mutate them without explicitly stating our intention during the lambda definition. This is done by appending the <code>mutable</code> keyword after the argument list and before the body of the lambda.</p>
<p>The last captured object is <code>text</code>. It is also captured by value, but this time, it is captured from the outer scope in the <code>foo()</code> method.</p>
<p>Once the program is executed, we have the following output:</p>
<pre class="console">
calculating ...
calculating ...
calculating ...
calculating ...
3.25</pre> <p>As we expected, our <a id="_idIndexMarker404"/>lambda has been called four times, and the calculated mean value is exactly the same as the value calculated by the functor in the previous section.</p>
<p>There are many ways to capture objects in the capture list. The following list shows some rules that apply:</p>
<div><div><img alt="Figure 4.1 – Ways to capture objects in a capture list" height="506" src="img/Figure_4.1_B20833.jpg" width="1330"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Ways to capture objects in a capture list</p>
<p>Now that we know how to properly capture the outer scope, let’s get familiar with a lambda’s parameter list.</p>
<h3>Parameter list</h3>
<p>The <a id="_idIndexMarker405"/>parameter list of a lambda is just like any other function parameter list. This is because the lambda’s parameter list is effectively the parameter list of the function call operator in a functor class. You can define your lambda to accept an arbitrary list of parameters, depending on the use case you have.</p>
<p>Using the <code>auto</code> specifier as a parameter type of one or more of the parameters in the lambda parameter lists makes it a <em class="italic">generic lambda</em>. A<a id="_idIndexMarker406"/> generic lambda acts as a template function call operator:</p>
<pre class="source-code">
auto sum = [](auto a, auto b) {
    return a*b;
}</pre> <p>This effectively<a id="_idIndexMarker407"/> acts as follows:</p>
<pre class="source-code">
class platform_specific_name {
public:
    template&lt;typename T1, typename T2&gt;
    auto operator()(T1 a, T2 b) const {
        return a*b;
    }
};</pre> <p>With the C++20 release, if you wish you can explicitly specify the template parameters that your lambda can get. The preceding example could be rewritten as follows:</p>
<pre class="source-code">
auto sum = []&lt;typename T1, typename T2&gt;(T1 a, T2 b) {
    return a*b;
}</pre> <p>Another important characteristic of lambdas is the return type. Let’s see its specifics.</p>
<h3>The return type</h3>
<p>Specifying the<a id="_idIndexMarker408"/> return type of the lambda is <em class="italic">optional</em>. If you<a id="_idIndexMarker409"/> don’t explicitly specify it, the compiler will try to deduce it for you. If it doesn’t succeed, then a compiler error in type deduction will be generated. Then, you have to either change your code to allow automatic return type deduction or explicitly specify the return type of the lambda.</p>
<p>Here is a compiler error in return type deduction:</p>
<pre class="source-code">
auto div = [](double x, double y) {
    if (y &lt; 0) { return 0; }
    return x / y;
};</pre> <p>This code will not compile because the compiler will fail to automatically deduce the return type <a id="_idIndexMarker410"/>of the lambda. It’s implementation logic has two execution branches. The first one returns an <code>integer</code> literal, <code>0</code>, but the other one returns<a id="_idIndexMarker411"/> the result of a division, the quotient, which is a <code>double</code> number.</p>
<p>In order to fix this, we need to explicitly specify that the return type of the lambda is <code>double</code>.</p>
<p>Here is an explicitly specified return type:</p>
<pre class="source-code">
auto div = [](double x, double y) -&gt; double {
    if (y &lt; 0) { return 0; }
    return x / y;
};</pre> <p>Now, for the compiler, it is clear that the return result is always converted to <code>double</code>.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>Summary</h1>
<p>In this chapter, we explored various aspects of objects in C++, including storage duration, scope, and lifetimes. We distinguished between objects and references and discussed different ways of initializing objects and when these initializations occur. Additionally, we delved into the world of functors, gaining an understanding of what they are and how to use them effectively. Building on that knowledge, we also learned about lambda expressions and their advantages over functors. We covered how to properly use both lambdas and functors with STL algorithms. Armed with this knowledge of object specifics, we can now move on to discussing error handling in C++ in the next chapter.</p>
</div>
</div></body></html>