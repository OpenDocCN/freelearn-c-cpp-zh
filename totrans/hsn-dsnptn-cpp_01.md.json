["```cpp\nclass Rational { public:\n  Rational& operator+=(const Rational& rhs);\n};\n```", "```cpp\nclass Rational {\n  public:\n  Rational& operator+=(const Rational& rhs); private:\n  long n_; // numerator\n  long d_; // denominator\n  void  reduce();\n};\nRational& Rational::operator+=(const Rational& rhs) {\n  n_ = n_*rhs.d_ + rhs.n_*d_;\n  d_ = d_*rhs.d_; reduce();\n  return *this;\n}\nRational a, b; a += b;\n```", "```cpp\nclass Rectangle {\n  public:\n  double Length() const { return length_; }\n  double Width() const { return width_; }\n  ...\n  private:\n  double l_;\n  double w_;\n};\nclass Square : public Rectangle {\n  ...\n};\n```", "```cpp\nclass Rectangle {\n  public:\n  void Scale(double sl, double sw) {\n     // Scale the dimensions\n    length_ *= sl;\n    width_ *= sw;\n  }\n  ...\n};\n```", "```cpp\nclass Base { ... };\nclass Derived : public Base { ... };\nDerived* d = new Derived;\nBase* b = d;    // Implicit conversion\n```", "```cpp\nBase* b = new Derived;     // *b is really Derived\nDerived* d = b; // Does not compile, not implicit Derived*\nDerived* d1 =\n     static_cast<Derived*>(b);    // Explicit conversion\n```", "```cpp\nclass Base1 { ... };\nclass Base2 { ... };\nclass Derived : public Base1, public Base2 { ... };\n```", "```cpp\n// Example 01_cast.C\nDerived d;\nDerived* p = &d;\nstd::cout << \"Derived: \" << (void*)(p) <<\n  \" Base1: \" << (void*)(static_cast<Base1*>(p)) <<\n  \" Base2: \" << (void*)(static_cast<Base2*>(p)) <<\n  std::endl;\n```", "```cpp\nDerived: 0x7f97e550 Base1: 0x7f97e550 Base2: 0x7f97e560\n```", "```cpp\nvoid f(Base2* p) {\n  if (p != nullptr) do_work(*p);\n}\nDerived* p = nullptr;\nf(p); // Will it try to dereference 0x10?\n```", "```cpp\nDerived* p = nullptr;\nstd::cout << \"Derived: \" << (void*)(p) <<\n  \" Base1: \" << (void*)(static_cast<Base1*>(p)) <<\n  \" Base2: \" << (void*)(static_cast<Base2*>(p)) <<\n  std::endl;\n```", "```cpp\nDerived: 0x0 Base1: 0x0 Base2: 0x0\n```", "```cpp\nclass Container : private std::vector<int> {\n  public:\n  using std::vector<int>::size;\n  ...\n};\n```", "```cpp\nclass Container {\n  private:\n  std::vector<int> v_;\n  public:\n  size_t size() const { return v_.size(); }\n  ...\n};\n```", "```cpp\nint x;     // Created at address 0xffff0000, size is 4\nint y;     // Created at address 0xffff0004\n```", "```cpp\nclass Empty {\n  public:\n  void useful_function();\n};\nclass Derived : private Empty {\n  int i;\n};    // sizeof(Derived) == 4\nclass Composed {\n  int i;\n  Empty e;\n};    // sizeof(Composed) == 8\n```", "```cpp\nDerived d;\nBase& b = d;\n...\nb.some_method(); // b is really a Derived object\n```", "```cpp\nclass FlyingBird : public Bird {\n  public:\n  virtual void fly(double speed, double direction) {\n    ... move the bird at the specified speed\n        in the given direction ...\n  }\n  ...\n};\n```", "```cpp\nclass Vulture : public FlyingBird {\n  public:\n  virtual void fly(double speed, double direction) {\n    ... move the bird but accumulate\n        exhaustion if too fast ...\n  }\n};\n```", "```cpp\nvoid hunt(FlyingBird& b) {\n  b.fly(...);    // Could be Vulture or Eagle\n  ...\n};\nEagle e;\nhunt(e);   // Now b in hunt() is Eagle\n           // FlyingBird::fly() is called\nVulture v;\nhunt(v);   // Now b in hunt() is Vulture\n           // Vulture::fly() is called\n```", "```cpp\nclass FlyingBird {\n  public:\n  virtual void fly(...) = 0;     // Pure virtual function\n};\n```", "```cpp\nclass Eagle : public FlyingBird {\n  public:\n  void fly(int speed, double direction);\n};\n```", "```cpp\nclass Eagle : public FlyingBird {\n  public:\n  void fly(int speed, double direction) override;\n};\n```", "```cpp\nclass Eagle : public FlyingBird {\n  public:\n  // All Eagles fly the same way, derived classes BaldEagle\n  // and GoldenEagle cannot change this.\n  void fly(int speed, double direction) final;\n};\n```", "```cpp\nvoid MakeLoudBoom(std::vector<FlyingBird*> birds)\n  for (auto bird : birds) {\n    bird->fly(...);   // Same action, different results\n  }\n}\n```", "```cpp\nclass Base {\n  public:\n  virtual void f() {\n      std::cout << \"Base::f()\" << std::endl;\n    }\n  void g() { f(); }\n};\nclass Derived : private Base {\n  public:\n  virtual void f() {\n    std::cout << \"Derived::f()\" << std::endl;\n  }\n  void h() { g(); }\n};\nDerived d;\nd.h(); // Prints \"Derived::f()\"\n```", "```cpp\nclass Base { ... };\nclass Derived : public Base { ... };\nBase* b1 = new Derived;     // Really Derived\nBase* b2 = new Base;   // Not Derived\nDerived* d1 = dynamic_cast<Derived*>(b1);  // Succeeds\nDerived* d2 = dynamic_cast<Derived*>(b2);  // d2 == nullptr\n```", "```cpp\n// Example 02_dynamic_cast.C\nclass Base {\n  protected:\n  int i = 0;\n  public:\n  virtual ~Base() {}\n  virtual int f() { return ++i; }\n};\nclass Derived : public Base {\n  int f() override { return --i; }\n};\nDerived* p = new Derived;\n// Measure the runtime of p->f();\n// Measure the runtime of dynamic_cast<Derived*>(p);\n```", "```cpp\nclass Eagle : public Bird, public FlyingAnimal { ... };\n```", "```cpp\nEagle* e = new Eagle;\nBird* b = e;\nFlyingAnimal* f = e;\n```", "```cpp\nBird* b = new Eagle;   // Also a FlyingAnimal\nFlyingAnimal* f = dynamic_cast<FlyingAnimal*>(b);\n```", "```cpp\nenum type_t { typeBase, typeDerived1, typeDerived2 };\nclass Base {\n  virtual type_t type() const { return typeBase; }\n};\nclass Derived1 : public Base {\n  type_t type() const override { return typeDerived1; }\n};\n…\nvoid process_derived1(Derived1* p);\nvoid do_work(Base* p) {\n  if (p->type() == typeDerived1) {\n    process_derived1(static_cast<Derived1*>(p));\n  }\n}\n```", "```cpp\nclass Empty1 {};\nclass Empty2 {};\nclass Derived : private Empty1, private Empty2 {\n  int i;\n};   // sizeof(Derived) == 4\nclass Composed {\n  int i;\n  Empty1 e1;\n  Empty2 e2;\n};   // sizeof(Composed) == 8\n```"]