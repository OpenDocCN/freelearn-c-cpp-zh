<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor089"/>4</h1>
<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>QPainter and 2D Graphics</h1>
<p>In this chapter, we will learn how to render 2D graphics on screen with Qt. Internally, Qt uses a low-level class called <code>QPainter</code> to render its widgets on the main window. Qt allows us to access and use the <code>QPainter</code> class for drawing vector graphics, text, 2D images, and even 3D graphics.</p>
<p>You can make use of the <code>QPainter</code> class to create your own custom widgets or to create programs that rely heavily on rendering computer graphics such as video games, photo editors, and 3D modeling tools.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Drawing basic shapes on the screen</li>
<li>Exporting shapes to <strong class="bold">Scalable Vector Graphics</strong> (<strong class="bold">SVG</strong>) files</li>
<li><strong class="bold">Coordinate transformation</strong></li>
<li>Displaying images on screen</li>
<li>Applying image effects to graphics</li>
<li>Creating a basic paint program</li>
<li>Rendering a 2D canvas in QML</li>
</ul>
<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>Technical requirements</h1>
<p>The technical requirements for this chapter include <strong class="bold">Qt 6.6.1 MinGW 64-bit</strong> and <strong class="bold">Qt Creator 12.0.2</strong>. All the code used in this chapter can be downloaded from the following GitHub repository: <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04</a>.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>Drawing basic shapes on the screen</h1>
<p>In this section, we will learn how to draw <a id="_idIndexMarker275"/>simple vector shapes (a line, a rectangle, a circle, and so on) and display text on the main window using the <code>QPainter</code> class. We will also learn how to change the drawing style of these vector shapes using the <code>QPen</code> class.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>How to do it…</h2>
<p>Let’s follow the steps listed here to display basic shapes in our Qt window:</p>
<ol>
<li>First, let’s create a new <strong class="bold">Qt Widgets </strong><strong class="bold">Application</strong> project.</li>
<li>Open up <code>mainwindow.ui</code> and remove the <code>menuBar</code>, <code>mainToolBar</code>, and <code>statusBar</code> objects so that we get a clean, empty main window. Right-click on the bar widgets and select <strong class="bold">Remove Menu Bar</strong> from the pop-up menu:</li>
</ol>
<div><div><img alt="Figure 4.1 – Removing the menu bar from the main window" src="img/B20976_04_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Removing the menu bar from the main window</p>
<ol>
<li value="3">Then, open up the <code>mainwindow.h</code> file and add the following code to include the <code>QPainter</code> header file:<pre class="source-code">
#include &lt;QMainWindow&gt;
#include &lt;QPainter&gt;</pre></li> <li>Then, declare the <code>paintEvent()</code> event handler below the class destructor:<pre class="source-code">
public:
explicit MainWindow(QWidget *parent = 0);
~MainWindow();
<code>mainwindow.cpp</code> file and define the <code>paintEvent()</code> event handler:<pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {}</pre></li> <li>After that, we will add<a id="_idIndexMarker276"/> text to the screen using the <code>QPainter</code> class inside the <code>paintEvent()</code> event handler. We set the text font settings before drawing it on the screen at the position of <code>(</code><code>20, 30)</code>:<pre class="source-code">
QPainter textPainter;
textPainter.begin(this);
<strong class="bold">textPainter.setFont(QFont("Times", 14, QFont::Bold));</strong>
<strong class="bold">textPainter.drawText(QPoint(20, 30), "Testing");</strong>
textPainter.end();</pre></li> <li>Then, we will draw a straight line that starts from <code>(50, 60)</code> and ends at <code>(</code><code>100, 100)</code>:<pre class="source-code">
QPainter linePainter;
linePainter.begin(this);
<strong class="bold">linePainter.drawLine(QPoint(50, 60), QPoint(100, 100));</strong>
linePainter.end();</pre></li> <li>We can also easily draw a rectangle by calling the <code>drawRect()</code> function using a <code>QPainter</code> class. This time, however, we also apply a background pattern to the shape before drawing it:<pre class="source-code">
QPainter rectPainter;
rectPainter.begin(this);
<strong class="bold">rectPainter.setBrush(Qt::BDiagPattern);</strong>
<strong class="bold">rectPainter.drawRect(QRect(40, 120, 80, 30));</strong>
rectPainter.end();</pre></li> <li>Next, declare a <code>QPen</code> class, set its color to <code>red</code>, and set its drawing style to <code>Qt::DashDotLine</code>. Then, apply<a id="_idIndexMarker277"/> the <code>QPen</code> class to <code>QPainter</code> and draw an ellipse shape at <code>(80, 200)</code> with a horizontal radius of <code>50</code> and a vertical radius of <code>20</code>:<pre class="source-code">
QPen ellipsePen;
ellipsePen.setColor(Qt::red);
ellipsePen.setStyle(Qt::DashDotLine);
QPainter ellipsePainter;
ellipsePainter.begin(this);
ellipsePainter.setPen(ellipsePen);
ellipsePainter.drawEllipse(QPoint(80, 200), 50, 20);
ellipsePainter.end();</pre></li> <li>We can also use the <code>QPainterPath</code> class to define a shape before passing it over to the <code>QPainter</code> class for rendering:<pre class="source-code">
QPainterPath rectPath;
rectPath.addRect(QRect(150, 20, 100, 50));
QPainter pathPainter;
pathPainter.begin(this);
pathPainter.setPen(QPen(Qt::red, 1, Qt::DashDotLine,
Qt::FlatCap, Qt::MiterJoin));
pathPainter.setBrush(Qt::yellow);
pathPainter.drawPath(rectPath);
pathPainter.end();</pre></li> <li>You can also draw any <a id="_idIndexMarker278"/>other shapes by using <code>QPainterPath</code>, such as an ellipse:<pre class="source-code">
QPainterPath ellipsePath;
ellipsePath.addEllipse(QPoint(200, 120), 50, 20);
QPainter ellipsePathPainter;
ellipsePathPainter.begin(this);
ellipsePathPainter.setPen(QPen(QColor(79, 106, 25), 5,
Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin));
ellipsePathPainter.setBrush(QColor(122, 163, 39));
ellipsePathPainter.drawPath(ellipsePath);
ellipsePathPainter.end();</pre></li> <li><code>QPainter</code> can also be used to draw an image file onto the screen. In the following example, we load an image file called <code>tux.png</code> and draw it on the screen at the <code>(100, </code><code>150)</code> position:<pre class="source-code">
QImage image;
image.load("tux.png");
QPainter imagePainter(this);
imagePainter.begin(this);
imagePainter.drawImage(QPoint(100, 150), image);
imagePainter.end();</pre></li> <li>The final result should look something like this:</li>
</ol>
<div><div><img alt="Figure 4.2 – Tux the penguin is overwhelmed by the shapes and lines" src="img/B20976_04_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Tux the penguin is overwhelmed by the shapes and lines</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>How it works...</h2>
<p>If you want to draw something on screen using <code>QPainter</code>, all you need to do is tell it what type of graphics it should be drawing (as in text, a vector shape, an image, a polygon) with the desired position and size. The <code>QPen</code> class determines what the outline of the graphic should<a id="_idIndexMarker279"/> look like, such as its color, line width, line style (solid, dashed, or dotted), cap style, join style, and so on. On the other hand, <code>QBrush</code> sets the style of the background of the graphics, such as the background color, pattern (solid color, gradient, dense brush, and crossing diagonal lines), and pixmap.</p>
<p>The options for the graphics should be set before calling a <code>draw</code> function (such as <code>drawLine()</code>, <code>drawRect()</code>, or <code>drawEllipse()</code>). If your graphics do not appear on the screen and you see warnings such as <code>QPainter::setPen: Painter not active</code> and <code>QPainter::setBrush: Painter not active</code> appearing on the application output window in Qt Creator, it means that the <code>QPainter</code> class is not currently active and your program will not trigger its paint event. To solve this problem, set the main window as the parent of the <code>QPainter</code> class. Usually, if you’re writing code in the <code>mainwindow.cpp</code> file, all you need to do is to put <code>this</code> in the brackets when initializing <code>QPainter</code>. For example, note the following:</p>
<pre class="source-code">
QPainter linePainter(this);</pre> <p><code>QImage</code> can load images from both the computer directories and from the program resources.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>There’s more…</h2>
<p>Think of <code>QPainter</code> as a robot<a id="_idIndexMarker280"/> with a pen and an empty canvas. You just have to tell the<a id="_idIndexMarker281"/> robot what type of shape it should be drawing and its location on the canvas, then the robot will do its job based on your description.</p>
<p>To make your life easier, the <code>QPainter</code> class also provides numerous functions, such as <code>drawArc()</code>, <code>drawEllipse()</code>, <code>drawLine()</code>, <code>drawRect()</code>, and <code>drawPie()</code>, which allow you to easily render a predefined shape. In Qt, all the widget classes (including the main window) have an event handler called <code>QWidget::paintEvent()</code>. This event handler will be triggered whenever the operating system thinks that the main window should re-draw its widgets. Many things can lead to that decision, such as the main window being scaled, a widget changing its state (that is, a button being pressed), or functions such as <code>repaint()</code> or <code>update()</code> being invoked manually in the code. Different operating systems may behave differently when it comes to deciding whether or not to trigger the update event on the same set of conditions. If you’re making a program that requires continuous and consistent graphical updates, call <code>repaint()</code> or <code>update()</code> manually with a timer.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Exporting shapes to SVG files</h1>
<p>SVG is an XML-based language for <a id="_idIndexMarker282"/>describing 2D vector graphics. Qt provides classes for <a id="_idIndexMarker283"/>saving vector shapes as SVG files. This feature can be used to create a simple vector graphics editor similar to Adobe Illustrator and Inkscape. In the next example, we will continue using the same project file from the previous example.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>How to do it…</h2>
<p>Let’s learn how to create a simple program that displays SVG graphics on screen:</p>
<ol>
<li>First of all, let’s create a <a id="_idIndexMarker284"/>menu bar by right-clicking the main window widget on the hierarchy window <a id="_idIndexMarker285"/>and selecting the <strong class="bold">Create Menu Bar</strong> option from the pop-up menu. After that, add a <strong class="bold">File</strong> option to the menu bar and a <strong class="bold">Save as SVG</strong> action underneath it:</li>
</ol>
<div><div><img alt="Figure 4.3 – Create a Save as SVG option on the menu bar" src="img/B20976_04_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Create a Save as SVG option on the menu bar</p>
<ol>
<li value="2">After that, you will see an item called <code>triggered()</code>, and click the <strong class="bold">OK</strong> button:</li>
</ol>
<div><div><img alt="Figure 4.4 – Creating a slot function for the triggered() signal" src="img/B20976_04_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Creating a slot function for the triggered() signal</p>
<ol>
<li value="3">Once you have clicked<a id="_idIndexMarker286"/> the <code>on_actionSave_as_SVG_triggered()</code> has been automatically added to your main window class. At the bottom of your <code>mainwindow.h</code> file, you will see something like this:<pre class="source-code">
void MainWindow::on_actionSave_as_SVG_triggered() {}</pre></li> <li>The preceding function is called when you click on the <code>QSvgGenerator</code> at the top of our source file. This header is very important as it’s required for generating SVG files. Then, we also need to include another class header called <code>QFileDialog</code>, which will be used to open the save dialog:<pre class="source-code">
#include &lt;QtSvg/QSvgGenerator&gt;
#include &lt;QFileDialog&gt;</pre></li> <li>We also need to add the <code>svg</code> module to our project file, like so:<pre class="source-code">
QT += core gui <code>paintAll()</code> within the <code>mainwindow.h</code> file, as shown in the following code:<pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    virtual void paintEvent(QPaintEvent *event);
<code>mainwindow.cpp</code> file, move all the code from <code>paintEvent()</code> to the <code>paintAll()</code> function. Then, replace all the individual <code>QPainter</code> objects<a id="_idIndexMarker288"/> with a single, unified <code>QPainter</code> for drawing all the<a id="_idIndexMarker289"/> graphics. Also, call the <code>begin()</code> function before drawing anything and call the <code>end()</code> function after finishing drawing. The code should look like this:<pre class="source-code">
void MainWindow::paintAll(QSvgGenerator *generator) {
    <strong class="bold">QPainter painter;</strong>
<strong class="bold">     if (engine)</strong>
<strong class="bold">         painter.begin(engine);</strong>
<strong class="bold">     else</strong>
<strong class="bold">         painter.begin(this);</strong>
<strong class="bold">     painter.setFont(QFont("Times", 14, QFont::Bold));</strong>
<strong class="bold">     painter.drawText(QPoint(20, 30), "Testing");</strong>
<strong class="bold">     painter.drawLine(QPoint(50, 60), QPoint(100, 100));</strong>
<strong class="bold">     painter.setBrush(Qt::BDiagPattern);</strong>
<strong class="bold">     painter.drawRect(QRect(40, 120, 80, 30));</strong></pre></li> <li>We go on to create <strong class="bold">ellipsePen</strong> and <strong class="bold">rectPath</strong>:<pre class="source-code">
    QPen ellipsePen;
    ellipsePen.setColor(Qt::red);
ellipsePen.setStyle(Qt::DashDotLine);
    painter.setPen(ellipsePen);
    painter.drawEllipse(QPoint(80, 200), 50, 20);
    QPainterPath rectPath;
    rectPath.addRect(QRect(150, 20, 100, 50));
    painter.setPen(QPen(Qt::red, 1, Qt::DashDotLine, Qt::FlatCap, Qt::MiterJoin));
    painter.setBrush(Qt::yellow);
    painter.drawPath(rectPath);</pre></li> <li>Then, we go <a id="_idIndexMarker290"/>on to create <code>ellipsePath</code> and <code>image</code>:<pre class="source-code">
    QPainterPath ellipsePath;
    ellipsePath.addEllipse(QPoint(200, 120), 50, 20);
    painter.setPen(QPen(QColor(79, 106, 25), 5, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin));
    painter.setBrush(QColor(122, 163, 39));
    painter.drawPath(ellipsePath);
    QImage image;
    image.load("tux.png");
    painter.drawImage(QPoint(100, 150), image);
    painter.end();
}</pre></li> <li>Since we have <a id="_idIndexMarker291"/>moved all the code from <code>paintEvent()</code> to <code>paintAll()</code>, we shall now call the <code>paintAll()</code> function inside <code>paintEvent()</code>, like so:<pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {
    <strong class="bold">paintAll();</strong>
}</pre></li> <li>Then, we will write the<a id="_idIndexMarker292"/> code for exporting the graphics as an SVG file. The<a id="_idIndexMarker293"/> code will be written inside the slot function called <code>on_actionSave_as_SVG_triggered()</code>, which was generated by Qt. We start by calling the save file dialog and obtain the directory path with the desired filename from the user:<pre class="source-code">
void MainWindow::on_actionSave_as_SVG_triggered() {
    <strong class="bold">QString filePath = QFileDialog::getSaveFileName(this, «Save SVG», «», «SVG files (*.svg)»);</strong>
<strong class="bold">    if (filePath == "")</strong>
<strong class="bold">        return;</strong>
}</pre></li> <li>After that, create a <code>QSvgGenerator</code> object and save the graphics to an SVG file by passing the <code>QSvgGenerator</code> object to the <code>paintAll()</code> function:<pre class="source-code">
void MainWindow::on_actionSave_as_SVG_triggered() {
    QString filePath = QFileDialog::getSaveFileName(this, "Save
SVG", "", "SVG files (*.svg)");
    if (filePath == "")
        return;
    <strong class="bold">QSvgGenerator generator;</strong>
<strong class="bold">    generator.setFileName(filePath);</strong>
<strong class="bold">    generator.setSize(QSize(this-&gt;width(), this-&gt;height()));</strong>
<strong class="bold">    generator.setViewBox(QRect(0, 0, this-&gt;width(), this-&gt;height()));</strong>
<strong class="bold">    generator.setTitle("SVG Example");</strong>
<strong class="bold">    generator.setDescription("This SVG file is generated by Qt.");</strong>
<strong class="bold">    paintAll(&amp;generator);</strong>
}</pre></li> <li>Now, compile and <a id="_idIndexMarker294"/>run the program and you should be able to <a id="_idIndexMarker295"/>export the graphics by going to <strong class="bold">File</strong> | <strong class="bold">Save </strong><strong class="bold">as SVG</strong>:</li>
</ol>
<div><div><img alt="Figure 4.5 – Comparing the results between our program and the SVG file on a web browser" src="img/B20976_04_005.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Comparing the results between our program and the SVG file on a web browser</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/>How it works...</h2>
<p>By default, <code>QPainter</code> will use the paint engine from its parent object to draw the graphics assigned to it. If you don’t assign any parent to <code>QPainter</code>, you can manually assign a paint engine to it, which is what we have done in this example.</p>
<p>The reason why we placed the code into <code>paintAll()</code> is that we want to reuse the same code for two different purposes: for displaying the graphics on the window and exporting the graphics to an SVG <a id="_idIndexMarker296"/>file. You can see that the default value of the generator variable in the <code>paintAll()</code> function is set to <code>0</code>, which means no <code>QSvgGenerator</code> object is required to run<a id="_idIndexMarker297"/> the function unless specified. Later on, in the <code>paintAll()</code> function, we check whether the generator object exists. If it does exist, use it as the paint engine for the painter, as shown in the following code:</p>
<pre class="source-code">
if (engine)
    painter.begin(engine);
else
    painter.begin(this);</pre> <p>Otherwise, pass the main window to the <code>begin()</code> function (since we’re writing the code in the <code>mainwindow.cpp</code> file, we can directly use this to refer to the main window’s pointer) so that it will use the paint engine of the main window itself, which means the graphics will be drawn onto the surface of the main window. In this example, it’s required to use a single <code>QPainter</code> object to save the graphics into the SVG file. If you use multiple <code>QPainter</code> objects, the resulting SVG file will contain multiple XML header definitions, and thus the file will be deemed to be invalid by any graphics editor software out there.</p>
<p><code>QFileDialog::getSaveFileName()</code> will open up the native save file dialog for the user to choose the save directory and set a desired filename. Once the user is done with that, the full path will be returned as a string, and we will be able to pass that information to the <code>QSvgGenerator</code> object to export the graphics.</p>
<p>Notice that in the previous screenshot, the penguin in the SVG file has been cropped. This is because the canvas size of the SVG was set to follow the size of the main window. To help the poor penguin get its body back, scale the window bigger before exporting the SVG file.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>There’s more…</h2>
<p>SVG defines the graphics in XML format. Since it is a form of vector graphics, SVG files do not lose any quality if they are <a id="_idIndexMarker298"/>zoomed in on or resized. The SVG format not only allows you to store vector graphics in <a id="_idIndexMarker299"/>the working file, but it also allows you to store raster graphics and text, which is more or less similar to Adobe Illustrator’s format. The SVG also allows you to group, style, transform, and composite graphical objects into previously rendered objects.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can check out the full specification of SVG graphics at <a href="https://www.w3.org/TR/SVG">https://www.w3.org/TR/SVG</a>.</p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/>Coordinate transformation</h1>
<p>In this example, we will learn <a id="_idIndexMarker300"/>how to use coordinate transformation and a timer to create a real-time clock display.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor101"/>How to do it…</h2>
<p>To create our first graphical clock display, let’s follow these steps:</p>
<ol>
<li>First, create a new <code>mainwindow.ui</code> and remove the <code>menuBar</code>, <code>mainToolBar</code>, and <code>statusBar</code> as we did before.</li>
<li>After that, open up the <code>mainwindow.h</code> file and include the following headers:<pre class="source-code">
#include &lt;QTime&gt;
#include &lt;QTimer&gt;
#include &lt;QPainter&gt;</pre></li> <li>Then, declare the <code>paintEvent()</code> function, like so:<pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    <code>mainwindow.cpp</code> file, create three arrays to store the shapes of the hour hand, minute hand, and <a id="_idIndexMarker301"/>second hand, where each of the arrays contains three sets of coordinates:<pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {
    <strong class="bold">static const QPoint hourHand[3] = {</strong>
<strong class="bold">        QPoint(4, 4),</strong>
<strong class="bold">        QPoint(-4, 4),</strong>
<strong class="bold">        QPoint(0, -40)</strong>
<strong class="bold">    </strong><strong class="bold">};</strong>
<strong class="bold">    static const QPoint minuteHand[3] = {</strong>
<strong class="bold">        QPoint(4, 4),</strong>
<strong class="bold">        QPoint(-4, 4),</strong>
<strong class="bold">        QPoint(0, -70)</strong>
<strong class="bold">    };</strong>
<strong class="bold">    static const QPoint secondHand[3] = {</strong>
<strong class="bold">        QPoint(2, 2),</strong>
<strong class="bold">        QPoint(-2, 2),</strong>
<strong class="bold">        QPoint(0, -90)</strong>
<strong class="bold">    </strong><strong class="bold">};</strong>
}</pre></li> <li>After that, add the following code below the arrays to create the painter and move it to the center of the main window. Also, we adjust the size of the painter so that it fits nicely in the main window, even when the window is being resized:<pre class="source-code">
int side = qMin(width(), height());
QPainter painter(this);
painter.setRenderHint(QPainter::Antialiasing);
painter.translate(width() / 2, height() / 2);
painter.scale(side / 250.0, side / 250.0);</pre></li> <li>Once you are done with that, we will start drawing the dials by using a for loop. Each dial is rotated by <a id="_idIndexMarker302"/>an increment of 6 degrees, so 60 dials would complete a full circle. Also, the dial will look slightly longer at every five minutes:<pre class="source-code">
for (int i = 0; i &lt; 60; ++i) {
    if ((i % 5) != 0)
        painter.drawLine(92, 0, 96, 0);
    else
        painter.drawLine(86, 0, 96, 0);
    painter.rotate(6.0);
}</pre></li> <li>Then, we proceed with drawing the hands of the clock. Each hand’s rotation is calculated according to the current time and its respective equivalent location over 360 degrees:<pre class="source-code">
QTime time = QTime::currentTime();
// Draw hour hand
painter.save();
painter.rotate((time.hour() * 360) / 12);
painter.setPen(Qt::NoPen);
painter.setBrush(Qt::black);
painter.drawConvexPolygon(hourHand, 3);
painter.restore();</pre></li> <li>Let’s draw the minute hand of the clock:<pre class="source-code">
// Draw minute hand
painter.save();
painter.rotate((time.minute() * 360) / 60);
painter.setPen(Qt::NoPen);
painter.setBrush(Qt::black);
painter.drawConvexPolygon(minuteHand, 3);
painter.restore();</pre></li> <li>Then, we also draw the <a id="_idIndexMarker303"/>hand for seconds:<pre class="source-code">
// Draw second hand
painter.save();
painter.rotate((time.second() * 360) / 60);
painter.setPen(Qt::NoPen);
painter.setBrush(Qt::black);
painter.drawConvexPolygon(secondHand, 3);
painter.restore();</pre></li> <li>Last, but not least, create a timer to refresh the graphics every second so that the program will work like a real clock:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    <strong class="bold">QTimer* timer = new QTimer(this);</strong>
<strong class="bold">    timer-&gt;start(1000);</strong>
    connect(timer, QTimer::timeout, this, MainWindow::update);
}</pre></li> <li>Compile and run the<a id="_idIndexMarker304"/> program now, and you should see something like this:</li>
</ol>
<div><div><img alt="Figure 4.6 – A real-time analog clock displayed on the Qt application" src="img/B20976_04_006.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – A real-time analog clock displayed on the Qt application</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor102"/>How it works...</h2>
<p>Each of the arrays contains three <code>QPoint</code> data instances, which form the shape of an elongated triangle. The arrays are then passed to the painter and rendered as a convex polygon using the <code>drawConvexPolygon()</code> function. Before drawing each of the clock hands, we use <code>painter.save()</code> to save the state of the <code>QPainter</code> object and then proceed with drawing the hand using coordinate transformation.</p>
<p>Once we’re done with the drawing, we restore the painter to its previous state by calling <code>painter.restore()</code>. This function will undo all the transformations before <code>painter. restore()</code> so that the next clock hand will not inherit the transformations of the previous one. Without using <code>painter.save()</code> and <code>painter.restore()</code>, we will have to manually change the position, rotation, and scale before drawing the next hand.</p>
<p>A good example of not using <code>painter.save()</code> and <code>painter.restore()</code> is when drawing the dials. Since each dial’s rotation is an increment of six degrees from the previous one, we don’t need to save the painter’s state at all. We just have to call <code>painter.rotate(6.0)</code> in a loop and each dial will inherit the previous dial’s rotation. We also use a modulus operator (<code>%</code>) to check whether the unit represented by the dial can be divided by five. If it can, then we draw it slightly longer.</p>
<p>Without using a timer to <a id="_idIndexMarker305"/>constantly call the <code>update()</code> slot, the clock will not function properly. This is because <code>paintEvent()</code> will not be called by Qt when there is no change to the state of the parent widget, which in this case is the main window. Therefore, we need to manually tell Qt that we need to refresh the graphics by calling <code>update()</code> every second.</p>
<p>We used the <code>painter.setRenderHint(QPainter::Antialiasing)</code> function to enable anti-aliasing when rendering the clock. Without anti-aliasing, the graphics will look very jagged and pixelated:</p>
<div><div><img alt="Figure 4.7 – Anti-aliasing produces a smoother result" src="img/B20976_04_007.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Anti-aliasing produces a smoother result</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor103"/>There’s more…</h2>
<p>The <code>QPainter</code> class uses the coordinate system to determine the position and size of the graphics before rendering them on screen. This information can be altered to make the graphics appear at a different position, rotation, and size. This process of altering the coordinate information of a graphic is what we call coordinate transformation. There are<a id="_idIndexMarker306"/> several types<a id="_idIndexMarker307"/> of transformation: among<a id="_idIndexMarker308"/> them <a id="_idIndexMarker309"/>are <strong class="bold">translation</strong>, <strong class="bold">rotation</strong>, <strong class="bold">scaling</strong>, and <strong class="bold">shearing</strong>:</p>
<div><div><img alt="Figure 4.8 – Different types of transformations" src="img/B20976_04_008.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Different types of transformations</p>
<p>Qt uses a coordinate system that has its origin at the top-left corner, meaning the <em class="italic">x</em> values increase to the right and the <em class="italic">y</em> values increase downward. This coordinate system might be different from the coordinate system used by the physical device, such as a computer screen. Qt handles <a id="_idIndexMarker310"/>this automatically by using the <code>QPaintDevice</code> class, which maps Qt’s logical coordinates to the physical coordinates.</p>
<p><code>QPainter</code> provides four transform operations to perform different types of transformation:</p>
<ul>
<li><code>QPainter::translate()</code>: This offsets the graphic’s position by a given set of units</li>
<li><code>QPainter::rotate()</code>: This rotates the graphics around the origin in a clockwise direction</li>
<li><code>QPainter::scale()</code>: This offsets the graphic’s size by a given factor</li>
<li><code>QPainter::shear()</code>: This twists the graphic’s coordinate system around the origin</li>
</ul>
<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/>Displaying images on screen</h1>
<p>Qt not only allows us to draw shapes and images on screen, but it also allows us to overlay multiple images on top of<a id="_idIndexMarker311"/> each other and combine the pixel information from all the layers using different types of algorithms to create very interesting results. In this example, we will learn how to overlay images on top of each other and apply different composition effects to them.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>How to do it…</h2>
<p>Let’s create a simple demo that shows the effect of different image compositions by following these steps:</p>
<ol>
<li>First, set up a new <code>menuBar</code>, <code>mainToolBar</code>, and <code>statusBar</code>, as we did in the first recipe.</li>
<li>Next, add the <code>QPainter</code> class header to the <code>mainwindow.h</code> file:<pre class="source-code">
#include &lt;QPainter&gt;</pre></li> <li>After that, declare the <code>paintEvent()</code> virtual function, like so:<pre class="source-code">
virtual void paintEvent(QPaintEvent* event);</pre></li> <li>In <code>mainwindow.cpp</code>, we will first load several image files using the <code>QImage</code> class:<pre class="source-code">
void MainWindow::paintEvent(QPaintEvent* event) {
    <strong class="bold">QImage image;</strong>
<strong class="bold">    image.load("checker.png");</strong>
<strong class="bold">    QImage image2;</strong>
<strong class="bold">    image2.load("tux.png");</strong>
<strong class="bold">    QImage image3;</strong>
<strong class="bold">    image3.load("butterfly.png");</strong>
}</pre></li> <li>Then, create a <code>QPainter</code> object and use it to draw two pairs of images, where one image is on top of the other:<pre class="source-code">
QPainter painter(this);
painter.drawImage(QPoint(10, 10), image);
painter.drawImage(QPoint(10, 10), image2);
painter.drawImage(QPoint(300, 10), image);
painter.drawImage(QPoint(300, 40), image3);</pre></li> <li>Now, compile and run<a id="_idIndexMarker312"/> the program and you should see something like this:</li>
</ol>
<div><div><img alt="Figure 4.9 – Displaying images normally" src="img/B20976_04_009.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Displaying images normally</p>
<ol>
<li value="7">Next, we will set the composition mode before drawing each image on screen:<pre class="source-code">
QPainter painter(this);
painter.setCompositionMode(QPainter::CompositionMode_Difference);
painter.drawImage(QPoint(10, 10), image);
painter.setCompositionMode(QPainter::CompositionMode_Multiply);
painter.drawImage(QPoint(10, 10), image2);
painter.setCompositionMode(QPainter::CompositionMode_Xor);
painter.drawImage(QPoint(300, 10), image);
painter.setCompositionMode(QPainter::CompositionMode_SoftLight);
painter.drawImage(QPoint(300, 40), image3);</pre></li> <li>Compile and run the<a id="_idIndexMarker313"/> program again and you will now see something like this:</li>
</ol>
<div><div><img alt="Figure 4.10 – Applying different composition modes to the images" src="img/B20976_04_010.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Applying different composition modes to the images</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>How it works...</h2>
<p>When drawing images with Qt, the sequence of calling the <code>drawImage()</code> function will determine which image is being rendered first and which one is rendered later. This will affect the depth order of the images and yield different outcomes.</p>
<p>In the previous example, we called the <code>drawImage()</code> function four times to draw four different images on screen. The first <code>drawImage()</code> function renders <code>checker.png</code>, and the second <code>drawImage()</code> function renders <code>tux.png</code> (the penguin). The image that gets rendered later will always appear in front of the others, which is why the penguin is showing in front of the checkered pattern. The same goes for the butterfly and the checkered pattern on the right. The reason why you can still see the checkered pattern even though the butterfly is rendered in front of it is because the butterfly image is not fully opaque.</p>
<p>Now, let’s invert the render<a id="_idIndexMarker314"/> sequence and see what happens. We will try to render the penguin first, followed by the checkered box. The same goes for the other pair of images on the right: the butterfly gets rendered first, followed by the checkered box:</p>
<div><div><img alt="Figure 4.11 – Both the penguin and butterfly are covered by the checkered boxes" src="img/B20976_04_011.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Both the penguin and butterfly are covered by the checkered boxes</p>
<p>To apply a composition effect to the image, we’ll have to set the painter’s composition mode before drawing the image, by calling the <code>painter.setCompositionMode()</code> function. You can pick a desired composition mode from the auto-complete menu by typing <code>QPainter::CompositionMode</code>.</p>
<p>In the previous example, we applied <code>QPainter::CompositionMode_Difference</code> to the checkered box on the left, which inverted its color. Next, we applied <code>QPainter::CompositionMode_Overlay</code> to the penguin, which makes it blend with the checkered pattern, and were able to see both images overlaying each other. On the right-hand side, we applied <code>QPainter::CompositionMode_Xor</code> to the checkered box, where, if differences exist between the source and destination, colors are shown; otherwise, it will be rendered black.</p>
<p>Since it’s comparing differences with the white background, the non-transparent part of the checkered box becomes completely black. We also applied <code>QPainter::CompositionMode_SoftLight</code> to the butterfly image. This blends the pixels with the background with reduced contrast. If you want to disable the composition mode that <a id="_idIndexMarker315"/>you’ve just set for the previous rendering before proceeding to the next, simply set it back to the default mode, which is <code>QPainter::CompositionMode_SourceOver</code>.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/>There’s more…</h2>
<p>For example, we can overlay multiple images on top of each other and use Qt’s <strong class="bold">Image Composition</strong> feature to merge <a id="_idIndexMarker316"/>them together and calculate the resulting pixels on screen, based on the composition mode we used. This is often used in image editing software such as Photoshop and GIMP to composite image layers.</p>
<p>There are more than 30 types of composition <a id="_idIndexMarker317"/>modes available in Qt. Some of the most commonly used modes are as follows:</p>
<ul>
<li><code>Clear</code>: The pixels in the destination are set to fully transparent, independent of the source.</li>
<li><code>Source</code>: The output is the source pixel. This mode is the inverse of <code>CompositionMode_Destination</code>.</li>
<li><code>Destination</code>: The output is the destination pixel. This means that the blending has no effect. This mode is the inverse of <code>CompositionMode_Source</code>.</li>
<li><code>Source Over</code>: This is often referred to as <code>QPainter</code>.</li>
<li><code>Destination Over</code>: The output is the blend between the alpha of the destination on top of the source pixels. The opposite of this mode is <code>CompositionMode_SourceOver</code>.</li>
<li><code>Source In</code>: The output is the source, where the alpha is reduced by that of the destination.</li>
<li><code>Destination In</code>: The output is the destination, where the alpha is reduced by that of the source. This mode is the inverse of <code>CompositionMode_SourceIn</code>.</li>
<li><code>Source Out</code>: The output is the<a id="_idIndexMarker319"/> source, where the alpha is reduced by the inverse of the destination.</li>
<li><code>Destination Out</code>: The output is the destination, where the alpha is reduced by the inverse of the source. This mode is the inverse of <code>CompositionMode_SourceOut</code>.</li>
<li><code>Source Atop</code>: The source pixel is blended on top of the destination, with the alpha of the source pixel reduced by the alpha of the destination pixel.</li>
<li><code>Destination Atop</code>: The destination pixel is blended on top of the source, with the alpha of the source pixel reduced by the alpha of the destination pixel. This mode is the inverse of <code>CompositionMode_SourceAtop</code>.</li>
<li><code>Xor</code>: This is short for <code>Exclusive OR</code>, which is an advanced blending mode that is primarily used for image analysis. Using this is much more complicated with this composition mode. First, the alpha of the source is reduced by the inverse of the destination alpha. Then, the alpha of the destination is reduced by the inverse of the source alpha. Finally, both the source and destination are then merged to produce the output.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more information, you can visit this link: <a href="https://pyside.github.io">https://pyside.github.io</a>.</p>
<p>The following figure shows the outcome of overlaying two images with different composition modes:</p>
<div><div><img alt="Figure 4.12 – Different types of composition modes" src="img/B20976_04_012.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Different types of composition modes</p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Applying image effects to graphics</h1>
<p>Qt provides an easy way to <a id="_idIndexMarker320"/>add image effects to any graphics drawn using the <code>QPainter</code> class. In this example, we will learn how to apply different image effects, such as <a id="_idIndexMarker321"/>drop shadow, blur, colorize, and opacity effects, to a graphic before displaying it on screen.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>How to do it…</h2>
<p>Let’s learn how to apply image effects to text and graphics by following these steps:</p>
<ol>
<li>Create a new <code>menuBar</code>, <code>mainToolBar</code>, and <code>StatusBar</code>.</li>
<li>Create a new resource file by going to <strong class="bold">File</strong> | <strong class="bold">New File or Project</strong> and add all the images required by the project:</li>
</ol>
<div><div><img alt="Figure 4.13 – Creating a new Qt resource file" src="img/B20976_04_013.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Creating a new Qt resource file</p>
<ol>
<li value="3">Next, open up <code>mainwindow.ui</code> and<a id="_idIndexMarker322"/> add four labels to the window. Two of <a id="_idIndexMarker323"/>the labels will be text, and the two others we will load with the images we have just added to the resource file:</li>
</ol>
<div><div><img alt="Figure 4.14 – Application filled with text and images" src="img/B20976_04_014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Application filled with text and images</p>
<ol>
<li value="4">You may already notice that<a id="_idIndexMarker324"/> the font sizes are way bigger than the default size. That can be achieved <a id="_idIndexMarker325"/>by adding a style sheet to the label widget, for example, as follows:<pre class="source-code">
font: 26pt "MS Gothic";</pre></li> <li>After that, open up <code>mainwindow.cpp</code> and include the following headers at the top of the source code:<pre class="source-code">
#include &lt;QGraphicsBlurEffect&gt;
#include &lt;QGraphicsDropShadowEffect&gt;
#include &lt;QGraphicsColorizeEffect&gt;
#include &lt;QGraphicsOpacityEffect&gt;</pre></li> <li>Then, within the constructor of the <code>MainWindow</code> class, add the following code to create a <code>DropShadowEffect</code>, and apply it to one of the labels:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
ui-&gt;setupUi(this);
<strong class="bold">QGraphicsDropShadowEffect* shadow = new QGraphicsDropShadowEffect();</strong>
<strong class="bold">shadow-&gt;setXOffset(4);</strong>
<strong class="bold">shadow-&gt;setYOffset(4);</strong>
<strong class="bold">ui-&gt;label-&gt;setGraphicsEffect(shadow);</strong>
}</pre></li> <li>Next, we will create <code>ColorizedEffect</code> and apply it to one of the images, in this case, the <a id="_idIndexMarker326"/>butterfly. We also set the effect color to<a id="_idIndexMarker327"/> red:<pre class="source-code">
QGraphicsColorizeEffect* colorize = new
QGraphicsColorizeEffect();
colorize-&gt;setColor(QColor(255, 0, 0));
ui-&gt;butterfly-&gt;setGraphicsEffect(colorize);</pre></li> <li>Once we’re done with that, create <code>BlurEffect</code> and set its radius to <code>12</code>. Then, apply the graphics effect to the other label:<pre class="source-code">
QGraphicsBlurEffect* blur = new QGraphicsBlurEffect();
blur-&gt;setBlurRadius(12);
ui-&gt;label2-&gt;setGraphicsEffect(blur);</pre></li> <li>Lastly, create an alpha effect and apply it to the penguin image. We set the opacity value to <code>0.2</code>, which means 20% opacity:<pre class="source-code">
QGraphicsOpacityEffect* alpha = new QGraphicsOpacityEffect();
alpha-&gt;setOpacity(0.2);
ui-&gt;penguin-&gt;setGraphicsEffect(alpha);</pre></li> <li>Now, compile and run the program and you should be able to see something like this:</li>
</ol>
<div><div><img alt="Figure 4.15 – Different types of graphics effects being applied to the texts and images" src="img/B20976_04_015.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Different types of graphics effects being applied to the texts and images</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/>How it works...</h2>
<p>Each of the graphic effects is a class of its <a id="_idIndexMarker328"/>own that inherits the <code>QGraphicsEffect</code> parent class. You can create<a id="_idIndexMarker329"/> your own custom effect by creating a new class that inherits <code>QGraphicsEffect</code> and re-implementing some of the functions in it.</p>
<p>Each effect has its own set of variables that are specifically created for it. For example, you can set the color of the colorized effect, but there is no such variable in the blur effect. This is because each effect is vastly different from the others, which is also why it needs to be a class of its own rather than using the same class for all the different effects.</p>
<p>It’s only possible to add a single graphics effect to a widget at a time. If you add more than one effect, only the last one will be applied to the widget, as it replaces the previous one. Other than that, be aware that if you create a graphics effect, for example, the drop shadow effect, you can’t assign it to two different widgets, as it will only get assigned to the last widget you applied it to. If you need to apply the same type of effect to several different widgets, create a few graphics effects of the same type and apply each of them to their respective widgets.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>There’s more…</h2>
<p>Currently, Qt supports blur, drop shadow, colorize, and opacity effects. These effects can be used by calling the following classes: <code>QGraphicsBlurEffect</code>, <code>QGraphicsDropShadowEffect</code>, <code>QGraphicsColorizeEffect</code>, and <code>QGraphicsOpacityEffect</code>. All these classes are inherited from the <code>QGraphicsEffect</code> class. You can also create<a id="_idIndexMarker330"/> your own custom image effect by creating a subclass of <code>QGrapicsEffect</code> (or any other existing effects) and re-implementing the <code>draw()</code> function.</p>
<p>The graphics effect changes only<a id="_idIndexMarker331"/> the bounding rectangle of the source. If you want to increase the margin of the bounding rectangle, re-implement the virtual <code>boundingRectFor()</code> function, and call <code>updateBoundingRect()</code> to notify the framework whenever this rectangle changes.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>Creating a basic paint program</h1>
<p>Since we have learned so much about the <code>QPainter</code> class and how to use it to display graphics on screen, I guess<a id="_idIndexMarker332"/> it’s time for us to do something fun where we can put our knowledge into practice.</p>
<p>In this recipe, we will learn how to make a basic paint program that allows us to draw lines on a canvas with different brush sizes and colors. We will also learn how to use the <code>QImage</code> class and mouse events in order to construct the paint program.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>How to do it…</h2>
<p>Let’s start our fun project with the following steps:</p>
<ol>
<li>Again, we start by creating a new <strong class="bold">Qt Widgets Application</strong> project and removing the toolbar and status bar. We will keep the menu bar this time.</li>
<li>After that, set up the menu bar like so:</li>
</ol>
<div><div><img alt="Figure 4.16 – Setting up the menu bar" src="img/B20976_04_016.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – Setting up the menu bar</p>
<ol>
<li value="3">We will leave the menu bar as it is for the moment, so let’s proceed to the <code>mainwindow.h</code> file. First, include<a id="_idIndexMarker333"/> the following header files, as they are required for the project:<pre class="source-code">
#include &lt;QPainter&gt;
#include &lt;QMouseEvent&gt;
#include &lt;QFileDialog&gt;</pre></li> <li>Next, declare the variables that we’ll be using for this project, like so:<pre class="source-code">
private:
    Ui::MainWindow *ui;
    <strong class="bold">QImage image;</strong>
<strong class="bold">    bool drawing;</strong>
<strong class="bold">    QPoint lastPoint;</strong>
<strong class="bold">    int brushSize;</strong>
<code>QWidget</code> class. These functions will be triggered by Qt when the respective event happens. We will override these functions and tell Qt what to do when these events get called:<pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    <strong class="bold">virtual void mousePressEvent(QMouseEvent *event);</strong>
<strong class="bold">    virtual void mouseMoveEvent(QMouseEvent *event);</strong>
<strong class="bold">    virtual void mouseReleaseEvent(QMouseEvent *event);</strong>
<strong class="bold">    virtual void paintEvent(QPaintEvent *event);</strong>
<code>mainwindow.cpp</code> file and add the following code to the class constructor to set up some <a id="_idIndexMarker334"/>of the variables:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    <strong class="bold">image = QImage(this-&gt;size(), QImage::Format_RGB32);</strong>
<strong class="bold">    </strong><strong class="bold">image.fill(Qt::white);</strong>
<strong class="bold">    drawing = false;</strong>
<strong class="bold">    brushColor = Qt::black;</strong>
<strong class="bold">    brushSize = 2;</strong>
}</pre></li> <li>Next, we will construct the <code>mousePressEvent()</code> event and tell Qt what to do when the left mouse button is pressed:<pre class="source-code">
void MainWindow::mousePressEvent(QMouseEvent *event) {
    <strong class="bold">if (event-&gt;button() == Qt::LeftButton) {</strong>
<strong class="bold">        drawing = true;</strong>
<strong class="bold">        lastPoint = event-&gt;pos();</strong>
<strong class="bold">    }</strong>
}</pre></li> <li>Then, we will construct the <code>mouseMoveEvent()</code> event and tell Qt what to do when the mouse is moving. In this case, we want to draw the lines on the canvas if the left mouse button is<a id="_idIndexMarker335"/> being held:<pre class="source-code">
void MainWindow::mouseMoveEvent(QMouseEvent *event) {
    <strong class="bold">if ((event-&gt;buttons() &amp; Qt::LeftButton) &amp;&amp; drawing) {</strong>
<strong class="bold">        QPainter painter(&amp;image);</strong>
<strong class="bold">        painter.setPen(QPen(brushColor, brushSize, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));</strong>
<strong class="bold">        painter.drawLine(lastPoint, event-&gt;pos());</strong>
<strong class="bold">lastPoint = event-&gt;pos();</strong>
<strong class="bold">         this-&gt;update();</strong>
<strong class="bold">    }</strong>
}</pre></li> <li>After that, we will also construct the <code>mouseReleaseEvent()</code> event, which will be triggered when the mouse button is released:<pre class="source-code">
void MainWindow::mouseReleaseEvent(QMouseEvent *event) {
    <strong class="bold">if (event-&gt;button() == Qt::LeftButton) {</strong>
<strong class="bold">        drawing = false;</strong>
<strong class="bold">    }</strong>
}</pre></li> <li>Once you’re done with that, we will proceed to the <code>paintEvent()</code> event, which is surprisingly simple compared to the other examples we have seen in previous sections:<pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {
    <strong class="bold">QPainter canvasPainter(this);</strong>
<strong class="bold">    canvasPainter.drawImage(this-&gt;rect(), image, image.rect());</strong>
}</pre></li> <li>Remember how we have a<a id="_idIndexMarker336"/> menu bar sitting around doing nothing? Let’s right-click on each of the actions below the GUI editor and select <strong class="bold">Go to slot…</strong> in the pop-up menu. We want to tell Qt what to do when each of these options on the menu bar is selected:</li>
</ol>
<div><div><img alt="Figure 4.17 – Creating slot function for each of the menu actions" src="img/B20976_04_017.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – Creating slot function for each of the menu actions</p>
<ol>
<li value="12">Then, select the default slot called <code>triggered()</code> and press the <code>mainwindow.h</code> and <code>mainwindow.cpp</code> files. Once you are done with all the actions, you should see something like this in your <code>mainwindow.h</code> file:<pre class="source-code">
private slots:
    void on_actionSave_triggered();
    void on_actionClear_triggered();
    void on_action2px_triggered();
    void on_action5px_triggered();
    void on_action10px_triggered();
    void on_actionBlack_triggered();
    void on_actionWhite_triggered();
    void on_actionRed_triggered();
    void on_actionGreen_triggered();
    void on_actionBlue_triggered();</pre></li> <li>Next, we will tell Qt what <a id="_idIndexMarker337"/>to do when each of these slots is triggered:<pre class="source-code">
void MainWindow::on_actionSave_triggered() {
    <strong class="bold">QString filePath = QFileDialog::getSaveFileName(this, «Save Image», «», «PNG (*.png);;JPEG (*.jpg *.jpeg);;All files</strong>
<strong class="bold">(*.*)»);</strong>
<strong class="bold">    if (filePath == "")</strong>
<strong class="bold">        </strong><strong class="bold">return;</strong>
<strong class="bold">    image.save(filePath);</strong>
}
void MainWindow::on_actionClear_triggered() {
    <strong class="bold">image.fill(Qt::white);</strong>
<strong class="bold">    this-&gt;update();</strong>
}</pre></li> <li>Then, we continue to<a id="_idIndexMarker338"/> implement the other slots:<pre class="source-code">
void MainWindow::on_action2px_triggered() {
    <strong class="bold">brushSize = 2;</strong>
}
void MainWindow::on_action5px_triggered() {
    <strong class="bold">brushSize = 5;</strong>
}
void MainWindow::on_action10px_triggered() {
    <strong class="bold">brushSize = 10;</strong>
}
void MainWindow::on_actionBlack_triggered() {
    <strong class="bold">brushColor = Qt::black;</strong>
}</pre></li> <li>Finally, we implement the rest of the slot functions:<pre class="source-code">
void MainWindow::on_actionWhite_triggered() {
    <strong class="bold">brushColor = Qt::white;</strong>
}
void MainWindow::on_actionRed_triggered() {
    <strong class="bold">brushColor = Qt::red;</strong>
}
void MainWindow::on_actionGreen_triggered() {
    <strong class="bold">brushColor = Qt::green;</strong>
}
void MainWindow::on_actionBlue_triggered() {
    <strong class="bold">brushColor = Qt::blue;</strong>
}</pre></li> <li>If we compile and run the <a id="_idIndexMarker339"/>program now, we will get a simple but usable paint program:</li>
</ol>
<div><div><img alt="Figure 4.18 – Our lovely paint program in action!" src="img/B20976_04_018.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – Our lovely paint program in action!</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>How it works...</h2>
<p>In this example, we created a <code>QImage</code> widget when the program started. This widget acts as the canvas and will follow the size of the window whenever the window gets resized. In order to draw something on the canvas, we will need to use the mouse events provided by Qt. These events will tell us the position of the cursor, and we will be able to use this information to change the pixels on the canvas.</p>
<p>We use a Boolean variable called <code>drawing</code> to let the program know whether it should start drawing when a mouse button is pressed. In this case, when the left mouse button is pressed, the <code>drawing</code> variable will be set to <code>true</code>. We also save the current cursor position to the <code>lastPoint</code> variable when the left mouse button is pressed, so that Qt will know where it should start drawing. When the mouse moves, the <code>mouseMoveEvent()</code> event will be triggered by Qt. This is where we need to check whether the drawing variable is set to <code>true</code>. If it is, then <code>QPainter</code> can start drawing the lines onto the <code>QImage</code> widget based on the brush settings that we provide. The brush settings consist of <code>brushColor</code> and <code>brushSize</code>. These settings are saved as variables and can be altered by selecting a different setting from the menu bar.</p>
<p>Please remember to call the <code>update()</code> function when the user is drawing on the canvas. Otherwise, the canvas will remain empty even though we have changed the pixel information of the canvas. We also have to call the <code>update()</code> function when we select <strong class="bold">File</strong> | <strong class="bold">Clear</strong> from the menu bar to reset our canvas.</p>
<p>In this example, we use <code>QImage::save()</code> to save the image file, which is very straightforward. We use the file dialog<a id="_idIndexMarker340"/> to let the user decide where to save the image and its desired filename. Then, we pass the information to <code>QImage</code>, and it will do the rest by itself. If we don’t specify the file format to the <code>QImage::save()</code> function, <code>QImage</code> will try to figure it out by looking at the extension of the desired filename.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor115"/>Rendering a 2D canvas in QML</h1>
<p>In all the previous examples <a id="_idIndexMarker341"/>of this chapter, we have discussed the methods and techniques <a id="_idIndexMarker342"/>used to render 2D graphics with Qt’s C++ API. However, we have yet to learn how to achieve similar results using the powerful QML script.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>How to do it…</h2>
<p>In this project, we’ll be doing something quite different:</p>
<ol>
<li>As usual, the first step is to create a new project by going to <strong class="bold">File</strong> | <strong class="bold">New File or Project</strong> and selecting <strong class="bold">Qt Quick Application</strong> as the project template:</li>
</ol>
<div><div><img alt="Figure 4.19 – Creating a new Qt Quick Application project" src="img/B20976_04_019.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – Creating a new Qt Quick Application project</p>
<ol>
<li value="2">Once you are done creating <a id="_idIndexMarker343"/>the new project, open up <code>main.qml</code>, which is<a id="_idIndexMarker344"/> listed under <code>qml.qrc</code> in the project pane. After that, set an ID for the window and adjust its <code>width</code> and <code>height</code> values to larger values, like so:<pre class="source-code">
import QtQuick
import QtQuick.Window
Window {
    <strong class="bold">id: myWindow</strong>
<strong class="bold">    visible: true</strong>
<strong class="bold">    width: 640</strong>
<strong class="bold">    height: 480</strong>
<strong class="bold">    title: qsTr("Hello World")</strong>
}</pre></li> <li>Then, add a <code>Canvas</code> object under <code>myWindow</code> and call it <code>myCanvas</code>. After that, we make its <code>width</code> and <code>height</code> values the same as <code>myWindow</code>:<pre class="source-code">
Window {
    id: myWindow
    visible: true
    width: 640
    height: 480
    <strong class="bold">Canvas {</strong>
<strong class="bold">        id: myCanvas</strong>
<strong class="bold">        width: myWindow.width</strong>
<strong class="bold">        height: myWindow.height</strong>
<strong class="bold">    }</strong>
}</pre></li> <li>Next, we define what<a id="_idIndexMarker345"/> will happen when the <code>onPaint</code> event is triggered; in this <a id="_idIndexMarker346"/>case, we will draw a cross on the window:<pre class="source-code">
Canvas {
    id: myCanvas
    width: myWindow.width
    height: myWindow.height
    <strong class="bold">onPaint: {</strong>
<strong class="bold">        var context = getContext('2d')</strong>
<strong class="bold">        </strong><strong class="bold">context.fillStyle = 'white'</strong>
<strong class="bold">        context.fillRect(0, 0, width, height)</strong>
<strong class="bold">        context.lineWidth = 2</strong>
<strong class="bold">        context.strokeStyle = 'black'</strong></pre></li> <li>Let’s continue to write<a id="_idIndexMarker347"/> the code, like so:<pre class="source-code">
// Draw cross
context.beginPath()
context.moveTo(50, 50)
context.lineTo(100, 100)
context.closePath()
context.stroke()
context.beginPath()
context.moveTo(100, 50)
context.lineTo(50, 100)
context.closePath()
context.stroke()
}
}</pre></li> <li>After that, we add the<a id="_idIndexMarker348"/> following code to draw a tick beside the cross:<pre class="source-code">
// Draw tick
context.beginPath()
context.moveTo(150, 90)
context.lineTo(158, 100)
context.closePath()
context.stroke()
context.beginPath()
context.moveTo(180, 100)
context.lineTo(210, 50)
context.closePath()
context.stroke()</pre></li> <li>Then, draw a triangle shape<a id="_idIndexMarker349"/> by adding the following code:<pre class="source-code">
// Draw triangle
context.lineWidth = 4
context.strokeStyle = "red"
context.fillStyle = "salmon"
context.beginPath()
context.moveTo(50,150)
context.lineTo(150,150)
context.lineTo(50,250)
context.closePath()
context.fill()
context.stroke()</pre></li> <li>After that, draw a half<a id="_idIndexMarker350"/> circle and a full circle with the following code:<pre class="source-code">
// Draw circle
context.lineWidth = 4
context.strokeStyle = "blue"
context.fillStyle = "steelblue"
var pi = 3.141592653589793
context.beginPath()
context.arc(220, 200, 60, 0, pi, true)
context.closePath()
context.fill()
context.stroke()</pre></li> <li>Then, we draw an<a id="_idIndexMarker351"/> arc:<pre class="source-code">
context.beginPath()
context.arc(220, 280, 60, 0, 2 * pi, true)
context.closePath()
context.fill()
context.stroke()</pre></li> <li>Finally, we draw a 2D<a id="_idIndexMarker352"/> image from a file:<pre class="source-code">
// Draw image
context.drawImage("tux.png", 280, 10, 150, 174)</pre></li> <li>However, the preceding code alone will not successfully render an image on screen because you must also load the image file beforehand. Add the following code within the <code>Canvas</code> object to ask QML to load the image file when the program is started, then call the <code>requestPaint()</code> signal when the image is loaded so that the <code>onPaint()</code> event slot will be triggered:<pre class="source-code">
onImageLoaded: requestPaint();
onPaint: {
    // The code we added previously
}</pre></li> <li>Then, open up <code>qml.qrc</code> by right-clicking it in the project panel and select <code>tux.png</code> image file to our project resource:</li>
</ol>
<div><div><img alt="Figure 4.20 – The tux.png image file is now listed under qml.qrc" src="img/B20976_04_020.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – The tux.png image file is now listed under qml.qrc</p>
<ol>
<li value="13">Now, build and run the <a id="_idIndexMarker353"/>program and you should get the<a id="_idIndexMarker354"/> following:</li>
</ol>
<div><div><img alt="Figure 4.21 – Tux the penguin is amused by the geometrical shapes" src="img/B20976_04_021.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21 – Tux the penguin is amused by the geometrical shapes</p>
<p>In the preceding example, we learned how to draw simple vector shapes on our screen using the <code>Canvas</code> element. Qt’s built-in modules make the complex rendering process more straightforward for programmers.</p>
</div>
</body></html>