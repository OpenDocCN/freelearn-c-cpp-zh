- en: Chapter 7.  One Step Forward, One Level Down - OpenGL Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 一步一步前进，一层层深入 - OpenGL 基础
- en: Often times it's easy to take a library like SFML for granted. After all, the
    ideas and concepts offered by it seem quite intuitive. Building something rather
    simple can take as little as a couple of minutes, and there are no major headaches
    to deal with. In a perfect world, we could just offload those troubles to someone
    else and simply rely on increasingly higher levels of abstraction to get the job
    done. However, what happens when certain limitations make us slam face-first into
    a brick wall? In order to know the way around them, it's necessary to know the
    fundamentals that SFML was built on. In other words, at that point, downward is
    the only way forward.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人往往容易将像 SFML 这样的库视为理所当然。毕竟，它提供的想法和概念看起来相当直观。构建一些相对简单的东西可能只需要几分钟，而且没有太多头疼的问题需要处理。在一个完美的世界里，我们可以将那些麻烦推给其他人，并简单地依赖越来越高的抽象层次来完成工作。然而，当某些限制让我们一头撞进砖墙时会发生什么呢？为了知道如何绕过它们，有必要了解
    SFML 建立在其基础上的基本原理。换句话说，在那个时刻，向下是唯一的出路。
- en: 'In this chapter, we are going to be covering:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Setting up and using OpenGL with a window from SFML
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SFML 窗口设置和使用 OpenGL
- en: Shaping and submitting data to the GPU
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形成并向 GPU 提交数据
- en: Creating, building, and using shaders for rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、构建和使用着色器进行渲染
- en: Applying textures to geometry
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将纹理应用到几何体上
- en: Looking at various coordinate spaces and model transformations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看各种坐标系和模型变换
- en: Implementing a camera
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现摄像机
- en: That is quite a laundry list of things to do, so let us not waste any time and
    jump right in!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一份相当长的待办事项清单，所以我们不要浪费时间，直接开始吧！
- en: Use of copyrighted resources
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版权资源的使用
- en: 'As always, let us acknowledge those who deserve to be acknowledged, and give
    credit where credit''s due. These are the resources used in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，让我们承认那些应该得到认可的人，并给予应有的赞誉。以下是本章使用的资源：
- en: 'Old wall texture by `texturelib.com` under the CC0: [license:http://texturelib.com/texture/?path=/Textures/brick/medieval/brick_medieval_0121](http://texturelib.com/texture/?path=/Textures/brick/medieval/brick_medieval_0121)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `texturelib.com` 在 CC0 许可下提供的旧墙纹理：[许可：http://texturelib.com/texture/?path=/Textures/brick/medieval/brick_medieval_0121](http://texturelib.com/texture/?path=/Textures/brick/medieval/brick_medieval_0121)
- en: STB public domain image loader by *Sean Barrett* under the CC0 license: [https://github.com/nothings/stb/blob/master/stb_image.h](https://github.com/nothings/stb/blob/master/stb_image.h)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 *Sean Barrett* 在 CC0 许可下提供的 STB 公共领域图像加载器：[https://github.com/nothings/stb/blob/master/stb_image.h](https://github.com/nothings/stb/blob/master/stb_image.h)
- en: Setting up OpenGL
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 OpenGL
- en: In order to have access to the latest version of OpenGL, we need to download
    two libraries. One is named the OpenGL Extension Wrangler Library. It loads and
    makes available all OpenGL extensions that are supported on the target platform.
    The library can be downloaded here [http://glew.sourceforge.net/](http://glew.sourceforge.net/).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了访问最新的 OpenGL 版本，我们需要下载两个库。一个是名为 OpenGL Extension Wrangler Library 的库。它加载并使目标平台上支持的所有
    OpenGL 扩展可用。该库可以从以下位置下载 [http://glew.sourceforge.net/](http://glew.sourceforge.net/)。
- en: The other library we need is called OpenGL Mathematics, or GLM for short. It
    is a header-only library that adds a lot of extra data types and functions, which
    come in handy more often than not. Anything from simple vector data types to functions
    used to calculate cross products are added in by this library. It can be found
    here [http://glm.g-truc.net/0.9.8/index.html](http://glm.g-truc.net/0.9.8/index.html).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要另一个名为 OpenGL Mathematics 或 GLM 的库。这是一个仅包含头文件的库，它添加了许多额外的数据类型和函数，这些在大多数情况下都很有用。从简单的向量数据类型到用于计算叉积的函数，这个库都添加了进来。它可以在以下位置找到
    [http://glm.g-truc.net/0.9.8/index.html](http://glm.g-truc.net/0.9.8/index.html)。
- en: Setting up a Visual Studio project
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Visual Studio 项目
- en: Alongside the usual SFML includes, which we are still going to need for creating
    a window, we also need to add the GLEW and GLM `include` folders in the **Include
    Directories** field under **VC++ Directories**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们仍然需要用于创建窗口的常用 SFML 包含文件外，我们还需要在 **VC++ Directories** 下的 **Include Directories**
    字段中添加 GLEW 和 GLM 的 `include` 文件夹。
- en: 'The GLEW **Additional Library Directory** must be added in as well in the **General**
    section under **Linker**. The library files are located inside the `Release` folder,
    which holds a couple of directories: `Win32` and `x64`. These need to be set up
    correctly for different build configurations.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在**链接器**下的**通用**部分，必须将GLEW的**附加库目录**也添加进去。库文件位于`Release`文件夹中，该文件夹包含几个目录：`Win32`和`x64`。这些需要为不同的构建配置正确设置。
- en: Finally, the `glew32.lib` file has to be added to the **Additional Dependencies**
    field in the **Input** section under **Linker**, as well as the `OpenGL32.lib`
    file. It can be linked statically, in which case, `glew32s.lib` needs to be added
    instead of the regular `glew32.lib`. If linking statically, the `GLEW_STATIC` **Preprocessor
    Definition** in the **Preprocessor** section under **C/C++** needs to be added
    as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须在**链接器**下的**输入**部分的**附加依赖**字段中添加`glew32.lib`文件，以及`OpenGL32.lib`文件。它可以静态链接，在这种情况下，需要添加`glew32s.lib`而不是常规的`glew32.lib`。如果静态链接，还需要在**C/C++**下的**预处理器**部分添加`GLEW_STATIC`的**预处理器定义**。
- en: Using GLEW
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GLEW
- en: 'The first thing we are going to need if we are working with OpenGL is a window.
    Luckily, window creation isn''t OpenGL specific, so one can be made using almost
    any library out there that supports it, including SFML. For our purposes, we''ll
    be reusing the Window class with some minor adjustments to it, including the actual
    SFML window type:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用OpenGL，我们首先需要的是一个窗口。幸运的是，窗口创建不是OpenGL特有的，因此可以使用几乎任何支持它的库来创建一个窗口，包括SFML。为了我们的目的，我们将重用Window类并对它进行一些小的调整，包括实际的SFML窗口类型：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note the data type of the `m_window` data member. If actual SFML is not used
    to draw anything, we do not need an instance of `sf::RenderWindow` and can instead
    work with `sf::Window`. This means that any task that does not have anything to
    do with the actual window has to be handled separately. This even includes clearing
    the window:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`m_window`数据成员的数据类型。如果实际没有使用SFML来绘制任何内容，我们不需要`sf::RenderWindow`的实例，而是可以使用`sf::Window`。这意味着任何与实际窗口无关的任务都必须单独处理。这甚至包括清除窗口：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we get a glimpse at the first two GL functions we are going to be using.
    Because GLEW is a C API, code that looks like this will be quite common. There
    are no classes to manage, as every task is performed via function calls and a
    shared state. Case in point, our first function `glClearColor()` actually sets
    up the color that the screen will be cleared with, including the alpha channel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们将要使用的第一个两个GL函数。因为GLEW是一个C API，所以看起来像这样的代码将会很常见。没有类需要管理，因为每个任务都是通过函数调用和共享状态来执行的。以我们的第一个函数`glClearColor()`为例，它实际上设置了屏幕清除时使用的颜色，包括alpha通道。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This specific function, as well as many others, takes in what is known as a
    **normalized** vector. It is useful when representing proportion. For example,
    clearing the screen to the color purple would mean passing the value *0.5f* as
    the first and the third parameter, which would mean half of the colour is red,
    and the other half is blue.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的函数，以及许多其他函数，接受一个所谓的**归一化**向量。当表示比例时很有用。例如，将屏幕清除到紫色意味着传递值*0.5f*作为第一个和第三个参数，这意味着颜色的一半是红色，另一半是蓝色。
- en: The second function call actually performs the clearing with the stored value.
    It takes in a single argument, which is essentially just a bitmask, defined using
    the `#define` pre-processor directive. This specific implementation detail allows
    more masks to be passed into the function call by utilizing **bitwise** or operations,
    represented by the pipe *|* symbol. This concept will be revisited by us eventually.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数调用实际上使用存储的值执行清除。它接受一个参数，本质上只是一个位掩码，使用`#define`预处理器指令定义。这个特定的实现细节允许通过使用**位或**操作（用管道符号*|*表示）将更多的掩码传递给函数调用。我们最终会回顾这个概念。
- en: 'With that out of the way, let us actually create the window and initialize
    the `GLEW` library:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，让我们实际创建窗口并初始化`GLEW`库：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All we need to do in order to initialize GLEW is to call a single function `glewInit()`.
    It returns a value, which represents the success/failure of the operation. Another
    useful function to keep around is `glGetString()`. It returns a static string
    that represents specific information about the OpenGL version that is supported
    by the computer it is executed on. In this case, we specifically want to check
    the version of OpenGL and print it out, but it can also be used to determine the
    OpenGL extensions, the supported GLSL version, the name of the hardware rendering
    platform, and so on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化GLEW，我们只需要调用一个函数`glewInit()`。它返回一个值，表示操作的成功或失败。另一个有用的函数是`glGetString()`。它返回一个静态字符串，表示在执行该字符串的计算机上支持的OpenGL版本的具体信息。在这种情况下，我们特别想检查OpenGL的版本并将其打印出来，但它也可以用来确定OpenGL扩展、支持的GLSL版本、硬件渲染平台的名称等等。
- en: The rendering pipeline
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染管线
- en: When drawing something on the screen, a certain sequence of steps must be followed
    in order to submit the geometry, convert it to pixels, and color them all appropriately.
    This particular sequence of steps is often referred to as the **rendering pipeline**.
    How it functions depends entirely on the version of OpenGL you are using. Versions
    below *3.0* use what is called a **fixed function pipeline**, while newer OpenGL
    releases of *3.0 +* utilize the **programmable pipeline**. The former is now deprecated
    and is referred to as **legacy** OpenGL, while the latter is widely used and applied,
    even on mobile devices, and has become the standard.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上绘制东西时，必须遵循一定的步骤来提交几何形状，将其转换为像素，并适当地着色。这个特定的步骤序列通常被称为**渲染管线**。其工作方式完全取决于你使用的OpenGL版本。低于*3.0*的版本使用所谓的**固定功能管线**，而*3.0+*的新OpenGL版本使用**可编程管线**。前者现在已弃用，被称为**传统**OpenGL，而后者被广泛使用和应用，甚至在移动设备上，已成为标准。
- en: Fixed function pipeline
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定功能管线
- en: 'Actually drawing things on screen with the fixed function pipeline is much
    easier than the modern way of doing things, but it comes at a price. Consider
    the following example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用固定功能管线在屏幕上绘制东西比现代方法要简单得多，但这也需要付出代价。考虑以下示例：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This particular block of code is quite easily readable, which is one advantage
    of the legacy method. We begin by invoking the `glBegin()` method and passing
    in a value, which signifies how the actual vertices should be interpreted as they
    are being submitted. We are working with triangles, which means that every three
    vertices submitted in a row will be connected and turned into a triangle. Note
    the calls to `glColor3f` as well. The color of the vertices is set as they are
    being submitted, and the same can be done with texture coordinates as well. The
    final call to the `glEnd()` method flushes all of the submitted data to the GPU
    for rendering.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段特定的代码非常易于阅读，这是传统方法的一个优点。我们首先调用`glBegin()`方法并传入一个值，这个值表示实际顶点在提交时应如何被解释。我们正在处理三角形，这意味着每行提交的前三个顶点将被连接并形成一个三角形。注意`glColor3f`的调用。顶点的颜色在提交时设置，同样也可以对纹理坐标进行相同的操作。最后调用`glEnd()`方法将所有提交的数据刷新到GPU进行渲染。
- en: While this is very readable and easy to understand for newcomers, the vertex
    data has to be resubmitted to the GPU every frame, which heavily impacts performance.
    Small applications would not notice the difference, but the memory transfer overhead
    really starts to add up after a significant number of primitives have been submitted.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对新手来说非常易于阅读和理解，但顶点数据必须每帧重新提交到GPU，这会严重影响性能。小型应用程序可能不会注意到差异，但提交大量原语后的内存传输开销确实开始累积。
- en: Another issue with this approach is how limited it is. Certain effects, if at
    all possible, can be extremely slow to pull off with the fixed function pipeline.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个问题是它的局限性。某些效果，如果可能的话，使用固定功能管线实现可能会非常慢。
- en: Programmable pipeline
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可编程管线
- en: 'Using the programmable pipeline is quite a bit more complicated for small tasks,
    but it proves invaluable for larger projects. Just like the fixed function pipeline,
    there are steps that are static and unchanging. The programmable pipeline does,
    however, provide a way to customize certain aspects of how the data submitted
    to the GPU is processed. This is where **shaders** come in. Shaders have already
    been briefly covered in the previous chapter; however, there is much more to them
    that has not yet been explained. They are the programs that can be written in
    a C-like language and executed on the GPU instead of the CPU. As it turns out,
    shaders are used to customize certain parts of the programmable pipeline. Consider
    the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小任务来说，使用可编程管线要复杂得多，但对于大型项目来说却非常有价值。就像固定功能管线一样，有一些步骤是静态的且不会改变。然而，可编程管线确实提供了一种方法来定制提交给GPU的数据的处理方式。这就是**着色器**的用武之地。着色器已经在上一章中简要介绍过；然而，它们还有很多尚未解释的内容。它们是可以用类似C的语言编写的程序，可以在GPU上而不是CPU上执行。实际上，着色器用于定制可编程管线的一部分。考虑以下图示：
- en: '![Programmable pipeline](img/image_07_001.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![可编程管线](img/image_07_001.jpg)'
- en: Just like the fixed-function pipeline, vertex data is submitted to the GPU.
    However, this data is not re-submitted every frame. Instead, the vertex data lives
    on the GPU and can be referred to when it needs to be rendered. Once a call has
    been made to draw a specific set of vertices, they're passed in to be processed
    and relayed to the vertex shader.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像固定功能管线一样，顶点数据被提交到GPU。然而，这些数据并不是每帧都重新提交。相反，顶点数据存在于GPU上，当需要渲染时可以引用。一旦调用绘制特定顶点集，它们就会被传递进来进行处理，并传递给顶点着色器。
- en: The **Vertex shader** is one of few programmable bits of this pipeline. It is
    often used to calculate the positions of vertices in the appropriate coordinate
    system, and pass these vertices down the pipeline to be processed further.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点着色器**是管线中少数可编程部分之一。它通常用于计算顶点在适当的坐标系中的位置，并将这些顶点传递到管线中以便进一步处理。'
- en: The **Tessellation** stage essentially is responsible for performing sub-divisions
    of our existing geometry into smaller primitives. It actually ends up connecting
    the vertices and passing these primitives further down the pipeline. There are
    two shaders in this stage that can be written and used; however, we are not going
    to be doing that.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**镶嵌**阶段本质上负责将我们现有的几何形状细分为更小的基本形状。它实际上连接了顶点并将这些基本形状进一步传递到管线中。在这个阶段有两个着色器可以编写和使用；然而，我们不会这么做。'
- en: All of the primitive data is then passed down to a **Geometry shader**, which
    just like the two tessellation shaders is optional. It can be used to generate
    more vertices from the existing geometry.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基本形状数据随后被传递到**几何着色器**，就像两个镶嵌着色器一样，它是可选的。它可以用来从现有几何形状生成更多顶点。
- en: After the primitives have been properly assembled, they are passed further down
    and handled by the rasterizer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本形状被正确组装后，它们会被进一步传递并由光栅器处理。
- en: '**Rasterization** is the actual process of turning vertex and primitive information
    into pixel data. These pixels are then passed further down the pipeline.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**光栅化**是将顶点和基本形状信息转换为像素数据的过程。然后这些像素被进一步传递到管线中。'
- en: The last programmable bit of this pipeline receives all of the pixel information
    from the previous stage. It is called the **Fragment shader** (that is, pixel
    shader), and can be used to determine the value of each individual pixel within
    the geometry we are rendering. Anything from assigning specific colors, to actually
    sampling pixels of a texture is done at this stage. These pixels are then pushed
    further down to be handled by other stages.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管线的最后一个可编程部分接收来自前一阶段的全部像素信息。它被称为**片段着色器**（即像素着色器），可以用来确定我们正在渲染的几何形状中每个单独像素的值。从分配特定颜色到实际采样纹理的像素，这一阶段都会完成。然后这些像素被进一步推送到其他阶段进行处理。
- en: The **Depth & Stencil** stage performs various tests in order to clip unneeded
    pixels that should not be drawn on screen. If a pixel is outside of the window
    area or even behind another bit of geometry, it is dropped at this stage.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度与模板**阶段执行各种测试，以剪裁不应在屏幕上绘制的无需像素。如果一个像素在窗口区域之外，甚至在其他几何形状之后，它在这个阶段就会被丢弃。'
- en: Unclipped pixels are then blended onto the existing frame buffer, which is used
    to draw everything on screen. Before they are blended, however, the **Dithering**
    process takes place, making sure pixels are correctly rounded up or down if the
    render image has less or more precision than the value we have.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 未裁剪的像素随后被混合到现有的帧缓冲区中，用于在屏幕上绘制一切。然而，在混合之前，**抖动**过程发生，确保如果渲染图像的精度低于或高于我们拥有的值，像素被正确地四舍五入。
- en: Although it may be hard to grasp this concept at first, the programmable pipeline
    is a superior approach to modern rendering. Out of all of these stages covered,
    we only really need to write the vertex and fragment shaders to get started. We
    will be covering that very soon.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能难以理解这个概念，但可编程管线是现代渲染的优越方法。在所有这些阶段中，我们实际上只需要编写顶点和片段着色器就可以开始。我们很快就会介绍这一点。
- en: Storing and drawing primitives
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储和绘制原语
- en: 'All of our primitive data has to be represented as a set of vertices. Whether
    we are dealing with a triangle or a sprite on screen, or if it is a huge, complex
    model of a monster, it can all be broken down to this fundamental type. Let us
    take a look at a class that represents it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有原语数据都必须表示为一组顶点。无论我们是在处理屏幕上的三角形或精灵，还是处理一个巨大的、复杂的怪物模型，它们都可以分解为这种基本类型。让我们看看一个表示它的类：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, it is only a simple `struct` that holds a 3D vector that represents
    a position. Later on, we might want to store other information about a vertex,
    such as texture coordinates, its color, and so on. These different pieces of information
    about a specific vertex are usually referred to as **attributes**. For convenience,
    we are also enumerating different attributes to make the rest of our code more
    clear.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它只是一个简单的`struct`，它包含一个表示位置的3D向量。稍后，我们可能想要存储有关顶点的其他信息，例如纹理坐标、其颜色等等。关于特定顶点的这些不同信息通常被称为**属性**。为了方便起见，我们还枚举了不同的属性，以使我们的代码更加清晰。
- en: Vertex storage
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点存储
- en: Before any primitives can be drawn, their data must be stored on the GPU. In
    OpenGL, this task is achieved by utilizing **Vertex Array Objects** (**VAO**)
    and **Vertex Buffer Objects** (**VBO**).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何原语可以绘制之前，其数据必须在GPU上存储。在OpenGL中，这项任务是通过利用**顶点数组对象**（**VAO**）和**顶点缓冲对象**（**VBO**）来完成的。
- en: A vertex buffer object can simply be thought of as space that gets allocated
    on the GPU for storing data. That data can be anything. It could be vertex positions,
    colors, texture coordinates, and so on. We are going to use VBOs to store all
    of our primitive information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点缓冲对象可以简单地理解为在GPU上分配的空间，用于存储数据。这些数据可以是任何东西。它可以是顶点位置、颜色、纹理坐标等等。我们将使用VBO来存储所有我们的原语信息。
- en: A vertex array object is like a parent to a VBO, or even multiple VBOs. It stores
    information about how data that lives inside a VBO should be accessed, how information
    can be passed into various shader stages, and many more details that together
    form a state. If a VBO is the actual data pool, a VAO can be thought of as an
    instruction set of how to access that data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点数组对象就像VBO的父对象，甚至可以是一个或多个VBO。它存储有关VBO内部数据如何访问的信息，如何将信息传递到各种着色器阶段，以及许多其他细节，这些细节共同形成状态。如果VBO是实际的数据池，VAO可以被视为访问该数据的指令集。
- en: Both VAO and VBO instances are identified by simple integers, which get returned
    after the space is allocated. These integers will be used to differentiate different
    buffers and array objects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: VAO和VBO实例都通过简单的整数来标识，这些整数在空间分配后返回。这些整数将被用来区分不同的缓冲区和数组对象。
- en: The model class
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型类
- en: 'With that bit of information out of the way, we can finally get down to actually
    implementing a model class! A model, in our case, is any set of triangles that
    can form a shape. With enough triangles, any shape can be modelled. Let us take
    a look at the class header:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些信息后，我们终于可以着手实现模型类了！在我们的情况下，模型是任何可以形成形状的三角形集合。有了足够的三角形，任何形状都可以建模。让我们看看类的头文件：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can tell, it is quite simple. The constructor takes in two arguments
    for now: a pointer to the first instance of a vertex, and the number of vertices
    we are actually submitting. This makes it easy for us to load a model quickly
    from a simple array of vertices, although it may not be the best way of loading
    more complex meshes.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它相当简单。构造函数目前接受两个参数：一个指向顶点第一个实例的指针，以及我们实际提交的顶点数量。这使得我们可以快速从简单的顶点数组中加载模型，尽管这可能不是加载更复杂网格的最佳方式。
- en: Note that the class also has a `Draw()` method, which will be used later on
    to actually submit its vertices to the rendering pipeline and begin the drawing
    process.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该类还有一个`Draw()`方法，稍后将会使用它将顶点提交到渲染管线并开始绘制过程。
- en: 'Lastly, we have the two *GL unsigned integer* types: `m_VAO` and `m_vertexVBO`.
    These integers will refer to the actual vertex array object that is used with
    this model, as well as the vertex buffer object, used to store all of the vertex
    information. We also have an *unsigned integer*, `m_drawCount`, which is going
    to store the number of vertices this particular model has in order to draw them
    all.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有两种*GL无符号整数*类型：`m_VAO`和`m_vertexVBO`。这些整数将引用与该模型一起使用的实际顶点数组对象以及用于存储所有顶点信息的顶点缓冲对象。我们还有一个*无符号整数*，`m_drawCount`，它将存储特定模型中顶点的数量，以便绘制它们。
- en: Implementing the model class
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现模型类
- en: 'With that out of the way, let us begin allocating and filling in our data structures!
    The constructor of the `GL_Model` class is going to be helping us with that task:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，让我们开始分配和填充我们的数据结构！`GL_Model`类的构造函数将帮助我们完成这项任务：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We begin by copying the amount of vertices to the `m_drawCount` data member.
    This is going to be useful later, as we need to know exactly how many vertices
    need to be drawn before actually rendering them. Some space for a VAO is then
    allocated, using the `glGenVertexArrays` function. Its first argument is the amount
    of objects that need to be created, while the second one takes a pointer to a
    variable that is going to store the returned identifiers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将顶点数量复制到`m_drawCount`数据成员中。这将在稍后变得很有用，因为我们需要确切知道在渲染之前需要绘制多少个顶点。然后使用`glGenVertexArrays`函数为VAO分配一些空间。它的第一个参数是需要创建的对象数量，而第二个参数是一个指向将要存储返回标识符的变量的指针。
- en: The next function call, `glBindVertexArray()`, actually enables a vertex array
    object with the provided identifier, so that any subsequent function call after
    this one modifies the vertex array object that was passed in as the argument.
    Any vertex array object manipulation from this point on will be performed on the
    VAO with the identifier, `m_VAO`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数调用，`glBindVertexArray()`，实际上是通过提供的标识符启用一个顶点数组对象，这样任何在此之后的函数调用都会修改作为参数传入的顶点数组对象。从这一点开始，任何对顶点数组对象的操作都将在这个具有标识符`m_VAO`的VAO上执行。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because GLEW is a C API, the idea of binding and unbinding something dominates
    most aspects of it. In order to modify or do anything with certain data that lives
    on the GPU, the appropriate buffer must be bound first.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GLEW是一个C API，绑定和解绑的概念在它的大多数方面都占主导地位。为了修改或与GPU上存在的数据进行任何操作，必须首先绑定适当的缓冲区。
- en: Just like the VAO, the vertex buffer object also needs to be generated. The
    function `glGenBuffers` does just that. In this case, we only need one buffer
    object, which is what the first argument denotes. Once it is generated, just like
    the VAO, we need to bind to this buffer in order to modify it. This is where the
    `glBindBuffer` function comes in. As it is bound to, we also need to specify the
    type of buffer we are going to treat it as. Because we just want an array of data,
    `GL_ARRAY_BUFFER` is used.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像VAO一样，顶点缓冲对象也需要生成。`glGenBuffers`函数正是用来做这个的。在这种情况下，我们只需要一个缓冲对象，这就是第一个参数所表示的。一旦生成，就像VAO一样，我们需要绑定到这个缓冲区以便修改它。这就是`glBindBuffer`函数发挥作用的地方。因为它被绑定，我们还需要指定我们将要将其视为哪种类型的缓冲区。因为我们只想有一个数据数组，所以使用`GL_ARRAY_BUFFER`。
- en: Now that we have a buffer created, we can push some data to it! A call to `glBufferData`
    does just that. The first argument, just like the previous function, determines
    what kind of buffer we are dealing with. The second argument is the **byte** size
    of the data chunk we want to submit, which OpenGL has to know in order to allocate
    enough space for the buffer to hold all of the data. In this case, it is just
    the number of vertices multiplied by the number of bytes the first element takes
    up. The third argument is just a pointer to the actual data structure we want
    to submit. How much of that is read in is determined by the second argument, which,
    in this case, is all of it. Finally, the last argument is used as a hint for OpenGL
    to manage the data storage as efficiently as possible depending on its use. It
    stores the data differently depending on what we do with it. `GL_STATIC_DRAW`
    means we are not going to be modifying the data, so that it can store it a certain
    way that is most efficient for this situation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个缓冲区，我们可以向其中推送一些数据了！调用`glBufferData`函数正是如此。第一个参数，就像之前的函数一样，决定了我们正在处理哪种类型的缓冲区。第二个参数是我们想要提交的数据块的字节大小，OpenGL需要知道这一点，以便为缓冲区分配足够的空间来存储所有数据。在这种情况下，它只是顶点数量的乘积乘以第一个元素占用的字节数。第三个参数是指向我们想要提交的实际数据结构的指针。读取多少数据由第二个参数确定，在这种情况下，是全部。最后，最后一个参数用作OpenGL管理数据存储的提示，以便尽可能高效地根据其使用情况。它根据我们如何使用它来存储数据的方式不同。`GL_STATIC_DRAW`表示我们不会修改数据，因此它可以以最有效的方式存储数据。
- en: With all of the data buffered, we can begin working with the VAO again and give
    it information about how the vertex information should be accessed. Because the
    vertex position has to be passed to the fragment shader, we need to enable it
    as an attribute and store information about how it should be processed in the
    VAO. This is where `glEnableVertexAttribArray()` and `glVertexAttribPointer()`
    functions come in.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有数据缓冲后，我们可以再次开始使用VAO，并给它提供有关如何访问顶点信息的信息。因为顶点位置必须传递给片段着色器，所以我们需要将其作为属性启用，并在VAO中存储有关其处理方式的信息。这就是`glEnableVertexAttribArray()`和`glVertexAttribPointer()`函数发挥作用的地方。
- en: 'The former function simply enables a certain attribute to be used by the vertex
    shader. `VertexAttribute::Position` evaluates to `0`, so the *0th* attribute in
    the vertex shader is enabled for use. The latter, however, actually specifies
    how this data is read and processed before it gets piped down the vertex shader.
    In this case, the *0th* attribute is defined as a set of three variables, all
    of which are floats. The next argument can be useful if we want to normalize the
    data before it gets sent to the vertex shader. In this case, we do not need to
    do that, so `GL_FALSE` is passed in instead. The last two arguments are the byte
    stride and byte offset of the data we are interested in inside the buffer. Because
    we are only storing the vertexes position inside the `GL_Vertex` structure so
    far, both of these values are `0`. However, what would happen if we had more attributes?
    Consider the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前者函数简单地启用某个属性以便由顶点着色器使用。`VertexAttribute::Position`计算结果为`0`，所以顶点着色器中的*0th*属性被启用以供使用。然而，后者实际上指定了在数据被传递到顶点着色器之前如何读取和处理这些数据。在这种情况下，*0th*属性被定义为三个变量的集合，它们都是浮点数。下一个参数在我们在将数据发送到顶点着色器之前想要归一化数据时可能很有用。在这种情况下，我们不需要这样做，所以传入`GL_FALSE`。最后两个参数是我们对缓冲区中感兴趣的数据的字节步长和字节偏移量。因为我们到目前为止只存储了`GL_Vertex`结构中的顶点位置，所以这两个值都是`0`。然而，如果我们有更多的属性会发生什么？考虑以下图表：
- en: '![Implementing the model class](img/image_07_002.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![实现模型类](img/image_07_002.jpg)'
- en: Imagine we have all of the data inside a buffer, which was shown previously.
    For each vertex in there, its position is followed by its color, and then by another
    vertexes position. If we just want to filter out the position data, for example,
    stride and offset can be very useful. The stride argument is the number of bytes
    that have to be jumped from the beginning of one data segment to another. Effectively,
    stride can be thought of as the size of the entire vertex's data structure, which,
    in this case, is the sum of the size of the position vector, as well as the color
    vector. To put it simply, it's the number of bytes from the beginning of one vertex,
    to the beginning of another.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个缓冲区内的所有数据，这在前面的示例中已经展示过。对于其中的每个顶点，其位置后面跟着其颜色，然后是另一个顶点的位置。如果我们只想过滤出位置数据，例如，步长和偏移量可以非常有用。步长参数是从一个数据段的开头跳到另一个数据段的开头所需的字节数。实际上，步长可以被视为整个顶点数据结构的大小，在这个例子中，是位置向量和颜色向量大小的总和。简单来说，它是从一个顶点的开头到另一个顶点开头的字节数。
- en: Offset, on the other hand, is just the number of bytes we need to move from
    the beginning of whichever structure we happen to be reading in order to reach
    the desired element. Accessing the color element would mean the offset would have
    to be the size of the position vector. To put it simply, the offset is the number
    of bytes from the beginning of the structure to the beginning of the desired element.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，偏移量只是我们需要从正在读取的结构的开头移动的字节数，以便到达所需的元素。访问颜色元素意味着偏移量必须是位置向量的大小。简单来说，偏移量是从结构开头到所需元素开头的字节数。
- en: After our data is submitted and accounted for, we can use `glBindVertexArray`
    again to bind to *0*, which would show that we're done with the VAO.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据提交并计入之后，我们可以再次使用`glBindVertexArray`来绑定到*0*，这表明我们已经完成了VAO的操作。
- en: 'All of this allocated data actually has to be disposed of when it''s no longer
    needed. The destructor can help us here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些分配的数据实际上在不再需要时都必须被释放。析构函数可以在这里帮助我们：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, the vertex buffer object needs to be disposed of. We pass the number
    of VBOs, as well as the pointer to the first identifier to the `glDeleteBuffers`
    function, which purges all of the buffer data on the GPU. The VAO follows a similar
    procedure afterwards.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要释放顶点缓冲对象。我们向`glDeleteBuffers`函数传递VBO的数量以及第一个标识符的指针，该函数会清除GPU上的所有缓冲数据。VAO随后遵循类似的程序。
- en: 'Finally, we can implement the `Draw` method of our `Model` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现我们的`Model`类的`Draw`方法：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before drawing something, we need to specify which data the pipeline should
    use. All of the vertex information sits safely in our buffer object that is managed
    by the VAO, so we bind it. The `glDrawArrays` function is then invoked. As the
    name states, it draws arrays of vertices. Its first argument is the type of primitive
    we want to draw, which in this case is triangles. Lines, points, and other types
    can also be drawn like this. The second argument is the starting index inside
    the buffer array object. Since we want to draw everything from the beginning,
    this is set to *0*. Lastly, the number of vertices to be drawn is passed in. The
    call to this function actually initiates the rendering pipeline, sending all of
    the vertex data into the vertex shader. The final call is to the `glBindVertexArray()`
    function that simply unbinds our VAO.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制任何东西之前，我们需要指定管线应该使用哪些数据。所有的顶点信息都安全地存储在我们的缓冲对象中，该对象由VAO管理，所以我们将其绑定。然后调用`glDrawArrays`函数。正如其名称所示，它绘制顶点数组。它的第一个参数是我们想要绘制的原语类型，在这个例子中是三角形。线条、点和其他类型也可以这样绘制。第二个参数是缓冲数组对象内的起始索引。由于我们想要从开始绘制一切，所以这个值被设置为*0*。最后，传递要绘制的顶点数量。对这个函数的调用实际上启动了渲染管线，将所有顶点数据发送到顶点着色器。最后的调用是`glBindVertexArray()`函数，它只是简单地解绑我们的VAO。
- en: Using shaders
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用着色器
- en: The standardization of the programmable pipeline now means shaders have to be
    written for certain tasks, including the basic ones. This means that simply submitting
    our vertex data and rendering it would do nothing, as the two fundamental chunks
    of the rendering pipeline, the vertex and fragment shaders, are non-existent.
    In this section, we are going to cover how shaders are loaded, built, and applied
    to our virtual geometry, in turn producing those glorious pixels on the screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可编程管道的标准化现在意味着必须为某些任务编写着色器，包括基本任务。这意味着仅仅提交我们的顶点数据并渲染它将不会产生任何效果，因为渲染管线中的两个基本部分，即顶点着色器和片段着色器，是不存在的。在本节中，我们将介绍着色器是如何被加载、构建并应用到我们的虚拟几何形状上的，从而在屏幕上产生那些辉煌的像素。
- en: Loading shader files
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载着色器文件
- en: 'Before we can use shaders, we must first discuss how they are loaded. All we
    technically need to create a shader is a string, containing all of its code. A
    very simple helper function can be written to parse a file and return it as a
    string, as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用着色器之前，我们首先需要讨论它们是如何被加载的。技术上，我们只需要一个字符串，其中包含着色器所有的代码。可以编写一个非常简单的辅助函数来解析文件，并将其作为字符串返回，如下所示：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is nothing we have not seen before, when it comes to file reading and parsing.
    A string is created, then appended to with each new line of the file being read,
    and finally returned.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到文件读取和解析时，这并不是我们第一次看到。创建一个字符串，然后逐行读取文件内容并将其追加到字符串中，最后返回。
- en: Creating shader programs
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建着色器程序
- en: 'OpenGL shaders themselves are part of programs that are used throughout the
    rendering pipeline. If we have a vertex shader and a fragment shader we wish to
    utilize, both of them are actually joined into one program, which is then bound
    to so that the pipeline can use the appropriate shader at the right time. This
    is important, because it shapes the way the `GL_Shader` data structure is built:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL着色器本身是渲染管线中使用的程序的一部分。如果我们有一个想要使用的顶点着色器和片段着色器，这两个着色器实际上会被合并成一个程序，然后绑定到管线中，以便在正确的时间使用适当的着色器。这一点很重要，因为它决定了`GL_Shader`数据结构的构建方式：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we enumerate the shader types we are going to be using. For basic purposes,
    vertex and fragment shaders are more than enough.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们列举出我们将要使用的着色器类型。对于基本用途来说，顶点着色器和片段着色器已经足够了。
- en: The constructor of the class takes a filename of the shader(s) we are going
    to be loading. There is also a `Bind()` method, which will be used to enable a
    specific shader program before rendering begins.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类的构造函数接受将要加载的着色器（们）的文件名。还有一个`Bind()`方法，它将在渲染开始之前用于启用特定的着色器程序。
- en: We also have two static helper methods, used for printing out errors inside
    shaders, and actually building them. Yes, shaders need to be compiled and linked
    before they can be used, much like C/C++.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个静态辅助方法，用于在着色器内部打印错误，并实际构建它们。是的，着色器在使用之前需要编译和链接，就像C/C++一样。
- en: Finally, we need two *GL unsigned integer* data members, the latter of which
    is an array. The first integer is going to represent the shader program, which
    contains all attached shaders. The array of integers keeps track of identifiers
    of all types of shaders that are in the program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要两个*GL无符号整数*数据成员，后者是一个数组。第一个整数将代表着色器程序，其中包含所有附加的着色器。整数数组跟踪程序中所有类型着色器的标识符。
- en: Implementing the shader class
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现着色器类
- en: 'Let us get down to actually creating some shaders! As always, a good place
    to start is the constructor:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们着手实际创建一些着色器！和往常一样，一个好的开始是从构造函数开始的：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before any shader compilation is done, we first need to have the actual source
    code loaded in memory. OpenGL does not do this for you, so we are going to be
    utilizing the `ReadFile` function implemented earlier. Once both types of shaders
    are loaded and checked for not being empty, a new shader program is created using
    `glCreateProgram()`. It returns an identifier that we need to keep track of if
    we want to use the shaders when rendering.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何着色器编译之前，我们首先需要在内存中加载实际的源代码。OpenGL不会为你做这件事，所以我们将利用之前实现的`ReadFile`函数。一旦两种类型的着色器都被加载并检查不为空，就会使用`glCreateProgram()`创建一个新的着色器程序。它返回一个标识符，如果我们想在渲染时使用着色器，我们需要跟踪这个标识符。
- en: For the actual vertex and fragment shaders the static `BuildShader()` method
    is invoked, and the returned identifier is stored inside the `m_shader` array
    for the relevant type of shader. Note the `GL_VERTEX_SHADER` and `GL_FRAGMENT_SHADER`
    definitions being passed to the method call. These are the shader types OpenGL
    needs in order to build the shaders.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际的顶点和片段着色器，调用静态`BuildShader()`方法，并将返回的标识符存储在`m_shader`数组中，对应于相关类型的着色器。注意传递给方法调用的`GL_VERTEX_SHADER`和`GL_FRAGMENT_SHADER`定义。这些是OpenGL构建着色器所需的着色器类型。
- en: After the shaders have been built, they need to be attached to our created program.
    For this we can simply use a loop and invoke `glAttachShader`, which takes the
    ID of the program, as well as an ID of the shader to be attached to said program.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器构建完成后，它们需要附加到我们创建的程序上。为此，我们可以简单地使用循环并调用`glAttachShader`，该函数接受程序的ID以及要附加到该程序的着色器ID。
- en: Shaders need to have some sort of input as they are being executed. Remember
    that our model rendering begins with a binding to a VAO, which holds the information
    about how certain attributes of a VBO should be accessed, followed by a draw call.
    In order for the data feeding to work properly, our shader class needs to bind
    a name and attribute location. This can be done by calling `glBindAttribLocation`,
    and passing in the ID of the program, the actual attribute location, which is
    enumerated as `VertexAttribute`, and the name of the attribute variable that's
    going to be used inside the shader program. This step ensures that the data being
    fed into the vertex shader will be accessible through a *position* variable. This
    will be covered more in the *Writing basic shaders* section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器在执行时需要某种形式的输入。记住，我们的模型渲染是从绑定到一个VAO开始的，该VAO包含有关如何访问VBO中某些属性的信息，然后是绘制调用。为了确保数据传输正常工作，我们的着色器类需要绑定一个名称和属性位置。这可以通过调用`glBindAttribLocation`并传入程序ID、实际的属性位置（枚举为`VertexAttribute`）以及将在着色器程序内部使用的属性变量名称来实现。这一步骤确保输入到顶点着色器中的数据将通过一个*位置*变量可访问。这将在*编写基本着色器*部分中进一步介绍。
- en: After the shaders are built and have their attributes bound, all we have left
    is linking and validation, the latter of which determines if the shader executable
    can run given the current OpenGL state. Both `glLinkProgram` and `glValidateProgram`
    simply take the ID of the program. After each of these function calls, we also
    invoke the other static helper method, `CheckError`. It is responsible for actually
    fetching a string of information, pertaining to any sort of errors during the
    linking and compilation stages. This method takes in the program ID, a flag that
    is used to determine what stage of the shader building process we are actually
    interested in, a *Boolean* value that signifies whether the whole shader program
    is being checked or if it is just an individual shader, and a string to be split
    out into the console window before the actual error is printed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器构建并绑定其属性之后，我们剩下的只是链接和验证，后者确定着色器可执行文件是否可以在当前的OpenGL状态下运行。`glLinkProgram`和`glValidateProgram`都只需传入程序的ID。在这些函数调用之后，我们还会调用其他静态辅助方法`CheckError`。该方法负责获取与链接和编译阶段中任何错误相关的信息字符串。此方法接受程序ID、一个用于确定我们实际上感兴趣的着色器构建过程的哪个阶段的标志、一个表示是否正在检查整个着色器程序或只是单个着色器的*布尔*值，以及一个字符串，在打印实际错误之前将其拆分到控制台窗口中。
- en: 'Shaders, just like any resource, need to be cleaned up once we are done with
    them:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器，就像任何资源一样，一旦使用完毕就需要进行清理：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Thanks to the `ShaderType` enumeration, we know exactly how many shader types
    we support, and so we are able to simply run a loop for each one during cleanup.
    For each shader type, we must first detach it from the shader program using `glDetachShader`,
    which takes the program ID and the shader ID, and then deletes it using `glDeleteShader`.
    Once all the shaders are removed, the program itself is deleted through the `glDeleteProgram()`
    function call.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`ShaderType`枚举，我们确切地知道我们支持多少种着色器类型，因此我们可以在清理过程中简单地为每个类型运行一个循环。对于每种着色器类型，我们首先必须使用`glDetachShader`将其从着色器程序中分离出来，该函数接受程序ID和着色器ID，然后使用`glDeleteShader`将其删除。一旦所有着色器都被移除，程序本身将通过`glDeleteProgram()`函数调用被删除。
- en: 'As discussed previously, OpenGL operates using function calls and a shared
    state. This means that certain resources such as shaders, for example, must be
    bound to before being used for rendering:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，OpenGL使用函数调用和共享状态来操作。这意味着某些资源，例如着色器，在使用于渲染之前必须绑定：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In order to use a shader for a specific set of primitives to be drawn, we simply
    need to call `glUseProgram` and pass in the ID of the shader program.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用着色器绘制特定的一组原语，我们只需调用`glUseProgram`并传入着色器程序的ID。
- en: 'Let us take a look at one of our helper methods, used to determine if there
    were any errors during the various stages of the shader program setup:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的一个辅助方法，用于确定在着色器程序设置的各种阶段是否有任何错误：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'First, a few local variables are set up for storing the state information:
    a success flag, and a buffer for an error message to be put in. If the `l_program`
    flag is true, it means we are trying to fetch information about the actual shader
    program. Otherwise, we are only interested in an individual shader. To obtain
    the parameter that signifies success or failure of link/validation/compilation
    stages of a shader/program, we need to use `glGetProgramiv` or `glGetShaderiv`.
    Both of them take an ID to a shader or program being checked, a flag of the parameter
    we are interested in, and a pointer to the return value that is to be overwritten
    with either `GL_TRUE` or `GL_FALSE` in this case.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置一些局部变量来存储状态信息：一个成功标志和一个用于放置错误消息的缓冲区。如果`l_program`标志为真，这意味着我们正在尝试获取有关实际着色器程序的信息。否则，我们只对单个着色器感兴趣。为了获取表示着色器/程序链接/验证/编译阶段成功或失败的参数，我们需要使用`glGetProgramiv`或`glGetShaderiv`。这两个函数都接受一个被检查的着色器或程序的ID，一个我们感兴趣的参数的标志，以及一个用于覆盖返回值的指针，在这种情况下要么是`GL_TRUE`要么是`GL_FALSE`。
- en: If whichever stage of the shader building process we are interested in finished
    successfully, we simply return from the method. Otherwise, we invoke either  `glGetProgramInfoLog()`
    or `glGetShaderInfoLog()` to fetch the error information of the program or individual
    shader. Both of these functions take the identifier of either the program or shader
    being checked, the size of the error message buffer we have allocated, a pointer
    to a variable that would be used to store the length of the string returned, which
    we do not really need so `nullptr` is passed in, and a pointer to the error message
    buffer that is to be written to. Afterwards, it is as simple as printing out our
    `l_errorMsg` prefix, followed by the actual error written to the `error` message
    buffer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们感兴趣的着色器构建过程的任何阶段成功完成，我们只需从方法中返回。否则，我们调用`glGetProgramInfoLog()`或`glGetShaderInfoLog()`来获取程序或单个着色器的错误信息。这两个函数都接受被检查的程序或着色器的标识符、我们已分配的错误消息缓冲区的大小、一个用于存储返回字符串长度的变量的指针，我们实际上不需要它，所以传入`nullptr`，以及一个指向要写入的错误消息缓冲区的指针。之后，就像打印出我们的`l_errorMsg`前缀，然后是实际写入到`error`消息缓冲区的错误一样简单。
- en: 'Last, but definitely not least, let us see what it takes to build an individual
    shader:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但绝对是最重要的，让我们看看构建单个着色器需要什么：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, an individual shader has to be created using the `glCreateShader()`
    method. It takes in a shader type, such as `GL_VERTEX_SHADER`, which we used in
    the constructor of this class. If, for some reason, the shader creation failed,
    an error message is written to the console window and the method returns a `0`.
    Otherwise, two arrays of GL types are set up: one for the sources of potentially
    multiple shaders, and one for the lengths of each source string. For now we''re
    only going to be dealing with one source per shader, but it is possible to handle
    multiple sources later on, should we ever want to.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须使用`glCreateShader()`方法创建单个着色器。它接受一个着色器类型，例如`GL_VERTEX_SHADER`，这是我们在这个类的构造函数中使用的。如果由于某种原因着色器创建失败，错误消息将被写入控制台窗口，并且方法返回`0`。否则，将设置两个GL类型数组：一个用于可能多个着色器的源，另一个用于每个源字符串的长度。目前我们只将处理每个着色器的一个源，但如果我们以后想要处理多个源，这是可能的。
- en: After the source code and its length have been written to the arrays we just
    set up, `glShaderSource` is used to submit the code to a buffer before it gets
    compiled. The function takes in the ID of the newly created shader, the number
    of source strings we're passing in, a pointer to the source array, as well as
    a pointer to the source length array. The shader is then actually compiled using
    `glCompileShader`, and the `CheckError` helper method is invoked to print out
    any possible compilation errors. Note the `GL_COMPILE_STATUS` flag being passed
    in, as well as the false flag, showing that we're interested in checking the status
    of an individual shader, rather than the whole shader program.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在将源代码及其长度写入我们刚刚设置的数组之后，使用`glShaderSource`将代码提交到缓冲区，以便在编译之前。该函数接受新创建的着色器的ID，我们传递的源字符串的数量，源数组的指针，以及源长度数组的指针。然后，使用`glCompileShader`实际编译着色器，并调用`CheckError`辅助方法来打印出任何可能的编译错误。注意传递的`GL_COMPILE_STATUS`标志以及false标志，这表明我们感兴趣的是检查单个着色器的状态，而不是整个着色器程序的状态。
- en: Writing basic shaders
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写基本着色器
- en: 'As our `GL_Shader` class is done, we can finally get to write some basic shaders
    for our application! Let us get started by taking a look at a file named `basic.vert`,
    which is our vertex shader:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`GL_Shader`类已经完成，我们最终可以开始为我们的应用程序编写一些基本的着色器了！让我们先看看一个名为`basic.vert`的文件，这是我们顶点着色器：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we set up the `attribute` of the shader that is going to be written to
    by OpenGL. It is an attribute of type `vec3`, and is going to represent our **vertex
    position** information that gets fed into this shader one by one. This type was
    set up inside the `GL_Model` class constructor using the `glVertexAttribPointer`,
    and then named in the `GL_Shader` class constructor, using the `glBindVertexAttribLocation`
    function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置OpenGL将要写入的着色器`attribute`。它是一个`vec3`类型的属性，并将代表我们一个接一个输入到这个着色器的**顶点位置**信息。这个类型是在`GL_Model`类的构造函数中使用`glVertexAttribPointer`设置的，然后在`GL_Shader`类的构造函数中使用`glBindVertexAttribLocation`函数命名。
- en: The body of the shader has to have a main function, where all of the magic happens.
    In this case, all we need to do is set the internal OpenGL variable `gl_Position`
    to the position we want our vertex to have. It requires a `vec4` type, so the
    position attribute is converted to it, with the last vector value, which is used
    for clipping purposes, being set to `1.0`. For now, we do not need to worry about
    this. Just keep in mind that the actual vertex position in normalized device coordinates
    (coordinates in a range of *(-1,-1)* and *(1,1)*) are set here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器的主体必须有一个主函数，所有的魔法都在这里发生。在这种情况下，我们只需要将内部OpenGL变量`gl_Position`设置为我们的顶点想要的位置。它需要一个`vec4`类型，因此位置属性被转换为它，最后一个向量值，用于裁剪目的，被设置为`1.0`。目前，我们不需要担心这一点。只需记住，实际的顶点位置在归一化设备坐标（范围在*（-1，-1）*和*（1，1）*）中设置在这里。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note the version number on the very first line. If your computer does not support
    OpenGL 4.5, this can be changed to anything else, especially because we are not
    doing anything that older versions do not support.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一行上的版本号。如果你的计算机不支持OpenGL 4.5，可以将其更改为任何其他版本，特别是因为我们没有做任何旧版本不支持的事情。
- en: 'After the vertex information is processed, we also need to worry about shading
    the individual pixels that make up our geometry correctly. This is where the fragment
    shader comes in:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理顶点信息之后，我们还需要担心正确着色组成我们的几何体的单个像素。这就是片段着色器发挥作用的地方：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This shader also uses an internal OpenGL variable. This time it is named `gl_FragColor`,
    and, predictably enough, is used for setting the color of the pixel we are processing.
    For now, let us just shade all of the pixels of our geometry white.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器也使用了一个内部OpenGL变量。这次它被命名为`gl_FragColor`，并且，如预期的那样，用于设置我们正在处理的像素的颜色。目前，让我们将我们的几何体的所有像素都着色为白色。
- en: Drawing our first triangle
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制我们的第一个三角形
- en: 'We have our model class that handles all of the geometry data, as well as the
    shader class, which deals with processing our data at various points of the programmable
    rendering pipeline. With that out of the way, all we have left to do is actually
    set up and use these classes. Let us start by adding them as data members to the
    `Game` object:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的模型类，它处理所有的几何数据，以及着色器类，它处理我们在可编程渲染管道的各个点的数据处理。把这些都处理完毕后，我们剩下的就是实际设置和使用这些类。让我们先从将它们作为数据成员添加到`Game`对象开始：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'They can then be set up in the constructor of our `Game` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以在我们的`Game`类的构造函数中设置：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, the shader class is created and a path with a filename is passed to
    it, so that the `basic.vert` and `basic.frag` shaders inside the `GL` directory
    of our executable directory can be loaded. An array of vertices is then set up,
    with each one being initialized to a particular position in normalized device
    coordinates. This particular arrangement creates three vertices in the middle
    of the screen, which will be connected into a triangle. The coordinates here fall
    within the range of what is known as **normalized device coordinates**. It is
    the coordinate system that the window uses, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个着色器类，并传入一个带有文件名的路径，以便加载可执行目录`GL`目录下的`basic.vert`和`basic.frag`着色器。然后设置一个顶点数组，每个顶点被初始化到特定的归一化设备坐标位置。这种特定的排列在屏幕中间创建三个顶点，它们将被连接成一个三角形。这里的坐标位于所谓的**归一化设备坐标**范围内。这是窗口使用的坐标系，如下所示：
- en: '![Drawing our first triangle](img/image_07_003.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![绘制我们的第一个三角形](img/image_07_003.jpg)'
- en: A `GL_Model` object is then created, with the vertex array and vertex count
    being passed in as arguments. The `GL_Model` then goes on to push this data to
    the GPU, as discussed previously.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个`GL_Model`对象，将顶点数组和顶点计数作为参数传入。然后`GL_Model`将像之前讨论的那样将此数据推送到GPU。
- en: 'Lastly, let us take a look at how we can render our triangle on screen:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看我们如何在屏幕上渲染我们的三角形：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After the window is cleared inside the `BeginDraw()` method, the shader program
    is bound to, so that the vertex and fragment shaders we wrote earlier are used
    when the vertex data of our `GL_Model` is being pushed through the rendering pipeline.
    The models `Draw()` method is then invoked, to begin the rendering process. After
    successful program compilation and execution, this is what we should see on screen:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BeginDraw()`方法内部清除窗口之后，着色器程序被绑定，这样我们之前编写的顶点和片段着色器就可以在推送`GL_Model`的顶点数据到渲染管线时使用。然后调用模型的`Draw()`方法，开始渲染过程。在程序成功编译和执行后，屏幕上应该显示如下内容：
- en: '![Drawing our first triangle](img/image_07_004.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![绘制我们的第一个三角形](img/image_07_004.jpg)'
- en: Hooray! After about 20 pages of theory, we have a triangle. This may be a little
    bit discouraging, but keep in mind that everything from this point on is going
    to get much, much easier. Congratulations on making it this far!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽！经过大约20页的理论学习，我们得到了一个三角形。这可能会有些令人沮丧，但请记住，从现在开始，一切都将变得容易得多。恭喜你走到了这一步！
- en: Using textures
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理
- en: A basic, white triangle is not very exciting to look at. The next obvious improvement
    to make to our code is making textures available to the fragment shader, so that
    they can be sampled and applied to our geometry. Unfortunately, OpenGL does not
    provide a way of actually loading image data, especially since there are so many
    different formats to keep up with. For that, we are going to use one of our resources
    listed at the beginning of this chapter, the STB image loader. It is a small,
    single header C library, used to load image data into a buffer that can later
    be used by OpenGL, or any other library for that matter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的白色三角形看起来并不令人兴奋。接下来，我们代码的下一个明显改进是使纹理对片段着色器可用，以便它们可以被采样并应用到我们的几何体上。不幸的是，OpenGL并没有提供实际加载图像数据的方法，特别是考虑到有如此多的不同格式需要处理。为此，我们将使用本章开头列出的资源之一，即STB图像加载器。它是一个小型单头C库，用于将图像数据加载到缓冲区中，该缓冲区可以稍后由OpenGL或其他任何库使用。
- en: The texture class
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理类
- en: 'Remember the remark that everything is going to get much easier at this point?
    It is true. Let us breeze through the texturing process, starting with a class
    definition for a texture object:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 记得之前提到的，从这一点开始一切都会变得容易得多？这是真的。让我们快速浏览一下纹理处理过程，从纹理对象的类定义开始：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although OpenGL does not actually handle loading texture data, it is still going
    to be handled within the confines of this class. Because of that, the constructor
    of our texture class is still going to take a path to the texture file to be loaded.
    Also, much like the shader class, we are going to need to bind to a specific texture
    before it can be used when rendering geometry. For now, ignore the argument it
    takes. It will be explained down the line.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然OpenGL实际上并不处理加载纹理数据，但它仍然会在本类的范围内进行处理。因此，我们的纹理类构造函数仍然需要传入要加载的纹理文件的路径。同样，就像着色器类一样，在渲染几何体之前，我们需要绑定到特定的纹理上。目前，忽略它所接受的参数。稍后将会解释。
- en: The OpenGL textures, just like shaders or geometry data, have to be stored on
    the GPU. Because of that, it stands to reason that texture data will be referred
    to by a `GLuint` identifier, just like shaders or buffers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与着色器或几何数据一样，OpenGL纹理必须存储在GPU上。因此，可以合理地推断纹理数据将通过`GLuint`标识符来引用，就像着色器或缓冲区一样。
- en: Implementing the texture class
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现纹理类
- en: 'Let us take a look at what needs to be done in order to successfully load textures
    from the hard disk, and push them into the GPU:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为了成功从硬盘加载纹理并将它们推送到GPU需要做什么：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, a few integers are created in order to be filled in with information
    about the texture that is going to be loaded. We then invoke the `stbi_load()`
    function, which is part of the STB image loading library, passing in a path to
    the texture file, pointers to the width, height, and the component count variables
    that are about to be written to, as well as the number of components the file
    is expected to have. The data is stored in the form of an *unsigned char*, a pointer
    to which is returned by the `stbi_load()` function. If `nullptr` was returned,
    we obviously need to return, as the loading process failed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建几个整数以便填充即将加载的纹理的信息。然后，调用`stbi_load()`函数，它是STB图像加载库的一部分，传递纹理文件的路径，指向即将写入的宽度、高度和组件计数变量的指针，以及文件预期的组件数量。数据以*无符号字符*的形式存储，该函数返回指向数据的指针。如果返回`nullptr`，显然需要返回，因为加载过程失败。
- en: 'The number of components an image has is simply the number of color channels.
    Passing in a value of 0 would mean the image data is loaded as is, while any other
    value *forces* the data to contain other color channel information. The component
    number to channel configuration can be evaluated like so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图像所包含的组件数量简单来说就是颜色通道的数量。传入值为0意味着图像数据将按原样加载，而任何其他值都会*强制*数据包含其他颜色通道信息。组件数量到通道配置的评估方式如下：
- en: '| **Components** | **Channels** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **通道** |'
- en: '| 1 | Gray |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 灰色 |'
- en: '| 2 | Gray, alpha |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 灰色，alpha |'
- en: '| 3 | Red, green, blue |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 红色，绿色，蓝色 |'
- en: '| 4 | Red, green, blue, alpha |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 红色，绿色，蓝色，alpha |'
- en: From this point on, we follow what should be a familiar pattern by now. First,
    a texture object is generated using `glGenTextures`, to which the number of textures
    we want is passed as the first argument, and the pointer to the texture identifier
    or a list of them as the second argument. We then bind to the newly created texture
    using `glBindTexture`. The first argument of this function simply lets OpenGL
    know what kind of texture we are dealing with. In this case, `GL_TEXTURE_2D` is
    used, because it is a basic 2D image.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将遵循现在应该已经熟悉的模式。首先，使用`glGenTextures`生成一个纹理对象，将我们想要的纹理数量作为第一个参数传递，并将纹理标识符或它们的列表的指针作为第二个参数传递。然后，我们使用`glBindTexture`绑定到新创建的纹理。这个函数的第一个参数简单地让OpenGL知道我们正在处理什么类型的纹理。在这种情况下，使用`GL_TEXTURE_2D`，因为它是一个基本的2D图像。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: OpenGL supports a myriad of different types of textures for various tasks, including
    3D textures, cube maps, and so on.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL支持多种不同类型的纹理，用于各种任务，包括3D纹理、立方体贴图等。
- en: 'Once a texture is bound to, we can manipulate various details it comes with.
    For textures, the parameter manipulation function is named `glTexParameter()`.
    There are many different types of this single function, all with different suffixes
    that give a hint to the programmer of what data type it is expecting. For our
    purposes, we are going to be using two types: *integer* and *float*, appropriately
    ended by letters *i* and *f*.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦纹理被绑定，我们就可以操作它所附带的各种细节。对于纹理，参数操作函数名为`glTexParameter()`。这个函数有多个不同类型，所有这些类型都以不同的后缀结尾，为程序员提供了关于它期望的数据类型的提示。就我们的目的而言，我们将使用两种类型：*整数*和*浮点数*，分别以字母*i*和*f*结尾。
- en: 'The first two lines deal with defining behavior for cases when texture data
    is being read outside of the boundaries of its size, that is, how the texture
    is wrapped. The `GL_TEXTURE_WRAP_S` parameter deals with wrapping on the *X* axis,
    while the `GL_TEXTURE_WRAP_T` parameter deals with the *Y* axis. Why *S* and *T*
    you may ask? The answer to that is simple. Positional vectors, color data, and
    texture coordinates are enumerated differently, but they both mean roughly the
    same thing. Consider the following table:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行处理的是当纹理数据在其大小边界之外读取时的行为定义，即纹理如何包裹。`GL_TEXTURE_WRAP_S`参数处理的是在*X*轴上的包裹，而`GL_TEXTURE_WRAP_T`参数处理的是*Y*轴。为什么是*S*和*T*？答案很简单。位置向量、颜色数据和纹理坐标的枚举方式不同，但它们都大致意味着相同的东西。考虑以下表格：
- en: '|  | 1 | 2 | 3 | 4 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|  | 1 | 2 | 3 | 4 |'
- en: '| Position | X | Y | Z | W |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | X | Y | Z | W |'
- en: '| Color | R | G | B | A |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 颜色 | R | G | B | A |'
- en: '| Textures | S | T | P | Q |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 纹理 | S | T | P | Q |'
- en: They are all vectors of four values. Accessing the position *X* value is the
    same as accessing the red channel of a color structure, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是四个值的向量。访问位置*X*值与访问颜色结构的红色通道相同，依此类推。
- en: The next two function calls deal with how the texture is interpolated when being
    sized down or up. Both cases specify the `GL_LINEAR` parameter, which means the
    pixels will be linearly interpolated.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个函数调用处理了纹理在缩放时如何插值的问题。两种情况都指定了`GL_LINEAR`参数，这意味着像素将进行线性插值。
- en: Finally, we actually submit the loaded pixel information to the GPU by invoking
    the `glTexImage2D()` method. Its first argument, once again, lets OpenGL know
    what type of texture we are submitting. The second argument is the texture's level
    of detail, which will be used for mip-mapping. The value `0` simply means it is
    the base level texture.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`glTexImage2D()`方法实际上将加载的像素信息提交给GPU。它的第一个参数再次让OpenGL知道我们正在提交哪种类型的纹理。第二个参数是纹理的细节级别，它将用于Mip映射。值`0`简单地意味着它是基本级别的纹理。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mip-mapping is an optional technique that can be utilized by OpenGL, in which
    multiple versions of the same texture, but of different resolutions, are loaded
    and submitted to the GPU, and later applied to geometry depending on how far it
    is from the viewer. If it is further away, a lower resolution texture (with a
    higher mip-mapping level) is used. This can be done for performance reasons, when
    necessary.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Mip映射是一种可选技术，OpenGL可以利用它，其中加载并提交给GPU的是同一纹理的多个版本，但具有不同的分辨率，并且根据它距离观察者的距离来应用几何体。如果它更远，则使用较低分辨率的纹理（具有更高的Mip映射级别）。这可以出于性能原因，在必要时进行。
- en: The third argument lets OpenGL know what arrangement the pixel information data
    is in. This is necessary, because certain formats may store it in varying configurations.
    The width and height information is passed in next, along with a number of pixels
    that can be used to add a border to the texture. We are not going to be using
    that feature, which is why `0` is passed in. The next argument is, once again,
    a flag for a certain arrangement of pixels. This time it lets OpenGL know which
    arrangement we want it to store the pixel data in. Finally, a flag for the type
    that our loaded texture is in is passed, along with a pointer to the actual texture
    data. We are using the `GL_UNSIGNED_BYTE` parameter, because that is what the
    STB image loader returns, and the *char* type is exactly one byte long.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数让OpenGL知道像素信息数据的排列方式。这是必要的，因为某些格式可能以不同的配置存储它。接下来传递宽度和高度信息，以及可以用来为纹理添加边框的像素数量。我们不会使用该功能，因此传递了`0`。下一个参数再次是一个标志，用于特定的像素排列。这次它让OpenGL知道我们希望它将像素数据存储在哪种排列中。最后，传递了一个标志，用于我们加载的纹理的类型，以及指向实际纹理数据的指针。我们使用`GL_UNSIGNED_BYTE`参数，因为这是STB图像加载器返回的，而`char`类型正好是一个字节长。
- en: After the texture information is submitted to the GPU, we no longer need to
    keep the image data buffer around. It's destroyed by calling `stbi_image_free`,
    and passing in the pointer to the buffer.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在将纹理信息提交给GPU之后，我们不再需要保留图像数据缓冲区。通过调用`stbi_image_free`并传入缓冲区指针来销毁它。
- en: 'The data we submitted to the GPU needs to be released once we no longer need
    the texture:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提交给GPU的数据，一旦不再需要纹理，就需要释放：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `glDeleteTextures` function takes the number of textures we want to dispose
    of, as well as a pointer to an array of *GLuint* identifiers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`glDeleteTextures`函数接收我们想要丢弃的纹理数量，以及一个指向`GLuint`标识符数组的指针。'
- en: 'Finally, let''s implement the `Bind()` method, which is going to give us the
    ability to use the texture when rendering:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们实现`Bind()`方法，这将使我们能够在渲染时使用纹理：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: OpenGL actually supports the ability for multiple textures to be bound all at
    once while rendering, so that complex geometry can be textured more efficiently.
    The exact number, at least at the time of writing, is `32` units. Most of the
    time we are not going to need that many, but it is nice to have the option. The
    identifier of the unit we want to use is passed in as an argument to the `Bind()`
    method. In order to avoid confusion, we are going to perform an `assert()` method
    and make sure that the `l_unit` value is in the right range first.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL实际上支持在渲染时同时绑定多个纹理的能力，这样就可以更有效地对复杂几何体进行纹理处理。确切的数量，至少在撰写本文时，是`32`个单位。大多数时候我们不需要那么多，但有一个选项是很好的。我们想要使用的单位标识符作为参数传递给`Bind()`方法。为了避免混淆，我们将执行一个`assert()`方法并确保`l_unit`值在正确的范围内。
- en: In order to enable a specific unit for a texture, the `glActiveTexture()` method
    needs to be called. It takes a single argument, which is the enumerated texture
    unit. It ranges from `GL_TEXTURE0` all the way to `GL_TEXTURE31`. Because those
    values are sequential, a neat trick is to simply add the `l_unit` to the `GL_TEXTURE0`
    definition, which will give us the right unit enumeration. After that, we simply
    bind to the texture as before, using the `glBindTexture()` method and passing
    in the type of texture we have, along with its identifier.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用特定纹理的单位，需要调用`glActiveTexture()`方法。它接受一个参数，即枚举的纹理单位。它从`GL_TEXTURE0`一直延伸到`GL_TEXTURE31`。因为这些值是连续的，一个巧妙的方法是简单地将`l_unit`添加到`GL_TEXTURE0`定义中，这将给我们正确的单位枚举。之后，我们就像之前一样绑定到纹理，使用`glBindTexture()`方法，并传递我们拥有的纹理类型及其标识符。
- en: Model and shader class changes
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型和着色器类更改
- en: 'To add support for textured geometry, we first need to make some changes to
    the vertex information that gets stored. Let us take a look at the `GL_Vertex`
    structure to see what needs to be added:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加对纹理几何体的支持，我们首先需要对存储的顶点信息进行一些修改。让我们看看`GL_Vertex`结构，看看需要添加什么：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, we need an additional vertex attribute, which is the coordinate
    of the texture a vertex is associated with. It is a simple two-dimensional vector
    that represents the texture coordinates, as shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要一个额外的顶点属性，即与顶点关联的纹理坐标。它是一个简单的二维向量，表示纹理坐标，如下所示：
- en: '![Model and shader class changes](img/image_07_005.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![模型和着色器类更改](img/image_07_005.jpg)'
- en: The great thing about representing texture coordinates in this fashion is the
    fact that it makes the coordinates resolution-independent. A point *(0.5,0.5)*
    on a smaller texture is going to be the exact same point on its larger counterpart.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式表示纹理坐标的优点是它使得坐标分辨率无关。在较小的纹理上，点*(0.5,0.5)*将与其较大的对应点完全相同。
- en: 'Because we now have more information about a single vertex that needs to be
    stored and accessed, the VAO needs to know exactly how to do so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在需要存储和访问单个顶点的更多信息，VAO需要确切知道如何做到这一点：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We now get to utilize the stride and offset parameters that were discussed previously!
    The stride is, of course, the full size of a `GL_Vertex` structure, while the
    offset to obtain texture coordinates is the size of the vertex position vector,
    because that is the amount by which the pointer needs to be offset.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始使用之前讨论过的步进和偏移参数了！步进当然是`GL_Vertex`结构的大小，而获取纹理坐标的偏移量是顶点位置向量的大小，因为这是指针需要偏移的量。
- en: After the data is submitted to the buffer, we enable the vertex position attribute
    and provide its pointer with the `stride`. The offset remains `0`, because `Position`
    is the first attribute.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据提交到缓冲区之后，我们启用顶点位置属性，并使用`stride`提供其指针。偏移量保持为`0`，因为`Position`是第一个属性。
- en: We also need to enable the `TexCoord` attribute, because it will be passed to
    the shaders as well. Its pointer is set up similarly to that of position, except
    we have `2` floats instead of `3`, and the offset now needs to be applied, so
    that the position data is skipped.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要启用`TexCoord`属性，因为它也将传递到着色器中。它的指针设置方式与位置类似，但我们有`2`个浮点数而不是`3`，现在需要应用偏移，以便跳过位置数据。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the `void*` cast for the last argument. This is because the offset actually
    takes a pointer, rather than a number of bytes. It is one of the leftover *legacy*
    details, and only means the number of bytes in newer versions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一个参数的`void*`转换。这是因为偏移实际上接受一个指针，而不是字节数。这是遗留的*细节*之一，在新版本中仅表示字节数。
- en: 'The final change to our C++ code pertains to updating the `GL_Shader` class,
    in order to register the new attribute that is going to be passed in to the vertex
    shader:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们C++代码的最终更改是更新`GL_Shader`类，以便注册将要传递到顶点着色器的新属性：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It simply establishes a name for our texture coordinate attribute, which is
    now `"texCoordVert"`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是为我们的纹理坐标属性建立了一个名称，现在命名为`"texCoordVert"`。
- en: Updating the shaders
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新着色器
- en: 'The actual sampling of the texture takes place inside the fragment shader.
    However, as the data is actually received in the vertex shader first, let us see
    how it needs to be updated to cater to our needs:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的纹理采样发生在片段着色器内部。然而，由于数据实际上首先在顶点着色器中接收，让我们看看它需要如何更新以满足我们的需求：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, the `texCoordVert` attribute is established here, along with
    a `varying` 2D vector named `texCoord`. A varying type simply means that its data
    is going to be passed down the rendering pipeline and received by the next shader
    in line. In our case, `texCoord` is going to be accessible inside the fragment
    shader. Its value is set to the input attribute of `texCoordVert`. Why? Because
    varying data received by any shader down the line is **interpolated**. That''s
    right. Take a look at the following diagram:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里建立了`texCoordVert`属性，以及一个名为`texCoord`的2D向量`varying`。`varying`类型仅仅意味着其数据将被传递到渲染管线中，并被下一个着色器接收。在我们的例子中，`texCoord`将在片段着色器内部可访问。其值设置为`texCoordVert`的输入属性。为什么？因为任何着色器接收到的`varying`数据都是**插值**的。没错。看看下面的图示：
- en: '![Updating the shaders](img/image_07_006.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![更新着色器](img/image_07_006.jpg)'
- en: 'In order to accurately sample color information for each pixel of our geometry,
    we do not really need to do any math by ourselves. Interpolation, or weighted
    averaging, takes care of that for us. If one vertex has texture coordinates of,
    let''s say **(1,1)**, and the opposite vertex has the coordinates **(0,0)**, the
    fragment shader executing on a pixel somewhere in between those vertices will
    receive the **interpolated** value of **(0.5, 0.5)**. This makes coloring a pixel
    as easy as this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准确采样我们几何体每个像素的颜色信息，我们实际上并不需要自己进行任何数学运算。插值，或者加权平均，为我们处理了这一切。如果一个顶点的纹理坐标是，比如说**(1,1**)，而相对的顶点坐标是**(0,0**)，那么在两个顶点之间的某个像素上执行的片段着色器将接收**插值**值为**(0.5,
    0.5**)。这使得给像素上色变得如此简单：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, note the `uniform` variable of type `sampler2D`, called `texture`. We
    do not need to manually pass this into our shaders as it is done behind the scenes.
    It simply provides access to the data of the current texture that it is bound
    to. Next, we set up the varying variable `texCoord`, which completes the *piping*
    of data from the vertex shader to the fragment shader. The fragment color is then
    set to a `vec4`, which gets returned from the `texture2D()` function that takes
    in the texture received by the fragment shader, as well as the coordinates we
    want to sample. Since the `vec4` that gets returned represents the color of the
    pixel, that is all that it takes to texture geometry!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意类型为`sampler2D`的`uniform`变量，名为`texture`。我们不需要手动将其传递到着色器中，因为这是在幕后完成的。它只是提供了访问绑定到当前纹理的数据的权限。接下来，我们设置变量`texCoord`，这完成了从顶点着色器到片段着色器的数据*管道*。然后，将片段颜色设置为`vec4`，它由`texture2D()`函数返回，该函数接收片段着色器接收到的纹理以及我们想要采样的坐标。由于返回的`vec4`代表像素的颜色，这就足以纹理化几何体了！
- en: Using a texture
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纹理
- en: 'Applying the texture to our geometry is quite simple at this point. First,
    the `GL_Texture` class needs to be added as a data member to the `Game` object.
    We can then proceed to set everything else up as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，将纹理应用到我们的几何体上相当简单。首先，需要将`GL_Texture`类添加为`Game`对象的数据成员。然后我们可以按照以下步骤设置其他一切：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `GL_Vertex` objects now take an additional argument, which represents the
    texture coordinates of the vertex. We also load the brick texture in the constructor,
    which is then bound to in the `Render()` method, right before the shader. When
    our model is rendered, it should look as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`GL_Vertex`对象现在接受一个额外的参数，它代表顶点的纹理坐标。我们还在构造函数中加载了砖块纹理，然后在`Render()`方法中将其绑定，就在着色器之前。当我们的模型被渲染时，它应该看起来如下：'
- en: '![Using a texture](img/image_07_007.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理](img/image_07_007.jpg)'
- en: We now have a motionless model with a texture applied. Still not very exciting,
    but we are getting there!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个应用了纹理的静止模型。仍然不太令人兴奋，但我们正在接近目标！
- en: Applying transformations
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用变换
- en: Moving, rotating, and otherwise manipulating vertex data may seem quite straight
    forward. One may even be tempted to simply update the vertex position information
    and simply resubmit that data back to the VBO. While things may have been done
    that way for a while in the past, there are much more efficient, albeit more math-intensive
    ways of performing this task. Displacing vertices is now done in the vertex shader
    by simply multiplying the vertex positions by something called a **matrix**.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 移动、旋转以及其他方式操纵顶点数据可能看起来相当直接。甚至有人可能会倾向于简单地更新顶点位置信息，并将这些数据重新提交到VBO。虽然过去可能一直是这样做的，但执行此任务有更高效、尽管更数学密集的方法。现在，通过简单地乘以称为**矩阵**的东西，顶点的位移现在在顶点着色器中完成。
- en: Matrix basics
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵基础
- en: 'Matrices are extremely useful in graphics programming, because they can represent
    any kind of rotation, scale, or displacement manipulation that can be applied
    to a vector. There are many different types of matrices, but they are all just
    blocks of information that look similar to this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵在图形编程中极其有用，因为它们可以表示应用于向量的任何类型的旋转、缩放或位移操作。存在许多不同类型的矩阵，但它们都是类似这样的信息块：
- en: '![Matrix basics](img/image_07_008.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵基础](img/image_07_008.jpg)'
- en: This particular matrix is a 4x4 identity matrix, but a variety of differently
    sized matrices exist, such as 3x3, 2x3, 3x2, and so on. There are rules when it
    comes to adding, subtracting, multiplying, or dividing them. We are not really
    going to get into that as it is beyond the scope of this chapter. The nice thing
    is that the `glm` library abstracts all of this away for us, so it is not absolutely
    necessary to know much about this for now. A thing to take away from this is that
    positional vectors can be transformed when added to or multiplied by matrices.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的矩阵是一个4x4的单位矩阵，但存在各种不同大小的矩阵，例如3x3、2x3、3x2等等。在加法、减法、乘法或除法时存在规则。我们实际上不会深入探讨这一点，因为它超出了本章的范围。好事是`glm`库为我们抽象了所有这些，所以现在我们不必绝对了解这些。从这个中我们可以得到的一个要点是，位置向量可以在加到或乘以矩阵时进行变换。
- en: The world space
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 世界空间
- en: 'Up until this point, we have been working with vertex positions that are specified
    in the normalized device coordinate space. This means that each vertex coordinate
    is actually relative to the center of the screen. In order to properly deal with
    transformations; however, we want to treat our geometry as being relative to an
    origin point that falls within the **model space**, as shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用在归一化设备坐标空间中指定的顶点位置。这意味着每个顶点坐标实际上相对于屏幕中心。然而，为了正确处理变换；我们希望将我们的几何形状视为相对于**模型空间**中的某个原点，如下所示：
- en: '![The world space](img/image_07_009.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![世界空间](img/image_07_009.jpg)'
- en: 'If a model has an origin, it can also have a global position within our world,
    where its origin is relative to some arbitrary point within the game world we
    have constructed. This global position, as well as some other attributes, such
    as the scale and rotation of the object, can be represented by a matrix. Applying
    these attributes to the vertex coordinates that are in model space, which is exactly
    what happens when they are multiplied by the **model matrix**, allows us to bring
    those coordinates into what is known as **world space**, as shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模型有一个原点，它也可以在我们的世界中有一个全局位置，其中其原点相对于我们构建的游戏世界中的某个任意点。这个全局位置以及一些其他属性，如对象的缩放和旋转，可以用一个矩阵来表示。将这些属性应用于模型空间中的顶点坐标，这正是当它们乘以**模型矩阵**时发生的情况，使我们能够将这些坐标带入所谓的**世界空间**，如下所示：
- en: '![The world space](img/image_07_010.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![世界空间](img/image_07_010.jpg)'
- en: This transformation simply means that the vertices are now relative to the world's
    origin, rather than the model origin, allowing us to accurately represent models
    in our own coordinate system before drawing them on screen.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变换简单来说就是顶点现在相对于世界的原点，而不是模型原点，这使得我们能够在屏幕上绘制之前，准确地在我们自己的坐标系中表示模型。
- en: The transform class
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变换类
- en: 'Before any transformations can be applied, they should be properly grouped
    together and represented by a single data structure. The `GL_Transform` class
    is going to do exactly that for us:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用任何变换之前，它们应该被适当地分组并由一个单一的数据结构表示。`GL_Transform`类将为我们做这件事：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, note the included headers on top. These are necessary for the data types
    and transformation functions that are going to be used in this class. Outside
    of that, we have three vectors that are going to represent the model's position,
    rotation, and scale, which are going to be used for calculating the model matrix
    that transforms vertices into world coordinates.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意顶部的包含头文件。这些是本类中将使用的数据类型和变换函数所必需的。除此之外，我们还有三个向量，将代表模型的位置、旋转和缩放，这些将被用于计算将顶点转换成世界坐标的模型矩阵。
- en: Implementing the transform class
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现变换类
- en: 'The constructor simply takes in the appropriate arguments and sets up some
    data members using the initializer list:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数简单地接受适当的参数并使用初始化列表设置一些数据成员：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The meat of this class is the `GetModelMatrix()` method, as it deals with all
    the necessary math:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的核心是`GetModelMatrix()`方法，因为它处理所有必要的数学运算：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The model matrix is going to be a result of many other matrices being multiplied
    together, thus making it contain all of the necessary transformation information.
    We begin by creating what is known as a **translation matrix**. Calling `glm::translate`
    creates one for us, with the position information of `m_position`. It is used
    to bring the positions of our vertices into world space.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 模型矩阵将是许多其他矩阵相乘的结果，因此它将包含所有必要的变换信息。我们首先创建一个称为**平移矩阵**的东西。调用`glm::translate`为我们创建一个，带有`m_position`的位置信息。它用于将我们的顶点位置带入世界空间。
- en: We then create a **scale matrix**, which is responsible for representing scaling
    or shrinking of a model. For example, if a model should be drawn as twice as big
    as it's stored on the GPU, the scale matrix will be used to adjust the positions
    of all vertices to make it look that way. Using `glm::scale` and passing in the
    scale vector as the argument will construct one for us.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个**缩放矩阵**，它负责表示模型的缩放或缩小。例如，如果一个模型应该绘制为存储在GPU上的两倍大小，那么缩放矩阵将用于调整所有顶点的位置，使其看起来是这样。使用`glm::scale`并传入缩放向量作为参数将为我们构建一个。
- en: The final type of matrix we need is the **rotation matrix**. It obviously represents
    different rotation values of an object, thus displacing all the vertices around
    an origin point. This one, however, is not quite so straightforward due to the
    fact that we are storing rotation information as a vector of **degrees**. Because
    of that, matrices of each axis need to be created using the `glm::rotate` function,
    which takes the degree of rotation, as well as a **directional vector**, representing
    the axis around which the rotation is desired. It simply means setting a value
    of `1` for the *x*, *y*, or *z* component, depending on which axis we are dealing
    with. The final rotational matrix is then calculated by multiplying all three
    previous matrices together. Using a different multiplication order will produce
    different results. Generally, a rule of thumb is to multiply all matrices in reverse
    order of application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一种矩阵是**旋转矩阵**。它显然代表了物体的不同旋转值，因此将所有顶点围绕一个原点进行位移。然而，由于我们将旋转信息存储为**度数**向量，所以这个矩阵并不那么直接。因此，每个轴的矩阵都需要使用`glm::rotate`函数来创建，该函数接受旋转角度以及一个**方向向量**，表示期望旋转的轴。这意味着根据我们处理的哪个轴，只需为*x*、*y*或*z*分量设置值为`1`。最终的旋转矩阵是通过将所有三个之前的矩阵相乘来计算的。使用不同的乘法顺序会产生不同的结果。一般来说，一个经验法则是按照应用的相反顺序乘以所有矩阵。
- en: 'Finally, we can calculate the model matrix by multiplying all previous matrices
    together like so:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过以下方式将所有之前的矩阵相乘来计算模型矩阵：
- en: '![Implementing the transform class](img/image_07_011.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![实现变换类](img/image_07_011.jpg)'
- en: The resulting model matrix is then returned.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后返回得到的模型矩阵。
- en: 'The rest of this class is fairly straightforward, as there is nothing else
    except setters and getters left:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课的剩余部分相当直接，因为除了设置器和获取器之外，没有其他内容：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Updating the shader class
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新着色器类
- en: 'Once again, we are going to be using the shader class to submit the necessary
    matrix information to the vertex shader, where it will be used. The reason this
    is done inside the vertex shader is because the GPU is optimized for operations
    like this. Let us take a look at what we need to change:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将使用着色器类来提交必要的矩阵信息到顶点着色器，在那里它将被使用。这样做是在顶点着色器中进行的原因是因为GPU针对此类操作进行了优化。让我们看看我们需要更改的内容：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, note a new enumeration that we have established. It enumerates all the
    uniform variable types that our shaders need, which, for now, consists of only
    one.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意我们建立的一个新枚举。它列出了我们的着色器需要的所有均匀变量类型，目前只包含一个。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A uniform performs a different task from the usual shader attributes or varying
    variables. Attributes are *filled in* by OpenGL behind the scenes, using data
    from the VBO. Varying shader variables are passed between shaders. A uniform variable
    is actually passed into the shader by our C++ code, which is why we need to treat
    it differently.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀变量执行的任务与通常的着色器属性或变化变量不同。属性在OpenGL幕后由OpenGL填充，使用来自VBO的数据。变化的着色器变量在着色器之间传递。均匀变量实际上是通过我们的C++代码传递到着色器的，这就是为什么我们需要以不同的方式处理它。
- en: The `GL_Shader` class now also needs an `Update()` method, which is going to
    take in a reference to the `GL_Transform` class and use it to pass the model matrix
    to the vertex shader. Lastly, we need to store identifiers that are used to locate
    uniform variables within shaders, so that they can be used. The `m_uniform` data
    member exists for that exact purpose.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`GL_Shader`类现在还需要一个`Update()`方法，它将接受对`GL_Transform`类的引用，并使用它将模型矩阵传递到顶点着色器。最后，我们需要存储用于在着色器中定位均匀变量的标识符，以便它们可以被使用。`m_uniform`数据成员就是为了这个目的存在的。'
- en: 'Let''s see how a uniform variable location can be obtained and stored:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何获取和存储均匀变量位置：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, OpenGL provides a nice function for that, called `glGetUniformLocation`.
    It takes an identifier of the program we are using, as well as the name of the
    uniform variable inside the shader, which is `"transform"`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，OpenGL提供了一个很好的函数来完成这个任务，称为`glGetUniformLocation`。它接受我们正在使用的程序的标识符，以及着色器内部均匀变量的名称，即`"transform"`。
- en: 'Setting the value of a uniform variable also comes down to a single function
    call:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 设置均匀变量的值也归结为单个函数调用：
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First, we obtain the model matrix from the transform class. The `glUniform`
    function is then called. It has a suffix of the exact data type we are submitting,
    which, in this case, is a 4x4 matrix of floats. The uniform ID we stored earlier
    is used as the first argument. The amount of data being submitted is the second
    argument, which in this case is only `1`, as one matrix is being submitted. The
    third argument is a flag that lets us transpose the matrix. We do not need to
    do that, so `GL_FALSE` is passed in. Finally, a pointer to the first element of
    the matrix is passed as the last argument. OpenGL knows exactly how big the matrix
    is, as we are calling the appropriate function, which allows it to read the entire
    matrix.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从变换类中获取模型矩阵。然后调用`glUniform`函数。它有一个后缀，表示我们正在提交的确切数据类型，在这种情况下，是一个4x4的浮点矩阵。我们之前存储的均匀ID用作第一个参数。正在提交的数据量是第二个参数，在这种情况下是`1`，因为我们只提交了一个矩阵。第三个参数是一个标志，允许我们转置矩阵。我们不需要这样做，所以传入`GL_FALSE`。最后，将矩阵的第一个元素的指针传递为最后一个参数。OpenGL知道矩阵的确切大小，因为我们调用了适当的函数，这使得它可以读取整个矩阵。
- en: 'Lastly, we need to modify the vertex shader in order to actually perform the
    transformation:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改顶点着色器以实际执行变换：
- en: '[PRE38]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note the `uniform` of type `mat4` being added. We simply need to multiply it
    by the position in the main function, which gives us our transformed vertex position.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意添加的`uniform`类型为`mat4`。我们只需要在主函数中将它乘以位置，这样就得到了我们的变换后的顶点位置。
- en: Manipulating the triangle
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作三角形
- en: 'Once again, all we have left to do in order to apply the code we have written
    is add it to the `Game` class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了应用我们编写的代码，我们剩下的唯一事情是将它添加到`Game`类中：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It really does not need any more setting up than that. We can jump straight
    to manipulation of the transform''s properties, by editing the `Update()` method:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上不需要更多的设置。我们可以直接跳转到通过编辑`Update()`方法来操作变换的属性：
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this case, we are simply playing around with rotations along all axes. After
    making those modifications, it is important to pass the transform object to the
    `GL_ShaderUpdate()` method, so that the vertices can be properly transformed,
    giving us this resulting rotation:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是在所有轴上玩旋转。在做出这些修改后，将变换对象传递给`GL_ShaderUpdate()`方法非常重要，这样顶点才能被正确变换，从而得到以下结果旋转：
- en: '![Manipulating the triangle](img/image_07_012.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![操作三角形](img/image_07_012.jpg)'
- en: Now we are getting somewhere! Still, we have no interaction with the scene.
    This whole time we are just sitting still while the geometry just spins around.
    At best, this is just a very elaborate screensaver. Let's actually implement something
    that will give us some *mobility*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在取得进展！然而，我们仍然没有与场景进行交互。在这整个过程中，我们只是静静地坐着，而几何体只是旋转。这最多只是一个非常复杂的屏保。让我们实际实现一些能够给我们带来一些**移动性**的功能。
- en: Creating a camera
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建摄像机
- en: OpenGL, unlike SFML, does not offer any means of actually moving around the
    view or the camera. While this may seem odd at first, that is mainly because there
    is no camera or view to move around. Yes, you heard that right. No camera, no
    views, just vertex data, shaders, and raw math to the rescue. How? Let's take
    a look!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与SFML不同，OpenGL不提供移动视图或摄像机的方法。虽然这乍一看可能有些奇怪，但这主要是因为没有摄像机或视图可以移动。是的，你听对了。没有摄像机，没有视图，只有顶点数据、着色器和原始数学来拯救。如何？让我们看看！
- en: View projection essentials
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图投影基础
- en: 'All of the rendering and programming trickery that lots of libraries abstract
    away is exactly that - tricks. When it comes to moving around the game world,
    there is no real *camera* that conveniently films the right sides of geometry
    to be rendered. The camera is just an illusion, used to abstract away concepts
    that are not intuitive. Moving around a game world involves nothing else except
    additional matrix math that is performed on the **vertices themselves**. The act
    of rotating the *camera* around the scene simply comes down to the exact opposite
    of that: rotating the scene around a point in space that is referred to as the
    camera. Once again, we are going to be transforming our vertices to be relative
    to yet another point of origin, and this time, it is the camera itself. Consider
    the following diagram:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数库抽象掉的渲染和编程技巧实际上就是那些技巧。当涉及到在游戏世界中移动时，并没有真正的**摄像机**方便地拍摄要渲染的几何体的正确侧面。摄像机只是一个幻觉，用于抽象那些不直观的概念。在游戏世界中移动除了在顶点上执行额外的矩阵数学运算之外，不涉及其他任何事情。围绕场景旋转摄像机的行为实际上正好相反：围绕被称为摄像机的空间中的点旋转场景。再一次，我们将把顶点转换成相对于另一个原点，这次是摄像机本身。考虑以下图示：
- en: '![View projection essentials](img/image_07_013.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![视图投影基础](img/image_07_013.jpg)'
- en: In order to implement the camera class and be able to *move around* the world,
    we need to know a few basics. First of all, we have to decide how wide the view
    angle of the camera should be. This affects how much we can actually see. The
    other important detail is correctly setting up the **view frustum**. Think of
    it as a pyramid shaped piece of geometry that defines the range of the camera's
    view. It determines how close certain things can be until they are no longer seen,
    as well as what's the maximum distance of an object from the camera until it's
    no longer rendered.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现摄像机类并能够在世界中**移动**，我们需要了解一些基础知识。首先，我们必须决定摄像机的视场角度应该有多宽。这会影响我们实际上能看到多少。另一个重要的细节是正确设置**视锥体**。想象一下，它是一个定义摄像机视场范围的金字塔形几何体。它决定了某些事物可以多近直到它们不再被看到，以及物体从摄像机到不再被渲染的最大距离。
- en: 'The aspect ratio of our window, as well as the field of view, near/far distances
    of the view frustum, and the position of the camera all add up to a total of two
    matrices we are going to calculate: the **view matrix** and **projection matrix**.
    The former deals with positioning vertices relative to the camera''s position,
    while the latter adjusts and warps them, which depends on how close or far away
    they are from the view frustum, the field of view, and other attributes.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们窗口的宽高比、视场、视锥体的近/远距离以及摄像机的位置共同构成了我们将要计算的两个矩阵：**视图矩阵**和**投影矩阵**。前者处理将顶点相对于摄像机位置进行定位，而后者则根据它们与视锥体、视场和其他属性的远近进行调整和扭曲。
- en: 'There are mainly two projection types we can work with: **perspective** and
    **orthographic**. The perspective projection offers a realistic result where objects
    can appear to be further away from the camera, while orthographic projection is
    more of a fixed depth feel, making objects look the same size regardless of their
    distances. We are going to be using the perspective projection for our purposes.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以主要使用两种投影类型：**透视**和**正交**。透视投影提供了一种逼真的结果，其中对象可以看起来离相机更远，而正交投影则更像是一种固定深度感，使得无论对象的距离如何，看起来大小都相同。我们将使用透视投影来完成我们的任务。
- en: The camera class
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相机类
- en: 'With all of this information covered, we are finally ready for the smoke and
    mirrors that is the `GL_Camera` class. Let us see what it takes in order to manoeuvre
    around our world:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖了所有这些信息之后，我们终于准备好了解`GL_Camera`类这个烟雾和镜子了。让我们看看要在这个世界中操纵需要什么：
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, we are storing all of the covered details, as well as a couple
    of new ones. Along with the field of view angle, the aspect ratio, and the near
    and far frustum values, we also need to keep around the position, a forward direction
    vector, and the up direction vector. The `m_forwardDir` is a normalized directional
    vector that represents which way the camera is looking. The `m_upDir` is also
    a normalized directional vector, but it simply stores the *up* direction. This
    will all start to make sense soon.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们存储了所有已覆盖的细节，以及一些新的内容。除了视场角度、纵横比以及近远视锥值之外，我们还需要保留位置、一个前进方向向量以及一个向上方向向量。`m_forwardDir`是一个归一化的方向向量，表示相机所看的方向。`m_upDir`也是一个归一化的方向向量，但它仅仅存储了*向上*的方向。这一切很快就会变得有意义。
- en: Implementing the camera class
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现相机类
- en: 'Let us see what the constructor of this class looks like:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个类构造器长什么样：
- en: '[PRE42]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Outside of initializing our data members, the constructor has three tasks. It
    recalculates the perspective matrix, which only needs to be done once unless the
    window is resized, and it sets up both the forward direction, and the up direction.
    The camera starts out looking towards the positive *Z* axis, which is literally
    *towards* the screen, if you imagine it in those terms. The *up* direction is
    the positive Y axis.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 除了初始化数据成员之外，构造函数有三个任务。它重新计算透视矩阵，这通常只需要做一次，除非窗口大小发生变化，并且它设置前进方向和向上方向。相机最初是朝向正*Z*轴，如果你这样想象的话，就是*朝向*屏幕的方向。*向上*的方向是正Y轴。
- en: 'Calculating the perspective matrix is quite simple, thanks to the `glm` library:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有`glm`库的帮助，计算透视矩阵相当简单：
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Our matrix is constructed by the `glm::perspective` function, which takes in
    the field of view, the aspect ratio, and both frustum distances.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的矩阵是通过`glm::perspective`函数构建的，它接受视场、纵横比以及两个视锥距离。
- en: 'Finally, we can obtain the **view projection matrix**, which is simply a combination
    of the view and projection matrix:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以获得**视图投影矩阵**，它仅仅是视图矩阵和投影矩阵的组合：
- en: '[PRE44]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We begin by calculating the view matrix, using the `glm::lookAt` function. It
    takes in the position of the camera, the point the camera is looking at, and the
    *up* direction. Afterwards, the multiplication of our perspective matrix and the
    view matrix results in obtaining the view projection matrix, which is returned
    for later use.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`glm::lookAt`函数计算视图矩阵。它接受相机的位置、相机所看的点以及*向上*的方向。之后，我们的透视矩阵和视图矩阵的乘积得到视图投影矩阵，该矩阵随后被返回以供后续使用。
- en: Updating the rest of the code
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新其余的代码
- en: 'Because our geometry needs to, once again, be transformed relative to yet another
    origin, we need to update the `GL_Shader` class:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的几何形状需要相对于另一个原点进行变换，我们需要更新`GL_Shader`类：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because the vertex shader is already multiplying its position by a transform,
    we can simply change which matrix it uses inside the `Update()` method. After
    the model matrix is obtained, we also grab the view projection matrix and multiply
    the two together. The resulting **model view matrix** is then passed down to the
    vertex shader.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因为顶点着色器已经通过变换乘以其位置，我们可以在`Update()`方法内部简单地更改它使用的矩阵。在获得模型矩阵后，我们也获取视图投影矩阵并将它们相乘。然后，得到的**模型视图矩阵**被传递到顶点着色器。
- en: 'Finally, the camera needs to be created inside the `Game` class:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要在`Game`类内部创建相机：
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It also needs to be set up with the appropriate information:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 它也需要用适当的信息进行设置：
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We begin by calculating the window's aspect ratio, which is its width divided
    by its height. After the `frustum_near` and `frustum_far` values are set up, they
    get passed in to the camera's constructor, along with its initial position, the
    field of view angle, and the aspect ratio of the window.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算窗口的宽高比，即其宽度除以高度。在设置`frustum_near`和`frustum_far`值后，它们被传递给相机的构造函数，包括其初始位置、视场角度和窗口的宽高比。
- en: 'Finally, we just need to update the shader class with the camera''s information:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要更新着色器类以包含相机的信息：
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Upon successful compilation and execution, we should see our triangle slightly
    further away from the camera, because its position was set to `-5.f`on the *Z*
    axis.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功编译和执行后，我们应该看到我们的三角形稍微远离相机，因为它的位置被设置为*Z*轴上的`-5.f`。
- en: Moving the camera around
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在相机周围移动
- en: 'Having a programmable camera is nice, but it still does not allow us to freely
    roam the scene. Let ''s actually give our camera class the ability to be manipulated
    in real time, so that we can have the illusion of floating around the world:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个可编程的相机很棒，但它仍然不能让我们自由地在场景中漫游。让我们实际上给我们的相机类赋予实时操作的能力，这样我们就可以产生在世界中漂浮的错觉：
- en: '[PRE49]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see, we are going to use two methods for that: one for moving the
    camera, and another for rotating it. We are also defining a helpful enumeration
    of all six possible directions.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将为此使用两种方法：一种用于移动相机，另一种用于旋转它。我们还定义了一个有用的枚举，包含所有六个可能的方向。
- en: 'Moving a position vector is fairly simple. Assume we have a scalar value that
    represents the speed of the camera. If we multiply it by a direction vector, we
    get a proportional position change based on which direction the vector was pointed
    at, like so:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 移动位置向量相当简单。假设我们有一个表示相机速度的标量值。如果我们将其乘以一个方向向量，我们就会得到基于向量指向方向的比例位置变化，如下所示：
- en: '![Moving the camera around](img/image_07_014.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![在相机周围移动](img/image_07_014.jpg)'
- en: 'With that in mind, let us implement the `MoveBy()` method:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们实现`MoveBy()`方法：
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If we are moving the camera forwards or backwards, the `l_amount` scalar value
    is multiplied by the forward direction. Moving the camera up and down is equally
    as simple, since the up direction can be used for that.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在前后移动相机，`l_amount`标量值会乘以前进方向。上下移动相机同样简单，因为可以使用向上方向来实现这一点。
- en: 'Moving left or right is slightly more complex. We cannot just statically change
    the position, because the camera''s idea of *left* or *right* depends on which
    way we are looking. This is where the **cross product** comes in:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 左右移动稍微复杂一些。我们不能只是静态地改变位置，因为相机的*左*或*右*的概念取决于我们朝哪个方向看。这就是**叉积**发挥作用的地方：
- en: '![Moving the camera around](img/image_07_015.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![在相机周围移动](img/image_07_015.jpg)'
- en: 'The cross product of two vectors is a slightly harder formula to memorize,
    but it is very useful. It gives us a vector that is **orthogonal** to the vectors
    *a* and *b*. Consider the following diagram:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量的叉积是一个稍微难以记忆的公式，但它非常有用。它给我们一个与向量*a*和*b***正交**的向量。考虑以下图示：
- en: '![Moving the camera around](img/image_07_016.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![在相机周围移动](img/image_07_016.jpg)'
- en: 'An orthogonal vector is one way of saying that the direction of that vector
    is **perpendicular** to the plane the other two vectors form. Knowing that, we
    can implement left and right strafing with relative ease:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 正交向量是表示该向量方向与另外两个向量形成的平面**垂直**的一种说法。了解这一点后，我们可以相对容易地实现左右侧滑：
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After obtaining the cross product of the forward and up vectors, we simply multiply
    it by the scalar and add the result to the camera's position, creating left and
    right movement.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得前进和向上向量的叉积后，我们只需将其乘以标量并加到相机的位置上，从而产生左右移动。
- en: 'Rotating the camera is slightly more involved, but not trivial:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转相机稍微复杂一些，但并非微不足道：
- en: '[PRE52]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once again, we use the cross product to obtain the orthogonal vector of the
    forward direction and up direction vectors plane. A rotation matrix is then calculated,
    by multiplying two rotation matrices of *X* and *Y* axes. For the *X* axis, we
    are simply rotating around the up direction vector, as shown here:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用叉积来获得前进方向和向上方向向量平面的正交向量。然后通过乘以*x*轴和*y*轴的两个旋转矩阵来计算旋转矩阵。对于*x*轴，我们只是围绕向上方向向量旋转，如下所示：
- en: '![Moving the camera around](img/image_07_017.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![在相机周围移动](img/image_07_017.jpg)'
- en: 'The *Y* axis rotation is made available by rotating along the orthogonal vector
    of the view direction and up vector''s plane:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y*轴旋转是通过绕着视图方向的正交向量和向上向量的平面旋转来实现的：'
- en: '![Moving the camera around](img/image_07_018.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![移动相机](img/image_07_018.jpg)'
- en: 'Having this functionality now allows us to program in actual camera movement,
    like so:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这个功能，我们可以编写实际的相机移动代码，如下所示：
- en: '[PRE53]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We are using the keyboard keys *W*, *S*, *A*, and *D* to move around the camera,
    and mouse position changes as scalar values to rotate it, provided the left mouse
    button is pressed.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用键盘上的*W*、*S*、*A*和*D*键来移动相机，当按下左鼠标按钮时，鼠标位置的变化作为标量值来旋转相机。
- en: Drawing with vertex indices
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用顶点索引绘制
- en: One last thing that is quite important for us before moving on is covering a
    more efficient way of rendering shapes. Our current method is fine for rendering
    a single triangle, but it can get inefficient really quickly when rendering something
    more complex, like a cube. If we are using vertices only, it would require a grand
    total of *36* to render *six* cube faces. A much more efficient approach would
    obviously be submitting *eight* vertices for each corner of the cube and then
    reusing them to draw each face. Luckily, there is a way to do just that by using
    an **index array**.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有一件对我们来说相当重要的事情是介绍一种更高效的形状渲染方法。我们当前的方法对于渲染单个三角形来说很好，但当渲染更复杂的形状，如立方体时，它可能会变得非常低效。如果我们只使用顶点，渲染*六个*立方体面就需要总共*36*个顶点。显然，一个更有效的方法是提交每个立方体角落的*八个*顶点，然后重新使用它们来绘制每个面。幸运的是，我们可以通过使用**索引数组**来实现这一点。
- en: 'Using indices simply means that for each model we are drawing, we also need
    to store an array of indices that represent the draw order of vertices. Each vertex
    in a model is given an index, starting from *0*. An array of these indices would
    then be used to connect the vertices, instead of having to re-submit them. Let''s
    implement this functionality, starting with the `GL_Model` class:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引简单来说，就是对于我们要绘制的每个模型，我们还需要存储一个表示顶点绘制顺序的索引数组。模型中的每个顶点都被赋予了一个索引，从*0*开始。然后，这些索引的数组会被用来连接顶点，而不是重新提交它们。让我们实现这个功能，从`GL_Model`类开始：
- en: '[PRE54]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As the new data member suggests, we need to store these indices in their own
    VBO, all of which happens inside the constructor:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如新的数据成员所暗示的，我们需要将这些索引存储在自己的VBO中，所有这些操作都在构造函数内部完成：
- en: '[PRE55]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The constructor needs to take two extra arguments: a pointer to an array of
    indices, and the count of indices in that array. Note that `m_drawCount` is now
    being set to `l_indexCount`. This is because we only need *eight* vertices for
    a cube model, but there are *36* indices that describe how to draw it.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数需要额外接受两个参数：一个指向索引数组的指针，以及该数组中索引的数量。注意，`m_drawCount`现在被设置为`l_indexCount`。这是因为我们只需要*八个*顶点来构建一个立方体模型，但是描述如何绘制它的索引有*36*个。
- en: After a new VBO is generated for the indices, we bind to it and submit the index
    data pretty much in the same way as before. The main difference here is the `GL_ELEMENT_ARRAY_BUFFER`
    flag. We cannot use `GL_ARRAY_BUFFER`, as the indices actually refer to the vertex
    data, which is located inside another VBO.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在为索引生成新的VBO之后，我们将其绑定并提交索引数据，基本上与之前相同。这里的主要区别是`GL_ELEMENT_ARRAY_BUFFER`标志。我们不能使用`GL_ARRAY_BUFFER`，因为索引实际上指的是位于另一个VBO内部的顶点数据。
- en: 'Obviously, this new data needs to be released once the model is no longer needed:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一旦模型不再需要，就需要释放这些新数据：
- en: '[PRE56]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Drawing our model using indices requires a different `Draw()` call altogether:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引绘制我们的模型需要完全不同的`Draw()`调用：
- en: '[PRE57]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The call to the `glDrawElements()` method takes four arguments: the type of
    primitives we are going to be drawing, the total number of indices, the data type
    that these indices are represented by, and an offset that can be used to skip
    them.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`glDrawElements()`方法需要四个参数：我们将要绘制的原语类型、索引的总数、这些索引表示的数据类型，以及可以用来跳过的偏移量。
- en: 'That is all there is to drawing geometry using indices! Now let''s set up a
    more exciting model to show it off:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用索引绘制几何形状的全部内容！现在让我们设置一个更令人兴奋的模型来展示它：
- en: '[PRE58]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you can see, we''ve now set up `8` vertices, and we''ve created another
    array for indices. Once the model is rendered, we would see something like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在已经设置了`8`个顶点，并为索引创建了一个新的数组。一旦模型渲染完成，我们会看到类似这样的效果：
- en: '![Drawing with vertex indices](img/image_07_019.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![使用顶点索引绘制](img/image_07_019.jpg)'
- en: Note that the bottom face is actually rendered on top for some reason. This
    is caused by OpenGL not knowing which geometry to render on top, and this will
    be solved in the next section.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于某种原因，底面实际上被渲染在了上面。这是由于OpenGL不知道应该渲染哪个几何体在顶部，这个问题将在下一节中解决。
- en: Face culling and depth buffer
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面剔除和深度缓冲区
- en: One way of solving the draw order issues is by using a **depth buffer**. In
    the simplest terms, a depth buffer, also commonly known as the **Z-buffer**, is
    basically a texture managed by OpenGL in the background that contains depth information
    of each pixel. When a pixel is being rendered, its depth (*Z* value) is checked
    against that on the depth buffer. If a pixel being rendered has a lower *Z* value,
    the pixel is overwritten, as it is clearly on top.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 解决绘制顺序问题的方法之一是使用**深度缓冲区**。简单来说，深度缓冲区，也常被称为**Z缓冲区**，是OpenGL在后台管理的一个纹理，它包含每个像素的深度信息。当渲染一个像素时，它的深度（*Z*值）会与深度缓冲区中的值进行比较。如果一个像素的*Z*值更低，那么这个像素会被覆盖，因为它显然在顶部。
- en: 'Enabling the depth buffer only comes down to a single `glEnable()` method call:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 启用深度缓冲区只需要一个`glEnable()`方法调用：
- en: '[PRE59]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Keep in mind that the depth buffer is a texture. It is imperative to make sure
    it gets allocated when the window is created, and it has enough data to work with.
    We can make sure of that by creating an `sf::ContextSettings` structure and filling
    out its `depthBits` data member before passing it to the SFML''s window `Create()`
    method:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，深度缓冲区是一个纹理。确保在创建窗口时分配它，并且它有足够的数据来工作是非常重要的。我们可以通过创建一个`sf::ContextSettings`结构并在将其传递给SFML窗口的`Create()`方法之前填充其`depthBits`数据成员来确保这一点：
- en: '[PRE60]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we just ran the code as is, the screen would be completely blank. Why? Well,
    remember that the Z-buffer is a texture. A texture, just like the display, needs
    to be cleared every cycle. We can accomplish that like so:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接运行代码，屏幕会完全变空白。为什么？记住，Z缓冲区是一个纹理。就像显示一样，每个周期都需要清除纹理。我们可以这样完成：
- en: '[PRE61]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Adding the pipe symbol allows us to perform a bitwise or operation on the `glClear`''s
    argument, joining in the `GL_DEPTH_BUFFER_BIT` definition. This ensures that the
    depth buffer is also cleared to black, and we can finally enjoy our cube:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 添加管道符号允许我们对`glClear`的参数执行位或操作，加入`GL_DEPTH_BUFFER_BIT`定义。这确保了深度缓冲区也被清空为黑色，我们最终可以享受我们的立方体：
- en: '![Face culling and depth buffer](img/image_07_020.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![面剔除和深度缓冲区](img/image_07_020.jpg)'
- en: Back face culling
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背面剔除
- en: 'In order to save on performance, it is a good idea to let OpenGL know that
    we would like to cull faces that are not visible from the current perspective.
    This feature can be enabled like so:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，一个好的做法是让OpenGL知道我们希望剔除从当前视角不可见的面。这个功能可以通过以下方式启用：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After we `glEnable` face culling, the `glCullFace` function is invoked to let
    OpenGL know which faces to cull. This will work right out of the box, but we may
    notice weird artifacts like this if our model data is not set up correctly:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`glEnable`启用面剔除之后，`glCullFace`函数被调用以让OpenGL知道哪些面需要剔除。这会直接生效，但如果我们的模型数据设置不正确，我们可能会注意到一些奇怪的效果，如下所示：
- en: '![Back face culling](img/image_07_021.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![背面剔除](img/image_07_021.jpg)'
- en: 'This is because the order our vertices are rendered in actually defines whether
    a face of a piece of geometry is facing inwards or outwards. For example, if the
    vertices of a face are rendered in a clockwise sequence, the face, by default,
    is considered to be facing **inwards** of the model and vice versa. Consider the
    following diagram:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们渲染顶点的顺序实际上定义了一个几何体面的朝向是向内还是向外。例如，如果一个面的顶点以顺时针顺序渲染，那么默认情况下，这个面被认为是向模型**内部**朝向的，反之亦然。考虑以下图示：
- en: '![Back face culling](img/image_07_022.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![背面剔除](img/image_07_022.jpg)'
- en: Setting up the model draw order correctly allows us to save on performance by
    not drawing invisible faces, and having our cube back just the way it was.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设置模型绘制顺序可以让我们通过不绘制不可见面来节省性能，并且让我们的立方体恢复原状。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: That may have been quite a lot to take in, but if you have made it all the way
    to the end, congratulations! The hard part is now over, and you are familiar with
    the modern versions of OpenGL, the programmable pipeline and general-purpose rendering.
    Even SFML itself was built around basic principles like the ones we have gone
    over, some of which we have already covered extensively.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要吸收很多信息，但如果你已经坚持到了最后，恭喜你！艰难的部分现在已经结束，你对现代版本的OpenGL、可编程管道和通用渲染已经非常熟悉。甚至SFML本身也是基于我们讨论过的基本原理构建的，其中一些我们已经进行了广泛的探讨。
- en: In the next chapter, we are going to be covering the basics of lighting to create
    a more dynamic feel to our world. See you there!
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍光照的基础知识，以使我们的世界更具动态感。那里见！
