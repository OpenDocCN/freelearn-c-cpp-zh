["```cpp\n#include \"SFML-2.5.1\\include\\SFML\\Graphics.hpp\" \n\nsf::Vector2f viewSize(1024, 768); \nsf::VideoMode vm(viewSize.x, viewSize.y); \nsf::RenderWindow window(vm, \"Hello SFML Game !!!\", sf::Style::Default); \n\nsf::Vector2f playerPosition; \nbool playerMoving = false; \n\nsf::Texture skyTexture; \nsf::Sprite skySprite; \n\nsf::Texture bgTexture; \nsf::Sprite bgSprite; \n\nvoid init() { \n\n   skyTexture.loadFromFile(\"Assets/graphics/sky.png\"); \n   skySprite.setTexture(skyTexture); \n\n   bgTexture.loadFromFile(\"Assets/graphics/bg.png\"); \n   bgSprite.setTexture(bgTexture); \n\n} \n\nvoid updateInput() { \n\n   sf::Event event; \n\n   // while there are pending events... \n   while (window.pollEvent(event)) { \n\n      if (event.key.code == sf::Keyboard::Escape || event.type == \n          sf::Event::Closed) \n         window.close(); \n\n   } \n\n} \n\nvoid update(float dt) { \n\n} \n\nvoid draw() { \n\n   window.draw(skySprite); \n   window.draw(bgSprite); \n\n} \n\nint main() { \n\n   sf::Clock clock; \n   window.setFramerateLimit(60); \n\n   init(); \n\n   while (window.isOpen()) { \n\n      updateInput(); \n\n      sf::Time dt = clock.restart(); \n      update(dt.asSeconds()); \n\n      window.clear(sf::Color::Red); \n\n      draw(); \n\n      window.display(); \n\n   } \n\n   return 0; \n} \n```", "```cpp\n#include \"SFML-2.5.0\\include\\SFML\\Graphics.hpp\" \n\nclass Hero{ \n\n}; \n```", "```cpp\npublic: \n   Hero(); \n   ~Hero(); \n\n   void init(std::string textureName, sf::Vector2f position, float \n   mass); \n   void update(float dt); \n   void jump(float velocity); \n   sf::Sprite getSprite(); \n\n```", "```cpp\nprivate: \n\n   sf::Texture m_texture; \n   sf::Sprite m_sprite; \n   sf::Vector2f m_position; \n\nint jumpCount = 0;    \nfloat m_mass; \n   float m_velocity; \n   const float m_gravity = 9.80f; \n      bool m_grounded; \n\n```", "```cpp\n#include \"Hero.h\" \n\nHero::Hero(){ \n\n} \n```", "```cpp\n Hero::~Hero(){ \n\n}\n```", "```cpp\nvoid Hero::init(std::string textureName, sf::Vector2f position, float mass){ \n\n   m_position = position; \n   m_mass = mass; \n\n   m_grounded = false; \n\n   // Load a Texture \n   m_texture.loadFromFile(textureName.c_str()); \n\n   // Create Sprite and Attach a Texture \n   m_sprite.setTexture(m_texture); \n   m_sprite.setPosition(m_position); \n   m_sprite.setOrigin(m_texture.getSize().x / 2, \n   m_texture.getSize().y / 2); \n\n} \n```", "```cpp\nvoid Hero::update(float dt){ \n\n   m_force -= m_mass * m_gravity * dt; \n\n   m_position.y -= m_force * dt; \n\n   m_sprite.setPosition(m_position); \n\n   if (m_position.y >= 768 * 0.75f) { \n\n      m_position.y = 768 * 0.75f; \n      m_force = 0; \n      m_grounded = true; \n      jumpCount = 0; \n   } \n\n}  \n```", "```cpp\nvoid Hero::jump(float velocity){ \n\n   if (jumpCount < 2) { \n      jumpCount++; \n\n      m_velocity = VELOCITY; \n      m_grounded = false; \n   } \n\n}\n```", "```cpp\n sf::Sprite Hero::getSprite(){ \n\n   return m_sprite; \n}  \n```", "```cpp\n#include \"SFML-2.5.1\\include\\SFML\\Graphics.hpp\" \n#include \"Hero.h\"\n```", "```cpp\nsf::Texture skyTexture; \nsf::Sprite skySprite; \n\nsf::Texture bgTexture; \nsf::Sprite bgSprite; \nHero hero;\n```", "```cpp\n   // Load bg Texture \n\n   bgTexture.loadFromFile(\"Assets/graphics/bg.png\"); \n\n   // Create Sprite and Attach a Texture \n   bgSprite.setTexture(bgTexture); \n\n   hero.init(\"Assets/graphics/hero.png\", sf::Vector2f(viewSize.x *\n 0.25f, viewSize.y * 0.5f), 200); \n```", "```cpp\nwhile (window.pollEvent(event)) {  \n    if (event.type == sf::Event::KeyPressed) {\n if (event.key.code == sf::Keyboard::Up) {\n hero.jump(750.0f);\n }\n }\n      if (event.key.code == sf::Keyboard::Escape || event.type == \n       sf::Event::Closed) \n         window.close(); \n\n   }  \n```", "```cpp\nvoid update(float dt) { \n hero.update(dt); \n} \n\n```", "```cpp\nvoid draw() { \n\n   window.draw(skySprite); \n   window.draw(bgSprite); \n window.draw(hero.getSprite());\n\n}\n```", "```cpp\n#pragma once \n#include \"SFML-2.5.1\\include\\SFML\\Graphics.hpp\" \n\nclass Enemy \n{ \npublic: \n   Enemy(); \n   ~Enemy(); \n\n   void init(std::string textureName, sf::Vector2f position, \n     float_speed); \n   void update(float dt); \n   sf::Sprite getSprite(); \n\nprivate: \n\n   sf::Texture m_texture; \n   sf::Sprite m_sprite; \n   sf::Vector2f m_position; \n   float m_speed; \n\n}; \n```", "```cpp\n#include \"Enemy.h\" \n\nEnemy::Enemy(){} \n\nEnemy::~Enemy(){} \n\nvoid Enemy::init(std::string textureName, sf::Vector2f position, \n    float _speed) { \n\n   m_speed = _speed; \n   m_position = position; \n\n   // Load a Texture \n   m_texture.loadFromFile(textureName.c_str()); \n\n   // Create Sprite and Attach a Texture \n   m_sprite.setTexture(m_texture); \n   m_sprite.setPosition(m_position); \n   m_sprite.setOrigin(m_texture.getSize().x / 2,    \n   m_texture.getSize().y / 2); \n\n} \n```", "```cpp\n void Enemy::update(float dt) { \n\n   m_sprite.move(m_speed * dt, 0); \n\n} \n\nsf::Sprite Enemy::getSprite() { \n\n   return m_sprite; \n}\n```", "```cpp\n#include \"SFML-2.5.1\\include\\SFML\\Graphics.hpp\" \n#include <vector> \n\n#include \"Hero.h\" \n#include \"Enemy.h\" \n```", "```cpp\nsf::Texture bgTexture; \nsf::Sprite bgSprite; \n\nHero hero; \n\nstd::vector<Enemy*> enemies;  \n```", "```cpp\nsf::Vector2f viewSize(1024, 768);\nsf::VideoMode vm(viewSize.x, viewSize.y); \nsf::RenderWindow window(vm, \"Hello SFML Game !!!\", sf::Style::Default); \n\nvoid spawnEnemy(); \n```", "```cpp\nhero.init(\"Assets/graphics/hero.png\", sf::Vector2f(viewSize.x * \n0.25f, viewSize.y * 0.5f), 200); \n\nsrand((int)time(0)); \n```", "```cpp\nvoid spawnEnemy() { \n\n   int randLoc = rand() % 3; \n\n   sf::Vector2f enemyPos; \n\n   float speed; \n\n   switch (randLoc) { \n\n   case 0: enemyPos = sf::Vector2f(viewSize.x, viewSize.y * 0.75f);\n   speed = -400; break; \n\n   case 1: enemyPos = sf::Vector2f(viewSize.x, viewSize.y * 0.60f); \n   speed = -550; break; \n\n   case 2: enemyPos = sf::Vector2f(viewSize.x, viewSize.y * 0.40f); \n   speed = -650; break; \n\n   default: printf(\"incorrect y value \\n\"); return; \n\n   } \n\n   Enemy* enemy = new Enemy(); \n   enemy->init(\"Assets/graphics/enemy.png\", enemyPos, speed); \n\n   enemies.push_back(enemy); \n} \n```", "```cpp\nHero hero; \n\nstd::vector<Enemy*> enemies; \n\nfloat currentTime; \nfloat prevTime = 0.0f;  \n```", "```cpp\n hero.update(dt); \n currentTime += dt;\n // Spawn Enemies\n if (currentTime >= prevTime + 1.125f)))) {\n spawnEnemy();\n prevTime = currentTime;\n}\n```", "```cpp\n   // Update Enemies \n\n   for (int i = 0; i < enemies.size(); i++) { \n\n      Enemy *enemy = enemies[i]; \n\n      enemy->update(dt); \n\n      if (enemy->getSprite().getPosition().x < 0) { \n\n         enemies.erase(enemies.begin() + i); \n         delete(enemy); \n\n      } \n   } \n```", "```cpp\nwindow.draw(skySprite); \nwindow.draw(bgSprite); \n\nwindow.draw(hero.getSprite()); \n\nfor (Enemy *enemy : enemies) { \n  window.draw(enemy->getSprite()); \n}\n```", "```cpp\n#pragma once \n\n#include \"SFML-2.5.1\\include\\SFML\\Graphics.hpp\" \n\nclass Rocket \n{ \npublic: \n   Rocket(); \n   ~Rocket(); \n\n   void init(std::string textureName, sf::Vector2f position, \n      float_speed); \n   void update(float dt); \n   sf::Sprite getSprite(); \n\nprivate: \n\n   sf::Texture m_texture; \n   sf::Sprite m_sprite; \n   sf::Vector2f m_position; \n   float m_speed; \n\n}; \n```", "```cpp\n#include \"Rocket.h\" \n\nRocket::Rocket(){ \n} \n\nRocket::~Rocket(){ \n} \n```", "```cpp\nvoid Rocket::init(std::string textureName, sf::Vector2f position, float _speed){ \n\n   m_speed = _speed; \n   m_position = position; \n\n   // Load a Texture \n   m_texture.loadFromFile(textureName.c_str()); \n\n   // Create Sprite and Attach a Texture \n   m_sprite.setTexture(m_texture); \n   m_sprite.setPosition(m_position); \n   m_sprite.setOrigin(m_texture.getSize().x / 2, \n     m_texture.getSize().y / 2); \n\n} \n```", "```cpp\nvoid Rocket::update(float dt){ \n   \\ \n   m_sprite.move(m_speed * dt, 0); \n\n} \n```", "```cpp\nsf::Sprite Rocket::getSprite() { \n\n   return m_sprite; \n} \n```", "```cpp\n#include \"Hero.h\" \n#include \"Enemy.h\" \n#include \"Rocket.h\" \n```", "```cpp\nstd::vector<Enemy*> enemies; \nstd::vector<Rocket*> rockets;  \n```", "```cpp\n   // Update Enemies \n\n   for (int i = 0; i < enemies.size(); i++) { \n\n      Enemy* enemy = enemies[i]; \n\n      enemy->update(dt); \n\n      if (enemy->getSprite().getPosition().x < 0) { \n\n         enemies.erase(enemies.begin() + i); \n         delete(enemy); \n\n      } \n   } \n // Update rockets\n\n for (int i = 0; i < rockets.size(); i++) {\n\n Rocket* rocket = rockets[i];\n\n rocket->update(dt);\n\n if (rocket->getSprite().getPosition().x > viewSize.x) {\n rockets.erase(rockets.begin() + i);\n delete(rocket);\n }\n}\n```", "```cpp\n    for (Enemy *enemy : enemies) { \n\n      window.draw(enemy->getSprite()); \n   } \n\nfor (Rocket *rocket : rockets) {\n window.draw(rocket->getSprite());\n}\n```", "```cpp\nvoid spawnEnemy(); \nvoid shoot(); \n```", "```cpp\nvoid shoot() { \n\n   Rocket* rocket = new Rocket(); \n\nrocket->init(\"Assets/graphics/rocket.png\",  \n            hero.getSprite().getPosition(),  \n    400.0f); \n\n   rockets.push_back(rocket); \n\n} \n```", "```cpp\n   if (event.type == sf::Event::KeyPressed) { \n\n      if (event.key.code == sf::Keyboard::Up) { \n\n         hero.jump(750.0f); \n      } \n\n      if (event.key.code == sf::Keyboard::Down) { \n\n         shoot(); \n      } \n   }  \n```", "```cpp\nvoid spawnEnemy(); \nvoid shoot(); \n\nbool checkCollision(sf::Sprite sprite1, sf::Sprite sprite2); \n```", "```cpp\nvoid shoot() { \n\n   Rocket* rocket = new Rocket(); \n\n   rocket->init(\"Assets/graphics/rocket.png\", \n     hero.getSprite().getPosition(), 400.0f); \n\n   rockets.push_back(rocket); \n\n} \n\nbool checkCollision(sf::Sprite sprite1, sf::Sprite sprite2) { \n\n   sf::FloatRect shape1 = sprite1.getGlobalBounds(); \n   sf::FloatRect shape2 = sprite2.getGlobalBounds(); \n\n   if (shape1.intersects(shape2)) { \n\n      return true; \n\n   } \n   else { \n\n      return false; \n\n   } \n\n}\n```", "```cpp\n   // Update rockets \n\n   for (int i = 0; i < rockets.size(); i++) { \n\n      Rocket* rocket = rockets[i]; \n\n      rocket->update(dt); \n\n      if (rocket->getSprite().getPosition().x > viewSize.x) { \n\n         rockets.erase(rockets.begin() + i); \n         delete(rocket); \n\n      } \n\n   } \n\n    // Check collision between Rocket and Enemies \n\n   for (int i = 0; i < rockets.size(); i++) { \n      for (int j = 0; j < enemies.size(); j++) { \n\n         Rocket* rocket = rockets[i]; \n         Enemy* enemy = enemies[j]; \n\n         if (checkCollision(rocket->getSprite(), \n            enemy->getSprite())) { \n\n            rockets.erase(rockets.begin() + i); \n            enemies.erase(enemies.begin() + j); \n\n            delete(rocket); \n            delete(enemy); \n\n            printf(\" rocket intersects enemy \\n\"); \n         } \n\n      } \n   }   \n```"]