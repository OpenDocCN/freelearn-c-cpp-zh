["```cpp\ngit clone https://github.com/codeplea/Hands-On-Network-Programming-with-C\ncd Hands-On-Network-Programming-with-C/chap05\n```", "```cpp\n/*chap05.h*/\n\n#if defined(_WIN32)\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x0600\n#endif\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#pragma comment(lib, \"ws2_32.lib\")\n\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <errno.h>\n\n#endif\n\n#if defined(_WIN32)\n#define ISVALIDSOCKET(s) ((s) != INVALID_SOCKET)\n#define CLOSESOCKET(s) closesocket(s)\n#define GETSOCKETERRNO() (WSAGetLastError())\n\n#else\n#define ISVALIDSOCKET(s) ((s) >= 0)\n#define CLOSESOCKET(s) close(s)\n#define SOCKET int\n#define GETSOCKETERRNO() (errno)\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n```", "```cpp\nipconfig /displaydns\n```", "```cpp\nint getaddrinfo(const char *node,\n                const char *service,\n                const struct addrinfo *hints,\n                struct addrinfo **res);\n```", "```cpp\nstruct addrinfo {\n    int              ai_flags;\n    int              ai_family;\n    int              ai_socktype;\n    int              ai_protocol;\n    socklen_t        ai_addrlen;\n    struct sockaddr *ai_addr;\n    char            *ai_canonname;\n    struct addrinfo *ai_next;\n};\n```", "```cpp\nstruct addrinfo hints;\nmemset(&hints, 0, sizeof(hints));\nhints.ai_flags = AI_ALL;\nstruct addrinfo *peer_address;\nif (getaddrinfo(\"example.com\", 0, &hints, &peer_address)) {\n    fprintf(stderr, \"getaddrinfo() failed. (%d)\\n\", GETSOCKETERRNO());\n    return 1;\n}\n```", "```cpp\nstruct addrinfo *address = peer_address;\ndo {\n    /* Work with address... */\n} while ((address = address->ai_next));\n```", "```cpp\nfreeaddrinfo(peer_address);\n```", "```cpp\nint getnameinfo(const struct sockaddr *addr, socklen_t addrlen,\n        char *host, socklen_t hostlen,\n        char *serv, socklen_t servlen, int flags);\n```", "```cpp\nchar host[100];\nchar serv[100];\ngetnameinfo(address->ai_addr, address->ai_addrlen,\n        host, sizeof(host),\n        serv, sizeof(serv),\n        0);\n\nprintf(\"%s %s\\n\", host, serv);\n```", "```cpp\nexample.com http\n```", "```cpp\nchar host[100];\nchar serv[100];\ngetnameinfo(address->ai_addr, address->ai_addrlen,\n        host, sizeof(host),\n        serv, sizeof(serv),\n        NI_NUMERICHOST | NI_NUMERICSERV);\n\nprintf(\"%s %s\\n\", host, serv);\n```", "```cpp\n93.184.216.34 80\n```", "```cpp\n/*lookup.c*/\n\n#include \"chap05.h\"\n\n#ifndef AI_ALL\n#define AI_ALL 0x0100\n#endi\n```", "```cpp\n/*lookup.c continued*/\n\nint main(int argc, char *argv[]) {\n\n    if (argc < 2) {\n        printf(\"Usage:\\n\\tlookup hostname\\n\");\n        printf(\"Example:\\n\\tlookup example.com\\n\");\n        exit(0);\n    }\n```", "```cpp\n/*lookup.c continued*/\n\n#if defined(_WIN32)\n    WSADATA d;\n    if (WSAStartup(MAKEWORD(2, 2), &d)) {\n        fprintf(stderr, \"Failed to initialize.\\n\");\n        return 1;\n    }\n#endif\n```", "```cpp\n/*lookup.c continued*/\n\n    printf(\"Resolving hostname '%s'\\n\", argv[1]);\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_flags = AI_ALL;\n    struct addrinfo *peer_address;\n    if (getaddrinfo(argv[1], 0, &hints, &peer_address)) {\n        fprintf(stderr, \"getaddrinfo() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n```", "```cpp\n/*lookup.c continued*/\n\n    printf(\"Remote address is:\\n\");\n    struct addrinfo *address = peer_address;\n    do {\n        char address_buffer[100];\n        getnameinfo(address->ai_addr, address->ai_addrlen,\n                address_buffer, sizeof(address_buffer),\n                0, 0,\n                NI_NUMERICHOST);\n        printf(\"\\t%s\\n\", address_buffer);\n    } while ((address = address->ai_next));\n```", "```cpp\n/*lookup.c continued*/\n\n    freeaddrinfo(peer_address);\n\n#if defined(_WIN32)\n    WSACleanup();\n#endif\n\n    return 0;\n}\n```", "```cpp\ngcc lookup.c -o lookup\n./lookup example.com\n```", "```cpp\ngcc lookup.c -o lookup.exe -lws2_32\nlookup.exe example.com\n```", "```cpp\nchar dns_query[] = {0xAB, 0xCD,                           /* ID */\n                    0x01, 0x00,                           /* Recursion */\n                    0x00, 0x01,                           /* QDCOUNT */\n                    0x00, 0x00,                           /* ANCOUNT */\n                    0x00, 0x00,                           /* NSCOUNT */\n                    0x00, 0x00,                           /* ARCOUNT */\n                    7, 'e', 'x', 'a', 'm', 'p', 'l', 'e', /* label */\n                    3, 'c', 'o', 'm',                     /* label */\n                    0,                                    /* End of name */\n                    0x00, 0x01,                           /* QTYPE = A */\n                    0x00, 0x01                            /* QCLASS */\n                    };\n```", "```cpp\n/*dns_query.c*/\n\nconst unsigned char *print_name(const unsigned char *msg,\n        const unsigned char *p, const unsigned char *end);\n```", "```cpp\n/*dns_query.c*/\n\n    if (p + 2 > end) {\n        fprintf(stderr, \"End of message.\\n\"); exit(1);}\n```", "```cpp\n/*dns_query.c*/\n\n    if ((*p & 0xC0) == 0xC0) {\n        const int k = ((*p & 0x3F) << 8) + p[1];\n        p += 2;\n        printf(\" (pointer %d) \", k);\n        print_name(msg, msg+k, end);\n        return p;\n```", "```cpp\n/*dns_query.c*/\n\n    } else {\n        const int len = *p++;\n        if (p + len + 1 > end) {\n            fprintf(stderr, \"End of message.\\n\"); exit(1);}\n\n        printf(\"%.*s\", len, p);\n        p += len;\n        if (*p) {\n            printf(\".\");\n            return print_name(msg, p, end);\n        } else {\n            return p+1;\n        }\n    }\n```", "```cpp\n/*dns_query.c*/\n\nvoid print_dns_message(const char *message, int msg_length);\n```", "```cpp\n/*dns_query.c*/\n\n    if (msg_length < 12) {\n        fprintf(stderr, \"Message is too short to be valid.\\n\");\n        exit(1);\n    }\n```", "```cpp\n/*dns_query.c*/\n\n    const unsigned char *msg = (const unsigned char *)message;\n```", "```cpp\n/*dns_query.c*/\n\n    int i;\n    for (i = 0; i < msg_length; ++i) {\n        unsigned char r = msg[i];\n        printf(\"%02d:   %02X  %03d  '%c'\\n\", i, r, r, r);\n    }\n    printf(\"\\n\");\n```", "```cpp\n/*dns_query.c*/\n\n    printf(\"ID = %0X %0X\\n\", msg[0], msg[1]);\n```", "```cpp\n/*dns_query.c*/\n\n    const int qr = (msg[2] & 0x80) >> 7;\n    printf(\"QR = %d %s\\n\", qr, qr ? \"response\" : \"query\");\n```", "```cpp\n/*dns_query.c*/\n\n    const int opcode = (msg[2] & 0x78) >> 3;\n    printf(\"OPCODE = %d \", opcode);\n    switch(opcode) {\n        case 0: printf(\"standard\\n\"); break;\n        case 1: printf(\"reverse\\n\"); break;\n        case 2: printf(\"status\\n\"); break;\n        default: printf(\"?\\n\"); break;\n    }\n\n    const int aa = (msg[2] & 0x04) >> 2;\n    printf(\"AA = %d %s\\n\", aa, aa ? \"authoritative\" : \"\");\n\n    const int tc = (msg[2] & 0x02) >> 1;\n    printf(\"TC = %d %s\\n\", tc, tc ? \"message truncated\" : \"\");\n\n    const int rd = (msg[2] & 0x01);\n    printf(\"RD = %d %s\\n\", rd, rd ? \"recursion desired\" : \"\");\n```", "```cpp\n/*dns_query.c*/\n\n    if (qr) {\n        const int rcode = msg[3] & 0x07;\n        printf(\"RCODE = %d \", rcode);\n        switch(rcode) {\n            case 0: printf(\"success\\n\"); break;\n            case 1: printf(\"format error\\n\"); break;\n            case 2: printf(\"server failure\\n\"); break;\n            case 3: printf(\"name error\\n\"); break;\n            case 4: printf(\"not implemented\\n\"); break;\n            case 5: printf(\"refused\\n\"); break;\n            default: printf(\"?\\n\"); break;\n        }\n        if (rcode != 0) return;\n    }\n```", "```cpp\n/*dns_query.c*/\n\n    const int qdcount = (msg[4] << 8) + msg[5];\n    const int ancount = (msg[6] << 8) + msg[7];\n    const int nscount = (msg[8] << 8) + msg[9];\n    const int arcount = (msg[10] << 8) + msg[11];\n\n    printf(\"QDCOUNT = %d\\n\", qdcount);\n    printf(\"ANCOUNT = %d\\n\", ancount);\n    printf(\"NSCOUNT = %d\\n\", nscount);\n    printf(\"ARCOUNT = %d\\n\", arcount);\n```", "```cpp\n/*dns_query.c*/\n\n    const unsigned char *p = msg + 12;\n    const unsigned char *end = msg + msg_length;\n```", "```cpp\n/*dns_query.c*/\n\n    if (qdcount) {\n        int i;\n        for (i = 0; i < qdcount; ++i) {\n            if (p >= end) {\n                fprintf(stderr, \"End of message.\\n\"); exit(1);}\n\n            printf(\"Query %2d\\n\", i + 1);\n            printf(\"  name: \");\n\n            p = print_name(msg, p, end); printf(\"\\n\");\n\n            if (p + 4 > end) {\n                fprintf(stderr, \"End of message.\\n\"); exit(1);}\n\n            const int type = (p[0] << 8) + p[1];\n            printf(\"  type: %d\\n\", type);\n            p += 2;\n\n            const int qclass = (p[0] << 8) + p[1];\n            printf(\" class: %d\\n\", qclass);\n            p += 2;\n        }\n    }\n```", "```cpp\n/*dns_query.c*/\n\n    if (ancount || nscount || arcount) {\n        int i;\n        for (i = 0; i < ancount + nscount + arcount; ++i) {\n            if (p >= end) {\n                fprintf(stderr, \"End of message.\\n\"); exit(1);}\n\n            printf(\"Answer %2d\\n\", i + 1);\n            printf(\"  name: \");\n\n            p = print_name(msg, p, end); printf(\"\\n\");\n\n            if (p + 10 > end) {\n                fprintf(stderr, \"End of message.\\n\"); exit(1);}\n\n            const int type = (p[0] << 8) + p[1];\n            printf(\"  type: %d\\n\", type);\n            p += 2;\n\n            const int qclass = (p[0] << 8) + p[1];\n            printf(\" class: %d\\n\", qclass);\n            p += 2;\n```", "```cpp\n/*dns_query.c*/\n\n            const unsigned int ttl = (p[0] << 24) + (p[1] << 16) +\n                (p[2] << 8) + p[3];\n            printf(\"   ttl: %u\\n\", ttl);\n            p += 4;\n\n            const int rdlen = (p[0] << 8) + p[1];\n            printf(\" rdlen: %d\\n\", rdlen);\n            p += 2;\n```", "```cpp\n/*dns_query.c*/\n\n            if (p + rdlen > end) {\n                fprintf(stderr, \"End of message.\\n\"); exit(1);}\n```", "```cpp\n/*dns_query.c*/\n\n            if (rdlen == 4 && type == 1) { /* A Record */\n                printf(\"Address \");\n                printf(\"%d.%d.%d.%d\\n\", p[0], p[1], p[2], p[3]);\n\n            } else if (type == 15 && rdlen > 3) { /* MX Record */\n                const int preference = (p[0] << 8) + p[1];\n                printf(\"  pref: %d\\n\", preference);\n                printf(\"MX: \");\n                print_name(msg, p+2, end); printf(\"\\n\");\n\n            } else if (rdlen == 16 && type == 28) { /* AAAA Record */\n                printf(\"Address \");\n                int j;\n                for (j = 0; j < rdlen; j+=2) {\n                    printf(\"%02x%02x\", p[j], p[j+1]);\n                    if (j + 2 < rdlen) printf(\":\");\n                }\n                printf(\"\\n\");\n\n            } else if (type == 16) { /* TXT Record */\n                printf(\"TXT: '%.*s'\\n\", rdlen-1, p+1);\n\n            } else if (type == 5) { /* CNAME Record */\n                printf(\"CNAME: \");\n                print_name(msg, p, end); printf(\"\\n\");\n            }\n            p += rdlen;\n```", "```cpp\n/*dns_query.c*/\n\n        }\n    }\n\n    if (p != end) {\n        printf(\"There is some unread data left over.\\n\");\n    }\n\n    printf(\"\\n\");\n```", "```cpp\n/*dns_query.c*/\n\nint main(int argc, char *argv[]) {\n\n    if (argc < 3) {\n        printf(\"Usage:\\n\\tdns_query hostname type\\n\");\n        printf(\"Example:\\n\\tdns_query example.com aaaa\\n\");\n        exit(0);\n    }\n\n    if (strlen(argv[1]) > 255) {\n        fprintf(stderr, \"Hostname too long.\");\n        exit(1);\n    }\n```", "```cpp\n/*dns_query.c*/\n\n    unsigned char type;\n    if (strcmp(argv[2], \"a\") == 0) {\n        type = 1;\n    } else if (strcmp(argv[2], \"mx\") == 0) {\n        type = 15;\n    } else if (strcmp(argv[2], \"txt\") == 0) {\n        type = 16;\n    } else if (strcmp(argv[2], \"aaaa\") == 0) {\n        type = 28;\n    } else if (strcmp(argv[2], \"any\") == 0) {\n        type = 255;\n    } else {\n        fprintf(stderr, \"Unknown type '%s'. Use a, aaaa, txt, mx, or any.\",\n                argv[2]);\n        exit(1);\n    }\n```", "```cpp\n/*dns_query.c*/\n\n#if defined(_WIN32)\n    WSADATA d;\n    if (WSAStartup(MAKEWORD(2, 2), &d)) {\n        fprintf(stderr, \"Failed to initialize.\\n\");\n        return 1;\n    }\n#endif\n```", "```cpp\n/*dns_query.c*/\n\n    printf(\"Configuring remote address...\\n\");\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_DGRAM;\n    struct addrinfo *peer_address;\n    if (getaddrinfo(\"8.8.8.8\", \"53\", &hints, &peer_address)) {\n        fprintf(stderr, \"getaddrinfo() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n```", "```cpp\n/*dns_query.c*/\n\n    printf(\"Creating socket...\\n\");\n    SOCKET socket_peer;\n    socket_peer = socket(peer_address->ai_family,\n            peer_address->ai_socktype, peer_address->ai_protocol);\n    if (!ISVALIDSOCKET(socket_peer)) {\n        fprintf(stderr, \"socket() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n```", "```cpp\n/*dns_query.c*/\n\n    char query[1024] = {0xAB, 0xCD, /* ID */\n                        0x01, 0x00, /* Set recursion */\n                        0x00, 0x01, /* QDCOUNT */\n                        0x00, 0x00, /* ANCOUNT */\n                        0x00, 0x00, /* NSCOUNT */\n                        0x00, 0x00 /* ARCOUNT */};\n```", "```cpp\n/*dns_query.c*/\n\n    char *p = query + 12;\n    char *h = argv[1];\n\n    while(*h) {\n        char *len = p;\n        p++;\n        if (h != argv[1]) ++h;\n\n        while(*h && *h != '.') *p++ = *h++;\n        *len = p - len - 1;\n    }\n\n    *p++ = 0;\n```", "```cpp\n/*dns_query.c*/\n\n    *p++ = 0x00; *p++ = type; /* QTYPE */\n    *p++ = 0x00; *p++ = 0x01; /* QCLASS */\n```", "```cpp\n/*dns_query.c*/\n\n    const int query_size = p - query;\n```", "```cpp\n/*dns_query.c*/\n\n    int bytes_sent = sendto(socket_peer,\n            query, query_size,\n            0,\n            peer_address->ai_addr, peer_address->ai_addrlen);\n    printf(\"Sent %d bytes.\\n\", bytes_sent);\n```", "```cpp\n/*dns_query.c*/\n\n    print_dns_message(query, query_size);\n```", "```cpp\n/*dns_query.c*/\n\n    char read[1024];\n    int bytes_received = recvfrom(socket_peer,\n            read, 1024, 0, 0, 0);\n\n    printf(\"Received %d bytes.\\n\", bytes_received);\n\n    print_dns_message(read, bytes_received);\n    printf(\"\\n\");\n```", "```cpp\n/*dns_query.c*/\n\n    freeaddrinfo(peer_address);\n    CLOSESOCKET(socket_peer);\n\n#if defined(_WIN32)\n    WSACleanup();\n#endif\n\n    return 0;\n}\n```", "```cpp\ngcc dns_query.c -o dns_query\n./dns_query example.com a\n```", "```cpp\ngcc dns_query.c -o dns_query.exe -lws2_32\ndns_query.exe example.com a\n```"]