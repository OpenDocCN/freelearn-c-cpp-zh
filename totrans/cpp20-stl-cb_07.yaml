- en: '*Chapter 7*: Strings, Streams, and Formatting'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL `string` class is a powerful, full-featured tool for storing, manipulating,
    and displaying character-based data. It has much of the convenience you would
    find in a high-level scripting language, yet remains as quick and agile as you
    would expect from C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `string` class is based on `basic_string`, a contiguous container class
    that may be instantiated with any character type. Its class signature looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Traits` and `Allocator` template parameters are usually left to their default
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The underlying storage of `basic_string` is a contiguous sequence of `CharT`,
    and can be accessed with the `data()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `data()` member function returns a `CharT*` that points to the underlying
    array of characters. Since C++11, the array returned by `data()` is null-terminated,
    making `data()` equivalent to `c_str()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `basic_string` class includes many of the methods you would find in other
    contiguous-storage classes, including `insert()`, `erase()`, `push_back()`, `pop_back()`,
    and others. These methods operate on the underlying array of `CharT`.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::string` is a type alias for `std::basic_string<char>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For most purposes, you'll use `std::string`.
  prefs: []
  type: TYPE_NORMAL
- en: String formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String formatting has traditionally been a weak point with the STL. Until recently,
    we've been left with an imperfect choice between the cumbersome STL `iostreams`
    or the archaic legacy `printf()`. Beginning with C++20 and the `format` library,
    STL string formatting has finally grown up. Closely based on Python's `str.format()`
    method, the new `format` library is fast and flexible, providing many of the advantages
    of both `iostreams` and `printf()`, along with good memory management and type
    safety.
  prefs: []
  type: TYPE_NORMAL
- en: For more about the `format` library, see the *Format text with the new format
    library* recipe in [*Chaper 1*](B18267_01_ePub.xhtml#_idTextAnchor027), *New C++20
    Features*.
  prefs: []
  type: TYPE_NORMAL
- en: While we no longer need to use `iostreams` for string formatting, it is still
    quite useful for other purposes, including file and stream I/O, and some type
    conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover these subjects and more in the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `string_view` as a lightweight string object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenate strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format text with C++20's `format` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trim whitespace from strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read strings from user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Count words in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize complex structures from file input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize a string class with `char_traits`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parse strings with Regular Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap07](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap07).
  prefs: []
  type: TYPE_NORMAL
- en: Use string_view as a lightweight string object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `string_view` class provides a lightweight alternative to the `string` class.
    Instead of maintaining its own data store, `string_view` operates on a *view*
    of a C-string. This makes `string_view` smaller and more efficient than `std::string`.
    It's useful in cases where you need a string object but don't need the more memory-
    and computation-intensive features of `std::string`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `string_view` class looks deceptively similar to the STL `string` class,
    but it works a bit differently. Let''s consider some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an STL `string` initialized from a C-string (array of `char`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `string` does not change when we modify the array. This is because
    the `string` constructor creates its own copy of the underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we do the same with a `string_view`, we get a different result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `string_view` constructor creates a *view* of the underlying data. It does
    not make its own copy. This results in significant efficiencies but also allows
    for side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `string_view` doesn''t copy the underlying data, the source data must
    remain in scope for the duration of the `string_view` object. So, this does not
    work:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the underlying data goes out of scope after the `sv()` function returns,
    the `greeting` object in `main()` is no longer valid by the time we use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `string_view` class has constructors that make sense for the underlying
    data. This includes character arrays (`const char*`), contiguous *ranges* (including
    `std::string`), and other `string_view` objects. This example uses the *ranges*
    constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a `string_view` literal operator `sv`, defined in the `std::literals`
    namespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This constructs a `constexpr string_view` object and calls its method `substr()`
    to get the `4` values starting at index `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `string_view` class is effectively an *iterator adapter* on a contiguous
    sequence of characters. The implementation typically has two members: a `const
    CharT *` and a `size_t`. It works by wrapping a `contiguous_iterator` around the
    source data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that you can use it like `std::string` for many purposes, with a
    few important distinctions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The copy constructor does not copy the data. This means that when you make
    a copy of a `string_view`, each copy operates on the same underlying data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that when you pass a `string_view` to a function, it uses the
    copy constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the address of the underlying data (returned by the `data()` member
    function) is the same for all instances of the `string_view`. That's because the
    copy constructor does not make a copy of the underlying data. Even though the
    `string_view` member pointer is `const`-qualified, it's still possible to cast
    away the `const` qualifier, though it's *not recommended* because it could cause
    unintended side effects. But it is worth noting that the data is never copied.
  prefs: []
  type: TYPE_NORMAL
- en: The `string_view` class lacks methods that directly operate on the underlying
    string. Methods such as `append()`, `operator+()`, `push_back()`, `pop_back()`,
    `replace()`, and `resize()`, which are supported in `string`, are not supported
    in `string_view`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need to concatenate strings with the `+` operator, you''ll need a `std::string`.
    For example, this does not work with `string_view`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll need to use `string` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Concatenate strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to concatenate strings in C++. In this recipe, we will
    look at the three most common: the `string` class `operator+()`, the `string`
    class `append()` function, and the `ostringstream` class `operator<<()`. New in
    C++20, we also have the `format()` function. Each of these has its advantages,
    disadvantages, and use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will examine ways to concatenate strings. We will then perform
    some benchmarks and consider the different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a couple of `std::string` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `string` objects are constructed from literal C-strings.
  prefs: []
  type: TYPE_NORMAL
- en: The C-string constructor makes a copy of the literal string and uses the local
    copy as the underlying data for the `string` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s construct a new empty string object and concatenate `a` and `b`
    with a separator and a newline:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we used the `string` object''s `+=` and `+` operators to concatenate
    the `a` and `b` strings, along with literal strings `", "` and `"\n"`. The resulting
    string has the elements concatenated together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We could instead use the `string` object''s `append()` member function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could construct an `ostringstream` object, which uses the stream interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also use the C++20 `format()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, we have the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `string` object has two distinct methods for concatenating a string, the
    `+` operator and the `append()` member function.
  prefs: []
  type: TYPE_NORMAL
- en: The `append()` member function adds data to the end of the `string` object's
    data. It must allocate and manage memory to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: The `+` operator uses the `operator+()` overload to construct a new `string`
    object with the old and new data, and returns the new object.
  prefs: []
  type: TYPE_NORMAL
- en: The `ostringstream` object works like an `ostream` but stores its output for
    use as a string.
  prefs: []
  type: TYPE_NORMAL
- en: The C++20 `format()` function uses a format string with variadic arguments and
    returns a newly constructed `string` object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do you decide which concatenation strategy is right for your code? We can
    start with some benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I performed these tests using GCC 11 on Debian Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a `timer` function using the `<chrono>` library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `timer` function calls the function passed to it, marking the time before
    and after the function call. It then displays the duration using `cout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we create a function that concatenates strings, using the `append()` member
    function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For benchmarking purposes, this function repeats the concatenation 10 million
    times. We call this function from `main()` with `timer()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: So, on this system, our concatenation ran 10 million iterations in about 425
    milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the same function with the `+` operator overload:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our benchmark output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This version performed 10 million iterations in about 660 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try it with `ostringstream`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our benchmark output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This version ran 10 million iterations in about 3.5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `format()` version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our benchmark output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `format()` version ran 10 million iterations in about 783 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summary of the results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![A comparison of concatenation performance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_table_7.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: A comparison of concatenation performance
  prefs: []
  type: TYPE_NORMAL
- en: Why the performance discrepancies?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can see from these benchmarks that the `ostringstream` version takes many
    times longer than the `string`-based versions.
  prefs: []
  type: TYPE_NORMAL
- en: The `append()` method is slightly faster than the `+` operator. It needs to
    allocate memory but does not construct new objects. Some optimizations may be
    possible due to repetition.
  prefs: []
  type: TYPE_NORMAL
- en: The `+` operator overload probably calls the `append()` method. The extra function
    call could make it incrementally slower than the `append()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `format()` version creates one new `string` object but without the overhead
    of the `iostream` system.
  prefs: []
  type: TYPE_NORMAL
- en: The `ostringstream` operator `<<` overload creates a new `ostream` object for
    each operation. Given the complexity of the stream object, along with managing
    the stream state, this makes it much slower than either of the `string`-based
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: Why would I choose one over another?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some measure of personal preference will be involved. The operator overloads
    (`+` or `<<`) can be convenient. Performance may or may not be an issue for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ostringstream` class has one distinct advantage over the `string` methods:
    it specializes the `<<` operator for each different type, so it''s able to operate
    in circumstances where you may have different types calling the same code.'
  prefs: []
  type: TYPE_NORMAL
- en: The `format()` function offers the same type-safety and customization options
    and is significantly faster than the `ostringstream` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `string` object's `+` operator overload is fast, easy to use, and easy to
    read but is incrementally slower than `append()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `append()` version is fastest but requires a separate function call for
    each item.
  prefs: []
  type: TYPE_NORMAL
- en: For my purposes, I like the `format()` function or the `string` object's `+`
    operator for most circumstances. I'll use `append()` if every bit of speed matters.
    I'll use `ostringstream` where I need its unique features and performance is not
    an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Transform strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::string` class is a *contiguous container*, much like a `vector` or
    an `array`. It supports the `contiguous_iterator` concept and all corresponding
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The `string` class is a specialization of `basic_string` with a `char` type.
    This means that the elements of the container are of type `char`. Other specializations
    are available, but `string` is most common.
  prefs: []
  type: TYPE_NORMAL
- en: Because it is fundamentally a contiguous container of `char` elements, `string`
    may be used with the `transform()` algorithm, or any other technique that uses
    the `contiguous_iterator` concept.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to do transformations, depending on the application.
    This recipe will explore a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a few predicate functions. A predicate function takes a transformation
    element and returns a related element. For example, here is a simple predicate
    that returns an upper-case character:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function is a wrapper around `std::toupper()`. Because the `toupper()`
    function returns an `int` and `string` elements are type `char`, we cannot use
    the `toupper()` function directly in a transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a corresponding `char_lower()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rot13()` function is a fun transformation predicate for demonstration
    purposes. It''s a simple substitution cypher, *not suitable for encryption* but
    commonly used for *obfuscation*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use these predicates with the `transform()` algorithm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `transform()` function calls `char_upper()` with each element of `s`, puts
    the result back in `s` and transforms all the characters to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of `transform()`, we can also use a simple `for` loop with a *predicate*
    *function*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Starting with our uppercase string object, the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The fun thing about the `rot13` cypher is that it unscrambles itself. Because
    there are 26 letters in the *ASCII* alphabet, rotating 13 and then rotating 13
    again results in the original string. Let''s transform to lowercase and `rot13`
    again to restore our string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Because of their uniform interface, the predicate functions may be *chained*
    as parameters of each other. We could also use `char_lower(rot13(c))` with the
    same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your requirement is too complex for a simple character-by-character transformation,
    you may use `string` iterators as you would with any contiguous container. Here''s
    a simple function that transforms a lowercase string to *Title Case* by capitalizing
    the first character and every character that follows a space:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because it returns a reference to the transformed string, we can call it with
    `cout`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::basic_string` class, and its specializations (including `string`),
    are supported by iterators fully compliant with `contiguous_iterator`. This means
    that any technique that works with any contiguous container also works with `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: These transformations will not work with `string_view` objects because the underlying
    data is `const`-qualified.
  prefs: []
  type: TYPE_NORMAL
- en: Format text with C++20's format library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++20 introduces the new `format()` function, which returns a formatted representation
    of its arguments in a string. `format()` uses a Python-style formatting string,
    with concise syntax, type safety, and excellent performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `format()` function takes a format string and a template, *parameter pack*,
    for its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The format string uses curly braces `{}` as a placeholder for the formatted
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It also uses the braces for format specifiers, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This recipe will show you how to use the `format()` function for some common
    string formatting solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was developed using a preview release of the Microsoft Visual C++
    compiler on Windows 10\. At the time of writing, this is the only compiler that
    fully supports the C++20 `<format>` library. Final implementations may differ
    in some details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s consider some common formatting solutions using the `format()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with some variables to format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `pi` constant is in the `<numbers>` header and the `std::numbers` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can display the variables using `cout`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at each of these with `format()`, starting with the C-string,
    `human`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the simplest form of the `format()` function. The format string has
    one placeholder `{}` and one corresponding variable, `human`. The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `format()` function returns a string, and we use `cout <<` to display the
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The original proposal for the `format()` library included a `print()` function,
    using the same parameters as `format()`. That would allow us to print our formatted
    strings in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, `print()` didn't make it into the C++20 standard, although it
    is expected to be included in C++23.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can provide the same functionality with a simple function, using `vformat()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple one-line function gives us a serviceable `print()` function. We
    can use it in place of the `cout << format()` combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: A more complete version of this function may be found in the `include` directory
    of the example files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format string also provides positional options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the order of the arguments by using positional options in the
    format string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the arguments remain the same. Only the positional values in the
    braces have changed. The positional indices are zero-based, just like the `[]`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: This feature can be useful for internationalization, as different languages
    use different orders for parts of speech in a sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many formatting options for numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify the number of digits of precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The colon character `:` is used to separate positional indices from formatting
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want a value to take up a certain amount of space, we can specify the
    number of characters like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We can align it left or right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, it fills with space characters, but we can change that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also center a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We can format integer numbers as hexadecimal, octal, or the default decimal
    representation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I used right alignment to line up the labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a capital `X` for uppercase hexadecimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: By default, Windows uses uncommon character encodings. Recent versions may default
    to UTF-16 or UTF-8 BOM. Older versions may default to "code page" 1252, a superset
    of the ISO 8859-1 ASCII standard. No Windows system defaults to the more common
    UTF-8 (no BOM).
  prefs: []
  type: TYPE_NORMAL
- en: By default, Windows will not display the standard UTF-8 `π` character. To make
    Windows compatible with UTF-8 encoding (and the rest of the world), use the compiler
    switch `/utf-8` and issue the command `chcp 65001` on the command line when testing.
    Now, you can have your `π` and eat it too.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `<format>` library uses a template *parameter pack* to pass arguments to
    the formatter. This allows the arguments to be individually inspected for class
    and type. The library function, `make_format_args()` takes a parameter pack and
    returns a `format_args` object, which provides a *type erased* list of arguments
    to be formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in action in our `print()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `make_format_args()` function takes a parameter pack and returns a `format_args`
    object. The `vformat()` function takes a format string and the `format_args` object,
    and returns a `std::string`. We use the `c_str()` method to get a C-string for
    use with `fputs()`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s common practice to overload the `ostream` `<<` operator for custom classes.
    For example, given a class `Frac` that holds the values of a fraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to print the object as a fraction like `3/5`. So, we would write a
    simple `operator<<` specialization like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide `format()` support for our custom class, we need to create a `formatter`
    object specialization, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The specialization of the `std::formatter` class overloads its `format()` method.
    We inherit from the `formatter<unsigned>` specialization for simplicity. The `format()`
    method is called with a `Context` object, which provides the output context for
    the formatted string. For the return value, we use the `format_to()` function
    with `ctx.out`, a normal format string, and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can now use our `print()` function with the `Frac` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The formatter now recognizes our class and provides our desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Trim whitespace from strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common for input from users to include extraneous whitespace at one or
    both ends of a string. This can be problematic, so we often need to remove it.
    In this recipe, we'll use the `string` class methods, `find_first_not_of()` and
    `find_last_not_of()`, to trim whitespace from the ends of a string.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `string` class includes methods for finding elements that are, or are not,
    included in a list of characters. We''ll use these methods to trim `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining `string` with input from a hypothetical ten-thumbed user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our input has a few extra tab `\t` and newline `\n` characters before and after
    the content. We print it with surrounding brackets to show the whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a `trimstr()` function to remove all the whitespace characters from
    both ends of `string`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We defined our set of whitespace characters as *space*, *tab*, *return*, *newline*,
    *vertical tab*, and *form feed*. Some of these are more common than others, but
    that's the canonical set.
  prefs: []
  type: TYPE_NORMAL
- en: This function uses the `find_first_not_of()` and `find_last_not_of()` methods
    of the `string` class to find the first/last elements that are *not* a member
    of the set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can call the function to get rid of all that unsolicited whitespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `string` class''s various `find...()` member functions return a position
    as a `size_t` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The return value is the zero-based position of the first matching character
    (*not* in the `s` list of characters) or the special value, `string::npos`, if
    not found. `npos` is a static member constant that represents an invalid position.
  prefs: []
  type: TYPE_NORMAL
- en: We test for `(first == string::npos)` and return an empty string `{}` if there
    is no match. Otherwise, we use the `first` and `last` positions with the `s.substr()`
    method to return the string without whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Read strings from user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL provides character-based input from the standard input stream using
    the `std::cin` object. The `cin` object is a global *singleton* that reads input
    from the console as an `istream` input stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `cin` reads *one word at a time* until it reaches the end of the
    stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This is of limited usefulness, and it may lead some to dismiss `cin` as minimally
    functional.
  prefs: []
  type: TYPE_NORMAL
- en: While `cin` certainly has its quirks, it can be easily wrangled into providing
    line-oriented input.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get basic line-oriented functionality from `cin`, there are two significant
    behaviors that need to be understood. One is the ability to get a line at a time,
    instead of a word at a time. The other is the ability to reset the stream after
    an error condition. Let''s look at these in some detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to prompt the user for input. Here''s a simple `prompt` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `cout.flush()` function call ensures that the output is displayed immediately.
    Sometimes, when the output doesn't include a newline, the output stream may not
    flush automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cin` class has a `getline()` method that gets a line of text from the
    input stream and puts it in a C-string array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cin.getline()` method takes three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is a C-string array for the destination. The second is the
    size of the array. The third is the delimiter for the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: The function will not put more than `count`-1 characters in the array, leaving
    room for a *null* terminator.
  prefs: []
  type: TYPE_NORMAL
- en: The delimiter defaults to the newline `'\n'` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL also provides a stand-alone `getline()` function that works with an
    STL `string` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The stand-alone `std::getline()` function takes three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the output stream, second is a reference to a `string`
    object, and the third is the end-of-line delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: If not specified, the delimiter defaults to the newline `'\n'` character.
  prefs: []
  type: TYPE_NORMAL
- en: I find the standalone `getline()` more convenient than the `cin.getline()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `cin` to get a specific type from the input stream. To do this, we
    must be able to handle an error condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When `cin` encounters an error, it sets the stream to an error condition and
    stops accepting input. To retry input after an error, we must reset the state
    of the stream. Here''s a function that resets the input stream after an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The `cin.clear()` function resets the error flags on the input stream but leaves
    text in the buffer. We then clear the buffer by reading a line and discarding
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can accept numeric input by using `cin` with numeric type variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The `cin >> a >> b` expression accepts input from the console and attempts to
    convert the first two words to types compatible with `a` and `b` (`double`). If
    it fails, we call `clearistream()` and try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `getline()` separator parameter to get comma-separated input:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Because this code runs after the numbers code, and because `cin` is messy, there
    may still be a line ending in the buffer. The `while(line.empty())` loop will
    optionally eat any empty lines.
  prefs: []
  type: TYPE_NORMAL
- en: We use a `stringstream` object to process the words, so we don't have to do
    it with `cin`. This allows us to use `getline()` to get one line without waiting
    for the end-of-file state.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call `getline()` on the `stringstream` object to parse out words separated
    by commas. This gives us words but with leading whitespace. We use the `trimstr()`
    function from the *Trim whitespace from strings* recipe in this chapter to trim
    the whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::cin` object is more useful than it may appear, but it can be a challenge
    to use. It tends to leave line endings on the stream, and in the case of errors,
    it can end up ignoring input.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to use `getline()` and, when necessary, put the line into a
    `stringstream` for convenient parsing.
  prefs: []
  type: TYPE_NORMAL
- en: Count words in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the `basic_istream` class reads one word at a time. We can take
    advantage of this property to use an `istream_iterator` to count words.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a simple recipe to count words using an `istream_iterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a simple function to count words using an `istream_iterator`
    object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `distance()` function takes two iterators and returns the number of steps
    between them. The `using` statement creates an alias `it_t` for the `istream_iterator`
    class with a `string` specialization. We then call `distance()` with an iterator,
    initialized with the input stream `it_t{is}`, and another with the default constructor,
    which gives us an end-of-stream sentinel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `wordcount()` from `main()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This calls `wordcount()` with our `fstream` object and prints the number of
    words in the file. When I call it with the text of Edgar Allan Poe''s *The Raven*,
    we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because `basic_istream` defaults to word-by-word input, the number of steps
    in a file will be the number of words. The `distance()` function will measure
    the number of steps between two iterators, so calling it with the beginning and
    the sentinel of a compatible object will count the number of words in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize complex structures from file input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One strength of the *input stream* is its ability to parse different types of
    data from a text file and convert them to their corresponding fundamental types.
    Here's a simple technique for importing data into a container of structures using
    an input stream.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll take a data file and import its disparate fields into
    a `vector` of `struct` objects. The data file represents cities with their populations
    and map coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is `cities.txt`, the data file we''ll read:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The city name is on a line by itself. The second line is population, followed
    by longitude and latitude. This pattern repeats for each of the five cities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define our filename in a constant so that we can open it later:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s a `City` struct to hold the data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We would like to read the file and populate a `vector` of `City` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s where the input stream makes this easy. We can simply specialize `operator>>`
    for our `City` class like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `std::ws` input manipulator discards leading whitespace from the input stream.
  prefs: []
  type: TYPE_NORMAL
- en: We use `getline()` to read the city name, as it could be one or more words.
  prefs: []
  type: TYPE_NORMAL
- en: This leverages the `>>` operator for the `population` (`unsigned long`), and
    `latitude` and `longitude` (both `double`) elements to populate the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can open the file and use the `>>` operator to read the file directly
    into the `vector` of `City` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can display the vector using `format()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The `make_commas()` function was also used in the *Use structured binding to
    return multiple values* recipe in [*Chapter 2*](B18267_02_ePub.xhtml#_idTextAnchor057),
    *General STL Features*. It takes a numeric value and returns a `string` object,
    with commas added for readability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The heart of this recipe is the `istream` class `operator>>` overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'By specifying our `City` class in the function header, this function will be
    called every time a `City` object appears on the right-hand side of an input stream
    `>>` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to specify exactly how the input stream reads data into a `City`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you run this code on a Windows system, you'll notice that the first word
    of the first line gets corrupted. That's because Windows always includes a **Byte
    Order Mark** (**BOM**) at the head of any UTF-8 file. So, when you read a file
    on Windows, the BOM will be included in the first object you read. The BOM is
    anachronistic, but at the time of writing, there is no way to stop Windows from
    employing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to call a function that checks the first three bytes of a file
    for the BOM. The BOM for UTF-8 is `EF BB BF`. Here''s a function that searches
    for, and skips, a UTF-8 BOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This reads the first three bytes of the file and checks them for the UTF-8 BOM
    signature. If any of the three bytes do not match, it resets the input stream
    to the beginning of the file. If the file has no BOM, there's no harm done.
  prefs: []
  type: TYPE_NORMAL
- en: 'You simply call this function before you begin reading from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that the BOM is not included in the first string of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Because the `cin` input stream is not seekable, the `skip_bom()` function will
    not work on the `cin` stream. It will only work with a seekable text file.
  prefs: []
  type: TYPE_NORMAL
- en: Customize a string class with char_traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `string` class is an alias of the `basic_string` class, with the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The first template parameter provides the type of character. The second template
    parameter provides a character traits class, which provides basic character and
    string operations for the specified character type. We normally use the default
    `char_traits<char>` class.
  prefs: []
  type: TYPE_NORMAL
- en: We can modify the behavior of a string by providing our own custom character
    traits class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a *character traits class* for use with `basic_string`
    that will ignore casing for comparison purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need a function to convert characters to a common case. We''ll
    use lowercase here, but it''s an arbitrary choice. Uppercase would work just as
    well:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function must be `constexpr` (for C++20 and later), so the existing `std::tolower()`
    function won't work here. Fortunately, it's a simple solution to a simple problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our traits class is called `ci_traits` (*ci* stands for case-independent).
    It inherits from `std::char_traits<char>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The inheritance allows us to override only the functions that we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The comparison functions are called `lt()` for less than and `eq()` for equal
    to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we compare the *lowercase* versions of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also a `compare()` function, which compares two C-strings. It returns
    `+1` for greater than, `-1` for less than, and `0` for equal to. We can use the
    spaceship `<=>` operator for this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to implement a `find()` function. This returns a pointer to
    the first instance of a found character, or `nullptr` if not found:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have a `ci_traits` class, we can define an alias for our `string`
    class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `main()` function, we define a `string` and a `ci_string`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to print them using `cout`, but this won''t work:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we need an operator overload for the `operator<<`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare two `ci_string` objects with different cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The comparison works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `find()` function on the `ci_s` object, we search for a lowercase
    `b` and find an uppercase `B`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `format()` function doesn't require a specialization. This was
    tested with the `fmt.dev` reference implementation. It did not work with the preview
    release of MSVC's `format()`, even with a specialization. Hopefully, this will
    be fixed in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe works by replacing the `std::char_traits` class in the template
    specialization of the `string` class with a `ci_traits` class of our own. The
    `basic_string` class uses the traits class for its fundamental character-specific
    functions, such as comparisons and searching. When we replace it with our own
    class, we can change these fundamental behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also override the `assign()` and `copy()` member functions to create
    a class that stores lowercase characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create an `lc_string` alias, and the object stores lowercase characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: These techniques work as expected on GCC and Clang but not on the preview release
    of MSVC. I expect that this will be fixed in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: Parse strings with Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Regular Expressions* (commonly abbreviated as *regex*) are commonly used for
    lexical analysis and pattern-matching on streams of text. They are common in Unix
    text-processing utilities, such as `grep`, `awk`, and `sed`, and are an integral
    part of the *Perl* language. There are a few common variations in the syntax.
    A POSIX standard was approved in 1992, while other common variations include *Perl*
    and *ECMAScript* (JavaScript) dialects. The C++ `regex` library defaults to the
    ECMAScript dialect.'
  prefs: []
  type: TYPE_NORMAL
- en: The `regex` library was first introduced to the STL with C++11\. It can be very
    useful for finding patterns in text files.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Regular Expression syntax and usage, I recommend the book,
    *Mastering Regular Expressions* by Jeffrey Friedl.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will extract hyperlinks from an HTML file. A hyperlink
    is coded in HTML like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: We will use a `regex` object to extract both the link and the text, as two separate
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example file is called `the-end.html`. It''s taken from my website ([https://bw.org/end/](https://bw.org/end/)),
    and is included in the GitHub repository:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define our `regex` object with a regular expression string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Regular expressions can look intimidating at first, but they're actually rather
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is parsed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Match the whole string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the substring `<a href="`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store everything up to the next `"` as sub-match `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skip past the `>` character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store everything up to the string `</a>` as sub-match `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we read our file entirely into a string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This opens the HTML file, reads it line by line, and appends each line to the
    `string` object, `in`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the link strings, we set up an `sregex_token_iterator` object to
    step through the file and extract each of the matched elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `1` and `2` correspond to the sub-matches in the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a corresponding function to step through the results with the iterator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We call the function with the `regex` iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'And we get this result with our descriptions and links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `regex` engine operates as a *generator* that evaluates and yields one
    result at a time. We set up the iterator using `sregex_iterator` or `sregex_token_iterator`.
    While `sregex_token_iterator` supports sub-matches, `sregex_iterator` does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parentheses in our regex serve as *sub-matches*, numbered `1` and `2` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Each part of the `regex` matches is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A Regular Expression with sub-matches'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – A Regular Expression with sub-matches
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to match a string and use parts of that string as our results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The sub-matches are numbered, beginning with `1`. Sub-match `0` is a special
    value that represents the entire match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our iterator, we use it as we would any other iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply steps through our results via the `regex` iterator, giving us the
    formatted output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
