- en: '*Chapter 6*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lesson Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Compose classes that inherit properties from other classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement polymorphism in C++ programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use best practices to manage dynamic memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use the advanced features of C++ to create
    dynamic programs.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In earlier chapters, we learned about templates that are used to create functions
    and classes that work with arbitrary types. This avoids duplication of work. However,
    using templates is not applicable in all cases, or may not be the best approach.
    The limitation of templates is that their types need to be known when the code
    is compiled.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world cases, this is not always possible. A typical example would be
    a program that determines what logging infrastructure to use depending on the
    value of a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: While developing the application and executing tests, the application would
    use a logger that prints detailed information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, when the application is deployed to the PCs of its users,
    the application would use a logger that prints **error summaries** and notifies
    the developers if there are any errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can solve these problems using the concept of inheritance in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inheritance allows the combination of one or more classes. Let''s look at an
    example of inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Car` class inherits from the `Vehicle` class, or, we can
    say `Car` derives from `Vehicle`. In C++ terminology, `Vehicle` is the *base*
    class, and `Car` is the *derived* class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining a class, we can specify the classes it derives from by appending
    `:`, followed by one or more classes, separated by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When specifying the list of classes to derive from, we can also specify the
    visibility of the inheritance – `private`, `protected`, or `public`.
  prefs: []
  type: TYPE_NORMAL
- en: The visibility modifier specifies who can know about the inheritance relationship
    between the classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods of the base class can be accessed as methods of the derived class
    based on the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the inheritance is `public`, the code external to the class knows that
    `Car` derives from `Vehicle`. All the public methods of the base class are accessible
    as *public* method of the derived class by the code in the program. The protected
    methods of the base class can be accessed as *protected* by the methods of the
    derived class. When inheritance is `protected`, all the public and protected members
    are accessible as *protected* by the derived class. Only the derived class and
    classes that derive from it know about inheritance; external code sees the two
    classes as unrelated.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when deriving with a `private` modifier, all the `public` and `protected`
    methods and fields of the base class are accessible by the derived class as `private`.
  prefs: []
  type: TYPE_NORMAL
- en: The private methods and fields of a class are *never accessible* outside of
    that class.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the fields of the base class follows the same rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C11557_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Base class methods and the access level they provide'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Inheritance creates a hierarchy of derived and base classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Orange` class can be derived from a `Citrus` class, which is in turn derived
    from a `Fruit` class. Here is how it can be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The class `Citrus` can access the public and protected methods of class `Fruit`,
    whereas class `Orange` will be able to access both `Citrus`' and `Fruit`'s public
    and protected methods (`Fruit`'s public methods are accessible through `Citrus`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 20: Creating a Program to Illustrate Inheritance in C++'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following exercise to create a derived class that inherits
    from multiple base classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the header file at the start of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the first base class, named `Vehicle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the second base class, named `CollectorItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the derived class, named `Ferrari250GT`, as illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `main` function, instantiate the `Ferrari250GT` class and call
    the `getValue()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The specifier is not mandatory. If it is omitted, it defaults to *public for
    structs* and to *private for classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you use inheritance to group together some functionality when implementing
    a class, it is often correct to use **private inheritance**, as that is a detail
    of how you are implementing the class, and it is not part the **public interface**
    of the class. If, instead, you want to write a derived class that can be used
    in place of the base class, use public inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'When inheriting from a class, the base class gets **embedded** into the derived
    class. This means that all the data of the base class also becomes part of the
    derived class in its **memory representation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Representation of the derived class and the base class](img/C11557_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Representation of the derived class and the base class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A question might come up at this point – we are embedding the base class inside
    the derived class. This means that we need to initialize the base class when we
    initialize the derived class, otherwise, part of the class would be left uninitialized.
    When do we initialize the base class?
  prefs: []
  type: TYPE_NORMAL
- en: When writing the constructor of the derived class, the compiler will implicitly
    call the default constructor of the base class before any initialization takes
    place.
  prefs: []
  type: TYPE_NORMAL
- en: If the base class does not have a default constructor but has a constructor
    that accepts parameters, then the derived class constructor can explicitly call
    it in the initialization list. Otherwise, there will be an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way to how the compiler calls the constructor of the base class
    when the derived class is constructed, the compiler takes care of always calling
    the destructor of the base class after the destructor of the derived class has
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When `B`''s constructor is called, the `A` needs to be initialized. Since `A`
    doesn''t have a default constructor, the compiler cannot initialize it for us:
    we have to call `A`''s constructor explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: The **copy constructor** and the **assignment operator** generated by the compiler
    take care of calling the constructor and operator of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: When, instead, we write our implementation of the copy constructor and the assignment
    operators, we need to take care of calling the copy constructor and assignment
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In many compilers, you can enable additional warnings that notify you if you
    forget to add the calls to the base constructor.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that inheritance needs to model an `A` to inherit
    from another class, `B`, you are saying that `A` `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, a vehicle is a good example: a car is a vehicle, a bus
    is a vehicle, and a truck is also a vehicle. A bad example would be for a car
    to inherit from an engine. While the engine might have similar functionality to
    a car, such as a `start` method, it is wrong to say that a car is an engine. The
    relationship, in this case, is **has a**: the car has an engine; this relationship
    represents composition.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using an **is a** test to understand whether a relationship can use inheritance
    can fail in some cases: for example, a **square** inheriting from a **rectangle**.
    When the width of the rectangle is doubled, the area of the rectangle doubles,
    but the area of the square quadruples. This means that code that expects to interact
    with rectangles might get surprising results when using a square, even if the
    square, mathematically, is a rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: A more general rule is to use the `A` class inherits from `B`, we could replace
    the `A` class anywhere the `B` class is used, and the code would still behave
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to now, we have seen examples of single inheritance: a derived class has
    a single base class. C++ supports multiple inheritance: a class can derive from
    multiple classes. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `C` struct derives both from `A` and from `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules on how inheritance works are the same for single and multiple inheritance:
    the methods of all the derived classes are visible based on the visibility access
    specified, and we need to make sure to call the appropriate constructors and assign
    an operator for all of the base classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is usually best to have a shallow inheritance hierarchy: there should not
    be many levels of derived classes.'
  prefs: []
  type: TYPE_NORMAL
- en: When using a multi-level inheritance hierarchy or multiple inheritance, it's
    more likely that you'll encounter some problems, such as **ambiguous calls**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A call is ambiguous when the compiler cannot clearly understand which method
    to call. Let''s explore the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, it is not clear which `foo()` to call, `A`''s or `B`''s. We
    can disambiguate that by prepending the name of the class followed by two columns:
    `A::foo()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 21: Using Multiple Inheritance to Create a "Welcome to the Community"
    Message Application'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s use multiple inheritance to create an application to print a "welcome
    to the community" message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the required header files in the program, as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the required classes, `DataScienceDev` and `FutureCppDev`, with the
    required print statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the `Student` class as illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, invoke the `Student` class in the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activity 23: Creating Game Characters'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want to write a new game, and in that game, create two types of characters
    – a hero and enemies. Enemies can swing their swords, and the hero can cast a
    spell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can achieve the task:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Character` class that has a public method, `moveTo`, that prints `Moved
    to position`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `Position` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create two classes, `Hero` and `Enemy`, that are derived from the Character
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Spell` class with the constructor that takes the name of the spell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Hero` class should have a `public` method to cast a spell. Use the value
    from the `Spell` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Enemy` class should have a `public` method to swing a sword, which prints
    `Swinging sword`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the main method, which calls these methods in various classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 309.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we mentioned that inheritance is a solution that allows
    you to change the behavior of code while a program is running. This is because
    inheritance enables polymorphism in C++.
  prefs: []
  type: TYPE_NORMAL
- en: '**Polymorphism** means *many forms* and represents the ability of objects to
    behave in different ways.'
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier that templates are a way to write code that works with
    many different types at compilation time and, depending on the types used to instantiate
    the template, the behavior will change.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of pattern is called **static polymorphism** – static because it is
    known during compilation time. C++ also supports **dynamic polymorphism** – having
    the behavior of methods change while the program is running. This is powerful
    because we can react to information we obtain only after we have compiled our
    program, such as user input, values in configurations, or the kind of hardware
    the code is running on. This is possible thanks to two features – **dynamic binding**
    and **dynamic dispatch**.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dynamic binding** is the ability for a reference or a pointer of a base type
    to point to an object of a derived type at runtime. Let''s explore the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To allow dynamic binding, the code must *know* that the derived class derives
    from the base class.
  prefs: []
  type: TYPE_NORMAL
- en: If the inheritance's visibility is `private`, then only code inside the derived
    class will be able to bind the object to a *pointer* or *reference* of the base
    class.
  prefs: []
  type: TYPE_NORMAL
- en: If the inheritance is `protected`, then the derived class and every class deriving
    from it will be able to perform dynamic binding. Finally, if the inheritance is
    `public`, the dynamic binding will always be *allowed*.
  prefs: []
  type: TYPE_NORMAL
- en: This creates the distinction between the `static` type and the `dynamic` (or
    run-time) type. The static type is the type we can see in the source code. In
    this case, we can see that `ref1` has a static type of a reference to the `A`
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dynamic type is the real type of the object: the type that has been constructed
    in the object''s memory location at runtime. For example, the static type of both
    `ref1` and `ref2` is a reference to the `A` struct, but the `ref1` dynamic type
    is `B`, since `ref1` refers to a memory location in which an object of type `B`
    has been created, and the `ref2` dynamic type is `C` for the same reason.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As said, the dynamic type can change at runtime. While the static type of a
    variable is always the same, its dynamic type can change: `ptr` has a static type,
    which is a pointer to `A`, but its dynamic type could change during the execution
    of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that only references and pointers can be assigned
    values from a derived class safely. If we were to assign an object to a value
    type, we would get a surprising result – the object would get sliced.
  prefs: []
  type: TYPE_NORMAL
- en: 'We said earlier that a base class is **embedded** inside a derived class. Say,
    for example, we were to try and assign to a value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code would compile, but only the embedded part of `A` inside of `B` would
    be copied – when we declare a variable of type `A`, the compiler dedicates an
    area of the memory big enough to contain an object of type `A`, so there cannot
    be enough space for `B`. When this happens, we say that we sliced the object,
    as we took only a part of the object when assigning or copying.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is not the intended behavior to slice the object. Be mindful of this interaction
    and try to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior happens because C++ uses *static dispatch* by default for function
    and method calls: when the compiler sees a method call, it will check the static
    type of the variable on which the method is called, and it will execute the `A`
    is called, and it only copies the part of `A` inside `B`, ignoring the remaining
    fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As said before, C++ supports dynamic dispatch. This is done by marking a method
    with a special keyword: **virtual**.'
  prefs: []
  type: TYPE_NORMAL
- en: If a method is marked with the `virtual` keyword, when the method is called
    on a *reference* or a *pointer*, the compiler will execute the implementation
    of the dynamic type instead of the static type.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two features enable *polymorphism* – we can write a function that accepts
    a reference to a base class, call methods on this base class, and the methods
    of the derived classes will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then call the function with many different types of vehicles, and the
    appropriate methods will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A typical pattern is to create an interface that only specifies the methods
    that are required for some functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Classes that need to be used with such functionality must derive the interface
    and implement all the required methods.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've learned the advantages of dynamic dispatch in C++ and how it can enable
    us to execute the methods of a derived class by calling a method on a reference
    or pointer to a base class.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take an in-depth look at how to tell the compiler to
    perform dynamic dispatch on a method. The way to specify that we want to use dynamic
    dispatch for a method is to use the `virtual` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `virtual` keyword is used in front of a method when declaring it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We need to remember that the compiler decides how to perform method dispatch
    based on the static type of the variable that is used when calling the method.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we need to apply the virtual keyword to the type we are using
    in the code. Let's examine the following exercise to explore the virtual keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 22: Exploring the Virtual Method'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a program using the concept of inheritance using the virtual
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure to add the required header file and namespace to compile the
    program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the `Vehicle` class as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Car` class, add the `virtual` keyword as illustrated :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the main function, invoke the `Car` class and pass the `car` object
    in the `myTurnOn()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the call will not be dynamically dispatched, and the call to the implementation
    of `Vehicle::turnOn()` will be executed. The reason is that the static type of
    the variable is `Vehicle`, and we did not mark the method as `virtual`, so the
    compiler uses static dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we wrote a `Car` class that declares the method virtual is not
    important, since the compiler only sees the `Vehicle` class being used in `myTurnOn()`.
    When a method is declared `virtual`, we can override it in a derived class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To override a method, we need to declare it with the same signature as the
    parent class: the same return type, name, parameters (including `const`-ness and
    `ref`-ness), `const` qualifier, and the other attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the signature does not match, we will create an overload for the function.
    The overload will be callable from the derived class, but it will never be executed
    with a dynamic dispatch from a base class, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When a class overrides a virtual method of the base class, the method of the
    *most derived class* will be executed when the method is called on a base class.
    This is `true` even if the method is called from inside the base class, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see a new keyword in the preceding example: the `override` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: C++11 introduced this keyword to enable us to specify that we are overriding
    a method explicitly. This allows the compiler to give us an error message if we
    use the `override` keyword, but the signature does not match any base class' virtual
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Always use the `override` keyword when you are overriding a method. It is easy
    to change the signature of the base class and forget to update all the locations
    where we overrode the method. If we do not update them, they will become a new
    overload instead of an override!
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we also used the `virtual` keyword for each function. This is
    not necessary, since a virtual method on a base class makes every method with
    the same signature in the derived classes virtual as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is good to be explicit `virtual` keyword, but if we are already using the
    `override` keyword, it might be redundant – in these cases, the best way is to
    follow the coding standard of the project you are working on.
  prefs: []
  type: TYPE_NORMAL
- en: The `virtual` keyword can be applied to any method. Since the constructor is
    not a method, the constructor cannot be marked as virtual. Additionally, dynamic
    dispatch is disabled inside constructors and destructors.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that when constructing a hierarchy of derived classes, the constructor
    of the base class is executed before the constructor of the derived class. This
    means that if we were to call the virtual method on the derived class when constructing
    the base class, the derived class would not be initialized yet.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when calling the destructor, the destructors of the whole hierarchy
    are executed in reverse order; first the derived and then the base class. Calling
    a `virtual` method in the destructor would call the method on a derived class
    that has already been destructed, which is an error.
  prefs: []
  type: TYPE_NORMAL
- en: While the constructor cannot be marked as virtual, the destructor can. If a
    class defines a virtual method, then it should also declare a virtual destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a destructor virtual is extremely important when classes are created
    on dynamic memory, or the heap. We are going to see later in this chapter how
    to manage dynamic memory with classes, but for now, it is important to know that
    if a destructor is not declared virtual, then an object might be only partially
    destructed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If a method is marked virtual, then the destructor should also be marked virtual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 24: Calculating Employee Salaries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are writing a system to compute the paycheques for the employees of a company.
    Each employee has a base salary plus a bonus.
  prefs: []
  type: TYPE_NORMAL
- en: 'For employee who are not managers, the bonus is computed from the performance
    of the department: they get 10% of the base salary if the department reached its
    goal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The company also has managers, for whom the bonus is computed in a different
    way: they get 20% of the base salary if the department reached its goal, plus
    1% of the difference between the achieved result of the department and the expected
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to create a function that takes an employee and computes their total
    salary, summing the base salary and the bonus, regardless of whether they are
    a manager or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Department class accepts the expected earning and the effective earning
    when constructed, and stores them in two fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an `Employee` class with two `virtual` functions, `getBaseSalary()`,
    and `getBonus()`. Within it, implement the logic for employee bonus calculation
    if the department goal is met:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another function that provides the total compensation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Manager` class that derives from `Employee`. Again, create the same
    virtual functions, `getBaseSalary()` and `getBonus()`. Within it, implement the
    logic for a `Manager` bonus calculation if the department goal is met:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `main` program, and run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 311.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Interfaces in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw how to define a method that is virtual, and
    how the compiler will do dynamic dispatch when calling it.
  prefs: []
  type: TYPE_NORMAL
- en: We have also talked about interfaces throughout the chapter, but we never specified
    what an interface is.
  prefs: []
  type: TYPE_NORMAL
- en: An interface is a way for the code to specify a contract that the caller needs
    to provide to be able to call some functionality. We looked at an informal definition
    when talking about the templates and the requirements they impose on the types
    used with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions and methods which accepts parameters as interface are a way of saying:
    in order to perform my actions, I need these functionalities; it''s up to you
    to provide them.'
  prefs: []
  type: TYPE_NORMAL
- en: To specify an interface in C++, we can use an **Abstract Base Class** (**ABC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive into the name; the class is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract**: This means that it cannot be instantiated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Base**: This means it is designed to be derived from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any class that defines a pure virtual method is `abstract`. A pure virtual
    method is a virtual method that ends with `= 0`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: A pure virtual method is a method that does not have to be defined. Nowhere
    in the previous code have we specified the implementation of `Vehicle::turnOn()`.
    Because of this, the `Vehicle` class cannot be instantiated, as we do not have
    any code to call for its pure virtual methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can instead derive from the class and override the pure virtual method.
    If a class derives from an abstract base class, it can be either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Another abstract base class if it declares an additional pure virtual method,
    or if it does not override all the pure virtual methods of the base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular class if it overrides all the pure virtual methods of the base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s continue with the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `Vehicle` is an abstract base class and `GasolineVehicle` is
    too, since it does not override all the pure virtual methods of `Vehicle`. It
    also defines an additional virtual method, which the `Car` class overrides together
    with the `Vehicle::turnOn()` method. This makes `Car` the only concrete class,
    a class that can be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same concept applies when a class is deriving from multiple abstract base
    classes: all the pure virtual methods of all the classes that need to be overridden
    in order to make the class concrete and thus instantiable.'
  prefs: []
  type: TYPE_NORMAL
- en: While abstract base classes cannot be instantiated, we can define references
    and pointers to them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you try to instantiate an abstract base class, the compiler will give an
    error specifying which methods are still pure virtual, thus making the class abstract.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and methods that require specific methods can accept references and
    pointers to abstract base classes, and instances of concrete classes that derive
    from them can be bound to such references.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is good practice for the consumer of the interface to define the interface.
  prefs: []
  type: TYPE_NORMAL
- en: A function, method, or class that requires some functionality to perform its
    actions should define the interface. Classes that should be used with such entities
    should implement the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since C++ does not provide a specialized keyword for defining interfaces and
    interfaces are simply abstract base classes, there are some guidelines that it''s
    best practice to follow when designing an interface in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract base class should *not* have any data members or fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason for this is that an interface specifies behavior, which should be
    independent of the data representation. It derives that abstract base classes
    should only have a default constructor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An abstract base class should always define a `virtual ~Interface() = default`.
    We are going to see why it is important for the destructor to be virtual later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the methods of an abstract base class should be pure virtual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface represents an expected functionality that needs to be implemented;
    a method which is not pure is an implementation. The implementation should be
    separate from the interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All of the methods of an abstract base class should be `public`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the previous point, we are defining a set of methods that we expect
    to call. We should not limit which classes can call the method only to classes
    deriving from the interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All the methods of an abstract base class should be regarding a single functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our code requires multiple functionalities, separate interfaces can be created,
    and the class can derive from all of them. This allows us to compose interfaces
    more easily.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Consider disabling the copy and move constructors and assignment operators
    on the interface. Allowing the interface to be copied can cause the slicing problem
    we were describing before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: With the last assignment, we only copied the `Vehicle` part, since the copy
    constructor of the `Vehicle` class has been called. The copy constructor is not
    virtual, so the implementation in `Vehicle` is called, and since it only knows
    about the data members of the `Vehicle` class (which should be none), the ones
    defined inside `Car` have not been copied! This results in problems that are very
    hard to identify.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible solution is to disable the interface copy and move construct and
    assign operator: `Interface(const Interface&) = delete`; and similar. This has
    the drawback of disabling the compiler from creating the copy constructor and
    assign operators of the derived classes.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to declare copy/move constructor/assignment protected so that
    only derived classes can call them, and we don't risk assigning interfaces while
    using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 25: Retrieving User Information'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are writing an application to allow users to buy and sell items. When a user
    logs in, we need to retrieve several pieces of information to populate their profile,
    such as the URL for the profile picture and the full name.
  prefs: []
  type: TYPE_NORMAL
- en: Our service is running in many data centers around the world, to always be close
    to its customers. Because of that, sometimes we want to retrieve information for
    the user from a cache, but sometimes we want to retrieve it from our main database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the code, which can be independent of where the data is coming
    from, so we create an abstract `UserProfileStorage` class to retrieve the `CustomerProfile`
    from `UserId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, write the `UserProfileCache` class, which inherits from `UserProfileStorage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main` function, instantiate the `UserProfileCache` class and the call
    `exampleOfUsage` function as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found at page 312.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have come across the term dynamic memory. Now let's understand
    in more detail what dynamic memory is, what problems it solves, and when to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic memory** is the part of the memory that the program can use to store
    objects, for which the program is responsible for maintaining the correct lifetime.'
  prefs: []
  type: TYPE_NORMAL
- en: It is usually also called the **heap** and is often the alternative to the stack,
    which instead is handled automatically by the program. Dynamic memory can usually
    store much larger objects than the stack, which usually has a limit.
  prefs: []
  type: TYPE_NORMAL
- en: A program can interact with the operating system to get pieces of dynamic memory
    that it can use to store objects, and later it must take care to return such memory
    to the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, developers would make sure they called the appropriate functions
    to get and return memory, but modern C++ automates most of this, so it is much
    easier to write correct programs nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to show how and when it is recommended to use
    dynamic memory in a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example: we want to write a function that will create
    a logger. When we execute tests, we create a logger specifically for the test
    called `TestLogger`, and when we run our program for users, we want to use a different
    logger, called `ReleaseLogger`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can see a good fit for interfaces here – we can write a logger abstract base
    class that defines all the methods needed for logging and have `TestLogger` and
    `ReleaseLogger` derive from it.
  prefs: []
  type: TYPE_NORMAL
- en: All our code will then use a reference to the logger when logging.
  prefs: []
  type: TYPE_NORMAL
- en: How can we write such a function?
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in *Chapter 2*, *Functions*, we cannot create the logger inside
    the function and then return a reference to it, since it would be an automatic
    variable and it would be destructed just after the return, leaving us with a dangling
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot create the logger before calling the function and let the function
    initialize it either, since the types are different, and the function knows which
    type should be created.
  prefs: []
  type: TYPE_NORMAL
- en: We would need some storage that is valid until we need the logger, to put the
    logger in it.
  prefs: []
  type: TYPE_NORMAL
- en: Given only an interface, we cannot know the size of the classes implementing
    it, since multiple classes could implement it and they could have different sizes.
    This prevents us from reserving some space in memory and passing a pointer to
    such space to the function, so that it could store the logger in it.
  prefs: []
  type: TYPE_NORMAL
- en: Since classes can have different sizes, the storage not only needs to remain
    valid longer than the function, but it also needs to be variable. That is **dynamic
    memory**!
  prefs: []
  type: TYPE_NORMAL
- en: In C++, there are two keywords to interact with dynamic memory – **new** and
    **free**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `new` expression is used to create a new object in dynamic memory – it
    is composed by the `new` keyword, followed by the type of the object to create
    and the parameters to pass to the constructor, and returns a pointer to the requested
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `new` expression requests a piece of dynamic memory big enough to hold the
    object created and instantiates an object in that memory. It then returns a pointer
    to such an instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program can now use the object pointed to by `myCar` until it decides to
    delete it. To delete a pointer, we can use the delete expression: it is composed
    by the `delete` keyword followed by a variable, which is a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `delete` keyword calls the destructor of the object pointed to by the pointer
    provided to it, and then gives the memory we initially requested back to the operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting pointers to automatic variables lead to an error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It is of absolute importance that, for each new expression, we call the `delete`
    expression only once, with the same returned pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we forget to call the `delete` function on an object returned by calling
    the `new` function, we will have two major problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The memory will not be returned to the operating system when we do not need
    it anymore. This is known as a **memory leak**. If this repeatedly happens during
    the execution of the program, our program will take more and more memory, until
    it consumes all the memory it can get.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destructor of the object will not be called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw in previous chapters that, in C++, we should make use of RAII and get
    the resources we need in the constructor and return them in the destructor.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not call the destructor, we might not return some resources. For example,
    a connection to the database would be kept open, and our database would struggle
    due to too many connections being open, even if we are using only one.
  prefs: []
  type: TYPE_NORMAL
- en: The problem that arises if we call `delete` multiple times on the same pointer
    is that all the calls after the first one will access memory they should not be
    accessing.
  prefs: []
  type: TYPE_NORMAL
- en: The result can range from our program crashing to deleting other resources our
    program is currently using, resulting in incorrect behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now see why it is extremely important to define a virtual destructor
    in the base class if we derive from it: we need to make sure that the destructor
    of the runtime type is called when calling the `delete` function on the base object.
    If we call `delete` on a pointer to the base class while the runtime type is the
    derived class, we will only call the destructor of the base class and not fully
    destruct the derived class.'
  prefs: []
  type: TYPE_NORMAL
- en: Making the destructor of the base class virtual will ensure that we are going
    to call the derived destructor, since we are using dynamic dispatch when calling
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For every call to the `new` operator, there must be exactly one call to `delete`
    with the pointer returned by `new`!
  prefs: []
  type: TYPE_NORMAL
- en: This error is extremely common and leads to many errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like single objects, we can also use dynamic memory to create arrays of objects.
    For such use cases, we can use the `new[]` and `delete[]` expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `new[]` expression will create enough space for `n Car` instances and will
    initialize them, returning a pointer to the first element created. Here, we are
    not providing the arguments to the constructor, so the class must have a default
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: With `new[]`, we can specify how many elements we want it to initialize. This
    is different from `std::array` and the built-in array we saw earlier because `n`
    can be decided at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We need to call `delete[]` on the pointer returned by `new[]` when we do not
    need the objects anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For every call to `new[]`, there must be exactly one call to `delete[]` with
    the pointer returned by `new[]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `new` operator and `new[]` function calls, and `delete` and `delete[]` function
    calls, cannot be intermixed. Always pair the ones for an array or the ones for
    single elements!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to use dynamic memory, we can write the function to
    create our logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function will call the new expression in its body to create an instance
    of the correct class, and it will then return a pointer to the base class so that
    the code calling it does not need to know about the type of logger created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to note in this function:'
  prefs: []
  type: TYPE_NORMAL
- en: Even if we wrote the `new` expression twice, `new` will be called only once
    per function call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This shows us that it is not enough to make sure we type `new` and `delete`
    an equal number of times; we need to understand how our code is executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is no call to `delete`! This means that the code calling the `createLogger`
    function needs to make sure to call `delete`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From these two points, we can can see why it is error prone to manage memory
    manually, and why it should be avoided whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of how to call the function correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If `myOperation` does not call `delete` on the logger, this is a *correct* use
    of dynamic memory. Dynamic memory is a powerful tool, but doing it manually is
    risky, error prone, and easy to get wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, modern C++ provides some facilities to make all this much easier
    to do. It is possible to write entire programs without ever using `new` and `delete`
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Safe and Easy Dynamic Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned how dynamic memory could be useful when
    working with interfaces, especially when creating new instances of derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how working with dynamic memory can be hard – we need to make sure
    to call new and delete in pairs, and failing to do so always has negative effects
    on our program. Fortunately for us, since C++11, there are tools in the standard
    library to help us overcome such limitations – **smart pointers**.
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers are types that behave like pointers, which are called **raw pointers**
    in this context, but have additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look at two smart pointers from the standard library: `std::unique_ptr`
    and `std::shared_ptr` (read as `delete` appropriately.'
  prefs: []
  type: TYPE_NORMAL
- en: They represent different ownership models. The owner of an object is the code
    that determines the lifetime of the object – the part of the code that decides
    when to create and when to destroy the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, ownership is associated with the scope a function or method, since
    the lifetime of automatic variables is controlled by it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the scope of `foo()` owns the `number` object, and it will make
    sure it is destroyed when the scope exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, classes might own objects when they are declared as value types
    between the data members of the class. In that case, the lifetime of the object
    will be the same as the lifetime of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`number` will be constructed when the `A` class is constructed and will be
    destroyed when the `A` class is destroyed. This is automatically done because
    the field `number` is embedded inside the class and the constructor and destructor
    of the class will automatically initialize `number`.'
  prefs: []
  type: TYPE_NORMAL
- en: When managing objects in dynamic memory, ownership is not enforced by the compiler
    anymore, but it is helpful to apply the concept of ownership to the dynamic memory
    as well – the owner is who decides when to delete the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function could be the owner of an object when the object is allocated with
    the new call inside the function, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a class might own it, by calling `new` in the constructor and storing the
    pointer in its fields, and calling `delete` on it in the destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: But the ownership of dynamic objects can also be passed around.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at an example earlier with the `createLogger` function. The function
    creates an instance of **Logger** and then passes the ownership to the parent
    scope. Now, the parent scope is in charge of making sure the object is valid until
    it is accessed in the program and deleted afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers allow us to specify the ownership in the type of the pointer
    and make sure it is respected so that we do not have to keep track of it manually
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Always use smart pointers to represent the ownership of objects.
  prefs: []
  type: TYPE_NORMAL
- en: In a code base, smart pointers should be the pointers that control the lifetime
    of objects, and raw pointers, or regular pointers, are used only to reference
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: A Single Owner Using std::unique_ptr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`unique_ptr` is the pointer type that''s used by default. The unique pointer
    points to an object that has a single owner; there is a single place in the program
    that decides when to delete the object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is the logger from before: there is a single place in the program
    that determines when to delete the object. Since we want the logger to be available
    as long as the program is running, to always be able to log information, we will
    destroy the logger only at the end of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The unique pointer guarantees the uniqueness of ownership: the unique pointer
    cannot be copied. This means that once we have created a unique pointer for an
    object, there can be only one.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when the unique pointer is destroyed, it deletes the object it
    owns. This way, we have a concrete object that tells us the ownership of the created
    object, and we do not have to manually make sure that only one place is calling
    `delete` for the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A unique pointer is a template that can take one argument: the *type of the
    object*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite the previous example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'While this code would compile, we would not be respecting the guideline we
    mentioned previously regarding always using smart pointers for ownership: `createLogger`
    returns a raw pointer, but it passes ownership to the parent scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update the signature of `createLogger` to return a smart pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, the signature expresses our intention, and we can update the implementation
    to make use of smart pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, with the use of smart pointers, code bases should
    not use `new` and `delete` anywhere. This is possible because the standard library,
    since C++14, offers a convenient function: `std::make_unique. make_unique` is
    a template function that takes the type of the object to create, and creates it
    in dynamic memory, passing its arguments to the object''s constructor and returning
    a unique pointer to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three important points regarding this function:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no longer a new expression in the body; it has been replaced with `make_unique`.
    The `make_unique` function is simple to call because we can provide all the arguments
    we would pass to the constructor of the type and have it created automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are creating a `unique_ptr` to a derived class, but we are returning a `unique_ptr`
    to a base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indeed, `unique_ptr` emulates the ability of raw pointers to convert pointers
    to derived classes to pointers to base classes. This makes using `unique_ptr`
    as simple as using **raw pointers**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are using the move on the `unique_ptr`. As we said earlier, we cannot copy
    `unique_ptr`, but we are returning from a function, so we must use a value; otherwise,
    a reference would become invalid after the function returns, as we saw in *Chapter
    2*, *Functions*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it cannot be copied, `unique_ptr` can be moved. When we move `unique_ptr`,
    we are transferring the ownership of the object to which it points to the recipient
    of the value. In this case, we are returning value, so we are transferring the
    ownership to the caller of the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now see how we can rewrite the class that owns the number we showed
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the fact that `unique_ptr` deletes the object automatically when it
    is destroyed, we did not have to write the destructor for the class, making our
    code even easier.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to pass a pointer to the object, without transferring ownership,
    we can use the `get()` method on the raw pointer. Remember that raw pointers should
    not be used for ownership, and code accepting the raw pointer should never call
    `delete` on it.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to these features, `unique_ptr` should be the default choice to keep
    track of the ownership of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Shared Ownership Using std::shared_ptr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`shared_ptr` represents an object that has multiple owners: one out of several
    objects will delete the owned object.'
  prefs: []
  type: TYPE_NORMAL
- en: An example could make a TCP connection, which is established by multiple threads
    to send data. Each thread uses the TCP connection to send data and then terminates.
  prefs: []
  type: TYPE_NORMAL
- en: We want to delete the TCP connection when the last thread has finished executing,
    but it is not always the same thread that terminates last; it could be any of
    the threads.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if we are modeling a graph of connected nodes, we might want
    to delete a node when every connection to it is removed from the graph. `unique_ptr`
    does not solve these cases, since there is not a single owner for the object.
  prefs: []
  type: TYPE_NORMAL
- en: '`shared_ptr` can be used in such situations: `shared_ptr` can be copied many
    times, and the object pointed to by the pointer will remain alive until the last
    `shared_ptr` is destroyed. We guarantee that the object remains valid as long
    as there is at least one `shared_ptr` instance pointing to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example making use of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we are holding many `shared_ptr` instance to nodes. If
    we have a `shared_ptr` instance to a node, we want to be sure that the node exists,
    but when we remove the shared pointer, we do not care about the node anymore:
    it might be deleted, or it might be kept alive if there is another node connected
    to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the `unique_ptr` counterpart, when we want to create a new node,
    we can use the `std::make_shared` function, which takes the type of the object
    to construct as the template argument and the arguments to pass to the constructor
    of the object and returns `shared_ptr` to the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that there might be a problem in the example we showed: what
    happens if node `A` is connected to node `B` and node `B` is connected to node
    `A`?'
  prefs: []
  type: TYPE_NORMAL
- en: Both nodes have a `shared_ptr` instance to the other, and even if no other node
    has a connection to them, they will remain alive because a `shared_ptr` instance
    to them exists. This is an example of circular dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using shared pointers, we must pay attention to these cases. The standard
    library offers a different kind of pointer to handle these situations: `std::weak_ptr`
    (read as **weak pointer**).'
  prefs: []
  type: TYPE_NORMAL
- en: '`weak_ptr` is a smart pointer that can be used in conjunction with `shared_ptr`
    to solve the circular dependencies that might happen in our programs.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, `shared_ptr` is enough to model most cases where `unique_ptr` does
    not work, and together they cover the majority of the uses of dynamic memory in
    a code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we are not helpless if we want to use dynamic memory for arrays of
    which we know the size only at runtime. `unique_ptr` can be used with array types,
    and `shared_ptr` can be used with array types starting from C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 26: Creating a Factory for UserProfileStorage'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our code needs to create new instances of the `UserProfileStorage` interface
    we wrote during *Activity 25: Retrieving User Information*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a new `UserProfileStorageFactory` class. Now create a new `create` method
    which returns a `UserProfileStorage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `UserProfileStorageFactory` class, return `unique_ptr` so that it manages
    the lifetime of the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the `main` function, call the `UserProfileStorageFactory` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found at page 313.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 27: Using a Database Connection for Multiple Operations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our online store, after a user has paid for a purchase, we want to update
    their order list so that it is displayed on their profile. At the same time, we
    also need to schedule the processing of the order.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we need to update the records in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t want to wait for one operation to perform the other, so we process
    the updates in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a `DatabaseConnection` class that can be used in parallel. We want
    to reuse this as much as possible, and we know we can use `std::async` to start
    a new parallel task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assuming that there are two functions, `updateOrderList(DatabaseConnection&)`
    and `scheduleOrderProcessing(DatabaseConnection&)`, write two functions, `updateWithConnection()`
    and `scheduleWithConnection()` which take a shared pointer to `DatabaseConnection`
    and call the respective function defined above:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use `shared_ptr` and keep a copy of `shared_ptr` in order to make sure that
    the connection remains valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s write the `main` function, where we create a shared pointer to the
    connection and then we call `std::async` with the two functions we defined above,
    as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found at page 314.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we saw how inheritance can be used to combine classes in C++.
    We saw what a base class is and what a derived class is, how to write a class
    that derives from another, and how to control the visibility modifier. We talked
    about how to initialize a base class in a derived one by calling the base class
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We then explained polymorphism and the ability of C++ to dynamically bind a
    pointer or reference of a derived class to a pointer or reference of the base
    class. We explained what dispatch for functions is, how it works statically by
    default, and how we can make it dynamic with the use of the virtual keyword. Following
    that, we explored how to properly write virtual functions and how we can override
    them, making sure to mark such overrode functions with the `override` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we showed how to define interfaces with abstract base classes and how
    to use pure virtual methods. We also provided guidelines on how to correctly define
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we delved into dynamic memory and what problems it solves, but we also
    saw how easy it is to use it incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We concluded the chapter by showing how modern C++ makes using dynamic memory
    painless by providing smart pointers that handle complex details for us: `unique_ptr`
    to manage objects with a single owner, and `shared_ptr` for objects owned by multiple
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: All these tools can be effective at writing solid programs that can be effectively
    evolved and maintained, while retaining the performance C++ is famous for.
  prefs: []
  type: TYPE_NORMAL
