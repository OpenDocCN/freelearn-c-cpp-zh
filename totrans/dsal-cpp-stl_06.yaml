- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Advanced Sequence Container Usage
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级序列容器使用
- en: Sequence containers are at the core of C++ data handling, providing structures
    to hold data linearly. For intermediate developers, making the right choice from
    an array of sequence containers including vectors, arrays, deques, and lists can
    be pivotal. This chapter breaks down each container type, emphasizing their distinct
    advantages and ideal use cases. Furthermore, diving into best practices—from efficient
    resizing to iterator management—will ensure developers choose the right container
    and utilize it effectively. Grasping these nuances elevates code efficiency, readability,
    and maintainability in real-world applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 序列容器是C++数据处理的核心，提供线性存储数据的结构。对于中级开发者来说，从包括向量、数组、deque和列表在内的序列容器数组中选择正确的选项可能是至关重要的。本章将详细分析每种容器类型，强调它们的独特优势和理想使用场景。此外，深入了解最佳实践——从高效的调整大小到迭代器管理——将确保开发者选择正确的容器并有效地使用它。掌握这些细微差别将提高代码在实际应用中的效率、可读性和可维护性。
- en: In the sprawling expanse of the C++ **Standard Template Library** (**STL**),
    sequence containers hold a position of prominence. Not just because they’re often
    the first choice of data structures for developers but also because of the unique
    and versatile solutions each offers. These containers, as their name implies,
    maintain elements sequentially. But as we dive deeper, you’ll find that the similarities
    often end there. Each sequence container brings its strengths and is tailored
    for particular scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在庞大的C++ **标准模板库**（**STL**）中，序列容器占据着显赫的位置。这不仅是因为它们通常是开发者首选的数据结构，也因为每个容器提供的独特和多功能解决方案。正如其名称所暗示的，这些容器按顺序维护元素。但当我们深入了解时，我们会发现相似之处通常到此为止。每个序列容器都带来其优势，并针对特定场景进行定制。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: '`std::array`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array`'
- en: '`std::vector`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`'
- en: '`std::deque`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque`'
- en: '`std::list`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list`'
- en: '`std::forward_list`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list`'
- en: '`std::string`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string`'
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: std::array
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::array
- en: '`std::array` is a fixed-size container that wraps around a traditional C-style
    array. If you’re coming from a C background or even early C++, you’ll be familiar
    with the headaches of raw arrays—the lack of bounds-checking, the cumbersome syntax,
    and more. With `std::array`, you get all the benefits of a traditional array,
    such as static memory allocation and constant-time access, while enjoying modern
    C++ amenities including range-based for-loops and member functions for size checking.
    Use `std::array` when you know the size of your dataset in advance, and it will
    not change. It’s perfect for scenarios where performance is paramount and your
    memory needs are static.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array`是一个固定大小的容器，它围绕传统的C风格数组。如果你来自C背景，甚至早期的C++，你将熟悉原始数组的烦恼——缺乏边界检查、繁琐的语法等等。使用`std::array`，你可以获得传统数组的所有好处，如静态内存分配和常数时间访问，同时享受现代C++的便利，包括基于范围的for循环和用于大小检查的成员函数。当你事先知道数据集的大小且不会改变时，使用`std::array`是完美的。在性能至关重要且内存需求静态的场景中，它非常适用。'
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on CPP core guidelines, please refer to *C++ Core* *Guidelines*
    [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C++核心指南的更多信息，请参阅*C++核心* *指南* [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)
- en: Purpose and suitability
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::array` is a container that encapsulates fixed-size arrays. Its strengths
    are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array`是一个封装固定大小数组的容器。其优势如下：'
- en: Predictable, fixed size
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可预测的固定大小
- en: Stack allocation, offering swift access and minimal overhead
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈分配，提供快速访问和最小开销
- en: 'It’s best to choose `std::array` in the following situations:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，最好选择`std::array`：
- en: The array size is known at compile-time.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的长度在编译时已知。
- en: Overhead minimization and performance predictability are crucial.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化开销和性能可预测性至关重要。
- en: For dynamic sizing needs, consider `std::vector` instead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态大小需求，请考虑使用`std::vector`。
- en: Ideal use cases
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想使用场景
- en: 'The following are some of the ideal use cases of `std::array`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::array`的理想使用场景：
- en: '`std::array` is the go-to choice. This makes it apt for situations where dimension
    sizes are predefined, such as in certain mathematical operations or game board
    representations.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array`是首选选择。这使得它在维度大小预定义的情况下非常适合，例如在某些数学运算或游戏板表示中。'
- en: '`std::array` does not involve dynamic memory allocations, which can benefit
    real-time or performance-critical applications.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array`不涉及动态内存分配，这可以有利于实时或性能关键的应用。'
- en: '`std::array` offers bounds-checking (with the `at()` member function), providing
    a safer alternative to C-style arrays, especially when dealing with potential
    out-of-bounds access.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array`提供了边界检查（通过`at()`成员函数），提供了比C风格数组更安全的替代方案，尤其是在处理潜在的越界访问时。'
- en: '`std::array`, size information is retained, making writing safer and more intuitive
    functions easier.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array`保留了大小信息，这使得编写更安全、更直观的函数变得更容易。'
- en: '`std::array` can seamlessly be used with C-style arrays, making it a great
    choice for projects with C and C++ integrations.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array`可以无缝地与C风格数组一起使用，使其成为具有C和C++集成的项目的绝佳选择。'
- en: '`std::array` is the best choice.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array`是最佳选择。'
- en: '`std::vector`, `std::array` offers contiguous memory storage, making it cache-friendly
    for iterations.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`和`std::array`提供连续的内存存储，这使得它们在迭代时对缓存友好。'
- en: '`std::array` ensures no surprise memory allocations.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array`确保没有意外的内存分配。'
- en: '`std::array` provides convenient initialization semantics.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array`提供了方便的初始化语义。'
- en: However, while `std::array` offers several advantages over traditional arrays,
    it is essential to note that it doesn’t fit situations where dynamic resizing
    is necessary. For those use cases, one might consider `std::vector` or other dynamic
    containers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管`std::array`在传统数组之上提供了几个优势，但必须注意，它并不适合需要动态调整大小的场景。对于这些用例，可以考虑`std::vector`或其他动态容器。
- en: Performance
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::array` is characterized as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array`的算法性能如下所述：'
- en: '**Insertion**: Not applicable since the size is fixed'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：由于大小固定，不适用'
- en: '**Deletion**: Not applicable'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：不适用'
- en: '**Access**: A constant *O(1)* for any position'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：任何位置的常数*O(1)*'
- en: '**Memory overhead**: Minimal, given stack allocation'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：由于栈分配，最小化。'
- en: '**Trade-off**: Fixed-size efficiency is at the cost of static sizing'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权衡**：固定大小的效率是以静态大小为代价的。'
- en: Memory management
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: Unlike `std::vector`, `std::array` doesn’t dynamically allocate memory. It is
    stack allocated, so there are no unexpected allocation behaviors or surprises.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::vector`不同，`std::array`不会动态分配内存。它是栈分配的，因此没有意外的分配行为或惊喜。
- en: Thread safety
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Are you reading from multiple threads? Perfectly fine. However, writing concurrently
    to the same element demands synchronization.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否在多线程中读取？完全可以。然而，并发写入同一元素需要同步。
- en: Extensions and variants
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: For dynamic needs, `std::vector` serves as the STL’s prime alternative. Other
    fixed-size array options include the plain old C-style arrays.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态需求，`std::vector`是STL的主要替代方案。其他固定大小数组选项包括传统的C风格数组。
- en: Sorting and searching complexity
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: '`std::sort()`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort()`'
- en: '`std::binary_search()`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::binary_search()`'
- en: Interface and member functions
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和成员函数
- en: 'Standard functions such as `begin()`, `end()`, and `size()` are present. Noteworthy
    member functions are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 存在标准函数，如`begin()`、`end()`和`size()`。值得注意的成员函数如下：
- en: '`fill`: Sets all elements to a value'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`：将所有元素设置为某个值'
- en: '`swap`: Swaps contents with another array of the same type and size'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap`：与相同类型和大小的另一个数组交换内容'
- en: Comparisons
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: Compared to `std::vector`, `std::array` does not resize but offers predictable
    performance. When choosing, weigh the need for dynamic sizing against performance
    consistency.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::vector`相比，`std::array`不进行大小调整，但提供可预测的性能。在做出选择时，权衡动态大小需求与性能一致性。
- en: Interactions with algorithms
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: STL algorithms play nicely with `std::array` due to random-access capabilities.
    However, those expecting dynamic sizing won’t work with `std::array`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法由于随机访问能力而很好地与`std::array`协同工作。然而，那些期望动态大小的将无法与`std::array`一起工作。
- en: Exceptions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: With `std::array`, out-of-bounds access (such as using `at()`) can throw exceptions,
    primarily `std::out_of_range`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::array`时，越界访问（如使用`at()`）可以抛出异常，主要是`std::out_of_range`。
- en: Customization
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: While you cannot resize, you can integrate custom types. Given the container’s
    stack-allocation nature, ensure they’re efficiently movable/copyable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不能调整大小，但可以集成自定义类型。鉴于容器栈分配的特性，确保它们高效可移动/可复制。
- en: Example
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'In this example, we will show the following best practices and use of `std::array`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将展示以下最佳实践和 `std::array` 的使用：
- en: Using `std::array` with a fixed size
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用固定大小的 `std::array`
- en: Using C++ structured bindings with `std::array` to destructure elements
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++ 结构化绑定与 `std::array` 解构元素
- en: Implementing compile-time calculations with `std::array` (thanks to its constexpr
    nature)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::array` 实现编译时计算（归功于其 constexpr 特性）
- en: Using algorithms such as `std::sort` and `std::find` with `std::array`
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::sort` 和 `std::find` 等算法与 `std::array`
- en: Structured bindings
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定
- en: Structured bindings, introduced in C++17, allow for the convenient and readable
    unpacking of elements from tuples, pairs, or struct-like objects into separate
    named variables. This syntax simplifies accessing multiple elements returned from
    a function or decomposing the contents of complex data structures, enhancing code
    clarity and reducing verbosity.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 中引入的结构化绑定，允许方便且易于阅读地从元组、对或类似结构体对象中解包元素到单独命名的变量中。这种语法简化了访问从函数返回的多个元素或分解复杂数据结构的内容，增强了代码的清晰度并减少了冗余。
- en: 'Here is the code example discussing the above points:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是讨论上述观点的代码示例：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example highlights the features and advantages of `std::array`, including
    its fixed-size nature, compatibility with modern C++ features like structured
    bindings, and its utility in compile-time computations. The preceding example
    also illustrates how STL algorithms can be seamlessly applied to `std::array`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例突出了 `std::array` 的特性和优势，包括其固定大小特性、与结构化绑定等现代 C++ 功能的兼容性，以及在编译时计算中的实用性。前面的示例还说明了如何无缝地将
    STL 算法应用于 `std::array`。
- en: Best practices
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using std::array:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用 `std::array` 的最佳实践：
- en: '`std::array` encapsulates the predictability of C-style arrays, enriching them
    with added utility. Its fixed size is particularly useful for situations with
    predetermined data sizes, making it a prime choice for such applications.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array` 封装了 C 风格数组的可预测性，并为其增加了额外的功能。其固定大小在数据大小已确定的情况下特别有用，使其成为此类应用的优选。'
- en: '`std::array` comes with a suite of member functions, elevating its capabilities.
    This makes it a compelling choice in contemporary C++ development over its traditional
    counterpart.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array` 提供了一系列成员函数，提高了其功能。这使得它在当代 C++ 开发中相对于其传统对应物更具吸引力。'
- en: '`.at()` member function is invaluable. It guards against out-of-bound accesses
    by throwing exceptions when boundaries are crossed.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.at()` 成员函数非常有价值。它通过在越界时抛出异常来防止越界访问。'
- en: '`std::array` is both its strength and limitation. It promises constant time
    access but lacks flexibility in resizing. Therefore, it is essential to be precise
    about the desired size during its declaration to prevent potential issues.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array` 既是其优势也是其限制。它承诺常数时间访问，但在调整大小方面缺乏灵活性。因此，在声明时精确指定所需的大小对于防止潜在问题至关重要。'
- en: '`std::array`, adopting this loop structure minimizes the chances of boundary
    errors, promoting code stability.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array` 采用这种循环结构最小化了边界错误的概率，促进了代码的稳定性。'
- en: '`std::array` can house diverse types, considering efficiency is pivotal. If
    the type, be it primitive or user-defined, is particularly large or intricate,
    ensure its move or copy operations are optimized to preserve performance during
    array operations.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array` 可以容纳多种类型，考虑到效率至关重要。如果类型，无论是原始类型还是用户定义类型，特别大或复杂，确保其移动或复制操作已优化，以在数组操作期间保持性能。'
- en: '`std::array` excels in scenarios that demand a fixed-size container. However,
    for applications where dynamic resizing or extensive data is anticipated, alternatives
    such as `std::vector` may offer a more adaptive solution.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array` 在需要固定大小容器的场景中表现出色。然而，对于预期动态调整大小或大量数据的适用，`std::vector` 等替代方案可能提供更灵活的解决方案。'
- en: std::vector
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::vector`'
- en: '`std::vector` is a dynamic array. It grows and shrinks as needed, offering
    an excellent balance between direct access performance and flexibility in size.
    `std::vector` has a cache-friendly contiguous memory layout and amortized constant-time
    insertions at the end, making it an excellent general-purpose container. It performs
    best when your primary operations are indexing and require dynamic resizing but
    without frequent insertions or deletions in the middle.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 是一个动态数组。它根据需要增长和缩小，在直接访问性能和大小灵活性之间提供了良好的平衡。`std::vector` 具有缓存友好的连续内存布局，在末尾提供摊销常数时间的插入，使其成为一个优秀的通用容器。当你的主要操作是索引和需要动态调整大小，但中间没有频繁的插入或删除时，性能最佳。'
- en: Purpose and suitability
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::vector` is essentially a dynamic array within the STL. Its primary strength
    lies in the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 在 STL 中本质上是一个动态数组。它的主要优势在于以下方面：'
- en: Offering constant-time random access
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供常数时间的随机访问
- en: Dynamically resizing as elements are inserted or removed
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素插入或删除时动态调整大小
- en: 'It’s particularly suitable when the following is required:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下要求时，它尤其适合：
- en: Random access is paramount.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机访问至关重要。
- en: Insertions or deletions are primarily at the end of the sequence.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入或删除主要在序列的末尾进行。
- en: Cache locality is essential.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存局部性至关重要。
- en: Opt for `std::vector` when constant-time access, performance, or cache friendliness
    trump other concerns.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当常数时间访问、性能或缓存友好性比其他关注点更重要时，选择 `std::vector`。
- en: Ideal use cases
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases of `std::vector`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::vector` 的理想用例：
- en: '`std::vector` is your best choice. Unlike standard arrays, vectors automatically
    manage their size and handle memory allocation/deallocation seamlessly.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 是你的最佳选择。与标准数组不同，向量会自动管理其大小并无缝处理内存分配/释放。'
- en: '`std::vector` offers constant-time access to any elements, making it suitable
    for frequently accessing or modifying data at specific indices.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 提供了对任何元素的常数时间访问，使其适合频繁访问或修改特定索引的数据。'
- en: '`std::vector` provides a contiguous block of memory that’s appropriate for
    this.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 提供了适合此目的的连续内存块。'
- en: '`std::vector` is optimized for insertions at its end, it is a good choice for
    applications such as log systems, where new entries are continuously added.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 对其末尾的插入进行了优化，因此对于日志系统等新条目持续添加的应用程序来说是一个不错的选择。'
- en: '`std::vector` provides one of the most memory-efficient ways to store data
    because of its continuous memory block and lack of structural overhead, unlike
    linked-list-based containers.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其连续内存块和缺乏结构开销，`std::vector` 提供了存储数据最内存高效的方式，与基于链表的容器不同。
- en: '`std::vector` is cache-friendly, leading to faster performance in many scenarios
    compared to non-contiguous data structures.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 是缓存友好的，与不连续的数据结构相比，在许多场景中性能更快。'
- en: '`std::vector` can be easily streamed or written.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 可以轻松地进行流式传输或写入。'
- en: '`std::stack` for this purpose, `std::vector` can effectively implement a stack
    data structure where elements are added or removed only from the back.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实现这个目的，`std::vector` 可以有效地实现一个栈数据结构，其中元素只从末尾添加或删除。
- en: '`std::vector` provides an efficient and dynamic container for this.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 为此提供了一个高效且动态的容器。'
- en: However, there are a few caveats when using `std::vector`. If frequent insertions
    or deletions are needed in the middle, `std::vector` might not be the most efficient
    choice due to the need to shift elements. Also, if you’re pushing elements frequently,
    using `reserve()` to preallocate memory and avoid frequent reallocations is a
    good practice.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用 `std::vector` 时有一些注意事项。如果需要在中间频繁插入或删除，由于需要移动元素，`std::vector` 可能不是最有效率的选项。另外，如果你经常推送元素，使用
    `reserve()` 预分配内存并避免频繁重新分配是一个好习惯。
- en: Performance
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::vector` is characterized as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 的算法性能特点如下：'
- en: '**Insertion:** *O(1)* average-case for the end, *O(n)* for elsewhere'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入：** 末尾的平均情况为 *O(1)*，其他位置为 *O(n)*'
- en: '**Deletion:** *O(1)* at the end, *O(n)* for the middle'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除：** 末尾为 *O(1)*，中间为 *O(n)*'
- en: '**Access:** A swift *O(1)* for any position'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问：** 任何位置的快速 *O(1)*'
- en: '**Memory overhead:** Typically low, but can inflate if reserved capacity isn’t
    managed'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销：** 通常较低，但如果未管理预留容量，可能会膨胀'
- en: '**Trade-offs:** The convenience of *O(1)* access is counterbalanced by potential
    *O(n)* costs for insertion at the start or middle.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权衡：** *O(1)* 访问的便利性被在开始或中间插入的潜在 *O(n)* 成本所抵消。'
- en: Memory management
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::vector` automatically manages its memory. If its capacity is exhausted,
    it typically doubles its size, though this isn’t strictly mandated. Allocators
    can influence this behavior, permitting fine-grained control.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 自动管理其内存。如果其容量耗尽，它通常会将其大小加倍，尽管这并不是强制性的。分配器可以影响这种行为，允许细粒度控制。'
- en: Thread safety
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Concurrent reads? No problem. But writes, or a mix of reads and writes, demand
    external synchronization. Consider mutexes or other concurrency tools.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 并发读取？没问题。但是写入，或者读取和写入的混合，需要外部同步。考虑互斥锁或其他并发工具。
- en: Extensions and variants
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: While `std::vector` is a dynamic array, the STL offers other sequence containers
    such as `std::deque` that provide an API for fast insertions at both ends or `std::list`,
    possibly optimizing middle insertions and deletions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `std::vector` 是一个动态数组，但 STL 提供了其他序列容器，如 `std::deque`，它提供了在两端快速插入的 API 或 `std::list`，可能优化中间插入和删除。
- en: Sorting and searching complexity
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'The sorting and search complexity is characterized as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度如下所述：
- en: '`std::sort()`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort()`'
- en: '`std::binary_search()`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::binary_search()`'
- en: Special interface and member functions
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Beyond the regulars (`push_back`, `pop_back`, `begin`, and `end`), acquaint
    yourself with the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规操作（如 `push_back`、`pop_back`、`begin` 和 `end`）之外，熟悉以下内容：
- en: '`emplace_back`: Constructs elements directly'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace_back`: 直接构造元素'
- en: '`resize`: Changes the number of elements'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize`: 改变元素数量'
- en: '`shrink_to_fit`: Reduces memory usage'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shrink_to_fit`: 减少内存使用'
- en: Comparisons
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: Against `std::list` and `std::deque`, `std::vector` excels at random access,
    but may falter with frequent middle modifications of very large data types.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::list` 和 `std::deque` 相比，`std::vector` 在随机访问方面表现出色，但在频繁修改非常大的数据类型的中间部分时可能会失败。
- en: Interactions with algorithms
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Many STL algorithms harmonize beautifully with `std::vector` due to its random-access
    nature. Algorithms requiring frequent reordering, however, might be better paired
    with other containers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 STL 算法与 `std::vector` 的随机访问特性非常和谐。然而，需要频繁重新排序的算法可能更适合与其他容器搭配。
- en: Exceptions
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Pushing beyond capacity or accessing out-of-bounds indices can throw exceptions.
    Notably, operations are exception-safe, preserving vector states even if operations
    (like insertions) throw exceptions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 超出容量或访问越界索引可能会抛出异常。值得注意的是，操作是异常安全的，即使在操作（如插入）抛出异常的情况下，也能保留向量的状态。
- en: Customization
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: With custom allocators, tweak memory allocation strategies. However, `std::vector`
    does not naturally support custom comparators or hash functions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义分配器时，调整内存分配策略。然而，`std::vector` 并不支持自定义比较器或哈希函数。
- en: Example
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'In this example, we will show the following best-practices and use of `std::vector`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将展示以下最佳实践和 `std::vector` 的使用：
- en: Preallocating memory with reserve
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `reserve` 预分配内存
- en: Using `emplace_back` for efficient insertion
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `emplace_back` 进行高效插入
- en: Using iterators for traversal and modification
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器进行遍历和修改
- en: Employing `std::vector` with custom objects
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义对象与 `std::vector` 结合
- en: Using algorithms such as `std::remove` with `std::vector`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::remove` 等算法与 `std::vector` 结合
- en: 'Here is the code example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码示例：
- en: '[PRE1]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding example demonstrates the efficiency and flexibility of `std::vector`
    combined with C++ STL algorithms. It showcases managing and manipulating a list
    of `Employee` objects in various ways.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了 `std::vector` 与 C++ STL 算法结合的效率和灵活性。它展示了以各种方式管理和操作 `Employee` 对象列表。
- en: Now, let us look at a `std::vector<bool>` example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个 `std::vector<bool>` 的示例。
- en: '`std::vector<bool>` is a somewhat controversial specialization in the C++ Standard
    Library. It was designed to use only one bit per boolean value, thereby saving
    space. However, this space optimization has led to several unexpected behaviors
    and quirks, especially compared to `std::vector` for other types.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector<bool>` 是 C++ 标准库中的一个有些争议的特殊化。它被设计为每个布尔值只使用一个比特位，从而节省空间。然而，这种空间优化导致了几个意想不到的行为和怪癖，尤其是在与其他类型的
    `std::vector` 相比时。'
- en: 'For those reasons, many experts advise caution when using `std::vector<bool>`.
    Nevertheless, if one still wishes to utilize it, here’s a canonical example illustrating
    its use and some of its quirks:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，许多专家建议在使用 `std::vector<bool>` 时要谨慎。尽管如此，如果仍然希望使用它，以下是一个展示其使用和一些怪癖的典型示例：
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The key takeaways from the preceding code are as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的关键要点如下：
- en: '`std::vector<bool>` offers memory savings by storing booleans as individual
    bits.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector<bool>` 通过将布尔值存储为单独的位来节省内存。'
- en: When accessing an element from `std::vector<bool>`, you don’t get a normal reference
    as you do with other vector types. Instead, you get a proxy object. This is why
    modifying `ref` in the example doesn’t change the actual value in the vector.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从 `std::vector<bool>` 访问元素时，你不会得到与其他向量类型相同的普通引用。相反，你得到一个代理对象。这就是为什么在示例中修改 `ref`
    并不会改变向量中的实际值。
- en: Other operations, such as iteration, resizing, and capacity checks, work similarly
    to other `std::vector` types.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他操作，如迭代、调整大小和容量检查，与其他 `std::vector` 类型的工作方式类似。
- en: For many applications, the peculiarities of `std::vector<bool>` might outweigh
    its memory-saving benefits. If the memory optimization isn’t crucial and the behavior
    quirks can be problematic, consider using alternative containers such as `std::deque<bool>`,
    `std::bitset`, or a third-party bitset/vector library.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用，`std::vector<bool>` 的特殊性可能超过其内存节省的好处。如果内存优化不是至关重要的，并且行为上的怪癖可能成为问题，请考虑使用其他容器，如
    `std::deque<bool>`、`std::bitset` 或第三方位集/向量库。
- en: Best practices
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using `std::vector`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用 `std::vector` 的最佳实践：
- en: '`std::vector<bool>` isn’t just a simple vector of boolean values. It’s specialized
    to save space, and this space efficiency comes at a cost: elements aren’t real
    bools but bitfield proxies. This specialization can lead to unique behavior in
    certain operations, making it vital to understand its intricacies fully.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector<bool>` 不仅仅是一个简单的布尔值向量。它被专门化以节省空间，这种空间效率是以牺牲为代价的：元素不是真正的布尔值，而是位字段代理。这种专门化可能导致某些操作中独特的表现，因此完全理解其复杂性至关重要。'
- en: '`std::vector` is its ability to resize dynamically. While this is powerful,
    predicting and guiding this resizing with the `reserve` function can be beneficial.
    Preallocating memory helps in minimizing reallocations and ensures efficient performance.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 的动态调整大小能力。虽然这很强大，但使用 `reserve` 函数预测和引导这种调整可能会有所帮助。预分配内存有助于最小化重新分配，并确保高效性能。'
- en: '`push_back` is a frequently used method to add elements, `emplace_back` provides
    a more efficient way to construct objects directly in the vector. Constructing
    objects in place can often enhance performance, especially with complex objects.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push_back` 是一个常用的方法来添加元素，`emplace_back` 提供了一种更高效的方法直接在向量中构造对象。就地构造对象通常可以增强性能，尤其是在复杂对象中。'
- en: '`std::vector` provides excellent random access performance. However, operations
    in the middle, such as insertions or deletions, can be more time-consuming due
    to the need to move subsequent elements. For tasks that require frequent middle
    operations, it is worthwhile to consider alternative STL containers.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 提供了优秀的随机访问性能。然而，由于需要移动后续元素，中间的操作，如插入或删除，可能会更加耗时。对于需要频繁中间操作的任务，考虑替代的
    STL 容器是值得的。'
- en: '`.at()` member function, on the other hand, provides bounds-checked access
    and will throw a `std::out_of_range` exception if an invalid index is used.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.at()` 成员函数另一方面，提供带边界检查的访问，如果使用无效索引，将抛出 `std::out_of_range` 异常。'
- en: '`std::vector`. While `std::vector` isn’t inherently thread-safe, you can achieve
    thread safety with appropriate synchronization tools such as mutexes.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`。虽然 `std::vector` 本身不是线程安全的，但可以使用适当的同步工具，如互斥锁，来实现线程安全。'
- en: '`std::vector` isn’t optimized for frequent middle insertions or deletions.
    That said, its cache-friendliness and ability to quickly search may still mean
    it is the best data type to use. Using it as a linked list can be suboptimal,
    but only for specific use cases (perhaps very large data types or very large datasets.)
    For such patterns, containers like `std::list` may be better suited. Never assume,
    however, that a `std::list` will perform better just because you require frequent
    insertions and deletions.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 并未针对频繁的中间插入或删除进行优化。然而，其缓存友好性和快速搜索的能力可能仍然意味着它是最佳的数据类型。将其用作链表可能不是最优的，但仅适用于特定的用例（可能是非常大的数据类型或非常大的数据集）。对于这种模式，容器如
    `std::list` 可能更适合。然而，永远不要假设 `std::list` 仅因为需要频繁的插入和删除就会表现更好。'
- en: '`std::map`, where vectors might be values, don’t fall into the trap of assuming
    automatic updates. It’s essential to manage and update these nested containers
    explicitly.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`，其中向量可能是值，不要陷入自动更新的陷阱。显式管理和更新这些嵌套容器是至关重要的。'
- en: std::deque
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::deque`'
- en: '`std::deque` is a double-ended queue. On the surface, it looks like `std::vector`
    with better insertions and deletions at both the beginning and the end. While
    that’s true, remember that this flexibility comes at the cost of a slightly more
    complex internal structure. If your application requires rapid insertions and
    deletions at both ends but does not need the tight memory layout of `std::vector`,
    `std::deque` is your container of choice.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque` 是一个双端队列。表面上，它看起来像 `std::vector`，在两端进行插入和删除操作更好。虽然这是真的，但请记住，这种灵活性是以略微复杂的内部结构为代价的。如果你的应用程序需要在两端进行快速插入和删除，但不需要
    `std::vector` 的紧凑内存布局，那么 `std::deque` 就是你的首选容器。'
- en: Purpose and suitability
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::deque` is a container that provides rapid insertions and deletions at
    both its beginning and end. Its primary strengths are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque` 是一个提供快速在两端进行插入和删除操作的容器。其主要优势如下：'
- en: Efficient *O(1)* insertions and deletions at both ends
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两端高效的 *O(1)* 插入和删除
- en: Dynamic size with no need for manual memory management
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态大小，无需手动内存管理
- en: Fairly good cache performance for front and back operations
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端和后端操作具有相当好的缓存性能
- en: '`std::deque` shines in the following contexts:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque` 在以下方面表现出色：'
- en: You require random-access capabilities but expect frequent modifications at
    both ends.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要随机访问能力，但预计两端将频繁修改。
- en: You need a dynamically sized container but do not want the memory overhead of
    a `std::list`.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个动态大小的容器，但不想有 `std::list` 的内存开销。
- en: If only end modifications are necessary, `std::vector` could be a better choice.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要端修改，`std::vector` 可能是一个更好的选择。
- en: Ideal use cases
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases of `std::deque`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::deque` 的理想用例：
- en: '`std::vector`, which primarily allows for fast insertion at the back, `std::deque`
    supports quick insertion and deletion at both the front and the back, making it
    ideal for scenarios requiring operations on both ends.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 主要允许在末尾快速插入，而 `std::deque` 支持在两端快速插入和删除，使其非常适合需要两端操作的场景。'
- en: '`std::deque` can serve as a queue (FIFO data structure) and a stack (LIFO data
    structure). It’s versatile in this regard, unlike other containers specializing
    in one or the other.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque` 可以作为队列（FIFO 数据结构）和栈（LIFO 数据结构）。在这方面，它非常灵活，不像其他专注于一个或另一个的容器。'
- en: '`std::vector`, `std::deque` offers constant-time random access to elements,
    making it suitable for applications that need to access elements by index.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 和 `std::deque` 提供了对元素的常数时间随机访问，这使得它们适合需要通过索引访问元素的应用程序。'
- en: '`std::vector` grows in one direction, `std::deque` can grow in both directions.
    This makes it especially useful for situations where the dataset might expand
    unpredictably on both ends.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 只向一个方向增长，而 `std::deque` 可以向两个方向增长。这使得它在数据集可能在两端不可预测地扩展的情况下特别有用。'
- en: '`std::deque` can be helpful. As data is consumed from the front (played), new
    data can be buffered at the back without reshuffling the entire dataset.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque` 可以在从前端（播放）消耗数据时有所帮助。新的数据可以在后端缓冲，而无需重新整理整个数据集。'
- en: '`std::deque` offers an efficient solution.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque` 提供了一个高效的解决方案。'
- en: '`std::deque` can easily be adapted into other custom data structures. For example,
    a balanced tree or a specific kind of priority queue might leverage the capabilities
    of `std::deque`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque` 可以轻松地适应其他自定义数据结构。例如，一个平衡树或特定类型的优先队列可能会利用 `std::deque` 的功能。'
- en: '`std::deque` can efficiently handle adding new actions and automatically removing
    the oldest ones.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque` 可以有效地处理添加新操作和自动删除最旧的项。'
- en: When considering `std::deque`, it is essential to weigh the benefits of its
    double-ended and random-access nature against its slightly higher per-element
    overhead compared to `std::vector`. Other data structures might be more space-efficient
    in scenarios with only one-sided growth.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 `std::deque` 时，必须权衡其双端和随机访问特性的好处与相对于 `std::vector` 的略高每元素开销。在其他只有单侧增长的场景中，其他数据结构可能更节省空间。
- en: Performance
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::deque` is characterized as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque` 的算法性能如下：'
- en: '**Insertion:** *O(1)* for both front and back; *O(n)* in the middle'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入：** 前端和后端都是 *O(1)*；中间是 *O(n)*'
- en: '**Deletion:** *O(1)* for both front and back; *O(n)* for the middle'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除：** 前端和后端都是 *O(1)*；中间是 *O(n)*'
- en: '**Access:** Consistent *O(1)* for random access'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问：** 随机访问保持一致的 *O(1)*'
- en: '`std::vector` due to segmented memory'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于分段内存，`std::vector`
- en: Memory management
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::deque` uses segmented allocation, which means it allocates chunks of
    memory as needed. Unlike `std::vector`, it doesn’t double its size; thus, there
    is no excessive memory overhead. Custom allocators can affect memory allocation
    strategies.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque` 使用分段分配，这意味着它根据需要分配内存块。与 `std::vector` 不同，它不会加倍其大小；因此，没有过度的内存开销。自定义分配器可以影响内存分配策略。'
- en: Thread safety
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Concurrent reads are safe. But like most STL containers, simultaneous writes
    or a mix of reads and writes require external synchronization mechanisms, such
    as mutexes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 并发读取是安全的。但像大多数 STL 容器一样，同时写入或读写混合需要外部同步机制，如互斥锁。
- en: Extensions and variants
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::deque` stands between `std::vector` and `std::list` in terms of performance
    and memory characteristics. However, it uniquely offers fast operations at both
    ends.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能和内存特性方面，`std::deque` 位于 `std::vector` 和 `std::list` 之间。然而，它独特地提供了两端快速操作。
- en: Sorting and searching complexity
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索的复杂度
- en: 'The sorting and search complexity is characterized as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索的复杂度如下：
- en: '`std::sort()`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort()`'
- en: '`std::binary_search()`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::binary_search()`'
- en: Interface and member functions
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和成员函数
- en: 'Apart from the familiar (`push_back`, `push_front`, `pop_back`, `pop_front`,
    `begin`, and `end`), get familiar with the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了熟悉的（`push_back`、`push_front`、`pop_back`、`pop_front`、`begin` 和 `end`）之外，熟悉以下内容：
- en: '`emplace_front` and `emplace_back`: In-place construction at respective ends'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace_front` 和 `emplace_back`：在各自的端进行就地构造'
- en: '`resize`: Adjust the container size, extending or truncating it as needed'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize`：调整容器大小，根据需要扩展或截断'
- en: Comparisons
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: Compared to `std::vector`, `std::deque` provides better front operations. Against
    `std::list`, it gives better random access but may suffer in terms of middle insertions/deletions.
    The non-contiguous storage of `std::deque` can be a disadvantage when it comes
    to iterating over elements compared to `std::vector` due to poorer cache performance.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::vector` 相比，`std::deque` 提供了更好的前端操作。与 `std::list` 相比，它提供了更好的随机访问，但在中间插入/删除方面可能表现不佳。与
    `std::vector` 相比，`std::deque` 的非连续存储可能在迭代元素时成为劣势，因为缓存性能较差。
- en: Interactions with algorithms
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: '`std::deque` can leverage most STL algorithms effectively due to its random-access
    nature. Algorithms requiring swift end modifications are particularly suited for
    `std::deque`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::deque` 的随机访问特性，它可以有效地利用大多数 STL 算法。特别适合 `std::deque` 的算法是那些需要快速端修改的算法。
- en: Exceptions
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Going beyond size or accessing out-of-range indices can lead to exceptions.
    If operations such as insertions throw exceptions, the container remains intact,
    ensuring exception safety.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 超出大小或访问越界索引可能导致异常。如果插入等操作抛出异常，容器保持完整，确保异常安全。
- en: Customization
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: '`std::deque` can be used with custom allocators to tailor memory allocation
    behavior, but it does not support custom comparators or hash functions.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque` 可以与自定义分配器一起使用，以定制内存分配行为，但它不支持自定义比较器或哈希函数。'
- en: Example
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'In this example, we will show the following best practices and use of `std::deque`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将展示以下最佳实践和 `std::deque` 的使用：
- en: Using `std::deque` to maintain a list of elements, taking advantage of its dynamic
    size
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::deque` 维护元素列表，利用其动态大小
- en: Inserting elements at both the front and back
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前后两端插入元素
- en: Efficient removal of elements from both the front and back
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从前后两端高效移除元素
- en: Using `std::deque` as a sliding window to process elements in chunks
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::deque` 作为滑动窗口以分块处理元素
- en: Applying STL algorithms such as `std::transform`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用 STL 算法，如 `std::transform`
- en: 'Here is the code example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码示例：
- en: '[PRE3]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, we do the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们执行以下操作：
- en: We demonstrate the dynamic nature of `std::deque` by adding elements to both
    the beginning and end of the container.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过向容器的开始和结束添加元素来展示 `std::deque` 的动态特性。
- en: We showcase the efficient operations of `pop_front()` and `pop_back()`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了 `pop_front()` 和 `pop_back()` 的有效操作。
- en: A sliding window function processes the elements in chunks, taking advantage
    of the random access nature of `std::deque`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动窗口函数以分块处理元素，利用 `std::deque` 的随机访问特性。
- en: Finally, we use the `std::transform` algorithm to manipulate the data.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `std::transform` 算法来操作数据。
- en: Best practices
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using `std::deque`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用 `std::deque` 的最佳实践：
- en: '`std::deque` is its segmented memory. This can sometimes lead to performance
    nuances that are less predictable compared to the contiguous memory layout of
    `std::vector`.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque`是其分段内存。这有时会导致与`std::vector`的连续内存布局相比，性能差异更难以预测的细微差别。'
- en: '`std::deque` with `std::vector` when it comes to memory behavior. The two have
    different architectures, leading to varied performances in specific scenarios.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及到内存行为时，`std::deque`与`std::vector`。这两个有不同的架构，导致在特定场景中性能各异。
- en: '`std::deque` provides quick insertions and deletions at both ends but not in
    the middle. If middle operations are measured to be a bottleneck, consider other
    containers such as `std::vector` and `std::list`.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque`在两端提供快速的插入和删除操作，但在中间不行。如果中间操作被认为是瓶颈，考虑其他容器，如`std::vector`和`std::list`。'
- en: '`std::deque` for its core strength: constant-time operations at both ends.
    Should you predominantly use only one end, `std::vector` could offer better performance.
    Even with this advantage, do not assume that `std::deque` will perform better
    than `std::vector`. You may find that `std::vector`’s contiguous storage and cache-friendliness
    allow it to outperform `std::deque` even with front insertions.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque`的核心优势在于两端都提供常数时间操作。如果你主要只使用一端，`std::vector`可能提供更好的性能。即使有这个优势，也不要假设`std::deque`的性能会优于`std::vector`。你可能发现，`std::vector`的连续存储和缓存友好性甚至允许它在头部插入时超越`std::deque`。'
- en: '`std::deque` doesn’t guarantee contiguous memory, it can pose challenges when
    dealing with APIs or libraries that demand raw arrays. Always be aware of this
    distinction.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque`不保证连续内存，当处理需要原始数组的API或库时可能会带来挑战。始终要意识到这种区别。'
- en: '`emplace_front` and `emplace_back` when adding elements. These functions construct
    elements directly within the deque, optimizing memory usage and performance.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加元素时使用`emplace_front`和`emplace_back`。这些函数直接在deque中构建元素，优化内存使用和性能。
- en: '`std::deque` when the front and back operations are frequent and the measured
    performance loss is acceptable. Its architecture is optimized for these operations,
    providing consistent performance.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前端和后端操作频繁且可接受的性能损失时，`std::deque`是合适的。其架构针对这些操作进行了优化，提供一致的性能。
- en: '`std::deque`, always ensure you’re within its size boundaries to prevent undefined
    behavior.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque`，始终确保你处于其大小边界内，以防止未定义的行为。'
- en: '`std::deque`, make sure to use appropriate synchronization mechanisms, such
    as mutexes or locks, to ensure data integrity and prevent race conditions.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque`，确保使用适当的同步机制，如互斥锁或锁，以确保数据完整性和防止竞态条件。'
- en: std::list
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::list
- en: '`std::list` is a doubly linked list. Unlike the previous containers, it does
    not store its elements contiguously. This means you lose out on the cache-friendliness
    but gain immense flexibility. Insertions and deletions, regardless of position,
    are a constant-time operation as long as you have an iterator to the position.
    However, access time is linear, making it less suited for tasks where random access
    is frequent. `std::list` is best suited for scenarios where the dataset experiences
    frequent insertions and deletions from both the middle and the ends, and direct
    access isn’t a priority.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::list`是一个双向链表。与之前的容器不同，它不连续存储其元素。这意味着你失去了缓存友好性，但获得了巨大的灵活性。只要你有指向位置的迭代器，无论位置如何，插入和删除操作都是常数时间操作。然而，访问时间是线性的，这使得它不太适合频繁进行随机访问的任务。`std::list`最适合那些数据集频繁在中间和两端进行插入和删除操作，且直接访问不是优先级的场景。'
- en: Purpose and suitability
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::list` is a doubly-linked list provided by the STL. Its strengths include
    the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::list`是STL提供的双向链表。其优势包括以下：'
- en: Facilitating constant-time insertions and deletions at any position (while sacrificing
    cache friendliness and fast searching)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何位置实现常数时间插入和删除（虽然牺牲了缓存友好性和快速搜索）
- en: Preserving iterator validity during modifications (except when the element referred
    to by the iterator is removed)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在修改期间保持迭代器有效性（除非迭代器引用的元素被删除）
- en: 'It’s best chosen in the following situations:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，它是最合适的选择：
- en: Frequent insertions and deletions from both the container’s front and middle
    are expected.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期会频繁地从容器的头部和中间进行插入和删除操作。
- en: Random access isn’t a primary requirement.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机访问不是主要要求。
- en: Iterator validity preservation is vital.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器有效性保持至关重要。
- en: You have inherently cache-unfriendly (large) data stored in each node.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点中存储的（大）数据本身就不利于缓存。
- en: When considering between different containers, lean towards `std::list` for
    its linked-list benefits. If random access is vital, `std::vector` or `std::deque`
    may be better choices.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑不同容器时，倾向于使用 `std::list` 以获得链表的优点。如果随机访问至关重要，`std::vector` 或 `std::deque`
    可能是更好的选择。
- en: Ideal use cases
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases of `std::list`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::list` 的理想用例：
- en: '`std::forward_list`, `std::list` provides bidirectional traversal capabilities,
    allowing you to iterate through the elements both forward and backward, which
    is beneficial for certain algorithms.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 和 `std::list` 提供双向遍历能力，允许你向前和向后迭代元素，这对某些算法是有益的。'
- en: '`std::list` offers constant time insertions and deletions at any position,
    provided you have an iterator to the position. This makes it suitable for applications
    where such operations are frequent. Note, however, that the cost of searching
    for the position to perform the insertion may outweigh the benefits of the insertion
    operation itself. Often, `std::vector` will outperform `std::list` even for frequent
    insertions and deletions.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有要插入的位置的迭代器，`std::list` 提供任何位置的常数时间插入和删除。这使得它适合于这种操作频繁的应用程序。然而，需要注意的是，搜索插入位置的成本可能会超过插入操作本身的收益。通常，即使对于频繁的插入和删除，`std::vector`
    也可能优于 `std::list`。
- en: '`std::list` can be a good choice.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list` 可以是一个好的选择。'
- en: '`std::list` proves efficient due to its splicing capabilities.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list` 由于其拼接能力而证明是高效的。'
- en: '`std::queue` is the standard choice, `std::list` can be employed to implement
    double-ended queues (deque) because of its bidirectional nature.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::queue` 是标准选择，`std::list` 可以因其双向特性被用来实现双端队列（deque）。'
- en: '`std::list` apt for maintaining an undo and redo history in software applications.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list` 适合在软件应用程序中维护撤销和重做历史。'
- en: '`std::list` is often a good choice due to its efficiency in moving elements
    around.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在元素间移动的高效性，`std::list` 常常是一个好的选择。
- en: '`std::list` can be adapted to create circular lists where the last element
    links back to the first.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list` 可以调整以创建循环列表，其中最后一个元素链接回第一个。'
- en: '`std::list` can be used.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `std::list`。
- en: While `std::list` is versatile, one should be cautious of its limitations. It
    doesn’t support direct access or indexing, unlike arrays or `std::vector`. Therefore,
    it is crucial to choose `std::list` when its specific strengths align well with
    the application’s requirements. It is also cache-unfriendly and expensive to perform
    a linear search on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `std::list` 多功能，但应谨慎其局限性。它不支持直接访问或索引，与数组或 `std::vector` 不同。因此，当其特定优势与应用程序的需求很好地匹配时，选择
    `std::list` 是至关重要的。它也不利于缓存，并且线性搜索的成本较高。
- en: Performance
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::list` is characterized as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::list` 的算法性能如下：'
- en: '**Insertion**: *O(1)* anywhere in the list.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：在任何位置的时间复杂度为 *O(1)*。'
- en: '**Deletion**: *O(1)* for a known position.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：对于已知位置的时间复杂度为 *O(1)*。'
- en: '**Access**: *O(n)* due to its linked nature.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问时间**：由于其链式结构，为 *O(n)*。'
- en: '**Memory overhead**: Generally higher than vector due to storage of next and
    previous pointers.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：通常高于向量，因为存储了下一个和上一个指针。'
- en: '`std::vector` will outperform `std::list` for most use cases.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数用例，`std::vector` 将优于 `std::list`。
- en: Memory management
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: Unlike `std::vector`, `std::list` does not reallocate en masse. Each element’s
    allocation is independent. Allocators can still influence individual node allocation,
    granting more specific memory management.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::vector` 不同，`std::list` 不会大量重新分配。每个元素的分配是独立的。分配器仍然可以影响单个节点的分配，从而提供更具体的内存管理。
- en: Thread safety
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Concurrent reads are safe. However, modifications, or simultaneous reads and
    writes, require external synchronization. Mutexes or similar constructs can be
    employed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 并发读取是安全的。然而，修改或同时读取和写入需要外部同步。可以使用互斥锁或类似的结构。
- en: Extensions and variants
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::forward_list` is a singly-linked variant, optimizing for space but losing
    the ability to traverse backward.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list` 是单链表的变体，优化了空间但失去了向后遍历的能力。'
- en: Sorting and searching complexity
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'The sorting and search complexity is characterized as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索的复杂度如下：
- en: '`std::list::sort()`, typically *O(n* *log n)*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list::sort()`，通常为 *O(n log n)*'
- en: '`std::find()` due to lack of random access'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于缺乏随机访问，`std::find()`
- en: Interface and member functions
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和成员函数
- en: 'Noteworthy functions are as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的函数如下：
- en: '`emplace_front`/`emplace_back`: Direct in-place construction'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace_front`/`emplace_back`：直接就地构造'
- en: '`splice`: Transfers elements from one list to another'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splice`：将元素从一个列表转移到另一个列表'
- en: '`merge`: Combines two sorted lists'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge`：合并两个排序后的列表'
- en: '`unique`: Removes duplicate elements'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique`：删除重复元素'
- en: Comparisons
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: When juxtaposed with `std::vector` or `std::deque`, `std::list` seems like it
    would be superior for frequent insertions and deletions in the middle. However,
    it does not offer the speedy random access the former containers do. This means
    that the cost of finding where to perform an insertion or deletion outweighs the
    benefits of the insertion or deletion itself.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`std::vector`或`std::deque`相比时，`std::list`似乎在频繁的中部插入和删除方面更优越。然而，它并不提供前者容器那样的快速随机访问。这意味着找到执行插入或删除的位置的成本超过了插入或删除本身的利益。
- en: Interactions with algorithms
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: While `std::list` can work with many STL algorithms, those requiring random
    access (e.g., `std::random_shuffle`) aren’t ideal.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`std::list`可以与许多STL算法一起工作，但那些需要随机访问的（例如，`std::random_shuffle`）并不理想。
- en: Exceptions
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Out-of-bounds or illegal operations might throw exceptions. However, many of
    `std::list`’s operations offer strong exception safety, ensuring the list remains
    consistent.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 越界或非法操作可能会抛出异常。然而，`std::list`的许多操作提供了强大的异常安全性，确保列表保持一致性。
- en: Customization
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: Custom allocators can be employed to influence the node memory allocation. Unlike
    containers such as `std::set` or `std::map`, custom comparators aren’t typical
    with `std::list`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用自定义分配器来影响节点内存分配。与`std::set`或`std::map`等容器不同，自定义比较器在`std::list`中并不常见。
- en: Example
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'In this example, we will show the following best practices and use of `std::list`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将展示以下最佳实践和`std::list`的使用：
- en: Exploiting the bidirectional nature of `std::list` to traverse and modify elements
    in both forward and reverse directions
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`std::list`的双向特性来遍历和修改元素，无论是正向还是反向方向
- en: Efficiently inserting and removing elements from anywhere in the list
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表的任何位置高效地插入和删除元素
- en: Using `std::list`’s member functions such as `sort()`, `merge()`, `splice()`,
    and `remove_if()`
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::list`的成员函数，如`sort()`、`merge()`、`splice()`和`remove_if()`
- en: Applying external STL algorithms like `std::find`
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用外部STL算法，如`std::find`
- en: 'Here is the code example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码示例：
- en: '[PRE4]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we do the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将执行以下操作：
- en: We traverse the `std::list` in reverse using reverse iterators.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用反向迭代器反向遍历`std::list`。
- en: We showcase the ability to efficiently insert elements at a desired position.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了在期望位置高效插入元素的能力。
- en: We demonstrate the use of `std::list`-specific operations such as `sort()`,
    `merge()`, and `splice()`.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了使用`std::list`特定操作，如`sort()`、`merge()`和`splice()`的用法。
- en: Finally, we use a lambda with `remove_if()` to conditionally remove elements
    from the list.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用lambda与`remove_if()`条件性地从列表中删除元素。
- en: This example illustrates various capabilities of `std::list`, including operations
    that are especially efficient with this container and ones that use its bidirectional
    nature.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了`std::list`的各种功能，包括特别高效的容器操作和使用其双向特性的操作。
- en: Best practices
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore some best practices for using `std::list`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用`std::list`的一些最佳实践：
- en: '`std::list` unless you have profiled your code against a data type such as
    `std::vector` and found a measurable performance improvement.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有针对数据类型如`std::vector`进行性能分析并发现可测量的性能改进之前，不要使用`std::list`。
- en: '`sort()` member function provided by `std::list` itself is essential rather
    than resorting to `std::sort`. This is due to c requiring random access iterators,
    which `std::list` doesn’t support.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list`本身提供的`sort()`成员函数是必不可少的，而不是求助于`std::sort`。这是因为C需要随机访问迭代器，而`std::list`不支持。'
- en: '`std::list` doesn’t offer *O(1)* random access due to its doubly-linked structure.
    For frequent random access, containers such as `std::vector` or `std::deque` may
    be more suitable.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`std::list`的双链结构，它不提供*O(1)*随机访问。对于频繁的随机访问，容器如`std::vector`或`std::deque`可能更合适。
- en: '`std::list` means it maintains two pointers per element. This enables backward
    and forward traversal but does come at a memory cost. If memory usage is critical
    and bidirectional traversal isn’t required, `std::forward_list` offers a cleaner
    alternative.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list`意味着它为每个元素维护两个指针。这使它能够进行双向遍历，但这也带来了内存成本。如果内存使用至关重要且不需要双向遍历，`std::forward_list`提供了一个更干净的替代方案。'
- en: '`std::list` can transform operations from *O(n)* to *O(1)*. Harness the power
    of iterators for more efficient insertions and deletions.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list` 可以将操作从 *O(n)* 转换为 *O(1)*。利用迭代器的力量进行更有效的插入和删除。'
- en: '`std::list` offers the unique ability to transfer elements between lists in
    constant time using the `splice` function. This operation is both efficient and
    can simplify list manipulations.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list` 提供了使用 `splice` 函数在常数时间内在不同列表之间传输元素的独特能力。这个操作既高效又可简化列表操作。'
- en: '`emplace_front` and `emplace_back`, you can construct elements in place, eliminating
    the need for temporary objects and potentially speeding up your code.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace_front` 和 `emplace_back`，你可以在原地构建元素，从而消除对临时对象的需求，并可能加快你的代码。'
- en: '`std::list`. Especially in memory-sensitive scenarios, being aware of this
    overhead can be critical in making informed container choices.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list`。特别是在内存敏感的场景中，了解这种开销对于做出明智的容器选择至关重要。'
- en: std::forward_list
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::forward_list
- en: '`std::forward_list` is a singly linked list. It’s similar to `std::list`, but
    each element points only to the next element and not the previous. This reduces
    memory overhead compared to `std::list` but at the cost of bidirectional iteration.
    Choose `std::forward_list` when you require a list structure but don’t need to
    traverse backward and wish to save on memory overhead.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list` 是一个单链表。它与 `std::list` 类似，但每个元素只指向下一个元素，而不是前一个。这比 `std::list`
    减少了内存开销，但以双向迭代为代价。当你需要一个列表结构但不需要向后遍历且希望节省内存开销时，选择 `std::forward_list`。'
- en: Purpose and suitability
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: 'The `std::forward_list` is a singly linked list container in the STL. Its primary
    appeal lies in the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list` 是 STL 中的一个单链表容器。它的主要吸引力在于以下方面：'
- en: Efficient insertions and deletions at any location in the list
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表的任何位置进行高效的插入和删除
- en: Consuming less memory than `std::list` since it doesn’t store previous pointers
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比使用 `std::list` 消耗更少的内存，因为它不存储前一个指针
- en: 'It’s especially fitting in the following contexts:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 它在以下情况下特别适用：
- en: You require constant-time insertions or deletions irrespective of the position.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要无论位置如何都能进行常数时间的插入或删除。
- en: Memory overhead is a concern.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存开销是一个需要关注的问题。
- en: Bidirectional iteration is not needed.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要双向迭代。
- en: While `std::vector` excels in random access, turn to `std::forward_list` if
    you value insertion and deletion efficiency above all.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `std::vector` 在随机访问方面表现出色，但如果你更重视插入和删除效率，则转向 `std::forward_list`。
- en: Ideal use cases
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases of `std::forward_list`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::forward_list` 的理想用例：
- en: '`std::forward_list` uses a singly-linked list, which has less overhead than
    doubly-linked lists since it only has to maintain a link in one direction. This
    makes it suitable for scenarios where space conservation is a priority.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 使用单链表，由于它只需要维护一个方向上的链接，所以比双链表的开销更小。这使得它在空间节约是首要考虑的场景中非常适用。'
- en: '`std::forward_list` offers optimal efficiency.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 提供了最优效率。'
- en: '`std::forward_list` can be a fitting choice.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 可以是一个合适的选择。'
- en: '`using std::forward_list` ensures one-directional movement.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using std::forward_list` 确保单向移动。'
- en: '`std::forward_list` can be employed to design stack-like behavior.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 可以用来设计类似栈的行为。'
- en: '`std::forward_list` can store these edges.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 可以存储这些边。'
- en: '`std::forward_list` provides the necessary structure.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 提供了必要的结构。'
- en: '`std::forward_list`.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list`.'
- en: It’s essential to understand that while `std::forward_list` offers advantages
    in specific use cases, it lacks some functionalities other containers offer, such
    as the bidirectional traversal seen in `std::list`. Choosing `std::forward_list`
    is appropriate when its benefits align with the application’s needs.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，虽然 `std::forward_list` 在特定用例中提供了优势，但它缺乏其他容器提供的某些功能，例如在 `std::list` 中看到的双向遍历。当其优势与应用程序的需求相匹配时，选择
    `std::forward_list` 是合适的。
- en: Performance
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::forward_list` is characterized as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list` 的算法性能如下：'
- en: '**Insertion**: *O(1)* irrespective of the position.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：无论位置如何都是 *O(1)*。'
- en: '**Deletion**: *O(1)* for any spot.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：任何位置都是 *O(1)*。'
- en: '**Access**: *O(n)* since sequential access is the only option.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：*O(n)*，因为只有顺序访问是唯一的选择。'
- en: '**Memory overhead**: Minimal, as only the next pointers are stored.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：最小化，因为只存储了下一个指针。'
- en: '`std::list`, is usually outweighed by its cache unfriendliness and slow search
    performance compared to `std::vector`. Generally, `std::vector` will outperform
    `std::forward_list` for most use cases.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list`通常由于其缓存不友好和与`std::vector`相比的慢速搜索性能而不足。一般来说，`std::vector`在大多数用例中会比`std::forward_list`表现更好。'
- en: Memory management
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: Memory is allocated as and when an element is inserted. Each node stores the
    element and a pointer to the next node. Custom allocators can adjust this allocation
    strategy.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 元素插入时分配内存。每个节点存储元素和指向下一个节点的指针。自定义分配器可以调整这种分配策略。
- en: Thread safety
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Concurrent reads are safe. However, writes or a combination of reads and writes
    require external synchronization.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 并发读取是安全的。然而，写入或读取和写入的组合需要外部同步。
- en: Extensions and variants
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: For those desiring bidirectional iteration capabilities, `std::list` (a doubly-linked
    list) is a viable alternative.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对于希望获得双向迭代能力的人来说，`std::list`（一个双链表）是一个可行的替代方案。
- en: Sorting and searching complexity
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'The sorting and search complexity is characterized as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索的复杂度如下：
- en: '`std::sort()`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort()`'
- en: '**Searching**: *O(n)* since there’s no random access'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：*O(n)*，因为没有随机访问'
- en: Special interface and member functions
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Noteworthy member functions are as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的成员函数如下：
- en: '`emplace_front`: For direct element construction'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace_front`：用于直接构造元素'
- en: '`remove`: To get rid of elements by value'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`：通过值移除元素'
- en: '`splice_after:` For transferring elements from another `std::forward_list`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splice_after:` 用于从另一个`std::forward_list`转移元素'
- en: Remember, there’s no `size()` or `push_back()` function in `std::forward_list`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`std::forward_list`中没有`size()`或`push_back()`函数。
- en: Comparisons
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: Against `std::list`, `std::forward_list` uses less memory but doesn’t support
    bidirectional iteration. Compared to `std::vector`, it doesn’t allow random access
    but ensures consistent insertion and deletion times.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::list`相比，`std::forward_list`使用更少的内存，但不支持双向迭代。与`std::vector`相比，它不允许随机访问，但确保了一致的插入和删除时间。
- en: Interactions with algorithms
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Given its forward-only nature, `std::forward_list` might not gel with algorithms
    needing bidirectional or random access iterators.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其单向性质，`std::forward_list`可能不适合需要双向或随机访问迭代器的算法。
- en: Exceptions
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Exceptions can arise during memory allocation failures. Most operations on `std::forward_list`
    offer strong exception safety guarantees.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存分配失败期间可能会出现异常。大多数对`std::forward_list`的操作都提供强大的异常安全保证。
- en: Customization
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: You can adjust the memory allocation strategy using custom allocators. `std::forward_list`
    doesn’t inherently support custom comparators or hash functions.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用自定义分配器调整内存分配策略。`std::forward_list`本身不支持自定义比较器或哈希函数。
- en: Example
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::forward_list` is a singly-linked list, which is particularly efficient
    at insertions/deletions from the front. It consumes less memory than `std::list`
    because it doesn’t store backward pointers for each element.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list`是一个单链表，在从前端进行插入/删除操作时特别高效。它比`std::list`消耗更少的内存，因为它不存储每个元素的向后指针。'
- en: 'One common use case for a `std::forward_list` is implementing a hash table
    with chaining to resolve collisions. Here’s a basic version of a chained hash
    table using `std::forward_list`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list`的一个常见用途是实现具有链表的哈希表以解决冲突。以下是一个使用`std::forward_list`的基本链式哈希表版本：'
- en: '[PRE5]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we do the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们做以下操作：
- en: The hash table consists of a `std::vector` of `std::forward_list` called table.
    Each slot in the vector corresponds to a hash value and potentially holds multiple
    keys (in a `forward_list`) that collide with that hash value.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表由一个名为`table`的`std::vector`组成，其中包含`std::forward_list`。向量的每个槽位对应一个哈希值，并且可能包含多个与该哈希值冲突的键（在一个`forward_list`中）。
- en: The `emplace_front` function of `forward_list` is particularly useful in this
    context because we can add new key-value pairs to the front of the list in constant
    time.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个上下文中，`forward_list`的`emplace_front`函数特别有用，因为我们可以在常数时间内向列表的前端添加新的键值对。
- en: We use `forward_list::remove_if` for removing a key-value pair, which scans
    through the list and removes the first matching key.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`forward_list::remove_if`来移除键值对，它遍历列表并移除第一个匹配的键。
- en: Best practices
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using `std::forward_list`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用`std::forward_list`的最佳实践：
- en: '`std::forward_list` unless you have profiled your code against a data type
    such as `std::vector` and found a measurable performance improvement.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有对代码与 `std::vector` 等数据类型进行性能分析并发现可测量的性能改进之前，不要使用 `std::forward_list`。
- en: '`std::forward_list` is a specialized container optimized for certain scenarios
    in the world of singly linked lists. Understanding its strengths and limitations
    is crucial to use it effectively.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 是一个针对单链表世界中的特定场景进行优化的专用容器。理解其优势和局限性对于有效地使用它至关重要。'
- en: '`std::forward_list` is a solid choice. However, it lacks fast direct access
    to elements, requiring an *O(n)* operation.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 是一个不错的选择。然而，它缺乏对元素的快速直接访问，需要 *O(n)* 操作。'
- en: '`std::forward_list` supports only forward iteration. If bidirectional traversal
    is necessary, consider other containers such as `std::list`.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 仅支持正向迭代。如果需要双向遍历，请考虑其他容器，例如 `std::list`。'
- en: '**No random access**: This container is unsuitable for scenarios where quick
    random access to elements is required.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无随机访问**：此容器不适用于需要快速随机访问元素的场景。'
- en: '`size()` member function means that determining the list’s size requires an
    *O(n)* operation. For a quick check on whether the list is empty, utilize the
    `empty()` function, which is efficient.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()` 成员函数意味着确定列表的大小需要 *O(n)* 操作。为了快速检查列表是否为空，请使用 `empty()` 函数，它效率很高。'
- en: '`std::forward_list` offers efficient insertions and deletions. Specifically,
    `emplace_front` is useful for in-place element construction, reducing overhead.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list` 提供高效的插入和删除。特别是，`emplace_front` 对于就地元素构造非常有用，可以减少开销。'
- en: '`sort()` function to maintain element order. To remove consecutive duplicate
    elements, apply the `unique()` function.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sort()` 函数来维护元素顺序。要移除连续的重复元素，请应用 `unique()` 函数。
- en: '**Cautions with iterators**: It’s imperative to recheck iterator validity after
    modifications, especially post insertions or deletions, as they may become invalidated.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对迭代器的注意事项**：在修改后，尤其是插入或删除后，务必重新检查迭代器的有效性，因为它们可能会失效。'
- en: '`std::forward_list` in multi-threaded applications to prevent data races or
    inconsistencies.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多线程应用程序中使用 `std::forward_list` 以防止数据竞争或不一致性。
- en: '`std::list`, the `std::forward_list` often uses less memory because it maintains
    only one pointer per element (forward pointer), making it a more memory-efficient
    choice when bidirectional iteration is not required.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list`，由于 `std::forward_list` 只维护每个元素一个指针（前向指针），因此它在使用双向迭代不是必需时，是一个更节省内存的选择。'
- en: std::string
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::string`'
- en: Within the STL, `std::string` is a class designed to manage sequences of characters.
    `std::string` simplifies text handling by providing a range of string manipulation
    and analysis features. `std::string` is not classified under the *sequence containers*
    category in the formal C++ Standard Library documentation, though it behaves very
    much like one. Instead, it is categorized under a separate *Strings* category,
    recognizing its general container-like behavior and its specialized nature for
    text handling.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在 STL 中，`std::string` 是一个用于管理字符序列的类。`std::string` 通过提供一系列字符串操作和分析功能简化了文本处理。尽管在正式的
    C++ 标准库文档中，`std::string` 并未被归类为 *序列容器* 类别，尽管它的行为非常像。相反，它被归类为单独的 *字符串* 类别，以认可其通用的容器行为和其在文本处理方面的专用性质。
- en: Purpose and suitability
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::string` represents a dynamic sequence of characters and is essentially
    a specialization of `std::vector<char>`. It is designed for the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string` 代表一个动态的字符序列，本质上是对 `std::vector<char>` 的特殊化。它被设计用于以下目的：'
- en: Manipulating textual data
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作文本数据
- en: Interacting with functions that expect string input or produce string output
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与期望字符串输入或产生字符串输出的函数交互
- en: 'It’s particularly suitable in the following contexts:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 它在以下情况下尤其适用：
- en: Dynamic text modification is frequent.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态文本修改频繁。
- en: Efficient access to individual characters is desired.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希望能够高效地访问单个字符。
- en: Choose `std::string` for most string manipulation tasks. If you require string
    views without ownership, consider `std::string_view`.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数字符串操作任务，请选择 `std::string`。如果您需要无所有权的字符串视图，请考虑 `std::string_view`。
- en: Ideal use cases
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases of `std::string`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::string` 的理想用例：
- en: '**Text processing**: Parsing files, processing logs, or any other task requiring
    dynamic text manipulation'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本处理**：解析文件、处理日志或任何需要动态文本操作的其它任务'
- en: '**User input/output**: Accepting user inputs; producing human-readable output'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户输入/输出**: 接受用户输入；生成人类可读的输出'
- en: '**Data serialization**: Encoding data as a string for transport/storage'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据序列化**: 将数据编码为字符串以进行传输/存储'
- en: Performance
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::string` is characterized as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`的算法性能如下所述：'
- en: '**Insertion**: *O(1)* average for the end, *O(n)* for elsewhere'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**: 平均 *O(1)* 在末尾，其他地方为 *O(n)*'
- en: '**Deletion**: *O(n)* since elements might need shifting'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**: 由于元素可能需要移动，因此 *O(n)*'
- en: '**Access**: A rapid *O(1)* for any position'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**: 任何位置的快速 *O(1)*'
- en: '**Memory overhead**: Generally low but can grow if reserved capacity isn’t
    used'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**: 通常较低，但如果未使用预留容量，则可能会增长'
- en: Memory management
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::string` dynamically allocates memory. When the buffer is filled, it reallocates,
    often doubling its size. Custom allocators can modify this behavior.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`动态分配内存。当缓冲区填满时，它会重新分配，通常加倍其大小。自定义分配器可以修改此行为。'
- en: Thread safety
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Concurrent reading is safe, but simultaneous modifications require synchronization,
    typically using mutexes.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 并发读取是安全的，但同时修改需要同步，通常使用互斥锁（mutexes）。
- en: Extensions and variants
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::wstring` is a wide-character version useful for certain localization
    tasks. `std::string_view` offers a non-owning view into a string, enhancing performance
    in specific scenarios. Also consider `std::u8string`, `std::u16string`, and `std::u32string`.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::wstring`是宽字符版本，适用于某些本地化任务。`std::string_view`提供对字符串的非拥有视图，在特定场景中提高性能。还应考虑`std::u8string`、`std::u16string`和`std::u32string`。'
- en: Sorting and searching complexity
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'The algorithmic performance of `std::string` is characterized as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`的算法性能如下所述：'
- en: '**Searching**: *O(n)* for linear search'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**: 线性搜索的 *O(n)*'
- en: '`std::binary_search()` is possible for sorted sequences'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于排序序列，可以进行`std::binary_search()`。
- en: Special interface and member functions
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Apart from the well-known ones (`substr`, `find`, and `append`), get familiar
    with the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 除了众所周知的（如`substr`、`find`和`append`）之外，熟悉以下内容：
- en: '`c_str()`: Returns a C-style string (provides functionalities for interacting
    with null-terminated C-strings)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c_str()`: 返回一个C风格字符串（提供与以null终止的C字符串交互的功能）'
- en: '`data()`: Direct access to underlying character data'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data()`: 直接访问底层字符数据'
- en: '`resize()`: Adjusts string length'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize()`: 调整字符串长度'
- en: '`shrink_to_fit()`: Reduces memory usage'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shrink_to_fit()`: 减少内存使用'
- en: Comparisons
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: While `std::string` manages text, `std::vector<char>` might seem similar but
    lacks string semantics, such as automatic null termination.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`std::string`管理文本，但`std::vector<char>`可能看起来相似，但它缺乏字符串语义，例如自动空终止。
- en: Interactions with algorithms
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: STL algorithms work seamlessly with `std::string`, though some, such as sorting,
    might seldom apply to textual content.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法与`std::string`无缝工作，尽管某些算法，如排序，可能很少应用于文本内容。
- en: Exceptions
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Bad accesses (e.g., `at()`) can throw. Operations are generally exception-safe,
    meaning a string remains valid even if an operation throws.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意访问（例如，`at()`）可能会抛出异常。操作通常是异常安全的，这意味着即使在操作抛出异常的情况下，字符串仍然有效。
- en: Customization
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: '`std::string` supports custom allocators, but custom comparators or hash functions
    aren’t applicable.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`支持自定义分配器，但自定义比较器或哈希函数不适用。'
- en: Example
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'The `std::string` in C++ is a versatile container that provides a series of
    member functions for different purposes, from text manipulation to searching and
    comparison. Here’s an advanced example illustrating best practices when using
    `std::string`:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的`std::string`是一个多用途容器，提供了一系列用于不同目的的成员函数，从文本操作到搜索和比较。以下是一个使用`std::string`的最佳实践的高级示例：
- en: '[PRE6]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we did the following:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们做了以下操作：
- en: We demonstrated basic string operations, including construction, accessing characters,
    and concatenation.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们演示了基本的字符串操作，包括构造、访问字符和连接。
- en: We used the `find` function to check for substrings.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`find`函数检查子字符串。
- en: We used `std::transform` with `std::toupper` and `std::tolower` to convert the
    entire string to uppercase and lowercase, respectively.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`std::transform`与`std::toupper`和`std::tolower`将整个字符串分别转换为大写和小写。
- en: We removed characters from the string using `erase` combined with `std::remove`.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`erase`结合`std::remove`从字符串中删除字符。
- en: We compared two strings using the natural ordering provided by the overloaded
    comparison operators of `std::string`.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`std::string`的重载比较运算符提供的自然排序比较了两个字符串。
- en: We converted numbers to strings and vice versa using the `std::to_string` and
    `std::stoi` functions.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `std::to_string` 和 `std::stoi` 函数将数字转换为字符串，反之亦然。
- en: These operations showcase various `std::string` best practices and its seamless
    integration with other STL components.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作展示了各种 `std::string` 最佳实践及其与其他 STL 组件的无缝集成。
- en: Best practices
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using `std::string`:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用 `std::string` 的最佳实践：
- en: '`+ operator` for string concatenation might hit performance, given the probable
    reallocations and copies. Switch to `+=` within loops to boost efficiency.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于字符串连接的 `+` 操作符可能会影响性能，考虑到可能的重新分配和复制。在循环中使用 `+=` 来提高效率。
- en: '`reserve()` to preallocate adequate memory, curtailing reallocations and bolstering
    performance.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `reserve()` 预分配足够的内存，减少重新分配并提高性能。
- en: '**Iterative modulation prudence**: Altering a string during iteration can serve
    you surprises. Exercise caution and avoid concurrent modifications while iterating.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代调制谨慎**：在迭代过程中修改字符串可能会给你带来惊喜。请谨慎行事，并在迭代时避免并发修改。'
- en: '`std::string` member functions such as `find()`, `replace()`, and `substr()`.
    They simplify the code, enhance readability, and may boost performance.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string` 成员函数，如 `find()`、`replace()` 和 `substr()`。它们简化了代码，增强了可读性，并可能提高性能。'
- en: '**Guarded element access**: Before diving into string elements, verify your
    indices. Out-of-bounds access is a one-way ticket to undefined behavior.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护元素访问**：在深入字符串元素之前，验证你的索引。越界访问是通向未定义行为的单程票。'
- en: '`std::string_view` for a lightweight reference to part or whole of a string.
    When modifications aren’t on your agenda, it is an efficient alternative to traditional
    string slicing.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string_view` 用于对字符串的部分或全部进行轻量级引用。当没有修改计划时，它是传统字符串切片的有效替代方案。'
- en: '`std::string`. It’s a derivative of the `std::basic_string` template, which
    can cater to custom character types and specialized character behaviors.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string`。它是 `std::basic_string` 模板的衍生，可以满足自定义字符类型和特定字符行为的需求。'
- en: '`std::string` for ASCII and UTF-8 needs. Are you venturing into UTF-16 or UTF-32
    territories? Look towards `std::wstring` and its wide character comrades. Always
    stay vigilant with encodings to avert potential data mishaps.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string` 用于 ASCII 和 UTF-8 需要。你是在探索 UTF-16 或 UTF-32 领域吗？转向 `std::wstring`
    及其宽字符同伴。始终对编码保持警惕，以避免潜在的数据错误。'
- en: '**Capitalizing on internal optimizations**: The **Small String Optimization**
    (**SSO**) is an ace up many standard libraries’ sleeves. It allows the storage
    of small strings directly within the string object, evading dynamic allocation.
    It’s a boon for performance with diminutive strings.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用内部优化**：**小字符串优化**（**SSO**）是许多标准库袖子中的王牌。它允许直接在字符串对象中存储小字符串，避免动态分配。对于小字符串来说，这是一个性能上的福音。'
- en: Just how small is a small string?
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 小字符串究竟有多小？
- en: The exact length of a *small string* varies by implementation. However, a typical
    size of the small string buffer is usually between 15 and 23 characters.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*小字符串* 的确切长度因实现而异。然而，小字符串缓冲区的大小通常在 15 到 23 个字符之间。'
- en: '`compare()` function of `std::string` offers more granularity than the `==`
    operator. It can give insights into lexical ordering, which might be vital for
    sorting operations.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string` 的 `compare()` 函数比 `==` 操作符提供了更多的粒度。它可以提供对词法排序的见解，这对于排序操作可能是至关重要的。'
- en: '`std::stringstream` provides a flexible way to concatenate and convert strings,
    it might come with overheads. When performance is pivotal, prefer direct string
    operations.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::stringstream` 提供了一种灵活的方式来连接和转换字符串，但它可能伴随着开销。当性能至关重要时，优先选择直接字符串操作。'
- en: '`std::stoi` and `std::to_string`, among others. These are safer and often more
    efficient than manual parsing.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::stoi` 和 `std::to_string` 等函数。它们比手动解析更安全且通常更高效。'
