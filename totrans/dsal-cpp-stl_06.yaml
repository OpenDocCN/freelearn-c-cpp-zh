- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Sequence Container Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequence containers are at the core of C++ data handling, providing structures
    to hold data linearly. For intermediate developers, making the right choice from
    an array of sequence containers including vectors, arrays, deques, and lists can
    be pivotal. This chapter breaks down each container type, emphasizing their distinct
    advantages and ideal use cases. Furthermore, diving into best practices—from efficient
    resizing to iterator management—will ensure developers choose the right container
    and utilize it effectively. Grasping these nuances elevates code efficiency, readability,
    and maintainability in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the sprawling expanse of the C++ **Standard Template Library** (**STL**),
    sequence containers hold a position of prominence. Not just because they’re often
    the first choice of data structures for developers but also because of the unique
    and versatile solutions each offers. These containers, as their name implies,
    maintain elements sequentially. But as we dive deeper, you’ll find that the similarities
    often end there. Each sequence container brings its strengths and is tailored
    for particular scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: std::array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::array` is a fixed-size container that wraps around a traditional C-style
    array. If you’re coming from a C background or even early C++, you’ll be familiar
    with the headaches of raw arrays—the lack of bounds-checking, the cumbersome syntax,
    and more. With `std::array`, you get all the benefits of a traditional array,
    such as static memory allocation and constant-time access, while enjoying modern
    C++ amenities including range-based for-loops and member functions for size checking.
    Use `std::array` when you know the size of your dataset in advance, and it will
    not change. It’s perfect for scenarios where performance is paramount and your
    memory needs are static.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on CPP core guidelines, please refer to *C++ Core* *Guidelines*
    [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::array` is a container that encapsulates fixed-size arrays. Its strengths
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Predictable, fixed size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack allocation, offering swift access and minimal overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s best to choose `std::array` in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: The array size is known at compile-time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overhead minimization and performance predictability are crucial.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For dynamic sizing needs, consider `std::vector` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases of `std::array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::array` is the go-to choice. This makes it apt for situations where dimension
    sizes are predefined, such as in certain mathematical operations or game board
    representations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array` does not involve dynamic memory allocations, which can benefit
    real-time or performance-critical applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array` offers bounds-checking (with the `at()` member function), providing
    a safer alternative to C-style arrays, especially when dealing with potential
    out-of-bounds access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array`, size information is retained, making writing safer and more intuitive
    functions easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array` can seamlessly be used with C-style arrays, making it a great
    choice for projects with C and C++ integrations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array` is the best choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector`, `std::array` offers contiguous memory storage, making it cache-friendly
    for iterations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array` ensures no surprise memory allocations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array` provides convenient initialization semantics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, while `std::array` offers several advantages over traditional arrays,
    it is essential to note that it doesn’t fit situations where dynamic resizing
    is necessary. For those use cases, one might consider `std::vector` or other dynamic
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::array` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: Not applicable since the size is fixed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: Not applicable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: A constant *O(1)* for any position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Minimal, given stack allocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trade-off**: Fixed-size efficiency is at the cost of static sizing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike `std::vector`, `std::array` doesn’t dynamically allocate memory. It is
    stack allocated, so there are no unexpected allocation behaviors or surprises.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Are you reading from multiple threads? Perfectly fine. However, writing concurrently
    to the same element demands synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For dynamic needs, `std::vector` serves as the STL’s prime alternative. Other
    fixed-size array options include the plain old C-style arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::sort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::binary_search()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Standard functions such as `begin()`, `end()`, and `size()` are present. Noteworthy
    member functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fill`: Sets all elements to a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swap`: Swaps contents with another array of the same type and size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::vector`, `std::array` does not resize but offers predictable
    performance. When choosing, weigh the need for dynamic sizing against performance
    consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STL algorithms play nicely with `std::array` due to random-access capabilities.
    However, those expecting dynamic sizing won’t work with `std::array`.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With `std::array`, out-of-bounds access (such as using `at()`) can throw exceptions,
    primarily `std::out_of_range`.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you cannot resize, you can integrate custom types. Given the container’s
    stack-allocation nature, ensure they’re efficiently movable/copyable.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will show the following best practices and use of `std::array`:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `std::array` with a fixed size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using C++ structured bindings with `std::array` to destructure elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing compile-time calculations with `std::array` (thanks to its constexpr
    nature)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using algorithms such as `std::sort` and `std::find` with `std::array`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured bindings
  prefs: []
  type: TYPE_NORMAL
- en: Structured bindings, introduced in C++17, allow for the convenient and readable
    unpacking of elements from tuples, pairs, or struct-like objects into separate
    named variables. This syntax simplifies accessing multiple elements returned from
    a function or decomposing the contents of complex data structures, enhancing code
    clarity and reducing verbosity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code example discussing the above points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example highlights the features and advantages of `std::array`, including
    its fixed-size nature, compatibility with modern C++ features like structured
    bindings, and its utility in compile-time computations. The preceding example
    also illustrates how STL algorithms can be seamlessly applied to `std::array`.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using std::array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::array` encapsulates the predictability of C-style arrays, enriching them
    with added utility. Its fixed size is particularly useful for situations with
    predetermined data sizes, making it a prime choice for such applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array` comes with a suite of member functions, elevating its capabilities.
    This makes it a compelling choice in contemporary C++ development over its traditional
    counterpart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.at()` member function is invaluable. It guards against out-of-bound accesses
    by throwing exceptions when boundaries are crossed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array` is both its strength and limitation. It promises constant time
    access but lacks flexibility in resizing. Therefore, it is essential to be precise
    about the desired size during its declaration to prevent potential issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array`, adopting this loop structure minimizes the chances of boundary
    errors, promoting code stability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array` can house diverse types, considering efficiency is pivotal. If
    the type, be it primitive or user-defined, is particularly large or intricate,
    ensure its move or copy operations are optimized to preserve performance during
    array operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array` excels in scenarios that demand a fixed-size container. However,
    for applications where dynamic resizing or extensive data is anticipated, alternatives
    such as `std::vector` may offer a more adaptive solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::vector` is a dynamic array. It grows and shrinks as needed, offering
    an excellent balance between direct access performance and flexibility in size.
    `std::vector` has a cache-friendly contiguous memory layout and amortized constant-time
    insertions at the end, making it an excellent general-purpose container. It performs
    best when your primary operations are indexing and require dynamic resizing but
    without frequent insertions or deletions in the middle.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::vector` is essentially a dynamic array within the STL. Its primary strength
    lies in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Offering constant-time random access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically resizing as elements are inserted or removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s particularly suitable when the following is required:'
  prefs: []
  type: TYPE_NORMAL
- en: Random access is paramount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertions or deletions are primarily at the end of the sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache locality is essential.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opt for `std::vector` when constant-time access, performance, or cache friendliness
    trump other concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases of `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::vector` is your best choice. Unlike standard arrays, vectors automatically
    manage their size and handle memory allocation/deallocation seamlessly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` offers constant-time access to any elements, making it suitable
    for frequently accessing or modifying data at specific indices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` provides a contiguous block of memory that’s appropriate for
    this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` is optimized for insertions at its end, it is a good choice for
    applications such as log systems, where new entries are continuously added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` provides one of the most memory-efficient ways to store data
    because of its continuous memory block and lack of structural overhead, unlike
    linked-list-based containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` is cache-friendly, leading to faster performance in many scenarios
    compared to non-contiguous data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` can be easily streamed or written.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::stack` for this purpose, `std::vector` can effectively implement a stack
    data structure where elements are added or removed only from the back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` provides an efficient and dynamic container for this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there are a few caveats when using `std::vector`. If frequent insertions
    or deletions are needed in the middle, `std::vector` might not be the most efficient
    choice due to the need to shift elements. Also, if you’re pushing elements frequently,
    using `reserve()` to preallocate memory and avoid frequent reallocations is a
    good practice.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::vector` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion:** *O(1)* average-case for the end, *O(n)* for elsewhere'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion:** *O(1)* at the end, *O(n)* for the middle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access:** A swift *O(1)* for any position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead:** Typically low, but can inflate if reserved capacity isn’t
    managed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trade-offs:** The convenience of *O(1)* access is counterbalanced by potential
    *O(n)* costs for insertion at the start or middle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::vector` automatically manages its memory. If its capacity is exhausted,
    it typically doubles its size, though this isn’t strictly mandated. Allocators
    can influence this behavior, permitting fine-grained control.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reads? No problem. But writes, or a mix of reads and writes, demand
    external synchronization. Consider mutexes or other concurrency tools.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `std::vector` is a dynamic array, the STL offers other sequence containers
    such as `std::deque` that provide an API for fast insertions at both ends or `std::list`,
    possibly optimizing middle insertions and deletions.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::sort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::binary_search()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond the regulars (`push_back`, `pop_back`, `begin`, and `end`), acquaint
    yourself with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace_back`: Constructs elements directly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resize`: Changes the number of elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shrink_to_fit`: Reduces memory usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Against `std::list` and `std::deque`, `std::vector` excels at random access,
    but may falter with frequent middle modifications of very large data types.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many STL algorithms harmonize beautifully with `std::vector` due to its random-access
    nature. Algorithms requiring frequent reordering, however, might be better paired
    with other containers.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pushing beyond capacity or accessing out-of-bounds indices can throw exceptions.
    Notably, operations are exception-safe, preserving vector states even if operations
    (like insertions) throw exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With custom allocators, tweak memory allocation strategies. However, `std::vector`
    does not naturally support custom comparators or hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will show the following best-practices and use of `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: Preallocating memory with reserve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `emplace_back` for efficient insertion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterators for traversal and modification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employing `std::vector` with custom objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using algorithms such as `std::remove` with `std::vector`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example demonstrates the efficiency and flexibility of `std::vector`
    combined with C++ STL algorithms. It showcases managing and manipulating a list
    of `Employee` objects in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at a `std::vector<bool>` example.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::vector<bool>` is a somewhat controversial specialization in the C++ Standard
    Library. It was designed to use only one bit per boolean value, thereby saving
    space. However, this space optimization has led to several unexpected behaviors
    and quirks, especially compared to `std::vector` for other types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For those reasons, many experts advise caution when using `std::vector<bool>`.
    Nevertheless, if one still wishes to utilize it, here’s a canonical example illustrating
    its use and some of its quirks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The key takeaways from the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::vector<bool>` offers memory savings by storing booleans as individual
    bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When accessing an element from `std::vector<bool>`, you don’t get a normal reference
    as you do with other vector types. Instead, you get a proxy object. This is why
    modifying `ref` in the example doesn’t change the actual value in the vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other operations, such as iteration, resizing, and capacity checks, work similarly
    to other `std::vector` types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For many applications, the peculiarities of `std::vector<bool>` might outweigh
    its memory-saving benefits. If the memory optimization isn’t crucial and the behavior
    quirks can be problematic, consider using alternative containers such as `std::deque<bool>`,
    `std::bitset`, or a third-party bitset/vector library.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::vector<bool>` isn’t just a simple vector of boolean values. It’s specialized
    to save space, and this space efficiency comes at a cost: elements aren’t real
    bools but bitfield proxies. This specialization can lead to unique behavior in
    certain operations, making it vital to understand its intricacies fully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` is its ability to resize dynamically. While this is powerful,
    predicting and guiding this resizing with the `reserve` function can be beneficial.
    Preallocating memory helps in minimizing reallocations and ensures efficient performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push_back` is a frequently used method to add elements, `emplace_back` provides
    a more efficient way to construct objects directly in the vector. Constructing
    objects in place can often enhance performance, especially with complex objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` provides excellent random access performance. However, operations
    in the middle, such as insertions or deletions, can be more time-consuming due
    to the need to move subsequent elements. For tasks that require frequent middle
    operations, it is worthwhile to consider alternative STL containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.at()` member function, on the other hand, provides bounds-checked access
    and will throw a `std::out_of_range` exception if an invalid index is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector`. While `std::vector` isn’t inherently thread-safe, you can achieve
    thread safety with appropriate synchronization tools such as mutexes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` isn’t optimized for frequent middle insertions or deletions.
    That said, its cache-friendliness and ability to quickly search may still mean
    it is the best data type to use. Using it as a linked list can be suboptimal,
    but only for specific use cases (perhaps very large data types or very large datasets.)
    For such patterns, containers like `std::list` may be better suited. Never assume,
    however, that a `std::list` will perform better just because you require frequent
    insertions and deletions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map`, where vectors might be values, don’t fall into the trap of assuming
    automatic updates. It’s essential to manage and update these nested containers
    explicitly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::deque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::deque` is a double-ended queue. On the surface, it looks like `std::vector`
    with better insertions and deletions at both the beginning and the end. While
    that’s true, remember that this flexibility comes at the cost of a slightly more
    complex internal structure. If your application requires rapid insertions and
    deletions at both ends but does not need the tight memory layout of `std::vector`,
    `std::deque` is your container of choice.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::deque` is a container that provides rapid insertions and deletions at
    both its beginning and end. Its primary strengths are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Efficient *O(1)* insertions and deletions at both ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic size with no need for manual memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fairly good cache performance for front and back operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` shines in the following contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: You require random-access capabilities but expect frequent modifications at
    both ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need a dynamically sized container but do not want the memory overhead of
    a `std::list`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If only end modifications are necessary, `std::vector` could be a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases of `std::deque`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::vector`, which primarily allows for fast insertion at the back, `std::deque`
    supports quick insertion and deletion at both the front and the back, making it
    ideal for scenarios requiring operations on both ends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` can serve as a queue (FIFO data structure) and a stack (LIFO data
    structure). It’s versatile in this regard, unlike other containers specializing
    in one or the other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector`, `std::deque` offers constant-time random access to elements,
    making it suitable for applications that need to access elements by index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` grows in one direction, `std::deque` can grow in both directions.
    This makes it especially useful for situations where the dataset might expand
    unpredictably on both ends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` can be helpful. As data is consumed from the front (played), new
    data can be buffered at the back without reshuffling the entire dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` offers an efficient solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` can easily be adapted into other custom data structures. For example,
    a balanced tree or a specific kind of priority queue might leverage the capabilities
    of `std::deque`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` can efficiently handle adding new actions and automatically removing
    the oldest ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When considering `std::deque`, it is essential to weigh the benefits of its
    double-ended and random-access nature against its slightly higher per-element
    overhead compared to `std::vector`. Other data structures might be more space-efficient
    in scenarios with only one-sided growth.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::deque` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion:** *O(1)* for both front and back; *O(n)* in the middle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion:** *O(1)* for both front and back; *O(n)* for the middle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access:** Consistent *O(1)* for random access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` due to segmented memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::deque` uses segmented allocation, which means it allocates chunks of
    memory as needed. Unlike `std::vector`, it doesn’t double its size; thus, there
    is no excessive memory overhead. Custom allocators can affect memory allocation
    strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reads are safe. But like most STL containers, simultaneous writes
    or a mix of reads and writes require external synchronization mechanisms, such
    as mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::deque` stands between `std::vector` and `std::list` in terms of performance
    and memory characteristics. However, it uniquely offers fast operations at both
    ends.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::sort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::binary_search()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the familiar (`push_back`, `push_front`, `pop_back`, `pop_front`,
    `begin`, and `end`), get familiar with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace_front` and `emplace_back`: In-place construction at respective ends'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resize`: Adjust the container size, extending or truncating it as needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::vector`, `std::deque` provides better front operations. Against
    `std::list`, it gives better random access but may suffer in terms of middle insertions/deletions.
    The non-contiguous storage of `std::deque` can be a disadvantage when it comes
    to iterating over elements compared to `std::vector` due to poorer cache performance.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::deque` can leverage most STL algorithms effectively due to its random-access
    nature. Algorithms requiring swift end modifications are particularly suited for
    `std::deque`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going beyond size or accessing out-of-range indices can lead to exceptions.
    If operations such as insertions throw exceptions, the container remains intact,
    ensuring exception safety.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::deque` can be used with custom allocators to tailor memory allocation
    behavior, but it does not support custom comparators or hash functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will show the following best practices and use of `std::deque`:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `std::deque` to maintain a list of elements, taking advantage of its dynamic
    size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting elements at both the front and back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient removal of elements from both the front and back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::deque` as a sliding window to process elements in chunks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying STL algorithms such as `std::transform`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrate the dynamic nature of `std::deque` by adding elements to both
    the beginning and end of the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We showcase the efficient operations of `pop_front()` and `pop_back()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sliding window function processes the elements in chunks, taking advantage
    of the random access nature of `std::deque`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use the `std::transform` algorithm to manipulate the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using `std::deque`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::deque` is its segmented memory. This can sometimes lead to performance
    nuances that are less predictable compared to the contiguous memory layout of
    `std::vector`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` with `std::vector` when it comes to memory behavior. The two have
    different architectures, leading to varied performances in specific scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` provides quick insertions and deletions at both ends but not in
    the middle. If middle operations are measured to be a bottleneck, consider other
    containers such as `std::vector` and `std::list`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` for its core strength: constant-time operations at both ends.
    Should you predominantly use only one end, `std::vector` could offer better performance.
    Even with this advantage, do not assume that `std::deque` will perform better
    than `std::vector`. You may find that `std::vector`’s contiguous storage and cache-friendliness
    allow it to outperform `std::deque` even with front insertions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` doesn’t guarantee contiguous memory, it can pose challenges when
    dealing with APIs or libraries that demand raw arrays. Always be aware of this
    distinction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace_front` and `emplace_back` when adding elements. These functions construct
    elements directly within the deque, optimizing memory usage and performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` when the front and back operations are frequent and the measured
    performance loss is acceptable. Its architecture is optimized for these operations,
    providing consistent performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque`, always ensure you’re within its size boundaries to prevent undefined
    behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque`, make sure to use appropriate synchronization mechanisms, such
    as mutexes or locks, to ensure data integrity and prevent race conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::list` is a doubly linked list. Unlike the previous containers, it does
    not store its elements contiguously. This means you lose out on the cache-friendliness
    but gain immense flexibility. Insertions and deletions, regardless of position,
    are a constant-time operation as long as you have an iterator to the position.
    However, access time is linear, making it less suited for tasks where random access
    is frequent. `std::list` is best suited for scenarios where the dataset experiences
    frequent insertions and deletions from both the middle and the ends, and direct
    access isn’t a priority.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::list` is a doubly-linked list provided by the STL. Its strengths include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Facilitating constant-time insertions and deletions at any position (while sacrificing
    cache friendliness and fast searching)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving iterator validity during modifications (except when the element referred
    to by the iterator is removed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s best chosen in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Frequent insertions and deletions from both the container’s front and middle
    are expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random access isn’t a primary requirement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator validity preservation is vital.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have inherently cache-unfriendly (large) data stored in each node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When considering between different containers, lean towards `std::list` for
    its linked-list benefits. If random access is vital, `std::vector` or `std::deque`
    may be better choices.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases of `std::list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::forward_list`, `std::list` provides bidirectional traversal capabilities,
    allowing you to iterate through the elements both forward and backward, which
    is beneficial for certain algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` offers constant time insertions and deletions at any position,
    provided you have an iterator to the position. This makes it suitable for applications
    where such operations are frequent. Note, however, that the cost of searching
    for the position to perform the insertion may outweigh the benefits of the insertion
    operation itself. Often, `std::vector` will outperform `std::list` even for frequent
    insertions and deletions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` can be a good choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` proves efficient due to its splicing capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::queue` is the standard choice, `std::list` can be employed to implement
    double-ended queues (deque) because of its bidirectional nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` apt for maintaining an undo and redo history in software applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` is often a good choice due to its efficiency in moving elements
    around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` can be adapted to create circular lists where the last element
    links back to the first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` can be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `std::list` is versatile, one should be cautious of its limitations. It
    doesn’t support direct access or indexing, unlike arrays or `std::vector`. Therefore,
    it is crucial to choose `std::list` when its specific strengths align well with
    the application’s requirements. It is also cache-unfriendly and expensive to perform
    a linear search on.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::list` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(1)* anywhere in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(1)* for a known position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(n)* due to its linked nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Generally higher than vector due to storage of next and
    previous pointers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` will outperform `std::list` for most use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike `std::vector`, `std::list` does not reallocate en masse. Each element’s
    allocation is independent. Allocators can still influence individual node allocation,
    granting more specific memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reads are safe. However, modifications, or simultaneous reads and
    writes, require external synchronization. Mutexes or similar constructs can be
    employed.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::forward_list` is a singly-linked variant, optimizing for space but losing
    the ability to traverse backward.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::list::sort()`, typically *O(n* *log n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::find()` due to lack of random access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Noteworthy functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace_front`/`emplace_back`: Direct in-place construction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splice`: Transfers elements from one list to another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge`: Combines two sorted lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique`: Removes duplicate elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When juxtaposed with `std::vector` or `std::deque`, `std::list` seems like it
    would be superior for frequent insertions and deletions in the middle. However,
    it does not offer the speedy random access the former containers do. This means
    that the cost of finding where to perform an insertion or deletion outweighs the
    benefits of the insertion or deletion itself.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `std::list` can work with many STL algorithms, those requiring random
    access (e.g., `std::random_shuffle`) aren’t ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Out-of-bounds or illegal operations might throw exceptions. However, many of
    `std::list`’s operations offer strong exception safety, ensuring the list remains
    consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom allocators can be employed to influence the node memory allocation. Unlike
    containers such as `std::set` or `std::map`, custom comparators aren’t typical
    with `std::list`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will show the following best practices and use of `std::list`:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting the bidirectional nature of `std::list` to traverse and modify elements
    in both forward and reverse directions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently inserting and removing elements from anywhere in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::list`’s member functions such as `sort()`, `merge()`, `splice()`,
    and `remove_if()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying external STL algorithms like `std::find`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We traverse the `std::list` in reverse using reverse iterators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We showcase the ability to efficiently insert elements at a desired position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We demonstrate the use of `std::list`-specific operations such as `sort()`,
    `merge()`, and `splice()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use a lambda with `remove_if()` to conditionally remove elements
    from the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example illustrates various capabilities of `std::list`, including operations
    that are especially efficient with this container and ones that use its bidirectional
    nature.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore some best practices for using `std::list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::list` unless you have profiled your code against a data type such as
    `std::vector` and found a measurable performance improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort()` member function provided by `std::list` itself is essential rather
    than resorting to `std::sort`. This is due to c requiring random access iterators,
    which `std::list` doesn’t support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` doesn’t offer *O(1)* random access due to its doubly-linked structure.
    For frequent random access, containers such as `std::vector` or `std::deque` may
    be more suitable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` means it maintains two pointers per element. This enables backward
    and forward traversal but does come at a memory cost. If memory usage is critical
    and bidirectional traversal isn’t required, `std::forward_list` offers a cleaner
    alternative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` can transform operations from *O(n)* to *O(1)*. Harness the power
    of iterators for more efficient insertions and deletions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` offers the unique ability to transfer elements between lists in
    constant time using the `splice` function. This operation is both efficient and
    can simplify list manipulations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace_front` and `emplace_back`, you can construct elements in place, eliminating
    the need for temporary objects and potentially speeding up your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list`. Especially in memory-sensitive scenarios, being aware of this
    overhead can be critical in making informed container choices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::forward_list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::forward_list` is a singly linked list. It’s similar to `std::list`, but
    each element points only to the next element and not the previous. This reduces
    memory overhead compared to `std::list` but at the cost of bidirectional iteration.
    Choose `std::forward_list` when you require a list structure but don’t need to
    traverse backward and wish to save on memory overhead.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `std::forward_list` is a singly linked list container in the STL. Its primary
    appeal lies in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Efficient insertions and deletions at any location in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming less memory than `std::list` since it doesn’t store previous pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s especially fitting in the following contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: You require constant-time insertions or deletions irrespective of the position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory overhead is a concern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bidirectional iteration is not needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `std::vector` excels in random access, turn to `std::forward_list` if
    you value insertion and deletion efficiency above all.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases of `std::forward_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::forward_list` uses a singly-linked list, which has less overhead than
    doubly-linked lists since it only has to maintain a link in one direction. This
    makes it suitable for scenarios where space conservation is a priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list` offers optimal efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list` can be a fitting choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using std::forward_list` ensures one-directional movement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list` can be employed to design stack-like behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list` can store these edges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list` provides the necessary structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s essential to understand that while `std::forward_list` offers advantages
    in specific use cases, it lacks some functionalities other containers offer, such
    as the bidirectional traversal seen in `std::list`. Choosing `std::forward_list`
    is appropriate when its benefits align with the application’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::forward_list` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(1)* irrespective of the position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(1)* for any spot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(n)* since sequential access is the only option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Minimal, as only the next pointers are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list`, is usually outweighed by its cache unfriendliness and slow search
    performance compared to `std::vector`. Generally, `std::vector` will outperform
    `std::forward_list` for most use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory is allocated as and when an element is inserted. Each node stores the
    element and a pointer to the next node. Custom allocators can adjust this allocation
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reads are safe. However, writes or a combination of reads and writes
    require external synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For those desiring bidirectional iteration capabilities, `std::list` (a doubly-linked
    list) is a viable alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::sort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: *O(n)* since there’s no random access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Noteworthy member functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace_front`: For direct element construction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`: To get rid of elements by value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splice_after:` For transferring elements from another `std::forward_list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, there’s no `size()` or `push_back()` function in `std::forward_list`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Against `std::list`, `std::forward_list` uses less memory but doesn’t support
    bidirectional iteration. Compared to `std::vector`, it doesn’t allow random access
    but ensures consistent insertion and deletion times.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given its forward-only nature, `std::forward_list` might not gel with algorithms
    needing bidirectional or random access iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions can arise during memory allocation failures. Most operations on `std::forward_list`
    offer strong exception safety guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can adjust the memory allocation strategy using custom allocators. `std::forward_list`
    doesn’t inherently support custom comparators or hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::forward_list` is a singly-linked list, which is particularly efficient
    at insertions/deletions from the front. It consumes less memory than `std::list`
    because it doesn’t store backward pointers for each element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One common use case for a `std::forward_list` is implementing a hash table
    with chaining to resolve collisions. Here’s a basic version of a chained hash
    table using `std::forward_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The hash table consists of a `std::vector` of `std::forward_list` called table.
    Each slot in the vector corresponds to a hash value and potentially holds multiple
    keys (in a `forward_list`) that collide with that hash value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `emplace_front` function of `forward_list` is particularly useful in this
    context because we can add new key-value pairs to the front of the list in constant
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `forward_list::remove_if` for removing a key-value pair, which scans
    through the list and removes the first matching key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using `std::forward_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::forward_list` unless you have profiled your code against a data type
    such as `std::vector` and found a measurable performance improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list` is a specialized container optimized for certain scenarios
    in the world of singly linked lists. Understanding its strengths and limitations
    is crucial to use it effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list` is a solid choice. However, it lacks fast direct access
    to elements, requiring an *O(n)* operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list` supports only forward iteration. If bidirectional traversal
    is necessary, consider other containers such as `std::list`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No random access**: This container is unsuitable for scenarios where quick
    random access to elements is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size()` member function means that determining the list’s size requires an
    *O(n)* operation. For a quick check on whether the list is empty, utilize the
    `empty()` function, which is efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list` offers efficient insertions and deletions. Specifically,
    `emplace_front` is useful for in-place element construction, reducing overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort()` function to maintain element order. To remove consecutive duplicate
    elements, apply the `unique()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cautions with iterators**: It’s imperative to recheck iterator validity after
    modifications, especially post insertions or deletions, as they may become invalidated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward_list` in multi-threaded applications to prevent data races or
    inconsistencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list`, the `std::forward_list` often uses less memory because it maintains
    only one pointer per element (forward pointer), making it a more memory-efficient
    choice when bidirectional iteration is not required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the STL, `std::string` is a class designed to manage sequences of characters.
    `std::string` simplifies text handling by providing a range of string manipulation
    and analysis features. `std::string` is not classified under the *sequence containers*
    category in the formal C++ Standard Library documentation, though it behaves very
    much like one. Instead, it is categorized under a separate *Strings* category,
    recognizing its general container-like behavior and its specialized nature for
    text handling.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::string` represents a dynamic sequence of characters and is essentially
    a specialization of `std::vector<char>`. It is designed for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating textual data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with functions that expect string input or produce string output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s particularly suitable in the following contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic text modification is frequent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient access to individual characters is desired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose `std::string` for most string manipulation tasks. If you require string
    views without ownership, consider `std::string_view`.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases of `std::string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text processing**: Parsing files, processing logs, or any other task requiring
    dynamic text manipulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User input/output**: Accepting user inputs; producing human-readable output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data serialization**: Encoding data as a string for transport/storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::string` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(1)* average for the end, *O(n)* for elsewhere'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(n)* since elements might need shifting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: A rapid *O(1)* for any position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Generally low but can grow if reserved capacity isn’t
    used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::string` dynamically allocates memory. When the buffer is filled, it reallocates,
    often doubling its size. Custom allocators can modify this behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reading is safe, but simultaneous modifications require synchronization,
    typically using mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::wstring` is a wide-character version useful for certain localization
    tasks. `std::string_view` offers a non-owning view into a string, enhancing performance
    in specific scenarios. Also consider `std::u8string`, `std::u16string`, and `std::u32string`.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::string` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Searching**: *O(n)* for linear search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::binary_search()` is possible for sorted sequences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the well-known ones (`substr`, `find`, and `append`), get familiar
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`c_str()`: Returns a C-style string (provides functionalities for interacting
    with null-terminated C-strings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data()`: Direct access to underlying character data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resize()`: Adjusts string length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shrink_to_fit()`: Reduces memory usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `std::string` manages text, `std::vector<char>` might seem similar but
    lacks string semantics, such as automatic null termination.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STL algorithms work seamlessly with `std::string`, though some, such as sorting,
    might seldom apply to textual content.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bad accesses (e.g., `at()`) can throw. Operations are generally exception-safe,
    meaning a string remains valid even if an operation throws.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::string` supports custom allocators, but custom comparators or hash functions
    aren’t applicable.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `std::string` in C++ is a versatile container that provides a series of
    member functions for different purposes, from text manipulation to searching and
    comparison. Here’s an advanced example illustrating best practices when using
    `std::string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated basic string operations, including construction, accessing characters,
    and concatenation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the `find` function to check for substrings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used `std::transform` with `std::toupper` and `std::tolower` to convert the
    entire string to uppercase and lowercase, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We removed characters from the string using `erase` combined with `std::remove`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We compared two strings using the natural ordering provided by the overloaded
    comparison operators of `std::string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We converted numbers to strings and vice versa using the `std::to_string` and
    `std::stoi` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These operations showcase various `std::string` best practices and its seamless
    integration with other STL components.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using `std::string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+ operator` for string concatenation might hit performance, given the probable
    reallocations and copies. Switch to `+=` within loops to boost efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reserve()` to preallocate adequate memory, curtailing reallocations and bolstering
    performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterative modulation prudence**: Altering a string during iteration can serve
    you surprises. Exercise caution and avoid concurrent modifications while iterating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::string` member functions such as `find()`, `replace()`, and `substr()`.
    They simplify the code, enhance readability, and may boost performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guarded element access**: Before diving into string elements, verify your
    indices. Out-of-bounds access is a one-way ticket to undefined behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::string_view` for a lightweight reference to part or whole of a string.
    When modifications aren’t on your agenda, it is an efficient alternative to traditional
    string slicing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::string`. It’s a derivative of the `std::basic_string` template, which
    can cater to custom character types and specialized character behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::string` for ASCII and UTF-8 needs. Are you venturing into UTF-16 or UTF-32
    territories? Look towards `std::wstring` and its wide character comrades. Always
    stay vigilant with encodings to avert potential data mishaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capitalizing on internal optimizations**: The **Small String Optimization**
    (**SSO**) is an ace up many standard libraries’ sleeves. It allows the storage
    of small strings directly within the string object, evading dynamic allocation.
    It’s a boon for performance with diminutive strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just how small is a small string?
  prefs: []
  type: TYPE_NORMAL
- en: The exact length of a *small string* varies by implementation. However, a typical
    size of the small string buffer is usually between 15 and 23 characters.
  prefs: []
  type: TYPE_NORMAL
- en: '`compare()` function of `std::string` offers more granularity than the `==`
    operator. It can give insights into lexical ordering, which might be vital for
    sorting operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::stringstream` provides a flexible way to concatenate and convert strings,
    it might come with overheads. When performance is pivotal, prefer direct string
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::stoi` and `std::to_string`, among others. These are safer and often more
    efficient than manual parsing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
