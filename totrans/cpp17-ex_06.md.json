["```cpp\n   #ifndef CLOCK_H \n   #define CLOCK_H \n\n   #include <QWidget> \n   #include <QTimer> \n\n   class Clock : public QWidget { \n     Q_OBJECT \n\n     public: \n       Clock(QWidget *parentWidget = nullptr); \n       void paintEvent(QPaintEvent *eventPtr);\n\n     private: \n     QTimer m_timer; \n   }; \n\n   #endif // CLOCK_H \n```", "```cpp\n   #include <QtWidgets> \n   #include \"Clock.h\" \n```", "```cpp\n    Clock::Clock(QWidget *parentWidget /*= nullptr*/) \n    :QWidget(parentWidget) { \n      setWindowTitle(tr(\"Clock Advanced\")); \n      resize(1000, 500); \n\n      m_timer.setParent(this); \n      connect(&m_timer, SIGNAL(timeout()), this, SLOT(update())); \n      m_timer.start(100); \n    } \n```", "```cpp\n    void Clock::paintEvent(QPaintEvent* /*event*/) { \n      int side = qMin(width(), height()); \n      QTime time = QTime::currentTime(); \n```", "```cpp\n    QPainter painter(this); \n    painter.setRenderHint(QPainter::Antialiasing); \n    painter.setRenderHint(QPainter::TextAntialiasing); \n    painter.translate(width() / 2, height() / 2); \n    painter.scale(side / 200.0, side / 200.0); \n```", "```cpp\n    painter.setFont(QFont(tr(\"Times New Roman\"), 12)); \n```", "```cpp\n     for (int hour = 1; hour <= 12; ++hour) { \n       QString text; \n       text.setNum(hour); \n```", "```cpp\n    double angle = (30.0 * hour) - 90; \n    double radius = 90.0; \n```", "```cpp\n    double x = radius * qCos(qDegreesToRadians(angle)), \n           y = radius * qSin(qDegreesToRadians(angle)); \n```", "```cpp\n     QRect rect(x - 100, y - 100, 200, 200); \n     painter.drawText(rect, Qt::AlignHCenter | \n                            Qt::AlignVCenter, text); \n     } \n```", "```cpp\n    double hours = time.hour(), minutes = time.minute(), \n      seconds = time.second(), milliseconds = time.msec(); \n\n    painter.setPen(Qt::black); \n    painter.setBrush(Qt::gray); \n\n    { static const QPoint hourHand[3] = \n       {QPoint(8, 8), QPoint(-8, 8), QPoint(0, -60)}; \n\n      painter.save(); \n      double hour = hours + (minutes / 60.0) + (seconds / 3600.0) + \n                  (milliseconds / 3600000.0); \n      painter.rotate(30.0 * hour); \n      painter.drawConvexPolygon(hourHand, 3); \n      painter.restore(); \n    } \n\n    { static const QPoint minuteHand[3] = \n      {QPoint(6, 8), QPoint(-6, 8), QPoint(0, -70)}; \n\n      painter.save(); \n      double minute = minutes + (seconds / 60.0) + \n                    (milliseconds / 60000.0); \n      painter.rotate(6.0 * minute); \n      painter.drawConvexPolygon(minuteHand, 3); \n      painter.restore(); \n    } \n\n    { static const QPoint secondHand[3] = \n       {QPoint(4, 8), QPoint(-4, 8), QPoint(0, -80)}; \n\n      painter.save(); \n      double second = seconds + (milliseconds / 1000); \n      painter.rotate(6.0 * second); \n      painter.drawConvexPolygon(secondHand, 3); \n      painter.restore(); \n    } \n }\n```", "```cpp\n#include <QApplication> \n#include \"Clock.h\" \n\nint main(int argc, char *argv[]) { \n  QApplication application(argc, argv); \n  Clock Clock; \n  Clock.show(); \n  return application.exec(); \n} \n```", "```cpp\n    #ifndef FIGURE_H \n    #define FIGURE_H \n\n    enum FigureId {LineId, RectangleId, EllipseId}; \n\n    #include <QtWidgets> \n    #include <FStream> \n    using namespace std; \n\n    class Figure { \n      public: \n      Figure(); \n```", "```cpp\n    virtual Figure* clone() const = 0; \n\n    virtual FigureId getId() const = 0; \n    virtual void initializePoints(QPoint point) = 0; \n```", "```cpp\n    virtual bool isClick(QPoint mousePoint) = 0; \n    virtual void modify(QSize distance) = 0; \n```", "```cpp\n    virtual bool isInside(QRect area) = 0; \n```", "```cpp\n    virtual void doubleClick(QPoint mousePoint) = 0; \n\n    virtual void move(QSize distance) = 0; \n    virtual void draw(QPainter &painter) const = 0; \n\n    virtual bool write(ofstream& outStream) const; \n    virtual bool read(ifstream& inStream); \n```", "```cpp\n    bool marked() const {return m_marked;} \n    bool& marked() {return m_marked;} \n\n    const QColor& color() const {return m_color;} \n    QColor& color() {return m_color;} \n\n    virtual bool filled() const {return m_filled;} \n    virtual bool& filled() {return m_filled;} \n\n    static const int Tolerance; \n\n    private: \n    QColor m_color; \n    bool m_marked = false, m_filled = false; \n    }; \n\n    #endif \n```", "```cpp\n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"Figure.h\" \n\n    const int Figure::Tolerance(6); \n\n    Figure::Figure() { \n       // Empty. \n    } \n```", "```cpp\n    bool Figure::write(ofstream& outStream) const { \n      writeColor(outStream, m_color); \n      outStream.write((char*) &m_filled, sizeof m_filled); \n      return ((bool) outStream); \n    } \n\n    bool Figure::read(ifstream& inStream) { \n      readColor(inStream, m_color); \n      inStream.read((char*) &m_filled, sizeof m_filled); \n      return ((bool) inStream); \n    } \n```", "```cpp\n    #ifndef LINE_H \n    #define LINE_H \n\n    #include <FStream> \n    using namespace std; \n\n    #include \"Figure.h\" \n\n    class Line : public Figure { \n      public: \n      Line(); \n      FigureId getId() const {return LineId;} \n      In addition to the  \n      Line(const Line& line); \n      Figure* clone() const; \n\n      void initializePoints(QPoint point); \n```", "```cpp\n    bool isClick(QPoint mousePoint); \n```", "```cpp\n    bool isInside(QRect area); \n```", "```cpp\n    void doubleClick(QPoint /* mousePoint */) {/* Empty. */} \n```", "```cpp\n    void modify(QSize distance); \n    void move(QSize distance); \n```", "```cpp\n    QRect area() const; \n    void draw(QPainter& painter) const; \n\n    bool write(ofstream& outStream) const; \n    bool read(ifstream& inStream); \n```", "```cpp\n      private: \n         enum {FirstPoint, LastPoint, MoveLine} m_lineMode; \n         QPoint m_firstPoint, m_lastPoint; \n```", "```cpp\n    static bool isPointInLine(QPoint m_firstPoint, \n                              QPoint m_lastPoint, QPoint point); \n    }; \n\n    #endif \n```", "```cpp\n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"Line.h\" \n```", "```cpp\n    Line::Line() \n    :m_lineMode(LastPoint) { \n      // Empty. \n    } \n```", "```cpp\n    Line::Line(const Line& line) \n     :Figure(line), \n       m_firstPoint(line.m_firstPoint), \n       m_lastPoint(line.m_lastPoint) { \n      // Empty. \n     } \n```", "```cpp\n    Figure* Line::clone() const { \n      Line* linePtr = new Line(*this); \n      return linePtr; \n    } \n```", "```cpp\n    void Line::initializePoints(QPoint point) { \n      m_firstPoint = point; \n      m_lastPoint = point; \n    } \n```", "```cpp\n    bool Line::isClick(QPoint mousePoint) { \n      QRect firstSquare(makeRect(m_firstPoint, Tolerance)); \n\n     if (firstSquare.contains(mousePoint)) { \n       m_lineMode = FirstPoint; \n       return true; \n     } \n```", "```cpp\n    QRect lastSquare(makeRect(m_lastPoint, Tolerance)); \n\n    if (lastSquare.contains(mousePoint)) { \n      m_lineMode = LastPoint; \n      return true; \n    } \n```", "```cpp\n    if (isPointInLine(m_firstPoint, m_lastPoint, mousePoint)) { \n      m_lineMode = MoveLine; \n      return true; \n    } \n```", "```cpp\n    return false; \n    } \n```", "```cpp\n    bool Line::isInside(QRect area) { \n     return area.contains(m_firstPoint) && \n       area.contains(m_lastPoint); \n    } \n```", "```cpp\n    bool Line::isPointInLine(QPoint m_firstPoint, QPoint m_lastPoint,\n                         QPoint point) {\n  if (m_firstPoint.x() == m_lastPoint.x()) {\n    QRect lineRect(m_firstPoint, m_lastPoint);\n    lineRect.normalized();\n    lineRect += Tolerance;\n    return lineRect.contains(point);\n  }\n  else {\n    QPoint leftPoint = (m_firstPoint.x() < m_lastPoint.x())\n                       ? m_firstPoint : m_lastPoint,\n           rightPoint = (m_firstPoint.x() < m_lastPoint.x())\n                       ? m_lastPoint : m_firstPoint;\n\n    if ((leftPoint.x() <= point.x()) &&\n        (point.x() <= rightPoint.x())) {\n      int lineWidth = rightPoint.x() - leftPoint.x(),\n          lineHeight = rightPoint.y() - leftPoint.y();\n\n      int diffWidth = point.x() - leftPoint.x(),\n          diffHeight = point.y() - leftPoint.y();\n\n      double delta = fabs(diffHeight -\n               (diffWidth * ((double) lineHeight) / lineWidth));\n      return (delta <= Tolerance);\n    }\n\n    return false;\n  }\n}\n```", "```cpp\n    void Line::modify(QSize distance) { \n      switch (m_lineMode) { \n        case FirstPoint: \n        m_firstPoint += distance; \n        break; \n\n        case LastPoint: \n        m_lastPoint += distance; \n        break; \n\n        case MoveLine: \n        move(distance); \n        break; \n      } \n    } \n```", "```cpp\n    void Line::move(QSize distance) { \n      m_firstPoint += distance; \n      m_lastPoint += distance; \n    } \n```", "```cpp\n    void Line::draw(QPainter& painter) const { \n      painter.setPen(color()); \n      painter.drawLine(m_firstPoint, m_lastPoint); \n\n      if (marked()) { \n        painter.fillRect(makeRect(m_firstPoint, Tolerance), \n                     Qt::black); \n        painter.fillRect(makeRect(m_lastPoint, Tolerance), \n                     Qt::black); \n      } \n    } \n```", "```cpp\n    QRect Line::area() const { \n      QRect lineArea(m_firstPoint, m_lastPoint); \n      lineArea.normalized(); \n\n      if (marked()) { \n         lineArea += Tolerance; \n      } \n\n      return lineArea; \n    } \n```", "```cpp\n    bool Line::write(ofstream& outStream) const { \n      Figure::write(outStream); \n      writePoint(outStream, m_firstPoint); \n      writePoint(outStream, m_lastPoint); \n      return ((bool) outStream); \n    } \n\n    bool Line::read(ifstream& inStream) { \n      Figure::read(inStream); \n      readPoint(inStream, m_firstPoint); \n      readPoint(inStream, m_lastPoint); \n      return ((bool) inStream); \n    } \n```", "```cpp\n    #ifndef RECTANGLE_H \n    #define RECTANGLE_H \n\n    #include <FStream> \n    using namespace std; \n\n    #include \"Figure.h\" \n\n    class RectangleX : public Figure { \n      public: \n      RectangleX(); \n      virtual FigureId getId() const {return RectangleId;} \n\n      RectangleX(const RectangleX& rectangle); \n      Figure* clone() const; \n\n      virtual void initializePoints(QPoint point); \n\n      virtual bool isClick(QPoint mousePoint); \n      virtual void modify(QSize distance); \n\n      virtual bool isInside(QRect area); \n      virtual void doubleClick(QPoint mousePoint); \n\n      virtual void move(QSize distance); \n      virtual QRect area() const; \n      virtual void draw(QPainter& painter) const; \n\n      virtual bool write(ofstream& outStream) const; \n      virtual bool read(ifstream& inStream); \n\n      private: \n        enum {TopLeftPoint, TopRightPoint, BottomRightPoint,  \n            BottomLeftPoint, MoveRectangle} m_rectangleMode; \n\n      protected: \n        QPoint m_topLeft, m_bottomRight; \n    }; \n\n    #endif \n```", "```cpp\n    #include <CAssert> \n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"Rectangle.h\" \n```", "```cpp\n    RectangleX::RectangleX() \n    :m_rectangleMode(BottomRightPoint) { \n      // Empty. \n    } \n```", "```cpp\n    RectangleX::RectangleX(const RectangleX& rectangle) \n    :Figure(rectangle), \n      m_topLeft(rectangle.m_topLeft), \n      m_bottomRight(rectangle.m_bottomRight) { \n      // Empty. \n    } \n```", "```cpp\n    Figure* RectangleX::clone() const { \n      RectangleX* rectanglePtr = new RectangleX(*this); \n      return rectanglePtr; \n    } \n\n    void RectangleX::initializePoints(QPoint point) { \n      m_topLeft = point; \n      m_bottomRight = point; \n    } \n```", "```cpp\n    bool RectangleX::isClick(QPoint mousePoint) { \n      QRect topLeftRect(makeRect(m_topLeft, Tolerance)); \n\n      if (topLeftRect.contains(mousePoint)) { \n        m_rectangleMode = TopLeftPoint; \n        return true; \n      } \n```", "```cpp\n     QPoint topRightPoint(m_bottomRight.x(), m_topLeft.y()); \n     QRect topRectRight(makeRect(topRightPoint, Tolerance)); \n\n     if (topRectRight.contains(mousePoint)) { \n       m_rectangleMode = TopRightPoint; \n       return true; \n     } \n```", "```cpp\n     QRect m_bottomRightRect(makeRect(m_bottomRight, Tolerance)); \n\n     if (m_bottomRightRect.contains(mousePoint)) { \n       m_rectangleMode = BottomRightPoint; \n       return true; \n     } \n```", "```cpp\n    QPoint bottomLeftPoint(m_topLeft.x(), m_bottomRight.y()); \n    QRect bottomLeftRect(makeRect(bottomLeftPoint, Tolerance)); \n\n    if (bottomLeftRect.contains(mousePoint)) { \n      m_rectangleMode = BottomLeftPoint; \n      return true; \n    } \n```", "```cpp\n  QRect areaRect(m_topLeft, m_bottomRight); \n\n  if (filled()) { \n    if (areaRect.contains(mousePoint)) { \n      m_rectangleMode = MoveRectangle; \n      return true; \n    } \n  } \n```", "```cpp\n     else { \n       QRect largeAreaRect(areaRect), smallAreaRect(areaRect); \n\n      largeAreaRect += Tolerance; \n      smallAreaRect -= Tolerance; \n\n      if (largeAreaRect.contains(mousePoint) && \n         !smallAreaRect.contains(mousePoint)) { \n           m_rectangleMode = MoveRectangle; \n           return true; \n        } \n     } \n```", "```cpp\n      return false; \n    } \n```", "```cpp\n     bool RectangleX::isInside(QRect area) { \n       return area.contains(m_topLeft) && \n         area.contains(m_bottomRight); \n     } \n```", "```cpp\n     void RectangleX::doubleClick(QPoint mousePoint) { \n       if (isClick(mousePoint)) { \n```", "```cpp\n     filled() = !filled(); \n    } \n  } \n```", "```cpp\n   void RectangleX::modify(QSize distance) { \n     switch (m_rectangleMode) { \n       case TopLeftPoint: \n       m_topLeft += distance; \n       break; \n\n       case TopRightPoint: \n       m_topLeft.setY(m_topLeft.y() + distance.height()); \n       m_bottomRight.setX(m_bottomRight.x() + distance.width()); \n       break; \n\n       case BottomRightPoint: \n       m_bottomRight += distance; \n       break; \n\n       case BottomLeftPoint: \n       m_topLeft.setX(m_topLeft.x() + distance.width()); \n       m_bottomRight.setY(m_bottomRight.y() + distance.height()); \n       break; \n\n       case MoveRectangle: \n       move(distance); \n       break; \n      } \n   } \n```", "```cpp\n    void RectangleX::move(QSize distance) { \n      m_topLeft += distance; \n      m_bottomRight += distance; \n    } \n```", "```cpp\n    QRect RectangleX::area() const { \n      QRect areaRect(m_topLeft, m_bottomRight); \n      areaRect.normalized(); \n\n      if (marked()) { \n        areaRect += Tolerance; \n      } \n\n      return areaRect; \n    } \n```", "```cpp\n    void RectangleX::draw(QPainter& painter) const { \n      painter.setPen(color()); \n\n      if (filled()) { \n        painter.fillRect(QRect(m_topLeft, m_bottomRight), color()); \n      } \n      else { \n        painter.setBrush(Qt::NoBrush); \n        painter.drawRect(QRect(m_topLeft, m_bottomRight)); \n      } \n```", "```cpp\n    if (marked()) { \n      painter.fillRect(makeRect(m_topLeft, Tolerance), Qt::black); \n      QPoint topRight(m_bottomRight.x(), m_topLeft.y()); \n      painter.fillRect(makeRect(topRight, Tolerance), Qt::black); \n      painter.fillRect(makeRect(m_bottomRight, Tolerance), \n                     Qt::black); \n      QPoint bottomLeft(m_topLeft.x(), m_bottomRight.y()); \n      painter.fillRect(makeRect(bottomLeft, Tolerance), Qt::black); \n    } \n  } \n```", "```cpp\n    bool RectangleX::write(ofstream& outStream) const { \n     Figure::write(outStream); \n     writePoint(outStream, m_topLeft); \n     writePoint(outStream, m_bottomRight); \n     return ((bool) outStream); \n    } \n\n    bool RectangleX::read (ifstream& inStream) { \n      Figure::read(inStream); \n      readPoint(inStream, m_topLeft); \n      readPoint(inStream, m_bottomRight); \n      return ((bool) inStream); \n } \n```", "```cpp\n    #ifndef ELLIPSE_H \n    #define ELLIPSE_H \n\n    #include \"Rectangle.h\" \n\n    class EllipseX : public RectangleX { \n      public: \n      EllipseX(); \n      FigureId getId() const {return EllipseId;} \n\n      EllipseX(const EllipseX& ellipse); \n      Figure* clone() const; \n```", "```cpp\n    bool isClick(QPoint mousePoint); \n```", "```cpp\n    void modify(QSize distance); \n    void draw(QPainter& painter) const; \n```", "```cpp\n     private: \n       enum {CreateEllipse, LeftPoint, TopPoint, RightPoint, \n           BottomPoint, MoveEllipse} m_ellipseMode; \n       }; \n\n       #endif \n```", "```cpp\n    #include <CAssert> \n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"Ellipse.h\" \n```", "```cpp\n     EllipseX::EllipseX() \n      :m_ellipseMode(CreateEllipse) { \n      // Empty. \n     } \n```", "```cpp\n    EllipseX::EllipseX(const EllipseX& ellipse) \n    :RectangleX(ellipse) { \n      // Empty. \n    } \n\n    Figure* EllipseX::clone() const { \n      EllipseX* ellipsePtr = new EllipseX(*this); \n      return ellipsePtr; \n    } \n```", "```cpp\n    bool EllipseX::isClick(QPoint mousePoint) { \n      QPoint leftPoint(m_topLeft.x(), \n                   (m_topLeft.y() + m_bottomRight.y()) / 2); \n      QRect leftRect(makeRect(leftPoint, Tolerance)); \n\n      if (leftRect.contains(mousePoint)) { \n        m_ellipseMode = LeftPoint; \n        return true; \n      } \n\n      QPoint topPoint((m_topLeft.x() + m_bottomRight.x()) / 2, \n                  m_topLeft.y()); \n      QRect topRect(makeRect(topPoint, Tolerance)); \n\n      if (topRect.contains(mousePoint)) { \n        m_ellipseMode = TopPoint; \n        return true; \n      } \n\n      QPoint rightPoint(m_bottomRight.x(), \n                    (m_topLeft.y() + m_bottomRight.y()) / 2); \n      QRect rightRect(makeRect(rightPoint, Tolerance)); \n\n      if (rightRect.contains(mousePoint)) { \n        m_ellipseMode = RightPoint; \n        return true; \n      } \n\n      QPoint bottomPoint((m_topLeft.x() + m_bottomRight.x()) / 2, \n                     m_bottomRight.y()); \n      QRect bottomRect(makeRect(bottomPoint, Tolerance)); \n\n      if (bottomRect.contains(mousePoint)) { \n        m_ellipseMode = BottomPoint; \n        return true; \n      } \n```", "```cpp\n    QRect normalRect(m_topLeft, m_bottomRight); \n    normalRect.normalized(); \n\n    if (filled()) { \n      QRegion normalEllipse(normalRect, QRegion::Ellipse); \n\n      if (normalEllipse.contains(mousePoint)) { \n        m_ellipseMode = MoveEllipse; \n        return true; \n      } \n    } \n```", "```cpp\n     else { \n       QRect largeRect(normalRect), smallRect(normalRect); \n       largeRect += Tolerance; \n       smallRect -= Tolerance; \n\n       QRegion largeEllipse(largeRect, QRegion::Ellipse), \n            smallEllipse(smallRect, QRegion::Ellipse); \n\n       if (largeEllipse.contains(mousePoint) && \n           !smallEllipse.contains(mousePoint)) { \n         m_ellipseMode = MoveEllipse; \n         return true; \n       } \n     } \n```", "```cpp\n      return false; \n   } \n```", "```cpp\n    void EllipseX::modify(QSize distance) { \n      switch (m_ellipseMode) { \n        case CreateEllipse: \n        m_bottomRight += distance; \n        break; \n\n        case LeftPoint: \n        m_topLeft.setX(m_topLeft.x() + distance.width()); \n        break; \n\n        case RightPoint: \n        m_bottomRight.setX(m_bottomRight.x() + distance.width()); \n        break; \n\n        case TopPoint: \n        m_topLeft.setY(m_topLeft.y() + distance.height()); \n        break; \n\n        case BottomPoint: \n        m_bottomRight.setY(m_bottomRight.y() + distance.height()); \n        break; \n\n        case MoveEllipse: \n        move(distance); \n        break; \n      } \n    } \n```", "```cpp\n    void EllipseX::draw(QPainter& painter) const { \n      painter.setPen(color()); \n\n      if (filled()) { \n        painter.setBrush(color()); \n        painter.drawEllipse(QRect(m_topLeft, m_bottomRight)); \n      } \n      else { \n        painter.setBrush(Qt::NoBrush); \n        painter.drawEllipse(QRect(m_topLeft, m_bottomRight)); \n      } \n```", "```cpp\n   if (marked()) {\n    QPoint leftPoint(m_topLeft.x(),\n                     (m_topLeft.y() + m_bottomRight.y())/2);\n    painter.fillRect(makeRect(leftPoint, Tolerance), Qt::black);\n\n    QPoint topPoint((m_topLeft.x() + m_bottomRight.x()) / 2,\n                    m_topLeft.y());\n    painter.fillRect(makeRect(topPoint, Tolerance), Qt::black);\n\n    QPoint rightPoint(m_bottomRight.x(),\n                      (m_topLeft.y() + m_bottomRight.y()) / 2);\n    painter.fillRect(makeRect(rightPoint, Tolerance), Qt::black);\n\n    QPoint bottomPoint((m_topLeft.x() + m_bottomRight.x()) / 2,\n                       m_bottomRight.y());\n    painter.fillRect(makeRect(bottomPoint, Tolerance), Qt::black);\n  }\n}\n```", "```cpp\n    #ifndef DRAWINGWINDOW_H \n    #define DRAWINGWINDOW_H \n\n    #include <QMainWindow> \n    #include <QActionGroup> \n\n    #include \"..\\MainWindow\\MainWindow.h\" \n    #include \"DrawingWidget.h\" \n\n    class DrawingWindow : public MainWindow { \n      Q_OBJECT \n\n      public: \n      DrawingWindow(QWidget *parentWidget = nullptr); \n      ~DrawingWindow(); \n\n      public: \n      void closeEvent(QCloseEvent *eventPtr) \n           { m_drawingWidgetPtr->closeEvent(eventPtr); } \n\n      private: \n       DrawingWidget* m_drawingWidgetPtr; \n       QActionGroup* m_figureGroupPtr; \n    }; \n\n    #endif // DRAWINGWINDOW_H \n```", "```cpp\n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"DrawingWindow.h\" \n```", "```cpp\nDrawingWindow::DrawingWindow(QWidget *parentWidget /*= nullptr*/)\n :MainWindow(parentWidget) {\n  resize(1000, 500);\n\n  m_drawingWidgetPtr = new DrawingWidget(this);\n  setCentralWidget(m_drawingWidgetPtr);\n  addFileMenu();\n  addEditMenu();\n```", "```cpp\n    { QMenu* formatMenuPtr = menuBar()->addMenu(tr(\"F&ormat\")); \n       connect(formatMenuPtr, SIGNAL(aboutToShow()), \n            this, SLOT(onMenuShow())); \n\n      addAction(formatMenuPtr, tr(\"&Color\"), \n              SLOT(onColor()), QKeySequence(Qt::ALT + Qt::Key_C), \n              QString(), nullptr, tr(\"Figure Color\")); \n\n      addAction(formatMenuPtr, tr(\"&Fill\"), \n              SLOT(onFill()), QKeySequence(Qt::CTRL + Qt::Key_F), \n              QString(), nullptr, tr(\"Figure Fill\"), \n              LISTENER(isFillEnabled)); \n```", "```cpp\n     m_figureGroupPtr = new QActionGroup(this); \n     addAction(formatMenuPtr, tr(\"&Modify\"), \n              SLOT(onModify()), \n              QKeySequence(Qt::CTRL + Qt::Key_M), \n              QString(), nullptr, tr(\"Modify Figure\"), nullptr, \n              LISTENER(isModifyChecked), m_figureGroupPtr); \n```", "```cpp\n    { QMenu* figureMenuPtr = \n               formatMenuPtr->addMenu(tr(\"&Figure\")); \n      connect(figureMenuPtr, SIGNAL(aboutToShow()), \n              this, SLOT(onMenuShow())); \n\n      addAction(figureMenuPtr, tr(\"&Line\"), \n                SLOT(onLine()), \n                QKeySequence(Qt::CTRL + Qt::Key_L), \n                QString(), nullptr, tr(\"Line Figure\"), nullptr, \n                LISTENER(isLineChecked), m_figureGroupPtr); \n\n      addAction(figureMenuPtr, tr(\"&Rectangle\"), \n                SLOT(onRectangle()), \n                QKeySequence(Qt::CTRL + Qt::Key_R), \n                QString(), nullptr, tr(\"Rectangle Figure\"), \n                nullptr, LISTENER(isRectangleChecked), \n                m_figureGroupPtr); \n\n      addAction(figureMenuPtr, tr(\"&Ellipse\"), \n                SLOT(onEllipse()), \n                QKeySequence(Qt::CTRL + Qt::Key_E), \n                QString(), nullptr, tr(\"Ellipse Figure\"), nullptr, \n                LISTENER(isEllipseChecked), m_figureGroupPtr); \n    } \n  } \n} \n\nDrawingWindow::~DrawingWindow() { \n  delete m_figureGroupPtr; \n} \n```", "```cpp\n    #ifndef DRAWINGWIDGET_H \n    #define DRAWINGWIDGET_H \n\n    #include \"..\\MainWindow\\MainWindow.h\" \n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"Figure.h\" \n\n    class DrawingWidget : public DocumentWidget { \n      Q_OBJECT \n\n      public: \n      DrawingWidget(QWidget* parentWidget); \n      ~DrawingWidget(); \n\n      public: \n      void mousePressEvent(QMouseEvent *eventPtr); \n      void mouseMoveEvent(QMouseEvent *eventPtr); \n      void mouseReleaseEvent(QMouseEvent *eventPtr); \n      void mouseDoubleClickEvent(QMouseEvent *eventPtr); \n      void paintEvent(QPaintEvent *eventPtr); \n\n      private: \n      void newDocument(void); \n      bool writeFile(const QString& filePath); \n      bool readFile(const QString& filePath); \n      Figure* createFigure(FigureId figureId); \n```", "```cpp\n     public slots: \n       bool isCopyEnabled(); \n       void onCopy(void); \n       bool isPasteEnabled(); \n       void onPaste(void); \n       void onDelete(void); \n       void onColor(void); \n\n       DEFINE_LISTENER(DrawingWidget, isFillEnabled); \n       void onFill(void); \n\n       DEFINE_LISTENER(DrawingWidget, isModifyChecked); \n       void onModify(void); \n\n       DEFINE_LISTENER(DrawingWidget, isLineChecked); \n       void onLine(void); \n\n       DEFINE_LISTENER(DrawingWidget, isRectangleChecked); \n       void onRectangle(void); \n\n       DEFINE_LISTENER(DrawingWidget, isEllipseChecked); \n       void onEllipse(void); \n```", "```cpp\n  private: \n    enum ApplicationMode {Idle, ModifySingle, ModifyRectangle}; \n    ApplicationMode m_applicationMode = Idle; \n    void setApplicationMode(ApplicationMode mode);\n```", "```cpp\n    enum ActionMode {Modify, Add}; \n    ActionMode m_actionMode = Add; \n    FigureId m_addFigureId = LineId; \n```", "```cpp\n    QColor m_nextColor = Qt::black; \n    bool m_nextFilled = false; \n```", "```cpp\n    QPoint m_mousePoint; \n```", "```cpp\n    QList<Figure*> m_figurePtrList, m_copyPtrList; \n```", "```cpp\n     QRect m_insideRectangle; \n   }; \n\n   #endif // DRAWINGWIDGET_H \n```", "```cpp\n    #include <CAssert> \n    #include \"..\\MainWindow\\DocumentWidget.h\" \n\n    #include \"DrawingWidget.h\" \n    #include \"Line.h\" \n    #include \"Rectangle.h\" \n    #include \"Ellipse.h\" \n```", "```cpp\n    DrawingWidget::DrawingWidget(QWidget* parentWidget) \n    :DocumentWidget(tr(\"Drawing Advanced\"), \n                 tr(\"Drawing files (*.drw)\"), \n                 parentWidget) { \n       // Empty. \n    }  \n```", "```cpp\n    DrawingWidget::~DrawingWidget() { \n       // Empty. \n    } \n```", "```cpp\n    void DrawingWidget::setApplicationMode(ApplicationMode mode) { \n      m_applicationMode = mode; \n      ((MainWindow*) parent())->onMenuShow(); \n} \n```", "```cpp\n    void DrawingWidget::newDocument(void) { \n      for (Figure* figurePtr : m_figurePtrList) { \n      delete figurePtr; \n    } \n\n    for (Figure* copyPtr : m_copyPtrList) { \n      delete copyPtr; \n    } \n\n    m_figurePtrList.clear(); \n    m_copyPtrList.clear(); \n```", "```cpp\n      m_nextColor = Qt::black; \n      m_nextFilled = false; \n      m_actionMode = Add; \n      m_addFigureId = LineId; \n    } \n```", "```cpp\n    bool DrawingWidget::writeFile(const QString& filePath) { \n      ofstream outStream(filePath.toStdString()); \n```", "```cpp\n  if (outStream) { \n    writeColor(outStream, m_nextColor); \n    outStream.write((char*) &m_nextFilled, sizeof m_nextFilled); \n```", "```cpp\n      int size = m_figurePtrList.size(); \n      outStream.write((char*) &size, sizeof size); \n```", "```cpp\n    for (Figure* figurePtr : m_figurePtrList) { \n      FigureId figureId = figurePtr->getId(); \n      outStream.write((char*) &figureId, sizeof figureId); \n      figurePtr->write(outStream); \n    } \n```", "```cpp\n    return ((bool) outStream); \n  } \n```", "```cpp\n   return false; \n  } \n```", "```cpp\n    bool DrawingWidget::readFile(const QString& filePath) { \n      ifstream inStream(filePath.toStdString()); \n```", "```cpp\n    if (inStream) { \n      readColor(inStream, m_nextColor); \n      inStream.read((char*) &m_nextFilled, sizeof m_nextFilled);\n```", "```cpp\n    int size; \n    inStream.read((char*) &size, sizeof size); \n```", "```cpp\n    for (int count = 0; count < size; ++count) { \n      FigureId figureId = (FigureId) 0; \n      inStream.read((char*) &figureId, sizeof figureId); \n      Figure* figurePtr = createFigure(figureId); \n      figurePtr->read(inStream); \n      m_figurePtrList.push_back(figurePtr); \n    } \n```", "```cpp\n     return ((bool) inStream); \n   } \n```", "```cpp\n  return false; \n} \n```", "```cpp\n    Figure* DrawingWidget::createFigure(FigureId figureId) { \n      Figure* figurePtr = nullptr; \n\n      switch (figureId) { \n        case LineId: \n         figurePtr = new Line(); \n         break; \n\n         case RectangleId: \n         figurePtr = new RectangleX(); \n         break; \n\n         case EllipseId: \n         figurePtr = new EllipseX(); \n         break; \n      } \n\n      return figurePtr; \n    } \n```", "```cpp\n    bool DrawingWidget::isCopyEnabled() { \n      for (Figure* figurePtr : m_figurePtrList) { \n        if (figurePtr->marked()) { \n          return true; \n        } \n      } \n\n      return false; \n    } \n```", "```cpp\n    void DrawingWidget::onCopy(void) { \n      for (Figure* copyPtr : m_copyPtrList) { \n         delete copyPtr; \n      } \n\n      m_copyPtrList.clear(); \n```", "```cpp\n   for (Figure* figurePtr : m_figurePtrList) { \n     if (figurePtr->marked()) { \n       m_copyPtrList.push_back(figurePtr->clone()); \n     } \n   } \n} \n```", "```cpp\n   bool DrawingWidget::isPasteEnabled() { \n      return !m_copyPtrList.isEmpty(); \n   } \n```", "```cpp\n    void DrawingWidget::onPaste(void) { \n      for (Figure* copyPtr : m_copyPtrList) { \n        Figure* pastePtr = copyPtr->clone(); \n        pastePtr->move(QSize(10, 10)); \n        m_figurePtrList.push_back(pastePtr); \n      } \n```", "```cpp\n     update(); \n  } \n```", "```cpp\n    void DrawingWidget::onDelete(void) { \n       for (Figure* figurePtr : m_figurePtrList) { \n         if (figurePtr->marked()) { \n         m_figurePtrList.removeOne(figurePtr); \n         delete figurePtr; \n       } \n     } \n```", "```cpp\n     update(); \n  } \n```", "```cpp\n    void DrawingWidget::onColor(void) { \n      QColor newColor = QColorDialog::getColor(m_nextColor, this); \n```", "```cpp\n    if (newColor.isValid() && (m_nextColor != newColor)) { \n      m_nextColor = newColor; \n      setModifiedFlag(true); \n\n      for (Figure* figurePtr : m_figurePtrList) { \n        if (figurePtr->marked()) { \n          figurePtr->color() = m_nextColor; \n```", "```cpp\n          update(); \n         } \n       } \n     } \n   } \n```", "```cpp\n    bool DrawingWidget::isFillEnabled(void) { \n      switch (m_actionMode) { \n```", "```cpp\n    case Modify: \n      for (Figure* figurePtr : m_figurePtrList) { \n        if (figurePtr->marked() && \n            ((figurePtr->getId() == RectangleId) || \n             (figurePtr->getId() == EllipseId))) { \n          return true; \n        } \n      } \n```", "```cpp\n      return false; \n```", "```cpp\n    case Add: \n      return (m_addFigureId == RectangleId) || \n             (m_addFigureId == EllipseId); \n    } \n```", "```cpp\n    assert(false); \n    return true; \n   } \n```", "```cpp\n    void DrawingWidget::onFill(void) { \n      switch (m_actionMode) { \n```", "```cpp\n    case Modify: \n      for (Figure* figurePtr : m_figurePtrList) { \n        if (figurePtr->marked()) { \n          figurePtr->filled() = !figurePtr->filled(); \n          update(); \n        } \n      } \n```", "```cpp\n      m_nextFilled = !m_nextFilled; \n      break; \n```", "```cpp\n    case Add: \n       m_nextFilled = !m_nextFilled; \n       break; \n    } \n  } \n```", "```cpp\n    bool DrawingWidget::isModifyChecked(void) { \n      return (m_actionMode == Modify); \n    } \n```", "```cpp\n    void DrawingWidget::onModify(void) { \n      m_actionMode = Modify; \n    } \n```", "```cpp\n    bool DrawingWidget::isLineChecked(void) { \n      return (m_actionMode == Add) && (m_addFigureId == LineId); \n    } \n```", "```cpp\n    void DrawingWidget::onLine(void) { \n      m_actionMode = Add; \n      m_addFigureId = LineId; \n    } \n```", "```cpp\n    bool DrawingWidget::isRectangleChecked(void) { \n      return (m_actionMode == Add) && (m_addFigureId == RectangleId); \n    } \n```", "```cpp\n    void DrawingWidget::onRectangle(void) { \n      m_actionMode = Add; \n      m_addFigureId = RectangleId; \n    } \n```", "```cpp\n    bool DrawingWidget::isEllipseEnabled(void) { \n      return !isEllipseChecked(); \n    } \n```", "```cpp\n    void DrawingWidget::onEllipse(void) { \n      m_actionMode = Add; \n      m_addFigureId = EllipseId; \n    }  \n```", "```cpp\n    void DrawingWidget::mousePressEvent(QMouseEvent* eventPtr) { \n       if (eventPtr->buttons() == Qt::LeftButton) { \n       m_mousePoint = eventPtr->pos(); \n```", "```cpp\n    switch (m_actionMode) { \n      case Modify: { \n          for (Figure* figurePtr : m_figurePtrList) { \n           figurePtr->marked() = false; \n          } \n```", "```cpp\n     m_clickedFigurePtr = nullptr; \n     for (QList<Figure*>::reverse_iterator iterator = \n         m_figurePtrList.rbegin(); \n     iterator != m_figurePtrList.rend(); ++iterator) { \n        Figure* figurePtr = *iterator; \n```", "```cpp\n    if (figurePtr->isClick(m_mousePoint)) { \n      setApplicationMode(ModifySingle); \n      m_clickedFigurePtr = figurePtr; \n      figurePtr->marked() = true; \n      m_figurePtrList.removeOne(figurePtr); \n      m_figurePtrList.push_back(figurePtr); \n      break; \n    } \n  } \n```", "```cpp\n    if (m_clickedFigurePtr == nullptr) { \n      setApplicationMode(ModifyRectangle); \n      m_insideRectangle = QRect(m_mousePoint, m_mousePoint); \n    } \n    } \n    break; \n```", "```cpp\n      case Add: { \n          Figure* newFigurePtr = createFigure(m_addFigureId); \n          newFigurePtr->color() = m_nextColor; \n          newFigurePtr->filled() = m_nextFilled; \n          newFigurePtr->initializePoints(m_mousePoint); \n```", "```cpp\n      m_figurePtrList.push_back(newFigurePtr); \n      setApplicationMode(ModifySingle); \n      setModifiedFlag(true); \n      } \n      break; \n    } \n```", "```cpp\n        update(); \n      } \n    } \n```", "```cpp\n    void DrawingWidget::mouseMoveEvent(QMouseEvent* eventPtr) { \n      if (eventPtr->buttons() == Qt::LeftButton) { \n        QPoint newMousePoint = eventPtr->pos(); \n        QSize distance(newMousePoint.x() - m_mousePoint.x(), \n                       newMousePoint.y() - m_mousePoint.y()); \n        m_mousePoint = newMousePoint; \n```", "```cpp\n    switch (m_applicationMode) { \n      case ModifySingle: \n        m_figurePtrList.back()->modify(distance); \n        setModifiedFlag(true); \n        break; \n```", "```cpp\n    case ModifyRectangle: \n      m_insideRectangle.setBottomRight(m_mousePoint); \n      break; \n    } \n```", "```cpp\n        update(); \n      } \n   } \n```", "```cpp\n     void DrawingWidget::mouseReleaseEvent(QMouseEvent* eventPtr) { \n       if (eventPtr->buttons() == Qt::LeftButton) { \n         switch (m_applicationMode) { \n           case ModifyRectangle: { \n             QList<Figure*> insidePtrList; \n```", "```cpp\n    for (Figure* figurePtr : m_figurePtrList) { \n      if (figurePtr->isInside(m_insideRectangle)) { \n        figurePtr->marked() = true; \n        m_figurePtrList.removeOne(figurePtr); \n        insidePtrList.push_back(figurePtr); \n      } \n    } \n```", "```cpp\n    for (Figure* figurePtr : insidePtrList) { \n      m_figurePtrList.removeOne(figurePtr); \n    } \n```", "```cpp\n    m_figurePtrList.append(insidePtrList); \n    } \n    break; \n    } \n```", "```cpp\n       setApplicationMode(Idle); \n       update(); \n      } \n    } \n```", "```cpp\n    void DrawingWidget::mouseDoubleClickEvent(QMouseEvent \n       *eventPtr) { \n      if ((eventPtr->buttons() == Qt::LeftButton) && \n          (m_clickedFigurePtr != nullptr)) { \n        m_clickedFigurePtr->doubleClick(eventPtr->pos()); \n        update(); \n      } \n    } \n```", "```cpp\n    void DrawingWidget::paintEvent(QPaintEvent* /* \n       eventPtr */) { \n     QPainter painter(this); \n     painter.setRenderHint(QPainter::Antialiasing); \n     painter.setRenderHint(QPainter::TextAntialiasing); \n```", "```cpp\n     for (Figure* figurePtr : m_figurePtrList) { \n       figurePtr->draw(painter); \n     } \n```", "```cpp\n    if (m_applicationMode == ModifyRectangle) { \n      painter.setPen(Qt::lightGray); \n      painter.setBrush(Qt::NoBrush); \n      painter.drawRect(m_insideRectangle); \n    } \n  } \n```", "```cpp\n    #include \"DrawingWindow.h\" \n    #include <QApplication> \n\n    int main(int argc, char *argv[]) { \n      QApplication application(argc, argv); \n      DrawingWindow drawingWindow; \n      drawingWindow.show(); \n      return application.exec(); \n    } \n```", "```cpp\n    #ifndef EDITORWINDOW_H \n    #define EDITORWINDOW_H \n\n    #include <QMainWindow> \n    #include <QActionGroup> \n    #include <QPair> \n    #include <QMap> \n\n    #include \"..\\MainWindow\\MainWindow.h\" \n    #include \"EditorWidget.h\" \n\n    class EditorWindow : public MainWindow { \n      Q_OBJECT \n\n      public: \n      EditorWindow(QWidget *parentWidgetPtr = nullptr); \n      ~EditorWindow(); \n\n      protected: \n      void keyPressEvent(QKeyEvent* eventPtr); \n      void closeEvent(QCloseEvent* eventPtr); \n\n      private: \n      EditorWidget* m_editorWidgetPtr; \n      QActionGroup* m_alignmentGroupPtr; \n    }; \n\n    #endif // EDITORWINDOW_H \n```", "```cpp\n#include \"EditorWindow.h\" \n#include <QtWidgets> \n```", "```cpp\nEditorWindow::EditorWindow(QWidget *parentWidgetPtr /*= nullptr*/)\n :MainWindow(parentWidgetPtr) {\n  resize(1000, 500);\n\n  m_editorWidgetPtr = new EditorWidget(this);\n  setCentralWidget(m_editorWidgetPtr);\n  addFileMenu();\n  addEditMenu();\n```", "```cpp\n      { QMenu* formatMenuPtr = menuBar()->addMenu(tr(\"F&ormat\")); \n       connect(formatMenuPtr, SIGNAL(aboutToShow()), this, \n            SLOT(onMenuShow())); \n       addAction(formatMenuPtr, tr(\"&Font\"), SLOT(onFont()), \n              0, QString(), nullptr, QString(), \n              LISTENER(isFontEnabled)); \n\n       { QMenu* alignmentMenuPtr = \n             formatMenuPtr->addMenu(tr(\"&Alignment\")); \n        connect(alignmentMenuPtr, SIGNAL(aboutToShow()), \n              this, SLOT(onMenuShow())); \n```", "```cpp\n       QToolBar* alignmentToolBarPtr = addToolBar(tr(\"Alignment\")); \n       m_alignmentGroupPtr = new QActionGroup(this); \n\n       addAction(alignmentMenuPtr, tr(\"&Left\"), SLOT(onLeft()), \n                QKeySequence(Qt::ALT + Qt::Key_L), tr(\"left\"), \n                alignmentToolBarPtr, tr(\"Left-aligned text\"), \n                nullptr, LISTENER(isLeftChecked)); \n       addAction(alignmentMenuPtr, tr(\"&Center\"), \n                SLOT(onCenter()), \n                QKeySequence(Qt::ALT + Qt::Key_C), \n                tr(\"center\"), alignmentToolBarPtr, \n                tr(\"Center-aligned text\"), nullptr, \n                LISTENER(isCenterChecked)); \n       addAction(alignmentMenuPtr, tr(\"&Right\"), \n                SLOT(onRight()), \n                QKeySequence(Qt::ALT + Qt::Key_R), \n                tr(\"right\"), alignmentToolBarPtr, \n                tr(\"Right-aligned text\"), nullptr, \n                LISTENER(isRightChecked)); \n       } \n     } \n\n     m_editorWidgetPtr->setModifiedFlag(false); \n    } \n\n    EditorWindow::~EditorWindow() { \n     delete m_alignmentGroupPtr; \n    } \n```", "```cpp\n    void EditorWindow::keyPressEvent(QKeyEvent* eventPtr) { \n      m_editorWidgetPtr->keyPressEvent(eventPtr); \n    }\n```", "```cpp\n\n    void EditorWindow::closeEvent(QCloseEvent* eventPtr) { \n      m_editorWidgetPtr->closeEvent(eventPtr); \n    } \n```", "```cpp\n    #ifndef EDITORWIDGET_H \n    #define EDITORWIDGET_H \n\n    #include <QWidget> \n    #include <QMap> \n    #include <QMenu> \n    #include <QToolBar> \n    #include <QPair> \n    #include \"Caret.h\" \n\n    #include \"..\\MainWindow\\Listener.h\" \n    #include \"..\\MainWindow\\DocumentWidget.h\" \n\n    class EditorWidget : public DocumentWidget { \n      Q_OBJECT \n\n      public: \n      EditorWidget(QWidget* parentWidgetPtr); \n      void keyPressEvent(QKeyEvent* eventPtr); \n\n      private: \n      void keyEditPressEvent(QKeyEvent* eventPtr); \n      void keyMarkPressEvent(QKeyEvent* eventPtr); \n```", "```cpp\n    public: \n      void mousePressEvent(QMouseEvent* eventPtr); \n      void mouseMoveEvent(QMouseEvent* eventPtr); \n      void mouseReleaseEvent(QMouseEvent* eventPtr); \n\n    private: \n      int mouseToIndex(QPoint point); \n\n    public: \n      void paintEvent(QPaintEvent* eventPtr); \n      void resizeEvent(QResizeEvent* eventPtr); \n```", "```cpp\n    private: \n      void newDocument(void); \n      bool writeFile(const QString& filePath); \n      bool readFile(const QString& filePath); \n\n    public slots: \n      bool isCopyEnabled(); \n      void onCopy(void); \n      bool isPasteEnabled(); \n      void onPaste(void); \n      void onDelete(void); \n\n      DEFINE_LISTENER(EditorWidget, isFontEnabled); \n      void onFont(void); \n```", "```cpp\n    DEFINE_LISTENER(EditorWidget, isLeftChecked); \n    DEFINE_LISTENER(EditorWidget, isCenterChecked); \n    DEFINE_LISTENER(EditorWidget, isRightChecked); \n```", "```cpp\n      void onLeft(void); \n      void onCenter(void); \n      void onRight(void); \n\n      private: \n       void setCaret(); \n       void simulateMouseClick(int x, int y); \n```", "```cpp\n    private: \n      enum Mode {Edit, Mark} m_mode; \n```", "```cpp\n     enum Alignment {Left, Center, Right} m_alignment; \n```", "```cpp\n    int m_editIndex, m_firstIndex, m_lastIndex; \n```", "```cpp\n    Caret m_caret; \n```", "```cpp\n     QString m_editorText, m_copyText; \n```", "```cpp\n    QList<QPair<int,int>> m_lineList; \n```", "```cpp\n    QFont m_textFont; \n    int m_fontHeight; \n```", "```cpp\n    Qt::MouseButton m_button; \n```", "```cpp\n    void calculate(); \n```", "```cpp\n     QList<QRect> m_rectList; \n    }; \n\n    #endif // EDITORWIDGET_H \n```", "```cpp\n    #include \"EditorWidget.h\" \n    #include <QtWidgets> \n    #include <CAssert> \n    using namespace std; \n```", "```cpp\n    EditorWidget::EditorWidget(QWidget* parentWidgetPtr) \n     :DocumentWidget(tr(\"Editor Advanced\"), \n         tr(\"Editor files (*.edi)\"), parentWidgetPtr), \n```", "```cpp\n      m_textFont(tr(\"Times New Roman\"), 12), \n        m_mode(Edit), \n        m_editIndex(0), \n        m_alignment(Left), \n        m_caret(this) { \n```", "```cpp\n     calculate(); \n     setCaret(); \n     m_caret.show(); \n   } \n```", "```cpp\n    void EditorWidget::newDocument(void) { \n      m_mode = Edit; \n      m_editIndex = 0; \n      m_textFont = QFont(tr(\"Times New Roman\"), 12); \n      m_editorText.clear(); \n      calculate(); \n      setCaret(); \n    } \n```", "```cpp\n    bool EditorWidget::writeFile(const QString& filePath) { \n      QFile file(filePath); \n      if (file.open(QIODevice::WriteOnly | QIODevice::Text)) { \n      QTextStream outStream(&file); \n      outStream << m_textFont.toString() << endl << m_editorText; \n```", "```cpp\n     return ((bool) outStream.Ok); \n   } \n```", "```cpp\n     return false; \n   } \n```", "```cpp\n    bool EditorWidget::readFile(const QString& filePath) { \n      QFile file(filePath); \n\n      if (file.open(QIODevice::ReadOnly | QIODevice::Text)) { \n        QTextStream inStream(&file); \n        m_textFont.fromString(inStream.readLine()); \n        m_editorText = inStream.readAll(); \n```", "```cpp\n      calculate(); \n      setCaret(); \n```", "```cpp\n     return ((bool) inStream.Ok); \n    } \n```", "```cpp\n    return false; \n   } \n```", "```cpp\n    bool EditorWidget::isCopyEnabled() { \n      return (m_mode == Mark); \n    } \n```", "```cpp\n    void EditorWidget::onCopy(void) { \n      int minIndex = qMin(m_firstIndex, m_lastIndex), \n      maxIndex = qMax(m_firstIndex, m_lastIndex); \n\n      m_copyText = \n        m_editorText.mid(minIndex, maxIndex - minIndex + 1); \n    } \n```", "```cpp\n    bool EditorWidget::isPasteEnabled() { \n      return !m_copyText.isEmpty(); \n    } \n```", "```cpp\n    void EditorWidget::onPaste(void) { \n      if (m_mode == Mark) { \n         onDelete(); \n      } \n```", "```cpp\n     m_editorText.insert(m_editIndex, m_copyText); \n     m_editIndex += m_copyText.size(); \n```", "```cpp\n     calculate(); \n     setCaret(); \n     setModifiedFlag(true); \n     update(); \n     } \n```", "```cpp\n    void EditorWidget::onDelete(void) { \n      QKeyEvent event(QEvent::KeyPress, Qt::Key_Delete, \n                  Qt::NoModifier); \n      keyPressEvent(&event); \n    } \n```", "```cpp\n    bool EditorWidget::isFontEnabled() { \n      return (m_mode == Edit); \n    } \n```", "```cpp\n     void EditorWidget::onFont(void) { \n       bool pressedOkButton; \n       QFont newFont = \n         QFontDialog::getFont(&pressedOkButton, m_textFont, this); \n```", "```cpp\n      if (pressedOkButton) { \n        m_textFont = newFont; \n        setModifiedFlag(true); \n```", "```cpp\n      calculate(); \n      m_caret.set(m_rectList[m_editIndex]); \n      update(); \n     } \n   } \n```", "```cpp\n    bool EditorWidget::isLeftChecked(void) { \n      return (m_alignment == Left); \n    } \n\n    bool EditorWidget::isCenterChecked(void) { \n      return (m_alignment == Center); \n    } \n\n    bool EditorWidget::isRightChecked(void) { \n      return (m_alignment == Right); \n    } \n```", "```cpp\n    void EditorWidget::onLeft(void) { \n      m_alignment = Left; \n      setModifiedFlag(true); \n      calculate(); \n      setCaret(); \n      update(); \n    } \n\n    void EditorWidget::onCenter(void) { \n      m_alignment = Center; \n      setModifiedFlag(true); \n      calculate(); \n      setCaret(); \n      update(); \n    } \n\n    void EditorWidget::onRight(void) { \n      m_alignment = Right; \n      setModifiedFlag(true); \n      calculate(); \n      setCaret(); \n      update(); \n    } \n```", "```cpp\n    void EditorWidget::mousePressEvent(QMouseEvent* eventPtr) { \n      if (eventPtr->buttons() == Qt::LeftButton) { \n         m_firstIndex = m_lastIndex = mouseToIndex(eventPtr->pos()); \n         m_mode = Mark; \n         m_caret.hide(); \n       } \n    } \n```", "```cpp\n    void EditorWidget::mouseMoveEvent(QMouseEvent* eventPtr) { \n      if (eventPtr->buttons() == Qt::LeftButton) { \n         m_lastIndex = mouseToIndex(eventPtr->pos()); \n         update(); \n      } \n    } \n```", "```cpp\n    void EditorWidget::mouseReleaseEvent(QMouseEvent* eventPtr) { \n      if (eventPtr->buttons() == Qt::LeftButton) { \n        if (m_firstIndex == m_lastIndex) { \n          m_mode = Edit; \n          m_editIndex = m_firstIndex; \n          setCaret(); \n          m_caret.show(); \n          update(); \n        } \n      } \n    } \n```", "```cpp\n     void EditorWidget::keyPressEvent(QKeyEvent* eventPtr) { \n       switch (m_mode) { \n         case Edit: \n         keyEditPressEvent(eventPtr); \n         break; \n\n         case Mark: \n         keyMarkPressEvent(eventPtr); \n         break; \n       } \n     }\n```", "```cpp\n    void EditorWidget::keyEditPressEvent(QKeyEvent* eventPtr) { \n      switch (eventPtr->key()) { \n```", "```cpp\n     case Qt::Key_Left: \n       if (m_editIndex > 0) { \n          --m_editIndex; \n       } \n       break; \n```", "```cpp\n    case Qt::Key_Right: \n      if (m_editIndex < m_editorText.size()) { \n        ++m_editIndex; \n      } \n      break; \n```", "```cpp\n     case Qt::Key_Up: { \n       QRect charRect = m_rectList[m_editIndex]; \n\n       if (charRect.top() > 0) { \n         int x = charRect.left() + (charRect.width() / 2), \n             y = charRect.top() - 1; \n         simulateMouseClick(x, y); \n       } \n     } \n     break; \n```", "```cpp\n     case Qt::Key_Down: { \n       QRect charRect = m_rectList[m_editIndex]; \n       int x = charRect.left() + (charRect.width() / 2), \n           y = charRect.bottom() + 1; \n       simulateMouseClick(x, y); \n     } \n     break; \n```", "```cpp\n    case Qt::Key_Delete: \n      if (m_editIndex < m_editorText.size()) { \n        m_editorText.remove(m_editIndex, 1); \n        setModifiedFlag(true); \n      } \n      break; \n```", "```cpp\n     case Qt::Key_Backspace: \n     if (m_editIndex > 0) { \n       --m_editIndex; \n       onDelete(); \n     } \n     break; \n```", "```cpp\n    case Qt::Key_Return: \n      m_editorText.insert(m_editIndex++, 'n'); \n      setModifiedFlag(true); \n      break; \n```", "```cpp\n     default: { \n        QString text = eventPtr->text(); \n\n        if (!text.isEmpty()) { \n          m_editorText.insert(m_editIndex++, text[0]); \n          setModifiedFlag(true); \n        } \n     } \n     break; \n    } \n```", "```cpp\n    calculate(); \n    setCaret(); \n    update(); \n  } \n```", "```cpp\n    void EditorWidget::keyMarkPressEvent(QKeyEvent* eventPtr) { \n      switch (eventPtr->key()) { \n```", "```cpp\n    case Qt::Key_Left: { \n        int minIndex = qMin(m_firstIndex, m_lastIndex); \n\n        if (minIndex > 0) { \n          m_mode = Edit; \n          m_caret.show(); \n          m_editIndex = minIndex; \n        } \n      } \n      break; \n```", "```cpp\n    case Qt::Key_Right: { \n      int maxIndex = qMax(m_firstIndex, m_lastIndex); \n\n      if (maxIndex < m_editorText.size()) { \n        m_mode = Edit; \n        m_caret.show(); \n        m_editIndex = maxIndex;\n```", "```cpp\n      } \n    } \n    break; \n```", "```cpp\n     case Qt::Key_Up: { \n       QRect charRect = m_rectList[m_editIndex]; \n\n       if (charRect.top() > 0) { \n         int x = charRect.left() + (charRect.width() / 2), \n             y = charRect.top() - 1; \n         simulateMouseClick(x, y); \n       } \n     } \n     break; \n\n     case Qt::Key_Down: { \n        QRect charRect = m_rectList[m_editIndex]; \n        int x = charRect.left() + (charRect.width() / 2), \n            y = charRect.bottom() + 1; \n        simulateMouseClick(x, y); \n      } \n      break; \n```", "```cpp\n    case Qt::Key_Delete: \n    case Qt::Key_Backspace: { \n        int minIndex = qMin(m_firstIndex, m_lastIndex), \n            maxIndex = qMax(m_firstIndex, m_lastIndex); \n```", "```cpp\n        m_editorText.remove(minIndex, maxIndex - minIndex); \n        setModifiedFlag(true); \n        m_mode = Edit; \n        m_editIndex = minIndex; \n        m_caret.show(); \n      } \n      break; \n```", "```cpp\n     case Qt::Key_Return: \n       onDelete(); \n       m_editorText.insert(m_editIndex++, 'n'); \n       setModifiedFlag(true); \n       break; \n```", "```cpp\n    default: { \n       QString text = eventPtr->text(); \n\n       if (!text.isEmpty()) { \n         onDelete(); \n         m_editorText.insert(m_editIndex++, text[0]); \n         setModifiedFlag(true); \n       } \n    } \n    break; \n    } \n```", "```cpp\n     calculate(); \n     setCaret(); \n     update(); \n    } \n```", "```cpp\n    void EditorWidget::simulateMouseClick(int x, int y) { \n      QMouseEvent pressEvent(QEvent::MouseButtonPress, QPointF(x, y), \n          Qt::LeftButton, Qt::NoButton, Qt::NoModifier); \n      mousePressEvent(&pressEvent); \n      QMouseEvent releaseEvent(QEvent::MouseButtonRelease, \n                     QPointF(x, y), Qt::LeftButton, \n                     Qt::NoButton, Qt::NoModifier); \n      mousePressEvent(&releaseEvent); \n    } \n```", "```cpp\n    void EditorWidget::setCaret() { \n      QRect charRect = m_rectList[m_editIndex]; \n      QRect caretRect(charRect.left(), charRect.top(), \n                  1, charRect.height()); \n      m_caret.set(caretRect); \n    } \n```", "```cpp\n    int EditorWidget::mouseToIndex(QPoint point) { \n       int x = point.x(), y = point.y(); \n```", "```cpp\n    if (y > (m_fontHeight * m_lineList.size())) { \n      return m_editorText.size(); \n    } \n```", "```cpp\n    else { \n      int lineIndex = y / m_fontHeight; \n      QPair<int,int> lineInfo = m_lineList[lineIndex]; \n      int firstIndex = lineInfo.first, lastIndex = lineInfo.second; \n```", "```cpp\n     if (x < m_rectList[firstIndex].left()) { \n        return firstIndex; \n     } \n```", "```cpp\n    else if (x >= m_rectList[lastIndex].right()) { \n      return (lastIndex + 1); \n    } \n```", "```cpp\n     else { \n       for (int charIndex = firstIndex + 1; \n           charIndex <= lastIndex; ++charIndex){ \n           int left = m_rectList[charIndex].left(); \n```", "```cpp\n        if (x < left) { \n          int last = m_rectList[charIndex - 1].left(); \n          int leftSize = x - last, rightSize = left - x; \n          return (leftSize < rightSize) ? (charIndex - 1) \n                                        : charIndex; \n          } \n        } \n      } \n    } \n```", "```cpp\n      assert(false); \n      return 0; \n   } \n```", "```cpp\n    void EditorWidget::resizeEvent(QResizeEvent* eventPtr) { \n      calculate(); \n      DocumentWidget::resizeEvent(eventPtr); \n    } \n```", "```cpp\n    void EditorWidget::calculate() { \n      m_lineList.clear(); \n      m_rectList.clear(); \n```", "```cpp\n      QFontMetrics metrics(m_textFont); \n      m_fontHeight = metrics.height(); \n      QList<int> charWidthList, lineWidthList; \n      int windowWidth = width(); \n```", "```cpp\n     { int firstIndex = 0, lineWidth = 0; \n        for (int charIndex = 0; charIndex < m_editorText.size(); \n           ++charIndex) { \n          QChar c = m_editorText[charIndex]; \n```", "```cpp\n      if (c == 'n') { \n        charWidthList.push_back(1); \n        lineWidthList.push_back(lineWidth); \n        m_lineList.push_back \n                   (QPair<int,int>(firstIndex, charIndex)); \n        firstIndex = charIndex + 1; \n        lineWidth = 0; \n      } \n```", "```cpp\n      else { \n        int charWidth = metrics.width(c); \n        charWidthList.push_back(charWidth); \n```", "```cpp\n    if ((lineWidth + charWidth) > windowWidth) { \n       if (firstIndex == charIndex) { \n         lineWidthList.push_back(windowWidth); \n         m_lineList.push_back \n              (QPair<int,int>(firstIndex, charIndex)); \n         firstIndex = charIndex + 1; \n       } \n```", "```cpp\n       else { \n          lineWidthList.push_back(lineWidth); \n          m_lineList.push_back(QPair<int,int>(firstIndex, \n              charIndex - 1)); \n          firstIndex = charIndex; \n       } \n       lineWidth = 0; \n    } \n```", "```cpp\n    else { \n          lineWidth += charWidth; \n         } \n    } \n  } \n```", "```cpp\n      m_lineList.push_back(QPair<int,int>(firstIndex, \n           m_editorText.size() - 1)); \n      lineWidthList.push_back(lineWidth); \n    } \n```", "```cpp\n     { int top = 0, left; \n        for (int lineIndex = 0; lineIndex < m_lineList.size(); \n           ++lineIndex) { \n        QPair<int,int> lineInfo = m_lineList[lineIndex]; \n        int lineWidth = lineWidthList[lineIndex]; \n        int firstIndex = lineInfo.first, \n           lastIndex = lineInfo.second; \n```", "```cpp\n      switch (m_alignment) { \n        case Left: \n          left = 0; \n          break; \n```", "```cpp\n        case Center: \n          left = (windowWidth - lineWidth) / 2; \n          break; \n```", "```cpp\n       case Right: \n          left = windowWidth - lineWidth; \n          break; \n       } \n```", "```cpp\n     for (int charIndex = firstIndex; \n           charIndex <= lastIndex;++charIndex){ \n        int charWidth = charWidthList[charIndex]; \n        QRect charRect(left, top, charWidth, m_fontHeight); \n        m_rectList.push_back(charRect); \n        left += charWidth; \n     } \n```", "```cpp\n      if (lastIndex == (m_editorText.size() - 1)) { \n        QRect lastRect(left, top, 1, m_fontHeight); \n        m_rectList.push_back(lastRect); \n      } \n```", "```cpp\n          top += m_fontHeight; \n        } \n      } \n    } \n```", "```cpp\n     void EditorWidget::paintEvent(QPaintEvent* /* eventPtr */) { \n       QPainter painter(this); \n       painter.setRenderHint(QPainter::Antialiasing); \n       painter.setRenderHint(QPainter::TextAntialiasing); \n       painter.setFont(m_textFont); \n```", "```cpp\n    int minIndex = qMin(m_firstIndex, m_lastIndex), \n       maxIndex = qMax(m_firstIndex, m_lastIndex); \n```", "```cpp\n     for (int index = 0; index < m_editorText.length(); ++index) { \n       QChar c = m_editorText[index]; \n```", "```cpp\n    if (c != 'n') { \n      if ((m_mode == Mark) && \n          (index >= minIndex) && (index < maxIndex)) { \n        painter.setPen(Qt::white); \n        painter.setBackground(Qt::black); \n      } \n```", "```cpp\n      else { \n        painter.setPen(Qt::black); \n        painter.setBrush(Qt::white); \n      } \n```", "```cpp\n      QRect rect = m_rectList[index]; \n      painter.drawText(rect, c); \n    } \n  } \n```", "```cpp\n      m_caret.paint(&painter); \n    } \n```", "```cpp\n#include \"EditorWindow.h\" \n#include <QApplication> \n\nint main(int argc, char *argv[]) { \n  QApplication application(argc, argv); \n  EditorWindow editorWindow; \n  editorWindow.show(); \n  return application.exec(); \n} \n```"]