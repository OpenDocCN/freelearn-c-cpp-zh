- en: Working with UE4 APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **application programming interface** (**API**) is the way in which you,
    as the programmer, instruct the engine, and therefore the PC, what to do. Some
    of the interesting APIs that we''ll explore in the recipes in this chapter are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Core/Logging API – defining a custom log category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core/Logging API – FMessageLog to write messages to the Message Log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core/Math API – rotation using FRotator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core/Math API – rotation using FQuat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core/Math API – rotation using FRotationMatrix to have one object face another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Landscape API – landscape generation with Perlin noise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foliage API – adding trees procedurally to your level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Landscape and Foliage APIs – map generation using Landscape and Foliage APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayAbilities API – triggering an actor's gameplay abilities with game controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayAbilities API – implementing stats with AttributeSet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayAbilities API – implementing buffs with GameplayEffect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayTags API – attaching GameplayTags to an actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayTasks API – making things happen with GameplayTasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP API – downloading web pages using web requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP API – displaying downloaded progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of UE4's functionality is encapsulated in modules, including very basic
    and core functionality. Each module has an API for it. To use an API, there is
    a very important linkage step, where you must list all APIs that you will be using
    in your build in a `ProjectName.Build.cs` file, which is located in your Solution
    Explorer window.
  prefs: []
  type: TYPE_NORMAL
- en: Do not name any of your UE4 projects with the exact same name as one of the
    UE4 API names!
  prefs: []
  type: TYPE_NORMAL
- en: There are a variety of APIs inside the UE4 engine that expose functionality
    to various essential parts of it.
  prefs: []
  type: TYPE_NORMAL
- en: The UE4 engine's base functionality, which is available in the editor, is quite
    broad. The functionality from C++ code is actually grouped into little sections
    called APIs. There is a separate API module for each important functionality in
    the UE4 codebase. This is done to keep the codebase highly organized and modular.
  prefs: []
  type: TYPE_NORMAL
- en: Using different APIs may require special linkage in your `Build.cs` file! If
    you are getting build errors, be sure to check that the linkage with the correct
    APIs is there!
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete API listing is located in the following documentation: [https://docs.unrealengine.com/latest/INT/API/](https://docs.unrealengine.com/latest/INT/API/).'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Core/Logging API – defining a custom log category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UE4 itself defines several logging categories, including categories such as
    `LogActor`, which has any log messages to do with the `Actor` class, and `LogAnimation`,
    which logs messages about animations. In general, UE4 defines a separate logging
    category for each module. This allows developers to output their log messages
    to different logging streams. Each log stream''s name is prefixed to the outputted
    message, as shown in the following example log messages from the engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These log messages are samples from the engine, each prefixed with their log
    category. Warning messages appear in yellow and have Warning added to the front
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example code you will find on the internet tends to use `LogTemp` for a
    UE4 project''s own messages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can actually improve upon this formula by defining our own custom `LogCategory`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a UE4 project ready in which you'd like to define a custom log. Open a
    header file that will be included in almost all files using this log.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the main header file for your project; for example, if your project''s
    name is `Chapter_11`, you''ll open `Chapter_11.h`. Add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As defined in `AssertionMacros.h`, there are three arguments to this declaration,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CategoryName`: This is the log category name being defined (`LogCh11` here)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultVerbosity`: This is the default verbosity to use on log messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompileTimeVerbosity`: This is the verbosity to bake into compiled code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the main `.cpp` file for your project (`Chapter_11.cpp` in our case),
    include the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use this log category in our own scripts. As an example, open up
    your project''s `GameModeBase` file (in this case, `Chapter_11GameModeBase.h`)
    and add the following function declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go to the implementation (`Chapter_11GameModeBase.cpp`) and use the following
    code as an example of the various display categories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your scripts. Afterwards, open the World Settings menu and set the
    GameMode Override property to `Chapter_11GameModeBase` and then run the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5e64d7dd-1c39-4e0b-80fe-1556f7b9cf2b.png)'
  prefs: []
  type: TYPE_IMG
- en: The location of the logged messages from the Output Log window
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we can see our custom log messages being displayed!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging works by outputting messages to the Output Log (Window | Developer Tools
    | Output Log) as well as a file. All information outputted to the Output Log is
    also mirrored to a simple text file that is located in your project's `/Saved/Logs`
    folder. The extension of the log files is `.log`, with the most recent one being
    named `YourProjectName.log`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can enable or suppress log messages for a particular log channel from within
    the editor using the following console commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you'd like to edit the initial values of the output levels of some of the
    built-in log types, you can use a C++ class to create changes for the `engine.ini`
    config file. You can change the initial values in the `engine.ini` configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime](https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '`UE_LOG` sends its output to Output Window. If you''d like to use the more
    specialized Message Log window in addition to this, you can use the `FMessageLog`
    object to write your output messages. `FMessageLog` writes to both the Message
    Log and the Output Window. See the next recipe for details.'
  prefs: []
  type: TYPE_NORMAL
- en: Core/Logging API – FMessageLog to write messages to the Message Log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FMessageLog` is an object that allows you to write output messages to the
    Message Log (Window | Developer Tools | Message Log) and Output Log (Window |
    Developer Tools | Output Log) simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have your project ready and some information to log to Message Log. Display
    the Message Log (Window | Developer Tools | Message Log) in your UE4 Editor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add `#define` to your main header file (`ProjectName.h`), defining `LOCTEXT_NAMESPACE`
    as something unique to your codebase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This `#define` is used by the `LOCTEXT()` macro, which we use to generate `FText`
    objects, but is not seen in output messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare your `FMessageLog` by constructing it somewhere very global. You can
    use `extern` in your `ProjectName.h` file. Consider the following piece of code
    as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create your `FMessageLog` by defining it in a `.cpp` file and registering
    it with `MessageLogModule`. Be sure to give your logger a clear and unique name
    on construction. It''s the category of your log that will appear to the left of
    your log messages in Output Log. For example, `ProjectName.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, head back to somewhere in your code to actually create the log and use
    it. For example, we can add the following `GameModeBase` class''s `BeginPlay`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `KEY` to `LOCTEXT` (first argument) must be unique or you will get a previously
    hashed string back. If you''d like, you can include a `#define` that repeats the
    argument to `LOCTEXT` twice, as we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#define FTEXT(x) LOCTEXT(x, x)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log your messages using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code utilizes the `FTEXT()` macro we defined earlier. Ensure it is in your
    codebase.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe displays a message to the Message Log. As we discussed previously,
    you can see logged information at the Message Log (Window | Developer Tools | Message
    Log) and Output Log (Window | Developer Tools | Output Log) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructing your message log again after initialization retrieves a copy of
    the original message log. For example, at any place in the code, you can write
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FMessageLog( LoggerName ).Info(FTEXT( "An info message"));`'
  prefs: []
  type: TYPE_NORMAL
- en: Core/Math API – rotation using FRotator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rotation in UE4 has such a complete implementation that it can be hard to choose
    how to rotate your objects. There are three main methods: `FRotator`, `FQuat`,
    and `FRotationMatrix`. This recipe outlines the construction and use of the first
    of the three different methods for the rotation of objects—the `FRotator`. Using
    this, and the following two recipes, you can select a method to use to rotate
    your objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a UE4 project that has an object you can get a C++ interface with. For
    example, you can construct a C++ class Coin that derives from `Actor` to test
    out rotations. Override the `Coin::Tick()` method to apply your rotations from
    the C++ code. Alternatively, you can call these rotation functions in the `Tick`
    event from Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will rotate an object at a rate of one degree per second
    by making use of an Actor component. The actual rotation will be the accumulated
    time since the object was created. To get this value, we'll just call `GetWorld()->TimeSeconds`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the Modes tab, under the Place section and under Basic, drag and drop a
    Cube object into your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Details tab, go to the Transform component and change the Mobility
    property to Movable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterwards, click on the Add Component button and select New C++ Component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the menu that pops up, select Actor Component and select Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7df035bd-fc84-445a-bc58-40af6b94ac73.png)'
  prefs: []
  type: TYPE_IMG
- en: From there, give your component a name, for example, `RotateActorComponent`,
    and then press the Create Class button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct your `FRotator`. `FRotators` can be constructed using a stock pitch,
    yaw, and roll constructor, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `FRotator` will be constructed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The standard orientation for an object in UE4 is with Forward facing down the
    *+X*-axis. Right is the *+Y*-axis, and Up is *+Z*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pitch is rotation about the *Y*-axis (across), yaw is rotation about the *Z*-axis
    (up), and roll is rotation about the *X*-axis. This is best understood in the
    following three points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Pitch**: If you think of an airplane in UE4 standard coordinates, the *Y*-axis
    goes along the wingspan (pitching tilts it forward and backward)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yaw**: The *Z*-axis goes straight up and down (yawing turns it left and right)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roll**: The *X*-axis goes straight along the fuselage of the plane (rolling
    does barrel rolls)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should note that in other conventions, the *X*-axis is pitch, the *Y*-axis
    is yaw, and the *Z*-axis is roll.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply your `FRotator` to your actor using the `SetActorRotation` member function,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Core/Math API – rotation using FQuat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quaternions sound intimidating, but they are extremely easy to use. You may
    want to review the theoretical math behind them by viewing the following videos:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fantastic Quaternions* by Numberphile: [https://www.youtube.com/watch?v=3BR8tK-LuB0](https://www.youtube.com/watch?v=3BR8tK-LuB0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding Quaternions* by Jim Van Verth: [http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding](http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we won't cover the math background here! In fact, you don't need to
    understand much about the math background of quaternions to use them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a project ready and an `Actor` with an override `::Tick()` function that
    we can enter the C++ code into.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To construct a quaternion, the best constructor to use is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Quaternions have quaternion addition, quaternion subtraction, multiplication
    by a scalar, and division by a scalar defined for them, among other functions.
    They are extremely useful to rotate things at arbitrary angles, and point objects
    at one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you wanted to use an FQuat inside of the `RotateActorComponent.cpp`
    file, it would look similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon compiling your code and returning to the game, you should notice the cube
    moving at a constant rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddb86012-77dc-4859-ad2f-ea3689f90875.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quaternions are a bit strange, but using them is quite simple. If *v* is the
    axis around which to rotate, and ![](img/6edc4c6a-2cc5-4162-9d74-cd70b3b729b3.jpg) is
    the magnitude of the angle of rotation, then we get the following equations for
    the components of a quaternion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9dc711a-8f43-48f8-bc68-a56de59ad11f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, for example, rotation about ![](img/ac235d9d-5ef7-46a7-8ce4-0a18ed80d558.jpg) by
    an angle of ![](img/69cf02ef-9e27-44a6-9a4b-efdc00908cd8.jpg) will have the following
    quaternion components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3c4d321-4172-4dbe-9974-d6e0b6c8fe89.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Three of the four components of the quaternion (*x*, *y*, and *z*) define the
    axis around which to rotate (scaled by the sine of half the angle of rotation),
    while the fourth component (*w*) has only the cosine of half the angle to rotate
    with.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quaternions, being vectors themselves, can be rotated. Simply extract the (*x*,
    *y*, *z*) components of the quaternion, normalize, and then rotate that vector.
    Construct a new quaternion from that new unit vector with the desired angle of
    rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying quaternions together represents a series of rotations that happen
    subsequently. For example, a rotation of 45º about the *X*-axis, followed by a
    rotation of 45º about the *Y*-axis will be composed by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give you a result that would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4bbdb04-e68b-48f2-abea-f943c4029dfd.png)'
  prefs: []
  type: TYPE_IMG
- en: API – rotation using FRotationMatrix to have one object face another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FRotationMatrix` offers matrix construction using a series of `::Make*` routines.
    They are easy to use and useful to get one object to face another. Say you have
    two objects, one of which is following the other. We want the rotation of the
    follower to always be facing what it is following. The construction methods of
    `FRotationMatrix` make this easy to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have two actors in a scene, one of which should face the other.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a new C++ Actor Component for the follower called `FollowActorComponent`
    (see the *Core/Math API – rotation using FRotator* recipe if you need help with
    this).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the `FollowActorComponent.h` file, we need to have a reference to the
    object we want to follow, so add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then, in the `FollowActorComponent.cpp` file, in the `TickComponent` function,
    look into the available constructors under the `FRotationMatrix` class. A bunch
    of constructors are available that will let you specify a rotation for an object
    (from stock position) by reorienting one or more of the *X*-, *Y*-, or *Z*-axes,
    named with the `FRotationMatrix::Make*()` pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assuming you have a default stock orientation for your actor (with Forward
    facing down the *+X*-axis, and up facing up the *+Z*-axis), find the vector from
    the follower to the object they want to follow, as shown in this piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your script and assign the Target property inside of the Follow Actor
    Component from the Details tab. This can be done using the eyedropper button to
    the right of the property or by using the drop-down list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/37b4eeb3-2998-4d99-b3cf-0d6e219be4d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If all went well, you should see the actor rotate correctly to face the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c28f774e-1745-4d24-bcd7-8d7986021a0c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting one object to look at another, with a desired up vector, can be done
    by calling the correct function, depending on your object''s stock orientation.
    Usually, you want to reorient the *X*-axis (Forward), while specifying either
    the *Y*-axis (Right) or *Z*-axis (Up) vectors (`FRotationMatrix::MakeFromXY()`).
    For example, to make an actor look along a `lookAlong` vector, with its right
    side facing right, we''d construct and set `FRotationMatrix` for it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: GameplayAbilities API – triggering an actor's gameplay abilities with game controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **GameplayAbilities** API can be used to attach C++ functions to invoke
    on certain button pushes, triggering the game unit to exhibit its abilities during
    play in response to keystroke events. In this recipe, we will show you how to
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumerate and describe your game character's abilities. You will need to know
    what your character does in response to key events to code in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several objects that we need to use here; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UGameplayAbility` class—this is needed to derive the C++ class instances
    of the `UGameplayAbility` class, with one derivative class for each ability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define what each ability does in `.h` and `.cpp` by overriding the available
    functions, such as `UGameplayAbility::ActivateAbility`, `UGameplayAbility::InputPressed`,
    `UGameplayAbility::CheckCost`, `UGameplayAbility::ApplyCost`, `UGameplayAbility::ApplyCooldown`,
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameplayAbilitiesSet` is a `DataAsset` derivative object that contains a series
    of enum''d command values, and blueprints of the corresponding `UGameplayAbility`
    derivative classes that define the behavior for that particular input command.
    Each GameplayAbility is kicked off by a keystroke or mouse-click, which is set
    in `DefaultInput.ini`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we''ll implement a `UGameplayAbility` derivative called
    `UGameplayAbility_Attack` for a `Warrior` class object. We''ll attach this gameplay
    functionality to the input command string `Ability1`, which we''ll activate on
    the left-mouse button-click:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your `.Build.cs` file (in our case, `Chapter_11.Build.cs`) and add
    the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Unreal Editor, go to Settings | Plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the menu that pops up, search for `GameplayAbilities` and check it. You''ll
    get a message asking if you are sure. Click on the Yes button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb27ba3b-6389-4a08-9651-614f0d31f7dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Afterwards, click on the Restart Now button. The classes should be added to
    your project correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, access the Add C++ Class wizard by selecting from the Content Browser
    Add New | New C++ Class... and check the Show All Classes option. From there,
    type in `gameplayability` and select the base GameplayAbility class to base our
    new class on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b731ae0b-66a3-40f4-a9d8-dae61e50aafb.png)'
  prefs: []
  type: TYPE_IMG
- en: Give the new gameplay ability a name of `GameplayAbility_Attack` and press Create
    Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the very least, you want to override the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UGameplayAbility_Attack::CanActivateAbility` member function to indicate
    when the actor is allowed to invoke the ability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UGameplayAbility_Attack::CheckCost` function to indicate whether the player
    can afford to use an ability or not. This is extremely important because if this
    returns false, ability invocation should fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UGameplayAbility_Attack::ActivateAbility` member function to write the
    code that the `Warrior` is to execute when their `Attack` ability is activated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `UGameplayAbility_Attack::InputPressed` member function and to respond
    to the key input event assigned to the ability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Derive a Blueprint class from your `UGameplayAbility_Attack` object inside the
    UE4 Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the Editor, navigate to Content Browser and create a `GameplayAbilitiesSet`
    object by doing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-clicking on Content Browser and selecting Miscellaneous | Data Asset:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/777500fc-befc-4e6b-b1ca-8924737f7ecf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the dialog box that follows, select `GameplayAbilitySet` for the Data Asset
    Class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/90023d90-6b67-4cc4-896a-ace1d96ee8c5.png)'
  prefs: []
  type: TYPE_IMG
- en: In fact, the `GameplayAbilitySet` object is a `UDataAsset` derivative. It is
    located in `GameplayAbilitySet.h` and contains a single member function, `GameplayAbilitySet::GiveAbilities()`,
    which I strongly recommend you not to use for reasons listed in a later step.
  prefs: []
  type: TYPE_NORMAL
- en: Name your `GameplayAbilitySet` data asset something related to the `WarriorAbilitySet`
    object so that we know to put it into the `Warrior` class (for example, `WarriorAbilitySet`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click to open and edit the new `WarriorAbilitySet` Data Asset. Stack
    in a list of `GameplayAbility` class derivative Blueprints by clicking + on the
    `TArray` object inside of it. Your `UGameplayAbility_Attack` object must appear
    in the dropdown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/01c90d63-775f-4669-8d74-a9e01192e4f7.png)'
  prefs: []
  type: TYPE_IMG
- en: We now need to create a `Character` class-derived object so that we can contain
    this ability set. In this example, we will call this class `Warrior`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `UPROPERTY UGameplayAbilitySet* gameplayAbilitySet` member to your `Warrior`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that your `Actor` class derivative also derives from the `UAbilitySystemInterface` interface.
    This is extremely important so that calls to `(Cast<IAbilitySystemInterface>(yourActor))->GetAbilitySystemComponent()` succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Blueprint of the `Warrior` class and set the Gameplay Ability Set
    to the Warrior Ability Set we created earlier, and set the Ability System Component
    to the Ability System Component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/16747445-09a2-4b0e-b317-85c07b104892.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are unable to see the Ability System Component, close and reopen the
    Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Once finished, assign `MyWarrior` as the Default Pawn Class of your Game Mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile, run, and select-in `WarriorAbilitySet` as it sits in Content Browser
    (created in Steps 5 to 7) of the abilities of which this `Warrior` is capable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some time after the construction of your actor, call `gameplayAbilitySet->GiveAbilities(
    abilitySystemComponent );` or enter a loop, as shown in the following step where
    you invoke `abilitySystemComponent->GiveAbility()` for each ability listed in
    your `gameplayAbilitySet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write an override for `AWarrior::SetupPlayerInputComponent( UInputComponent*
    Input )` to connect the input controller to the Warrior''s `GameplayAbility` activations.
    After doing so, iterate over each `GameplayAbility` listed in your `GameplayAbilitySet`''s
    Abilities group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your code and then play the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7cad0887-cbad-49f8-966b-83e6fc2d9f0d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must subclass and link in a set of `UGameplayAbility` objects to your actor's
    `UAbilitySystemComponent` object through a series of calls to `UAbilitySystemComponent::GiveAbility(
    spec )` with appropriately constructed `FGameplayAbilitySpec` objects. What this
    does is deck out your actor with this bunch of `GameplayAbilities`. The functionality
    of each `UGameplayAbility`, as well as its cost, cooldown, and activation, is
    all neatly contained within the `UGameplayAbility` class derivative that you will
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use  the `GameplayAbilitySet::GiveAbilities()` member function because
    it doesn't give you access to the set of `FGameplayAbilitySpecHandle` objects
    that you actually need later to bind and invoke the ability to an input component.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll want to carefully code in a bunch of the other functions that are available
    in the `GameplayAbility.h` header file, including implementations for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SendGameplayEvent`: This is a function to notify GameplayAbility that some
    general gameplay event has happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CancelAbility`: This is a function to stop an ability''s usage midway through,
    and to give the ability an interrupted state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that there are a bunch of existing `UPROPERTY` specifiers near
    the bottom of the `UGameplayAbility` class declaration that either activate or
    cancel the ability upon addition or removal of certain `GameplayTags`. See the
    following *GameplayTags API – attaching GameplayTags to an actor* recipe for more
    details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a bunch more! Explore the API and implement those functions you find
    to be useful in your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GameplayAbilities` API is a rich and nicely interwoven series of objects
    and functions. Explore `GameplayEffects`, `GameplayTags`, and `GameplayTasks`
    and how they integrate with the `UGameplayAbility` class to fully explore the
    functionality the library has to offer. You can read more about the API here: [https://api.unrealengine.com/INT/API/Plugins/GameplayAbilities/index.html](https://api.unrealengine.com/INT/API/Plugins/GameplayAbilities/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayAbilities API - Implementing stats with UAttributeSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GameplayAbilities` API allows you to associate a set of attributes, that
    is, `UAttributeSet`, to an Actor. `UAttributeSet` describes properties appropriate
    for that Actor's in-game attributes, such as `Hp`, `Mana`, `Speed`, `Armor`, `AttackDamage`,
    and so on. You can either define a single game-wide set of attributes common to
    all Actors, or several different sets of attributes appropriate for the different
    classes of actors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AbilitySystemComponent` is the first thing you will need to add to your actors
    to equip them to use the `GameplayAbilities` API and `UAttributeSet` classes.
    To define your custom `UAttributeSet`, you will simply derive from the `UAttributeSet`
    base class and extend the base class with your own series of `UPROPERTY` members.
    After that, you must register your custom `AttributeSet` with your `Actor` class''s `AbilitySystemComponent`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have not done so already, complete Steps 1-4 of the *GameplayAbilities
    API – triggering an actor's gameplay abilities with game controls* recipe to link
    to the `GameplayAbilities` API in your `ProjectName.Build.cs` file and enable
    its functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C++ class  by going to the Content Browser and selecting Add New
    | Add C++ Class. From the Add C++ Class menu, check the Show All Classes option.
    From there, type in `attr` and select `AttributeSet` as your parent class. From
    there, click the Next button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98d22785-cb67-4d52-b392-4c4424e5a76e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Give the class a Name of `GameUnitAttributeSet` and click on Create Class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df7f58db-1f4a-46d1-a5e5-3c5e43478d3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Once created, deck the class out with a set of `UPROPERTY` specifiers that you
    want each Actor to have in their property set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might want to declare your `UAttributeSet` derivate class
    similar to what''s given in the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If your code is networked, you might want to enable replication on each of the
    `UPROPERTY` specifiers with the replicated declaration in the `UPROPERTY` macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect `GameUnitAttributeSet` with your `AbilitySystemComponent` inside your
    `Actor` class. We can do this with the `Warrior` class we created previously by
    opening the `Warrior.h` file and adding the following function declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open `Warrior.cpp` and add the following `#include`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, implement that function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can put this call somewhere in `PostInitializeComponents()`, or in code
    that is called later than that.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have registered `UAttributeSet`, you can move on with the next recipe
    and apply `GameplayEffect` to some of the elements in the attribute set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure your `Actor` class object implements `IAbilitySystemInterface` by deriving
    from it. This is extremely important as the `UAbilitySet` object will attempt
    a cast to `IAbilitySystemInterface` to call `GetAbilitySystemComponent()` on it
    at various places in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UAttributeSets` simply allow you to enumerate and define attributes of different
    actors. `GameplayEffects` will be your means to make changes to the attributes
    of a specific actor.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can code in definitions of `GameplayEffects`, which will be things that
    act on the `AbilitySystemComponent`'s `AttributeSet` collections. You can also
    write `GameplayTasks` for generic functions that run at specific times or follow
    particular events, or even in response to a tag addition (`GameplayTagResponseTable.cpp`).
    You can define `GameplayTags` to modify `GameplayAbility` behavior, as well as
    select and match gameplay units during play.
  prefs: []
  type: TYPE_NORMAL
- en: GameplayAbilities API – implementing buffs with GameplayEffect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A buff is just an effect that introduces a temporary, permanent, or recurring
    change to a game unit's attributes from its `AttributeSet`. Buffs can either be
    good or bad, supplying either bonuses or penalties. For example, you might have
    a hex buff that slows a unit to half speed, an angel wing buff that increases
    unit speed by 2x, or a cherub buff that recovers `5 hp` every 5 seconds for 3
    minutes. A `GameplayEffect` affects an individual gameplay attribute in the `UAttributeSet` that's
    attached to an `AbilitySystemComponent` of an Actor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brainstorm your game units' effects that happen during the game. Be sure that
    you've created an `AttributeSet`, as shown in the previous recipe, with gameplay
    attributes that you'd like to affect. Select an effect to implement and follow
    the succeeding steps with your example.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to turn `LogAbilitySystem` into a `VeryVerbose` setting by going
    to the Output Log and typing `` ` ``, and then `Log LogAbilitySystem All`. This
    will display much more information from `AbilitySystem` in the Output Log, making
    it easier to see what's going on within the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we''ll construct a quick `GameplayEffect` that heals
    `50 hp` to the selected unit''s `AttributeSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `Warrior.h` file we created previously. In there, add the following
    function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, open up `Warrior.cpp` and add the following methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following code to implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `AddModifier` function to change the `Hp` field of `GameUnitAttributeSet`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill in the other properties of `GameplayEffect`, including fields such as
    `DurationPolicy` and `ChanceToApplyToTarget`, or any other fields that you''d
    like to modify, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the effect to an `AbilitySystemComponent` of your choice. The underlying
    `UAttributeSet` will be affected and modified by your call, as shown in the following
    piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GameplayEffects` are simply little objects that effect changes to an actor''s
    `AttributeSet`. `GameplayEffects` can occur once, or repeatedly, in intervals
    over a `Period`. You can program-in effects pretty quickly, and the `GameplayEffect`
    class creation is intended to be inline.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the `GameplayEffect` is active, you will receive an `FActiveGameplayEffectHandle`.
    You can use this handle to attach a function delegate to run when the effect is
    over using the `OnRemovedDelegate` member of the `FActiveGameplayEffectHandle`.
    For example, you might call the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: GameplayTasks API – making things happen with GameplayTasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GameplayTasks` are used to wrap up some gameplay functionality in a reusable
    object. All you have to do to use them is derive from the `UGameplayTask` base
    class and override some of the member functions that you prefer to implement.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have not done so already, complete Steps 1-4 of the *GameplayAbilities
    API – triggering an actor's gameplay abilities with game controls* recipe to link
    to the `GameplayTasks` API in your `ProjectName.Build.cs` file and enable its
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Afterwards, go in the UE4 Editor and navigate to Class Viewer by going to Window
    | Developer Tools | Class Viewer. Under Filters, uncheck the Actors Only and Placeable
    Only options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that the `GameplayTask` object type exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3294cedd-2012-4aee-b372-41fee61f3347.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click on File | Add C++ Class.... Choose to derive from `GameplayTask`. To
    do so, you must first tick Show All Classes, and then type `gameplaytask` into
    the filter box. Click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bcf5cdab-33de-40f8-82db-fc30adcbe46e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Name your C++ class (something like `GameplayTask_TaskName` is the convention),
    then add the class to your project. The example spawns a particle emitter and
    is called `GameplayTask_CreateParticles`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bbd3d5ad-3e83-46d0-abcb-5096ca481530.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once your `GameplayTask_CreateParticles.h` and `.cpp` pair are created, navigate
    to the `.h` file and update the class to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the `GameplayTask_CreateParticles.cpp` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up your `Warrior.h` file and add the following interface to the class
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, add the following new properties to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Below that, add the following function definitions for the `GameplayTaskOwnerInterface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, go to the `Warrior.cpp` file and update the class constructor to
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your scripts, return to the Unreal Editor, and compile your code. Once
    compiled, open your `Actor` class derivative (`MyWarrior`) and then scroll down
    to the Stats section and set the Particle System property to something you''d
    like to see, for instance, the `P_Fire` option if you included the sample content
    when you created your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e2540cdb-18c9-4567-9772-0bff4c83ab28.png)'
  prefs: []
  type: TYPE_IMG
- en: Which is available in the Full Blueprint Editor in the Components drop-down
    of the Components tab in the Blueprint editor. Add `GameplayTasksComponent` to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create and add an instance of your `GameplayTask` inside your `Actor` derivative
    (`MyWarrior`) instance using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code runs anywhere in your `Actor` class derivative, any time after `GameplayTasksComponent`
    is initialized (any time after `PostInitializeComponents()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile your code. Set your level to use `MyWarrior` as the Default Pawn Type
    and when the game starts, you should notice that the particle plays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d976d754-77a1-43dd-9906-1e21151058ec.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GameplayTasks` simply register with the `GameplayTasksComponent` situated
    inside an `Actor` class derivative of your choice. You can activate any number
    of `GameplayTasks` at any time during gameplay to trigger their effects.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameplayTasks` can also kick off `GameplayEffects` to change attributes of
    `AbilitySystemsComponents` if you wish.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can derive `GameplayTasks` for any number of events in your game. What's
    more is that you can override a few more virtual functions to hook into additional
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP API – downloading webpages using web requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're maintaining scoreboards or other such things that require regular
    HTTP request access to servers, you can use the HTTP API to perform such web request
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a server that you're allowed to request data via HTTP from. You can use
    a public server of any type to try out HTTP requests, if you'd like.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Link to the `HTTP` API in your `ProjectName.Build.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file that you will send your web request from (in my case, I''ll be
    using the `Chapter_11GameModeBase` class), include the new additions to the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Construct an `IHttpRequest` object from `FHttpModule` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`FHttpModule` is a singleton object. One copy of it exists for the entire program
    that you are meant to use for all interactions with the `FHttpModule` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach your function to run to the `IHttpRequest` object''s `FHttpRequestCompleteDelegate`,
    which has the following signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The delegate is found inside of the `IHttpRequest` object as `http->OnProcessRequestComplete()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few ways to attach a callback function to the delegate. You can
    use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A lambda using `delegate.BindLambda()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the URL of the site you''d like to hit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Process the request by calling `ProcessRequest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when you run this code, you should notice the contents of the URL you
    pointed to being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5de988c-e6c7-4509-a9af-9ff2c3a41881.png)'
  prefs: []
  type: TYPE_IMG
- en: HTML content of unrealengine.com displayed
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in this instance, it's a web page, but you can easily point this
    to a CSV file, text document, or anything to obtain information for your project!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP object is all you need to send off HTTP requests to a server and get
    HTTP responses. You can use the HTTP request/response for anything that you wish;
    for example, submitting scores to a high scores table or to retrieve text to display
    in-game from a server.
  prefs: []
  type: TYPE_NORMAL
- en: They are decked out with a URL to visit and a function callback to run when
    the request is complete. Finally, they are sent off via `FManager`. When the web
    server responds, your callback is called and the results of your HTTP response
    can be shown.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are also other ways in which you can attach a callback function to the
    delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using any UObject''s member function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You cannot attach to `UFunction` directly here as the `.BindUFunction()` command
    requests arguments that are all `UCLASS`, `USTRUCT`, or `UENUM`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With any plain old C++ object''s member function, using `.BindRaw`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You have to ensure that your `plainObject` refers to a valid object in memory
    at the time that the HTTP request completes. This means that you cannot use `TAutoPtr` on `plainObject`,
    because that will deallocate `plainObject` at the end of the block in which it
    is declared, but that may be before the HTTP request completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a global C-style static function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When using a delegate callback with an object, be sure that the object instance
    that you're calling back on lives on at least until the point at which the `HttpResponse` arrives
    back from the server. Processing the `HttpRequest` takes real time to run. It
    is a web request after all—think of waiting for a web page to load.
  prefs: []
  type: TYPE_NORMAL
- en: You have to be sure that the object instance on which you're calling the callback
    function has not deallocated on you between the time of the initial call and the
    invocation of your `HttpHandler` function. The object must still be in memory
    when the callback returns after the HTTP request completes.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot simply expect that the `HttpResponse` function happens immediately
    after you attach the callback function and call `ProcessRequest()`! Using a reference
    counted `UObject` instance to attach the `HttpHandler` member function is a good
    idea to ensure that the object stays in memory until the HTTP request completes.
  prefs: []
  type: TYPE_NORMAL
- en: You can see an example of all seven possible ways it can be used inside of the
    `Chapter_11GameModeBase.cpp` file in the Example Code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set additional HTTP request parameters via the following member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetVerb()`, to change whether you are using the `GET` or `POST` method in
    your HTTP request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetHeaders()`, to modify any general header settings you would like'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP API – displaying downloaded progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `IHttpRequest` object from the HTTP API will report HTTP download progress
    via a callback on a `FHttpRequestProgressDelegate`, which is accessible via `OnRequestProgress()`.
    The signature of the function we can attach to the `OnRequestProgress()` delegate
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The three parameters of the function you may write include the original `IHttpRequest`
    object, the bytes sent, and the bytes received so far. This function gets called
    back periodically until the `IHttpRequest` object completes, which is when the
    function you attach to `OnProcessRequestComplete()` when it gets called. You can
    use the values passed to your `HandleRequestProgress` function to find out your
    progress.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need an internet connection to use this recipe. We will be requesting
    a file from a public server. You can use a public server or your own private server
    for your HTTP request, if you'd like.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will bind a callback function to just the `OnRequestProgress()`
    delegate to display the download progress of a file from a server. Have a project
    ready where we can write a piece of code that will perform `IHttpRequest,` and
    a nice interface on which to display percentage progress.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Link to the `HTTP` API in your `ProjectName.Build.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct an `IHttpRequest` object using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a callback function to call when the request progresses, which updates
    our user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Process your request with `http->ProcessRequest()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `OnRequestProgress()` callback gets fired every so often with the bytes
    sent and bytes received HTTP progress. We will compute the total percentage of
    the download that is completed by calculating `(float)receivedBytes/totalLen`,
    where `totalLen` is the HTTP response's total length in bytes. Using the lambda
    function we attached to the `OnRequestProgress()` delegate callback, we can display
    the information through text.
  prefs: []
  type: TYPE_NORMAL
- en: With the code in the previous *How to do it...* section as a base, it would
    be possible to create a UMG widget for a progress bar and call the `.SetPercent()`
    member function to reflect the download's progress.
  prefs: []
  type: TYPE_NORMAL
