- en: Working with UE4 APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与UE4 API一起工作
- en: 'The **application programming interface** (**API**) is the way in which you,
    as the programmer, instruct the engine, and therefore the PC, what to do. Some
    of the interesting APIs that we''ll explore in the recipes in this chapter are
    as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）是程序员如何指令引擎，以及因此指令PC执行的方式。在本章的食谱中，我们将探索一些有趣的API，如下所示：'
- en: Core/Logging API – defining a custom log category
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心日志API - 定义自定义日志类别
- en: Core/Logging API – FMessageLog to write messages to the Message Log
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心日志API - 使用FMessageLog将消息写入消息日志
- en: Core/Math API – rotation using FRotator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心数学API - 使用FRotator进行旋转
- en: Core/Math API – rotation using FQuat
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心数学API - 使用FQuat进行旋转
- en: Core/Math API – rotation using FRotationMatrix to have one object face another
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心数学API - 使用FRotationMatrix进行旋转，使一个对象面向另一个对象
- en: Landscape API – landscape generation with Perlin noise
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地形API - 使用Perlin噪声生成地形
- en: Foliage API – adding trees procedurally to your level
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Foliage API - 以程序方式将树木添加到你的级别
- en: Landscape and Foliage APIs – map generation using Landscape and Foliage APIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地形和Foliage API - 使用地形和Foliage API进行地图生成
- en: GameplayAbilities API – triggering an actor's gameplay abilities with game controls
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameplayAbilities API - 使用游戏控制触发角色的游戏能力
- en: GameplayAbilities API – implementing stats with AttributeSet
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameplayAbilities API - 使用AttributeSet实现属性
- en: GameplayAbilities API – implementing buffs with GameplayEffect
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameplayAbilities API - 使用GameplayEffect实现增益效果
- en: GameplayTags API – attaching GameplayTags to an actor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameplayTags API - 将GameplayTags附加到角色
- en: GameplayTasks API – making things happen with GameplayTasks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameplayTasks API - 使用GameplayTasks使事物发生
- en: HTTP API – downloading web pages using web requests
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP API - 使用网络请求下载网页
- en: HTTP API – displaying downloaded progress
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP API - 显示下载进度
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: All of UE4's functionality is encapsulated in modules, including very basic
    and core functionality. Each module has an API for it. To use an API, there is
    a very important linkage step, where you must list all APIs that you will be using
    in your build in a `ProjectName.Build.cs` file, which is located in your Solution
    Explorer window.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: UE4的所有功能都封装在模块中，包括非常基本和核心的功能。每个模块都有一个API。要使用API，有一个非常重要的链接步骤，你必须在一个名为`ProjectName.Build.cs`的文件中列出你将在构建中使用的所有API，该文件位于你的解决方案资源管理器窗口中。
- en: Do not name any of your UE4 projects with the exact same name as one of the
    UE4 API names!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将你的任何UE4项目命名为与UE4 API名称完全相同！
- en: There are a variety of APIs inside the UE4 engine that expose functionality
    to various essential parts of it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: UE4引擎内部包含各种API，它们将功能暴露给其各个基本部分。
- en: The UE4 engine's base functionality, which is available in the editor, is quite
    broad. The functionality from C++ code is actually grouped into little sections
    called APIs. There is a separate API module for each important functionality in
    the UE4 codebase. This is done to keep the codebase highly organized and modular.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: UE4引擎的基础功能，在编辑器中可用，相当广泛。从C++代码中的功能实际上被分组到称为API的小部分中。在UE4代码库中，每个重要功能都有一个单独的API模块。这样做是为了保持代码库高度组织和模块化。
- en: Using different APIs may require special linkage in your `Build.cs` file! If
    you are getting build errors, be sure to check that the linkage with the correct
    APIs is there!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的API可能需要在你的`Build.cs`文件中进行特殊链接！如果你遇到构建错误，请确保已经存在与正确API的链接！
- en: 'The complete API listing is located in the following documentation: [https://docs.unrealengine.com/latest/INT/API/](https://docs.unrealengine.com/latest/INT/API/).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的API列表位于以下文档中：[https://docs.unrealengine.com/latest/INT/API/](https://docs.unrealengine.com/latest/INT/API/)。
- en: Technical requirements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用Unreal Engine 4，并使用Visual Studio 2017作为IDE。有关如何安装这两款软件及其要求的信息，请参阅本书的[第1章](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)，*UE4开发工具*。
- en: Core/Logging API – defining a custom log category
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心日志API - 定义自定义日志类别
- en: 'UE4 itself defines several logging categories, including categories such as
    `LogActor`, which has any log messages to do with the `Actor` class, and `LogAnimation`,
    which logs messages about animations. In general, UE4 defines a separate logging
    category for each module. This allows developers to output their log messages
    to different logging streams. Each log stream''s name is prefixed to the outputted
    message, as shown in the following example log messages from the engine:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These log messages are samples from the engine, each prefixed with their log
    category. Warning messages appear in yellow and have Warning added to the front
    as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The example code you will find on the internet tends to use `LogTemp` for a
    UE4 project''s own messages, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can actually improve upon this formula by defining our own custom `LogCategory`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a UE4 project ready in which you'd like to define a custom log. Open a
    header file that will be included in almost all files using this log.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the main header file for your project; for example, if your project''s
    name is `Chapter_11`, you''ll open `Chapter_11.h`. Add the following line of code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As defined in `AssertionMacros.h`, there are three arguments to this declaration,
    which are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '`CategoryName`: This is the log category name being defined (`LogCh11` here)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultVerbosity`: This is the default verbosity to use on log messages'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompileTimeVerbosity`: This is the verbosity to bake into compiled code'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the main `.cpp` file for your project (`Chapter_11.cpp` in our case),
    include the following line of code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can use this log category in our own scripts. As an example, open up
    your project''s `GameModeBase` file (in this case, `Chapter_11GameModeBase.h`)
    and add the following function declaration:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, go to the implementation (`Chapter_11GameModeBase.cpp`) and use the following
    code as an example of the various display categories:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Compile your scripts. Afterwards, open the World Settings menu and set the
    GameMode Override property to `Chapter_11GameModeBase` and then run the game:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5e64d7dd-1c39-4e0b-80fe-1556f7b9cf2b.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: The location of the logged messages from the Output Log window
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we can see our custom log messages being displayed!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging works by outputting messages to the Output Log (Window | Developer Tools
    | Output Log) as well as a file. All information outputted to the Output Log is
    also mirrored to a simple text file that is located in your project's `/Saved/Logs`
    folder. The extension of the log files is `.log`, with the most recent one being
    named `YourProjectName.log`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can enable or suppress log messages for a particular log channel from within
    the editor using the following console commands:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you'd like to edit the initial values of the output levels of some of the
    built-in log types, you can use a C++ class to create changes for the `engine.ini`
    config file. You can change the initial values in the `engine.ini` configuration
    file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要编辑某些内置日志类型的输出级别的初始值，你可以使用一个C++类来为`engine.ini`配置文件创建更改。你可以在`engine.ini`配置文件中更改初始值。
- en: See [https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime](https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime)
    for more details.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情请见[https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime](https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime)。
- en: '`UE_LOG` sends its output to Output Window. If you''d like to use the more
    specialized Message Log window in addition to this, you can use the `FMessageLog`
    object to write your output messages. `FMessageLog` writes to both the Message
    Log and the Output Window. See the next recipe for details.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`UE_LOG`将输出发送到输出窗口。如果你还想使用这个更专业的消息日志窗口，你可以使用`FMessageLog`对象来写入你的输出消息。`FMessageLog`将写入消息日志和输出窗口。有关详细信息，请参阅下一道菜谱。'
- en: Core/Logging API – FMessageLog to write messages to the Message Log
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心日志API - 使用FMessageLog将消息写入消息日志
- en: '`FMessageLog` is an object that allows you to write output messages to the
    Message Log (Window | Developer Tools | Message Log) and Output Log (Window |
    Developer Tools | Output Log) simultaneously.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`FMessageLog`是一个对象，它允许你同时将输出消息写入消息日志（窗口 | 开发者工具 | 消息日志）和输出日志（窗口 | 开发者工具 | 输出日志）。'
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have your project ready and some information to log to Message Log. Display
    the Message Log (Window | Developer Tools | Message Log) in your UE4 Editor.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好你的项目并准备记录到消息日志中的信息。在UE4编辑器中显示消息日志（窗口 | 开发者工具 | 消息日志）。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Add `#define` to your main header file (`ProjectName.h`), defining `LOCTEXT_NAMESPACE`
    as something unique to your codebase:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主要头文件（`ProjectName.h`）中添加`#define`，将`LOCTEXT_NAMESPACE`定义为你的代码库中独特的东西：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `#define` is used by the `LOCTEXT()` macro, which we use to generate `FText`
    objects, but is not seen in output messages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`#define`被`LOCTEXT()`宏使用，我们用它来生成`FText`对象，但在输出消息中是不可见的。
- en: 'Declare your `FMessageLog` by constructing it somewhere very global. You can
    use `extern` in your `ProjectName.h` file. Consider the following piece of code
    as an example:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某个非常全局的地方声明你的`FMessageLog`，你可以在`ProjectName.h`文件中使用`extern`。考虑以下代码片段作为示例：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, create your `FMessageLog` by defining it in a `.cpp` file and registering
    it with `MessageLogModule`. Be sure to give your logger a clear and unique name
    on construction. It''s the category of your log that will appear to the left of
    your log messages in Output Log. For example, `ProjectName.cpp`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过在`.cpp`文件中定义它并使用`MessageLogModule`注册它来创建你的`FMessageLog`。确保在构建时给你的记录器一个清晰且独特的名称。这是你的日志类别，它将出现在输出日志中你的日志消息的左侧。例如，`ProjectName.cpp`：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, head back to somewhere in your code to actually create the log and use
    it. For example, we can add the following `GameModeBase` class''s `BeginPlay`
    method:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，回到你的代码中的某个地方，实际创建日志并使用它。例如，我们可以在以下`GameModeBase`类的`BeginPlay`方法中添加以下内容：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `KEY` to `LOCTEXT` (first argument) must be unique or you will get a previously
    hashed string back. If you''d like, you can include a `#define` that repeats the
    argument to `LOCTEXT` twice, as we did earlier:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOCTEXT`（第一个参数）的`KEY`必须是唯一的，否则你会得到一个之前哈希过的字符串。如果你愿意，你可以包含一个`#define`，重复`LOCTEXT`的参数两次，就像我们之前做的那样：'
- en: '`#define FTEXT(x) LOCTEXT(x, x)`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`#define FTEXT(x) LOCTEXT(x, x)`'
- en: 'Log your messages using the following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码记录你的消息：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code utilizes the `FTEXT()` macro we defined earlier. Ensure it is in your
    codebase.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了我们之前定义的`FTEXT()`宏。确保它在你的代码库中。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe displays a message to the Message Log. As we discussed previously,
    you can see logged information at the Message Log (Window | Developer Tools | Message
    Log) and Output Log (Window | Developer Tools | Output Log) .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱显示了一条消息到消息日志。正如我们之前讨论的，你可以在消息日志（窗口 | 开发者工具 | 消息日志）和输出日志（窗口 | 开发者工具 | 输出日志）中看到记录的信息。
- en: 'Constructing your message log again after initialization retrieves a copy of
    the original message log. For example, at any place in the code, you can write
    the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化后再次构建你的消息日志会获取原始消息日志的一个副本。例如，在代码的任何地方，你可以编写以下代码：
- en: '`FMessageLog( LoggerName ).Info(FTEXT( "An info message"));`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`FMessageLog( LoggerName ).Info(FTEXT( "An info message"));`'
- en: Core/Math API – rotation using FRotator
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心数学API - 使用FRotator进行旋转
- en: 'Rotation in UE4 has such a complete implementation that it can be hard to choose
    how to rotate your objects. There are three main methods: `FRotator`, `FQuat`,
    and `FRotationMatrix`. This recipe outlines the construction and use of the first
    of the three different methods for the rotation of objects—the `FRotator`. Using
    this, and the following two recipes, you can select a method to use to rotate
    your objects.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: UE4中的旋转实现如此完整，以至于选择如何旋转对象可能会很困难。主要有三种方法：`FRotator`、`FQuat`和`FRotationMatrix`。本食谱概述了三种不同旋转方法中第一种——`FRotator`的构建和使用。使用此方法以及以下两个食谱，你可以选择用于旋转对象的方法。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open a UE4 project that has an object you can get a C++ interface with. For
    example, you can construct a C++ class Coin that derives from `Actor` to test
    out rotations. Override the `Coin::Tick()` method to apply your rotations from
    the C++ code. Alternatively, you can call these rotation functions in the `Tick`
    event from Blueprints.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个UE4项目，该项目中有一个你可以通过C++接口获取的对象。例如，你可以构建一个从`Actor`派生的C++类`Coin`来测试旋转。通过C++代码覆盖`Coin::Tick()`方法来应用你的旋转。或者，你也可以在Blueprints的`Tick`事件中调用这些旋转函数。
- en: In this example, we will rotate an object at a rate of one degree per second
    by making use of an Actor component. The actual rotation will be the accumulated
    time since the object was created. To get this value, we'll just call `GetWorld()->TimeSeconds`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将通过使用Actor组件以每秒一度速率旋转对象。实际的旋转将是对象创建以来的累积时间。为了获取此值，我们将调用`GetWorld()->TimeSeconds`。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: From the Modes tab, under the Place section and under Basic, drag and drop a
    Cube object into your scene.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“模式”选项卡下，“放置”部分和“基本”部分下，将一个立方体对象拖放到你的场景中。
- en: From the Details tab, go to the Transform component and change the Mobility
    property to Movable.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“详细信息”选项卡中，转到“变换”组件并将“移动性”属性更改为“可移动”。
- en: Afterwards, click on the Add Component button and select New C++ Component.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，点击“添加组件”按钮并选择“新C++组件”。
- en: 'From the menu that pops up, select Actor Component and select Next:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的菜单中选择“Actor组件”并选择“下一步”：
- en: '![](img/7df035bd-fc84-445a-bc58-40af6b94ac73.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7df035bd-fc84-445a-bc58-40af6b94ac73.png)'
- en: From there, give your component a name, for example, `RotateActorComponent`,
    and then press the Create Class button.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，给你的组件命名，例如，`RotateActorComponent`，然后按创建类按钮。
- en: 'Construct your `FRotator`. `FRotators` can be constructed using a stock pitch,
    yaw, and roll constructor, as shown in the following example:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建你的`FRotator`。`FRotators`可以使用库存的俯仰、偏航和滚转构造函数来构建，如下例所示：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Your `FRotator` will be constructed as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的`FRotator`将按照以下方式构建：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The standard orientation for an object in UE4 is with Forward facing down the
    *+X*-axis. Right is the *+Y*-axis, and Up is *+Z*.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UE4中对象的标准化方向是面向下*+X*轴。右是*+Y*轴，上是*+Z*。
- en: 'Pitch is rotation about the *Y*-axis (across), yaw is rotation about the *Z*-axis
    (up), and roll is rotation about the *X*-axis. This is best understood in the
    following three points:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 俯仰是关于*Y*轴（横跨）的旋转，偏航是关于*Z*轴（向上）的旋转，滚转是关于*X*轴的旋转。以下三点最能理解这一点：
- en: '**Pitch**: If you think of an airplane in UE4 standard coordinates, the *Y*-axis
    goes along the wingspan (pitching tilts it forward and backward)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**俯仰**：如果你在UE4标准坐标系中想象一架飞机，*Y*轴沿着机翼（俯仰使其前后倾斜）'
- en: '**Yaw**: The *Z*-axis goes straight up and down (yawing turns it left and right)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏航**：*Z*轴垂直向上和向下（偏航使其左右转动）'
- en: '**Roll**: The *X*-axis goes straight along the fuselage of the plane (rolling
    does barrel rolls)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚转**：*X*轴沿着飞机的机身（滚转使其做桶滚）'
- en: You should note that in other conventions, the *X*-axis is pitch, the *Y*-axis
    is yaw, and the *Z*-axis is roll.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意，在其他约定中，*X*轴是俯仰，*Y*轴是偏航，*Z*轴是滚转。
- en: 'Apply your `FRotator` to your actor using the `SetActorRotation` member function,
    as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetActorRotation`成员函数将`FRotator`应用到你的actor上，如下所示：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Core/Math API – rotation using FQuat
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心数学API - 使用FQuat进行旋转
- en: 'Quaternions sound intimidating, but they are extremely easy to use. You may
    want to review the theoretical math behind them by viewing the following videos:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数听起来很吓人，但它们极其容易使用。你可能想通过查看以下视频来回顾它们背后的理论数学：
- en: '*Fantastic Quaternions* by Numberphile: [https://www.youtube.com/watch?v=3BR8tK-LuB0](https://www.youtube.com/watch?v=3BR8tK-LuB0)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numberphile的*奇妙的四元数*：[https://www.youtube.com/watch?v=3BR8tK-LuB0](https://www.youtube.com/watch?v=3BR8tK-LuB0)
- en: '*Understanding Quaternions* by Jim Van Verth: [http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding](http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jim Van Verth的《*理解四元数*》：[http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding](http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding)
- en: However, we won't cover the math background here! In fact, you don't need to
    understand much about the math background of quaternions to use them effectively.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会在这里介绍数学背景！实际上，你不需要对四元数的数学背景有太多了解就能有效地使用它们。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have a project ready and an `Actor` with an override `::Tick()` function that
    we can enter the C++ code into.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好一个项目和一个具有覆盖`::Tick()`函数的`Actor`，我们可以将C++代码输入其中。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To construct a quaternion, the best constructor to use is as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构造一个四元数，最好使用的构造函数如下：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Quaternions have quaternion addition, quaternion subtraction, multiplication
    by a scalar, and division by a scalar defined for them, among other functions.
    They are extremely useful to rotate things at arbitrary angles, and point objects
    at one another.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数有四元数加法、四元数减法、标量乘法和标量除法等定义，以及其他函数。它们在以任意角度旋转物体和指向其他物体方面非常有用。
- en: 'For example, if you wanted to use an FQuat inside of the `RotateActorComponent.cpp`
    file, it would look similar to this:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果你想在`RotateActorComponent.cpp`文件中使用FQuat，它看起来会类似于这样：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Upon compiling your code and returning to the game, you should notice the cube
    moving at a constant rate:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 编译你的代码并返回游戏后，你应该注意到立方体以恒定速度移动：
- en: '![](img/ddb86012-77dc-4859-ad2f-ea3689f90875.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddb86012-77dc-4859-ad2f-ea3689f90875.png)'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Quaternions are a bit strange, but using them is quite simple. If *v* is the
    axis around which to rotate, and ![](img/6edc4c6a-2cc5-4162-9d74-cd70b3b729b3.jpg) is
    the magnitude of the angle of rotation, then we get the following equations for
    the components of a quaternion:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数有点奇怪，但使用它们相当简单。如果*v*是旋转的轴，而![图片](img/6edc4c6a-2cc5-4162-9d74-cd70b3b729b3.jpg)是旋转角度的大小，那么我们得到以下四元数分量的方程：
- en: '![](img/e9dc711a-8f43-48f8-bc68-a56de59ad11f.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9dc711a-8f43-48f8-bc68-a56de59ad11f.jpg)'
- en: 'So, for example, rotation about ![](img/ac235d9d-5ef7-46a7-8ce4-0a18ed80d558.jpg) by
    an angle of ![](img/69cf02ef-9e27-44a6-9a4b-efdc00908cd8.jpg) will have the following
    quaternion components:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，绕![图片](img/ac235d9d-5ef7-46a7-8ce4-0a18ed80d558.jpg)旋转一个角度![图片](img/69cf02ef-9e27-44a6-9a4b-efdc00908cd8.jpg)的四元数成分如下：
- en: '![](img/d3c4d321-4172-4dbe-9974-d6e0b6c8fe89.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3c4d321-4172-4dbe-9974-d6e0b6c8fe89.jpg)'
- en: Three of the four components of the quaternion (*x*, *y*, and *z*) define the
    axis around which to rotate (scaled by the sine of half the angle of rotation),
    while the fourth component (*w*) has only the cosine of half the angle to rotate
    with.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数的四个分量中的三个(*x*，*y*和*z*)定义了旋转的轴（通过旋转角度的一半的正弦进行缩放），而第四个分量(*w*)只有旋转角度的一半的余弦。
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Quaternions, being vectors themselves, can be rotated. Simply extract the (*x*,
    *y*, *z*) components of the quaternion, normalize, and then rotate that vector.
    Construct a new quaternion from that new unit vector with the desired angle of
    rotation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为向量本身的四元数也可以旋转。只需提取四元数的(*x*，*y*，*z*)分量，归一化，然后旋转该向量。从新的单位向量构造一个新的四元数，具有所需的旋转角度。
- en: 'Multiplying quaternions together represents a series of rotations that happen
    subsequently. For example, a rotation of 45º about the *X*-axis, followed by a
    rotation of 45º about the *Y*-axis will be composed by the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将四元数相乘表示一系列连续发生的旋转。例如，绕*X*轴旋转45度，然后绕*Y*轴旋转45度，将会组合成以下形式：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This would give you a result that would look similar to this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出一个类似以下的结果：
- en: '![](img/f4bbdb04-e68b-48f2-abea-f943c4029dfd.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4bbdb04-e68b-48f2-abea-f943c4029dfd.png)'
- en: API – rotation using FRotationMatrix to have one object face another
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API – 使用FRotationMatrix进行旋转以使一个对象面向另一个对象
- en: '`FRotationMatrix` offers matrix construction using a series of `::Make*` routines.
    They are easy to use and useful to get one object to face another. Say you have
    two objects, one of which is following the other. We want the rotation of the
    follower to always be facing what it is following. The construction methods of
    `FRotationMatrix` make this easy to do.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`FRotationMatrix`提供了一系列`::Make*`例程来构建矩阵。它们易于使用，并且有助于使一个对象面向另一个对象。假设你有两个对象，其中一个对象在跟随另一个对象。我们希望跟随者的旋转始终面向它所跟随的对象。`FRotationMatrix`的构造方法使这变得容易实现。'
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have two actors in a scene, one of which should face the other.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中有两个 actor，其中一个应该面向另一个。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Add a new C++ Actor Component for the follower called `FollowActorComponent`
    (see the *Core/Math API – rotation using FRotator* recipe if you need help with
    this).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '为跟随者添加一个新的 C++ Actor 组件，称为 `FollowActorComponent`（如果你需要帮助，请参阅 *Core/Math API
    – 使用 FRotator 进行旋转* 菜单）。 '
- en: 'From the `FollowActorComponent.h` file, we need to have a reference to the
    object we want to follow, so add the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `FollowActorComponent.h` 文件中，我们需要有一个对我们想要跟随的对象的引用，因此添加以下内容：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, in the `FollowActorComponent.cpp` file, in the `TickComponent` function,
    look into the available constructors under the `FRotationMatrix` class. A bunch
    of constructors are available that will let you specify a rotation for an object
    (from stock position) by reorienting one or more of the *X*-, *Y*-, or *Z*-axes,
    named with the `FRotationMatrix::Make*()` pattern.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `FollowActorComponent.cpp` 文件中，在 `TickComponent` 函数中，查看 `FRotationMatrix`
    类下的可用构造函数。有一系列构造函数可供使用，允许你通过重新定位一个或多个 *X*、*Y* 或 *Z* 轴来指定一个对象（从原生位置）的旋转，这些构造函数以
    `FRotationMatrix::Make*()` 模式命名。
- en: 'Assuming you have a default stock orientation for your actor (with Forward
    facing down the *+X*-axis, and up facing up the *+Z*-axis), find the vector from
    the follower to the object they want to follow, as shown in this piece of code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你为你的 actor 有一个默认的股票方向（其中前进方向朝下沿 *+X*-轴，向上方向朝上沿 *+Z*-轴），找到从跟随者到他们想要跟随的对象的向量，如图中所示：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Compile your script and assign the Target property inside of the Follow Actor
    Component from the Details tab. This can be done using the eyedropper button to
    the right of the property or by using the drop-down list:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的脚本，并在“跟随者组件”的详细信息选项卡中分配目标属性。这可以通过使用属性右侧的吸管按钮或使用下拉列表来完成：
- en: '![](img/37b4eeb3-2998-4d99-b3cf-0d6e219be4d6.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37b4eeb3-2998-4d99-b3cf-0d6e219be4d6.png)'
- en: 'If all went well, you should see the actor rotate correctly to face the target:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该看到 actor 正确旋转以面对目标：
- en: '![](img/c28f774e-1745-4d24-bcd7-8d7986021a0c.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c28f774e-1745-4d24-bcd7-8d7986021a0c.png)'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Getting one object to look at another, with a desired up vector, can be done
    by calling the correct function, depending on your object''s stock orientation.
    Usually, you want to reorient the *X*-axis (Forward), while specifying either
    the *Y*-axis (Right) or *Z*-axis (Up) vectors (`FRotationMatrix::MakeFromXY()`).
    For example, to make an actor look along a `lookAlong` vector, with its right
    side facing right, we''d construct and set `FRotationMatrix` for it, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用正确的函数，根据你的对象的原生方向，使一个对象看向另一个对象，并指定一个期望的向上向量。通常，你想要重新定位 *X*-轴（前进），同时指定 *Y*-轴（右）或
    *Z*-轴（上）向量（`FRotationMatrix::MakeFromXY()`）。例如，要使一个 actor 沿着 `lookAlong` 向量看去，其右侧朝向右侧，我们需要为它构造并设置
    `FRotationMatrix`，如下所示：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: GameplayAbilities API – triggering an actor's gameplay abilities with game controls
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameplayAbilities API – 使用游戏控制触发角色的游戏能力
- en: The **GameplayAbilities** API can be used to attach C++ functions to invoke
    on certain button pushes, triggering the game unit to exhibit its abilities during
    play in response to keystroke events. In this recipe, we will show you how to
    do that.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**GameplayAbilities** API 可以用来将 C++ 函数附加到某些按钮的点击上，触发游戏单位在游戏过程中响应按键事件时展示其能力。在这个菜谱中，我们将向你展示如何做到这一点。'
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Enumerate and describe your game character's abilities. You will need to know
    what your character does in response to key events to code in this recipe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列出并描述你的游戏角色的能力。你需要知道你的角色在响应按键事件时做什么，以便在这个菜谱中编写代码。
- en: 'There are several objects that we need to use here; they are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们需要使用几个对象；它们如下所示：
- en: 'The `UGameplayAbility` class—this is needed to derive the C++ class instances
    of the `UGameplayAbility` class, with one derivative class for each ability:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UGameplayAbility` 类——这是为了从 `UGameplayAbility` 类派生 C++ 类实例所必需的，每个能力都有一个派生类：'
- en: Define what each ability does in `.h` and `.cpp` by overriding the available
    functions, such as `UGameplayAbility::ActivateAbility`, `UGameplayAbility::InputPressed`,
    `UGameplayAbility::CheckCost`, `UGameplayAbility::ApplyCost`, `UGameplayAbility::ApplyCooldown`,
    and so on
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过覆盖可用的函数，如 `UGameplayAbility::ActivateAbility`、`UGameplayAbility::InputPressed`、`UGameplayAbility::CheckCost`、`UGameplayAbility::ApplyCost`、`UGameplayAbility::ApplyCooldown`
    等，在 `.h` 和 `.cpp` 文件中定义每个能力的作用。
- en: '`GameplayAbilitiesSet` is a `DataAsset` derivative object that contains a series
    of enum''d command values, and blueprints of the corresponding `UGameplayAbility`
    derivative classes that define the behavior for that particular input command.
    Each GameplayAbility is kicked off by a keystroke or mouse-click, which is set
    in `DefaultInput.ini`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameplayAbilitiesSet` 是一个 `DataAsset` 派生对象，它包含一系列枚举的命令值，以及定义特定输入命令行为的相应 `UGameplayAbility`
    派生类的蓝图。每个 GameplayAbility 都由一个按键或鼠标点击启动，这已在 `DefaultInput.ini` 中设置。'
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following code, we''ll implement a `UGameplayAbility` derivative called
    `UGameplayAbility_Attack` for a `Warrior` class object. We''ll attach this gameplay
    functionality to the input command string `Ability1`, which we''ll activate on
    the left-mouse button-click:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将实现一个名为 `UGameplayAbility_Attack` 的 `UGameplayAbility` 派生类，用于 `Warrior`
    类对象。我们将把这个游戏功能附加到输入命令字符串 `Ability1` 上，我们将在左鼠标按钮点击时激活它：
- en: 'Open up your `.Build.cs` file (in our case, `Chapter_11.Build.cs`) and add
    the following dependencies:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 `.Build.cs` 文件（在我们的例子中，`Chapter_11.Build.cs`），并添加以下依赖项：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile your code.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码。
- en: From the Unreal Editor, go to Settings | Plugins.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Unreal 编辑器，转到 设置 | 插件。
- en: 'From the menu that pops up, search for `GameplayAbilities` and check it. You''ll
    get a message asking if you are sure. Click on the Yes button:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出的菜单中，搜索 `GameplayAbilities` 并勾选它。你会得到一个确认消息。点击是按钮：
- en: '![](img/fb27ba3b-6389-4a08-9651-614f0d31f7dc.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb27ba3b-6389-4a08-9651-614f0d31f7dc.png)'
- en: Afterwards, click on the Restart Now button. The classes should be added to
    your project correctly.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，点击立即重启按钮。类应该被正确添加到你的项目中。
- en: 'Now, access the Add C++ Class wizard by selecting from the Content Browser
    Add New | New C++ Class... and check the Show All Classes option. From there,
    type in `gameplayability` and select the base GameplayAbility class to base our
    new class on:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过从内容浏览器添加新 | 新 C++ 类... 选择添加 C++ 类向导，并检查显示所有类选项。从那里，输入 `gameplayability`
    并选择基础 GameplayAbility 类以基于我们的新类：
- en: '![](img/b731ae0b-66a3-40f4-a9d8-dae61e50aafb.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b731ae0b-66a3-40f4-a9d8-dae61e50aafb.png)'
- en: Give the new gameplay ability a name of `GameplayAbility_Attack` and press Create
    Class.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新的游戏能力命名为 `GameplayAbility_Attack` 并按创建类。
- en: 'At the very least, you want to override the following:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少，你想要重写以下内容：
- en: The `UGameplayAbility_Attack::CanActivateAbility` member function to indicate
    when the actor is allowed to invoke the ability.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UGameplayAbility_Attack::CanActivateAbility` 成员函数用于指示当演员被允许调用能力时。'
- en: The `UGameplayAbility_Attack::CheckCost` function to indicate whether the player
    can afford to use an ability or not. This is extremely important because if this
    returns false, ability invocation should fail.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UGameplayAbility_Attack::CheckCost` 函数用于指示玩家是否有能力使用一个能力。这一点非常重要，因为如果这个函数返回
    false，能力调用应该失败。'
- en: The `UGameplayAbility_Attack::ActivateAbility` member function to write the
    code that the `Warrior` is to execute when their `Attack` ability is activated.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UGameplayAbility_Attack::ActivateAbility` 成员函数用于编写当 `Warrior` 的 `Attack` 能力被激活时
    `Warrior` 将要执行的代码。'
- en: 'The `UGameplayAbility_Attack::InputPressed` member function and to respond
    to the key input event assigned to the ability:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UGameplayAbility_Attack::InputPressed` 成员函数以及响应分配给能力的按键输入事件：'
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Derive a Blueprint class from your `UGameplayAbility_Attack` object inside the
    UE4 Editor.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 UE4 编辑器中从你的 `UGameplayAbility_Attack` 对象派生一个蓝图类。
- en: 'Inside the Editor, navigate to Content Browser and create a `GameplayAbilitiesSet`
    object by doing the following:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器内部，导航到内容浏览器，通过以下步骤创建一个 `GameplayAbilitiesSet` 对象：
- en: 'Right-clicking on Content Browser and selecting Miscellaneous | Data Asset:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内容浏览器上右键单击并选择杂项 | 数据资产：
- en: '![](img/777500fc-befc-4e6b-b1ca-8924737f7ecf.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/777500fc-befc-4e6b-b1ca-8924737f7ecf.png)'
- en: 'In the dialog box that follows, select `GameplayAbilitySet` for the Data Asset
    Class:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在随后的对话框中，选择数据资产类为 `GameplayAbilitySet`：
- en: '![](img/90023d90-6b67-4cc4-896a-ace1d96ee8c5.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90023d90-6b67-4cc4-896a-ace1d96ee8c5.png)'
- en: In fact, the `GameplayAbilitySet` object is a `UDataAsset` derivative. It is
    located in `GameplayAbilitySet.h` and contains a single member function, `GameplayAbilitySet::GiveAbilities()`,
    which I strongly recommend you not to use for reasons listed in a later step.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`GameplayAbilitySet` 对象是一个 `UDataAsset` 派生对象。它位于 `GameplayAbilitySet.h`
    中，包含一个成员函数 `GameplayAbilitySet::GiveAbilities()`，我强烈建议你不要使用它，原因将在后续步骤中列出。
- en: Name your `GameplayAbilitySet` data asset something related to the `WarriorAbilitySet`
    object so that we know to put it into the `Warrior` class (for example, `WarriorAbilitySet`).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的 `GameplayAbilitySet` 数据资产命名为与 `WarriorAbilitySet` 对象相关的内容，以便我们知道将其放入 `Warrior`
    类中（例如，`WarriorAbilitySet`）。
- en: 'Double-click to open and edit the new `WarriorAbilitySet` Data Asset. Stack
    in a list of `GameplayAbility` class derivative Blueprints by clicking + on the
    `TArray` object inside of it. Your `UGameplayAbility_Attack` object must appear
    in the dropdown:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击打开并编辑新的 `WarriorAbilitySet` 数据资产。通过在其内部的 `TArray` 对象上点击 + 来堆叠一个 `GameplayAbility`
    类派生蓝图列表。您的 `UGameplayAbility_Attack` 对象必须出现在下拉菜单中：
- en: '![](img/01c90d63-775f-4669-8d74-a9e01192e4f7.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01c90d63-775f-4669-8d74-a9e01192e4f7.png)'
- en: We now need to create a `Character` class-derived object so that we can contain
    this ability set. In this example, we will call this class `Warrior`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要创建一个从 `Character` 类派生的对象，以便我们可以包含这个能力集。在这个例子中，我们将把这个类命名为 `Warrior`。
- en: 'Add a `UPROPERTY UGameplayAbilitySet* gameplayAbilitySet` member to your `Warrior`
    class:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `Warrior` 类中添加一个 `UPROPERTY UGameplayAbilitySet* gameplayAbilitySet` 成员：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ensure that your `Actor` class derivative also derives from the `UAbilitySystemInterface` interface.
    This is extremely important so that calls to `(Cast<IAbilitySystemInterface>(yourActor))->GetAbilitySystemComponent()` succeed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的 `Actor` 类派生也派生自 `UAbilitySystemInterface` 接口。这一点非常重要，以便 `(Cast<IAbilitySystemInterface>(yourActor))->GetAbilitySystemComponent()`
    调用成功。
- en: 'Create a Blueprint of the `Warrior` class and set the Gameplay Ability Set
    to the Warrior Ability Set we created earlier, and set the Ability System Component
    to the Ability System Component:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Warrior` 类的蓝图，并将游戏能力集设置为之前创建的 `Warrior Ability Set`，并将能力系统组件设置为能力系统组件：
- en: '![](img/16747445-09a2-4b0e-b317-85c07b104892.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/16747445-09a2-4b0e-b317-85c07b104892.png)'
- en: If you are unable to see the Ability System Component, close and reopen the
    Blueprint.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到能力系统组件，请关闭并重新打开蓝图。
- en: Once finished, assign `MyWarrior` as the Default Pawn Class of your Game Mode.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，将 `MyWarrior` 分配为您的游戏模式的默认Pawn类。
- en: Compile, run, and select-in `WarriorAbilitySet` as it sits in Content Browser
    (created in Steps 5 to 7) of the abilities of which this `Warrior` is capable.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译、运行并选择在内容浏览器中（在第 5 步到第 7 步创建）的 `WarriorAbilitySet` 作为 `Warrior` 能够使用的技能。
- en: Some time after the construction of your actor, call `gameplayAbilitySet->GiveAbilities(
    abilitySystemComponent );` or enter a loop, as shown in the following step where
    you invoke `abilitySystemComponent->GiveAbility()` for each ability listed in
    your `gameplayAbilitySet`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的演员构建一段时间后，调用 `gameplayAbilitySet->GiveAbilities( abilitySystemComponent );`
    或进入循环，如下一步所示，其中为 `gameplayAbilitySet` 中列出的每个能力调用 `abilitySystemComponent->GiveAbility()`。
- en: 'Write an override for `AWarrior::SetupPlayerInputComponent( UInputComponent*
    Input )` to connect the input controller to the Warrior''s `GameplayAbility` activations.
    After doing so, iterate over each `GameplayAbility` listed in your `GameplayAbilitySet`''s
    Abilities group:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `AWarrior::SetupPlayerInputComponent( UInputComponent* Input )` 编写一个覆盖，以将输入控制器连接到战士的
    `GameplayAbility` 激活。完成后，遍历 `GameplayAbilitySet` 的 `Abilities` 组中列出的每个 `GameplayAbility`：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compile your code and then play the game:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的代码然后玩游戏：
- en: '![](img/7cad0887-cbad-49f8-966b-83e6fc2d9f0d.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7cad0887-cbad-49f8-966b-83e6fc2d9f0d.png)'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You must subclass and link in a set of `UGameplayAbility` objects to your actor's
    `UAbilitySystemComponent` object through a series of calls to `UAbilitySystemComponent::GiveAbility(
    spec )` with appropriately constructed `FGameplayAbilitySpec` objects. What this
    does is deck out your actor with this bunch of `GameplayAbilities`. The functionality
    of each `UGameplayAbility`, as well as its cost, cooldown, and activation, is
    all neatly contained within the `UGameplayAbility` class derivative that you will
    construct.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须通过一系列对 `UAbilitySystemComponent::GiveAbility( spec )` 的调用，使用适当构造的 `FGameplayAbilitySpec`
    对象，将一组 `UGameplayAbility` 对象子类化并链接到您的演员的 `UAbilitySystemComponent` 对象。这样做会给您的演员配备这批
    `GameplayAbilities`。每个 `UGameplayAbility` 的功能，以及其成本、冷却时间和激活，都整齐地包含在您将要构建的 `UGameplayAbility`
    类派生类中。
- en: Do not use  the `GameplayAbilitySet::GiveAbilities()` member function because
    it doesn't give you access to the set of `FGameplayAbilitySpecHandle` objects
    that you actually need later to bind and invoke the ability to an input component.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `GameplayAbilitySet::GiveAbilities()` 成员函数，因为它不会给您提供访问您实际需要的 `FGameplayAbilitySpecHandle`
    对象集合，这些对象稍后用于将能力绑定并调用到输入组件。
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You''ll want to carefully code in a bunch of the other functions that are available
    in the `GameplayAbility.h` header file, including implementations for the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你还想要仔细编写 `GameplayAbility.h` 头文件中可用的其他函数，包括以下实现的函数：
- en: '`SendGameplayEvent`: This is a function to notify GameplayAbility that some
    general gameplay event has happened.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SendGameplayEvent`：这是一个通知 GameplayAbility 发生了某些通用游戏事件的函数。'
- en: '`CancelAbility`: This is a function to stop an ability''s usage midway through,
    and to give the ability an interrupted state.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CancelAbility`：这是一个在能力使用中途停止并给能力一个中断状态的函数。'
- en: Keep in mind that there are a bunch of existing `UPROPERTY` specifiers near
    the bottom of the `UGameplayAbility` class declaration that either activate or
    cancel the ability upon addition or removal of certain `GameplayTags`. See the
    following *GameplayTags API – attaching GameplayTags to an actor* recipe for more
    details.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，在 `UGameplayAbility` 类声明的底部附近有许多现有的 `UPROPERTY` 指示符，它们在添加或删除某些 `GameplayTags`
    时会激活或取消能力。有关更多详细信息，请参阅以下 *GameplayTags API – 将 GameplayTags 关联到 Actor* 菜谱。
- en: There are a bunch more! Explore the API and implement those functions you find
    to be useful in your code.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多！探索 API 并实现你在代码中找到的有用的函数。
- en: See also
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `GameplayAbilities` API is a rich and nicely interwoven series of objects
    and functions. Explore `GameplayEffects`, `GameplayTags`, and `GameplayTasks`
    and how they integrate with the `UGameplayAbility` class to fully explore the
    functionality the library has to offer. You can read more about the API here: [https://api.unrealengine.com/INT/API/Plugins/GameplayAbilities/index.html](https://api.unrealengine.com/INT/API/Plugins/GameplayAbilities/index.html)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameplayAbilities` API 是一系列丰富且紧密交织的对象和函数。探索 `GameplayEffects`、`GameplayTags`
    和 `GameplayTasks` 以及它们如何与 `UGameplayAbility` 类集成，以全面了解库提供的功能。你可以在此处了解更多关于 API
    的信息：[https://api.unrealengine.com/INT/API/Plugins/GameplayAbilities/index.html](https://api.unrealengine.com/INT/API/Plugins/GameplayAbilities/index.html)'
- en: GameplayAbilities API - Implementing stats with UAttributeSet
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameplayAbilities API - 使用 UAttributeSet 实现统计数据
- en: The `GameplayAbilities` API allows you to associate a set of attributes, that
    is, `UAttributeSet`, to an Actor. `UAttributeSet` describes properties appropriate
    for that Actor's in-game attributes, such as `Hp`, `Mana`, `Speed`, `Armor`, `AttackDamage`,
    and so on. You can either define a single game-wide set of attributes common to
    all Actors, or several different sets of attributes appropriate for the different
    classes of actors.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameplayAbilities` API 允许你将一组属性，即 `UAttributeSet`，关联到一个 Actor 上。`UAttributeSet`
    描述了适合该 Actor 游戏内属性的属性，例如 `Hp`（生命值）、`Mana`（法力）、`Speed`（速度）、`Armor`（护甲）、`AttackDamage`（攻击伤害）等等。你可以定义一个通用于所有
    Actor 的单个游戏内属性集，或者为不同类别的 Actor 定义几个不同的属性集。'
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`AbilitySystemComponent` is the first thing you will need to add to your actors
    to equip them to use the `GameplayAbilities` API and `UAttributeSet` classes.
    To define your custom `UAttributeSet`, you will simply derive from the `UAttributeSet`
    base class and extend the base class with your own series of `UPROPERTY` members.
    After that, you must register your custom `AttributeSet` with your `Actor` class''s `AbilitySystemComponent`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbilitySystemComponent` 是你首先需要添加到你的 Actor 上的，以便它们能够使用 `GameplayAbilities`
    API 和 `UAttributeSet` 类。为了定义你的自定义 `UAttributeSet`，你只需从 `UAttributeSet` 基类派生，并使用你自己的
    `UPROPERTY` 成员扩展基类。之后，你必须将你的自定义 `AttributeSet` 注册到你的 `Actor` 类的 `AbilitySystemComponent`。'
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: If you have not done so already, complete Steps 1-4 of the *GameplayAbilities
    API – triggering an actor's gameplay abilities with game controls* recipe to link
    to the `GameplayAbilities` API in your `ProjectName.Build.cs` file and enable
    its functionality.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请完成 *GameplayAbilities API – 使用游戏控制触发 Actor 的游戏能力* 菜谱的步骤 1-4，以在 `ProjectName.Build.cs`
    文件中链接到 `GameplayAbilities` API 并启用其功能。
- en: 'Create a new C++ class  by going to the Content Browser and selecting Add New
    | Add C++ Class. From the Add C++ Class menu, check the Show All Classes option.
    From there, type in `attr` and select `AttributeSet` as your parent class. From
    there, click the Next button:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到内容浏览器并选择添加新项 | 添加 C++ 类来创建一个新的 C++ 类。从添加 C++ 类菜单中，勾选显示所有类选项。从那里，输入 `attr`
    并选择 `AttributeSet` 作为你的父类。然后，点击下一步按钮：
- en: '![](img/98d22785-cb67-4d52-b392-4c4424e5a76e.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98d22785-cb67-4d52-b392-4c4424e5a76e.png)'
- en: 'Give the class a Name of `GameUnitAttributeSet` and click on Create Class:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给这个类命名为 `GameUnitAttributeSet` 并点击创建类：
- en: '![](img/df7f58db-1f4a-46d1-a5e5-3c5e43478d3d.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df7f58db-1f4a-46d1-a5e5-3c5e43478d3d.png)'
- en: Once created, deck the class out with a set of `UPROPERTY` specifiers that you
    want each Actor to have in their property set.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，为每个演员在其属性集中拥有的`UPROPERTY`指定符装饰这个类。
- en: 'For example, you might want to declare your `UAttributeSet` derivate class
    similar to what''s given in the following piece of code:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，你可能希望声明你的`UAttributeSet`派生类，类似于以下代码片段中给出的内容：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If your code is networked, you might want to enable replication on each of the
    `UPROPERTY` specifiers with the replicated declaration in the `UPROPERTY` macro.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码是网络化的，你可能希望在每个`UPROPERTY`指定符上启用复制，并在`UPROPERTY`宏中使用复制声明。
- en: 'Connect `GameUnitAttributeSet` with your `AbilitySystemComponent` inside your
    `Actor` class. We can do this with the `Warrior` class we created previously by
    opening the `Warrior.h` file and adding the following function declaration:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Actor`类内部将`GameUnitAttributeSet`与`AbilitySystemComponent`连接起来。我们可以通过打开之前创建的`Warrior`类文件并添加以下函数声明来实现这一点：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, open `Warrior.cpp` and add the following `#include`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`Warrior.cpp`并添加以下`#include`：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Afterwards, implement that function:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，实现该函数：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can put this call somewhere in `PostInitializeComponents()`, or in code
    that is called later than that.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个调用放在`PostInitializeComponents()`中，或者在其之后调用的代码中。
- en: Once you have registered `UAttributeSet`, you can move on with the next recipe
    and apply `GameplayEffect` to some of the elements in the attribute set.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你注册了`UAttributeSet`，你就可以继续下一个菜谱，并将`GameplayEffect`应用于属性集中的某些元素。
- en: Be sure your `Actor` class object implements `IAbilitySystemInterface` by deriving
    from it. This is extremely important as the `UAbilitySet` object will attempt
    a cast to `IAbilitySystemInterface` to call `GetAbilitySystemComponent()` on it
    at various places in the code.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的`Actor`类对象通过从它派生来实现`IAbilitySystemInterface`。这非常重要，因为`UAbilitySet`对象将尝试在代码的多个位置将其转换为`IAbilitySystemInterface`以调用其`GetAbilitySystemComponent()`。
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`UAttributeSets` simply allow you to enumerate and define attributes of different
    actors. `GameplayEffects` will be your means to make changes to the attributes
    of a specific actor.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`UAttributeSets`只是允许你枚举和定义不同演员的属性。`GameplayEffects`将是改变特定演员属性的手段。'
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can code in definitions of `GameplayEffects`, which will be things that
    act on the `AbilitySystemComponent`'s `AttributeSet` collections. You can also
    write `GameplayTasks` for generic functions that run at specific times or follow
    particular events, or even in response to a tag addition (`GameplayTagResponseTable.cpp`).
    You can define `GameplayTags` to modify `GameplayAbility` behavior, as well as
    select and match gameplay units during play.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写`GameplayEffects`的定义，这些定义将作用于`AbilitySystemComponent`的`AttributeSet`集合。你也可以编写`GameplayTasks`，用于在特定时间或跟随特定事件运行通用函数，或者甚至在响应标签添加时（`GameplayTagResponseTable.cpp`）。你可以定义`GameplayTags`来修改`GameplayAbility`的行为，以及在游戏过程中选择和匹配游戏单位。
- en: GameplayAbilities API – implementing buffs with GameplayEffect
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameplayAbilities API – 使用GameplayEffect实现增益效果
- en: A buff is just an effect that introduces a temporary, permanent, or recurring
    change to a game unit's attributes from its `AttributeSet`. Buffs can either be
    good or bad, supplying either bonuses or penalties. For example, you might have
    a hex buff that slows a unit to half speed, an angel wing buff that increases
    unit speed by 2x, or a cherub buff that recovers `5 hp` every 5 seconds for 3
    minutes. A `GameplayEffect` affects an individual gameplay attribute in the `UAttributeSet` that's
    attached to an `AbilitySystemComponent` of an Actor.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 增益效果只是引入到游戏单位属性中的临时、永久或重复变化的效果，这些属性来自其`AttributeSet`。增益效果可以是好的或坏的，提供奖励或惩罚。例如，你可能有一个减速增益效果，将单位速度减半，一个增加单位速度2倍的翅膀增益效果，或者一个每5秒恢复`5
    hp`，持续3分钟的炽天使增益效果。`GameplayEffect`影响附着在演员`AbilitySystemComponent`的`UAttributeSet`中的单个游戏属性。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Brainstorm your game units' effects that happen during the game. Be sure that
    you've created an `AttributeSet`, as shown in the previous recipe, with gameplay
    attributes that you'd like to affect. Select an effect to implement and follow
    the succeeding steps with your example.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，头脑风暴你的游戏单位的效果。确保你已经创建了一个`AttributeSet`，如前一个菜谱中所示，其中包含你想要影响的游戏属性。选择一个要实现的效果，并按照随后的步骤使用你的示例进行操作。
- en: You may want to turn `LogAbilitySystem` into a `VeryVerbose` setting by going
    to the Output Log and typing `` ` ``, and then `Log LogAbilitySystem All`. This
    will display much more information from `AbilitySystem` in the Output Log, making
    it easier to see what's going on within the system.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望通过转到输出日志并输入` `` ``，然后输入`Log LogAbilitySystem All`将`LogAbilitySystem`转换为`VeryVerbose`设置。这将显示输出日志中来自`AbilitySystem`的更多信息，使您更容易看到系统中的情况。
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we''ll construct a quick `GameplayEffect` that heals
    `50 hp` to the selected unit''s `AttributeSet`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将构建一个快速`GameplayEffect`，为所选单位的`AttributeSet`恢复`50 hp`：
- en: 'Open up the `Warrior.h` file we created previously. In there, add the following
    function definition:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们之前创建的`Warrior.h`文件。在那里，添加以下函数定义：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Afterwards, open up `Warrior.cpp` and add the following methods:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`Warrior.cpp`并添加以下方法：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, add the following code to implement:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下代码以实现：
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use the `AddModifier` function to change the `Hp` field of `GameUnitAttributeSet`,
    as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AddModifier`函数更改`GameUnitAttributeSet`的`Hp`字段，如下所示：
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Fill in the other properties of `GameplayEffect`, including fields such as
    `DurationPolicy` and `ChanceToApplyToTarget`, or any other fields that you''d
    like to modify, as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写`GameplayEffect`的其他属性，包括`DurationPolicy`和`ChanceToApplyToTarget`等字段，或您希望修改的任何其他字段，如下所示：
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Apply the effect to an `AbilitySystemComponent` of your choice. The underlying
    `UAttributeSet` will be affected and modified by your call, as shown in the following
    piece of code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将效果应用于您选择的`AbilitySystemComponent`。底层的`UAttributeSet`将受到您的调用影响并修改，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`GameplayEffects` are simply little objects that effect changes to an actor''s
    `AttributeSet`. `GameplayEffects` can occur once, or repeatedly, in intervals
    over a `Period`. You can program-in effects pretty quickly, and the `GameplayEffect`
    class creation is intended to be inline.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameplayEffects`是简单地影响演员`AttributeSet`变化的小对象。`GameplayEffects`可以在`Period`间隔内一次性或重复发生。您可以快速编程效果，并且`GameplayEffect`类的创建旨在内联。'
- en: There's more...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Once the `GameplayEffect` is active, you will receive an `FActiveGameplayEffectHandle`.
    You can use this handle to attach a function delegate to run when the effect is
    over using the `OnRemovedDelegate` member of the `FActiveGameplayEffectHandle`.
    For example, you might call the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`GameplayEffect`激活，您将收到一个`FActiveGameplayEffectHandle`。您可以使用此句柄通过`FActiveGameplayEffectHandle`的`OnRemovedDelegate`成员附加一个函数委托，在效果结束时运行。例如，您可能调用以下代码：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: GameplayTasks API – making things happen with GameplayTasks
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameplayTasks API – 使用GameplayTasks实现功能
- en: '`GameplayTasks` are used to wrap up some gameplay functionality in a reusable
    object. All you have to do to use them is derive from the `UGameplayTask` base
    class and override some of the member functions that you prefer to implement.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameplayTasks`用于将一些游戏功能封装在可重用的对象中。您要使用它们，只需从`UGameplayTask`基类派生并重写一些您希望实现的成员函数。'
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you have not done so already, complete Steps 1-4 of the *GameplayAbilities
    API – triggering an actor's gameplay abilities with game controls* recipe to link
    to the `GameplayTasks` API in your `ProjectName.Build.cs` file and enable its
    functionality.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未这样做，请完成*GameplayAbilities API – 使用游戏控制触发演员的游戏技能*配方中的步骤1-4，以在您的`ProjectName.Build.cs`文件中链接到`GameplayTasks`
    API并启用其功能。
- en: Afterwards, go in the UE4 Editor and navigate to Class Viewer by going to Window
    | Developer Tools | Class Viewer. Under Filters, uncheck the Actors Only and Placeable
    Only options.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，进入UE4编辑器，通过转到窗口 | 开发者工具 | 类查看器导航到类查看器。在过滤器下，取消选中仅演员和仅可放置选项。
- en: 'Ensure that the `GameplayTask` object type exists:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 确保存在`GameplayTask`对象类型：
- en: '![](img/3294cedd-2012-4aee-b372-41fee61f3347.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3294cedd-2012-4aee-b372-41fee61f3347.png)'
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Click on File | Add C++ Class.... Choose to derive from `GameplayTask`. To
    do so, you must first tick Show All Classes, and then type `gameplaytask` into
    the filter box. Click on Next:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文件 | 添加C++类....选择从`GameplayTask`派生。为此，您必须首先选中显示所有类，然后在过滤器框中输入`gameplaytask`。点击下一步：
- en: '![](img/bcf5cdab-33de-40f8-82db-fc30adcbe46e.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcf5cdab-33de-40f8-82db-fc30adcbe46e.png)'
- en: 'Name your C++ class (something like `GameplayTask_TaskName` is the convention),
    then add the class to your project. The example spawns a particle emitter and
    is called `GameplayTask_CreateParticles`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的C++类命名（例如，`GameplayTask_TaskName`是惯例），然后将类添加到您的项目中。示例生成一个粒子发射器，并命名为`GameplayTask_CreateParticles`：
- en: '![](img/bbd3d5ad-3e83-46d0-abcb-5096ca481530.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbd3d5ad-3e83-46d0-abcb-5096ca481530.png)'
- en: 'Once your `GameplayTask_CreateParticles.h` and `.cpp` pair are created, navigate
    to the `.h` file and update the class to the following:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的`GameplayTask_CreateParticles.h`和`.cpp`对创建完成，导航到`.h`文件，并更新类如下：
- en: '[PRE36]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, implement the `GameplayTask_CreateParticles.cpp` file, as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现`GameplayTask_CreateParticles.cpp`文件，如下所示：
- en: '[PRE37]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Open up your `Warrior.h` file and add the following interface to the class
    definition:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`Warrior.h`文件，并将以下接口添加到类定义中：
- en: '[PRE38]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Afterwards, add the following new properties to it:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，向其中添加以下新的属性：
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Below that, add the following function definitions for the `GameplayTaskOwnerInterface`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面，为`GameplayTaskOwnerInterface`添加以下函数定义：
- en: '[PRE40]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Afterwards, go to the `Warrior.cpp` file and update the class constructor to
    the following:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，转到`Warrior.cpp`文件，更新类构造函数如下：
- en: '[PRE41]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Save your scripts, return to the Unreal Editor, and compile your code. Once
    compiled, open your `Actor` class derivative (`MyWarrior`) and then scroll down
    to the Stats section and set the Particle System property to something you''d
    like to see, for instance, the `P_Fire` option if you included the sample content
    when you created your project:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本，返回到Unreal编辑器，并编译你的代码。一旦编译完成，打开你的`Actor`类派生（`MyWarrior`），然后滚动到统计部分，将粒子系统属性设置为你想看到的内容，例如，如果你在创建项目时包含了示例内容，可以选择`P_Fire`选项：
- en: '![](img/e2540cdb-18c9-4567-9772-0bff4c83ab28.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2540cdb-18c9-4567-9772-0bff4c83ab28.png)'
- en: Which is available in the Full Blueprint Editor in the Components drop-down
    of the Components tab in the Blueprint editor. Add `GameplayTasksComponent` to
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这在完整蓝图编辑器中可用，在蓝图编辑器的组件选项卡下的组件下拉菜单中。将`GameplayTasksComponent`添加到
- en: 'Create and add an instance of your `GameplayTask` inside your `Actor` derivative
    (`MyWarrior`) instance using the following code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码在你的`Actor`派生（`MyWarrior`）实例中创建并添加一个`GameplayTask`实例：
- en: '[PRE42]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code runs anywhere in your `Actor` class derivative, any time after `GameplayTasksComponent`
    is initialized (any time after `PostInitializeComponents()`).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可以在你的`Actor`类派生中的任何位置运行，在任何`GameplayTasksComponent`初始化之后（在任何`PostInitializeComponents()`之后）。
- en: 'Compile your code. Set your level to use `MyWarrior` as the Default Pawn Type
    and when the game starts, you should notice that the particle plays:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码。将你的关卡设置为使用`MyWarrior`作为默认的Pawn类型，当游戏开始时，你应该会注意到粒子效果播放：
- en: '![](img/d976d754-77a1-43dd-9906-1e21151058ec.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d976d754-77a1-43dd-9906-1e21151058ec.png)'
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`GameplayTasks` simply register with the `GameplayTasksComponent` situated
    inside an `Actor` class derivative of your choice. You can activate any number
    of `GameplayTasks` at any time during gameplay to trigger their effects.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameplayTasks`简单地注册到位于你选择的`Actor`类派生中的`GameplayTasksComponent`。你可以在游戏中的任何时间激活任意数量的`GameplayTasks`以触发它们的效果。'
- en: '`GameplayTasks` can also kick off `GameplayEffects` to change attributes of
    `AbilitySystemsComponents` if you wish.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameplayTasks`也可以启动`GameplayEffects`来改变`AbilitySystemsComponents`的属性，如果你希望的话。'
- en: There's more...
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can derive `GameplayTasks` for any number of events in your game. What's
    more is that you can override a few more virtual functions to hook into additional
    functionality.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为游戏中的任何数量的事件派生`GameplayTasks`。更重要的是，你可以覆盖更多虚拟函数以钩入额外的功能。
- en: HTTP API – downloading webpages using web requests
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP API – 使用网络请求下载网页
- en: When you're maintaining scoreboards or other such things that require regular
    HTTP request access to servers, you can use the HTTP API to perform such web request
    tasks.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当你维护计分板或其他需要定期通过HTTP请求访问服务器的类似事物时，你可以使用HTTP API来执行此类网络请求任务。
- en: Getting ready
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have a server that you're allowed to request data via HTTP from. You can use
    a public server of any type to try out HTTP requests, if you'd like.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个你可以通过HTTP请求数据的服务器。如果你想尝试HTTP请求，可以使用任何类型的公共服务器。
- en: How to do it...
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Link to the `HTTP` API in your `ProjectName.Build.cs` file:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`ProjectName.Build.cs`文件中链接到`HTTP` API：
- en: '[PRE43]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the file that you will send your web request from (in my case, I''ll be
    using the `Chapter_11GameModeBase` class), include the new additions to the following
    code snippet:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你将发送网络请求的文件中（在我的例子中，我将使用`Chapter_11GameModeBase`类），将以下代码片段的新增内容包含进去：
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Construct an `IHttpRequest` object from `FHttpModule` using the following code:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码从`FHttpModule`构造一个`IHttpRequest`对象：
- en: '[PRE45]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`FHttpModule` is a singleton object. One copy of it exists for the entire program
    that you are meant to use for all interactions with the `FHttpModule` class.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`FHttpModule` 是一个单例对象。整个程序中只有一个它的副本，你应该用它来与 `FHttpModule` 类进行所有交互。'
- en: 'Attach your function to run to the `IHttpRequest` object''s `FHttpRequestCompleteDelegate`,
    which has the following signature:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的函数附加到 `IHttpRequest` 对象的 `FHttpRequestCompleteDelegate`，该委托具有以下签名：
- en: '[PRE46]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The delegate is found inside of the `IHttpRequest` object as `http->OnProcessRequestComplete()`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委托位于 `IHttpRequest` 对象中的 `http->OnProcessRequestComplete()` 内：
- en: '[PRE47]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There are a few ways to attach a callback function to the delegate. You can
    use the following methods:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将回调函数附加到委托中。你可以使用以下方法：
- en: 'A lambda using `delegate.BindLambda()`:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `delegate.BindLambda()` 的 lambda 表达式：
- en: '[PRE48]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Specify the URL of the site you''d like to hit:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定你想要访问的网站的 URL：
- en: '[PRE49]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Process the request by calling `ProcessRequest`:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `ProcessRequest` 处理请求：
- en: '[PRE50]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, when you run this code, you should notice the contents of the URL you
    pointed to being displayed:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你运行此代码时，你应该会注意到你指向的 URL 的内容被显示出来：
- en: '![](img/b5de988c-e6c7-4509-a9af-9ff2c3a41881.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5de988c-e6c7-4509-a9af-9ff2c3a41881.png)'
- en: HTML content of unrealengine.com displayed
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 unrealengine.com 的 HTML 内容
- en: Of course, in this instance, it's a web page, but you can easily point this
    to a CSV file, text document, or anything to obtain information for your project!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个例子中，它是一个网页，但你可以轻松地将它指向 CSV 文件、文本文档或任何其他内容，以获取你项目所需的信息！
- en: How it works...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The HTTP object is all you need to send off HTTP requests to a server and get
    HTTP responses. You can use the HTTP request/response for anything that you wish;
    for example, submitting scores to a high scores table or to retrieve text to display
    in-game from a server.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 对象是发送 HTTP 请求到服务器并获取 HTTP 响应所需的所有内容。你可以使用 HTTP 请求/响应来做任何你想做的事情；例如，将分数提交到高分榜或从服务器检索用于游戏中显示的文本。
- en: They are decked out with a URL to visit and a function callback to run when
    the request is complete. Finally, they are sent off via `FManager`. When the web
    server responds, your callback is called and the results of your HTTP response
    can be shown.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 它们配备了要访问的 URL 和请求完成时要运行的函数回调。最后，它们通过 `FManager` 发送出去。当 web 服务器响应时，你的回调被调用，并且可以显示你的
    HTTP 响应的结果。
- en: There's more...
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are also other ways in which you can attach a callback function to the
    delegate:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过其他方式将回调函数附加到委托中：
- en: 'Using any UObject''s member function:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任何 UObject 的成员函数：
- en: '[PRE51]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You cannot attach to `UFunction` directly here as the `.BindUFunction()` command
    requests arguments that are all `UCLASS`, `USTRUCT`, or `UENUM`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接附加到 `UFunction`，因为 `.BindUFunction()` 命令请求所有都是 `UCLASS`、`USTRUCT` 或 `UENUM`
    的参数。
- en: 'With any plain old C++ object''s member function, using `.BindRaw`:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于任何普通的 C++ 对象的成员函数，使用 `.BindRaw`:'
- en: '[PRE52]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You have to ensure that your `plainObject` refers to a valid object in memory
    at the time that the HTTP request completes. This means that you cannot use `TAutoPtr` on `plainObject`,
    because that will deallocate `plainObject` at the end of the block in which it
    is declared, but that may be before the HTTP request completes.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须确保你的 `plainObject` 在 HTTP 请求完成时指向内存中的有效对象。这意味着你不能在 `plainObject` 上使用 `TAutoPtr`，因为这将导致在声明它的代码块结束时释放
    `plainObject`，但这可能发生在 HTTP 请求完成之前。
- en: 'Using a global C-style static function:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局 C 风格的静态函数：
- en: '[PRE53]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When using a delegate callback with an object, be sure that the object instance
    that you're calling back on lives on at least until the point at which the `HttpResponse` arrives
    back from the server. Processing the `HttpRequest` takes real time to run. It
    is a web request after all—think of waiting for a web page to load.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用与对象相关的委托回调时，确保你调用的对象实例至少在 `HttpResponse` 从服务器返回之前仍然存在。处理 `HttpRequest` 需要实际运行时间。毕竟，它是一个网络请求——想象一下等待网页加载。
- en: You have to be sure that the object instance on which you're calling the callback
    function has not deallocated on you between the time of the initial call and the
    invocation of your `HttpHandler` function. The object must still be in memory
    when the callback returns after the HTTP request completes.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须确保在调用回调函数的对象实例在初始调用和 `HttpHandler` 函数调用之间没有被释放。当 HTTP 请求完成后，回调返回时，对象必须仍然在内存中。
- en: You cannot simply expect that the `HttpResponse` function happens immediately
    after you attach the callback function and call `ProcessRequest()`! Using a reference
    counted `UObject` instance to attach the `HttpHandler` member function is a good
    idea to ensure that the object stays in memory until the HTTP request completes.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能简单地期望在附加回调函数并调用 `ProcessRequest()` 之后立即发生 `HttpResponse` 函数！使用引用计数的 `UObject`
    实例来附加 `HttpHandler` 成员函数是一个好主意，以确保对象在 HTTP 请求完成之前保持在内存中。
- en: You can see an example of all seven possible ways it can be used inside of the
    `Chapter_11GameModeBase.cpp` file in the Example Code for this chapter.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章示例代码中的 `Chapter_11GameModeBase.cpp` 文件中看到所有七种可能的用法示例。
- en: 'You can set additional HTTP request parameters via the following member functions:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下成员函数设置额外的 HTTP 请求参数：
- en: '`SetVerb()`, to change whether you are using the `GET` or `POST` method in
    your HTTP request'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetVerb()`，用于更改您在 HTTP 请求中是否使用 `GET` 或 `POST` 方法'
- en: '`SetHeaders()`, to modify any general header settings you would like'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetHeaders()`，用于修改您希望设置的任何通用头部设置'
- en: HTTP API – displaying downloaded progress
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP API – 显示下载进度
- en: 'The `IHttpRequest` object from the HTTP API will report HTTP download progress
    via a callback on a `FHttpRequestProgressDelegate`, which is accessible via `OnRequestProgress()`.
    The signature of the function we can attach to the `OnRequestProgress()` delegate
    is as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 HTTP API 的 `IHttpRequest` 对象将通过 `FHttpRequestProgressDelegate` 上的回调报告 HTTP
    下载进度，该委托可以通过 `OnRequestProgress()` 访问。我们可以附加到 `OnRequestProgress()` 委托的函数签名如下：
- en: '[PRE54]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The three parameters of the function you may write include the original `IHttpRequest`
    object, the bytes sent, and the bytes received so far. This function gets called
    back periodically until the `IHttpRequest` object completes, which is when the
    function you attach to `OnProcessRequestComplete()` when it gets called. You can
    use the values passed to your `HandleRequestProgress` function to find out your
    progress.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要编写的函数的三个参数包括原始的 `IHttpRequest` 对象、已发送的字节数和到目前为止已接收的字节数。此函数会在 `IHttpRequest`
    对象完成时定期回调，即当调用 `OnProcessRequestComplete()` 时。您可以使用传递给您的 `HandleRequestProgress`
    函数的值来找出您的进度。
- en: Getting ready
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need an internet connection to use this recipe. We will be requesting
    a file from a public server. You can use a public server or your own private server
    for your HTTP request, if you'd like.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要一个互联网连接来使用此食谱。我们将从公共服务器请求一个文件。如果您愿意，可以使用公共服务器或您自己的私有服务器进行 HTTP 请求。
- en: In this recipe, we will bind a callback function to just the `OnRequestProgress()`
    delegate to display the download progress of a file from a server. Have a project
    ready where we can write a piece of code that will perform `IHttpRequest,` and
    a nice interface on which to display percentage progress.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将绑定一个回调函数到 `OnRequestProgress()` 委托，以显示从服务器下载文件的下载进度。请准备好一个项目，在其中我们可以编写一个执行
    `IHttpRequest` 的代码片段，以及一个用于显示百分比进度的良好界面。
- en: How to do it...
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Link to the `HTTP` API in your `ProjectName.Build.cs` file.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `ProjectName.Build.cs` 文件中链接到 `HTTP` API。
- en: 'Construct an `IHttpRequest` object using the following code:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码构建 `IHttpRequest` 对象：
- en: '[PRE55]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Provide a callback function to call when the request progresses, which updates
    our user:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个回调函数，在请求进度时调用，以更新我们的用户：
- en: '[PRE56]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Process your request with `http->ProcessRequest()`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `http->ProcessRequest()` 处理您的请求。
- en: How it works...
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `OnRequestProgress()` callback gets fired every so often with the bytes
    sent and bytes received HTTP progress. We will compute the total percentage of
    the download that is completed by calculating `(float)receivedBytes/totalLen`,
    where `totalLen` is the HTTP response's total length in bytes. Using the lambda
    function we attached to the `OnRequestProgress()` delegate callback, we can display
    the information through text.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnRequestProgress()` 回调会定期触发，带有已发送的字节数和已接收的字节数 HTTP 进度。我们将通过计算 `(float)receivedBytes/totalLen`
    来计算已完成的下载总百分比，其中 `totalLen` 是 HTTP 响应的总字节数。通过附加到 `OnRequestProgress()` 委托回调的 lambda
    函数，我们可以通过文本显示信息。'
- en: With the code in the previous *How to do it...* section as a base, it would
    be possible to create a UMG widget for a progress bar and call the `.SetPercent()`
    member function to reflect the download's progress.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节 *如何操作...* 的代码基础上，可以创建一个用于进度条的 UMG 小部件，并调用 `.SetPercent()` 成员函数来反映下载进度。
