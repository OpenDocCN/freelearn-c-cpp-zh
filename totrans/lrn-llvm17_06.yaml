- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Basics of IR Code Generation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IR 代码生成基础
- en: Having created a decorated **abstract syntax tree** (**AST**) for your programming
    language, the next task is to generate the LLVM IR code from it. LLVM IR code
    resembles a three-address code with a human-readable representation. Therefore,
    we need a systematic approach to translate language concepts such as control structures
    into the lower level of LLVM IR.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在为您的编程语言创建了一个装饰过的**抽象语法树**（**AST**）之后，接下来的任务是从它生成 LLVM IR 代码。LLVM IR 代码类似于具有人类可读表示的三地址代码。因此，我们需要一种系统性的方法来将诸如控制结构等语言概念转换为
    LLVM IR 的低级形式。
- en: In this chapter, you will learn about the basics of LLVM IR and how to generate
    IR for control flow structures from the AST. You will also learn how to generate
    LLVM IR for expressions in **static single assignment** (**SSA**) form using a
    modern algorithm. Finally, you will learn how to emit assembler text and object
    code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解 LLVM IR 的基础知识以及如何从 AST 生成控制流结构的 IR。您还将学习如何使用现代算法生成 **静态单赋值**（**SSA**）形式的
    LLVM IR。最后，您将学习如何生成汇编文本和目标代码。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Generating IR from the AST
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 AST 生成 IR
- en: Using AST numbering to generate IR code in SSA form
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AST 编号生成 SSA 形式的 IR 代码
- en: Setting up the module and the driver
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置模块和驱动程序
- en: By the end of this chapter, you will know how to create a code generator for
    your programming language and how to integrate it into your compiler.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何为您的编程语言创建代码生成器以及如何将其集成到您的编译器中。
- en: Generating IR from the AST
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 AST 生成 IR
- en: 'The LLVM code generator takes a module in LLVM IR as input and turns it into
    object code or assembly text. We need to transform the AST representation into
    IR. To implement an IR code generator, we will look at a simple example first
    and then develop the classes needed for the code generator. The complete implementation
    will be divided into three classes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 代码生成器接受一个以 LLVM IR 表示的模块作为输入，并将其转换为目标代码或汇编文本。我们需要将 AST 表示转换为 IR。为了实现 IR
    代码生成器，我们首先将查看一个简单的示例，然后开发代码生成器所需的类。完整的实现将分为三个类：
- en: '`CodeGenerator`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CodeGenerator`'
- en: '`CGModule`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGModule`'
- en: '`CGProcedure`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGProcedure`'
- en: The `CodeGenerator` class is the general interface used by the compiler driver.
    The `CGModule` and `CGProcedure` classes hold the state required for generating
    the IR code for a compilation unit and a single function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`CodeGenerator` 类是编译器驱动程序使用的通用接口。`CGModule` 和 `CGProcedure` 类包含生成编译单元和单个函数的
    IR 代码所需的状态。'
- en: We’ll begin by looking at the Clang-generated IR.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看 Clang 生成的 IR。
- en: Understanding the IR code
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 IR 代码
- en: 'Before generating the IR code, it’s good to know the main elements of the IR
    language. In [*Chapter 2*](B19561_02.xhtml#_idTextAnchor037), *The Structure of
    a Compiler*, we had a brief look at IR. An easy way to get more knowledge of IR
    is to study the output from `clang`. For example, save this C source code, which
    implements the Euclidean algorithm for calculating the greatest common divisor
    of two numbers, as `gcd.c`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成 IR 代码之前，了解 IR 语言的主要元素是很有帮助的。在 [*第 2 章*](B19561_02.xhtml#_idTextAnchor037)，*编译器的结构*中，我们简要地了解了
    IR。了解 IR 的一个简单方法是通过研究 `clang` 的输出。例如，将实现计算两个数最大公约数的欧几里得算法的 C 源代码保存为 `gcd.c`：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you can create the `gcd.ll` IR file by using `clang` and the following
    command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `clang` 和以下命令创建 `gcd.ll` IR 文件：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The IR code is not target-independent, even if it often looks like it is. The
    preceding command compiles the source file for an ARM 64-bit CPU on Linux. The
    `-S` option instructs `clang` to output an assembly file, and with the additional
    specification of `-emit-llvm`, an IR file is created. The optimization level,
    `-O1`, is used to get an easily readable IR code. Clang has many more options,
    all of which are documented in the command-line argument reference at [https://clang.llvm.org/docs/ClangCommandLineReference.html](https://clang.llvm.org/docs/ClangCommandLineReference.html).
    Let’s have a look at the generated file and understand how the C source maps to
    the LLVM IR.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: IR 代码不是目标无关的，尽管它通常看起来是这样。前面的命令编译了 Linux 上 ARM 64 位 CPU 的源文件。`-S` 选项指示 `clang`
    输出一个汇编文件，通过添加 `-emit-llvm` 的额外指定，创建了一个 IR 文件。使用 `-O1` 优化级别可以得到易于阅读的 IR 代码。Clang
    有许多其他选项，所有这些都在 [https://clang.llvm.org/docs/ClangCommandLineReference.html](https://clang.llvm.org/docs/ClangCommandLineReference.html)
    的命令行参数参考中有记录。让我们看一下生成的文件，并了解 C 源代码如何映射到 LLVM IR。
- en: A C file is translated into a `i`, followed by the number of bits. For example,
    the 64-bit integer type is written as `i64`. The most basic float types are `float`
    and `double`, denoting the 32-bit and 64-bit IEEE floating-point types. It is
    also possible to create aggregate types such as vectors, arrays, and structures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C 文件被翻译成 `i`，后面跟着位数。例如，64 位整数类型写作 `i64`。最基本的浮点类型是 `float` 和 `double`，分别表示 32
    位和 64 位的 IEEE 浮点类型。还可以创建聚合类型，如向量、数组和结构体。
- en: 'Here is what the LLVM IR looks like. At the top of the file, some basic properties
    are established:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 LLVM IR 的样子。在文件顶部，定义了一些基本属性：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line is a comment informing you about which module identifier was
    used. In the following line, the filename of the source file is named. With `clang`,
    both are the same.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个注释，告诉你使用了哪个模块标识符。在下一行中，指定了源文件的文件名。使用 `clang` 时，两者相同。
- en: 'The `target datalayout` string establishes some basic properties. The different
    parts are separated by `-`. The following information is included:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`target datalayout` 字符串建立了一些基本属性。不同的部分由 `-` 分隔。以下信息包括：'
- en: A small `e` means that bytes in memory are stored using the little-endian schema.
    To specify a big endian, you must use a big `E`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写的 `e` 表示内存中的字节使用小端模式存储。要指定大端模式，必须使用大写的 `E`。
- en: '`M:` specifies the name mangling that’s applied to symbols. Here, `m:e` means
    that ELF name mangling is used.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M:` 指定了应用于符号的名称修饰。在这里，`m:e` 表示使用 ELF 名称修饰。'
- en: The entries in `iN:A:P` form, such as`i8:8:32`, specify the alignment of data,
    given in bits. The first number is the alignment required by the ABI, and the
    second number is the preferred alignment. For bytes (`i8`), the ABI alignment
    is 1 byte (`8`) and the preferred alignment is 4 bytes (`32`).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iN:A:P` 形式的条目，如 `i8:8:32`，指定了数据对齐方式，以位为单位。第一个数字是 ABI 所需的对齐方式，第二个数字是首选对齐方式。对于字节（`i8`），ABI
    对齐是 1 字节（`8`），首选对齐是 4 字节（`32`）。'
- en: '`n` specifies which native register sizes are available. `n32:64` means that
    32-bit and 64-bit wide integers are natively supported.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` 指定了哪些本地寄存器大小可用。`n32:64` 表示原生支持 32 位和 64 位宽整数。'
- en: '`S` specifies the alignment of the stack, again in bits. `S128` means that
    the stack maintains a 16-byte alignment.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S` 指定了栈的对齐方式，再次以位为单位。`S128` 表示栈保持 16 字节对齐。'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The provided target data layout must match what the backend expects. Its purpose
    is to communicate the captured information to the target-independent optimization
    passes. For example, an optimization pass can query the data layout to get the
    size and alignment of a pointer. However, changing the size of a pointer in the
    data layout does not change the code generation in the backend.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的目标数据布局必须与后端期望的相匹配。它的目的是将捕获的信息传达给与目标无关的优化过程。例如，优化过程可以查询数据布局以获取指针的大小和对齐方式。然而，在数据布局中更改指针的大小不会改变后端的代码生成。
- en: A lot more information is provided with the target data layout. You can find
    more information in the reference manual at [https://llvm.org/docs/LangRef.html#data-layout](https://llvm.org/docs/LangRef.html#data-layout).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目标数据布局提供了更多信息。你可以在参考手册中找到更多信息，手册地址为 [https://llvm.org/docs/LangRef.html#data-layout](https://llvm.org/docs/LangRef.html#data-layout)。
- en: 'Last, the `target triple` string specifies the architecture we are compiling
    for. This reflects the information we gave on the command line. The triple is
    a configuration string that usually consists of the CPU architecture, the vendor,
    and the operating system. More information about the environment is often added.
    For example, the `x86_64-pc-win32` triple is used for a Windows system running
    on a 64-bit X86 CPU. `x86_64` is the CPU architecture, `pc` is a generic vendor,
    and `win32` is the operating system. The parts are connected by a hyphen. A Linux
    system running on an ARMv8 CPU uses `aarch64-unknown-linux-gnu` as its triple.
    `aarch64` is the CPU architecture, while the operating system is `linux` running
    a `gnu` environment. There is no real vendor for a Linux-based system, so this
    part is `unknown`. Parts that are not known or unimportant for a specific purpose
    are often omitted: the `aarch64-linux-gnu` triple describes the same Linux system.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`target triple` 字符串指定了我们正在为其编译的架构。这反映了我们在命令行上给出的信息。三元组是一个配置字符串，通常由 CPU 架构、供应商和操作系统组成。经常还会添加更多关于环境的信息。例如，`x86_64-pc-win32`
    三元组用于在 64 位 X86 CPU 上运行的 Windows 系统。`x86_64` 是 CPU 架构，`pc` 是一个通用的供应商，`win32` 是操作系统。这些部分由连字符连接。在
    ARMv8 CPU 上运行的 Linux 系统使用 `aarch64-unknown-linux-gnu` 作为其三元组。`aarch64` 是 CPU 架构，操作系统是运行在
    `gnu` 环境下的 `linux`。对于基于 Linux 的系统，实际上没有真正的供应商，所以这部分是 `unknown`。对于特定目的不重要或不为人知的部分通常会被省略：`aarch64-linux-gnu`
    三元组描述了相同的 Linux 系统。
- en: 'Next, the `gcd` function is defined in the IR file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 IR 文件中定义了 `gcd` 函数：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This resembles the function signature in the C file. The `unsigned` data type
    is translated into the 32-bit integer type, `i32`. The function name is prefixed
    with `@`, and the parameter names are prefixed with `%`. The body of the function
    is enclosed in curly braces. The code of the body follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 C 文件中的函数签名相似。`unsigned` 数据类型被转换为 32 位整数类型，`i32`。函数名前缀为 `@`，参数名前缀为 `%`。函数体被大括号包围。函数体的代码如下：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The IR code is organized into so-called `entry`. The code in the block is simple:
    the first instruction compares the `%b` parameter against `0`. The second instruction
    branches to the `return` label if the condition is `true` and to the `while.body`
    label if the condition is `false`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: IR 代码被组织成所谓的 `entry`。该块中的代码很简单：第一条指令比较 `%b` 参数与 `0`。第二条指令在条件为 `true` 时跳转到 `return`
    标签，在条件为 `false` 时跳转到 `while.body` 标签。
- en: Another characteristic of the IR code is that it is in a `%cmp`. This register
    is then used, but it is never written again. Optimizations such as constant propagation
    and common-sub-expression elimination work very well with the SSA form and all
    modern compilers are using it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: IR 代码的另一个特点是它位于 `%cmp` 中。然后使用这个寄存器，但从未再次写入。常量传播和公共子表达式消除等优化与 SSA 形式配合得很好，并且所有现代编译器都在使用它。
- en: SSA
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SSA
- en: 'The SSA form was developed in the late 1980s. Since then, it has been widely
    used in compilers because it simplifies data flow analysis and optimizations.
    For example, the identification of common sub-expressions inside a loop becomes
    much easier if the IR is in SSA form. A basic property of SSA is that it establishes
    `def-use` and `use-def` chains: for a single definition, you know of all uses
    (`def-use`), and for each use, you know the unique definition (`use-def`). This
    knowledge is used a lot, such as in constant propagation: if a definition is determined
    to be a constant, then all uses of this value can be easily replaced with that
    constant value.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: SSA 形式是在 1980 年代末开发的。从那时起，它被广泛用于编译器，因为它简化了数据流分析和优化。例如，如果 IR 是 SSA 形式，那么在循环内识别公共子表达式会变得容易得多。SSA
    的一个基本特性是它建立了 `def-use` 和 `use-def` 链：对于单个定义，你知道所有的使用（`def-use`），对于每个使用，你知道唯一的定义（`use-def`）。这种知识被大量使用，例如在常量传播中：如果一个定义被确定为常量，那么这个值的所有使用都可以轻松地替换为那个常量值。
- en: To construct the SSA form, the algorithm from Cytron et al. (1989) is very popular,
    and it is also used in the LLVM implementation. Other algorithms have been developed
    too. An early observation is that these algorithms become simpler if the source
    language does not have a `goto` statement.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建 SSA 形式，Cytron 等人于 1989 年提出的算法非常流行，并且也被用于 LLVM 实现。也开发出了其他算法。一个早期的观察是，如果源语言没有
    `goto` 语句，这些算法会变得更简单。
- en: An in-depth treatment of SSA can be found in the book *SSA-based Compiler Design*,
    by F. Rastello and F. B. Tichadou, Springer 2022.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F. Rastello 和 F. B. Tichadou 所著的《基于 SSA 的编译器设计》一书中可以找到对 SSA 的深入探讨，Springer
    2022 年出版。
- en: 'The next basic block is the body of the `while` loop:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个基本块是 `while` 循环的主体：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inside the loop of `gcd`, the `a` and `b` parameters are assigned new values.
    If a register can be only written once, then this is not possible. The solution
    is to use the special `phi` instruction. The `phi` instruction has a list of basic
    blocks and values as parameters. A basic block presents the incoming edge from
    that basic block, and the value is the value from that basic block. At runtime,
    the `phi` instruction compares the label of the previously executed basic block
    with the labels in the parameter list.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gcd` 循环内部，`a` 和 `b` 参数被分配了新的值。如果寄存器只能写入一次，那么这是不可能的。解决方案是使用特殊的 `phi` 指令。`phi`
    指令有一个基本块列表和值作为参数。基本块表示从该基本块进入的边，值是来自该基本块的值。在运行时，`phi` 指令将之前执行的基本块的标签与参数列表中的标签进行比较。
- en: The value of the instruction is the value that’s associated with the label.
    For the first `phi` instruction, the value is the `%rem` register if the previously
    executed basic block was `while.body`. The value is `%b` if `entry` was the previously
    executed basic block. The values are the ones at the start of the basic block.
    The `%b.loop` register gets a value from the first `phi` instruction. The same
    register is used in the parameter list of the second `phi` instruction, but the
    value is assumed to be the one before it is changed through the first `phi` instruction.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的值是与标签关联的值。对于第一个 `phi` 指令，如果之前执行的基本块是 `while.body`，则值是 `%rem` 寄存器。如果 `entry`
    是之前执行的基本块，则值是 `%b`。值是基本块开始时的值。`%b.loop` 寄存器从第一个 `phi` 指令获取值。在第二个 `phi` 指令的参数列表中使用相同的寄存器，但假设的值是它通过第一个
    `phi` 指令更改之前的值。
- en: 'After the loop’s body, the return value must be chosen:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环主体之后，必须选择返回值：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, a `phi` instruction is used to select the desired value. The `ret` instruction
    not only ends this basic block but also denotes the end of this function at runtime.
    It has the return value as a parameter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，使用 `phi` 指令来选择所需的值。`ret` 指令不仅结束这个基本块，而且在运行时也标志着这个函数的结束。它将返回值作为参数。
- en: 'There are some restrictions on the use of `phi` instructions. They must be
    the first instructions of a basic block. The first basic block is special: it
    has no previously executed block. Therefore, it cannot begin with a `phi` instruction.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `phi` 指令的使用有一些限制。它们必须是基本块的第一条指令。第一个基本块是特殊的：它没有之前执行过的块。因此，它不能以 `phi` 指令开始。
- en: LLVM IR reference
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM IR 参考
- en: We’ve only touched the very basics of the LLVM IR. Please visit the LLVM Language
    Reference Manual at [https://llvm.org/docs/LangRef.html](https://llvm.org/docs/LangRef.html)
    to look up all the details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只接触了 LLVM IR 的基础知识。请访问 [https://llvm.org/docs/LangRef.html](https://llvm.org/docs/LangRef.html)
    中的 LLVM 语言参考手册以查找所有详细信息。
- en: The IR code itself looks a lot like a mix of C and assembly language. Despite
    this familiar style, it is not clear how we can easily generate the IR code from
    an AST. The `phi` instruction in particular looks difficult to generate. But don’t
    be scared – in the next section, we’ll implement a simple algorithm to just do
    that!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: IR 代码本身看起来很像 C 和汇编语言的混合体。尽管这种风格很熟悉，但我们并不清楚如何轻松地从 AST 生成 IR 代码。特别是 `phi` 指令看起来很难生成。但别害怕——在下一节中，我们将实现一个简单的算法来完成这项工作！
- en: Learning about the load-and-store approach
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解加载和存储方法
- en: All local optimizations in LLVM are based on the SSA form shown here. For global
    variables, memory references are used. The IR language knows load and store instructions,
    which are used to fetch and store those values. You can use this for local variables
    too. These instructions do not belong to the SSA form, and LLVM knows how to convert
    them into the required SSA form. Therefore, you can allocate memory slots for
    each local variable and use load and store instructions to change their value.
    All you need to remember is the pointer to the memory slot where a variable is
    stored. The `clang` compiler uses this approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 中所有的本地优化都基于这里显示的 SSA 形式。对于全局变量，使用内存引用。IR 语言知道加载和存储指令，用于获取和存储这些值。您也可以为局部变量使用此方法。这些指令不属于
    SSA 形式，LLVM 知道如何将它们转换为所需的 SSA 形式。因此，您可以为每个局部变量分配内存槽，并使用加载和存储指令来更改它们的值。您只需要记住变量存储的内存槽的指针。`clang`
    编译器使用这种方法。
- en: 'Let’s look at the IR code for load and store. Compile `gcd.c` again, but this
    time without enabling optimization:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看加载和存储的 IR 代码。再次编译 `gcd.c`，但这次不启用优化：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `gcd` function now looks different. This is the first basic block:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcd` 函数现在看起来不同了。这是第一个基本块：'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The IR code now relies on the automatic numbering of registers and labels. The
    names of the parameters are not specified. Implicitly, they are `%0` and `%1`.
    The basic block has no label, so `2` is assigned. The first few instructions allocate
    memory for the four 32-bit values. After that, the `%0` and `%1` parameters are
    stored in the memory slots pointed to by registers `%4` and `%5`. To compare `%1`
    to `0`, the value is explicitly loaded from the memory slot. With this approach,
    you do not need to use the `phi` instruction! Instead, you load a value from a
    memory slot, perform a calculation on it, and store the new value back in the
    memory slot. The next time you read the memory slot, you get the last computed
    value. All the other basic blocks for the `gcd` function follow this pattern.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 IR 代码依赖于寄存器和标签的自动编号。参数的名称没有指定。隐含地，它们是 `%0` 和 `%1`。基本块没有标签，因此分配了 `2`。前几条指令为四个
    32 位值分配内存。之后，`%0` 和 `%1` 参数存储在由寄存器 `%4` 和 `%5` 指向的内存槽中。为了比较 `%1` 与 `0`，显式地从内存槽中加载了值。使用这种方法，你不需要使用
    `phi` 指令！相反，你从内存槽中加载一个值，对其进行计算，然后将新值存储回内存槽。下次你读取内存槽时，你会得到最后计算出的值。`gcd` 函数的所有其他基本块都遵循这个模式。
- en: The advantage of using load and store instructions in this way is that it is
    fairly easy to generate the IR code. The disadvantage is that you generate a lot
    of IR instructions that LLVM will remove with the `mem2reg` pass in the very first
    optimization step, after converting the basic block into SSA form. Therefore,
    we generate the IR code in SSA form directly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用加载和存储指令的优点是生成 IR 代码相对容易。缺点是你会生成大量的 IR 指令，LLVM 将在将基本块转换为 SSA 形式后的第一个优化步骤中通过
    `mem2reg` 过滤器删除这些指令。因此，我们直接以 SSA 形式生成 IR 代码。
- en: We’ll start developing IR code generation by mapping the control flow to basic
    blocks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始通过将控制流映射到基本块来开发 IR 代码生成。
- en: Mapping the control flow to basic blocks
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将控制流映射到基本块
- en: The conceptual idea of a basic block is that it is a *linear sequence of instructions*
    that are executed in that order. A basic block has exactly one entry at the beginning,
    and it ends with a terminator instruction, which is an instruction that transfers
    the control flow to another basic block, such as a branch instruction, a switch
    instruction, or a return instruction. See [https://llvm.org/docs/LangRef.html#terminator-instructions](https://llvm.org/docs/LangRef.html#terminator-instructions)
    for a complete list of terminator instructions. A basic block can begin with `phi`
    instructions, but inside a basic block, neither `phi` nor branch instructions
    are allowed. In other words, you can only enter a basic block at the first instruction,
    and you can only leave a basic block at the last instruction, which is the terminator
    instruction. It is not possible to branch to an instruction inside a basic block
    or to branch to another basic block from the middle of a basic block. Please note
    that a simple function call with the `call` instruction can occur inside a basic
    block. Each basic block has exactly one label, marking the first instruction of
    the basic block. Labels are the targets of branch instructions. You can view branches
    as directed edges between two basic blocks, resulting in the **control flow graph**
    (**CFG**). A basic block can have **predecessors** and **successors**. The first
    basic block of a function is special in the sense that no predecessors are allowed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基本块的概念是它是一个 *按顺序执行的线性指令序列*。基本块在开始处恰好有一个入口，并以一个终止指令结束，这是一个将控制流转移到另一个基本块的指令，例如分支指令、切换指令或返回指令。有关终止指令的完整列表，请参阅
    [https://llvm.org/docs/LangRef.html#terminator-instructions](https://llvm.org/docs/LangRef.html#terminator-instructions)。基本块可以以
    `phi` 指令开始，但在基本块内部不允许 `phi` 或分支指令。换句话说，你只能从第一个指令进入基本块，你只能从最后一个指令离开基本块，即终止指令。不可能从基本块内部的指令分支，也不可能从基本块中间分支到另一个基本块。请注意，使用
    `call` 指令的简单函数调用可以在基本块内部发生。每个基本块恰好有一个标签，标记基本块的第一条指令。标签是分支指令的目标。你可以将分支视为两个基本块之间的有向边，从而形成
    **控制流图**（**CFG**）。基本块可以有 **前驱** 和 **后继**。函数的第一个基本块在意义上是特殊的，不允许有前驱。
- en: 'As a consequence of these restrictions, control statements of the source language,
    such as `WHILE` and `IF`, produce several basic blocks. Let’s look at the `WHILE`
    statement. The condition of the `WHILE` statement controls if the loop body or
    the next statement is executed. The condition must be generated in a basic block
    of its own because there are two predecessors:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制，源语言的控制语句，如 `WHILE` 和 `IF`，会产生多个基块。让我们看看 `WHILE` 语句。`WHILE` 语句的条件控制循环体或下一个语句是否执行。条件必须在它自己的基块中生成，因为它有两个前驱：
- en: The basic block resulting from the statement before `WHILE`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `WHILE` 语句前的语句产生的基块
- en: The branch from the end of the loop body back to the condition
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从循环体末尾返回到条件的分支
- en: 'There are also two successors:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也有两个后继：
- en: The beginning of the loop body
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环体的开始
- en: The basic block resulting from the statement following `WHILE`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `WHILE` 语句后的语句产生的基块
- en: 'The loop body itself has at least one basic block:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 循环体本身至少有一个基块：
- en: '![Figure 4.1 – The basic blocks of a WHILE statement](img/B19561_04_1.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – WHILE 语句的基块](img/B19561_04_1.jpg)'
- en: Figure 4.1 – The basic blocks of a WHILE statement
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – WHILE 语句的基块
- en: 'The IR code generation follows this structure. We store a pointer to the current
    basic block in the `CGProcedure` class and use an instance of `llvm::IRBuilder<>`
    to insert instructions into the basic block. First, we create the basic blocks:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: IR 代码生成遵循这个结构。我们在 `CGProcedure` 类中存储当前基块的指针，并使用 `llvm::IRBuilder<>` 实例将指令插入到基块中。首先，我们创建基本块：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Fn` variable denotes the current function and `getLLVMCtx()` returns the
    LLVM context. Both are set later. We end the current basic block with a branch
    to the basic block, which will hold the condition:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fn` 变量表示当前函数，`getLLVMCtx()` 返回 LLVM 上下文。这两个都是在之后设置的。我们通过一个分支结束当前基块，该分支将持有条件：'
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The basic block for the condition becomes the new current basic block. We generate
    the condition and end the block with a conditional branch:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 条件的基块变为新的当前基块。我们生成条件，并以条件分支结束该块：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we generate the loop body. Finally, we add a branch back to the basic
    block of the condition:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们生成循环体。最后，我们添加一个返回到条件基块的分支：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With that, we have generated the `WHILE` statement. Now that we’ve generated
    the `WhileCondBB` and `Curr` blocks, we can seal them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就生成了 `WHILE` 语句。现在我们已经生成了 `WhileCondBB` 和 `Curr` 基块，我们可以将它们封闭：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The empty basic block for statements following `WHILE` becomes the new current
    basic block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHILE` 语句后的语句的空基块变为新的当前基块：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Following this schema, you can create an `emit()` method for each statement
    of the source language.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个模式，你可以为源语言中的每个语句创建一个 `emit()` 方法。
- en: Using AST numbering to generate IR code in SSA form
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AST 编号生成 SSA 形式的 IR 代码
- en: To generate IR code in SSA form from the AST, we can use an approach called
    **AST numbering**. The basic idea is that for each basic block, we store the current
    value of local variables written in this basic block.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 AST 生成 SSA 形式的 IR 代码，我们可以使用一种称为 **AST 编号** 的方法。基本思想是，对于每个基本块，我们存储在此基本块中写入的局部变量的当前值。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The implementation is based on the paper *Simple and Efficient Construction
    of Static Single Assignment Form*, by Braun et al., International Conference on
    CompilerConstruction 2013 (CC 2013), Springer (see http://individual.utoronto.ca/dfr/ece467/braun13.pdf).
    In its presented form, it only works for IR code that has a structured controlled
    flow. The paper also describes the necessary extensions if you need to support
    arbitrary control flow – for example, a `goto` statement.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实现基于 Braun 等人撰写的论文《简单且高效的静态单赋值形式构建》，发表于 2013 年国际编译器构造会议（CC 2013），Springer（见
    http://individual.utoronto.ca/dfr/ece467/braun13.pdf）。在其呈现的形式中，它仅适用于具有结构化控制流的
    IR 代码。该论文还描述了如果需要支持任意控制流（例如，`goto` 语句）所需的必要扩展。
- en: Although it is simple, we will still need several steps. We will introduce the
    required data structure first, and after that, we will learn how to read and write
    values local to a basic block. Then, we will handle values that are used in several
    basic blocks and conclude by optimizing the created `phi` instructions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它很简单，但我们仍然需要几个步骤。我们首先介绍所需的数据结构，然后我们将学习如何读取和写入基本块本地的值。然后，我们将处理在多个基本块中使用的值，并通过优化创建的
    `phi` 指令来结束。
- en: Defining the data structure to hold values
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义用于存储值的数结构
- en: 'We use the `BasicBlockDef` struct to hold the information for a single block:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `BasicBlockDef` 结构体来保存单个块的信息：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `llvm::Value` LLVN class represents a value in SSA form. The `Value` class
    acts like a label on the result of a computation. It is created once, usually
    through an IR instruction, and then used. Various changes can occur during optimizations.
    For example, if the optimizer detects that the `%1` and `%2` values are always
    the same, then it can replace the use of `%2` with `%1`. This changes the label
    but not the computation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm::Value` 类表示 SSA 形式中的值。`Value` 类类似于计算结果的标签。它一旦创建，通常通过 IR 指令创建，然后使用。在优化过程中可能会发生各种变化。例如，如果优化器检测到
    `%1` 和 `%2` 值始终相同，那么它可以替换 `%2` 的使用为 `%1`。这改变了标签，但没有改变计算。'
- en: 'To be aware of such changes, we cannot use the `Value` class directly. Instead,
    we need a value handle. There are value handles with different functionality.
    To track replacement, we can use the `llvm::TrackingVH<>` class. As a result,
    the `Defs` member maps a declaration of the AST (a variable or a formal parameter)
    to its current value. Now, we need to store this information for each basic block:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了意识到这样的变化，我们不能直接使用 `Value` 类。相反，我们需要一个值句柄。有不同的功能值句柄。为了跟踪替换，我们可以使用 `llvm::TrackingVH<>`
    类。结果，`Defs` 成员将 AST（变量或形式参数）的声明映射到其当前值。现在，我们需要为每个基本块存储这些信息：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this data structure, we are now able to handle local values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种数据结构，我们现在能够处理局部值。
- en: Reading and writing values local to a basic block
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入基本块内的局部值
- en: 'To store the current value of a local variable in a basic block, we will create
    an entry in the maps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基本块中存储局部变量的当前值，我们将在映射中创建一个条目：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The lookup of a variable’s value is a bit more complicated because the value
    might not be in the basic block. In this case, we need to extend the search to
    the predecessors using a possible recursive search:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 查找变量的值稍微复杂一些，因为值可能不在基本块中。在这种情况下，我们需要通过可能的递归搜索扩展搜索到前驱：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The real work is searching the predecessors, which we’ll implement in the next
    section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的工作是搜索前驱，我们将在下一节中实现它。
- en: Searching the predecessor blocks for a value
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在前驱块中搜索值
- en: If the current basic block we are looking at has only one predecessor, then
    we search there for the value of the variable. If the basic block has several
    predecessors, then we need to search for the value in all these blocks and combine
    the results. To illustrate this situation, you can look at the basic block with
    the condition of a `WHILE` statement from the previous section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在查看的当前基本块只有一个前驱，那么我们将在那里搜索变量的值。如果一个基本块有多个前驱，那么我们需要在这些所有块中搜索值并组合结果。为了说明这种情况，你可以查看上一节中
    `WHILE` 语句条件的那个基本块。
- en: This basic block has two predecessors – the one resulting from the statement
    before the `WHILE` statement and the one resulting from the branch for the end
    of the body of the `WHILE` loop. A variable that’s used in the condition should
    have some initial value and will most likely be changed in the body of the loop.
    So, we need to collect these definitions and create a `phi` instruction from it.
    The basic blocks that are created from the `WHILE` statement contain a cycle.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本块有两个前驱 - 一个是由 `WHILE` 语句之前的语句产生的，另一个是由 `WHILE` 循环体结束的分支产生的。在条件中使用的变量应该有一些初始值，并且很可能会在循环体中被更改。因此，我们需要收集这些定义并从中创建一个
    `phi` 指令。由 `WHILE` 语句创建的基本块包含一个循环。
- en: 'Because we recursively search the predecessor blocks, we must break this cycle.
    To do so, we can use a simple trick: we can insert an empty `phi` instruction
    and record this as the current value of the variable. If we see this basic block
    again in our search, then we’ll see that the variable has a value that we can
    use. The search stops at this point. Once we’ve collected all the values, we must
    update the `phi` instruction.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们会递归地搜索前驱块，我们必须打破这个循环。为此，我们可以使用一个简单的技巧：我们可以插入一个空的 `phi` 指令，并将其记录为变量的当前值。如果我们再次在搜索中看到这个基本块，那么我们会看到变量有一个我们可以使用的值。搜索在这里停止。一旦我们收集了所有值，我们必须更新
    `phi` 指令。
- en: However, we will still face a problem. At the time of the lookup, not all predecessors
    of a basic block may be known. How can this happen? Look at the creation of the
    basic blocks for the `WHILE` statement. The IR for the condition of the loop is
    generated first. However, the branch from the end of the body that goes back to
    the basic block, which contains the condition, can only be added after the IR
    for the body is generated. This is because this basic block is not known earlier.
    If we need to read the value of a variable in the condition, then we are stuck,
    because not all predecessors are known.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然会面临一个问题。在查找时，基本块的所有前驱可能并不都是已知的。这怎么可能发生呢？看看`WHILE`语句的基本块的创建。循环条件的IR首先生成。然而，从体尾返回包含条件的那个基本块的分支只能在体IR生成后添加。这是因为这个基本块在之前是未知的。如果我们需要读取条件中变量的值，那么我们就陷入了困境，因为并非所有前驱都是已知的。
- en: 'To solve this situation, we must do a little more:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须做更多一点：
- en: First, we must attach a `Sealed` flag to the basic block.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须给基本块附加一个`Sealed`标志。
- en: Then, we must define a basic block as sealed if we know all the predecessors
    of the basic block. If the basic block is not sealed and we need to look up the
    value of the variable not yet defined in this basic block, then we must insert
    an empty `phi` instruction and use it as the value.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果我们知道基本块的所有前驱，我们必须定义基本块为密封的。如果基本块未密封并且我们需要查找在此基本块中尚未定义的变量的值，那么我们必须插入一个空的`phi`指令并使用它作为值。
- en: 'We also need to remember this instruction. If the block is later sealed, then
    we need to update the instruction with the real values. To implement this, we
    must add two more members to `struct BasicBlockDef`: the `IncompletePhis` map,
    which records the `phi` instructions we need later to update, and the `Sealed`
    flag, which indicates if the basic block is sealed:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要记住这个指令。如果块后来被密封，那么我们需要更新指令以使用真实值。为了实现这一点，我们必须向`struct BasicBlockDef`添加两个额外的成员：`IncompletePhis`映射，它记录了我们稍后需要更新的`phi`指令，以及`Sealed`标志，它表示基本块是否被密封：
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, the method can be implemented, as discussed at the beginning of this
    section:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，可以按照本节开头讨论的方法实现该方法：
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `addEmptyPhi()` method inserts an empty `phi` instruction at the beginning
    of the basic block:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addEmptyPhi()`方法在基本块的开头插入一个空的`phi`指令：'
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To add the missing operands to the `phi` instruction, first, we must search
    all the predecessors of the basic block and add the operand pair value and basic
    block to the `phi` instruction. Then, we must try to optimize the instruction:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向`phi`指令添加缺失的操作数，首先，我们必须搜索基本块的所有前驱，并将操作数对值和基本块添加到`phi`指令中。然后，我们必须尝试优化指令：
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This algorithm can generate unneeded `phi` instructions. One approach to optimize
    these will be implemented in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可能会生成不必要的`phi`指令。在下一节中，我们将实现一种优化这些指令的方法。
- en: Optimizing the generated phi instructions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化生成的`phi`指令
- en: 'How can we optimize a `phi` instruction and why should we do it? Although the
    SSA form is advantageous for many optimizations, the `phi` instruction is often
    not interpreted by the algorithms and thus hinders the optimization in general.
    Therefore, the fewer `phi` instructions we generate, the better. Let’s take a
    closer look:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何优化`phi`指令，为什么我们应该这样做？尽管SSA形式对许多优化有利，但`phi`指令通常不被算法解释，从而阻碍了整体的优化。因此，我们生成的`phi`指令越少，越好。让我们更仔细地看看：
- en: 'If the instruction has only one operand or all operands have the same value,
    then we replace the instruction with this value. If the instruction has no operand,
    then we replace the instruction with the special `Undef` value. Only if the instruction
    has two or more distinct operands do we have to keep the instruction:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指令只有一个操作数或者所有操作数都有相同的值，那么我们用这个值替换指令。如果指令没有操作数，那么我们用特殊的`Undef`值替换指令。只有当指令有两个或更多不同的操作数时，我们才必须保留指令：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Removing a `phi` instruction may lead to optimization opportunities in other
    `phi` instructions. Fortunately, LLVM keeps track of the users and the use of
    values (which is the `use-def` chain mentioned in the definition of SSA). We must
    search for all uses of the value in other `phi` instructions and try to optimize
    these instructions too:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`phi`指令可能会导致其他`phi`指令中的优化机会。幸运的是，LLVM跟踪用户和值的用法（这是在SSA定义中提到的`use-def`链）。我们必须搜索其他`phi`指令中值的所有用法，并尝试优化这些指令：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we want, we can improve this algorithm even further. Instead of always iterating
    the list of values for each `phi` instruction, we can pick and remember two distinct
    values. Then, in the `optimizePhi` function, we can check if these two values
    are still in the list of the `phi` instruction. If that is the case, then we know
    that there is nothing to optimize. But even without this optimization, this algorithm
    runs very fast, so we are not going to implement this now.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以进一步改进这个算法。我们不必总是迭代每个 `phi` 指令的值列表，我们可以选择并记住两个不同的值。然后，在 `optimizePhi`
    函数中，我们可以检查这两个值是否仍然在 `phi` 指令的列表中。如果是这样，那么我们就知道没有什么可以优化的。但即使没有这个优化，这个算法运行得非常快，所以我们现在不会实现它。
- en: We are almost done. The only thing we haven’t done is implement the operation
    to seal a basic block. We will do this in the next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。我们还没有做的事情是实现封闭基本块的运算。我们将在下一节中这样做。
- en: Sealing a block
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封闭一个块
- en: As soon as we know that all the predecessors of a block are known, we can seal
    the block. If the source language contains only structured statements such as
    `tinylang`, then it is easy to determine where a block can be sealed. Take another
    look at the basic blocks that are generated for the `WHILE` statement.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道一个块的所有前驱都已知，我们就可以封闭这个块。如果源语言只包含结构化语句，如 `tinylang`，那么确定可以封闭块的位置很容易。再次看看为
    `WHILE` 语句生成的基块。
- en: 'The basic block that contains the condition can be sealed after the branch
    from the end of the body is added because this was the last missing predecessor.
    To seal a block, we can simply add the missing operands to the incomplete `phi`
    instructions and set the flag:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 包含条件的基块在从主体末尾添加分支后可以封闭，因为这是最后一个缺失的前驱。要封闭一个块，我们可以简单地向不完整的 `phi` 指令添加缺失的操作数并设置标志：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With these methods, we are now ready to generate the IR code for expressions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法，我们现在可以生成表达式的 IR 代码。
- en: Creating the IR code for expressions
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为表达式创建 IR 代码
- en: 'In general, you translate expressions, as shown in [*Chapter 2*](B19561_02.xhtml#_idTextAnchor037),
    *The Structure of a Compiler*. The only interesting part is how to access variables.
    The previous section treated local variables, but there are other kinds of variables
    we can consider. Let’s discuss what we need to do:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你翻译表达式，如[*第 2 章*](B19561_02.xhtml#_idTextAnchor037)《编译器的结构》中所示。唯一有趣的部分是如何访问变量。上一节处理了局部变量，但还有其他类型的变量我们可以考虑。让我们讨论我们需要做什么：
- en: For a local variable of the procedure, we use the `readLocalVariable()` and
    `writeLocalVariable()` methods from the previous section.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于过程中的局部变量，我们使用上一节中的 `readLocalVariable()` 和 `writeLocalVariable()` 方法。
- en: For a local variable in an enclosing procedure, we need a pointer to the frame
    of the enclosing procedure. This will be handled later in this chapter.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于封装过程中的局部变量，我们需要指向封装过程框架的指针。这将在本章的后面处理。
- en: For a global variable, we generate load and store instructions.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于全局变量，我们生成加载和存储指令。
- en: For a formal parameter, we have to differentiate between passing by value and
    passing by reference (the `VAR` parameter in `tinylang`). A parameter that’s passed
    by value is treated as a local variable, and a parameter passed by reference is
    treated as a global variable.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于形式参数，我们必须区分按值传递和按引用传递（`tinylang` 中的 `VAR` 参数）。按值传递的参数被视为局部变量，而按引用传递的参数被视为全局变量。
- en: 'Putting it all together, we get the following code for reading a variable or
    formal parameter:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们得到以下读取变量或形式参数的代码：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Writing to a variable or formal parameter is symmetrical – we just need to exchange
    the method to read with the one to write and use a `store` instruction instead
    of a `load` instruction.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 向变量或形式参数写入是对称的——我们只需要交换读取方法和写入方法，并使用 `store` 指令而不是 `load` 指令。
- en: Next, these functions are applied while generating the IR code for the functions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在为函数生成 IR 代码时应用这些函数。
- en: Emitting the IR code for a function
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成函数的 IR 代码
- en: Most of the IR code will live in a function. A function in IR code resembles
    a function in C. It specifies in the name, the types of parameters, the return
    value, and other attributes. To call a function in a different compilation unit,
    you need to declare the function. This is similar to a prototype in C. If you
    add basic blocks to the function, then you define the function. We will do all
    this in the next few sections, but first, we will discuss the visibility of symbol
    names.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数IR代码将存在于一个函数中。IR代码中的函数类似于C语言中的函数。它在名称中指定了参数类型、返回值和其他属性。要调用不同编译单元中的函数，你需要声明该函数。这类似于C语言中的原型。如果你向函数中添加基本块，那么你就定义了该函数。我们将在接下来的几节中做所有这些，但首先，我们将讨论符号名称的可见性。
- en: Controlling visibility with linkage and name mangling
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用链接和名称混淆控制可见性
- en: Functions (and also global variables) have a linkage style attached. With the
    linkage style, we define the visibility of a symbol name and what should happen
    if more than one symbol has the same name. The most basic linkage styles are `private`
    and `external`. A symbol with `private` linkage is only visible in the current
    compilation unit, while a symbol with `external` linkage is globally available.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数（以及全局变量）附有一个链接样式。通过链接样式，我们定义了符号名称的可见性以及当多个符号具有相同名称时应该发生什么。最基本的链接样式是 `private`
    和 `external`。具有 `private` 链接的符号仅在当前编译单元中可见，而具有 `external` 链接的符号在全局范围内可用。
- en: For a language without a proper module concept, such as C, this is adequate.
    With modules, we need to do more. Let’s assume that we have a module called `Square`
    that provides a `Root()` function and a `Cube` module, which also provides a `Root()`
    function. If the functions are private, then there is no problem. The function
    gets the name `Root` and private linkage. The situation is different if the function
    is exported so that it can be called from other modules. Using the function name
    alone is not enough, because this name is not unique.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有适当模块概念的编程语言，如C，这已经足够了。有了模块，我们需要做更多。假设我们有一个名为 `Square` 的模块，它提供了一个 `Root()`
    函数和一个 `Cube` 模块，它也提供了一个 `Root()` 函数。如果函数是私有的，那么就没有问题。函数获得名称 `Root` 和私有链接。如果函数是导出的，以便可以从其他模块调用它，那么情况就不同了。仅使用函数名称是不够的，因为这个名称不是唯一的。
- en: 'The solution is to tweak the name to make it globally unique. This is called
    name `Square.Root` as the name looks like an obvious solution, but it may lead
    to problems with assemblers as the dot may have a special meaning. Instead of
    using a delimiter between the name components, we can get a similar effect by
    prefixing the name components with their length: `6Square4Root`. This is no legal
    identifier for LLVM, but we can fix this by prefixing the whole name with `_t`
    (with `t` for `tinylang`): `_t6Square4Root`. In this way, we can create unique
    names for exported symbols:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是调整名称以使其全局唯一。这被称为名称 `Square.Root`，因为名称看起来像是一个明显的解决方案，但它可能导致汇编器出现问题，因为点号可能有特殊含义。我们可以在名称组件之间使用分隔符，而不是使用名称组件的长度作为前缀：`6Square4Root`。这不是LLVM的有效标识符，但我们可以通过在名称前加上
    `_t`（代表 `tinylang`）来修复这个问题：`_t6Square4Root`。这样，我们可以为导出符号创建唯一的名称：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If your source language supports type overloading, then you need to extend this
    scheme with type names. For example, to distinguish between the `int root(int)`
    and `double root(double)` C++ functions, the type of the parameter and the return
    value must be added to the function name.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的源语言支持类型重载，那么你需要通过类型名称扩展此方案。例如，为了区分 `int root(int)` 和 `double root(double)`
    C++ 函数，必须将参数类型和返回值类型添加到函数名称中。
- en: You also need to think about the length of the generated name since some linkers
    place restrictions on the length. With nested namespaces and classes in C++, the
    mangled names can be rather long. There, C++ defines a compression scheme to avoid
    repeating name components over and over again.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要考虑生成的名称长度，因为一些链接器对长度有限制。在C++中，嵌套命名空间和类可能导致名称变得相当长。在那里，C++定义了一种压缩方案，以避免重复名称组件。
- en: Next, we’ll look at how to treat parameters.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何处理参数。
- en: Converting a type from an AST description into LLVM types
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将类型从AST描述转换为LLVM类型
- en: 'The parameters of a function also need some consideration. First, we need to
    map the types of the source language to an LLVM type. As `tinylang` currently
    has only two types, this is easy:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数也需要考虑。首先，我们需要将源语言的类型映射到LLVM类型。由于 `tinylang` 目前只有两种类型，这很容易：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Int64Ty`, `Int1Ty`, and `VoidTy` are class members that hold the type representation
    of the `i64`, `i1`, and `void` LLVM types.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int64Ty`、`Int1Ty`和`VoidTy`是类成员，它们持有`i64`、`i1`和`void` LLVM类型的类型表示。'
- en: 'For a formal parameter passed by reference, this is not enough. The LLVM type
    of this parameter is a pointer. However, when we want to use the value of the
    formal parameter, we need to know the underlying type. This is controlled by the
    `HonorReference` flag, which has a default value of `true`. We generalize the
    function and take the formal parameter into account:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于按引用传递的形式参数，这还不够。此参数的LLVM类型是指针。然而，当我们想要使用形式参数的值时，我们需要知道其底层类型。这由`HonorReference`标志控制，其默认值为`true`。我们泛化函数并考虑形式参数：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With these helpers at hand, we can create the LLVM IR function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些辅助工具，我们可以创建LLVM IR函数。
- en: Creating the LLVM IR function
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建LLVM IR函数
- en: 'To emit a function in LLVM IR, a function type is needed, which is similar
    to a prototype in C. Creating the function type involves mapping the types and
    then calling the factory method to create the function type:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要在LLVM IR中发射一个函数，需要一个函数类型，这类似于C中的原型。创建函数类型涉及映射类型，然后调用工厂方法创建函数类型：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Based on the function type, we also create the LLVM function. This associates
    the function type with the linkage and the mangled name:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 基于函数类型，我们也创建LLVM函数。这将函数类型与链接和混淆名称关联：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `getModule()` method returns the current LLVM module, which we’ll set up
    a bit later.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`getModule()`方法返回当前LLVM模块，我们将在稍后设置它。'
- en: 'With the function created, we can add some more information about it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 函数创建后，我们可以添加一些关于它的更多信息：
- en: First, we can give the parameter’s names. This makes the IR more readable.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以给出参数的名称。这使得IR更易于阅读。
- en: Second, we can add attributes to the function and to the parameters to specify
    some characteristics. As an example, we will do this for parameters passed by
    reference.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们可以向函数及其参数添加属性以指定一些特性。作为一个例子，我们将为按引用传递的参数执行此操作。
- en: At the LLVM level, these parameters are pointers. But from the source language
    design, these are very restricted pointers. Analogous to references in C++, we
    always need to specify a variable for a `VAR` parameter. So, by design, we know
    that this pointer will never be null and that it is always dereferenceable, meaning
    that we can read the value that’s being pointed to without risking a general protection
    fault. Also, by design, this pointer cannot be passed around – in particular,
    there are no copies of the pointer that outlive the call to the function. Therefore,
    the pointer is said to not be captured.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM级别，这些参数是指针。但从源语言设计来看，这些是非常受限的指针。类似于C++中的引用，我们始终需要为`VAR`参数指定一个变量。因此，按照设计，我们知道这个指针永远不会为空，并且总是可解引用的，这意味着我们可以读取被指向的值而不会冒着引发一般保护故障的风险。此外，按照设计，这个指针不能被传递——特别是没有超出函数调用的指针副本。因此，这个指针被认为是未被捕获的。
- en: 'The `llvm::AttributeBuilder` class is used to build the set of attributes for
    a formal parameter. To get the storage size of a parameter type, we can simply
    query the data layout object:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm::AttributeBuilder`类用于构建形式参数的属性集。要获取参数类型的存储大小，我们可以简单地查询数据布局对象：'
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With that, we have created the IR function. In the next section, we’ll add the
    basic blocks of the function body to the function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经创建了IR函数。在下一节中，我们将函数主体的基本块添加到函数中。
- en: Emitting the function body
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发射函数体
- en: 'We are almost done with emitting the IR code for a function! We only need to
    put the pieces together to emit a function, including its body:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎完成了函数IR代码的发射！我们只需要将这些部分组合起来以发射一个函数，包括其主体：
- en: 'Given a procedure declaration from `tinylang`, first, we will create the function
    type and the function:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定`tinylang`中的过程声明，首先，我们将创建函数类型和函数：
- en: '[PRE33]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will create the first basic block of the function and make it the
    current one:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建函数的第一个基本块并将其设置为当前块：
- en: '[PRE34]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we must step through all formal parameters. To handle VAR parameters
    correctly, we need to initialize the `FormalParams` member (used in `readVariable()`).
    In contrast to local variables, formal parameters have a value in the first basic
    block, so we must make these values known:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须遍历所有形式参数。为了正确处理VAR参数，我们需要初始化`FormalParams`成员（在`readVariable()`中使用）。与局部变量不同，形式参数在第一个基本块中有一个值，因此我们必须使这些值已知：
- en: '[PRE35]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After this setup, we can call the `emit()` method to start generating the IR
    code for statements:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此设置之后，我们可以调用 `emit()` 方法来开始生成语句的 IR 代码：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The last block after generating the IR code may not be sealed yet, so we must
    call `sealBlock()` now. A procedure in `tinylang` may have an implicit return,
    so we must also check if the last basic block has a proper terminator, and add
    one if not:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成 IR 代码后的最后一个块可能尚未密封，因此我们现在必须调用 `sealBlock()`。`tinylang` 中的过程可能有一个隐式的返回值，因此我们还需要检查最后一个基本块是否有适当的终止符，如果没有，则添加一个：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With that, we’ve finished generating IR code for functions. However, we still
    need to create the LLVM module, which holds all the IR code together. We’ll do
    this in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了函数的 IR 代码生成。然而，我们仍然需要创建一个 LLVM 模块，它将所有 IR 代码组合在一起。我们将在下一节中这样做。
- en: Setting up the module and the driver
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置模块和驱动程序
- en: We collect all the functions and global variables of a compilation unit in an
    LLVM module. To ease the IR generation process, we can wrap all the functions
    from the previous sections into a code generator class. To get a working compiler,
    we also need to define the target architecture for which we want to generate code,
    and also add the passes that emit the code. We will implement this in this and
    the next few chapters, starting with the code generator.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个 LLVM 模块中收集编译单元的所有函数和全局变量。为了简化 IR 生成过程，我们可以将前几节中的所有函数包装到一个代码生成器类中。为了得到一个可工作的编译器，我们还需要定义我们想要为其生成代码的目标架构，并添加生成代码的传递。我们将在本章和接下来的几章中实现这一点，从代码生成器开始。
- en: Wrapping all in the code generator
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容包装在代码生成器中
- en: 'The IR module is the brace around all elements we generate for a compilation
    unit. At the global level, we iterate through the declarations at the module level,
    create global variables, and call the code generation for procedures. A global
    variable in `tinylang` is mapped to an instance of the `llvm::GobalValue` class.
    This mapping is saved in `Globals` and made available to the code generation for
    procedures:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: IR 模块是我们为编译单元生成的所有元素的括号。在全局级别，我们遍历模块级别的声明，创建全局变量，并调用过程的代码生成。`tinylang` 中的全局变量映射到
    `llvm::GlobalValue` 类的实例。这种映射保存在 `Globals` 中，并可供过程的代码生成使用：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The module also holds the `LLVMContext` class and caches the most commonly
    used LLVM types. The latter ones need to be initialized, for example, for the
    64-bit integer type:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块还持有 `LLVMContext` 类，并缓存最常用的 LLVM 类型。后者需要初始化，例如，对于 64 位整数类型：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `CodeGenerator` class initializes the LLVM IR module and calls the code
    generation for the module. Most importantly, this class must know for which target
    architecture we’d like to generate code. This information is passed in the `llvm::TargetMachine`
    class, which is set up in the driver:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`CodeGenerator` 类初始化 LLVM IR 模块并调用模块的代码生成。最重要的是，这个类必须知道我们想要为哪个目标架构生成代码。这个信息通过
    `llvm::TargetMachine` 类传递，该类在驱动程序中设置：'
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For ease of use, we must also introduce a factory method for the code generator:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于使用，我们还必须引入一个代码生成器的工厂方法：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `CodeGenerator` class provides a small interface to create IR code, which
    is ideal for use in the compiler driver. Before we integrate it, we need to implement
    the support for machine code generation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`CodeGenerator` 类提供了一个小的接口来创建 IR 代码，这对于在编译器驱动程序中使用是理想的。在我们将其集成之前，我们需要实现机器代码生成的支持。'
- en: Initializing the target machine class
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化目标机器类
- en: 'Now, only the target machine is missing. With the target machine, we define
    the CPU architecture we’d like to generate code for. For each CPU, there are features
    available that can be used to influence the code generation process. For example,
    a newer CPU of a CPU architecture family can support vector instructions. With
    features, we can toggle the use of vector instructions on or off. To support setting
    all these options from the command line, LLVM provides some supporting code. In
    the `Driver` class, we can add the following `include` variable:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只缺少目标机器。有了目标机器，我们定义了我们想要为其生成代码的 CPU 架构。对于每个 CPU，都有可用于影响代码生成过程的功能。例如，一个 CPU
    架构家族的新 CPU 可以支持向量指令。通过功能，我们可以打开或关闭向量指令的使用。为了支持从命令行设置所有这些选项，LLVM 提供了一些支持代码。在 `Driver`
    类中，我们可以添加以下 `include` 变量：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This `include` variable adds common command-line options to our compiler driver.
    Many LLVM tools also use these command-line options, which have the benefit of
    providing a common interface to the user. Only the option to specify a target
    triple is missing. As this is very useful, we’ll add this ourselves:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`include`变量将常见的命令行选项添加到我们的编译器驱动程序中。许多LLVM工具也使用这些命令行选项，这有利于为用户提供一个统一的接口。唯一缺少的是指定目标三元组的选项。由于这非常有用，我们将自己添加它：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s create the target machine:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建目标机器：
- en: 'To display error messages, the name of the application must be passed to the
    function:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示错误消息，必须将应用程序的名称传递给函数：
- en: '[PRE44]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'First, we must collect all the information provided by the command line. These
    are options for the code generator – that is, the name of the CPU and possible
    features that should be activated or deactivated, and the triple of the target:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须收集命令行提供的所有信息。这些是代码生成器的选项——即CPU的名称以及应该激活或禁用的可能特性，以及目标的三元组：
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we must look up the target in the target registry. If an error occurs,
    then we will display the error message and bail out. A possible error would be
    an unsupported triple specified by the user:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须在目标注册表中查找目标。如果发生错误，我们将显示错误消息并退出。一个可能错误是用户指定的不支持的三元组：
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With the help of the `Target` class, we can configure the target machine using
    all the known options requested by the user:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Target`类的帮助下，我们可以使用用户请求的所有已知选项来配置目标机器：
- en: '[PRE47]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With the target machine instance, we can generate IR code that targets a CPU
    architecture of our choice. What is missing is the translation to assembly text
    or the generation of object code files. We’ll add this support in the next section.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用目标机器实例，我们可以生成针对我们选择的CPU架构的IR代码。缺少的是将其翻译成汇编文本或生成目标代码文件。我们将在下一节中添加此支持。
- en: Emitting assembler text and object code
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出汇编文本和目标代码
- en: In LLVM, the IR code is run through a pipeline of passes. Each pass performs
    a single task, such as removing dead code. We’ll learn more about passes in [*Chapter
    7*](B19561_07.xhtml#_idTextAnchor117), *Optimizing IR*. Outputting assembler code
    or an object file is implemented as a pass too. Let’s add basic support for it!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM中，IR代码通过一系列的遍历运行。每个遍历执行单个任务，例如删除死代码。我们将在[*第7章*](B19561_07.xhtml#_idTextAnchor117)，*优化IR*中了解更多关于遍历的内容。输出汇编代码或目标文件也被实现为一个遍历。让我们添加基本支持它！
- en: 'We need to include even more LLVM header files. First, we need the `llvm::legacy::PassManager`
    class to hold the passes to emit code to a file. We also want to be able to output
    LLVM IR code, so we also need a pass to emit this. Finally, we’ll use the `llvm::
    ToolOutputFile` class for the file operations:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要包含更多的LLVM头文件。首先，我们需要`llvm::legacy::PassManager`类来保存要输出到文件的代码的遍历。我们还想能够输出LLVM
    IR代码，因此我们还需要一个遍历来输出这些代码。最后，我们将使用`llvm:: ToolOutputFile`类来进行文件操作：'
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Another command-line option for outputting LLVM IR is also needed:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要另一个命令行选项来输出LLVM IR：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we want to be able to give the output file a name:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望能够给输出文件命名：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first task in the new `emit()` method is to deal with the name of the output
    file if it’s not given by the user on the command line. If the input is read from
    `stdin`, indicated by the use of the minus symbol, `-`, then we output the result
    to `stdout`. The `ToolOutputFile` class knows how to handle the special filename,
    `-`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`emit()`方法中的第一个任务是处理输出文件名，如果用户没有在命令行中提供。如果输入是从`stdin`读取的，表示使用减号`-`，则我们将结果输出到`stdout`。`ToolOutputFile`类知道如何处理特殊文件名`-`：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Otherwise, we drop a possible extension of the input filename and append `.ll`,
    `.s`, or `.o` as an extension, depending on the command-line options given by
    the user. The `FileType` option is defined in the `llvm/CodeGen/CommandFlags.inc`
    header file, which we included earlier. This option doesn’t support emitting IR
    code, so we’ve added the new`–emit-llvm` option, which only takes effect if it’s
    used together with the assembly file type:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们将丢弃输入文件名的可能扩展名，并根据用户提供的命令行选项添加`.ll`、`.s`或`.o`作为扩展名。`FileType`选项在`llvm/CodeGen/CommandFlags.inc`头文件中定义，我们之前已经包含它。此选项不支持输出IR代码，因此我们添加了新的`–emit-llvm`选项，该选项仅在与其一起使用汇编文件类型时才有效：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Some platforms distinguish between text and binary files, so we have to provide
    the right open flags when opening the output file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一些平台区分文本文件和二进制文件，因此我们必须在打开输出文件时提供正确的打开标志：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we can add the required passes to `PassManager`. The `TargetMachine` class
    has a utility method that adds the requested classes. Therefore, we only need
    to check if the user requests to output the LLVM IR code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向 `PassManager` 添加所需的传递。`TargetMachine` 类有一个实用方法，可以添加请求的类。因此，我们只需要检查用户是否请求输出
    LLVM IR 代码：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With all this preparation done, emitting the file boils down to a single function
    call:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些准备工作后，生成文件简化为单个函数调用：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `ToolOutputFile` class automatically deletes the file if we do not explicitly
    request that we want to keep it. This makes error handling easier as there are
    potentially many places where we need to handle errors and only one place is reached
    if everything goes well. We successfully emitted the code, so we want to keep
    the file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolOutputFile` 类会自动删除文件，除非我们明确请求保留它。这使得错误处理变得更容易，因为可能有很多地方需要处理错误，而如果一切顺利，只有一个地方会被访问。我们成功生成了代码，因此我们希望保留文件：'
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we must report success to the caller:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须向调用者报告成功：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Calling the `emit()` method with `llvm::Module`, which we created with a call
    to the `CodeGenerator` class, emits the code as requested.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `llvm::Module` 调用 `emit()` 方法，这是我们通过调用 `CodeGenerator` 类创建的，按照要求生成代码。
- en: 'Suppose you have the greatest common divisor algorithm in `tinylang` stored
    in the `Gcd.mod` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将 `tinylang` 中的最大公约数算法存储在 `Gcd.mod` 文件中：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To translate this to the `Gcd.o` object file, type the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此转换为 `Gcd.o` 目标文件，请输入以下内容：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you’d like to inspect the generated IR code directly on the screen, type
    the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要直接在屏幕上检查生成的 IR 代码，请输入以下内容：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'With the current state of the implementation, it is not possible to create
    a complete program in `tinylang`. However, you can use a small C program called
    `callgcd.c` to test the generated object file. Note the use of the mangled name
    to call the `GCD` function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前实现的状况，在 `tinylang` 中创建一个完整的程序是不可能的。然而，你可以使用一个名为 `callgcd.c` 的小型 C 程序来测试生成的目标文件。注意使用混淆名称来调用
    `GCD` 函数：
- en: '[PRE61]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To compile and run the whole application with `clang`, type the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `clang` 编译和运行整个应用程序，请输入以下内容：
- en: '[PRE62]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Let’s celebrate! At this point, we have created a complete compiler by reading
    the source language up and emitting assembler code or an object file.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们庆祝！在这个阶段，我们已经通过读取源语言并生成汇编代码或目标文件创建了一个完整的编译器。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to implement a code generator for LLVM IR code.
    Basic blocks are important data structures that hold all the instructions and
    express branches. You learned how to create basic blocks for the control statements
    of the source language and how to add instructions to a basic block. You applied
    a modern algorithm to handle local variables in functions, leading to less IR
    code. The goal of a compiler is to generate assembler text or an object file for
    the input, so you also added a simple compilation pipeline. With this knowledge,
    you will be able to generate LLVM IR code and assembler text or object code for
    your language compiler.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何实现 LLVM IR 代码的代码生成器。基本块是重要的数据结构，它包含所有指令并表达分支。你学习了如何为源语言的控制语句创建基本块以及如何向基本块添加指令。你应用了一种现代算法来处理函数中的局部变量，从而减少了
    IR 代码。编译器的目标是为目标生成汇编文本或目标文件，因此你也添加了一个简单的编译管道。有了这些知识，你将能够为你自己的语言编译器生成 LLVM IR 代码、汇编文本或目标代码。
- en: In the next chapter, you’ll learn how to deal with aggregate data structures
    and how to ensure that function calls comply with the rules of your platform.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何处理聚合数据结构以及如何确保函数调用符合平台规则。
