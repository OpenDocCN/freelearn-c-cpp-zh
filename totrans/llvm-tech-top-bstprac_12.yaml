- en: '*Chapter 9*: Working with PassManager and AnalysisManager'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：使用PassManager和AnalysisManager'
- en: In the previous section of this book, *Frontend Development*, we began with
    an introduction to the internals of Clang, which is LLVM's official frontend for
    the C family of programming languages. We went through various projects, involving
    skills and knowledge, that can help you to deal with problems that are tightly
    coupled with source code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前一节*前端开发*中，我们开始介绍了Clang的内部结构，它是LLVM为C系列编程语言提供的官方前端。我们探讨了各种项目，涉及技能和知识，这些可以帮助你处理与源代码紧密相关的问题。
- en: In this part of the book, we will be working with **LLVM IR** – a target-independent
    **intermediate representation** (**IR**) for compiler optimization and code generation.
    Compared to Clang's **Abstract Syntax Tree** (**AST**), LLVM IR provides a different
    level of abstraction by encapsulating extra execution details to enable more powerful
    program analyses and transformations. In addition to the design of LLVM IR, there
    is a mature ecosystem around this IR format, which provides countless resources,
    such as libraries, tools, and algorithm implementations. We will cover a variety
    of topics in LLVM IR, including the most common LLVM Pass development, using and
    writing program analysis, and the best practices and tips for working with LLVM
    IR APIs. Additionally, we will review more advanced skills such as **Program Guided
    Optimization** (**PGO**) and sanitizer development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们将使用**LLVM IR** – 一种针对编译优化和代码生成的目标无关的**中间表示**（**IR**）。与Clang的**抽象语法树**（**AST**）相比，LLVM
    IR通过封装额外的执行细节提供了不同层次的抽象，从而能够实现更强大的程序分析和转换。除了LLVM IR的设计，围绕这种IR格式还有一个成熟的生态系统，它提供了无数的资源，如库、工具和算法实现。我们将涵盖LLVM
    IR的多个主题，包括最常见的LLVM Pass开发、使用和编写程序分析，以及与LLVM IR API一起工作的最佳实践和技巧。此外，我们还将回顾更高级的技能，如**程序引导优化**（**PGO**）和sanitizer开发。
- en: In this chapter, we are going to talk about writing a transformation **Pass**
    and program analysis for the new **PassManager**. LLVM Pass is one of the most
    fundamental, and crucial, concepts within the entire project. It allows developers
    to encapsulate program processing logic into a modular unit that can be freely
    composed with other Passes by the **PassManager**, depending on the situation.
    In terms of the design of the Pass infrastructure, LLVM has actually gone through
    an overhaul of both PassManager and AnalysisManager to improve their runtime performance
    and optimization quality. The new PassManager uses a quite different interface
    for its enclosing Passes. This new interface, however, is not backward-compatible
    to the legacy one, meaning you cannot run legacy Passes in the new PassManager
    and vice versa. What is worse, there aren't many learning resources online that
    talk about this new interface, even though, now, they are enabled, by default,
    in both LLVM and Clang. The content of this chapter will fill this gap and provide
    you with an up-to-date guide to this crucial subsystem in LLVM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论编写用于新**PassManager**的转换**Pass**和程序分析。LLVM Pass是整个项目中最为基础和关键的概念之一。它允许开发者将程序处理逻辑封装成一个模块化的单元，该单元可以通过**PassManager**根据情况自由组合其他Pass。在Pass基础设施的设计方面，LLVM实际上对PassManager和AnalysisManager都进行了彻底的改造，以提高它们的运行时性能和优化质量。新的PassManager为其封装的Pass使用了相当不同的接口。然而，这个新接口与旧接口不兼容，这意味着你无法在新PassManager中运行旧Pass，反之亦然。更糟糕的是，网上关于这个新接口的学习资源并不多，尽管现在它们在LLVM和Clang中默认启用。本章的内容将填补这一空白，并提供关于LLVM中这一关键子系统的最新指南。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing an LLVM Pass for the new PassManager
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为新的PassManager编写LLVM Pass
- en: Working with the new AnalysisManager
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的AnalysisManager
- en: Learning instrumentations in the new PassManager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的PassManager中学习instrumentations
- en: With the knowledge learned from this chapter, you should be able to write an
    LLVM Pass, using the new Pass infrastructure, to transform or even optimize your
    input code. You can also further improve the quality of your Pass by leveraging
    the analysis data provided by LLVM's program analysis framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章学习到的知识，你应该能够编写一个LLVM Pass，使用新的Pass基础设施，来转换甚至优化你的输入代码。你也可以通过利用LLVM程序分析框架提供的分析数据来进一步提高你Pass的质量。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will, primarily, use a command-line utility, called `opt`,
    to test our Passes. You can build it using a command like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要使用一个名为`opt`的命令行工具来测试我们的Pass。您可以使用以下命令构建它：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code example for this chapter can be found at [https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter09](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter09).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在[https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter09](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter09)找到。
- en: Writing an LLVM Pass for the new PassManager
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为新的PassManager编写LLVM Pass
- en: 'A **Pass in LLVM** is the basic unit that is required to perform certain actions
    against LLVM IR. It is similar to a single production step in a factory, where
    the products that need to be processed are LLVM IR and the factory workers are
    the Passes. In the same way that a normal factory usually has multiple manufacturing
    steps, LLVM also consists of multiple Passes that are executed in sequential order,
    called the **Pass pipeline**. *Figure 9.1* shows an example of the Pass pipeline:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**LLVM中的Pass**是执行针对LLVM IR的某些操作所需的基本单元。它类似于工厂中的一个单一生产步骤，其中需要处理的产品是LLVM IR，而工厂工人是Pass。同样，一个正常的工厂通常有多个制造步骤，LLVM也由多个按顺序执行的Pass组成，称为**Pass流水线**。*图9.1*显示了Pass流水线的一个示例：'
- en: '![Figure 9.1 – An example of the LLVM Pass pipeline and its intermediate results'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – LLVM Pass流水线和其中间结果的示例'
- en: '](img/Figure_9.1_B14590.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.1_B14590.jpg]'
- en: Figure 9.1 – An example of the LLVM Pass pipeline and its intermediate results
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – LLVM Pass流水线和其中间结果的示例
- en: In the preceding diagram, multiple Passes are arranged in a straight line. The
    LLVM IR for the `foo` function is processed by one Pass after another. `foo` and
    replaces an arithmetic multiplication (`mul`) by 2 with left shifting (`shl`)
    by 1, which is considered easier than multiplication in most hardware architectures.
    In addition, this figure also illustrates that the **code generation** steps are
    modeled as Passes. Code generation in LLVM transforms LLVM IR, which is target
    independent, into assembly code for certain hardware architecture (for example,
    **x86_64** in *Figure 9.1*). Each detailed procedure, such as the register allocation,
    instruction selection, or instruction scheduling, is encapsulated into a single
    Pass and is executed in a certain order.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，多个Pass按直线排列。`foo`函数的LLVM IR被一个Pass接着另一个Pass处理。`foo`和将一个乘以2的算术乘法(`mul`)替换为左移(`shl`)1，这在大多数硬件架构中被认为比乘法更容易。此外，此图还说明了**代码生成**步骤被建模为Pass。在LLVM中，代码生成将目标无关的LLVM
    IR转换为特定硬件架构的汇编代码（例如，*图9.1*中的**x86_64**）。每个详细过程，如寄存器分配、指令选择或指令调度，都被封装到一个单独的Pass中，并按一定顺序执行。
- en: Code generation Passes
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成Pass
- en: Passes for code generation have a different API than normal LLVM IR Passes.
    Additionally, during the code generation phase, LLVM IR is actually converted
    into another kind of IR, called **Machine IR** (**MIR**). However, in this chapter,
    we will only be covering LLVM IR and its Passes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成Pass具有与正常LLVM IR Pass不同的API。此外，在代码生成阶段，LLVM IR实际上被转换为另一种类型的IR，称为**机器IR**（**MIR**）。然而，在本章中，我们只将涵盖LLVM
    IR及其Pass。
- en: This Pass pipeline is conceptually managed by an infrastructure called **PassManager**.
    PassManager owns the plan – their execution order, for example – to run these
    Passes. Conventionally, we actually use the terms *Pass pipeline* and *PassManager*
    interchangeably since they have nearly identical missions. In the *Learning instrumentations
    in the new PassManager* section, we will go into more detail about the pipeline
    itself and discuss how to customize the execution order of these enclosing Passes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Pass流水线在概念上由一个名为**PassManager**的基础设施管理。PassManager拥有计划 – 例如，它们的执行顺序 – 来运行这些Pass。传统上，我们实际上使用*Pass流水线*和*PassManager*这两个术语互换，因为它们几乎有相同的任务。在*新PassManager中的学习工具*部分，我们将更详细地介绍流水线本身，并讨论如何自定义这些封装Pass的执行顺序。
- en: Code transformations in modern compilers can be complex. Because of this, multiple
    transformation Passes might need the same set of program information, which is
    called **analysis** in LLVM, in order to do their work. Furthermore, to achieve
    maximum efficiency, LLVM also *caches* this analysis data so that it can be reused
    if possible. However, since a transformation Pass might change the IR, some cached
    analysis data, which was previously collected, might be outdated after running
    that Pass. To solve these challenges, in addition to PassManager, LLVM has also
    created **AnalysisManager** to manage everything related to program analysis.
    We will go deeper into AnalysisManager in the *Working with the new AnalysisManager*
    section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编译器中的代码转换可能很复杂。正因为如此，多个转换Pass可能需要相同的一组程序信息，这在LLVM中被称为**分析**，以便完成它们的工作。此外，为了达到最大效率，LLVM还会**缓存**这些分析数据，以便在可能的情况下重用。然而，由于转换Pass可能会更改IR，一些之前收集的缓存分析数据在运行该Pass后可能会过时。为了解决这些挑战，除了PassManager之外，LLVM还创建了**AnalysisManager**来管理与程序分析相关的所有内容。我们将在*使用新的AnalysisManager*部分中深入了解AnalysisManager。
- en: As mentioned in the introduction of this chapter, LLVM has gone through a series
    of overhauls on its Pass and PassManager (and AnalysisManager) infrastructure.
    The new infrastructure runs faster and generates results with better quality.
    Nevertheless, the new Pass differs in many places from the old one; we will briefly
    explain these differences along the way. However, aside from that, we will only
    be discussing the new Pass infrastructure, by default, for the rest of the chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言中所述，LLVM对其Pass和PassManager（以及AnalysisManager）基础设施进行了一系列的重大改造。新的基础设施运行速度更快，生成的结果质量更好。尽管如此，新的Pass与旧的一个有很多不同之处；我们将在途中简要解释这些差异。然而，除了这一点之外，我们将在本章的其余部分默认只讨论新的Pass基础设施。
- en: In this section, we will show you how to develop a simple Pass for the new PassManager.
    As usual, we will begin with a description of the sample project we are about
    to use. Then, we will show you the steps to create a Pass that can be dynamically
    loaded from a plugin into the Pass pipeline, which was mentioned earlier, using
    the `opt` utility.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何为新的PassManager开发一个简单的Pass。像往常一样，我们将从描述我们即将使用的示例项目开始。然后，我们将向您展示使用`opt`实用程序创建一个Pass的步骤，该Pass可以从插件动态加载到之前提到的Pass管道中。
- en: Project overview
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this section, the sample project we are using is called `noalias` attribute
    to every function parameter that has a pointer type. Effectively, it adds a `restrict`
    keyword to the function parameters in C code. First, let's explain what the `restrict`
    keyword does.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用的示例项目被称为`noalias`属性，将其应用于所有具有指针类型的函数参数。实际上，它向C代码中的函数参数添加了`restrict`关键字。首先，让我们解释一下`restrict`关键字的作用。
- en: The restrict keyword in C and C++
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++中的`restrict`关键字
- en: The `restrict` keyword was introduced in C99\. However, it doesn't have a counterpart
    in C++. Nevertheless, mainstream compilers such as Clang, GCC, and MSVS all support
    the same functionality in C++. For example, in Clang and GCC, you can use `__restrict__`
    or `__restrict` in C++ code and it has the same effect as `restrict` in C.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`restrict`关键字是在C99中引入的。然而，它在C++中没有对应的关键字。不过，主流编译器如Clang、GCC和MSVS都在C++中支持相同的功能。例如，在Clang和GCC中，您可以在C++代码中使用`__restrict__`或`__restrict`，它具有与C中`restrict`相同的效果。'
- en: 'The `restrict` keyword can also be used alongside pointer type variables in
    C. In the most common cases, it is used with pointer type function parameters.
    The following is an example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`restrict`关键字也可以与C中的指针类型变量一起使用。在最常见的案例中，它与指针类型函数参数一起使用。以下是一个示例：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Essentially, this additional attribute tells the compiler that argument `x`
    will never point to the *same memory region* as argument `y`. In other words,
    programmers can use this keyword to *persuade* the compilers that they will *never*
    call the `foo` function, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个额外的属性告诉编译器，参数 `x` 永远不会指向与参数 `y` 相同的内存区域。换句话说，程序员可以使用这个关键字来*说服*编译器他们永远不会调用
    `foo` 函数，如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The rationale behind this is that if the compiler knows that two pointers –
    in this case, the two pointer arguments – will never point to the same memory
    region, it can do more *aggressive* optimizations. To give you a more concrete
    understanding of this, if you compare the assembly code of the `foo` function
    with and without the `restrict` keyword, the latter version takes five instructions
    to execute (on x86_64):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的原因是，如果编译器知道两个指针——在这种情况下，两个指针参数——永远不会指向相同的内存区域，它可以进行更**激进**的优化。为了给您一个更具体的理解，如果您比较带有和没有
    `restrict` 关键字的 `foo` 函数的汇编代码，后者版本在 x86_64 上执行需要五条指令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The version with the `restrict` keyword added only takes four instructions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了 `restrict` 关键字的版本仅需要四条指令：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although the difference here seems subtle, in the version without `restrict`,
    the compiler needs to insert an extra memory load to assure that the last argument
    `*y` (in the original C code) always reads the latest value. This extra cost might
    gradually accumulate in a more complex code base and, eventually, create a performance
    bottleneck.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里的差异看起来很微妙，但在没有 `restrict` 的版本中，编译器需要插入一个额外的内存加载操作来确保最后一个参数 `*y`（在原始 C 代码中）总是读取最新的值。这种额外的开销可能会在更复杂的代码库中逐渐累积，并最终成为性能瓶颈。
- en: 'Now, you have learned how `restrict` works and its importance for ensuring
    good performance. In LLVM IR, there is also a corresponding directive to model
    the `restrict` keyword: the `noalias` attribute. This attribute is attached to
    the pointer function parameters if hints such as `restrict` have been given by
    programmers in the original source code. For example, the `foo` function (with
    the `restrict` keywords) can be translated into the following LLVM IR:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了 `restrict` 的工作原理及其在确保良好性能方面的重要性。在 LLVM IR 中，也有一个相应的指令来模拟 `restrict`
    关键字：`noalias` 属性。如果程序员在原始源代码中给出了如 `restrict` 之类的提示，则此属性附加到指针函数参数上。例如，带有 `restrict`
    关键字的 `foo` 函数可以转换为以下 LLVM IR：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Furthermore, we can also generate the LLVM IR code of the `foo` function *without*
    `restrict` in C code, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以在 C 代码中生成 `foo` 函数的 LLVM IR 代码，而不使用 `restrict`，如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you will find that there is an extra memory load (as shown in the highlighted
    instruction of the preceding snippet), which is similar to what happened to the
    assembly examples from earlier. That is, LLVM is unable to perform more aggressive
    optimization to remove that memory load since it's not sure whether those pointers
    overlap each other.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您会发现有一个额外的内存加载（如前一个片段中突出显示的指令所示），这与之前汇编示例中发生的情况类似。也就是说，LLVM 无法执行更激进的优化来删除该内存加载，因为它不确定这些指针是否重叠。
- en: 'In this section, we are going to write a Pass to add a `noalias` attribute
    to every pointer argument of a function. The Pass will be built as a plugin, and
    once it''s loaded into `opt`, users can use the `--passes` argument to explicitly
    trigger `StrictOpt`, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个 Pass，将 `noalias` 属性添加到函数的每个指针参数。该 Pass 将作为插件构建，一旦加载到 `opt` 中，用户可以使用
    `--passes` 参数显式触发 `StrictOpt`，如下所示：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, we can make `StrictOpt` run before other optimizations if the
    optimization level is greater or equal to `-O3`. The following is an example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果优化级别大于或等于 `-O3`，我们可以在其他优化之前运行 `StrictOpt`。以下是一个示例：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will show you how to switch between these two modes shortly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快向您展示如何在这两种模式之间切换。
- en: A demo-only Pass
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用于演示的 Pass
- en: Note that `StrictOpt` is merely a demo-only Pass, and adding `noalias` to every
    pointer function argument is absolutely *not* the thing you should do in real-world
    use cases. This is because it might break the **correctness** of the target program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`StrictOpt` 仅仅是一个仅用于演示的 Pass，并且将 `noalias` 添加到每个指针函数参数绝对不是您在现实世界用例中应该做的事情。这是因为这可能会破坏目标程序的**正确性**。
- en: In the next section, we will show you detailed steps of how to create this Pass.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向您展示创建此 Pass 的详细步骤。
- en: Writing the StrictOpt Pass
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 StrictOpt Pass
- en: 'The following instructions will take you through the process of developing
    the core Pass logic before covering how to register `StrictOpt` into the Pass
    pipeline dynamically:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明将引导您完成开发核心 Pass 逻辑的过程，然后再介绍如何动态地将 `StrictOpt` 注册到 Pass 管道中：
- en: 'We only have two source files this time: `StrictOpt.h` and `StrictOpt.cpp`.
    In the former file, we place the skeleton of the `StrictOpt` Pass:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们只有两个源文件：`StrictOpt.h` 和 `StrictOpt.cpp`。在前者文件中，我们放置了 `StrictOpt` Pass 的框架：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To implement the skeleton from the previous step, we are heading to `StrictOpt.cpp`.
    In this file, first, we create the following method definition:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现上一步骤中的框架，我们正在前往 `StrictOpt.cpp` 文件。在这个文件中，首先，我们创建以下方法定义：
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The returned `PreservedAnalyses::all()` instance is just a placeholder that
    will be removed later.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回的 `PreservedAnalyses::all()` 实例只是一个占位符，稍后将被移除。
- en: 'Now, we are finally creating the code to add a `noalias` attribute to the pointer
    function arguments. The logic is simple: for each `Argument` instance in a `Function`
    class, attach `noalias` if it fulfills the criteria:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们最终正在创建代码来向指针函数参数添加 `noalias` 属性。逻辑很简单：对于 `Function` 类中的每个 `Argument` 实例，如果它满足条件，则附加
    `noalias`：
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Certain analysis data might become outdated after a transformation Pass since
    the latter might change the program''s IR. Therefore, when writing a Pass, we
    need to return a `PreservedAnalyses` instance to show which analysis was affected
    and should be subject to recalculation. While there are many analyses available
    in LLVM, we don''t need to enumerate each of them. Instead, there are some handy
    utility functions to create `PreservedAnalyses` instances, representing *all analyses*
    or *none of the analyses*, such that we only need to subtract or add (un) affected
    analysis from it. Here is what we do in `StrictOpt`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于转换 Pass 可能会改变程序的 IR，某些分析数据在转换后可能会过时。因此，在编写 Pass 时，我们需要返回一个 `PreservedAnalyses`
    实例来显示哪些分析受到了影响，并且应该进行重新计算。虽然 LLVM 中有大量的分析可用，我们不需要逐一列举它们。相反，有一些方便的实用函数可以创建代表 *所有分析*
    或 *没有分析* 的 `PreservedAnalyses` 实例，这样我们只需要从其中减去或添加（未）受影响的分析即可。以下是我们在 `StrictOpt`
    中所做的工作：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The core logic of `StrictOpt` is essentially finished. Now, we are going to
    show you how to dynamically register the Pass into the pipeline. In `StrictOpt.cpp`,
    we create a special global function, called `llvmGetPassPluginInfo`, with an outline
    like this:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StrictOpt` 的核心逻辑基本上已经完成。现在，我们将向您展示如何动态地将 Pass 注册到管道中。在 `StrictOpt.cpp` 中，我们创建了一个特殊的全局函数，称为
    `llvmGetPassPluginInfo`，其轮廓如下：'
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '$ opt registerPipelineParsingCallback method in PassBuilder:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ opt registerPipelineParsingCallback 方法在 PassBuilder 中：
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, we also want to trigger our `StrictOpt` at the beginning of
    the Pass pipeline without using the textual pipeline description, as we described
    in the *Project overview* section. This means that the Pass will be run before
    other Passes after it is loaded into `opt` using the following command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们还想在 Pass 管道开始时触发我们的 `StrictOpt`，而不使用文本管道描述，正如我们在 *项目概述* 部分中描述的那样。这意味着在将
    Pass 加载到 `opt` 中使用以下命令后，Pass 将在其他的 Pass 之前运行：
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: …
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: '[](PassBuilder &PB) {'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[](PassBuilder &PB) {'
- en: using OptimizationLevel
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using OptimizationLevel
- en: = typename PassBuilder::OptimizationLevel;
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: = typename PassBuilder::OptimizationLevel;
- en: PB.registerPipelineStartEPCallback(
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PB.registerPipelineStartEPCallback(
- en: '[](ModulePassManager &MPM, OptimizationLevel OL) {'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[](ModulePassManager &MPM, OptimizationLevel OL) {'
- en: if (OL.getSpeedupLevel() >= 2) {
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (OL.getSpeedupLevel() >= 2) {
- en: MPM.addPass(
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MPM.addPass(
- en: createModuleToFunctionPassAdaptor(StrictOpt()));
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: createModuleToFunctionPassAdaptor(StrictOpt()));
- en: '}'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are several things worth noting in the preceding snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中有几个值得注意的点：
- en: The `registerPipelineStartEPCallback` method we are using here registers a callback
    that can customize certain places in the Pass pipeline, called **extension points**
    (**EPs**). The EP we are going to customize here is one of the earliest points
    in the pipeline.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这里使用的 `registerPipelineStartEPCallback` 方法注册了一个回调，该回调可以自定义 Pass 管道中的某些位置，称为
    **扩展点**（**EPs**）。我们在这里将要定制的 EP 是管道中最早的位置之一。
- en: In comparison to the lambda callback we saw in `registerPipelineParsingCallback`,
    the lambda callback for `registerPipelineStartEPCallback` only provides `ModulePassManager`,
    rather than `FunctionPassManager`, to insert our `StrictOpt` Pass, which is a
    function Pass. We are using `ModuleToFunctionPassAdapter` to overcome this issue.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与我们在 `registerPipelineParsingCallback` 中看到的 lambda 回调相比，`registerPipelineStartEPCallback`
    的 lambda 回调只提供 `ModulePassManager`，而不是 `FunctionPassManager`，以插入我们的 `StrictOpt`
    Pass，这是一个函数 Pass。我们使用 `ModuleToFunctionPassAdapter` 来解决这个问题。
- en: '`ModuleToFunctionPassAdapter` is a module Pass that can run a given function
    Pass over a module''s enclosing functions. It is suitable for running a function
    Pass in contexts where only `ModulePassManager` is available, such as in this
    scenario. The `createModuleToFunctionPassAdaptor` function highlighted in the
    preceding code is used to create a new `ModuleToFunctionPassAdapter` instance
    from a specific function Pass.'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ModuleToFunctionPassAdapter` 是一个模块 Pass，可以在模块的封装函数上运行给定的函数 Pass。它适用于仅在 `ModulePassManager`
    可用的上下文中运行函数 Pass，例如在这个场景中。前面代码中突出显示的 `createModuleToFunctionPassAdaptor` 函数用于从一个特定的函数
    Pass 创建一个新的 `ModuleToFunctionPassAdapter` 实例。'
- en: Finally, in this version, we are only enabling `StrictOpt` when the optimization
    level is greater or equal to `-O2`. Therefore, we leverage the `OptimizationLevel`
    argument passing into the lambda callback to determine whether we want to insert
    `StrictOpt` into the pipeline or not.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在这个版本中，我们只有在优化级别大于或等于 `-O2` 时才启用 `StrictOpt`。因此，我们利用传递给 lambda 回调的 `OptimizationLevel`
    参数来决定是否将 `StrictOpt` 插入到管道中。
- en: With these Pass registration steps, we have also learned how to trigger our
    `StrictOpt` without explicitly specifying the textual Pass pipeline.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这些 Pass 注册步骤，我们还学习了如何触发我们的 `StrictOpt`，而无需显式指定文本 Pass 管道。
- en: 'To summarize, in this section, we learned the essentials of the LLVM Pass and
    Pass pipeline. Through the `StrictOpt` project, we have learned how to develop
    a Pass – which is also encapsulated as a plugin – for the new PassManager and
    how to dynamically register it against the Pass pipeline in `opt` in two different
    ways: first, by triggering the Pass explicitly via a textual description, and
    second, by running it at a certain time point (EP) in the pipeline. We also learned
    how to invalidate analyses depending on the changes made in the Pass. These skills
    can help you develop high-quality and modern LLVM Passes to process IR in a composable
    fashion with maximum flexibility. In the next section, we will dive into the program
    analysis infrastructure of LLVM. This greatly improves the capability of normal
    LLVM transformation Passes.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们学习了 LLVM Pass 和 Pass 管道的要点。通过 `StrictOpt` 项目，我们学习了如何开发一个 Pass——它也被封装为插件——用于新的
    PassManager，以及如何以两种不同的方式在 `opt` 中动态注册它：首先，通过通过文本描述显式触发 Pass，其次，在管道中的某个时间点（EP）运行它。我们还学习了如何根据
    Pass 中所做的更改使分析无效。这些技能可以帮助您开发高质量和现代的 LLVM Pass，以最大灵活性以可组合的方式处理 IR。在下一节中，我们将深入了解
    LLVM 的程序分析基础设施。这大大提高了普通 LLVM 转换 Pass 的能力。
- en: Working with the new AnalysisManager
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的 AnalysisManager
- en: Modern compiler optimizations can be complex. They usually require lots of information
    from the target program in order to make correct decisions and optimal transformations.
    For example, in the *Writing an LLVM Pass for the new PassManager* section, LLVM
    used the `noalias` attribute to calculate memory aliasing information, which might
    eventually be used to remove redundant memory loads.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编译器的优化可能很复杂。它们通常需要从目标程序中获取大量信息，以便做出正确的决策和最优的转换。例如，在 *编写用于新 PassManager 的 LLVM
    Pass* 部分中，LLVM 使用了 `noalias` 属性来计算内存别名信息，这些信息最终可能被用来删除冗余的内存加载。
- en: Some of this information – called **analysis**, in LLVM – is expensive to evaluate.
    In addition, a single analysis might also depend on other analyses. Therefore,
    LLVM creates an **AnalysisManager** component to handle all tasks related to program
    analysis in LLVM. In this section, we are going to show you how to use AnalysisManager
    in your own Passes for the sake of writing more powerful and sophisticated program
    transformations or analyses. We will also use a sample project, **HaltAnalyzer**,
    to drive our tutorial here. The next section will provide you with an overview
    of HaltAnalyzer before moving on to the detailed development steps.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些信息——在 LLVM 中称为 **analysis**——评估成本很高。此外，单个分析也可能依赖于其他分析。因此，LLVM 创建了一个 **AnalysisManager**
    组件来处理与 LLVM 程序分析相关的所有任务。在本节中，我们将向您展示如何在自己的 Pass 中使用 AnalysisManager，以便编写更强大和复杂的程序转换或分析。我们还将使用一个示例项目，**HaltAnalyzer**，来驱动本教程。下一节将在详细介绍开发步骤之前，为您提供
    HaltAnalyzer 的概述。
- en: Overview of the project
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目概述
- en: HaltAnalyzer is set up in a scenario where target programs are using a special
    function, `my_halt`, that terminates the program execution when it is called.
    The `my_halt` function is similar to the `std::terminate` function, or the `assert`
    function when its sanity check fails.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: HaltAnalyzer是在一个场景中设置的，其中目标程序使用一个特殊函数`my_halt`，当它被调用时终止程序执行。`my_halt`函数类似于`std::terminate`函数，或者当其健全性检查失败时的`assert`函数。
- en: 'The job of HaltAnalyzer is to analyze the program to find basic blocks that
    are *guaranteed to be unreachable* because of the `my_halt` function. To be more
    specific, let''s take the following C code as an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: HaltAnalyzer的任务是分析程序，以找到由于`my_halt`函数而*保证无法到达*的基本块。更具体地说，让我们以下面的C代码为例：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because `my_halt` was called at the beginning of the true block for the `if
    (x < 43)` statement, the code highlighted in the preceding snippet will never
    be executed (that is, `my_halt` stopped all of the program executions before even
    getting to those lines).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`my_halt`在`if (x < 43)`语句的真块开始时被调用，所以前面代码片段中高亮显示的代码永远不会被执行（即`my_halt`在到达这些行之前就停止了所有程序执行）。
- en: 'HaltAnalyzer should identify these basic blocks and print out warning messages
    to `stderr`. Just like the sample project from the previous section, HaltAnalyzer
    is also a function Pass wrapped inside a plugin. Therefore, if we use the preceding
    snippet as the input to our HaltAnalyzer Pass, it should print out the following
    messages:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: HaltAnalyzer应该识别这些基本块，并向`stderr`打印出警告信息。就像上一节中的示例项目一样，HaltAnalyzer也是一个封装在插件中的函数Pass。因此，如果我们使用前面的代码片段作为HaltAnalyzer
    Pass的输入，它应该打印出以下信息：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `%if.else` and `%if.then2` strings are just names for the basic blocks in
    the `if (y > 45)` statement (you might see different names on your side). Another
    thing worth noting is the `--disable-output` command-line flag. By default, the
    `opt` utility will print out the binary form of LLVM IR (that is, the LLVM bitcode)
    anyway unless users redirect the output to other places via the `-o` flag. Using
    the aforementioned flag is merely to tell `opt` not to do that since we are not
    interested in the final content of LLVM IR (because we are not going to modify
    it) this time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`%if.else`和`%if.then2`字符串只是`if (y > 45)`语句中基本块的名称（你可能会看到不同的名称）。另一个值得注意的事情是`--disable-output`命令行标志。默认情况下，`opt`实用程序会打印出LLVM
    IR的二进制形式（即LLVM位码），除非用户通过`-o`标志将输出重定向到其他地方。使用上述标志只是为了告诉`opt`不要这样做，因为我们这次对LLVM IR的最终内容不感兴趣（因为我们不会对其进行修改）。'
- en: 'Although the algorithm of HaltAnalyzer seems pretty simple, writing it from
    scratch might be a pain. That''s why we are leveraging one of the analyses provided
    by LLVM: the **Dominator Tree (DT)**. The concept of **Control Flow Graph** (**CFG**)
    domination has been taught in most entry-level compiler classes, so we are not
    going to explain it in depth here. Simply speaking, if we say a basic block *dominates*
    another block, every execution flow that arrives at the latter is guaranteed to
    go through the former first. A DT is one of the most important and commonly used
    analyses in LLVM; most control flow-related transformations cannot live without
    it.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HaltAnalyzer的算法看起来相当简单，但从零开始编写它可能是个头疼的问题。这就是为什么我们正在利用LLVM提供的一项分析：**支配树（DT）**。**控制流图（CFG）支配**的概念在大多数入门级编译器课程中都有讲解，所以我们在这里就不深入解释了。简单来说，如果我们说一个基本块*支配*另一个块，那么到达后者的每个执行流程都保证首先经过前者。DT是LLVM中最重要且最常用的分析之一；大多数与控制流相关的转换都离不开它。
- en: Putting this idea into HaltAnalyzer, we are simply looking for all of the basic
    blocks that are dominated by the basic blocks that contain a function call to
    `my_halt` (we are excluding the basic blocks that contain the `my_halt` call sites
    from the warning messages). In the next section, we will show you detailed instructions
    on how to write HaltAnalyzer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个想法应用到HaltAnalyzer中，我们只是在寻找所有被包含`my_halt`函数调用的基本块支配的基本块（我们在警告信息中排除了包含`my_halt`调用站点的基本块）。在下一节中，我们将向您展示如何编写HaltAnalyzer的详细说明。
- en: Writing the HaltAnalyzer Pass
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 HaltAnalyzer Pass
- en: 'In this project, we will only create a single source file, `HaltAnalyzer.cpp`.
    Most of the infrastructure, including `CMakeListst.txt`, can be reused from the
    `StrictOpt` project in the previous section:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们只创建一个源文件，`HaltAnalyzer.cpp`。大部分基础设施，包括`CMakeListst.txt`，都可以从上一节中的`StrictOpt`项目重用：
- en: 'Inside `HaltAnalyzer.cpp`, first, we create the following Pass skeleton:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HaltAnalyzer.cpp`内部，首先，我们创建以下Pass框架：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s implement `findHaltCalls` first:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先实现`findHaltCalls`：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s go back to the `HaltAnalyzer::run` method. There are two things
    we are going to do. We will collect the call sites to `my_halt` via `findHaltCalls`,
    which we just wrote, and then retrieve the DT analysis data:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到`HaltAnalyzer::run`方法。我们将做两件事。我们将通过`findHaltCalls`收集对`my_halt`的调用位置，这是我们刚刚编写的，然后检索DT分析数据：
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: // `FAM` is a FunctionAnalysisManager
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // `FAM`是FunctionAnalysisManager
- en: typename T::Result &Data = FAM.getResult<T>(F);
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: typename T::Result &Data = FAM.getResult<T>(F);
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After we retrieve `DominatorTree`, it''s time to find all of the basic blocks
    dominated by the `Instruction` call sites that we collected earlier:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们检索到`DominatorTree`之后，是时候找到我们之前收集的所有由`Instruction`调用位置支配的基本块了：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we need to dynamically insert our HaltAnalyzer Pass into the Pass
    pipeline. We are using the same method that we did in the last section, by implementing
    the `llvmGetPassPluginInfo` function and using `PassBuilder` to put our Pass at
    one of the EPs in the pipeline:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的HaltAnalyzer Pass动态地插入到Pass pipeline中。我们使用与上一节相同的方法，通过实现`llvmGetPassPluginInfo`函数并使用`PassBuilder`将我们的Pass放置在pipeline中的某个EP（扩展点）：
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These are all the necessary steps to implement our HaltAnalyzer. Now you have
    learned how to use LLVM's program analysis infrastructure to obtain more information
    about the target program in an LLVM Pass. These skills can provide you with more
    insight into IR when you are developing a Pass. In addition, this infrastructure
    allows you to reuse high-quality, off-the-shelf program analysis algorithms from
    LLVM instead of recreating the wheels by yourself. To browse all of the available
    analyses provided by LLVM, the `llvm/include/llvm/Analysis` folder in the source
    tree is a good starting point. Most of the header files within this folder are
    standalone analysis data files that you can use.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是实现我们的HaltAnalyzer所必需的步骤。现在你已经学会了如何使用LLVM的程序分析基础设施在LLVM Pass中获取有关目标程序更多信息。这些技能可以让你在开发Pass时对IR有更深入的了解。此外，这个基础设施允许你重用LLVM提供的优质、现成的程序分析算法，而不是自己重新造轮子。要浏览LLVM提供的所有分析，源树中的`llvm/include/llvm/Analysis`文件夹是一个很好的起点。这个文件夹中的大多数头文件都是独立的分析数据文件，你可以使用它们。
- en: In the final section of this chapter, we will show you some diagnosis techniques
    that are useful for debugging an LLVM Pass.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将向您展示一些有用的诊断技术，这些技术对于调试LLVM Pass非常有用。
- en: Learning instrumentations in the new PassManager
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在新的PassManager中学习instrumentations
- en: PassManager and AnalysisManager in LLVM are complicated pieces of software.
    They manage interactions between hundreds of Passes and analyses, and it can be
    a challenge when we try to diagnose a problem caused by them. In addition, it's
    really common for a compiler engineer to fix crashes in the compiler or **miscompilation**
    bugs. In those scenarios, useful instrumentation tools that provide insights to
    Passes and the Pass pipeline can greatly improve the productivity of fixing those
    problems. Fortunately, LLVM has already provided many of those tools.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM中的PassManager和AnalysisManager是复杂的软件组件。它们管理着数百个Pass和分析之间的交互，当我们试图诊断由它们引起的问题时，这可能是一个挑战。此外，编译器工程师修复编译器中的崩溃或**Miscompilation**
    bugs是非常常见的。在这些情况下，有用的instrumentation工具可以为Pass和Pass pipeline提供洞察力，从而大大提高修复这些问题的效率。幸运的是，LLVM已经提供了许多这样的工具。
- en: Miscompilation
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Miscompilation
- en: '**Miscompilation** bugs usually refer to logical issues in the **compiled program**,
    which were introduced by compilers. For example, an overly aggressive compiler
    optimization removes certain loops that shouldn''t be removed, causing the compiled
    software to malfunction, or mistakenly reorder memory barriers and create *race
    conditions* in the generated code.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**Miscompilation** bugs usually refer to logical issues in the **compiled program**,
    which were introduced by compilers. For example, an overly aggressive compiler
    optimization removes certain loops that shouldn''t be removed, causing the compiled
    software to malfunction, or mistakenly reorder memory barriers and create *race
    conditions* in the generated code.'
- en: 'We will introduce a single tool at a time in each of the following sections.
    Here is the list of them:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的每个部分中一次介绍一个工具。以下是它们的列表：
- en: Printing Pass pipeline details
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印Pass pipeline详细信息
- en: Printing changes to the IR after each Pass
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个Pass之后打印IR的变化
- en: Bisecting the Pass pipeline
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割Pass pipeline
- en: These tools can interact purely in the command-line interface of `opt`. In fact,
    you can also create *your own* instrumentation tools (without even changing the
    LLVM source tree!); we will leave this as an exercise for you.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具可以在 `opt` 的命令行界面中交互。实际上，你还可以创建 *自己的* 仪器工具（甚至不需要更改 LLVM 源树！）；我们将把这个留给你作为练习。
- en: Printing Pass pipeline details
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印 Pass 管道详细信息
- en: There are many different `-O1`, `-O2`, or `-Oz` flags we are familiar with when
    using `clang` (or `opt`). Each optimization level is running a *different set
    of Passes* and arranging them in *different orders*. In some cases, this might
    greatly affect the generated code, in terms of performance or correctness. Therefore,
    sometimes, it's crucial to know these configurations in order to gain a clear
    understanding of the problems we are going to deal with.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `clang`（或 `opt`）时，我们熟悉许多不同的 `-O1`、`-O2` 或 `-Oz` 标志。每个优化级别都在运行 *不同集合的 Pass*
    并以 *不同顺序* 安排它们。在某些情况下，这可能会极大地影响生成的代码，从性能或正确性方面来看。因此，有时了解这些配置对于获得我们将要处理的问题的清晰理解至关重要。
- en: 'To print out all the Passes and the order they are currently running in inside
    `opt`, we can use the `--debug-pass-manager` flag. For instance, given the following
    C code, `test.c`, we will see the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印出 `opt` 中所有 Pass 及其当前运行顺序，我们可以使用 `--debug-pass-manager` 标志。例如，给定以下 C 代码，`test.c`，我们将看到以下内容：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We first generate the IR for it using the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用以下命令为其生成 IR：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The -disable-O0-optnone flag
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`-disable-O0-optnone` 标志'
- en: By default, `clang` will attach a special attribute, `optnone`, to each function
    under the `-O0` optimization level. This attribute will prevent any further optimization
    on the attached functions. Here, the `-disable-O0-optnone` (frontend) flag is
    preventing `clang` from attaching to this attribute.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`clang` 将在 `-O0` 优化级别下将特殊属性 `optnone` 附接到每个函数上。此属性将防止对附加函数进行任何进一步优化。在这里，`-disable-O0-optnone`（前端）标志阻止
    `clang` 附上此属性。
- en: 'Then, we use the following command to print out all of the Passes running under
    the optimization level of `-O2`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令来打印出在 `-O2` 优化级别下运行的所有 Pass：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding command-line output tells us that `opt` first runs a set of *module-level*
    optimizations; the ordering of those Passes (for example, `Annotation2MetadataPass`
    and `ForceFunctionAttrsPass`) are also listed. After that, a sequence of *function-level*
    optimizations is performed on the `bar` function (for example, `SROA`) before
    running those optimizations on the `foo` function. Furthermore, it also shows
    the analyses used in the pipeline (for example, `DominatorTreeAnalysis`), as well
    as prompting us with a message regarding they became invalidated (by a certain
    Pass).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令行输出告诉我们 `opt` 首先运行一组 *模块级* 优化；这些 Pass 的顺序（例如，`Annotation2MetadataPass` 和
    `ForceFunctionAttrsPass`）也被列出。之后，对 `bar` 函数（例如，`SROA`）执行一系列 *函数级* 优化，然后再对这些优化应用于
    `foo` 函数。此外，它还显示了管道中使用的分析（例如，`DominatorTreeAnalysis`），并提示我们有关它们因某个 Pass 而失效的消息。
- en: To sum up, `--debug-pass-manager` is a useful tool to peek into the Passes and
    their ordering run by the Pass pipeline at a certain optimization level. Knowing
    this information can give you a big picture of how Passes and analyses interact
    with the input IR.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`--debug-pass-manager` 是一个有用的工具，可以窥探在特定优化级别下 Pass 管道运行的 Pass 及其顺序。了解这些信息可以帮助你获得
    Pass 和分析如何与输入 IR 交互的整体图景。
- en: Printing changes to the IR after each Pass
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印每个 Pass 后的 IR 变化
- en: To understand the effects of a particular transformation Pass on your target
    program, one of the most straightforward ways is to compare the IR before and
    after it is processed by that Pass. To be more specific, in most cases, we are
    interested in the *changes* made by a particular transformation Pass. For instance,
    if LLVM mistakenly removes a loop that it shouldn't do, we want to know *what*
    Pass did that, and *when* the removal happened in the Pass pipeline.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解特定转换 Pass 对目标程序的影响，最直接的方法之一是比较该 Pass 处理前后的 IR。更具体地说，在大多数情况下，我们感兴趣的是特定转换 Pass
    所做的 *更改*。例如，如果 LLVM 错误地删除了它不应该删除的循环，我们想知道是哪个 Pass 做了这件事，以及 Pass 管道中删除发生的时间。
- en: 'By using the `--print-changed` flag (and some other supported flags that we
    will introduce shortly) with `opt`, we can print out the IR after each Pass if
    it was ever modified by that Pass. Using the `test.c` (and its IR file, `test.ll`)
    example code from the previous paragraph, we can use the following command to
    print changes, if there are any, made by each Pass:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`--print-changed`标志（以及我们将很快介绍的某些其他支持的标志）与`opt`结合，我们可以在每次Pass修改IR的情况下打印出IR。使用上一段中的`test.c`（及其IR文件`test.ll`）示例代码，我们可以使用以下命令来打印变化，如果有任何变化的话：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we have only shown a small amount of output. However, in the highlighted
    part of the snippet, we can see that this tool will first print out the original
    IR (`IR Dump At Start`), then show the IR after it is processed by each Pass.
    For example, the preceding snippet shows that the `bar` function has become much
    shorter after the SROA Pass. If a Pass didn't modify the IR at all, it will omit
    the IR dump to reduce the amount of noise.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只展示了少量输出。然而，在代码片段的高亮部分，我们可以看到这个工具将首先打印出原始IR（`IR Dump At Start`），然后显示每个Pass处理后的IR。例如，前面的代码片段显示，经过SROA
    Pass后，`bar`函数变得短得多。如果一个Pass根本未修改IR，它将省略IR转储以减少噪声。
- en: 'Sometimes, we are only interested in the changes that have happened on a *particular
    set of functions*, say, the `foo` function, in this case. Instead of printing
    the *change log* of the entire module, we can add the `--filter-print-funcs=<function
    names>` flag to only print IR changes for a subset of functions. For example,
    to only print IR changes for the `foo` function, you can use the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们只对特定函数集上的变化感兴趣，比如在这个例子中的`foo`函数。而不是打印整个模块的*变更日志*，我们可以添加`--filter-print-funcs=<function
    names>`标志来仅打印函数子集的IR变化。例如，要仅打印`foo`函数的IR变化，可以使用以下命令：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Just like `--filter-print-funcs`, sometimes, we only want to see changes made
    by a *particular set of Passes*, say, the SROA and `InstCombine` Passes. In that
    case, we can add the `--filter-passes=<Pass names>` flag. For example, to view
    only the content that is relevant to SROA and `InstCombine`, we can use the following
    command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`--filter-print-funcs`一样，有时候我们只想看到特定Pass集所做的变化，比如SROA和`InstCombine` Pass。在这种情况下，我们可以添加`--filter-passes=<Pass
    names>`标志。例如，要仅查看与SROA和`InstCombine`相关的内容，可以使用以下命令：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now you have learned how to print the IR differences among all the Passes in
    the pipeline, with additional filters that can further focus on a specific function
    or Pass. In other words, this tool can help you to easily observe the *progression*
    of changes throughout the Pass pipeline and quickly spot any traces that you might
    be interested in. In the next section, we will learn how to debug problems raised
    in the code optimization by *bisecting* the Pass pipeline.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何打印管道中所有Pass的IR差异，并使用额外的过滤器进一步关注特定的函数或Pass。换句话说，这个工具可以帮助你轻松观察Pass管道中变化的*进展*，并快速找到你可能感兴趣的任何痕迹。在下一节中，我们将学习如何通过*二分法*Pass管道来调试代码优化中提出的问题。
- en: Bisecting the Pass pipeline
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分Pass管道
- en: 'In the previous section, we introduced the `--print-changed` flag, which prints
    out the *IR change log* throughout the Pass pipeline. We also mentioned that it
    is useful to call out changes that we are interested in; for instance, an invalid
    code transformation that caused miscompilation bugs. Alternatively, we can also
    `--opt-bisect-limit=<N>` flag in `opt` bisects the Pass pipeline by *disabling*
    all Passes except the first `N` ones. The following command shows an example of
    this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们介绍了`--print-changed`标志，该标志在整个Pass管道中打印出*IR变更日志*。我们还提到，调用我们感兴趣的变化是有用的；例如，一个导致误编译错误的无效代码转换。或者，我们也可以在`opt`中使用`--opt-bisect-limit=<N>`标志，通过*禁用*除了前N个之外的所有Pass来二分Pass管道。以下命令展示了这个示例：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: (Note that this is different from examples shown in the previous sections; the
    preceding command has printed both messages from `--opt-bisect-limit` and the
    final textual IR.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，这与前几节中显示的示例不同；前面的命令已打印出`--opt-bisect-limit`和最终文本IR的消息。）
- en: Since we implemented the `--opt-bisect-limit=5` flag, the Pass pipeline only
    ran the first five Passes. As you can see from the diagnostic messages, SROA was
    applied on `bar` but not the `foo` function, leaving the final IR of `foo` less
    optimal.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实现了`--opt-bisect-limit=5`标志，Pass管道只运行了前五个Pass。正如诊断消息所示，SROA应用于`bar`函数，但没有应用于`foo`函数，导致`foo`函数的最终IR不太优化。
- en: By changing the number that follows `--opt-bisect-limit`, we can adjust the
    cut point until certain code changes appear or a certain bug is triggered (for
    example, a crash). This is particularly useful as an *early filtering step* to
    narrow down the original problem to a smaller range of Passes in the pipeline.
    Furthermore, since it uses a numeric value as the parameter, this feature fits
    perfectly to automating environments such as automatic crash reporting tools or
    performance regression tracking tools.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改 `--opt-bisect-limit` 后面的数字，我们可以调整截止点，直到出现某些代码更改或触发某个特定错误（例如，崩溃）。这特别有用，可以作为
    *早期过滤步骤* 来缩小原始问题在管道中 Pass 的范围。此外，由于它使用数值作为参数，这个特性非常适合自动化环境，例如自动崩溃报告工具或性能回归跟踪工具。
- en: In this section, we introduced several useful instrumentation tools in `opt`
    for debugging and diagnosing the Pass pipeline. These tools can greatly improve
    your productivity when it comes to fixing problems, such as compiler crashes,
    performance regressions (on the target program), and miscompilation bugs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 `opt` 中的一些有用的仪器工具，用于调试和诊断 Pass 管道。这些工具可以大大提高您在修复问题时的生产力，例如编译器崩溃、性能回归（在目标程序上）和误编译错误。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to write an LLVM Pass for the new PassManager
    and how to use program analysis data within a Pass via the AnalysisManager. We
    also learned how to leverage various instrumentation tools to improve the development
    experiences while working with the Pass pipeline. With the skills gained from
    this chapter, you can now write a Pass to process LLVM IR, which can be used to
    transform or even optimize a program.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何为新的 PassManager 编写 LLVM Pass，以及如何通过 AnalysisManager 在 Pass 中使用程序分析数据。我们还学习了如何利用各种仪器工具来改善与
    Pass 管道一起工作的开发体验。通过本章获得的知识，您现在可以编写一个处理 LLVM IR 的 Pass，这可以用来转换甚至优化程序。
- en: These topics are some of the most fundamental and crucial skills to learn before
    starting on any IR level transformation or analysis task. If you have been working
    with the legacy PassManager, these skills can also help you to migrate your code
    to the new PassManager system, which has now been enabled by default.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题是在开始任何 IR 级别的转换或分析任务之前需要学习的最基本和最重要的技能之一。如果您一直在使用传统的 PassManager，这些技能也可以帮助您将代码迁移到新的
    PassManager 系统，该系统现在已被默认启用。
- en: In the next chapter, we will show you various tips along with the best practices
    that you should know when using the APIs of LLVM IR.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您展示在使用 LLVM IR 的 API 时，您应该知道的各项技巧和最佳实践。
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: In the `StrictOpt` example of the *Writing an LLVM Pass for the new PassManager*
    section, how can you write a Pass without deriving the `PassInfoMixin` class?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“为新的 PassManager 编写 LLVM Pass”部分的 `StrictOpt` 示例中，您如何在不需要派生 `PassInfoMixin`
    类的情况下编写一个 Pass？
- en: 'How can you develop a custom instrumentation for the new PassManager? Additionally,
    how can you do this without modifying the LLVM source tree? (Hint: think about
    the Pass plugin that we learned about in this chapter.)'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何为新的 PassManager 开发自定义的仪器？此外，您如何在不修改 LLVM 源树的情况下做到这一点？（提示：想想我们在本章中学到的 Pass
    插件。）
