<html><head></head><body>
		<div id="_idContainer161">
			<h1 id="_idParaDest-185" class="chapter-number"><a id="_idTextAnchor184"/>6</h1>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Infinite Flyer</h1>
			<p>In this chapter, you’ll build a 3D infinite runner (or more accurately, infinite <em class="italic">flyer</em>) in the vein of <em class="italic">Temple Run</em> or <em class="italic">Subway Surfers</em>. The player’s goal is to fly as far as possible, passing through floating rings to collect points, while avoiding obstacles. By building this game, you’ll get a feel for<a id="_idIndexMarker461"/> how to make 3D objects interact and how to generate a 3D world automatically, rather than building it piece-by-piece as you did in earlier games such as <em class="italic">Minigolf</em> or <span class="No-Break"><em class="italic">Jungle Jump</em></span><span class="No-Break">.</span></p>
			<p>Here are some of the new things you’ll learn in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Using transforms to rotate and move in <span class="No-Break">3D space</span></li>
				<li>Load and unload “chunks” of your <span class="No-Break">game world</span></li>
				<li>How to randomly generate the game environment and <span class="No-Break">game objects</span></li>
				<li>Saving and loading files for persistent <span class="No-Break">data storage</span></li>
				<li>Using <strong class="source-inline">CharacterBody3D</strong> and <span class="No-Break">detecting collisions</span></li>
			</ul>
			<p>When completed, the game will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B19289_06_01.jpg" alt="Figure 6.1: Finished game screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: Finished game screenshot</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Technical requirements</h1>
			<p>Download the game assets from the following link and unzip them into your new <span class="No-Break">project folder:</span></p>
			<p><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads"><span class="No-Break">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads</span></a></p>
			<p>You can also find the complete code for this chapter on GitHub <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter06%20-%20Infinite%20Flyer"><span class="No-Break">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter06%20-%20Infinite%20Flyer</span></a></p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor187"/>Project setup</h1>
			<p>Create a <a id="_idIndexMarker462"/>new project in Godot to get started. As you’ve done before, download the project assets and unzip them in the new project folder. Once you’ve created the project, you’ll start by configuring the inputs and Godot settings needed for <span class="No-Break">the game.</span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>Inputs</h2>
			<p>You’ll control <a id="_idIndexMarker463"/>the plane with up, down, left, and right inputs. You can add them in <strong class="bold">Input Map</strong> in the same way you’ve done with other projects. Name the four inputs <strong class="source-inline">pitch_up</strong>, <strong class="source-inline">pitch_down</strong>, <strong class="source-inline">roll_left</strong>, and <strong class="source-inline">roll_right</strong>. You can add the arrow keys and/or the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys to these, but if you have a game controller, you can also use a joystick for more precise control. To add joystick inputs, you can select <strong class="bold">Joypad Axes</strong> after pressing the <strong class="bold">+</strong> button. The values are labeled, such as <strong class="bold">Left Stick Up</strong>, so you can easily keep track <span class="No-Break">of them:</span></p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B19289_06_02.jpg" alt="Figure 6.2: Input configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: Input configuration</p>
			<p>The <a id="_idIndexMarker464"/>nice part about this setup is that your code won’t have to be any different for the different types of input. By using <strong class="source-inline">Input.get_axis()</strong> and passing in the four input events, you’ll get a result whether the player pressed a key or moved the stick. Pressing the keys is equivalent to pushing the stick all the way in <span class="No-Break">one direction.</span></p>
			<p>Now that the project is set up, you can start making your game objects, starting with the <span class="No-Break">player-controlled airplane.</span></p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor189"/>Airplane scene</h1>
			<p>In this <a id="_idIndexMarker465"/>section, you’ll create the airplane that the player will control. It <a id="_idIndexMarker466"/>will fly forward while the player can move it up, down, left, <span class="No-Break">and right.</span></p>
			<p>Start your new plane scene with a <strong class="source-inline">CharacterBody3D</strong> node named <strong class="source-inline">Plane</strong> and <span class="No-Break">save it.</span></p>
			<p>You can find the 3D model for the airplane in the <strong class="source-inline">assets</strong> folder, named <strong class="source-inline">cartoon_plane.glb</strong>. The name indicates the model is stored as a <em class="italic">binary</em> <strong class="source-inline">.gltf</strong> file (exported from Blender). Godot imports <strong class="source-inline">.gltf</strong> files as scenes containing meshes, animations, materials, and <a id="_idIndexMarker467"/>other objects that may have been exported in the file. Click the <strong class="bold">Instance a Child Scene</strong> button and choose the plane model. You’ll see it appears as <strong class="source-inline">Node3D</strong>, but it’s facing the wrong direction. Select it and set the <strong class="bold">Rotation/Y</strong> function to <strong class="source-inline">180</strong> in the Inspector feature, so that it points along the <em class="italic">z</em> axis, which is Godot’s “forward” direction. Note that typing the value directly is easier than trying to rotate the <a id="_idIndexMarker468"/>node exactly using <span class="No-Break">the mouse.</span></p>
			<p class="callout-heading">Model orientation</p>
			<p class="callout">As mentioned in the previous chapter, the various 3D design programs use different axis orientations. It’s very common to import your model and have its forward direction not match Godot’s. If you’re making the model yourself, you can correct this when you export it, but when you’re using a model made by someone else, it’s common to need to reorient it <span class="No-Break">in Godot.</span></p>
			<p>If you right-click on the <strong class="source-inline">cartoon_plane</strong> node and choose <strong class="bold">Editable Children</strong>, you’ll see all of the meshes that make up the plane, <span class="No-Break">plus </span><span class="No-Break"><strong class="source-inline">AnimationPlayer</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B19289_06_03.jpg" alt="Figure 6.3: Airplane meshes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: Airplane meshes</p>
			<p><strong class="source-inline">AnimationPlayer</strong> contains an animation for making the propeller spin, so select it and set the <strong class="source-inline">prop_spin</strong> animation for the <strong class="bold">Autoplay on </strong><span class="No-Break"><strong class="bold">Load</strong></span><span class="No-Break"> function:</span></p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B19289_06_04.jpg" alt="Figure 6.4: Autoplay animation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: Autoplay animation</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/>Collision shapes</h2>
			<p>Add a <strong class="source-inline">CollisionShape3D</strong> node to <strong class="source-inline">Plane</strong> and choose <strong class="bold">New CylinderShape3D</strong> for its <strong class="bold">Shape</strong> setting. You <a id="_idIndexMarker469"/>can size a cylinder with the two orange size handles, but you’ll need to rotate it around the <em class="italic">x</em> axis by <strong class="source-inline">90</strong> to align it with the plane’s fuselage. You can do this with the gizmo (don’t forget to turn on snapping using the “Use Smart Snap” icon      to get it perfectly aligned) or by typing the value directly <span class="No-Break">into Inspector.</span></p>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/B19289_06_05.jpg" alt=""/>
				</div>
			</div>
			<p>The wings also need to be covered, so add a second <strong class="source-inline">CollisionShape3D</strong> node. This time, use <strong class="source-inline">BoxShape3D</strong>. Size it to cover <span class="No-Break">the wings:</span></p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/B19289_06_06.jpg" alt="Figure 6.5: Airplane collision shapes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: Airplane collision shapes</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>Scripting the plane</h2>
			<p>You can <a id="_idIndexMarker470"/>begin with the airplane’s controls. There are two axes of movement: “pitch up” and “pitch down” will raise or lower the nose of the plane (rotating around its <em class="italic">x</em> axis), causing it to move up or down. The <strong class="source-inline">roll_left</strong> and <strong class="source-inline">roll_right</strong> functions will rotate the plane around its <em class="italic">z</em> axis, which causes it to go left <span class="No-Break">or right.</span></p>
			<p>For either <a id="_idIndexMarker471"/>input, you’ll want smooth rotation, and when the player lets go of the button or returns the stick to the center, the plane should smoothly rotate back to its original position. You can do this by <strong class="bold">interpolating</strong> the<a id="_idIndexMarker472"/> rotation rather than setting it directly <span class="No-Break">when rotating.</span></p>
			<p class="callout-heading">About interpolation</p>
			<p class="callout"><strong class="bold">Linear interpolation</strong>, typically <a id="_idIndexMarker473"/>abbreviated to <strong class="bold">lerp</strong>, is a term that you’ll encounter often in game development. It means to calculate an intermediate value between two given values, using a straight-line function. In practice, it can be used to smoothly change a value from one value to another <span class="No-Break">over time.</span></p>
			<p>To begin, attach a script to the <strong class="source-inline">Plane</strong> node and define <span class="No-Break">some variables:</span></p>
			<pre class="source-code">
extends CharacterBody3D
@export var pitch_speed = 1.1
@export var roll_speed = 2.5
@export var level_speed = 4.0
var roll_input = 0
var pitch_input = 0</pre>
			<p>The exported variables let you set the speed of the plane’s rotation in either direction, as well as the speed of its automatic return to <span class="No-Break">level flight.</span></p>
			<p>In your <strong class="source-inline">get_input()</strong> function, you’ll check the values of the inputs from <strong class="bold">Input Map</strong> to determine which way <span class="No-Break">to rotate:</span></p>
			<pre class="source-code">
func get_input(delta):
    pitch_input = Input.get_axis("pitch_down", "pitch_up")
    roll_input = Input.get_axis("roll_left", "roll_right")</pre>
			<p>The <strong class="source-inline">Input.get_axis()</strong> function returns a value between <strong class="source-inline">-1</strong> and <strong class="source-inline">1</strong> based on the two inputs. When using keys, which can only be pressed or not pressed, that will mean you’ll only get <strong class="source-inline">-1</strong> when one key is pressed, <strong class="source-inline">1</strong> for the other, and <strong class="source-inline">0</strong> when neither or both are pressed. However, when using an analog input such as a joystick axis, you can get the full range of values. This allows more precise control, as tilting the joystick only slightly to the<a id="_idIndexMarker474"/> right will give a small <strong class="source-inline">roll_input</strong> value of <strong class="source-inline">0.25</strong>, <span class="No-Break">for example.</span></p>
			<p>In <strong class="source-inline">_physics_process()</strong>, you can then rotate the plane on its <em class="italic">x</em> axis based on the <span class="No-Break">pitch input:</span></p>
			<pre class="source-code">
func _physics_process(delta):
    get_input(delta)
    rotation.x = lerpf(rotation.x, pitch_input,
        pitch_speed * delta)
    rotation.x = clamp(rotation.x, deg_to_rad(-45),
        deg_to_rad(45))</pre>
			<p>It’s also important to use <strong class="source-inline">clamp()</strong> to limit the rotation so the plane doesn’t flip completely <span class="No-Break">upside down.</span></p>
			<p>You can test this out by making a new test scene and adding the plane and <strong class="source-inline">Camera3D</strong>, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/B19289_06_07.jpg" alt="Figure 6.6: Test scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6: Test scene</p>
			<p>Position the camera behind the plane and run the scene to test that pressing the pitch up and pitch down inputs correctly tilts the plane up <span class="No-Break">and down.</span></p>
			<p>For the roll, you could rotate the body in the <em class="italic">z</em> axis as well, but then the two rotations would add together, and you’d find it very difficult to get the plane back to level flight. Since for this game, you want the plane to continue going forward, it will be easier to rotate the <a id="_idIndexMarker475"/>child mesh instead. Add this line next <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">_physics_process()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$cartoon_plane.rotation.z = lerpf($cartoon_plane.rotation.z, roll_input, roll_speed * delta)</pre>
			<p>Test it again in your test scene and make sure that the controls all work <span class="No-Break">as expected.</span></p>
			<p>To finish up the movement, add two more variables at the top of the script. Your plane’s flying speed will be <strong class="source-inline">forward_speed</strong>. You’ll adjust this later to change the difficulty of the game. You can use <strong class="source-inline">max_altitude</strong> to keep the plane from <span class="No-Break">climbing offscreen:</span></p>
			<pre class="source-code">
@export var forward_speed = 25
var max_altitude = 20</pre>
			<p>In <strong class="source-inline">get_input()</strong>, after checking the inputs, add this to cause the plane to level out if it reaches the <span class="No-Break">maximum altitude:</span></p>
			<pre class="source-code">
if position.y &gt;= max_altitude and pitch_input &gt; 0:
    position.y = max_altitude
    pitch_input = 0</pre>
			<p>Then, add this to <strong class="source-inline">_physics_process()</strong> to handle the movement. The forward velocity will be the <span class="No-Break"><strong class="source-inline">forward_speed</strong></span><span class="No-Break"> amount:</span></p>
			<pre class="source-code">
velocity = -transform.basis.z * forward_speed</pre>
			<p>For the side-to-side movement (in the <em class="italic">x</em> direction), you can multiply by the amount of rotation to make it faster or slower depending on how much the plane has rolled. Then, scale the speed based on the forward speed (dividing by two to make it a little bit slower – experiment here to change <span class="No-Break">the feel):</span></p>
			<pre class="source-code">
velocity += transform.basis.x * $cartoon_plane.rotation.z / deg_to_rad(45) * forward_speed / 2.0
move_and_slide()</pre>
			<p>Your plane should now be flying forward and the controls should be working as expected. Don’t <a id="_idIndexMarker476"/>move on to the next step until you’ve checked that the plane behaves correctly. In the next section, you will build the environment for the plane to fly <span class="No-Break">around in.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/>Building the world</h1>
			<p>Because<a id="_idIndexMarker477"/> this is an <em class="italic">infinite</em>-style game, the player will continue to fly through the world as long as possible. That means you will need to continuously create more of the world for them to see – random buildings, items to collect, and so on. It would be impractical to create this all ahead of time both because you don’t know how far the player will go, and because you don’t want the game to be the same every time you play. It would also be inefficient to load a huge game world if the player isn’t going to see most <span class="No-Break">of it.</span></p>
			<p>For that reason, it makes more sense to <a id="_idIndexMarker478"/>use a <strong class="bold">chunking</strong> strategy. You’ll randomly generate the world in smaller pieces, or chunks. You can then create these as they’re needed – as the player moves forward. You can also remove them once they’ve been passed when the game doesn’t need to keep track of <span class="No-Break">them anymore.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>World objects</h2>
			<p>Each time<a id="_idIndexMarker479"/> you generate a new chunk of the world, it’s going to contain a number of different world objects. You can begin with two: buildings, which will be obstacles, and rings that the player tries to collect by flying <span class="No-Break">through them.</span></p>
			<h3>Buildings</h3>
			<p>For the <a id="_idIndexMarker480"/>first building, start a new scene with a <strong class="source-inline">StaticBody3D</strong> node and name it <strong class="source-inline">Building1</strong>. Add a <strong class="source-inline">MeshInstance3D</strong> node and drag <strong class="source-inline">res://assets/building_meshes/Build_01.obj</strong> into the <strong class="bold">Mesh</strong> property. Rather than a <strong class="source-inline">.glTF</strong> file, the building’s mesh is stored in the <em class="italic">OBJ</em> format. There is also a separate <strong class="source-inline">.mtl</strong> file that contains the mesh’s material – Godot hides it in the <strong class="bold">FileSystem</strong> panel, but it will be used for the texture in the <span class="No-Break">mesh instance.</span></p>
			<p>You’ll <a id="_idIndexMarker481"/>notice that the building is centered on the origin. Since your buildings are going to be of different sizes, this will make it difficult to place them all on the ground – they’ll all have different offsets. If your buildings are all consistently offset ahead of time, then they can be more <span class="No-Break">easily placed.</span></p>
			<p>To position the building mesh, change the <strong class="bold">Position</strong> property of the <strong class="source-inline">MeshInstance3D</strong> node to <strong class="source-inline">(0, 6, -8)</strong>, which moves it up and places its edge on the origin. Add a collision shape by selecting the mesh and choosing <strong class="bold">Mesh</strong> -&gt; <strong class="bold">Create Trimesh </strong><span class="No-Break"><strong class="bold">Collision Sibling</strong></span><span class="No-Break">.</span></p>
			<p>Save the scene in a new folder called <strong class="source-inline">res://buildings/</strong> and repeat the process with the other buildings, starting each scene with a <strong class="source-inline">StaticBody3D</strong> node, adding the mesh, offsetting it, and then creating the collision shape. Since each building is a different size, here are the offsets that will position <span class="No-Break">them perfectly:</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Building</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Offset</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">1</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">(0, </strong><span class="No-Break"><strong class="source-inline">6, -8)</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">2</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">(0, </strong><span class="No-Break"><strong class="source-inline">8, -4)</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">3</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">(0, </strong><span class="No-Break"><strong class="source-inline">10, -6)</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">4</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">(0, </strong><span class="No-Break"><strong class="source-inline">10, -6)</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">5</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">(0, </strong><span class="No-Break"><strong class="source-inline">11, -4)</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>The chunk can now load and instance these buildings randomly to create a varied <span class="No-Break">city skyline.</span></p>
			<h3>Rings</h3>
			<p>Rings <a id="_idIndexMarker482"/>will appear ahead of the player, and the plane needs to fly through them to score. If the plane is very close to the center of the ring, the player will get a score bonus. As the game progresses, the rings can become more difficult to catch – changing size, moving back and forth, and <span class="No-Break">so on.</span></p>
			<p>Before starting, and without looking ahead, think about which type of node would be best for the <span class="No-Break">ring object.</span></p>
			<p>Did you select <strong class="source-inline">Area3D</strong>? Since you want to detect when the plane flies through the ring, but not collide with it, an area’s <strong class="source-inline">body_entered</strong> detection will be the <span class="No-Break">ideal solution.</span></p>
			<p>Start the<a id="_idIndexMarker483"/> new <strong class="source-inline">Ring</strong> scene with <strong class="source-inline">Area3D</strong> and add a <strong class="source-inline">MeshInstance3D</strong> child. For <strong class="bold">Mesh</strong>, choose <strong class="source-inline">TorusMesh</strong>, and in the mesh properties, set <strong class="bold">Inner Radius</strong> to <strong class="source-inline">3.5</strong> and <strong class="bold">Outer Radius</strong> to <strong class="source-inline">4</strong>, so that you have a <span class="No-Break">narrow ring.</span></p>
			<p>Add a <strong class="source-inline">CollisionShape3D</strong> node and choose <strong class="bold">New CylinderShape3D</strong> for its <strong class="bold">Shape</strong>. This time, set the <strong class="bold">Height</strong> property to <strong class="source-inline">.5</strong> and <strong class="bold">Radius</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">.</span></p>
			<p>Later, you’ll want to animate the ring moving up and down. An easy way to do this will be to move the collision shape relative to the root node’s position. Since you’ll want the mesh to move as well, drag the mesh to make it a child of <strong class="source-inline">CollisionShape3D</strong>. Rotate the collision shape 90 degrees around <em class="italic">x</em> to make it <span class="No-Break">stand up.</span></p>
			<p>A plain white ring is not very exciting, so you can add texture. In the <strong class="bold">Mesh</strong> property of <strong class="source-inline">MeshInstance3D</strong>, add <strong class="bold">New StandardMaterial3D</strong> and click to expand it. Under <strong class="bold">Albedo/Texture</strong>, add <strong class="source-inline">res://assets/textures/texture_09.png</strong>. You’ll notice that the texture, which is a grid of alternating light and dark squares, looks very stretched around the torus. You can adjust how a texture is wrapped around the mesh by changing the <strong class="bold">UV1/Scale</strong> values. Try <strong class="source-inline">(12, 1, 1)</strong> for a beginning value and adjust it to your liking. Under <strong class="bold">Shading</strong>, set <strong class="bold">Shading Mode</strong> to <strong class="bold">Unshaded</strong> – this will ensure that the ring ignores lighting and shadows, keeping it bright and visible at <span class="No-Break">all times.</span></p>
			<p>Next, add a <strong class="source-inline">Label3D</strong> node to the <strong class="source-inline">Ring</strong> node. You’ll use this to show the player how many points they scored for the ring and whether or not they got the center bonus. Set the <strong class="bold">Text/Text</strong> field to <strong class="source-inline">100</strong> so you can see something to test. Under <strong class="bold">Text/Font</strong>, add <strong class="source-inline">Baloo2-Medium.ttf</strong> from the assets folder and set the font size to <strong class="source-inline">720</strong>. To make the text always face the camera, set <strong class="bold">Flags/Billboard</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Enabled</strong></span><span class="No-Break">.</span></p>
			<p>Add a script to the ring and connect the <strong class="source-inline">body_entered</strong> signal. The <strong class="source-inline">Label3D</strong> function should be hidden at first, and the ring will be hidden when the plane touches it. There’s a problem, though: what if a ring spawns and overlaps a building? The <strong class="source-inline">body_entered</strong> signal will still be triggered, but you don’t want the building to collect <span class="No-Break">the ring!</span></p>
			<p>You can solve this by setting collision layers. On the <strong class="source-inline">Plane</strong> scene, change its <strong class="bold">Collision/Layer</strong> value to <strong class="source-inline">2</strong> (removing <strong class="source-inline">1</strong>), then come back to the <strong class="source-inline">Ring</strong> node and set its <strong class="bold">Collision/Mask</strong> setting to only layer <strong class="source-inline">2</strong>. Now, you can be sure that if the ring sees a body enter, it <a id="_idIndexMarker484"/>can only be <span class="No-Break">the plane:</span></p>
			<pre class="source-code">
extends Area3D
func _ready():
    $Label3D.hide()</pre>
			<p>After that, you need to find the distance from the plane to the center of the ring to see if the player scored the bonus and set the <strong class="source-inline">text</strong> property to the correct value. If the plane hits the ring directly in the center (closer than 2.0 units), you can also color the text yellow to indicate the <span class="No-Break">perfect hit:</span></p>
			<pre class="source-code">
func _on_body_entered(body):
    $CollisionShape3D/MeshInstance3D.hide()
    var d = global_position.distance_to(body.global_position)
    if d &lt; 2.0:
        $Label3D.text = "200"
        $Label3D.modulate = Color(1, 1, 0)
    elif d &gt; 3.5:
        $Label3D.text = "50"
    else:
        $Label3D.text = "100"
    $Label3D.show()</pre>
			<p>Continuing the <strong class="source-inline">_on_body_entered()</strong> function, add some animation to the label to make it move and <span class="No-Break">fade out:</span></p>
			<pre class="source-code">
var tween = create_tween().set_parallel()
tween.tween_property($Label3D, "position",
    Vector3(0, 10, 0), 1.0)
tween.tween_property($Label3D, "modulate:a", 0.0, 0.5)</pre>
			<p>Lastly, give <a id="_idIndexMarker485"/>the ring a nice <span class="No-Break">rotation effect:</span></p>
			<pre class="source-code">
func _process(delta):
    $CollisionShape3D/MeshInstance3D.rotate_y(deg_to_rad(50) * delta)</pre>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>Chunks</h2>
			<p>Now that you’ve got the <a id="_idIndexMarker486"/>building blocks of your chunk, you can make the chunk scene itself. This is the scene that the game will instance whenever there needs to be more of the world ahead of the player. When you instantiate a new chunk, it will randomly place buildings along the left and right sides, as well as spawning rings at random points along <span class="No-Break">its length.</span></p>
			<p>Start the <strong class="source-inline">Chunk</strong> scene with a <strong class="source-inline">Node3D</strong> node and a <strong class="source-inline">MeshInstance3D</strong> child named <strong class="source-inline">Ground</strong>. Make the <strong class="bold">Mesh</strong> property a <strong class="source-inline">PlaneMesh</strong> and set its <strong class="bold">Size</strong> setting to <strong class="source-inline">(50, 200)</strong>. This is the size of a <span class="No-Break">single chunk:</span></p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B19289_06_08.jpg" alt="Figure 6.7: Plane size settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7: Plane size settings</p>
			<p>Position it to start at the origin by setting its <strong class="bold">Z</strong> position <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">-100</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B19289_06_09.jpg" alt="Figure 6.8: Positioning the plane"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8: Positioning the plane</p>
			<p>Add<a id="_idIndexMarker487"/> material and use <strong class="source-inline">texture_01.png</strong> as the <strong class="bold">Albedo/Texture</strong> and set the <strong class="bold">UV1/Scale</strong> values to <strong class="source-inline">(2, 10, 2)</strong>. By default, Godot links the three scale values to keep them the same, so you’ll need to uncheck the link button to allow them to <span class="No-Break">be different:</span></p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/B19289_06_10.jpg" alt="Figure 6.9: Adjusting the UV scale"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9: Adjusting the UV scale</p>
			<p>Select the <strong class="source-inline">Ground</strong> node and choose <strong class="bold">Mesh</strong> -&gt; <strong class="bold">Create Trimesh Static Body</strong> to add a <strong class="source-inline">StaticBody3D</strong> node and a <strong class="source-inline">CollisionShape3D</strong> node that matches the size of <span class="No-Break">the ground.</span></p>
			<p>As the plane moves toward the end of the chunk, you’ll spawn a new chunk ahead, and you can also remove old chunks once they’ve passed by. To assist with the latter, add a <strong class="source-inline">VisibleOnScreenNotifier3D</strong> node and set its <strong class="bold">Position</strong> property to (<strong class="source-inline">0, 0, -250)</strong>, which places it past the end of the <span class="No-Break">ground plane.</span></p>
			<p>You can now add a script to the <strong class="source-inline">Chunk</strong> node and connect the notifier’s <strong class="source-inline">screen_exited</strong> signal so that the chunk will <span class="No-Break">be removed:</span></p>
			<pre class="source-code">
func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()</pre>
			<p>At the top <a id="_idIndexMarker488"/>of the script, load the scenes that need to <span class="No-Break">be instanced:</span></p>
			<pre class="source-code">
extends Node3D
var buildings = [
    preload("res://buildings/building_1.tscn"),
    preload("res://buildings/building_2.tscn"),
    preload("res://buildings/building_3.tscn"),
    preload("res://buildings/building_4.tscn"),
    preload("res://buildings/building_5.tscn"),
]
var ring = preload("res://ring.tscn")
var level = 0</pre>
			<p class="callout-heading">Loading many scenes</p>
			<p class="callout">In a bigger game, where you have a much larger number of buildings and possibly other scenes, you wouldn’t want to write them all out individually in the script as you’ve done here. Another solution would be to write code here that loads every scene file saved in a <span class="No-Break">particular folder.</span></p>
			<p>The <strong class="source-inline">level</strong> variable can be set by the main scene when the chunk is loaded to allow increasing difficulty by spawning rings with different behaviors (more about <span class="No-Break">that later).</span></p>
			<p>In <strong class="source-inline">_ready()</strong>, the chunk needs to do <span class="No-Break">three things:</span></p>
			<ul>
				<li>Spawn buildings along the sides of the <span class="No-Break">ground plane</span></li>
				<li>Occasionally spawn buildings in the middle to act <span class="No-Break">as obstacles</span></li>
				<li><span class="No-Break">Spawn rings</span></li>
			</ul>
			<p>Each of<a id="_idIndexMarker489"/> these steps will involve some code, so you can keep it all organized by creating three <span class="No-Break">separate functions:</span></p>
			<pre class="source-code">
func _ready():
    add_buildings()
    add_center_buildings()
    add_rings()</pre>
			<p>The first step is to spawn the side buildings. Since they need to be on both sides of the chunk, you repeat the loop twice – once for the positive <em class="italic">x</em> direction and once for the negative direction. Each time, you’ll move along the length of the chunk spawning <span class="No-Break">random buildings:</span></p>
			<pre class="source-code">
func add_buildings():
    for side in [-1, 1]:
        var zpos = -10
        for i in 18:
            if randf() &gt; 0.75:
                zpos -= randi_range(5, 10)
                continue
            var nb = buildings[randi_range(0,
                buildings.size()-1)].instantiate()
            add_child(nb)
            nb.transform.origin.z = zpos
            nb.transform.origin.x = 20 * side
            zpos -= nb.get_node("MeshInstance3D").mesh.get_aabb().size.z</pre>
			<p>The <strong class="source-inline">randf()</strong> function is a common random function that returns a floating point number between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, making it easy to use to calculate percentages. Check here if the random number is greater than <strong class="source-inline">0.75</strong> to have a 25% chance of there being no building at a <span class="No-Break">particular spot.</span></p>
			<p>By <a id="_idIndexMarker490"/>getting the size of the building mesh using <strong class="source-inline">get_aabb()</strong>, you can ensure that the buildings don’t overlap each other. The position of the next building will be exactly at the edge of the <span class="No-Break">previous one.</span></p>
			<p>Next, spawning middle buildings won’t happen at the start, but later in the game, they’ll start appearing with a <span class="No-Break">20% probability:</span></p>
			<pre class="source-code">
func add_center_buildings():
    if level &gt; 0:
        for z in range(0, -200, -20):
            if randf() &gt; 0.8:
                var nb = buildings[0].instantiate()
                add_child(nb)
                nb.position.z = z
                nb.position.x += 8
                nb.rotation.y = PI / 2</pre>
			<p>The third step is spawning the rings. Right now, it just positions some rings at random fixed positions. Later, you’ll add some more variation here as the <span class="No-Break">game progresses:</span></p>
			<pre class="source-code">
func add_rings():
    for z in range(0, -200, -10):
        if randf() &gt; 0.76:
            var nr = ring.instantiate()
            nr.position.z = z
            nr.position.y = randf_range(3, 17)
            add_child(nr)</pre>
			<p>You’re finished setting up the chunk. When it loads, it takes care of populating itself with a random <a id="_idIndexMarker491"/>assortment of buildings and rings, and it also removes itself when it later goes offscreen. In the next section, you’ll bring it all together in a scene that instantiates chunks as the plane <span class="No-Break">moves forward.</span></p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor195"/>Main scene</h1>
			<p>In this <a id="_idIndexMarker492"/>section, you’ll make the main scene, which, in this<a id="_idIndexMarker493"/> game, will handle loading the world chunks, displaying the game information, and starting and ending <span class="No-Break">the game.</span></p>
			<p>Start a new scene with a <strong class="source-inline">Node3D</strong> named <strong class="source-inline">Main</strong>. Add an instance of the <strong class="source-inline">Plane</strong> and an instance of the <strong class="source-inline">Chunk</strong> to <span class="No-Break">start with.</span></p>
			<p>You’ll also need some lighting, so in the toolbar, choose the “Edit Sun and Environment settings” dropdown and add the sun and environment to <span class="No-Break">the scene:</span></p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/B19289_06_11.jpg" alt="Figure 6.10: Add environment and sun"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10: Add environment and sun</p>
			<p>Rather than use the generated sky texture, you can use <strong class="source-inline">styled_sky.hdr</strong> found in the assets folder. Select <strong class="source-inline">WorldEnvironment</strong> and then expand its <strong class="bold">Sky</strong> property. You’ll see that it’s set to <strong class="source-inline">ProdeduralSkyMaterial</strong>. Click the down arrow and choose <strong class="bold">New PanoramaSkyMaterial</strong>. When you expand that, you’ll see an empty <strong class="bold">Panorama</strong> property where you can drag and <span class="No-Break">drop </span><span class="No-Break"><strong class="source-inline">styled_sky.hdr</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/B19289_06_12.jpg" alt="Figure 6.11: WorldEnvironment sky settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11: WorldEnvironment sky settings</p>
			<p>Before <a id="_idIndexMarker494"/>you <a id="_idIndexMarker495"/>can test, you’ll also need a camera. Add a <strong class="source-inline">Camera3D</strong> and then add a script to it. Since it’s a standalone node without any children, you don’t need to make it a separate <span class="No-Break">saved scene:</span></p>
			<pre class="source-code">
extends Camera3D
@export var target_path : NodePath
@export var offset = Vector3.ZERO
var target = null
func _ready():
    if target_path:
        target = get_node(target_path)
        position = target.position + offset
        look_at(target.position)
func _physics_process(_delta):
    if !target:
        return
    position = target.position + offset</pre>
			<p>This camera <a id="_idIndexMarker496"/>script is generic and could be used in other projects<a id="_idIndexMarker497"/> where you want a camera to follow a moving <span class="No-Break">3D object.</span></p>
			<p>Select the <strong class="source-inline">Camera3D</strong> node and in Inspector, click <strong class="bold">Target Path</strong> and choose the <strong class="source-inline">Plane</strong> node. Set <strong class="bold">Offset</strong> to <strong class="source-inline">(7, 7, 15)</strong>, which will keep the camera behind, above, and to the right of <span class="No-Break">the plane.</span></p>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/B19289_06_13.jpg" alt="Figure 6.12: Camera follow settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12: Camera follow settings</p>
			<p>Play the <strong class="source-inline">Main</strong> scene and you should be able to fly along the chunk, collecting rings. If you run into the buildings, nothing will happen, and when you reach the end of the chunk, you won’t see <span class="No-Break">another one.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Spawning new chunks</h2>
			<p>The<a id="_idIndexMarker498"/> length of each chunk is <strong class="source-inline">200</strong>, so when the plane has traveled half that distance, a new chunk should spawn ahead at the end position of the previous chunk. The <strong class="source-inline">max_position</strong> setting will keep track of the middle of the next chunk ahead, which is the position that the plane needs to reach to spawn a <span class="No-Break">new chunk.</span></p>
			<p>You’ll also <a id="_idIndexMarker499"/>keep track of how many chunks have been spawned, so you can use that to determine when the game should <span class="No-Break">get harder.</span></p>
			<p>Add a script to <strong class="source-inline">Main</strong> and add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
extends Node3D
var chunk = preload("res://chunk.tscn")
var num_chunks = 1
var chunk_size = 200
var max_position = -100</pre>
			<p>Remember that everything is moving forward in the <em class="italic">-z</em> direction, so the position at the center of the first chunk will have a <em class="italic">z</em> value of <strong class="source-inline">-100</strong>. The plane’s <em class="italic">z</em> coordinate will continue to decrease as it <span class="No-Break">moves forward.</span></p>
			<p>In <strong class="source-inline">_process()</strong>, you’ll check the plane’s position, and if it goes past <strong class="source-inline">max_position</strong>, it’s time to instantiate a new chunk and update <strong class="source-inline">max_position</strong> to the center of the <span class="No-Break">next chunk:</span></p>
			<pre class="source-code">
func _process(delta):
    if $Plane.position.z  &lt; max_position:
        num_chunks += 1
        var new_chunk = chunk.instantiate()
        new_chunk.position.z = max_position – chunk_size / 2
        new_chunk.level = num_chunks / 4
        add_child(new_chunk)
        max_position -= chunk_size</pre>
			<p>Here is where the chunk spawning happens. The new chunk gets placed at the end of the previous one. Remember that <strong class="source-inline">max_position</strong> is the center of the chunk, so you also need to add <strong class="source-inline">chunk_size / </strong><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></p>
			<p>Then, to get <a id="_idIndexMarker500"/>the level number, dividing by <strong class="source-inline">4</strong> results<a id="_idIndexMarker501"/> in <strong class="bold">integer division</strong>, meaning the fractional part will be discarded. For example, on chunk number <strong class="source-inline">5</strong>, <strong class="source-inline">5/4</strong> is just <strong class="source-inline">1</strong>. The level will reach <strong class="source-inline">2</strong> at chunk number <strong class="source-inline">8</strong>, <strong class="source-inline">3</strong> at chunk number <strong class="source-inline">12</strong>, and so on. This will give you a gradual increase <span class="No-Break">in difficulty.</span></p>
			<p>Play the scene. You should now see the new chunks appearing ahead of the plane as it <span class="No-Break">moves forward.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Increasing difficulty</h2>
			<p>Now that you’re spawning chunks, they’re being given a level value that gradually increases. You can <a id="_idIndexMarker502"/>use that to start making the rings more challenging to collect. For example, currently, they’re placed exactly in the center, so the player doesn’t need to steer left or right at all. You could start randomizing the <em class="italic">x</em> coordinate of the rings. You could also start making the rings move back and forth or up <span class="No-Break">and down.</span></p>
			<p>Add these variables to the top <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ring.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
var move_x = false
var move_y = false
var move_amount = 2.5
var move_speed = 2.0</pre>
			<p>The two Boolean variables will let you turn on movement in the <em class="italic">x</em> or <em class="italic">y</em> direction, and <strong class="source-inline">move_amount</strong> and <strong class="source-inline">move_speed</strong> will let you control how much movement <span class="No-Break">you want.</span></p>
			<p>When those values are set, you can check <strong class="source-inline">_ready()</strong>, start the movement, then use <span class="No-Break">a tween:</span></p>
			<pre class="source-code">
func _ready():
    $Label3D.hide()
    var tween = create_tween().set_loops()
        .set_trans(Tween.TRANS_SINE)
    tween.stop()
    if move_y:
        tween.tween_property($CollisionShape3D,
            "position:y", -move_amount, move_speed)
        tween.tween_property($CollisionShape3D,
            "position:y", move_amount, move_speed)
        tween.play()
    if move_x:
        tween.tween_property($CollisionShape3D,
            "position:x", -move_amount, move_speed)
        tween.tween_property($CollisionShape3D,
            "position:x", move_amount, move_speed)
        tween.play()</pre>
			<p>Note that<a id="_idIndexMarker503"/> by default, a tween starts playing automatically. Since you may or may not be actually animating a property, depending on what level the player is on, you can use <strong class="source-inline">stop()</strong> to stop the tween initially and then use <strong class="source-inline">play()</strong> to start it once you’ve set up which property you want to affect. By using <strong class="source-inline">set_loops()</strong>, you’re telling the tween to repeat the two moves endlessly, moving back <span class="No-Break">and forth.</span></p>
			<p>Now the ring is ready to move, your chunk can set these values when it spawns the ring. Go to <strong class="source-inline">chunk.gd</strong> and update the section that spawns rings to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">level</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func add_rings():
    for z in range(0, -200, -10):
        var n = randf()
        if n &gt; 0.76:
            var nr = ring.instantiate()
            nr.position.z = z
            nr.position.y = randf_range(3, 17)
            match level:
                0: pass
                1:
                    nr.move_y = true
                2:
                    nr.position.x = randf_range(-10, 10)
                    nr.move_y = true
                3:
                    nr.position.x = randf_range(-10, 10)
                    nr.move_x = true
            add_child(nr)</pre>
			<p>As you <a id="_idIndexMarker504"/>can see, once the level reaches <strong class="source-inline">1</strong>, the rings will start moving up and down. At level <strong class="source-inline">2</strong>, they’ll start to have a random <em class="italic">x</em> position, and at level <strong class="source-inline">3</strong>, they’ll start <span class="No-Break">moving horizontally.</span></p>
			<p>You should consider this an example of what’s possible. Feel free to create your own pattern of <span class="No-Break">increasing difficulty.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Collisions</h2>
			<p>The next <a id="_idIndexMarker505"/>step is to make the plane explode if it runs into anything, such as the ground or the buildings. If it does, you’ll play an explosion animation, and that’s the end of <span class="No-Break">the game.</span></p>
			<h3>Explosion</h3>
			<p>Go to your <strong class="source-inline">Plane</strong> scene and add an <strong class="source-inline">AnimatedSprite3D</strong> child. Name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">Explosion</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">AnimatedSprite3D</strong> node works<a id="_idIndexMarker506"/> very much like the 2D version you used earlier in the book. Add a new <strong class="source-inline">SpriteFrames</strong> resource in the <strong class="bold">Frames</strong> property, and click it to open the <strong class="bold">SpriteFrames</strong> panel at the bottom of the screen. Drag the five images from <strong class="source-inline">res://assets/smoke/</strong> into the <strong class="bold">Animation Frames</strong> box, set <strong class="bold">Speed</strong> to <strong class="source-inline">10</strong> FPS, and turn <span class="No-Break">off </span><span class="No-Break"><strong class="bold">Loop</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/B19289_06_14.jpg" alt="Figure 6.13: Explosion sprite frames"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13: Explosion sprite frames</p>
			<p>You may notice that you can’t see the sprite in the viewport. When displaying a 2D image, which is drawn in pixels, in 3D, the engine needs to know how big a pixel is in 3D space. To size the explosion to match the size of the plane, set <strong class="bold">Pixel Size</strong> to <strong class="source-inline">0.5</strong> in Inspector. Under <strong class="bold">Flags</strong>, set <strong class="bold">Billboard</strong> to enabled. This ensures that the sprite always faces the camera. You should now see a large cloud (the first frame of the animation) superimposed on <span class="No-Break">your plane.</span></p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/B19289_06_15.jpg" alt="Figure 6.14: Explosion sprite"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14: Explosion sprite</p>
			<p>You don’t want to see the explosion, so click the eye icon to <span class="No-Break">hide </span><span class="No-Break"><strong class="source-inline">Explosion</strong></span><span class="No-Break">.</span></p>
			<h3>Scripting the collisions</h3>
			<p>Add a <a id="_idIndexMarker507"/>new signal at the top of <strong class="source-inline">plane.gd</strong>, which will notify the game that the player <span class="No-Break">has crashed:</span></p>
			<pre class="source-code">
signal dead</pre>
			<p>In <strong class="source-inline">_physics_process()</strong>, you’re using <strong class="source-inline">move_and_slide()</strong> to move the plane. Whenever a <strong class="source-inline">CharacterBody3D</strong> node is moved with this method, it can check for <strong class="bold">slide collisions</strong>. Since<a id="_idIndexMarker508"/> it doesn’t matter <em class="italic">what</em> the plane collided with, only that there <em class="italic">was</em> a collision, add this just <span class="No-Break">after </span><span class="No-Break"><strong class="source-inline">move_and_slide()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if get_slide_collision_count() &gt; 0:
    die()</pre>
			<p>You can then define the <strong class="source-inline">die()</strong> function to handle what should happen when the plane crashes. First, it will stop moving forward. Then, you can hide the plane and show the explosion, playing the animation. Once the animation has ended, you can reset the game. Since you haven’t made the title screen yet, you can just restart <span class="No-Break">for now:</span></p>
			<pre class="source-code">
func die():
    set_physics_process(false)
    $cartoon_plane.hide()
    $Explosion.show()
    $Explosion.play("default")
    await $Explosion.animation_finished
    $Explosion.hide()
    dead.emit()
    get_tree().reload_current_scene()</pre>
			<p>You’ll remove that last line later once the rest of the game has been <span class="No-Break">set up.</span></p>
			<p>Play the <strong class="source-inline">Main</strong> scene now and try running into something to verify that the explosion plays and the <span class="No-Break">scene restarts.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Fuel and score</h2>
			<p>The <a id="_idIndexMarker509"/>next step is to keep track of the score earned when collecting the rings. You’ll also add a fuel component to the plane. This value will steadily decrease, and the game will end if the fuel runs out. The player gets fuel back based on collecting <span class="No-Break">the rings.</span></p>
			<p>Add two new signals at the top <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">plane.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
signal score_changed
signal fuel_changed</pre>
			<p>These will notify the UI to display the score and <span class="No-Break">fuel values.</span></p>
			<p>Then, add these <span class="No-Break">new variables:</span></p>
			<pre class="source-code">
@export var fuel_burn = 1.0
var max_fuel = 10.0
var fuel = 10.0:
    set = set_fuel
var score = 0:
    set = set_score</pre>
			<p>The setter<a id="_idIndexMarker510"/> functions for these variables will update them and emit <span class="No-Break">the signals:</span></p>
			<pre class="source-code">
func set_fuel(value):
    fuel = min(value, max_fuel)
    fuel_changed.emit(fuel)
    if fuel &lt;= 0:
        die()
func set_score(value):
    score = value
    score_changed.emit(score)</pre>
			<p>To reduce the fuel over time, add this line <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">_physics_process()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
fuel -= fuel_burn * delta</pre>
			<p>Try playing the main scene and you’ll see that you run out of fuel and explode after about <span class="No-Break">10 seconds.</span></p>
			<p>Now, you can make the rings update the score and give some fuel back based on how close the player was to the center of the ring. You’re already setting the ring’s label, and you can do the<a id="_idIndexMarker511"/> rest in the same section <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ring.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if d &lt; 2.0:
    $Label3D.text = "200"
    $Label3D.modulate = Color(1, 1, 0)
    body.fuel = 10
    body.score += 200
elif d &gt; 3.5:
    $Label3D.text = "50"
    body.fuel += 1
    body.score += 50
else:
    $Label3D.text = "100"
    body.fuel += 2.5
    body.score += 100</pre>
			<p>If you test again, you should be able to fly longer as long as you keep collecting rings. It’s hard to tell how much fuel you have left, though, so you should add a UI overlay that displays the fuel and <span class="No-Break">the score.</span></p>
			<h3>UI</h3>
			<p>Create a <a id="_idIndexMarker512"/>new scene with a <strong class="source-inline">CanvasLayer</strong> layer called “UI”. Add two children: <strong class="source-inline">TextureProgressBar</strong> (<strong class="source-inline">FuelBar</strong>) and <span class="No-Break"><strong class="source-inline">Label</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">Score</strong></span><span class="No-Break">).</span></p>
			<p>Set the text in the <strong class="source-inline">Score</strong> box <strong class="bold">Text</strong> property to <strong class="source-inline">0</strong> and add the font as you’ve done before, setting its <strong class="bold">Size</strong> to <strong class="source-inline">48</strong>. Use the toolbar menu to set the layout to <span class="No-Break"><strong class="bold">Top Right</strong></span><span class="No-Break">.</span></p>
			<p>For <strong class="source-inline">FuelBar</strong>, you have two textures in the <strong class="source-inline">assets</strong> folder. You can use <strong class="source-inline">bar_red.png</strong> for the <strong class="bold">Progress</strong> texture and <strong class="source-inline">bar_glass.png</strong> for the <strong class="bold">Over</strong> texture. Under <strong class="bold">Range</strong>, set <strong class="bold">Max Value</strong> to <strong class="source-inline">10</strong> and <strong class="bold">Step</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0.01</strong></span><span class="No-Break">.</span></p>
			<p>You can position the bar in the bottom left, but if you want to resize it, you’ll need to change a few more settings. Check the box labeled <strong class="bold">Nine Patch Stretch</strong> in Inspector. You can then resize the bar by dragging its bounding box. However, you’ll notice that the outline becomes very distorted – scale it very large to see the effect. To prevent this, keeping the <a id="_idIndexMarker513"/>borders unsized while stretching the interior, is what <strong class="bold">nine patch stretch</strong> does. Under <strong class="bold">Stretch Margin</strong>, set all four values to <strong class="source-inline">6</strong>. You’ll see that now, no matter how you resize the bar, the borders <span class="No-Break">remain unstretched:</span></p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/B19289_06_16.jpg" alt="Figure 6.15: Nine patch stretch settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15: Nine patch stretch settings</p>
			<p>Make the bar a comfortable size and then add a script <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">UI</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
extends CanvasLayer
func update_fuel(value):
    $FuelBar.value = value
func update_score(value):
    $Score.text = str(value)</pre>
			<p>Add an instance<a id="_idIndexMarker514"/> of the UI scene to <strong class="source-inline">Main</strong>. Connect the plane’s <strong class="source-inline">score_changed</strong> signal and the <strong class="source-inline">fuel_changed</strong> signal to the functions you just made on <span class="No-Break">the UI:</span></p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/B19289_06_17.jpg" alt="Figure 6.16: Connecting the plane’s signal to the UI"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16: Connecting the plane’s signal to the UI</p>
			<p>Play the scene once again and verify that the bar shows the fuel changing and that the score updates correctly when rings <span class="No-Break">are collected.</span></p>
			<p>You are almost done! You have a mostly working game at this point. Take a moment to play it a few times to make sure you’re not missing any of the interactions. Are the chunks increasing in difficulty as you fly farther? You should see moving rings and then rings that spawn to the left and right of the center. Make sure to review the previous sections if there’s anything you are unclear about. When you’re ready, move on to making the <span class="No-Break">title screen.</span></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor200"/>Title screen</h1>
			<p>The <a id="_idIndexMarker515"/>purpose of the title screen is to introduce the game and give a way to start it by pressing a button. This section will not go into much detail on the styling – you should experiment with the settings and try to make it <span class="No-Break">look pleasing.</span></p>
			<p>Start your <strong class="source-inline">TitleScreen</strong> scene with a <strong class="source-inline">Control</strong> node and add a <strong class="source-inline">Label</strong> and a <strong class="source-inline">TextureButton</strong> plus a <strong class="source-inline">TextureRect</strong> for <span class="No-Break">the background.</span></p>
			<p>You can use <strong class="source-inline">styled_sky.hdr</strong> for the <strong class="source-inline">TextureRect</strong>’s <strong class="bold">Texture</strong> property. It’s a lot bigger than the screen size, so feel free to scale and/or position it as <span class="No-Break">you like.</span></p>
			<p>For <strong class="source-inline">TextureButton</strong>, there are<a id="_idIndexMarker516"/> three images in the <strong class="source-inline">res://assets/buttons/</strong> folder for the <strong class="bold">Normal</strong>, <strong class="bold">Pressed</strong>, and <strong class="bold">Hover</strong> textures. The images are quite large to allow for sizing, so you can check <strong class="bold">Ignore Texture Size</strong> and set <strong class="bold">Stretch Mode</strong> to <strong class="bold">Keep Aspect</strong> to allow you to <span class="No-Break">resize it.</span></p>
			<p>The <strong class="source-inline">Label</strong> node is there to display the game’s title. Set up the font with large font size, such as <strong class="source-inline">128</strong>. Arrange <strong class="source-inline">Label</strong> and <strong class="source-inline">TextureButton</strong> on the screen. Set both of their layouts to <strong class="bold">Center</strong> and then move them up and down to <span class="No-Break">position them.</span></p>
			<p>The only code needed is to determine what to do when the button is pressed, so add a script to the scene and connect the button’s <strong class="source-inline">pressed</strong> signal. When the button is pressed, it should load the <span class="No-Break">main scene:</span></p>
			<pre class="source-code">
extends Control
func _on_texture_button_pressed():
    get_tree().change_scene_to_file("res://main.tscn")</pre>
			<p>To return to the title screen at the end of the game, remove <strong class="source-inline">get_tree().reload_current_scene()</strong> from the plane’s <strong class="source-inline">die()</strong> function, and then go to the <strong class="source-inline">Main</strong> scene and connect the plane instance’s <span class="No-Break"><strong class="source-inline">dead</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
var title_screen = "res://title_screen.tscn"
func _on_plane_dead():
    get_tree(). change_scene_to_file(title_screen)</pre>
			<p>Now when you crash, you should immediately return to the title screen, where you can press <span class="No-Break"><strong class="bold">Play</strong></span><span class="No-Break"> again.</span></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor201"/>Audio</h1>
			<p>There <a id="_idIndexMarker517"/>are two sound effect files located in the <strong class="source-inline">assets</strong> folder: <strong class="source-inline">impact.wav</strong> for the plane’s explosion and <strong class="source-inline">three_tone.wav</strong> for the ring collection sound. You can add <strong class="source-inline">AudioStreamPlayer</strong> nodes to the <strong class="source-inline">Plane</strong> and <strong class="source-inline">Ring</strong> scenes to play them at the <span class="No-Break">appropriate time.</span></p>
			<p>For the background music, which should be played in a loop during the game, add <strong class="source-inline">AudioStreamPlayer</strong> to the <strong class="source-inline">Main</strong> scene, using <strong class="source-inline">Riverside Ride Short Loop.wav</strong> for <strong class="bold">Stream</strong>. Since it needs to play automatically at the start, you can check the <span class="No-Break"><strong class="bold">Autoplay</strong></span><span class="No-Break"> box.</span></p>
			<p>The audio for this game is intentionally kept simple and upbeat. While there’s a sound effect for each major game event (flying through a ring, crashing), you could also try adding additional sounds for the airplane engine, bonuses, or a warning when fuel is low. Experiment to see what works <span class="No-Break">for you.</span></p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor202"/>Saving a high score</h1>
			<p>Saving<a id="_idIndexMarker518"/> the player’s high score is another common feature in many games (and one that you can add to the other games in this book as well). Since the score needs to be saved between sessions of the game, you’ll need to save it in an external file that the game can read the next time you <span class="No-Break">open it.</span></p>
			<p>Here’s <span class="No-Break">the process:</span></p>
			<ol>
				<li>When the game launches, check for a <span class="No-Break">save file.</span></li>
				<li>If the save file exists, load the score from it, otherwise <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>
				<li>When a game ends, check if the score is higher than the current high score. If it is, save it to <span class="No-Break">the file.</span></li>
				<li>Show the high score on the <span class="No-Break">title screen.</span></li>
			</ol>
			<p>Since you’ll need to access the high score variable from different parts of your game, it makes sense to use an autoload. In the <strong class="bold">Script</strong> editor, click <strong class="bold">File</strong> -&gt; <strong class="bold">New Script</strong> and name it <strong class="source-inline">global.gd</strong>. To begin, you’ll need <span class="No-Break">two variables:</span></p>
			<pre class="source-code">
extends Node
var high_score = 0
var score_file = "user://hs.dat"</pre>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>About file locations</h2>
			<p>You’ll <a id="_idIndexMarker519"/>notice that the path for the save file doesn’t begin with <strong class="source-inline">res://</strong> like all of the other files you’ve been working with. The <strong class="source-inline">res://</strong> designation represents your game’s project folder – the place where all the scripts, scenes, and assets are located. When you export your game, though, that folder becomes read-only. To store persistent data, you use a location on the device that’s set aside for the game to write to: <strong class="source-inline">user://</strong>. Where this folder is actually located depends on the operating system you’re using. For example, in Windows, it would be <strong class="source-inline">%APPDATA%\Godot\app_userdata\[project_name]</strong>. You can find the paths for other supported operating <span class="No-Break">systems here:</span></p>
			<p><span class="No-Break">https://docs.godotengine.org/en/stable/tutorials/io/data_paths.html</span></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>Accessing files</h2>
			<p>Accessing files<a id="_idIndexMarker520"/> in Godot is done via the <strong class="source-inline">FileAccess</strong> object. This object handles opening, reading, and writing files. Add these functions <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">global.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func _ready():
    load_score()
func load_score():
    if FileAccess.file_exists(score_file):
        var file = FileAccess.open(score_file,
            FileAccess.READ)
        high_score = file.get_var()
    else:
        high_score = 0
func save_score():
    var file = FileAccess.open(score_file, FileAccess.WRITE)
    file.store_var(high_score)</pre>
			<p>As you <a id="_idIndexMarker521"/>can see, the script calls <strong class="source-inline">load_score()</strong> in <strong class="source-inline">_ready()</strong>, so it’s done immediately when the game is launched. The <strong class="source-inline">load_score()</strong> function uses <strong class="source-inline">FileAccess</strong> to check if the save file exists, and if it does, it opens it and retrieves the data that was stored in it <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">get_var()</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">save_score()</strong> function does the opposite. Note that you don’t have to check if the file exists – if you try to write to a file that doesn’t exist, it will <span class="No-Break">be created.</span></p>
			<p>Save this script and add it as an autoload in <span class="No-Break"><strong class="bold">Project Settings</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/B19289_06_18.jpg" alt="Figure 6.17: Adding a global script"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17: Adding a global script</p>
			<p>Go to your <strong class="source-inline">Title</strong> scene and add another <strong class="source-inline">Label</strong> node to display the high score. Set its font and arrange it on the screen – the bottom middle might be a good choice. Add this to the script, so that the score will be displayed whenever the title <span class="No-Break">screen loads:</span></p>
			<pre class="source-code">
func _ready():
    $Label2.text = "High Score: " + str(Global.high_score)</pre>
			<p>Finally, at the end of the game, you’ll need to check if there’s a new high score. The <strong class="source-inline">score</strong> variable is kept on the plane, so open <strong class="source-inline">plane.gd</strong> and find the <strong class="source-inline">die()</strong> function, which is called when the game ends. Add a score check and call <strong class="source-inline">save_score()</strong> <span class="No-Break">if needed:</span></p>
			<pre class="source-code">
if score &gt; Global.high_score:
    Global.high_score = score
    Global.save_score()</pre>
			<p>Run the game<a id="_idIndexMarker522"/> to test that the high score is being displayed, saved, and loaded again when you run the game the <span class="No-Break">next time.</span></p>
			<p>This technique can be used for any type of data that you want to save between runs of your game. It’s a useful technique, so be sure to try it out with your own projects in the future. Reusing code is a great way to accelerate development, so once you’ve got a save system that you’re happy with, stick <span class="No-Break">with it!</span></p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor205"/>Suggestions for additional features</h1>
			<p>For an <a id="_idIndexMarker523"/>additional challenge, try to expand the game by adding more features. Here are some suggestions to get <span class="No-Break">you started:</span></p>
			<ul>
				<li>Track the distance the player flies in each game, and save the maximum value as a <span class="No-Break">high score.</span></li>
				<li>Increase the speed incrementally as time goes on or include boost items that increase the <span class="No-Break">plane’s speed.</span></li>
				<li>Flying obstacles that need to be dodged, such as other planes <span class="No-Break">or birds.</span></li>
				<li>(Advanced) Instead of only straight lines, add curved chunks as well. The player will have to steer and the camera will have to move to stay <span class="No-Break">behind them.</span></li>
			</ul>
			<p>This would also be a great game for you to experiment with building a game for a mobile platform. See the next chapter for information about <span class="No-Break">exporting games.</span></p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Summary</h1>
			<p>In this chapter, you extended your 3D skills by learning about more of Godot’s 3D nodes, such as the <strong class="source-inline">CharacterBody3D</strong>. You should have a good understanding of the 3D transform and how it works to move and rotate an object in space. Randomly generating chunks, while relatively simple in this game, is something that you can extend to much larger games and more <span class="No-Break">complex environments.</span></p>
			<p>Congratulations, you’ve made it to the end of the last project! But with these five games, your journey to becoming a game developer has <span class="No-Break">just begun.</span></p>
			<p>In the next chapter, you can read about some other topics that didn’t quite fit into the example games, as well as find some pointers for where to go next in building your game <span class="No-Break">development skills.</span></p>
		</div>
	</body></html>