<html><head></head><body>
		<div><h1 id="_idParaDest-185" class="chapter-number"><a id="_idTextAnchor184"/>6</h1>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Infinite Flyer</h1>
			<p>In this chapter, you’ll build a 3D infinite runner (or more accurately, infinite <em class="italic">flyer</em>) in the vein of <em class="italic">Temple Run</em> or <em class="italic">Subway Surfers</em>. The player’s goal is to fly as far as possible, passing through floating rings to collect points, while avoiding obstacles. By building this game, you’ll get a feel for<a id="_idIndexMarker461"/> how to make 3D objects interact and how to generate a 3D world automatically, rather than building it piece-by-piece as you did in earlier games such as <em class="italic">Minigolf</em> or <em class="italic">Jungle Jump</em>.</p>
			<p>Here are some of the new things you’ll learn in this chapter:</p>
			<ul>
				<li>Using transforms to rotate and move in 3D space</li>
				<li>Load and unload “chunks” of your game world</li>
				<li>How to randomly generate the game environment and game objects</li>
				<li>Saving and loading files for persistent data storage</li>
				<li>Using <code>CharacterBody3D</code> and detecting collisions</li>
			</ul>
			<p>When completed, the game will look like this:</p>
			<div><div><img src="img/B19289_06_01.jpg" alt="Figure 6.1: Finished game screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: Finished game screenshot</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Technical requirements</h1>
			<p>Download the game assets from the following link and unzip them into your new project folder:</p>
			<p><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads</a></p>
			<p>You can also find the complete code for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter06%20-%20Infinite%20Flyer">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter06%20-%20Infinite%20Flyer</a></p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor187"/>Project setup</h1>
			<p>Create a <a id="_idIndexMarker462"/>new project in Godot to get started. As you’ve done before, download the project assets and unzip them in the new project folder. Once you’ve created the project, you’ll start by configuring the inputs and Godot settings needed for the game.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>Inputs</h2>
			<p>You’ll control <a id="_idIndexMarker463"/>the plane with up, down, left, and right inputs. You can add them in <code>pitch_up</code>, <code>pitch_down</code>, <code>roll_left</code>, and <code>roll_right</code>. You can add the arrow keys and/or the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys to these, but if you have a game controller, you can also use a joystick for more precise control. To add joystick inputs, you can select <strong class="bold">Joypad Axes</strong> after pressing the <strong class="bold">+</strong> button. The values are labeled, such as <strong class="bold">Left Stick Up</strong>, so you can easily keep track of them:</p>
			<div><div><img src="img/B19289_06_02.jpg" alt="Figure 6.2: Input configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: Input configuration</p>
			<p>The <a id="_idIndexMarker464"/>nice part about this setup is that your code won’t have to be any different for the different types of input. By using <code>Input.get_axis()</code> and passing in the four input events, you’ll get a result whether the player pressed a key or moved the stick. Pressing the keys is equivalent to pushing the stick all the way in one direction.</p>
			<p>Now that the project is set up, you can start making your game objects, starting with the player-controlled airplane.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor189"/>Airplane scene</h1>
			<p>In this <a id="_idIndexMarker465"/>section, you’ll create the airplane that the player will control. It <a id="_idIndexMarker466"/>will fly forward while the player can move it up, down, left, and right.</p>
			<p>Start your new plane scene with a <code>CharacterBody3D</code> node named <code>Plane</code> and save it.</p>
			<p>You can find the 3D model for the airplane in the <code>assets</code> folder, named <code>cartoon_plane.glb</code>. The name indicates the model is stored as a <em class="italic">binary</em> <code>.gltf</code> file (exported from Blender). Godot imports <code>.gltf</code> files as scenes containing meshes, animations, materials, and <a id="_idIndexMarker467"/>other objects that may have been exported in the file. Click the <code>Node3D</code>, but it’s facing the wrong direction. Select it and set the <code>180</code> in the Inspector feature, so that it points along the <em class="italic">z</em> axis, which is Godot’s “forward” direction. Note that typing the value directly is easier than trying to rotate the <a id="_idIndexMarker468"/>node exactly using the mouse.</p>
			<p class="callout-heading">Model orientation</p>
			<p class="callout">As mentioned in the previous chapter, the various 3D design programs use different axis orientations. It’s very common to import your model and have its forward direction not match Godot’s. If you’re making the model yourself, you can correct this when you export it, but when you’re using a model made by someone else, it’s common to need to reorient it in Godot.</p>
			<p>If you right-click on the <code>cartoon_plane</code> node and choose <code>AnimationPlayer</code>:</p>
			<div><div><img src="img/B19289_06_03.jpg" alt="Figure 6.3: Airplane meshes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: Airplane meshes</p>
			<p><code>AnimationPlayer</code> contains an animation for making the propeller spin, so select it and set the <code>prop_spin</code> animation for the <strong class="bold">Autoplay on </strong><strong class="bold">Load</strong> function:</p>
			<div><div><img src="img/B19289_06_04.jpg" alt="Figure 6.4: Autoplay animation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: Autoplay animation</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/>Collision shapes</h2>
			<p>Add a <code>CollisionShape3D</code> node to <code>Plane</code> and choose <code>90</code> to align it with the plane’s fuselage. You can do this with the gizmo (don’t forget to turn on snapping using the “Use Smart Snap” icon      to get it perfectly aligned) or by typing the value directly into Inspector.</p>
			<div><div><img src="img/B19289_06_05.jpg" alt=""/>
				</div>
			</div>
			<p>The wings also need to be covered, so add a second <code>CollisionShape3D</code> node. This time, use <code>BoxShape3D</code>. Size it to cover the wings:</p>
			<div><div><img src="img/B19289_06_06.jpg" alt="Figure 6.5: Airplane collision shapes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: Airplane collision shapes</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>Scripting the plane</h2>
			<p>You can <a id="_idIndexMarker470"/>begin with the airplane’s controls. There are two axes of movement: “pitch up” and “pitch down” will raise or lower the nose of the plane (rotating around its <em class="italic">x</em> axis), causing it to move up or down. The <code>roll_left</code> and <code>roll_right</code> functions will rotate the plane around its <em class="italic">z</em> axis, which causes it to go left or right.</p>
			<p>For either <a id="_idIndexMarker471"/>input, you’ll want smooth rotation, and when the player lets go of the button or returns the stick to the center, the plane should smoothly rotate back to its original position. You can do this by <strong class="bold">interpolating</strong> the<a id="_idIndexMarker472"/> rotation rather than setting it directly when rotating.</p>
			<p class="callout-heading">About interpolation</p>
			<p class="callout"><strong class="bold">Linear interpolation</strong>, typically <a id="_idIndexMarker473"/>abbreviated to <strong class="bold">lerp</strong>, is a term that you’ll encounter often in game development. It means to calculate an intermediate value between two given values, using a straight-line function. In practice, it can be used to smoothly change a value from one value to another over time.</p>
			<p>To begin, attach a script to the <code>Plane</code> node and define some variables:</p>
			<pre class="source-code">
extends CharacterBody3D
@export var pitch_speed = 1.1
@export var roll_speed = 2.5
@export var level_speed = 4.0
var roll_input = 0
var pitch_input = 0</pre>
			<p>The exported variables let you set the speed of the plane’s rotation in either direction, as well as the speed of its automatic return to level flight.</p>
			<p>In your <code>get_input()</code> function, you’ll check the values of the inputs from <strong class="bold">Input Map</strong> to determine which way to rotate:</p>
			<pre class="source-code">
func get_input(delta):
    pitch_input = Input.get_axis("pitch_down", "pitch_up")
    roll_input = Input.get_axis("roll_left", "roll_right")</pre>
			<p>The <code>Input.get_axis()</code> function returns a value between <code>-1</code> and <code>1</code> based on the two inputs. When using keys, which can only be pressed or not pressed, that will mean you’ll only get <code>-1</code> when one key is pressed, <code>1</code> for the other, and <code>0</code> when neither or both are pressed. However, when using an analog input such as a joystick axis, you can get the full range of values. This allows more precise control, as tilting the joystick only slightly to the<a id="_idIndexMarker474"/> right will give a small <code>roll_input</code> value of <code>0.25</code>, for example.</p>
			<p>In <code>_physics_process()</code>, you can then rotate the plane on its <em class="italic">x</em> axis based on the pitch input:</p>
			<pre class="source-code">
func _physics_process(delta):
    get_input(delta)
    rotation.x = lerpf(rotation.x, pitch_input,
        pitch_speed * delta)
    rotation.x = clamp(rotation.x, deg_to_rad(-45),
        deg_to_rad(45))</pre>
			<p>It’s also important to use <code>clamp()</code> to limit the rotation so the plane doesn’t flip completely upside down.</p>
			<p>You can test this out by making a new test scene and adding the plane and <code>Camera3D</code>, like this:</p>
			<div><div><img src="img/B19289_06_07.jpg" alt="Figure 6.6: Test scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6: Test scene</p>
			<p>Position the camera behind the plane and run the scene to test that pressing the pitch up and pitch down inputs correctly tilts the plane up and down.</p>
			<p>For the roll, you could rotate the body in the <em class="italic">z</em> axis as well, but then the two rotations would add together, and you’d find it very difficult to get the plane back to level flight. Since for this game, you want the plane to continue going forward, it will be easier to rotate the <a id="_idIndexMarker475"/>child mesh instead. Add this line next in <code>_physics_process()</code>:</p>
			<pre class="source-code">
$cartoon_plane.rotation.z = lerpf($cartoon_plane.rotation.z, roll_input, roll_speed * delta)</pre>
			<p>Test it again in your test scene and make sure that the controls all work as expected.</p>
			<p>To finish up the movement, add two more variables at the top of the script. Your plane’s flying speed will be <code>forward_speed</code>. You’ll adjust this later to change the difficulty of the game. You can use <code>max_altitude</code> to keep the plane from climbing offscreen:</p>
			<pre class="source-code">
@export var forward_speed = 25
var max_altitude = 20</pre>
			<p>In <code>get_input()</code>, after checking the inputs, add this to cause the plane to level out if it reaches the maximum altitude:</p>
			<pre class="source-code">
if position.y &gt;= max_altitude and pitch_input &gt; 0:
    position.y = max_altitude
    pitch_input = 0</pre>
			<p>Then, add this to <code>_physics_process()</code> to handle the movement. The forward velocity will be the <code>forward_speed</code> amount:</p>
			<pre class="source-code">
velocity = -transform.basis.z * forward_speed</pre>
			<p>For the side-to-side movement (in the <em class="italic">x</em> direction), you can multiply by the amount of rotation to make it faster or slower depending on how much the plane has rolled. Then, scale the speed based on the forward speed (dividing by two to make it a little bit slower – experiment here to change the feel):</p>
			<pre class="source-code">
velocity += transform.basis.x * $cartoon_plane.rotation.z / deg_to_rad(45) * forward_speed / 2.0
move_and_slide()</pre>
			<p>Your plane should now be flying forward and the controls should be working as expected. Don’t <a id="_idIndexMarker476"/>move on to the next step until you’ve checked that the plane behaves correctly. In the next section, you will build the environment for the plane to fly around in.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/>Building the world</h1>
			<p>Because<a id="_idIndexMarker477"/> this is an <em class="italic">infinite</em>-style game, the player will continue to fly through the world as long as possible. That means you will need to continuously create more of the world for them to see – random buildings, items to collect, and so on. It would be impractical to create this all ahead of time both because you don’t know how far the player will go, and because you don’t want the game to be the same every time you play. It would also be inefficient to load a huge game world if the player isn’t going to see most of it.</p>
			<p>For that reason, it makes more sense to <a id="_idIndexMarker478"/>use a <strong class="bold">chunking</strong> strategy. You’ll randomly generate the world in smaller pieces, or chunks. You can then create these as they’re needed – as the player moves forward. You can also remove them once they’ve been passed when the game doesn’t need to keep track of them anymore.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>World objects</h2>
			<p>Each time<a id="_idIndexMarker479"/> you generate a new chunk of the world, it’s going to contain a number of different world objects. You can begin with two: buildings, which will be obstacles, and rings that the player tries to collect by flying through them.</p>
			<h3>Buildings</h3>
			<p>For the <a id="_idIndexMarker480"/>first building, start a new scene with a <code>StaticBody3D</code> node and name it <code>Building1</code>. Add a <code>MeshInstance3D</code> node and drag <code>res://assets/building_meshes/Build_01.obj</code> into the <code>.glTF</code> file, the building’s mesh is stored in the <em class="italic">OBJ</em> format. There is also a separate <code>.mtl</code> file that contains the mesh’s material – Godot hides it in the <strong class="bold">FileSystem</strong> panel, but it will be used for the texture in the mesh instance.</p>
			<p>You’ll <a id="_idIndexMarker481"/>notice that the building is centered on the origin. Since your buildings are going to be of different sizes, this will make it difficult to place them all on the ground – they’ll all have different offsets. If your buildings are all consistently offset ahead of time, then they can be more easily placed.</p>
			<p>To position the building mesh, change the <code>MeshInstance3D</code> node to <code>(0, 6, -8)</code>, which moves it up and places its edge on the origin. Add a collision shape by selecting the mesh and choosing <strong class="bold">Mesh</strong> -&gt; <strong class="bold">Create Trimesh </strong><strong class="bold">Collision Sibling</strong>.</p>
			<p>Save the scene in a new folder called <code>res://buildings/</code> and repeat the process with the other buildings, starting each scene with a <code>StaticBody3D</code> node, adding the mesh, offsetting it, and then creating the collision shape. Since each building is a different size, here are the offsets that will position them perfectly:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Building</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Offset</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>1</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>(0, </code><code>6, -8)</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>2</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>(0, </code><code>8, -4)</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>3</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>(0, </code><code>10, -6)</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>4</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>(0, </code><code>10, -6)</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>5</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>(0, </code><code>11, -4)</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>The chunk can now load and instance these buildings randomly to create a varied city skyline.</p>
			<h3>Rings</h3>
			<p>Rings <a id="_idIndexMarker482"/>will appear ahead of the player, and the plane needs to fly through them to score. If the plane is very close to the center of the ring, the player will get a score bonus. As the game progresses, the rings can become more difficult to catch – changing size, moving back and forth, and so on.</p>
			<p>Before starting, and without looking ahead, think about which type of node would be best for the ring object.</p>
			<p>Did you select <code>Area3D</code>? Since you want to detect when the plane flies through the ring, but not collide with it, an area’s <code>body_entered</code> detection will be the ideal solution.</p>
			<p>Start the<a id="_idIndexMarker483"/> new <code>Ring</code> scene with <code>Area3D</code> and add a <code>MeshInstance3D</code> child. For <code>TorusMesh</code>, and in the mesh properties, set <code>3.5</code> and <code>4</code>, so that you have a narrow ring.</p>
			<p>Add a <code>CollisionShape3D</code> node and choose <code>.5</code> and <code>3</code>.</p>
			<p>Later, you’ll want to animate the ring moving up and down. An easy way to do this will be to move the collision shape relative to the root node’s position. Since you’ll want the mesh to move as well, drag the mesh to make it a child of <code>CollisionShape3D</code>. Rotate the collision shape 90 degrees around <em class="italic">x</em> to make it stand up.</p>
			<p>A plain white ring is not very exciting, so you can add texture. In the <code>MeshInstance3D</code>, add <code>res://assets/textures/texture_09.png</code>. You’ll notice that the texture, which is a grid of alternating light and dark squares, looks very stretched around the torus. You can adjust how a texture is wrapped around the mesh by changing the <code>(12, 1, 1)</code> for a beginning value and adjust it to your liking. Under <strong class="bold">Shading</strong>, set <strong class="bold">Shading Mode</strong> to <strong class="bold">Unshaded</strong> – this will ensure that the ring ignores lighting and shadows, keeping it bright and visible at all times.</p>
			<p>Next, add a <code>Label3D</code> node to the <code>Ring</code> node. You’ll use this to show the player how many points they scored for the ring and whether or not they got the center bonus. Set the <code>100</code> so you can see something to test. Under <code>Baloo2-Medium.ttf</code> from the assets folder and set the font size to <code>720</code>. To make the text always face the camera, set <strong class="bold">Flags/Billboard</strong> to <strong class="bold">Enabled</strong>.</p>
			<p>Add a script to the ring and connect the <code>body_entered</code> signal. The <code>Label3D</code> function should be hidden at first, and the ring will be hidden when the plane touches it. There’s a problem, though: what if a ring spawns and overlaps a building? The <code>body_entered</code> signal will still be triggered, but you don’t want the building to collect the ring!</p>
			<p>You can solve this by setting collision layers. On the <code>Plane</code> scene, change its <code>2</code> (removing <code>1</code>), then come back to the <code>Ring</code> node and set its <code>2</code>. Now, you can be sure that if the ring sees a body enter, it <a id="_idIndexMarker484"/>can only be the plane:</p>
			<pre class="source-code">
extends Area3D
func _ready():
    $Label3D.hide()</pre>
			<p>After that, you need to find the distance from the plane to the center of the ring to see if the player scored the bonus and set the <code>text</code> property to the correct value. If the plane hits the ring directly in the center (closer than 2.0 units), you can also color the text yellow to indicate the perfect hit:</p>
			<pre class="source-code">
func _on_body_entered(body):
    $CollisionShape3D/MeshInstance3D.hide()
    var d = global_position.distance_to(body.global_position)
    if d &lt; 2.0:
        $Label3D.text = "200"
        $Label3D.modulate = Color(1, 1, 0)
    elif d &gt; 3.5:
        $Label3D.text = "50"
    else:
        $Label3D.text = "100"
    $Label3D.show()</pre>
			<p>Continuing the <code>_on_body_entered()</code> function, add some animation to the label to make it move and fade out:</p>
			<pre class="source-code">
var tween = create_tween().set_parallel()
tween.tween_property($Label3D, "position",
    Vector3(0, 10, 0), 1.0)
tween.tween_property($Label3D, "modulate:a", 0.0, 0.5)</pre>
			<p>Lastly, give <a id="_idIndexMarker485"/>the ring a nice rotation effect:</p>
			<pre class="source-code">
func _process(delta):
    $CollisionShape3D/MeshInstance3D.rotate_y(deg_to_rad(50) * delta)</pre>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>Chunks</h2>
			<p>Now that you’ve got the <a id="_idIndexMarker486"/>building blocks of your chunk, you can make the chunk scene itself. This is the scene that the game will instance whenever there needs to be more of the world ahead of the player. When you instantiate a new chunk, it will randomly place buildings along the left and right sides, as well as spawning rings at random points along its length.</p>
			<p>Start the <code>Chunk</code> scene with a <code>Node3D</code> node and a <code>MeshInstance3D</code> child named <code>Ground</code>. Make the <code>PlaneMesh</code> and set its <code>(50, 200)</code>. This is the size of a single chunk:</p>
			<div><div><img src="img/B19289_06_08.jpg" alt="Figure 6.7: Plane size settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7: Plane size settings</p>
			<p>Position it to start at the origin by setting its <code>-100</code>:</p>
			<div><div><img src="img/B19289_06_09.jpg" alt="Figure 6.8: Positioning the plane"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8: Positioning the plane</p>
			<p>Add<a id="_idIndexMarker487"/> material and use <code>texture_01.png</code> as the <code>(2, 10, 2)</code>. By default, Godot links the three scale values to keep them the same, so you’ll need to uncheck the link button to allow them to be different:</p>
			<div><div><img src="img/B19289_06_10.jpg" alt="Figure 6.9: Adjusting the UV scale"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9: Adjusting the UV scale</p>
			<p>Select the <code>Ground</code> node and choose <code>StaticBody3D</code> node and a <code>CollisionShape3D</code> node that matches the size of the ground.</p>
			<p>As the plane moves toward the end of the chunk, you’ll spawn a new chunk ahead, and you can also remove old chunks once they’ve passed by. To assist with the latter, add a <code>VisibleOnScreenNotifier3D</code> node and set its <code>0, 0, -250)</code>, which places it past the end of the ground plane.</p>
			<p>You can now add a script to the <code>Chunk</code> node and connect the notifier’s <code>screen_exited</code> signal so that the chunk will be removed:</p>
			<pre class="source-code">
func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()</pre>
			<p>At the top <a id="_idIndexMarker488"/>of the script, load the scenes that need to be instanced:</p>
			<pre class="source-code">
extends Node3D
var buildings = [
    preload("res://buildings/building_1.tscn"),
    preload("res://buildings/building_2.tscn"),
    preload("res://buildings/building_3.tscn"),
    preload("res://buildings/building_4.tscn"),
    preload("res://buildings/building_5.tscn"),
]
var ring = preload("res://ring.tscn")
var level = 0</pre>
			<p class="callout-heading">Loading many scenes</p>
			<p class="callout">In a bigger game, where you have a much larger number of buildings and possibly other scenes, you wouldn’t want to write them all out individually in the script as you’ve done here. Another solution would be to write code here that loads every scene file saved in a particular folder.</p>
			<p>The <code>level</code> variable can be set by the main scene when the chunk is loaded to allow increasing difficulty by spawning rings with different behaviors (more about that later).</p>
			<p>In <code>_ready()</code>, the chunk needs to do three things:</p>
			<ul>
				<li>Spawn buildings along the sides of the ground plane</li>
				<li>Occasionally spawn buildings in the middle to act as obstacles</li>
				<li>Spawn rings</li>
			</ul>
			<p>Each of<a id="_idIndexMarker489"/> these steps will involve some code, so you can keep it all organized by creating three separate functions:</p>
			<pre class="source-code">
func _ready():
    add_buildings()
    add_center_buildings()
    add_rings()</pre>
			<p>The first step is to spawn the side buildings. Since they need to be on both sides of the chunk, you repeat the loop twice – once for the positive <em class="italic">x</em> direction and once for the negative direction. Each time, you’ll move along the length of the chunk spawning random buildings:</p>
			<pre class="source-code">
func add_buildings():
    for side in [-1, 1]:
        var zpos = -10
        for i in 18:
            if randf() &gt; 0.75:
                zpos -= randi_range(5, 10)
                continue
            var nb = buildings[randi_range(0,
                buildings.size()-1)].instantiate()
            add_child(nb)
            nb.transform.origin.z = zpos
            nb.transform.origin.x = 20 * side
            zpos -= nb.get_node("MeshInstance3D").mesh.get_aabb().size.z</pre>
			<p>The <code>randf()</code> function is a common random function that returns a floating point number between <code>0</code> and <code>1</code>, making it easy to use to calculate percentages. Check here if the random number is greater than <code>0.75</code> to have a 25% chance of there being no building at a particular spot.</p>
			<p>By <a id="_idIndexMarker490"/>getting the size of the building mesh using <code>get_aabb()</code>, you can ensure that the buildings don’t overlap each other. The position of the next building will be exactly at the edge of the previous one.</p>
			<p>Next, spawning middle buildings won’t happen at the start, but later in the game, they’ll start appearing with a 20% probability:</p>
			<pre class="source-code">
func add_center_buildings():
    if level &gt; 0:
        for z in range(0, -200, -20):
            if randf() &gt; 0.8:
                var nb = buildings[0].instantiate()
                add_child(nb)
                nb.position.z = z
                nb.position.x += 8
                nb.rotation.y = PI / 2</pre>
			<p>The third step is spawning the rings. Right now, it just positions some rings at random fixed positions. Later, you’ll add some more variation here as the game progresses:</p>
			<pre class="source-code">
func add_rings():
    for z in range(0, -200, -10):
        if randf() &gt; 0.76:
            var nr = ring.instantiate()
            nr.position.z = z
            nr.position.y = randf_range(3, 17)
            add_child(nr)</pre>
			<p>You’re finished setting up the chunk. When it loads, it takes care of populating itself with a random <a id="_idIndexMarker491"/>assortment of buildings and rings, and it also removes itself when it later goes offscreen. In the next section, you’ll bring it all together in a scene that instantiates chunks as the plane moves forward.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor195"/>Main scene</h1>
			<p>In this <a id="_idIndexMarker492"/>section, you’ll make the main scene, which, in this<a id="_idIndexMarker493"/> game, will handle loading the world chunks, displaying the game information, and starting and ending the game.</p>
			<p>Start a new scene with a <code>Node3D</code> named <code>Main</code>. Add an instance of the <code>Plane</code> and an instance of the <code>Chunk</code> to start with.</p>
			<p>You’ll also need some lighting, so in the toolbar, choose the “Edit Sun and Environment settings” dropdown and add the sun and environment to the scene:</p>
			<div><div><img src="img/B19289_06_11.jpg" alt="Figure 6.10: Add environment and sun"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10: Add environment and sun</p>
			<p>Rather than use the generated sky texture, you can use <code>styled_sky.hdr</code> found in the assets folder. Select <code>WorldEnvironment</code> and then expand its <code>ProdeduralSkyMaterial</code>. Click the down arrow and choose <code>styled_sky.hdr</code>:</p>
			<div><div><img src="img/B19289_06_12.jpg" alt="Figure 6.11: WorldEnvironment sky settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11: WorldEnvironment sky settings</p>
			<p>Before <a id="_idIndexMarker494"/>you <a id="_idIndexMarker495"/>can test, you’ll also need a camera. Add a <code>Camera3D</code> and then add a script to it. Since it’s a standalone node without any children, you don’t need to make it a separate saved scene:</p>
			<pre class="source-code">
extends Camera3D
@export var target_path : NodePath
@export var offset = Vector3.ZERO
var target = null
func _ready():
    if target_path:
        target = get_node(target_path)
        position = target.position + offset
        look_at(target.position)
func _physics_process(_delta):
    if !target:
        return
    position = target.position + offset</pre>
			<p>This camera <a id="_idIndexMarker496"/>script is generic and could be used in other projects<a id="_idIndexMarker497"/> where you want a camera to follow a moving 3D object.</p>
			<p>Select the <code>Camera3D</code> node and in Inspector, click <code>Plane</code> node. Set <code>(7, 7, 15)</code>, which will keep the camera behind, above, and to the right of the plane.</p>
			<div><div><img src="img/B19289_06_13.jpg" alt="Figure 6.12: Camera follow settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12: Camera follow settings</p>
			<p>Play the <code>Main</code> scene and you should be able to fly along the chunk, collecting rings. If you run into the buildings, nothing will happen, and when you reach the end of the chunk, you won’t see another one.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Spawning new chunks</h2>
			<p>The<a id="_idIndexMarker498"/> length of each chunk is <code>200</code>, so when the plane has traveled half that distance, a new chunk should spawn ahead at the end position of the previous chunk. The <code>max_position</code> setting will keep track of the middle of the next chunk ahead, which is the position that the plane needs to reach to spawn a new chunk.</p>
			<p>You’ll also <a id="_idIndexMarker499"/>keep track of how many chunks have been spawned, so you can use that to determine when the game should get harder.</p>
			<p>Add a script to <code>Main</code> and add the following:</p>
			<pre class="source-code">
extends Node3D
var chunk = preload("res://chunk.tscn")
var num_chunks = 1
var chunk_size = 200
var max_position = -100</pre>
			<p>Remember that everything is moving forward in the <em class="italic">-z</em> direction, so the position at the center of the first chunk will have a <em class="italic">z</em> value of <code>-100</code>. The plane’s <em class="italic">z</em> coordinate will continue to decrease as it moves forward.</p>
			<p>In <code>_process()</code>, you’ll check the plane’s position, and if it goes past <code>max_position</code>, it’s time to instantiate a new chunk and update <code>max_position</code> to the center of the next chunk:</p>
			<pre class="source-code">
func _process(delta):
    if $Plane.position.z  &lt; max_position:
        num_chunks += 1
        var new_chunk = chunk.instantiate()
        new_chunk.position.z = max_position – chunk_size / 2
        new_chunk.level = num_chunks / 4
        add_child(new_chunk)
        max_position -= chunk_size</pre>
			<p>Here is where the chunk spawning happens. The new chunk gets placed at the end of the previous one. Remember that <code>max_position</code> is the center of the chunk, so you also need to add <code>chunk_size / </code><code>2</code>.</p>
			<p>Then, to get <a id="_idIndexMarker500"/>the level number, dividing by <code>4</code> results<a id="_idIndexMarker501"/> in <code>5</code>, <code>5/4</code> is just <code>1</code>. The level will reach <code>2</code> at chunk number <code>8</code>, <code>3</code> at chunk number <code>12</code>, and so on. This will give you a gradual increase in difficulty.</p>
			<p>Play the scene. You should now see the new chunks appearing ahead of the plane as it moves forward.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Increasing difficulty</h2>
			<p>Now that you’re spawning chunks, they’re being given a level value that gradually increases. You can <a id="_idIndexMarker502"/>use that to start making the rings more challenging to collect. For example, currently, they’re placed exactly in the center, so the player doesn’t need to steer left or right at all. You could start randomizing the <em class="italic">x</em> coordinate of the rings. You could also start making the rings move back and forth or up and down.</p>
			<p>Add these variables to the top of <code>ring.gd</code>:</p>
			<pre class="source-code">
var move_x = false
var move_y = false
var move_amount = 2.5
var move_speed = 2.0</pre>
			<p>The two Boolean variables will let you turn on movement in the <em class="italic">x</em> or <em class="italic">y</em> direction, and <code>move_amount</code> and <code>move_speed</code> will let you control how much movement you want.</p>
			<p>When those values are set, you can check <code>_ready()</code>, start the movement, then use a tween:</p>
			<pre class="source-code">
func _ready():
    $Label3D.hide()
    var tween = create_tween().set_loops()
        .set_trans(Tween.TRANS_SINE)
    tween.stop()
    if move_y:
        tween.tween_property($CollisionShape3D,
            "position:y", -move_amount, move_speed)
        tween.tween_property($CollisionShape3D,
            "position:y", move_amount, move_speed)
        tween.play()
    if move_x:
        tween.tween_property($CollisionShape3D,
            "position:x", -move_amount, move_speed)
        tween.tween_property($CollisionShape3D,
            "position:x", move_amount, move_speed)
        tween.play()</pre>
			<p>Note that<a id="_idIndexMarker503"/> by default, a tween starts playing automatically. Since you may or may not be actually animating a property, depending on what level the player is on, you can use <code>stop()</code> to stop the tween initially and then use <code>play()</code> to start it once you’ve set up which property you want to affect. By using <code>set_loops()</code>, you’re telling the tween to repeat the two moves endlessly, moving back and forth.</p>
			<p>Now the ring is ready to move, your chunk can set these values when it spawns the ring. Go to <code>chunk.gd</code> and update the section that spawns rings to use <code>level</code>:</p>
			<pre class="source-code">
func add_rings():
    for z in range(0, -200, -10):
        var n = randf()
        if n &gt; 0.76:
            var nr = ring.instantiate()
            nr.position.z = z
            nr.position.y = randf_range(3, 17)
            match level:
                0: pass
                1:
                    nr.move_y = true
                2:
                    nr.position.x = randf_range(-10, 10)
                    nr.move_y = true
                3:
                    nr.position.x = randf_range(-10, 10)
                    nr.move_x = true
            add_child(nr)</pre>
			<p>As you <a id="_idIndexMarker504"/>can see, once the level reaches <code>1</code>, the rings will start moving up and down. At level <code>2</code>, they’ll start to have a random <em class="italic">x</em> position, and at level <code>3</code>, they’ll start moving horizontally.</p>
			<p>You should consider this an example of what’s possible. Feel free to create your own pattern of increasing difficulty.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Collisions</h2>
			<p>The next <a id="_idIndexMarker505"/>step is to make the plane explode if it runs into anything, such as the ground or the buildings. If it does, you’ll play an explosion animation, and that’s the end of the game.</p>
			<h3>Explosion</h3>
			<p>Go to your <code>Plane</code> scene and add an <code>AnimatedSprite3D</code> child. Name it <code>Explosion</code>.</p>
			<p>The <code>AnimatedSprite3D</code> node works<a id="_idIndexMarker506"/> very much like the 2D version you used earlier in the book. Add a new <code>SpriteFrames</code> resource in the <code>res://assets/smoke/</code> into the <code>10</code> FPS, and turn off <strong class="bold">Loop</strong>:</p>
			<div><div><img src="img/B19289_06_14.jpg" alt="Figure 6.13: Explosion sprite frames"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13: Explosion sprite frames</p>
			<p>You may notice that you can’t see the sprite in the viewport. When displaying a 2D image, which is drawn in pixels, in 3D, the engine needs to know how big a pixel is in 3D space. To size the explosion to match the size of the plane, set <code>0.5</code> in Inspector. Under <strong class="bold">Flags</strong>, set <strong class="bold">Billboard</strong> to enabled. This ensures that the sprite always faces the camera. You should now see a large cloud (the first frame of the animation) superimposed on your plane.</p>
			<div><div><img src="img/B19289_06_15.jpg" alt="Figure 6.14: Explosion sprite"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14: Explosion sprite</p>
			<p>You don’t want to see the explosion, so click the eye icon to hide <code>Explosion</code>.</p>
			<h3>Scripting the collisions</h3>
			<p>Add a <a id="_idIndexMarker507"/>new signal at the top of <code>plane.gd</code>, which will notify the game that the player has crashed:</p>
			<pre class="source-code">
signal dead</pre>
			<p>In <code>_physics_process()</code>, you’re using <code>move_and_slide()</code> to move the plane. Whenever a <code>CharacterBody3D</code> node is moved with this method, it can check for <code>move_and_slide()</code>:</p>
			<pre class="source-code">
if get_slide_collision_count() &gt; 0:
    die()</pre>
			<p>You can then define the <code>die()</code> function to handle what should happen when the plane crashes. First, it will stop moving forward. Then, you can hide the plane and show the explosion, playing the animation. Once the animation has ended, you can reset the game. Since you haven’t made the title screen yet, you can just restart for now:</p>
			<pre class="source-code">
func die():
    set_physics_process(false)
    $cartoon_plane.hide()
    $Explosion.show()
    $Explosion.play("default")
    await $Explosion.animation_finished
    $Explosion.hide()
    dead.emit()
    get_tree().reload_current_scene()</pre>
			<p>You’ll remove that last line later once the rest of the game has been set up.</p>
			<p>Play the <code>Main</code> scene now and try running into something to verify that the explosion plays and the scene restarts.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Fuel and score</h2>
			<p>The <a id="_idIndexMarker509"/>next step is to keep track of the score earned when collecting the rings. You’ll also add a fuel component to the plane. This value will steadily decrease, and the game will end if the fuel runs out. The player gets fuel back based on collecting the rings.</p>
			<p>Add two new signals at the top of <code>plane.gd</code>:</p>
			<pre class="source-code">
signal score_changed
signal fuel_changed</pre>
			<p>These will notify the UI to display the score and fuel values.</p>
			<p>Then, add these new variables:</p>
			<pre class="source-code">
@export var fuel_burn = 1.0
var max_fuel = 10.0
var fuel = 10.0:
    set = set_fuel
var score = 0:
    set = set_score</pre>
			<p>The setter<a id="_idIndexMarker510"/> functions for these variables will update them and emit the signals:</p>
			<pre class="source-code">
func set_fuel(value):
    fuel = min(value, max_fuel)
    fuel_changed.emit(fuel)
    if fuel &lt;= 0:
        die()
func set_score(value):
    score = value
    score_changed.emit(score)</pre>
			<p>To reduce the fuel over time, add this line to <code>_physics_process()</code>:</p>
			<pre class="source-code">
fuel -= fuel_burn * delta</pre>
			<p>Try playing the main scene and you’ll see that you run out of fuel and explode after about 10 seconds.</p>
			<p>Now, you can make the rings update the score and give some fuel back based on how close the player was to the center of the ring. You’re already setting the ring’s label, and you can do the<a id="_idIndexMarker511"/> rest in the same section of <code>ring.gd</code>:</p>
			<pre class="source-code">
if d &lt; 2.0:
    $Label3D.text = "200"
    $Label3D.modulate = Color(1, 1, 0)
    body.fuel = 10
    body.score += 200
elif d &gt; 3.5:
    $Label3D.text = "50"
    body.fuel += 1
    body.score += 50
else:
    $Label3D.text = "100"
    body.fuel += 2.5
    body.score += 100</pre>
			<p>If you test again, you should be able to fly longer as long as you keep collecting rings. It’s hard to tell how much fuel you have left, though, so you should add a UI overlay that displays the fuel and the score.</p>
			<h3>UI</h3>
			<p>Create a <a id="_idIndexMarker512"/>new scene with a <code>CanvasLayer</code> layer called “UI”. Add two children: <code>TextureProgressBar</code> (<code>FuelBar</code>) and <code>Label</code> (<code>Score</code>).</p>
			<p>Set the text in the <code>Score</code> box <code>0</code> and add the font as you’ve done before, setting its <code>48</code>. Use the toolbar menu to set the layout to <strong class="bold">Top Right</strong>.</p>
			<p>For <code>FuelBar</code>, you have two textures in the <code>assets</code> folder. You can use <code>bar_red.png</code> for the <code>bar_glass.png</code> for the <code>10</code> and <code>0.01</code>.</p>
			<p>You can position the bar in the bottom left, but if you want to resize it, you’ll need to change a few more settings. Check the box labeled <code>6</code>. You’ll see that now, no matter how you resize the bar, the borders remain unstretched:</p>
			<div><div><img src="img/B19289_06_16.jpg" alt="Figure 6.15: Nine patch stretch settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15: Nine patch stretch settings</p>
			<p>Make the bar a comfortable size and then add a script to <code>UI</code>:</p>
			<pre class="source-code">
extends CanvasLayer
func update_fuel(value):
    $FuelBar.value = value
func update_score(value):
    $Score.text = str(value)</pre>
			<p>Add an instance<a id="_idIndexMarker514"/> of the UI scene to <code>Main</code>. Connect the plane’s <code>score_changed</code> signal and the <code>fuel_changed</code> signal to the functions you just made on the UI:</p>
			<div><div><img src="img/B19289_06_17.jpg" alt="Figure 6.16: Connecting the plane’s signal to the UI"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16: Connecting the plane’s signal to the UI</p>
			<p>Play the scene once again and verify that the bar shows the fuel changing and that the score updates correctly when rings are collected.</p>
			<p>You are almost done! You have a mostly working game at this point. Take a moment to play it a few times to make sure you’re not missing any of the interactions. Are the chunks increasing in difficulty as you fly farther? You should see moving rings and then rings that spawn to the left and right of the center. Make sure to review the previous sections if there’s anything you are unclear about. When you’re ready, move on to making the title screen.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor200"/>Title screen</h1>
			<p>The <a id="_idIndexMarker515"/>purpose of the title screen is to introduce the game and give a way to start it by pressing a button. This section will not go into much detail on the styling – you should experiment with the settings and try to make it look pleasing.</p>
			<p>Start your <code>TitleScreen</code> scene with a <code>Control</code> node and add a <code>Label</code> and a <code>TextureButton</code> plus a <code>TextureRect</code> for the background.</p>
			<p>You can use <code>styled_sky.hdr</code> for the <code>TextureRect</code>’s <strong class="bold">Texture</strong> property. It’s a lot bigger than the screen size, so feel free to scale and/or position it as you like.</p>
			<p>For <code>TextureButton</code>, there are<a id="_idIndexMarker516"/> three images in the <code>res://assets/buttons/</code> folder for the <strong class="bold">Normal</strong>, <strong class="bold">Pressed</strong>, and <strong class="bold">Hover</strong> textures. The images are quite large to allow for sizing, so you can check <strong class="bold">Ignore Texture Size</strong> and set <strong class="bold">Stretch Mode</strong> to <strong class="bold">Keep Aspect</strong> to allow you to resize it.</p>
			<p>The <code>Label</code> node is there to display the game’s title. Set up the font with large font size, such as <code>128</code>. Arrange <code>Label</code> and <code>TextureButton</code> on the screen. Set both of their layouts to <strong class="bold">Center</strong> and then move them up and down to position them.</p>
			<p>The only code needed is to determine what to do when the button is pressed, so add a script to the scene and connect the button’s <code>pressed</code> signal. When the button is pressed, it should load the main scene:</p>
			<pre class="source-code">
extends Control
func _on_texture_button_pressed():
    get_tree().change_scene_to_file("res://main.tscn")</pre>
			<p>To return to the title screen at the end of the game, remove <code>get_tree().reload_current_scene()</code> from the plane’s <code>die()</code> function, and then go to the <code>Main</code> scene and connect the plane instance’s <code>dead</code> signal:</p>
			<pre class="source-code">
var title_screen = "res://title_screen.tscn"
func _on_plane_dead():
    get_tree(). change_scene_to_file(title_screen)</pre>
			<p>Now when you crash, you should immediately return to the title screen, where you can press <strong class="bold">Play</strong> again.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor201"/>Audio</h1>
			<p>There <a id="_idIndexMarker517"/>are two sound effect files located in the <code>assets</code> folder: <code>impact.wav</code> for the plane’s explosion and <code>three_tone.wav</code> for the ring collection sound. You can add <code>AudioStreamPlayer</code> nodes to the <code>Plane</code> and <code>Ring</code> scenes to play them at the appropriate time.</p>
			<p>For the background music, which should be played in a loop during the game, add <code>AudioStreamPlayer</code> to the <code>Main</code> scene, using <code>Riverside Ride Short Loop.wav</code> for <strong class="bold">Stream</strong>. Since it needs to play automatically at the start, you can check the <strong class="bold">Autoplay</strong> box.</p>
			<p>The audio for this game is intentionally kept simple and upbeat. While there’s a sound effect for each major game event (flying through a ring, crashing), you could also try adding additional sounds for the airplane engine, bonuses, or a warning when fuel is low. Experiment to see what works for you.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor202"/>Saving a high score</h1>
			<p>Saving<a id="_idIndexMarker518"/> the player’s high score is another common feature in many games (and one that you can add to the other games in this book as well). Since the score needs to be saved between sessions of the game, you’ll need to save it in an external file that the game can read the next time you open it.</p>
			<p>Here’s the process:</p>
			<ol>
				<li>When the game launches, check for a save file.</li>
				<li>If the save file exists, load the score from it, otherwise use <code>0</code>.</li>
				<li>When a game ends, check if the score is higher than the current high score. If it is, save it to the file.</li>
				<li>Show the high score on the title screen.</li>
			</ol>
			<p>Since you’ll need to access the high score variable from different parts of your game, it makes sense to use an autoload. In the <code>global.gd</code>. To begin, you’ll need two variables:</p>
			<pre class="source-code">
extends Node
var high_score = 0
var score_file = "user://hs.dat"</pre>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>About file locations</h2>
			<p>You’ll <a id="_idIndexMarker519"/>notice that the path for the save file doesn’t begin with <code>res://</code> like all of the other files you’ve been working with. The <code>res://</code> designation represents your game’s project folder – the place where all the scripts, scenes, and assets are located. When you export your game, though, that folder becomes read-only. To store persistent data, you use a location on the device that’s set aside for the game to write to: <code>user://</code>. Where this folder is actually located depends on the operating system you’re using. For example, in Windows, it would be <code>%APPDATA%\Godot\app_userdata\[project_name]</code>. You can find the paths for other supported operating systems here:</p>
			<p>https://docs.godotengine.org/en/stable/tutorials/io/data_paths.html</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>Accessing files</h2>
			<p>Accessing files<a id="_idIndexMarker520"/> in Godot is done via the <code>FileAccess</code> object. This object handles opening, reading, and writing files. Add these functions to <code>global.gd</code>:</p>
			<pre class="source-code">
func _ready():
    load_score()
func load_score():
    if FileAccess.file_exists(score_file):
        var file = FileAccess.open(score_file,
            FileAccess.READ)
        high_score = file.get_var()
    else:
        high_score = 0
func save_score():
    var file = FileAccess.open(score_file, FileAccess.WRITE)
    file.store_var(high_score)</pre>
			<p>As you <a id="_idIndexMarker521"/>can see, the script calls <code>load_score()</code> in <code>_ready()</code>, so it’s done immediately when the game is launched. The <code>load_score()</code> function uses <code>FileAccess</code> to check if the save file exists, and if it does, it opens it and retrieves the data that was stored in it using <code>get_var()</code>.</p>
			<p>The <code>save_score()</code> function does the opposite. Note that you don’t have to check if the file exists – if you try to write to a file that doesn’t exist, it will be created.</p>
			<p>Save this script and add it as an autoload in <strong class="bold">Project Settings</strong>:</p>
			<div><div><img src="img/B19289_06_18.jpg" alt="Figure 6.17: Adding a global script"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17: Adding a global script</p>
			<p>Go to your <code>Title</code> scene and add another <code>Label</code> node to display the high score. Set its font and arrange it on the screen – the bottom middle might be a good choice. Add this to the script, so that the score will be displayed whenever the title screen loads:</p>
			<pre class="source-code">
func _ready():
    $Label2.text = "High Score: " + str(Global.high_score)</pre>
			<p>Finally, at the end of the game, you’ll need to check if there’s a new high score. The <code>score</code> variable is kept on the plane, so open <code>plane.gd</code> and find the <code>die()</code> function, which is called when the game ends. Add a score check and call <code>save_score()</code> if needed:</p>
			<pre class="source-code">
if score &gt; Global.high_score:
    Global.high_score = score
    Global.save_score()</pre>
			<p>Run the game<a id="_idIndexMarker522"/> to test that the high score is being displayed, saved, and loaded again when you run the game the next time.</p>
			<p>This technique can be used for any type of data that you want to save between runs of your game. It’s a useful technique, so be sure to try it out with your own projects in the future. Reusing code is a great way to accelerate development, so once you’ve got a save system that you’re happy with, stick with it!</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor205"/>Suggestions for additional features</h1>
			<p>For an <a id="_idIndexMarker523"/>additional challenge, try to expand the game by adding more features. Here are some suggestions to get you started:</p>
			<ul>
				<li>Track the distance the player flies in each game, and save the maximum value as a high score.</li>
				<li>Increase the speed incrementally as time goes on or include boost items that increase the plane’s speed.</li>
				<li>Flying obstacles that need to be dodged, such as other planes or birds.</li>
				<li>(Advanced) Instead of only straight lines, add curved chunks as well. The player will have to steer and the camera will have to move to stay behind them.</li>
			</ul>
			<p>This would also be a great game for you to experiment with building a game for a mobile platform. See the next chapter for information about exporting games.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Summary</h1>
			<p>In this chapter, you extended your 3D skills by learning about more of Godot’s 3D nodes, such as the <code>CharacterBody3D</code>. You should have a good understanding of the 3D transform and how it works to move and rotate an object in space. Randomly generating chunks, while relatively simple in this game, is something that you can extend to much larger games and more complex environments.</p>
			<p>Congratulations, you’ve made it to the end of the last project! But with these five games, your journey to becoming a game developer has just begun.</p>
			<p>In the next chapter, you can read about some other topics that didn’t quite fit into the example games, as well as find some pointers for where to go next in building your game development skills.</p>
		</div>
	</body></html>