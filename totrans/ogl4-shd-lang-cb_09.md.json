["```cpp\n#include <glm/gtc/noise.hpp> \n```", "```cpp\nGLubyte *data = new GLubyte[ width * height * 4 ]; \n\nfloat xFactor = 1.0f / (width - 1); \nfloat yFactor = 1.0f / (height - 1); \n\nfor( int row = 0; row < height; row++ ) { \n  for( int col = 0 ; col < width; col++ ) { \n    float x = xFactor * col; \n    float y = yFactor * row; \n    float sum = 0.0f; \n    float freq = a; \n    float scale = b; \n\n    // Compute the sum for each octave \n    for( int oct = 0; oct < 4; oct++ ) { \n      glm::vec2 p(x * freq, y * freq); \n      float val = glm::perlin(p) / scale; \n      sum += val; \n      float result = (sum + 1.0f)/ 2.0f; \n\n      // Store in texture buffer \n      data[((row * width + col) * 4) + oct] =  \n                   (GLubyte) ( result * 255.0f ); \n      freq *= 2.0f;   // Double the frequency \n      scale *= b;     // Next power of b \n    } \n  } \n} \n```", "```cpp\nGLuint texID; \nglGenTextures(1, &texID); \n\nglBindTexture(GL_TEXTURE_2D, texID); \nglTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, width, height); \nglTexSubImage2D(GL_TEXTURE_2D,0,0,0,width,height,\n   GL_RGBA,GL_UNSIGNED_BYTE,data); \n\ndelete [] data; \n```", "```cpp\nfloat val = glm::perlin(p) / scale; \n```", "```cpp\nfloat val = 0.0f; \nif( periodic ) { \n  val = glm::perlin(p, glm::vec2(freq)) / scale; \n} else { \n  val = glm::perlin(p) / scale; \n} \n```", "```cpp\n#define PI 3.14159265 \n\nlayout( binding=0 ) uniform sampler2D NoiseTex; \n\nuniform vec4 SkyColor = vec4( 0.3, 0.3, 0.9, 1.0 ); \nuniform vec4 CloudColor = vec4( 1.0, 1.0, 1.0, 1.0 ); \n\nin vec2 TexCoord; \n\nlayout ( location = 0 ) out vec4 FragColor; \n\nvoid main() {\n  vec4 noise = texture(NoiseTex, TexCoord); \n  float t = (cos( noise.g * PI ) + 1.0) / 2.0; \n  vec4 color = mix( SkyColor, CloudColor, t ); \n  FragColor = vec4( color.rgb , 1.0 ); \n} \n```", "```cpp\nfloat t = (cos( noise.g * PI ) + 1.0 ) / 2.0; \nt = clamp( t - 0.25, 0.0, 1.0 ); \n```", "```cpp\nlayout(binding=0) uniform sampler2D NoiseTex; \n\nuniform vec4 DarkWoodColor = vec4( 0.8, 0.5, 0.1, 1.0 ); \nuniform vec4 LightWoodColor = vec4( 1.0, 0.75, 0.25, 1.0 ); \nuniform mat4 Slice; \n\nin vec2 TexCoord; \n\nlayout ( location = 0 ) out vec4 FragColor; \n\nvoid main() {\n  // Transform the texture coordinates to define the \n  // \"slice\" of the log. \n  vec4 cyl = Slice * vec4( TexCoord.st, 0.0, 1.0 ); \n\n  // The distance from the log's y axis. \n  float dist = length(cyl.xz); \n\n  // Perturb the distance using the noise texture \n  vec4 noise = texture(NoiseTex, TexCoord); \n  dist += noise.b; \n\n  // Determine the color as a mixture of the light and  \n  // dark wood colors. \n  float t = 1.0 - abs( fract( dist ) * 2.0 - 1.0 ); \n  t = smoothstep( 0.2, 0.5, t ); \n  vec4 color = mix( DarkWoodColor, LightWoodColor, t ); \n\n  FragColor = vec4( color.rgb , 1.0 ); \n}\n```", "```cpp\ndist += noise.b; \n```", "```cpp\nvec2 tc = TexCoord; \nif( tc.s > 0.5 ) tc.s = 1.0 - tc.s; \nvec4 cyl = Slice * vec4( tc, 0.0, 1.0 ); \n```", "```cpp\n// Insert uniforms needed for the Phong shading model \n\nlayout(binding=0) uniform sampler2D NoiseTex; \n\nin vec4 Position; \nin vec3 Normal; \nin vec2 TexCoord; \n\nuniform float LowThreshold; \nuniform float HighThreshold; \n\nlayout ( location = 0 ) out vec4 FragColor; \n\nvec3 phongModel() { \n  // Compute Phong shading model... \n} \nvoid main() \n{ \n  // Get the noise value at TexCoord \n  vec4 noise = texture( NoiseTex, TexCoord ); \n\n  // If the value is outside the threshold, discard \n  if( noise.a < LowThreshold || noise.a > HighThreshold) \n    discard; \n\n  // Color the fragment using the shading model \n  vec3 color = phongModel(); \n  FragColor = vec4( color , 1.0 ); \n} \n```", "```cpp\n// Uniforms for the Phong shading model \n...\n\n// The noise texture \nlayout(binding=0) uniform sampler2D NoiseTex; \n// Input from the vertex shader \nin vec4 Position; \nin vec3 Normal; \nin vec2 TexCoord; \n\n// The paint-spatter uniforms \nuniform vec3 PaintColor = vec3(1.0); \nuniform float Threshold = 0.65; \n\nlayout ( location = 0 ) out vec4 FragColor; \n\nvec3 phongModel(vec3 kd) { \n  // Evaluate the Phong shading model \n} \n\nvoid main() { \n  vec4 noise = texture( NoiseTex, TexCoord ); \n  vec3 color = Material.Kd; \n  if( noise.g> Threshold ) color = PaintColor; \n  FragColor = vec4( phongModel(color) , 1.0 ); \n} \n```", "```cpp\nin vec3 ReflectDir;\nin vec2 TexCoord;\n\nuniform samplerCube CubeMapTex;\nuniform sampler2D NoiseTex;\n\nuniform float ReflectFactor;\nuniform vec4 MaterialColor;\n\nlayout( location = 0 ) out vec4 FragColor;\n\nuniform float Threshold = 0.58;\n\nvoid main() {\n    // Access the noise texture\n    float noise = texture( NoiseTex, TexCoord ).a;\n    float scale = floor( noise + (1 - Threshold) );\n\n    // Access the cube map texture\n    vec3 cubeMapColor = texture(CubeMapTex, ReflectDir).rgb;\n\n    // Gamma correct\n    cubeMapColor = pow(cubeMapColor, vec3(1.0/2.2));\n\n    vec3 rustColor = mix( MaterialColor.rgb, vec3(0.01), noise.a );\n\n    FragColor = vec4( mix( cubeMapColor, rustColor, scale), 1);\n}\n```", "```cpp\nin vec3 Position; \nin vec3 Normal; \nin vec2 TexCoord; \n\nuniform int Width; \nuniform int Height; \nuniform float Radius; \nlayout(binding=0) uniform sampler2D RenderTex; \nlayout(binding=1) uniform sampler2D NoiseTex; \n\nsubroutine vec4 RenderPassType(); \nsubroutine uniform RenderPassType RenderPass; \n\n// Define any uniforms needed for the shading model. \n\nlayout( location = 0 ) out vec4 FragColor; \n\nvec3 phongModel( vec3 pos, vec3 norm ) {\n  // Compute the Phong shading model \n} \n\n// Returns the relative luminance of the color value \nfloat luminance( vec3 color ) { \n  return dot( color.rgb, vec3(0.2126, 0.7152, 0.0722) ); \n} \n\nsubroutine (RenderPassType) \nvec4 pass1() {\n  return vec4(phongModel( Position, Normal ),1.0); \n} \n\nsubroutine( RenderPassType ) \nvec4 pass2() {\n  vec4 noise = texture(NoiseTex, TexCoord); \n  vec4 color = texture(RenderTex, TexCoord); \n  float green = luminance( color.rgb ); \n\n  float dist1 = length(gl_FragCoord.xy - \n       vec2(Width*0.25, Height*0.5));  \n       float dist2 = length(gl_FragCoord.xy - \n       vec2(3.0*Width*0.25, Height*0.5)); \n  if( dist1 > Radius && dist2 > Radius ) green = 0.0; \n\n  return vec4(0.0, green * clamp(noise.a + 0.25, 0.0, 1.0),\n       0.0 ,1.0); \n} \n\nvoid main() {\n  // This will call either pass1() or pass2() \n  FragColor = RenderPass(); \n} \n```"]