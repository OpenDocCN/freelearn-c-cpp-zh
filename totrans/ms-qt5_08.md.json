["```cpp\nTEMPLATE = subdirs \n\nCONFIG += c++14 \n\nOTHER_FILES += \\ \n            sdk/Filter.h \n\n```", "```cpp\n#include <QImage> \n\nclass Filter \n{ \npublic: \n    virtual ~Filter() {} \n    virtual QString name() const = 0; \n    virtual QImage process(const QImage& image) = 0; \n}; \n\n#define Filter_iid \"org.masteringqt.imageanimation.filters.Filter\" \nQ_DECLARE_INTERFACE(Filter, Filter_iid) \n\n```", "```cpp\n#define Filter_iid \"org.masteringqt.imageanimation.filters.Filter\" \nQ_DECLARE_INTERFACE(Filter, Filter_iid) \n\n```", "```cpp\nINCLUDEPATH += $$PWD/sdk \nDEPENDPATH += $$PWD/sdk \n\n```", "```cpp\nOTHER_FILES += \\ \n            sdk/Filter.h \\ \n            plugins-common.pri \n\n```", "```cpp\nQT       += core widgets \n\nTARGET = $$qtLibraryTarget(filter-plugin-original) \nTEMPLATE = lib \nCONFIG += plugin \n\nSOURCES += \\ \n    FilterOriginal.cpp \n\nHEADERS += \\ \n    FilterOriginal.h \n\ninclude(../plugins-common.pri) \n\n```", "```cpp\n#include <QObject> \n\n#include <Filter.h> \n\nclass FilterOriginal : public QObject, Filter \n{ \n    Q_OBJECT \n    Q_PLUGIN_METADATA(IID \"org.masteringqt.imageanimation.filters.Filter\") \n    Q_INTERFACES(Filter) \n\npublic: \n    FilterOriginal(QObject* parent = 0); \n    ~FilterOriginal(); \n\n    QString name() const override; \n    QImage process(const QImage& image) override; \n}; \n\n```", "```cpp\nFilterOriginal::FilterOriginal(QObject* parent) : \n    QObject(parent) \n{ \n} \n\nFilterOriginal::~FilterOriginal() \n{ \n} \n\nQString FilterOriginal::name() const \n{ \n    return \"Original\"; \n} \n\nQImage FilterOriginal::process(const QImage& image) \n{ \n    return image; \n} \n\n```", "```cpp\nOTHER_FILES += \\ \n            sdk/Filter.h \\ \n            plugins-common.pri \\ \n            plugins-common-opencv.pri \n\n```", "```cpp\nwindows { \n    INCLUDEPATH += $$(OPENCV_HOME)/../../include \n    LIBS += -L$$(OPENCV_HOME)/lib \\ \n        -lopencv_core2413 \\ \n        -lopencv_imgproc2413 \n} \n\nlinux { \n    CONFIG += link_pkgconfig \n    PKGCONFIG += opencv \n} \n\nmacx { \n    INCLUDEPATH += /usr/local/Cellar/opencv/2.4.13/include/ \n\n    LIBS += -L/usr/local/lib \\ \n        -lopencv_core \\ \n        -lopencv_imgproc \n} \n\n```", "```cpp\nQT       += core widgets \n\nTARGET = $$qtLibraryTarget(filter-plugin-grayscale) \nTEMPLATE = lib \nCONFIG += plugin \n\nSOURCES += \\ \n    FilterGrayscale.cpp \n\nHEADERS += \\ \n    FilterGrayscale.h \n\ninclude(../plugins-common.pri) \ninclude(../plugins-common-opencv.pri) \n\n```", "```cpp\n#include <opencv/cv.h> \n\n// Constructor & Destructor here \n... \n\nQString FilterOriginal::name() const \n{ \n    return \"Grayscale\"; \n} \n\nQImage FilterOriginal::process(const QImage& image) \n{ \n    // QImage => cv::mat \n    cv::Mat tmp(image.height(), \n                image.width(), \n                CV_8UC4, \n                (uchar*)image.bits(), \n                image.bytesPerLine()); \n\n    cv::Mat resultMat; \n    cv::cvtColor(tmp, resultMat, CV_BGR2GRAY); \n\n    // cv::mat => QImage \n    QImage resultImage((const uchar *) resultMat.data, \n                       resultMat.cols, \n                       resultMat.rows, \n                       resultMat.step, \n                       QImage::Format_Grayscale8); \n    return resultImage.copy(); \n} \n\n```", "```cpp\nQString FilterOriginal::name() const \n{ \n    return \"Blur\"; \n} \n\nQImage FilterOriginal::process(const QImage& image) \n{ \n    // QImage => cv::mat \n    cv::Mat tmp(image.height(), \n                image.width(), \n                CV_8UC4, \n                (uchar*)image.bits(), \n                image.bytesPerLine()); \n\n    int blur = 17; \n    cv::Mat resultMat; \n    cv::GaussianBlur(tmp, \n                     resultMat, \n                     cv::Size(blur, blur), \n                     0.0, \n                     0.0); \n\n    // cv::mat => QImage \n    QImage resultImage((const uchar *) resultMat.data, \n                       resultMat.cols, \n                       resultMat.rows, \n                       resultMat.step, \n                       QImage::Format_RGB32); \n    return resultImage.copy(); \n} \n\n```", "```cpp\nINCLUDEPATH += $$PWD/sdk \nDEPENDPATH += $$PWD/sdk \n\nwindows { \n    CONFIG(debug, debug|release) { \n        target_install_path = $$OUT_PWD/../image-animation/debug/plugins/ \n    } else { \n        target_install_path = $$OUT_PWD/../image-animation/release/plugins/ \n    } \n\n} else { \n    target_install_path = $$OUT_PWD/../image-animation/plugins/ \n} \n\n# Check Qt file 'spec_post.prf' for more information about '$$QMAKE_MKDIR_CMD' \ncreatePluginsDir.path = $$target_install_path \ncreatePluginsDir.commands = $$QMAKE_MKDIR_CMD $$createPluginsDir.path \nINSTALLS += createPluginsDir \n\ntarget.path = $$target_install_path \nINSTALLS += target \n\n```", "```cpp\nINCLUDEPATH += $$PWD/../sdk \nDEPENDPATH += $$PWD/../sdk \n\n```", "```cpp\n#include <memory> \n#include <vector> \n\n#include <Filter.h> \n\nclass FilterLoader \n{ \n\npublic: \n    FilterLoader(); \n    void loadFilters(); \n\n    const std::vector<std::unique_ptr<Filter>>& filters() const; \n\nprivate: \n    std::vector<std::unique_ptr<Filter>> mFilters; \n}; \n\n```", "```cpp\n#include \"FilterLoader.h\" \n\n#include <QApplication> \n#include <QDir> \n#include <QPluginLoader> \n\nFilterLoader::FilterLoader() : \n    mFilters() \n{ \n} \n\nvoid FilterLoader::loadFilters() \n{ \n    QDir pluginsDir(QApplication::applicationDirPath()); \n#ifdef Q_OS_MAC \n    pluginsDir.cdUp(); \n    pluginsDir.cdUp(); \n    pluginsDir.cdUp(); \n#endif \n    pluginsDir.cd(\"plugins\"); \n\n    for(QString fileName: pluginsDir.entryList(QDir::Files)) { \n        QPluginLoader pluginLoader( \n                      pluginsDir.absoluteFilePath(fileName)); \n        QObject* plugin = pluginLoader.instance(); \n        if (plugin) { \n            mFilters.push_back(std::unique_ptr<Filter>( \n                        qobject_cast<Filter*>(plugin) \n            )); \n        } \n    } \n} \n\nconst std::vector<std::unique_ptr<Filter>>& FilterLoader::filters() const \n{ \n    return mFilters; \n} \n\n```", "```cpp\n#include <QWidget> \n#include <QImage> \n\nnamespace Ui { \nclass FilterWidget; \n} \n\nclass Filter; \n\nclass FilterWidget : public QWidget \n{ \n    Q_OBJECT \n\npublic: \n    explicit FilterWidget(Filter& filter, QWidget *parent = 0); \n    ~FilterWidget(); \n\n    void process(); \n\n    void setSourcePicture(const QImage& sourcePicture); \n    void setSourceThumbnail(const QImage& sourceThumbnail); \n    void updateThumbnail(); \n\n    QString title() const; \n\nsignals: \n    void pictureProcessed(const QImage& picture); \n\nprotected: \n    void mousePressEvent(QMouseEvent*) override; \n\nprivate: \n    Ui::FilterWidget *ui; \n    Filter& mFilter; \n\n    QImage mDefaultSourcePicture; \n    QImage mSourcePicture; \n    QImage mSourceThumbnail; \n\n    QImage mFilteredPicture; \n    QImage mFilteredThumbnail; \n}; \n\n```", "```cpp\n#include <QMainWindow> \n#include <QImage> \n#include <QVector> \n\n#include \"FilterLoader.h\" \n\nnamespace Ui { \nclass MainWindow; \n} \n\nclass FilterWidget; \n\nclass MainWindow : public QMainWindow \n{ \n    Q_OBJECT \n\npublic: \n    explicit MainWindow(QWidget *parent = 0); \n    ~MainWindow(); \n\n    void loadPicture(); \n\nprotected: \n    void resizeEvent(QResizeEvent* event) override; \n\nprivate slots: \n    void displayPicture(const QImage& picture); \n    void saveAsPicture(); \n\nprivate: \n    void initFilters(); \n    void updatePicturePixmap(); \n\nprivate: \n    Ui::MainWindow *ui; \n    QImage mSourcePicture; \n    QImage mSourceThumbnail; \n    QImage& mFilteredPicture; \n    QPixmap mCurrentPixmap; \n\n    FilterLoader mFilterLoader; \n    FilterWidget* mCurrentFilter; \n    QVector<FilterWidget*> mFilters; \n}; \n\n```", "```cpp\nvoid MainWindow::initFilters() \n{ \n    mFilterLoader.loadFilters(); \n\n    auto& filters = mFilterLoader.filters(); \n    for(auto& filter : filters) { \n        FilterWidget* filterWidget = new FilterWidget(*filter); \n        ui->filtersLayout->addWidget(filterWidget); \n        connect(filterWidget, &FilterWidget::pictureProcessed, \n                this, &MainWindow::displayPicture); \n        mFilters.append(filterWidget); \n    } \n\n    if (mFilters.length() > 0) { \n        mCurrentFilter = mFilters[0]; \n    } \n} \n\n```", "```cpp\n void MainWindow::loadPicture() \n{ \n    ... \n    for (int i = 0; i <mFilters.size(); ++i) { \n        mFilters[i]->setSourcePicture(mSourcePicture); \n        mFilters[i]->setSourceThumbnail(mSourceThumbnail); \n        mFilters[i]->updateThumbnail(); \n    } \n    mCurrentFilter->process(); \n} \n\n```", "```cpp\nQLabel label; \nQPropertyAnimation animation; \n\nanimation.setTargetObject(&label); \nanimation.setPropertyName(\"geometry\"); \nanimation.setDuration(4000); \nanimation.setStartValue(QRect(0, 0, 150, 50)); \nanimation.setEndValue(QRect(300, 200, 150, 50)); \nanimation.start(); \n\n```", "```cpp\nQRect(x, y, width, height) \n\n```", "```cpp\nQLabel label; \nQPropertyAnimation animation(&label, \"geometry\"); \nanimation.setDuration(4000); \nanimation.setStartValue(QRect(0, 0, 150, 50)); \nanimation.setEndValue(QRect(300, 200, 150, 50)); \nanimation.setEasingCurve(QEasingCurve::InCirc); \nanimation.start(); \n\n```", "```cpp\nQLabel label; \nQPropertyAnimation animation(&label, \"geometry\"); \nanimation.setDuration(4000); \nanimation.setKeyValueAt(0, QRect(0, 0, 150, 50)); \nanimation.setKeyValueAt(0.25, QRect(225, 112.5, 150, 50)); \nanimation.setKeyValueAt(1, QRect(300, 200, 150, 50)); \nanimation.start(); \n\n```", "```cpp\nQPropertyAnimation animation1(&label1, \"geometry\"); \nQPropertyAnimation animation2(&label2, \"geometry\"); \n... \nQSequentialAnimationGroup animationGroup; \nanimationGroup.addAnimation(&anim1); \nanimationGroup.addAnimation(&anim2); \nanimationGroup.start(); \n\n```", "```cpp\n#include <QPropertyAnimation> \n\nclass FilterWidget : public QWidget \n{ \n    Q_OBJECT \n\npublic: \n    explicit FilterWidget(Filter& filter, QWidget *parent = 0); \n    ~FilterWidget(); \n    ... \n\nprivate: \n    void initAnimations(); \n    void startSelectionAnimation(); \n\nprivate: \n    ... \n    QPropertyAnimation mSelectionAnimation; \n}; \n\n```", "```cpp\nFilterWidget::FilterWidget(Filter& filter, QWidget *parent) : \n    QWidget(parent), \n    ... \n    mSelectionAnimation() \n{ \n    ... \n    initAnimations(); \n    updateThumbnail(); \n} \n\n```", "```cpp\nvoid FilterWidget::initAnimations() \n{ \n    mSelectionAnimation.setTargetObject(ui->thumbnailLabel); \n    mSelectionAnimation.setPropertyName(\"geometry\"); \n    mSelectionAnimation.setDuration(200); \n} \n\n```", "```cpp\nvoid FilterWidget::mousePressEvent(QMouseEvent*) \n{ \n    process(); \n    startSelectionAnimation(); \n} \n\n```", "```cpp\nvoid FilterWidget::startSelectionAnimation() \n{ \n    if (mSelectionAnimation.state() == \n        QAbstractAnimation::Stopped) { \n\n        QRect currentGeometry = ui->thumbnailLabel->geometry(); \n        QRect targetGeometry = ui->thumbnailLabel->geometry(); \n        targetGeometry.setY(targetGeometry.y() - 50.0); \n\n        mSelectionAnimation.setKeyValueAt(0, currentGeometry); \n        mSelectionAnimation.setKeyValueAt(0.3, targetGeometry); \n        mSelectionAnimation.setKeyValueAt(1, currentGeometry); \n        mSelectionAnimation.start(); \n    } \n} \n\n```", "```cpp\n#include <QPropertyAnimation> \n#include <QGraphicsOpacityEffect> \n\nclass MainWindow : public QMainWindow \n{ \n    ... \nprivate: \n    ... \n    void initAnimations(); \nprivate: \n    ... \n    QPropertyAnimation mLoadPictureAnimation; \n    QGraphicsOpacityEffect mPictureOpacityEffect; \n}; \n\n```", "```cpp\nMainWindow::MainWindow(QWidget *parent) : \n    QMainWindow(parent), \n    ... \n    mLoadPictureAnimation(), \n    mPictureOpacityEffect() \n{ \n    ... \n    initFilters(); \n    initAnimations(); \n} \n\n```", "```cpp\nvoid MainWindow::initAnimations() \n{ \n    ui->pictureLabel->setGraphicsEffect(&mPictureOpacityEffect); \n    mLoadPictureAnimation.setTargetObject(&mPictureOpacityEffect); \n    mLoadPictureAnimation.setPropertyName(\"opacity\"); \n    mLoadPictureAnimation.setDuration(500); \n    mLoadPictureAnimation.setStartValue(0); \n    mLoadPictureAnimation.setEndValue(1); \n    mLoadPictureAnimation.setEasingCurve(QEasingCurve::InCubic); \n} \n\n```", "```cpp\nvoid MainWindow::loadPicture() \n{ \n    ... \n    mCurrentFilter->process(); \n    mLoadPictureAnimation.start(); \n} \n\n```", "```cpp\n#include <QGraphicsColorizeEffect> \n\nclass FilterWidget : public QWidget \n{ \n    Q_OBJECT \n\npublic: \n    explicit FilterWidget(Filter& filter, QWidget *parent = 0); \n    ~FilterWidget(); \n    ... \n    QPropertyAnimation* colorAnimation(); \n\nprivate: \n    ... \n    QPropertyAnimation mSelectionAnimation; \n    QPropertyAnimation* mColorAnimation; \n    QGraphicsColorizeEffect mColorEffect; \n}; \n\n```", "```cpp\nFilterWidget::FilterWidget(Filter& filter, QWidget *parent) : \n    QWidget(parent), \n    ... \n    mColorAnimation(new QPropertyAnimation()), \n    mColorEffect() \n{ \n    ... \n} \n\n```", "```cpp\nQPropertyAnimation* FilterWidget::colorAnimation() \n{ \n    return mColorAnimation; \n} \n\n```", "```cpp\nvoid FilterWidget::initAnimations() \n{ \n    ... \n    mColorEffect.setColor(QColor(0, 150, 150)); \n    mColorEffect.setStrength(0.0); \n    ui->thumbnailLabel->setGraphicsEffect(&mColorEffect); \n\n    mColorAnimation->setTargetObject(&mColorEffect); \n    mColorAnimation->setPropertyName(\"strength\"); \n    mColorAnimation->setDuration(200); \n    mColorAnimation->setStartValue(1.0); \n    mColorAnimation->setEndValue(0.0); \n} \n\n```", "```cpp\n#include <QSequentialAnimationGroup> \n\nclass MainWindow : public QMainWindow \n{ \n    Q_OBJECT \n    ... \n\nprivate: \n    ... \n    QSequentialAnimationGroup mFiltersGroupAnimation; \n}; \n\n```", "```cpp\nMainWindow::MainWindow(QWidget *parent) : \n    QMainWindow(parent), \n    ... \n    mFiltersGroupAnimation() \n{ \n    ... \n} \n\n```", "```cpp\nvoid MainWindow::initAnimations() \n{ \n    ... \n    for (FilterWidget* filterWidget : mFilters) { \n        mFiltersGroupAnimation.addAnimation( \n            filterWidget->colorAnimation()); \n    } \n} \n\n```", "```cpp\nvoid MainWindow::loadPicture() \n{ \n    ... \n    mCurrentFilter->process(); \n    mLoadPictureAnimation.start(); \n    mFiltersGroupAnimation.start(); \n} \n\n```", "```cpp\nvoid MainWindow::loadPicture() \n{ \n    ... \n    for (int i = 0; i <mFilters.size(); ++i) { \n        mFilters[i]->setSourcePicture(mSourcePicture); \n        mFilters[i]->setSourceThumbnail(mSourceThumbnail); \n        //mFilters[i]->updateThumbnail(); \n    } \n    ... \n} \n\n```", "```cpp\nvoid FilterWidget::initAnimations() \n{ \n    ... \n    mColorAnimation->setTargetObject(&mColorEffect); \n    mColorAnimation->setPropertyName(\"strength\"); \n    mColorAnimation->setDuration(200); \n    mColorAnimation->setStartValue(1.0); \n    mColorAnimation->setEndValue(0.0); \n    connect(mColorAnimation, &QPropertyAnimation::finished, [this]  \n    { \n        updateThumbnail(); \n    }); \n} \n\n```"]