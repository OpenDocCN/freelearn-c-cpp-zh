["```cpp\n#include <vulkan\\vulkan.h> \n#include <vector> \n#include <set> \n#include <algorithm>  \n```", "```cpp\nclassSwapChain { \npublic: \n   SwapChain(); \n   ~SwapChain(); \n\n   VkSwapchainKHR swapChain; \n   VkFormat swapChainImageFormat; \n   VkExtent2D swapChainImageExtent; \n\n   std::vector<VkImage> swapChainImages; \n\n   VkSurfaceFormatKHRchooseSwapChainSurfaceFormat(\n     const std::vector<VkSurfaceFormatKHR>&availableFormats); \n\n   VkPresentModeKHRchooseSwapPresentMode(\n     const std::vector<VkPresentModeKHR>availablePresentModes); \n\n   VkExtent2DchooseSwapExtent(constVkSurfaceCapabilitiesKHR&capabilities); \n\n   void create(VkSurfaceKHRsurface); \n\nvoid destroy(); \n}  \n```", "```cpp\n#include\"SwapChain.h\" \n\n#include \"VulkanContext.h\"\n```", "```cpp\nVkSurfaceFormatKHRSwapChain::chooseSwapChainSurfaceFormat(const std::vector<VkSurfaceFormatKHR>&availableFormats) { \n\n   if (availableFormats.size() == 1 &&availableFormats[0].format == \n     VK_FORMAT_UNDEFINED) { \n         return{VK_FORMAT_B8G8R8A8_UNORM, \n           VK_COLOR_SPACE_SRGB_NONLINEAR_KHR }; \n   } \n\n   for (constauto& availableFormat : availableFormats) { \n         if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM&& \n            availableFormat.colorSpace == \n            VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { \n                return availableFormat; \n         } \n   } \n   returnavailableFormats[0]; \n} \n```", "```cpp\nVkPresentModeKHRSwapChain::chooseSwapPresentMode(\n  const std::vector<VkPresentModeKHR>availablePresentModes) { \n\n   VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR; \n\n   for (constauto& availablePresentMode : availablePresentModes) { \n\n         if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { \n               return availablePresentMode; \n         } \n         elseif (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) { \n               bestMode = availablePresentMode; \n         } \n\n         return bestMode; \n   } \n} \n```", "```cpp\n\nVkExtent2DSwapChain::chooseSwapExtent(constVkSurfaceCapabilitiesKHR&\n   capabilities) { \n\n   if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) { \n         returncapabilities.currentExtent; \n   } \n   else { \n\n         VkExtent2D actualExtent = { 1280, 720 }; \n\n         actualExtent.width = std::max(capabilities.minImageExtent.\n                              width, std::min(capabilities.\n                              maxImageExtent. width, \n                              actualExtent.width)); \n         actualExtent.height = std::max(capabilities.minImageExtent.\n                               height, std::min(capabilities.\n                               maxImageExtent.height, \n                               actualExtent.height)); \n\n         return actualExtent; \n   } \n} \n\n```", "```cpp\nvoid SwapChain::create(VkSurfaceKHR surface) { \n... \n} \n\n```", "```cpp\nSwapChainSupportDetails swapChainSupportDetails = VulkanContext::getInstance()-> getDevice()->swapchainSupport;\n```", "```cpp\n   VkSurfaceFormatKHR surfaceFormat = chooseSwapChainSurfaceFormat\n     (swapChainSupportDetails.surfaceFormats); \n   VkPresentModeKHR presentMode = chooseSwapPresentMode\n     (swapChainSupportDetails.presentModes); \n   VkExtent2D extent = chooseSwapExtent\n      (swapChainSupportDetails.surfaceCapabilities); \n```", "```cpp\nuint32_t imageCount = swapChainSupportDetails.\n                      surfaceCapabilities.minImageCount; \n```", "```cpp\n   if (swapChainSupportDetails.surfaceCapabilities.maxImageCount > 0 && \n     imageCount > swapChainSupportDetails.surfaceCapabilities.\n     maxImageCount) { \n         imageCount = swapChainSupportDetails.surfaceCapabilities.\n                      maxImageCount; \n   } \n\n```", "```cpp\n   VkSwapchainCreateInfoKHR createInfo = {}; \n   createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; \n```", "```cpp\n   createInfo.surface = surface; \n   createInfo.minImageCount = imageCount; \n   createInfo.imageFormat = surfaceFormat.format; \n   createInfo.imageColorSpace = surfaceFormat.colorSpace; \n   createInfo.imageExtent = extent; \n   createInfo.imageArrayLayers = 1; // this is 1 unless you are making\n   a stereoscopic 3D application \n   createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;\n```", "```cpp\n   if (indices.graphicsFamily != indices.presentFamily) { \n\n         createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; \n         createInfo.queueFamilyIndexCount = 2; \n         createInfo.pQueueFamilyIndices = queueFamilyIndices; \n\n   } \n   else { \n\n         createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; \n         createInfo.queueFamilyIndexCount = 0; \n         createInfo.pQueueFamilyIndices = nullptr; \n   } \n```", "```cpp\nif (vkCreateSwapchainKHR(VulkanContext::getInstance()->getDevice()->\n   logicalDevice, &createInfo, nullptr, &swapChain) != VK_SUCCESS) { \n         throw std::runtime_error(\"failed to create swap chain !\"); \n   } \n```", "```cpp\n   vkGetSwapchainImagesKHR(VulkanContext::getInstance()->getDevice()->\n      logicalDevice, swapChain, &imageCount, nullptr); \n   swapChainImages.resize(imageCount); \n   vkGetSwapchainImagesKHR(VulkanContext::getInstance()->getDevice()->\n      logicalDevice, swapChain, &imageCount, swapChainImages.data()); \n```", "```cpp\n   swapChainImageFormat = surfaceFormat.format; \n   swapChainImageExtent= extent; \n```", "```cpp\nvoid SwapChain::destroy(){ \n\n   // Swapchain \n   vkDestroySwapchainKHR(VulkanContext::getInstance()-> getDevice()->\n      logicalDevice, swapChain, nullptr); \n\n} \n```", "```cpp\n   swapChain = new SwapChain(); \n   swapChain->create(surface);\n```", "```cpp\n#include <vulkan\\vulkan.h> \n#include <array> \n\nclass Renderpass \n{ \npublic: \n   Renderpass(); \n   ~Renderpass(); \n\n   VkRenderPass renderPass; \n\n   void createRenderPass(VkFormat swapChainImageFormat); \n\n   void destroy(); \n};\n```", "```cpp\n#include\"Renderpass.h\" \n#include \"VulkanContext.h\"\nRenderpass::Renderpass(){} \n\nRenderpass::~Renderpass(){} \n\n```", "```cpp\nvoidRenderpass::createRenderPass(VkFormatswapChainImageFormat) { \n... \n} \n```", "```cpp\n   VkAttachmentDescription colorAttachment = {}; \n   colorAttachment.format = swapChainImageFormat; \n   colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; \n   colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; \n   colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;  \n   colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; \n   colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; \n\n   colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; \n   colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;  \n```", "```cpp\n   VkAttachmentReference colorAttachRef = {}; \n   colorAttachRef.attachment = 0;  \n   colorAttachRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;  \n\n```", "```cpp\n   VkSubpassDescription subpass = {}; \n   subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; \n   subpass.colorAttachmentCount = 1;  \n   subpass.pColorAttachments = &colorAttachRef; \n\n```", "```cpp\n   std::array<VkAttachmentDescription, 1> attachments = \n      { colorAttachment }; \n\n   VkRenderPassCreateInfo rpCreateInfo = {}; \n   rpCreateInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; \n   rpCreateInfo.attachmentCount = static_cast<uint32_t>\n                                  (attachments.size()); \n   rpCreateInfo.pAttachments = attachments.data(); \n   rpCreateInfo.subpassCount = 1; \n   rpCreateInfo.pSubpasses = &subpass; \n\n```", "```cpp\n\n if (vkCreateRenderPass(VulkanContext::getInstance()-> \n   getDevice()->logicalDevice, &rpCreateInfo, nullptr, &renderPass)\n   != VK_SUCCESS) { \n         throw std::runtime_error(\" failed to create renderpass !!\"); \n   }\n```", "```cpp\nvoidRenderpass::destroy(){ \n\n   vkDestroyRenderPass(VulkanContext::getInstance()-> getDevice()->\n      logicalDevice, renderPass, nullptr); \n\n} \n```", "```cpp\n   renderPass = new Renderpass(); \n   renderPass->createRenderPass(swapChain->swapChainImageFormat); \n```", "```cpp\n #include <vulkan/vulkan.h> \n#include<array> \n\nclass RenderTexture \n{ \npublic: \n   RenderTexture(); \n   ~RenderTexture(); \n\n   std::vector<VkImage> _swapChainImages; \n   VkExtent2D _swapChainImageExtent; \n\n   std::vector<VkImageView> swapChainImageViews; \n   std::vector<VkFramebuffer> swapChainFramebuffers; \n\n   void createViewsAndFramebuffer(std::vector<VkImage> swapChainImages,  \n     VkFormat swapChainImageFormat, VkExtent2D swapChainImageExtent, \n     VkRenderPass renderPass); \n\n   void createImageViews(VkFormat swapChainImageFormat); \n   void createFrameBuffer(VkExtent2D swapChainImageExtent, \n      VkRenderPass renderPass); \n\n   void destroy(); \n\n}; \n```", "```cpp\n#include \"RenderTexture.h\" \n#include \"VulkanContext.h\" \nRenderTexture::RenderTexture(){} \n\nRenderTexture::~RenderTexture(){} \n```", "```cpp\nvoid RenderTexture::createViewsAndFramebuffer(std::vector<VkImage> swapChainImages, VkFormat swapChainImageFormat,  \nVkExtent2D swapChainImageExtent,  \nVkRenderPass renderPass){ \n\n   _swapChainImages =  swapChainImages; \n   _swapChainImageExtent = swapChainImageExtent; \n\n   createImageViews(swapChainImageFormat); \n   createFrameBuffer(swapChainImageExtent, renderPass); \n}\n```", "```cpp\nvoid RenderTexture::createImageViews(VkFormat swapChainImageFormat){ \n\n   swapChainImageViews.resize(_swapChainImages.size()); \n\n   for (size_t i = 0; i < _swapChainImages.size(); i++) { \n\n         swapChainImageViews[i] = vkTools::createImageView\n                                  (_swapChainImages[i], \n               swapChainImageFormat,  \n               VK_IMAGE_ASPECT_COLOR_BIT); \n   } \n} \n```", "```cpp\n#include <vulkan\\vulkan.h> \n#include <stdexcept> \n#include <vector> \n\nnamespace vkTools { \n\n   VkImageView createImageView(VkImage image, VkFormat format, \n       VkImageAspectFlags aspectFlags); \n\n}\n```", "```cpp\n#include \"Tools.h\" \n#include \"VulkanContext.h\"\n\nnamespace vkTools { \n   VkImageView createImageView(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags) { \n\n         VkImageViewCreateInfo viewInfo = {}; \n         viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; \n         viewInfo.image = image; \n         viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; \n         viewInfo.format = format; \n\n         viewInfo.subresourceRange.aspectMask = aspectFlags; \n         viewInfo.subresourceRange.baseMipLevel = 0; \n         viewInfo.subresourceRange.levelCount = 1; \n         viewInfo.subresourceRange.baseArrayLayer = 0; \n         viewInfo.subresourceRange.layerCount = 1; \n\n         VkImageView imageView; \n         if (vkCreateImageView(VulkanContext::getInstance()->\n            getDevice()->logicalDevice, &viewInfo, nullptr, &imageView) \n            != VK_SUCCESS) { \n               throw std::runtime_error(\"failed to create \n                 texture image view !\"); \n         } \n\n         return imageView; \n   } \n\n} \n```", "```cpp\nvoid RenderTexture::createFrameBuffer(VkExtent2D swapChainImageExtent, VkRenderPass renderPass){ \n\n   swapChainFramebuffers.resize(swapChainImageViews.size()); \n\n   for (size_t i = 0; i < swapChainImageViews.size(); i++) { \n\n         std::array<VkImageView, 2> attachments = { \n               swapChainImageViews[i] \n         }; \n\n         VkFramebufferCreateInfo fbInfo = {}; \n         fbInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; \n         fbInfo.renderPass = renderPass;  \n         fbInfo.attachmentCount = static_cast<uint32_t>\n                                  (attachments.size());; \n         fbInfo.pAttachments = attachments.data();; \n         fbInfo.width = swapChainImageExtent.width; \n         fbInfo.height = swapChainImageExtent.height; \n         fbInfo.layers = 1;  \n\n         if (vkCreateFramebuffer(VulkanContext::getInstance()->\n            getDevice()->logicalDevice, &fbInfo, NULL, \n            &swapChainFramebuffers[i]) != VK_SUCCESS) { \n\n               throw std::runtime_error(\" failed to create \n                  framebuffers !!!\"); \n         } \n   } \n} \n\n```", "```cpp\nvoid RenderTexture::destroy(){ \n\n   // image views \n   for (auto imageView : swapChainImageViews) { \n\n         vkDestroyImageView(VulkanContext::getInstance()->getDevice()->\n            logicalDevice, imageView, nullptr); \n   } \n\n   // Framebuffers \n   for (auto framebuffer : swapChainFramebuffers) { \n         vkDestroyFramebuffer(VulkanContext::getInstance()->\n            getDevice()->logicalDevice, framebuffer, nullptr); \n   } \n\n} \n```", "```cpp\n   renderTexture = new RenderTexture(); \n   renderTexture->createViewsAndFramebuffer(swapChain->swapChainImages, \n         swapChain->swapChainImageFormat, \n         swapChain->swapChainImageExtent, \n         renderPass->renderPass); \n```", "```cpp\n#include <vulkan\\vulkan.h> \n#include <vector> \n\nclass DrawCommandBuffer \n{ \npublic: \n   DrawCommandBuffer(); \n   ~DrawCommandBuffer(); \n\n   VkCommandPool commandPool; \n   std::vector<VkCommandBuffer> commandBuffers; \n\n   void createCommandPoolAndBuffer(size_t imageCount); \n   void beginCommandBuffer(VkCommandBuffer commandBuffer); \n   void endCommandBuffer(VkCommandBuffer commandBuffer); \n\n   void createCommandPool(); \n   void allocateCommandBuffers(size_t imageCount); \n\n   void destroy(); \n}; \n```", "```cpp\n#include \"DrawCommandBuffer.h\" \n#include \"VulkanContext.h\"\n\nDrawCommandBuffer::DrawCommandBuffer(){} \n\nDrawCommandBuffer::~DrawCommandBuffer(){}   \n\n```", "```cpp\nvoid DrawCommandBuffer::createCommandPoolAndBuffer(size_t imageCount){ \n\n   createCommandPool(); \n   allocateCommandBuffers(imageCount); \n}\n```", "```cpp\nvoid DrawCommandBuffer::createCommandPool() { \n\n   QueueFamilyIndices qFamilyIndices = VulkanContext::\n                                       getInstance()->getDevice()-> \n                                       getQueueFamiliesIndicesOfCurrentDevice(); \n\n   VkCommandPoolCreateInfo cpInfo = {}; \n\n   cpInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; \n   cpInfo.queueFamilyIndex = qFamilyIndices.graphicsFamily; \n   cpInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT; \n\n   if (vkCreateCommandPool(VulkanContext::getInstance()->\n       getDevice()->logicalDevice, &cpInfo, nullptr, &commandPool) \n       != VK_SUCCESS) { \n          throw std::runtime_error(\" failed to create command pool !!\"); \n   } \n\n} \n```", "```cpp\nvoid DrawCommandBuffer::allocateCommandBuffers(size_t imageCount) { \n\n   commandBuffers.resize(imageCount); \n\n   VkCommandBufferAllocateInfo cbInfo = {}; \n   cbInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; \n   cbInfo.commandPool = commandPool; \n   cbInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; \n   cbInfo.commandBufferCount = (uint32_t)commandBuffers.size(); \n\n   if (vkAllocateCommandBuffers(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, &cbInfo, commandBuffers.data()) \n      != VK_SUCCESS) { \n\n         throw std::runtime_error(\" failed to allocate \n            command buffers !!\"); \n   } \n\n} \n\n```", "```cpp\n\nvoid DrawCommandBuffer::beginCommandBuffer(VkCommandBuffer commandBuffer){ \n\n   VkCommandBufferBeginInfo cbBeginInfo = {}; \n\n   cbBeginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; \n\n   cbBeginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; \n\n   if (vkBeginCommandBuffer(commandBuffer, &cbBeginInfo) != VK_SUCCESS) { \n\n         throw std::runtime_error(\" failed to begin command buffer !!\"); \n   } \n\n}\n```", "```cpp\nvoid DrawCommandBuffer::endCommandBuffer(VkCommandBuffer commandBuffer){ \n\n   if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) { \n\n         throw std::runtime_error(\" failed to record command buffer\"); \n   } \n\n} \n```", "```cpp\nvoid DrawCommandBuffer::destroy(){ \n\n   vkDestroyCommandPool(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, commandPool, nullptr); \n\n} \n```", "```cpp\n   renderTexture = new RenderTexture(); \n   renderTexture->createViewsAndFramebuffer(swapChain->swapChainImages, \n         swapChain->swapChainImageFormat, \n         swapChain->swapChainImageExtent, \n         renderPass->renderPass); \n\n   drawComBuffer = new DrawCommandBuffer(); \n   drawComBuffer->createCommandPoolAndBuffer(swapChain->\n     swapChainImages.size());\n```", "```cpp\nclass Renderpass \n{ \npublic: \n   Renderpass(); \n   ~Renderpass(); \n\n   VkRenderPass renderPass; \n\n   void createRenderPass(VkFormat swapChainImageFormat); \n\n   void beginRenderPass(std::array<VkClearValue, 1> \n      clearValues, VkCommandBuffer commandBuffer, VkFramebuffer \n      swapChainFrameBuffer, VkExtent2D swapChainImageExtent); \n\n   void endRenderPass(VkCommandBuffer commandBuffer); \n\n   void destroy(); \n}; \n\n```", "```cpp\nvoid Renderpass::beginRenderPass(std::array<VkClearValue, 1> clearValues, \n    VkCommandBuffer commandBuffer, VkFramebuffer swapChainFrameBuffer, \n    VkExtent2D swapChainImageExtent) { \n\n   VkRenderPassBeginInfo rpBeginInfo = {}; \n   rpBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; \n   rpBeginInfo.renderPass = renderPass; \n   rpBeginInfo.framebuffer = swapChainFrameBuffer; \n   rpBeginInfo.renderArea.offset = { 0,0 }; \n   rpBeginInfo.renderArea.extent = swapChainImageExtent; \n\n   rpBeginInfo.pClearValues = clearValues.data(); \n   rpBeginInfo.clearValueCount = static_cast<uint32_t>(clearValues.size()); \n\n   vkCmdBeginRenderPass(commandBuffer,&rpBeginInfo,\n      VK_SUBPASS_CONTENTS_INLINE); \n} \n```", "```cpp\nvoid Renderpass::endRenderPass(VkCommandBuffer commandBuffer){ \n\n   vkCmdEndRenderPass(commandBuffer); \n} \n\n```", "```cpp\npublic: \n\n   static VulkanApplication* getInstance(); \n   static VulkanApplication* instance; \n\n   ~VulkanApplication(); \n\n   void initVulkan(GLFWwindow* window); \n\n   void drawBegin(); \n   void drawEnd(); \nvoid cleanup(); \n\nprivate: \n\n   uint32_t imageIndex = 0; \n   VkCommandBuffer currentCommandBuffer; \n\n   //surface \n   VkSurfaceKHR surface; \n\n```", "```cpp\nvoid VulkanApplication::drawBegin(){ \n\n   vkAcquireNextImageKHR(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, \n         swapChain->swapChain, \n         std::numeric_limits<uint64_t>::max(), \n         NULL,  \n         VK_NULL_HANDLE, \n         &imageIndex); \n\n   currentCommandBuffer = drawComBuffer->commandBuffers[imageIndex]; \n\n   // Begin command buffer recording \n   drawComBuffer->beginCommandBuffer(currentCommandBuffer); \n\n   // Begin renderpass \n   VkClearValue clearcolor = { 1.0f, 0.0f, 1.0f, 1.0f }; \n\n   std::array<VkClearValue, 1> clearValues = { clearcolor }; \n\n   renderPass->beginRenderPass(clearValues, \n         currentCommandBuffer, \n         renderTexture->swapChainFramebuffers[imageIndex], \n         renderTexture->_swapChainImageExtent); \n\n} \n```", "```cpp\nvoid VulkanApplication::drawEnd(){ \n\n   // End render pass commands \n   renderPass->endRenderPass(currentCommandBuffer); \n\n   // End command buffer recording \n   drawComBuffer->endCommandBuffer(currentCommandBuffer); \n\n   // submit command buffer \n   VkSubmitInfo submitInfo = {}; \n   submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; \n   submitInfo.commandBufferCount = 1; \n   submitInfo.pCommandBuffers = &currentCommandBuffer; \n\n   vkQueueSubmit(VulkanContext::getInstance()->getDevice()->\n      graphicsQueue, 1, &submitInfo, NULL); \n\n   // Present frame \n   VkPresentInfoKHR presentInfo = {}; \n   presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; \n   presentInfo.swapchainCount = 1; \n   presentInfo.pSwapchains = &swapChain->swapChain; \n   presentInfo.pImageIndices = &imageIndex; \n\n   vkQueuePresentKHR(VulkanContext::getInstance()->\n       getDevice()->presentQueue, &presentInfo); \n\n   vkQueueWaitIdle(VulkanContext::getInstance()->\n       getDevice()->presentQueue); \n\n} \n```", "```cpp\nvoid VulkanApplication::cleanup() { \n\n   vkDeviceWaitIdle(VulkanContext::getInstance()->\n     getDevice()->logicalDevice); \n\n   drawComBuffer->destroy(); \n   renderTexture->destroy(); \n   renderPass->destroy(); \n   swapChain->destroy(); \n\n   VulkanContext::getInstance()->getDevice()->destroy(); \n\n   valLayersAndExt->destroy(vInstance->vkInstance, \n      isValidationLayersEnabled); \n\n   vkDestroySurfaceKHR(vInstance->vkInstance, surface, nullptr);   \n   vkDestroyInstance(vInstance->vkInstance, nullptr); \n\n} \n delete drawComBuffer;\n delete renderTarget;\n delete renderPass;\n delete swapChain;\n delete device;\n\n delete valLayersAndExt;\n delete vInstance;\n\n if (instance) {\n  delete instance;\n  instance = nullptr;\n }\n```", "```cpp\n#define GLFW_INCLUDE_VULKAN \n#include<GLFW/glfw3.h> \n\n#include \"VulkanApplication.h\" \n\nint main() { \n\n   glfwInit(); \n\n   glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); \n   glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); \n\n   GLFWwindow* window = glfwCreateWindow(1280, 720, \n                        \"HELLO VULKAN \", nullptr, nullptr); \n\n   VulkanApplication::getInstance()->initVulkan(window); \n\n   while (!glfwWindowShouldClose(window)) { \n\n         VulkanApplication::getInstance()->drawBegin(); \n\n         // draw command  \n\n         VulkanApplication::getInstance()->drawEnd(); \n\n         glfwPollEvents(); \n   }               \n\n   VulkanApplication::getInstance()->cleanup(); \n\n   glfwDestroyWindow(window); \n   glfwTerminate(); \n\n   return 0; \n} \n\n```"]