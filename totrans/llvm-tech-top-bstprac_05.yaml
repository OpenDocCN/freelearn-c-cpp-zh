- en: '*Chapter 4*: TableGen Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TableGen** is a **domain-specific language** (**DSL**) that was originally
    developed in **Low-Level Virtual Machine** (**LLVM**) to express processors''
    **instruction set architecture** (**ISA**) and other hardware-specific details,
    similar to the **GNU Compiler Collection''s** (**GCC''s**) **Machine Description**
    (**MD**). Thus, many people learn TableGen when they''re dealing with LLVM''s
    backend development. However, TableGen is not just for describing hardware specifications:
    it is a *general DSL* useful for any tasks that involve non-trivial *static and
    structural data*. LLVM has also been using TableGen on parts outside the backend.
    For example, Clang has been using TableGen for its command-line options management.
    People in the community are also exploring the possibility to implement **InstCombine**
    rules (LLVM''s **peephole optimizations**) in TableGen syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite TableGen's universality, the language's core syntax has never been widely
    understood by many new developers in this field, creating lots of copy-and-pasted
    boilerplate TableGen code in LLVM's code base since they're not familiar with
    the language *itself*. This chapter tries to shed a little bit of light on this
    situation and show the way to apply this amazing technique to a wide range of
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter starts with an introduction to common and important TableGen syntax,
    which prepares you for writing a delicious donut recipe in TableGen as a practice,
    culminating in a demonstration of TableGen's universality in the second part.
    Finally, the chapter will end with a tutorial to develop a custom *emitter*, or
    a **TableGen backend**, to convert those nerdy sentences in the TableGen recipe
    into normal plaintext descriptions that can be put in the kitchen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of the sections we will be covering:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to TableGen syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a donut recipe in TableGen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing a recipe via the TableGen backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter focuses on one tool in the `utils` folder: `llvm-tblgen`. To build
    it, launch the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you chose to build `llvm-tblgen` in `LLVM_OPTIMIZED_TABLEGEN` CMake variable
    introduced in the first chapter, you might want to change that setting since it's
    always better to have a debug version of `llvm-tblgen` in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the source code in this chapter can be found in this GitHub repository:
    [https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter04](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to TableGen syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section serves as a quick tour of all the important and common TableGen
    syntax, providing all the essential knowledge to get hands-on, writing a donut
    recipe in TableGen in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: TableGen is a domain-specific programming language used for modeling custom
    data layouts. Despite being a programming language, it does something quite different
    from conventional languages. **Conventional programming languages** usually describe
    *actions* performed on the (input) data, how they interact with the environment,
    and how they generate results, regardless of the programming paradigms (imperative,
    functional, event-driven…) you adopt. TableGen, in contrast, barely describes
    any actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'TableGen is designed only to describe structural **static data**. First, developers
    define the layout—which is essentially just a table with many fields—of their
    desired data structure. They then need to fill data into those layouts *right
    away* as most of the fields are populated/initialized. The latter part is probably
    what makes TableGen unique: many programming languages or frameworks provide ways
    to design your domain-specific data structures (for example, Google''s **Protocol
    Buffers**), but in those scenarios, data is usually filled in **dynamically**,
    mostly in the code that consumes the DSL part.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TABLE`; and in TableGen, it''s `class`, which will be introduced later on
    in this section. However, SQL provides much more functions other than crafting
    the layout. It can also query (actually, that''s where its name came from: **Structured
    Query Language**) and update data dynamically, which are absent in TableGen. However,
    later in this chapter, you will see that TableGen provides a nice framework to
    flexibly process and *interpret* this TableGen-defined data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now introduce four important TableGen constructions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Layout and records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bang operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Directed-Acyclic Graph** (**DAG**) data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout and records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the fact that TableGen is just a more fancy and expressive way to describe
    structural data, it''s pretty straightforward to think that there is a primitive
    representation for the data''s `class` syntax, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As shown here, a class is similar to a struct in C and many other programming
    languages, which only contains a group of data fields. Each field has a type,
    which can be any of the primitive types (`int`, `string`, `bit`, and so on) or
    another user-defined `class` type. A field can also assign a default value such
    as `John Smith`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After looking a layout, it''s time to create an instance (or a **record**,
    in TableGen''s terms), out of it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `john_smith` is a record using `Person` as a template so that it also
    has two fields—`Name` and `Age`—with the `Name` field filled with the value `John
    Smith`. This looks pretty straightforward, but recall that TableGen should define
    static data and that *most* fields should be filled with values. Also, in this
    case, the `Age` field is still left uninitialized. You can populate its value
    by *overriding* with a bracket closure and statements within, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even define new fields specifically for the `john_smith` record, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Just be aware that you can only override fields (using the `let` keyword) that
    have been declared, just as with many other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Bang operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bang operators are a group of functions performing simple tasks such as basic
    arithmetic or casting on values in TableGen. Here is a simple example of converting
    kilograms to grams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Common operators include arithmetic and bitwise operators (to name but a few),
    and some of these are outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`!add(a, b)`: For arithmetic addition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!sub(a, b)`: For arithmetic subtraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!mul(a, b)`: For arithmetic multiplication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!and(a, b)`: For logical `AND` operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!or(a, b)`: For logical `OR` operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!xor(a, b)`: For logical `XOR` operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also use conditional operators, and a few are outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`!ge(a, b)`: Returns 1 if `a >= b`, and 0 otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!gt(a, b)`: Returns 1 if `a > b`, and 0 otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!le(a, b)`: Returns 1 if `a <= b`, and 0 otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!lt(a, b)`: Returns 1 if `a < b`, and 0 otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!eq(a, b)`: Returns 1 if `a == b`, and 0 otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other interesting operators include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`!cast<type>(x)`: This operator performs type casting on the `x` operand, according
    to the `type` parameter. In cases where the type is a numerical type, such as
    with `int` or `bits`, this performs normal arithmetic type casting. In some special
    cases, we have the following scenarios:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `type` is string and `x` is a record, this returns the record's name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If `x` is a string, it is treated as the name of a record. TableGen will look
    up all the record definitions so far and cast the one with the name of `x` and
    return it with a type that matches the `type` parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`!if(pred, then, else)`: This operator returns the `then` expression if `pred`
    is 1, and returns the `else` expression otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!cond(cond1 : val1, cond2 : val2, …, condN : valN)`: This operator is an enhanced
    version of the `!if` operator. It will continuously evaluate `cond1…condN` until
    one of the expressions returns 1, before returning its associated `val` expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unlike functions, which are evaluated during runtime, bang operators are more
    like *macros*, which are evaluated during build time—or in TableGen's terminology,
    when those syntaxes are processed by TableGen backends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Multiclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many cases where we want to define multiple records at once. For
    example, the following snippet tries to create *auto part* records for multiple
    cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can further simplify these by using the `multiclass` syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating record instances, use the `defm` syntax instead of `def`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Thus, at the end, it will still generate records with names such as `car1_fuel_tank`,
    `car1_engine`, `car2_fuel_tank`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite having `class` in its name, `multiclass` has nothing to do with a class.
    Instead of describing the layout of a record, `multiclass` acts as a template
    to *generate* records. Inside a `multiclass` template are the prospective records
    to be created and the records'' name *suffix* after the template is expanded.
    For example, the `defm car1 : Car<1>` directive in the preceding snippet will
    eventually be expanded into three `def` directives, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def car1_fuel_tank : AutoPart<1>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def car1_engine : AutoPart<1>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def car1_wheels : AutoPart<!mul(1, 4)>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see in the preceding list, the name suffixes we found inside `multiclass`
    (for instance, `_fuel_tank`) was concatenated with the name appearing after `defm`—c`ar1`
    in this case. Also, the `quantity` template argument from `multiclass`, was also
    instantiated into every expanded record.
  prefs: []
  type: TYPE_NORMAL
- en: In short, `multiclass` tries to extract common parameters from multiple record
    instances and make it possible to create them at once.
  prefs: []
  type: TYPE_NORMAL
- en: The DAG data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to conventional data types, TableGen has a pretty unique first-class
    type: the `dag` type that is used for expressing DAG instances. To create a DAG
    instance, you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `operator` can only be a record instance, operands (`operand1`…`operandN`)
    can have arbitrary types. Here is an example of trying to model an arithmetic
    expression, `x * 2 + y + 8 * z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you can associate `operator` and/or each operand with a *tag*,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A tag always starts with a dollar sign, `$`, followed by a user-defined tag
    name. These tags provide a *logical* description of each `dag` component and can
    be useful when processing DAGs in the TableGen backend.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have gone through the principal components of the TableGen
    language and introduced some essential syntax. In the next section, we are going
    to get hands-on, writing a delicious donut recipe using TableGen.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a donut recipe in TableGen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the knowledge from previous sections, it''s time to write our own donut
    recipe! We''ll proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first file to create is `Kitchen.td`. It defines the environment for cooking,
    including measuring units, equipment, and procedures, to name but a few aspects.
    We are going to start with the measuring units, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the `Text` field is the textual format showing on the recipe, and `Imperial`
    is just a Boolean flag marking whether this unit is imperial or metric. Each weight
    or volume unit will be a record inheriting from this class—have a look at the
    following code snippet for an example of this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are plenty of measuring units we want to create, but the code is already
    pretty lengthy. A way to simplify and make it more readable is by using `class`
    template arguments, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In contrast to C++'s template arguments, the template arguments in TableGen
    only accept concrete values. They're just an alternative way to assign values
    to fields.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since TableGen doesn''t support floating-point numbers, we need to define some
    way to express numberings, such as `Integral` and `DecimalPoint` fields mentioned,
    the value represented by this `FixedPoint` class is equal to the following formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Integral * 10^(-DecimalPoint)*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since ¼, ½, and ¾ are apparently commonly used in measuring (especially for
    imperial units such as a US cup), it''s probably a good idea to use a helper class
    to create them, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement `NplusQuarter`, especially the conversion from the `NplusQuarter`
    class template parameters to that of `FixedPoint`, we need some simple arithmetic
    calculations, which is where TableGen''s bang operators come into place, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: num_quarter{8…6,4,2…0}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: num_quarter{1…7}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the measuring units and number format, we can finally deal with the ingredients
    needed for this recipe. First, let''s use a separated file, `Ingredients.td`,
    to store all the ingredient records. To use all the things mentioned earlier,
    we can import `Kitchen.td` by using the `include` syntax, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, a base class of all ingredients is created to carry some common fields,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'class Milk<cup_unit put at the template argument for IngredientBase tells us
    that milk is measured by a US cup unit, and its quantity is to be determined later
    by the Milk class template arguments. When writing a recipe, each required ingredient
    is represented by a record created from one of these ingredient `class` types:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Some ingredients, however, always come together—for example, lemon peel and
    lemon juice, egg yolk, and egg white. That is, if you have two egg yolks, then
    there must be two servings of egg white. However, if we need to create a record
    and assign a quantity for each of the ingredients one by one, there will be a
    lot of duplicate code. A more elegant way to solve this problem is by using TableGen's
    `multiclass` syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Taking the following egg example, assume we want to create `WholeEgg`, `EggWhite`,
    and `EggYolk` records at once with the same quantity, and define the `multiclass`
    first:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'defm egg_ingredient : Egg<3>;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need a way to describe the steps to make a donut. Many recipes
    have some preparation steps that don''t need to be done in a specific order. Take
    the donut recipe here, for example: preheating the oil can be done at any time
    before the donuts are ready to be fried. Thus, it might be a good idea to express
    baking steps in a `dag` type.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s first create the `class` to represent a baking step, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'def Action is just a class used for describing movements. The following snippet
    represents the fact that step_mixing2 is using the outcome from step_mixing (maybe
    a raw dough) and mixing it with butter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'def step_mixing2 : Step<(mix:dag tags have no immediate effect in TableGen
    code, except affecting how TableGen backends handle the current record—for example,
    if we have a string type field, CustomFormat, in the Step class, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And that wraps up this section of this chapter. In the next section, the goal
    is to develop a custom TableGen backend to take the TableGen version recipe here
    as input and print out a normal plaintext recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Printing a recipe via the TableGen backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following up on the last part of the previous section, after composing the donut
    recipe in TableGen's syntax, it's time to print out a *normal* recipe from that
    via a custom-built TableGen backend.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Please don''t confuse a **TableGen backend** with a **LLVM backend**: the former
    converts (or transpiles) TableGen files into an *arbitrary textual content*, C/C++
    header files being the most common form. An LLVM backend, on the other hand, lowers
    LLVM **intermediate representations** (**IR**) into low-level assembly code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''re developing the TableGen backend to print the donut
    we composed in the previous section into content, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: First, we will give an overview of `llvm-tblgen`, the program for driving the
    TableGen translation process. Then, we will show you how to develop our recipe-printing
    TableGen backend. Finally, we'll show you how to integrate our backend into the
    `llvm-tblgen` executable.
  prefs: []
  type: TYPE_NORMAL
- en: TableGen's high-level workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TableGen backend takes in-memory representation (in the form of C++ objects)
    of the TableGen code we just learned and transforms it into arbitrary `llvm-tblgen`
    executable, whose workflow can be illustrated by this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Workflow of llvm-tblgen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B14590.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Workflow of llvm-tblgen
  prefs: []
  type: TYPE_NORMAL
- en: 'TableGen code''s in-memory representation (which consists of C++ types and
    APIs) plays an important role in the TableGen backend development. Similar to
    LLVM IR, it is organized *hierarchically*. Starting from the top level, here is
    a list of its hierarchy, where each of the items is a C++ class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RecordKeeper`: A collection (and owner) of all `Record` objects in the current
    translation unit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Record`: Represents a record or a `class`. The enclosing fields are represented
    by `RecordVal`. If it''s a `class`, you can also access its template arguments.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RecordVal`: Represents a *pair* of record fields and their initialized value,
    along with supplementary information such as the field''s type and source location.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Init`: Represents the initialized value of a field. It is a parent class of
    `many`, which represents different types of initialized values—For example, `IntInit`
    for integer values and `DagInit` for DAG values.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To give you a little task on the practical aspect of a TableGen backend, here
    is the skeleton of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This emitter basically takes a `RecordKeeper` object (passed in by the constructor)
    as the input and prints the output into the `raw_ostream` stream—the function
    argument of `SampleEmitter::run`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we're going to show you how to set up the development environment
    and get hands- on, writing a TableGen backend.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the TableGen backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we're showing you the steps of writing a backend to print out
    recipes written in TableGen. Let's start with the setup.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started, LLVM has already provided a skeleton for writing a TableGen
    backend. So, please copy the `llvm/lib/TableGen/TableGenBackendSkeleton.cpp` file
    from the LLVM Project''s source tree into the `llvm/utils/TableGen` folder, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Then, refactor the c`SkeletonEmitter` class into `RecipePrinter`.
  prefs: []
  type: TYPE_NORMAL
- en: '`RecipePrinter` has the following workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Collect all baking steps and ingredient records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print individual ingredients in textual formats using individual functions to
    print measuring units, temperature, equipment, and so on in textual formats.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Linearize the DAG of all baking steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print each linearized baking step using a function to print custom formatting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're not going to cover all the implementation details since lots of backend
    codes are actually not directly related to TableGen (text formatting and string
    processing, for example). Therefore, the following subsections only focus on how
    to retrieve information from TableGen's in-memory objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting all the baking steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the TableGen backend, a TableGen record is represented by the `Record` C++
    class. When we want to retrieve all the records derived from a specific TableGen
    `class`, we can use one of the functions of `RecordKeeper`: `getAllDerivedDefinitions`.
    For instance, let''s say we want to fetch all the baking steps records that derived
    from the `Step` TableGen class in this case. Here is how we do with `getAllDerivedDefinitions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a list of `Record` pointers that represent all of the `Step` records.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this section, we will use `Record` in this format (with Courier
    font face) to refer to the C++ counterpart of a TableGen record.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving field values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Retrieving field values from `Record` is probably the most basic operation.
    Let''s say we''re working on a method for printing `Unit` record objects introduced
    earlier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Record` class provides some handy functions, such as `getValueAsString`,
    to retrieve the value of a field and try to convert it into a specific type so
    that you don''t need to retrieve the `RecordVal` value of a specific field (in
    this case, the `Text` field) before getting the real value. Similar functions
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Record* getValueAsDef(StringRef FieldName)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool getValueAsBit(StringRef FieldName)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int64_t getValueAsInt(StringRef FieldName)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DagInit* getValueAsDag(StringRef FieldName)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these utility functions, we sometimes just want to check if a
    specific field exists in a record. In such cases, call `Record::getValue(StringRef
    FieldName)` and check if the returned value is null. But just be aware that not
    every field *needs* to be initialized; you may still need to check if a field
    exists, but is uninitialized. When that happens, let `Record::isValueUnset` help
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: TableGen actually uses a special `Init` class, `UnsetInit`, to represent an
    uninitialized value.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Init` represents initialization values, but most of the time we''re not directly
    working with it but with one of its children''s classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `StepOrIngredient` is an `Init` type object that represents either
    a `Step` record or an ingredient record. It would be easier for us to convert
    it to its underlying `DefInit` object since `DefInit` provides richer functionalities.
    We can use the following code to typecast the `Init` type `StepOrIngredient` into
    a `DefInit` type object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `isa<…>(…)` to check its underlying type first, or `dyn_cast<…>(…)`
    if you don't want to receive an exception when the conversion fails.
  prefs: []
  type: TYPE_NORMAL
- en: '`Record` represents a TableGen record, but it would be better if we can find
    out its parent class, which further tells us the field''s information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, after getting the underlying `Record` object for `SIDef`, we can
    use the `isSubClassOf` function to tell if that `Record` is a baking step or ingredient,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Knowing what the underlying TableGen class actually is can help us to print
    that record in its own way.
  prefs: []
  type: TYPE_NORMAL
- en: Handling DAG values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we are going to print out the `Step` records. Recall that we used the
    `dag` type to represent the action and the ingredients required for a baking step.
    Have a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the highlighted `dag` is stored in the `Action` field of the `Step` TableGen
    class. So, we use `getValueAsDag` to retrieve that field as a `DagInit` object,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`DagInit` is just another class derived from `Init`, which wasintroduced earlier.
    It contains some DAG-specific APIs. For example, we can iterate through all of
    its operands and get their associated `Init` object using the `getArg` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can use the `getArgNameStr` function to retrieve the token
    (if there is any), which is always represented in string type in the TableGen
    backend, associated with a specific operand, as illustrated in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If `ArgTok` is empty, this means there is no token associated with that operand.
    To get the token associated with the operator, we can use the `getNameStr` API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Both `DagInit::getArgNameStr` and `DagInit::getNameStr` return the token string
    *without* the leading dollar sign.
  prefs: []
  type: TYPE_NORMAL
- en: This section has shown you some of the most important aspects of working with
    TableGen directives' in-memory C++ representation, which is the building block
    of writing a TableGen backend. In the next section, we will show you the final
    step to put everything together and run our custom TableGen backend.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the RecipePrinter TableGen backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After finishing the `utils/TableGen/RecipePrinter.cpp` file, it's time to put
    everything together.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, a TableGen backend is always associated with the `llvm-tblgen`
    tool, which is also the only interface to use the backend. `llvm-tblgen` uses
    simple command-line options to choose a backend to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of choosing one of the backends, `IntrInfoEmitter`, to generate
    a C/C++ header file from a `TableGen` file that carries instruction set information
    of `X86`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now see how to integrate `RecipePrinter` source file to `TableGen` backend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To link the `RecipePrinter` source file into `llvm-tblgen` and add a command-line
    option to select it, we''re going to use `utils/TableGen/TableGenBackends.h` first.
    This file only contains a list of TableGen backend entry functions, which are
    functions that take a `raw_ostream` output stream and the `RecordKeeper` object
    as arguments. We''re also putting our `EmitRecipe` function into the list, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, inside `llvm/utils/TableGen/TableGen.cpp`, we''re first adding a new
    `ActionType` enum element and the selected command-line option, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, go to the `LLVMTableGenMain` function and insert the function call
    to `EmitRecipe`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, don''t forget to update `utils/TableGen/CMakeLists.txt`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s all there is to it! You can now run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: =======Ingredients=======
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1\. oil 500 ml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2\. flour 300 g
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3\. milk 1.25 cup
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4\. whole egg 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 5\. yeast 1.50 tsp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 6\. butter 3.50 tbsp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 7\. sugar 2.0 tbsp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 8\. salt 0.50 tsp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 9\. vanilla extract 1.0 tsp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: =======Instructions=======
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1\. use deep fryer to heat oil until 160 C
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2\. use mixer to mix flour, milk, whole egg, yeast, butter, sugar, salt, and
    vanilla extract. stir in low speed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3\. use mixer to mix outcome from (step 2). stir in medium speed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4\. use bowl to ferment outcome from (step 3).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 5\. use rolling pin to flatten outcome from (step 4).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 6\. use cutter to cut outcome from (step 5).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 7\. use deep fryer to fry outcome from (step 1) and outcome from (step 6).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we have learned how to build a custom TableGen backend to transform
    a recipe written in TableGen into normal plaintext format. Things we learned here
    include how `llvm-tblgen`, the driver of translating TableGen code, works; how
    to use the TableGen backend's C++ APIs to operate TableGen directive's in-memory
    representation; and how to integrate our custom backend into `llvm-tblgen` in
    order to run it. Combining the skills you learned in this chapter and in the previous
    one, you can create a complete and standalone toolchain that implements your custom
    logic, using TableGen as a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced TableGen, a powerful DSL for expressing structural
    data. We have shown you its universality in solving a variety of tasks, albeit
    it originally being created for compiler development. Through the lens of writing
    a donut recipe in TableGen, we have learned its core syntax. The following section
    on developing a custom TableGen backend taught you how to use C++ APIs to interact
    with in-memory TableGen directives parsed from the source input, giving you the
    power to create a complete and standalone TableGen toolchain to implement your
    own custom logic. Learning how to master TableGen can not only help your development
    in LLVM-related projects but also gives you more options to solve structural data
    problems in arbitrary projects.
  prefs: []
  type: TYPE_NORMAL
- en: This section marks the end of the first part—an introduction to all kinds of
    useful supporting components in the LLVM project. Starting from the next chapter,
    we will move into the core compilation pipeline of LLVM. The first important topic
    we will cover is Clang, LLVM's official frontend for C-family programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This LLVM page provides a good reference on the TableGen syntax: [https://llvm.org/docs/TableGen/ProgRef.html](https://llvm.org/docs/TableGen/ProgRef.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This LLVM page provides a good reference on developing a TableGen backend:
    [https://llvm.org/docs/TableGen/BackGuide.html](https://llvm.org/docs/TableGen/BackGuide.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
