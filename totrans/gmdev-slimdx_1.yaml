- en: Chapter 1. Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。入门
- en: So maybe you have played with XNA Game Studio and already know that it can help
    you get a small game going relatively quickly. As you get better with it, you
    start to uncover its limitations. You'd prefer to have the full power of DirectX
    available to you in C#, since C# is nicer to work in than C++. Is there an alternative
    to XNA that can give you this? The answer is yes. **SlimDX** will give you that
    power in C#. It also gives you the power to work with different versions of DirectX
    as well. This means that you can make your games support multiple DirectX versions
    so that they can run on more computers, expanding your potential user base.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所以也许您已经玩过 XNA Game Studio，并且已经知道它可以帮助您相对快速地开始一个小游戏。随着您对其越来越熟悉，您开始发现它的局限性。您更希望拥有
    DirectX 的全部功能，在 C# 中使用，因为 C# 比使用 C++ 更容易工作。有没有一种替代 XNA 的方法可以提供这种功能？答案是肯定的。**SlimDX**
    将在 C# 中为您提供这种功能。它还为您提供了使用不同版本的 DirectX 的能力。这意味着您可以使您的游戏支持多个 DirectX 版本，以便它们可以在更多计算机上运行，扩大您的潜在用户群。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up Visual Studio 2013 Express and SlimDX
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Visual Studio 2013 Express 和 SlimDX
- en: Creating our initial framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的初始框架
- en: The GameWindow class and the GameLoop method
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameWindow 类和 GameLoop 方法
- en: Testing our game window
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试我们的游戏窗口
- en: Setting up Visual Studio 2013 Express
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Visual Studio 2013 Express
- en: We will be using Visual Studio 2013 Express since it is freely available from
    Microsoft.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Visual Studio 2013 Express，因为它可以从微软免费获得。
- en: 'Here are the steps to set up Visual Studio 2013 Express:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是设置 Visual Studio 2013 Express 的步骤：
- en: 'To download Visual Studio 2013 Express, you can visit the Microsoft website
    at: [http://www.visualstudio.com/downloads/download-visual-studio-vs](http://www.visualstudio.com/downloads/download-visual-studio-vs).'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要下载 Visual Studio 2013 Express，您可以访问微软网站：[http://www.visualstudio.com/downloads/download-visual-studio-vs](http://www.visualstudio.com/downloads/download-visual-studio-vs)。
- en: This website will show you all of the Express versions of Visual Studio that
    are available.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该网站将显示所有可用的 Visual Studio Express 版本。
- en: You will have to choose **Visual Studio Express 2013 for Windows Desktop** since
    we are focusing on PC development. Click on it to expand its section of the page,
    and then click on the **Install now** link to begin downloading the installer
    (`wdexpress_full.exe`).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将必须选择 **Visual Studio Express 2013 for Windows Desktop**，因为我们专注于 PC 开发。点击它以展开页面上的部分，然后点击
    **立即安装** 链接以开始下载安装程序（`wdexpress_full.exe`）。
- en: Now that you've downloaded the installer for Visual Studio 2013 Express, it's
    time to install it. Just double-click on the installer file to begin the installation
    process.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经下载了 Visual Studio 2013 Express 的安装程序，是时候安装它了。只需双击安装文件即可开始安装过程。
- en: When you start up Visual Studio 2013 Express, you will get a window asking you
    to log in with your Microsoft account. This is the account you will use to log
    in to your Hotmail account or your Xbox 360 (if you have one).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您启动 Visual Studio 2013 Express 时，您将得到一个窗口，要求您使用您的微软账户登录。这是您将用于登录您的 Hotmail
    账户或您的 Xbox 360（如果您有的话）的账户。
- en: Once you log in, Visual Studio 2013 Express will be registered to your Microsoft
    account. This is a smoother process than what it used to be.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，Visual Studio 2013 Express 将注册到您的微软账户。这是一个比以前更顺畅的过程。
- en: Setting up SlimDX
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 SlimDX
- en: 'Next, we need to download and install SlimDX. You can get SlimDX from its official
    website: [http://www.slimdx.org.](http://www.slimdx.org.)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要下载并安装 SlimDX。您可以从其官方网站获取 SlimDX：[http://www.slimdx.org.](http://www.slimdx.org.)
- en: 'Follow these steps to set up SlimDX:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置 SlimDX：
- en: Once you go to the SlimDX website, click on the **Download** tab at the top
    of the page. This will take you to the downloads page.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您进入 SlimDX 网站，点击页面顶部的 **下载** 选项卡。这将带您进入下载页面。
- en: At the time of this writing, the January 2012 release of SlimDX is the latest
    version. In order to create SlimDX-based software, we need to get the **SlimDX
    Developer SDK**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撰写本文时，2012 年 1 月发布的 SlimDX 是最新版本。为了创建基于 SlimDX 的软件，我们需要获取 **SlimDX 开发者 SDK**。
- en: So go to the section of the page with the heading **Developer SDK**. There is
    a short paragraph here and an orange button that says **Install Developer SDK**.
    As you can see from the short paragraph, this SDK contains all of the SlimDX binaries
    (the compiled SlimDX software), documentation, and samples. The SDK also supports
    both 32- and 64-bit systems. Click on the **Install Developer SDK** button.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，转到页面标题为**开发者SDK**的部分。这里有一段简短的段落和一个写着**安装开发者SDK**的橙色按钮。如短段落所示，此SDK包含所有SlimDX二进制文件（编译后的SlimDX软件）、文档和示例。SDK还支持32位和64位系统。单击**安装开发者SDK**按钮。
- en: This opens a second web page with a link at the top to a file called `SlimDX
    SDK (January 2012).msi`. Click on this link to begin downloading the SlimDX Developer
    SDK.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开一个包含顶部链接到名为`SlimDX SDK (January 2012).msi`的文件的第二个网页。单击此链接开始下载SlimDX开发者SDK。
- en: Once the download has completed, simply double-click on the installer file to
    begin the installation process. When the installer is finished, click on the **Finish**
    button to close it. We are now ready to write our first bits of code!
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，只需双击安装文件即可开始安装过程。安装程序完成后，点击**完成**按钮关闭它。我们现在可以开始编写我们的第一段代码了！
- en: Creating a framework
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建框架
- en: To make things easier, we will make a framework project that will contain code
    that we will use in numerous demo projects. It will be a class library that will
    hold our **engine code** . It is code that is not specific to a particular game,
    but rather is designed to be able to be re-used in multiple game development projects.
    If this sounds complicated, don't worry. It is really very easy to do. We will
    use the term **game code** to refer to code that is specific to a certain game.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情变得简单，我们将创建一个框架项目，该项目将包含我们在众多演示项目中将使用的代码。它将是一个类库，将包含我们的**引擎代码**。这是一种不特定于某个游戏的代码，而是设计成可以在多个游戏开发项目中重复使用的。如果这听起来很复杂，请不要担心。实际上，这非常容易做到。我们将使用**游戏代码**这个术语来指代特定于某个游戏的代码。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should *always* keep your engine code separated from your game code as much
    as possible. This increases the reusability of your engine code so that you can
    use it in multiple game development projects much more easily. This can also potentially
    save you a lot of time on future projects since you won't have to start completely
    from scratch every time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该**始终**尽可能将您的引擎代码与您的游戏代码分开。这增加了引擎代码的可重用性，使您能够更容易地在多个游戏开发项目中使用它。这还可以在未来的项目中节省您大量时间，因为您不必每次都从头开始。
- en: 'We are now ready to create a Visual Studio project that will store our framework
    code and resources:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建一个Visual Studio项目，用于存储我们的框架代码和资源：
- en: Open Visual Studio Express, if you haven't already.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有打开，请打开Visual Studio Express。
- en: Click on the **New Project...** link on the left-hand side of the **Start Page**,
    or from the **FILE** menu, choose **New** **Project...**; either way you will
    end up in the **New Project** window.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**开始页面**的左侧单击**新建项目...**链接，或从**文件**菜单中选择**新建** **项目...**；无论哪种方式，您都会进入**新建项目**窗口。
- en: We need to choose the type of project we wish to create. In this case, we first
    need to click on the **Visual C#** category in the left-hand side column. The
    screen changes to show C# project types in the center portion of the window.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要选择我们希望创建的项目类型。在这种情况下，我们首先需要在左侧列中的**Visual C#**类别上单击。屏幕将改变以显示窗口中心部分的C#项目类型。
- en: Now select **Class Library** shown in the middle of the window. A class library
    is just that, a library of classes. It cannot be executed by itself though.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择窗口中间显示的**类库**。类库正是如此，一个类的库。尽管如此，它本身不能执行。
- en: Enter a name for the project in the **Name** textbox at the bottom of the window.
    We'll call this project `SlimFramework`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口底部的**名称**文本框中输入项目的名称。我们将把这个项目命名为`SlimFramework`。
- en: If you don't have one ready, you will need to create a folder somewhere on your
    computer to store your work. Then specify that folder in the **Location** textbox
    at the bottom of the window shown in the following screenshot:![Creating a framework](img/7389OS_01_01.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有准备好，您需要在您的计算机上某个位置创建一个文件夹来存储您的作品。然后，在以下截图所示的窗口底部的**位置**文本框中指定该文件夹：![创建框架](img/7389OS_01_01.jpg)
- en: The New Project window
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新建项目窗口
- en: You can click on the **Browse** button to open a folder browser window that
    you can use to specify the folder you want to save to.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以单击**浏览**按钮打开文件夹浏览器窗口，您可以使用它来指定您想要保存到的文件夹。
- en: Leave the **Create directory for solution** checkbox checked so that Visual
    Studio will make a subfolder to put this project in. Your **New Project** window
    should look like the previous screenshot.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持**为解决方案创建目录**复选框选中，这样Visual Studio将创建一个子文件夹来放置此项目。你的**新建项目**窗口应该看起来像之前的截图。
- en: Click on the **OK** button to create the `SlimFramework` project. Visual Studio
    will create the project and display the `Class1.cs` file. It is just an empty
    class for now.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**按钮以创建`SlimFramework`项目。Visual Studio将创建项目并显示`Class1.cs`文件。目前它只是一个空类。
- en: To make a game, we first need a window to display our game in. So we will start
    our framework by creating a simple game window class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作一个游戏，我们首先需要一个窗口来显示我们的游戏。因此，我们将通过创建一个简单的游戏窗口类来开始我们的框架。
- en: 'Follow these simple steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单步骤操作：
- en: Select the `Class1.cs` file in the **Solution Explorer** pane. The **Solution
    Explorer** pane is on the upper-right portion of the Visual Studio window and
    allows us to see the files in our project.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**窗格中选择`Class1.cs`文件。**解决方案资源管理器**窗格位于Visual Studio窗口的右上角，允许我们查看项目中的文件。
- en: If it is not there, you can access it by opening the **VIEW** menu and choosing
    **Solution Explorer** to open it.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它不在那里，你可以通过打开**视图**菜单并选择**解决方案资源管理器**来打开它。
- en: Right-click on the `Class1.cs` file and rename it to `GameWindow.cs`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`Class1.cs`文件，将其重命名为`GameWindow.cs`。
- en: You may get a message box asking if you want to also rename all references to
    the code element `Class1`. If you click on **Yes**, it will replace any occurrences
    of `Class1` in your code with the new name so that your code won't be broken since
    you renamed the class. You will usually need to click on **Yes** for this.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会收到一个消息框询问你是否想要也将代码元素`Class1`的所有引用重命名。如果你点击**是**，它将替换代码中所有`Class1`的出现，以新的名称，这样你的代码就不会因为重命名了类而损坏。通常你需要点击**是**来完成这个操作。
- en: Before we can start creating this class though, we need to add some references
    to our project. To accomplish this, right-click on the heading **References**
    in the **Solution Explorer** pane and choose **Add Reference...**
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始创建这个类之前，我们需要向项目中添加一些引用。要完成这个操作，在**解决方案资源管理器**窗格中右键点击**引用**标题，并选择**添加引用...**
- en: The **Reference Manager** window will appear. The **Framework** category is
    currently selected, which is fine, because two of the references we need are in
    this category.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**引用管理器**窗口将出现。当前选中的是**框架**类别，这是可以的，因为我们需要的两个引用都在这个类别中。'
- en: Scroll down the list until you find **System.Windows.Forms**. A checkbox appears
    for the highlighted extension. Check this checkbox since we want to add a reference
    to this extension. This is shown in the following screenshot:![Creating a framework](img/7389OS_01_03.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动列表，直到找到**System.Windows.Forms**。会出现一个复选框用于高亮显示的扩展名。勾选此复选框，因为我们想添加对这个扩展名的引用。这在上面的截图中有展示：![创建框架](img/7389OS_01_03.jpg)
- en: Adding a reference to System.Windows.Forms
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加System.Windows.Forms引用
- en: Now, scroll up to find **System.Drawing** and put a check in its checkbox too.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向上滚动以找到**System.Drawing**，并在其复选框中勾选。
- en: Now we need to select the **Extensions** category in the left-hand side column.
    This causes the list in the center of the window to display extensions.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在左侧列中选择**扩展**类别。这将导致窗口中央的列表显示扩展。
- en: Scroll down until you find **SlimDX** in the list. You will find that there
    are two versions. You will have to select Version 4 as shown in the following
    screenshot:![Creating a framework](img/7389OS_01_04.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动直到你找到列表中的**SlimDX**。你会发现有两个版本。你必须选择版本4，如以下截图所示：![创建框架](img/7389OS_01_04.jpg)
- en: Adding a reference to SlimDX
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加SlimDX引用
- en: Click on the **OK** button and Visual Studio will add all of the references
    we specified to the project for us.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**按钮，Visual Studio将为我们添加所有指定的项目引用。
- en: If you now expand the **References** heading in the **Solution Explorer** pane,
    you will see that **SlimDX** now appears in the list of references that our project
    is using, as do **System.Windows.Forms** and **System.Drawing**. Now that we have
    added our references, we will be able to use SlimDX in our project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在展开**解决方案资源管理器**窗格中的**引用**标题，你将看到**SlimDX**现在出现在我们项目使用的引用列表中，同样还有**System.Windows.Forms**和**System.Drawing**。现在我们已经添加了引用，我们将在项目中使用SlimDX。
- en: The GameWindow class
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameWindow类
- en: The `GameWindow` class will provide basic game window functionality. It will
    provide all of the basic properties we want to have in our game window, and it
    will be used as a base class. We will not be making many game window subclasses
    in this book, but the idea here is that you can make different subclasses for
    different types of game windows. For example, you can have a game window class
    for DirectX 10 as well as a game window class for DirectX 11.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameWindow` 类将提供基本的游戏窗口功能。它将提供我们希望在游戏窗口中拥有的所有基本属性，并且它将被用作基类。在这本书中，我们不会创建很多游戏窗口子类，但这里的想法是，你可以为不同类型的游戏窗口创建不同的子类。例如，你可以有一个用于
    DirectX 10 的游戏窗口类，以及一个用于 DirectX 11 的游戏窗口类。'
- en: The main things we need to implement for the `GameWindow` class are a constructor
    to initialize it, **Game Loop** , `UpdateScene()` and `RenderScene()` methods,
    and a cleanup code for when the window is closed. A game loop is a method that
    is essentially the heart of a game engine. It is called repeatedly as long as
    the game is running. It is called once per frame in order to run the code that
    makes everything happen in our game world. It calls the `UpdateScene()` method,
    which updates objects in our game world. For example, this method will call on
    the physics system to simulate the physics for objects that are moving around
    in our game world.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为 `GameWindow` 类实现的主要事情是一个构造函数来初始化它，**游戏循环**，`UpdateScene()` 和 `RenderScene()`
    方法，以及当窗口关闭时的清理代码。游戏循环是一个本质上游戏引擎核心的方法。只要游戏在运行，它就会被反复调用。它每帧调用一次，以运行使我们的游戏世界中的一切发生代码。它调用
    `UpdateScene()` 方法，该方法更新我们游戏世界中的对象。例如，此方法将调用物理系统来模拟我们游戏世界中移动对象的物理。
- en: Once `UpdateScene()` has finished updating the states of all of the objects
    in our game world, the game loop will then call the `RenderScene()` method to
    draw the current frame. So ultimately, the game loop simulates and draws the game
    world frame-by-frame. Each time it is called, it simulates another frame.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `UpdateScene()` 完成更新我们游戏世界中所有对象的州，游戏循环就会调用 `RenderScene()` 方法来绘制当前帧。所以最终，游戏循环是逐帧模拟和绘制游戏世界的。每次调用时，它都会模拟另一个帧。
- en: 'A video game is composed of frames, just like movies are, except that in a
    video game each frame is being generated on the fly by the computer. Ideally,
    we want a game to run at least at 30 FPS (frames per second) so that the video
    is smooth. If the frame rate is too low, the game''s video will become choppy,
    or worse the game can become unplayable. Let''s go ahead and get started with
    implementing our `GameWindow` class. First, we need to add some `using` statements
    at the beginning of the `GameWindow.cs` file so that we can use some classes defined
    by SlimDX and the .NET Framework:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 电子游戏由帧组成，就像电影一样，只不过在电子游戏中，每个帧都是由计算机实时生成的。理想情况下，我们希望游戏至少以 30 FPS（每秒帧数）运行，以便视频流畅。如果帧率太低，游戏的视频会变得不连贯，或者更糟糕的是，游戏可能无法玩。让我们开始实现我们的
    `GameWindow` 类。首先，我们需要在 `GameWindow.cs` 文件的开头添加一些 `using` 语句，以便我们可以使用由 SlimDX
    和 .NET 框架定义的一些类：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt 书籍的账户中下载所有示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以直接将文件通过电子邮件发送给你。
- en: In some places in this book, not all code is shown due to space constraints.
    I will make a note of it when this is the case, so you will need to download the
    code for this book to see the full code for some demos.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间限制，本书中的一些地方没有显示所有代码。在这种情况下，我会做笔记，所以你需要下载这本书的代码来查看某些演示的完整代码。
- en: 'Next, we will create a member variables section at the beginning of the `GameWindow`
    class. Inside it, we will define all of the member variables for storing various
    information about the game window. Here is the the finished member variables section
    in the `GameWindow` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `GameWindow` 类的开始处创建一个成员变量部分。在其中，我们将定义所有用于存储有关游戏窗口信息的成员变量。以下是 `GameWindow`
    类中完成的成员变量部分：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most of these are fairly self-explanatory, but I'll run through them just in
    case.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内容都是相当直观的，但我还是想逐一过一遍，以防万一。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The downloadable code for this book is fully commented. I've removed comments
    here to save space and make the page look clean.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的可下载代码已全部注释。我在这里移除了注释以节省空间并使页面看起来更整洁。
- en: 'Here is a list of our member variables and what each one is for:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们成员变量及其用途的列表：
- en: '| Member variables | Purpose |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 成员变量 | 目的 |'
- en: '| --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `m_IsDisposed` | Simply indicates whether or not our game window has been
    disposed of. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `m_IsDisposed` | 简单地表示我们的游戏窗口是否已被销毁。|'
- en: '| `m_IsInitialized` | Indicates whether or not our game window has been initialized
    yet. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `m_IsInitialized` | 表示我们的游戏窗口是否已经初始化。|'
- en: '| `m_IsFullScreen` | Indicates whether or not the game window is running in
    full-screen mode. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `m_IsFullScreen` | 表示游戏窗口是否以全屏模式运行。|'
- en: '| `m_IsPaused` | This, of course, indicates whether or not the game window
    is paused. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `m_IsPaused` | 当然，这表示游戏窗口是否已暂停。|'
- en: '| `m_Form` | This holds the SlimDX `RenderForm` object that represents the
    game window itself. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `m_Form` | 这保存了代表游戏窗口本身的SlimDX `RenderForm`对象。|'
- en: '| `m_ClearColor` | This simply specifies the color to use whenever the screen
    is cleared. This is essentially the background color that we start with when we
    draw our scene. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `m_ClearColor` | 这简单地指定了在清除屏幕时使用的颜色。这基本上是我们绘制场景时开始时的背景颜色。|'
- en: '| `m_CurrFrameTime` | Holds the time in ticks when we start processing the
    current frame. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `m_CurrFrameTime` | 保存我们开始处理当前帧时的刻度时间。|'
- en: '| `m_LastFrameTime` | Holds the time in ticks when we start processing the
    previous frame. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `m_LastFrameTime` | 保存我们开始处理上一帧时的刻度时间。|'
- en: '| `m_FrameCount` | This is only used by the debug code in the `GameLoop()`
    method. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `m_FrameCount` | 仅在`GameLoop()`方法中的调试代码中使用。|'
- en: '| `m_FPS` | Holds the current FPS (frames per second) that the game loop is
    running at. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `m_FPS` | 保存游戏循环当前运行的FPS（每秒帧数）。|'
- en: Now that we've created our member variables, we need to make some **properties**
    to provide access to the ones that need to be accessible from outside of this
    class. A property is just a pair of methods for getting and setting the value
    of the member variable it represents. These methods are often called **accessor
    methods** or **accessors**. Most of the variables we just created will have accessors,
    but we don't have room to show them all here, so we will just look at the first
    one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了成员变量，我们需要创建一些**属性**来提供对那些需要从类外部访问的成员变量的访问。属性只是代表成员变量值的一对获取和设置方法。这些方法通常被称为**访问器方法**或**访问器**。我们刚刚创建的大多数变量都将有访问器，但这里没有足够的空间展示它们，所以我们只看第一个。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Check out the downloadable code to see the rest of the accessor methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 查看可下载代码以查看其余的访问器方法。
- en: 'Here is the code for the `ClearColor` property:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ClearColor`属性的代码：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the `ClearColor` property defines both the `get` and `set` methods.
    The `set` method is declared `protected` so that this property can only be set
    by this class or subclasses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ClearColor`属性定义了`get`和`set`方法。`set`方法被声明为`protected`，这样这个属性就只能由这个类或其子类设置。
- en: The constructor
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Now we need to set up a constructor for our `GameWindow` class. Here is the
    code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为我们的`GameWindow`类设置一个构造函数。以下是代码：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first two lines of code simply set the basic properties of the window to
    the values that have been passed into the constructor. The next line sets the
    default color, which is black. This means that each time we draw a new frame,
    we start with an empty black screen. The color is an **ARGB** (**Alpha, Red, Green,
    and Blue**) value. As you can see, this line sets all of the color channels to
    a value of `0.0f` (except for alpha)which gives us the color black. A value of
    `1.0f` for alpha means the color is opaque, while a value of `0.0f` would make
    it completely transparent. A value of `0.5f` would make the color 50 percent transparent.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前两行只是将窗口的基本属性设置为构造函数中传入的值。下一行设置了默认颜色，即黑色。这意味着每次我们绘制新帧时，我们都从一个空白的黑色屏幕开始。颜色是一个**ARGB**（**Alpha，红色，绿色，蓝色**）值。如您所见，这一行将所有颜色通道的值设置为`0.0f`（除了alpha），这给我们了黑色。alpha的值为`1.0f`意味着颜色是不透明的，而值为`0.0f`将使其完全透明。值为`0.5f`将使颜色50%透明。
- en: The next two lines create the `RenderForm` object, set its title text, and initialize
    it to the size that was passed into the constructor. `RenderForm` is a SlimDX
    class that represents a window for us to draw on. And finally, the last line simply
    subscribes the `GameWindow` class to the `Closed` event of the `RenderForm` object.
    This causes the `GameWindow` class to be notified when the window is closed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行创建了`RenderForm`对象，设置了其标题文本，并将其初始化为构造函数中传入的大小。`RenderForm`是SlimDX类，代表我们可以绘制其上的窗口。最后，最后一行简单地将`GameWindow`类订阅到`RenderForm`对象的`Closed`事件。这会导致当窗口关闭时，`GameWindow`类被通知。
- en: 'Now that we have our constructor, we need to define an event handler for the
    event we just subscribed the `GameWindow` class to. As you might guess, this event
    is fired when the game window is closed (either by the user or programmatically).
    Here is the code, which is pretty short as you can see:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了构造函数，我们需要为刚刚订阅了`GameWindow`类的那个事件定义一个事件处理器。正如你可能猜到的，这个事件是在游戏窗口关闭时触发的（无论是用户关闭还是程序关闭）。以下是代码，如你所见，相当简短：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `if` statement checks to see if the game window has already been disposed
    of. If not, then it calls the `Dispose()` method to dispose of it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句检查游戏窗口是否已经被释放。如果没有，它将调用`Dispose()`方法来释放它。'
- en: The IDisposable interface
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IDisposable`接口'
- en: 'Currently, the declaration of our `GameWindow` class says that it does not
    inherit from any other class, nor does it implement an interface. We are going
    to change this because we are going to implement the `IDisposable` interface.
    It is a very small interface so implementing it will be quick. First, we need
    to edit the declaration of our class to say that it will be implementing this
    interface. To do this, simply go to the beginning of the `GameWindow` class and
    change `public class GameWindow` to `public class GameWindow : IDisposable`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '目前，我们`GameWindow`类的声明表明它没有从任何其他类继承，也没有实现任何接口。我们将要改变这一点，因为我们将要实现`IDisposable`接口。这个接口非常小，实现它将很快。首先，我们需要编辑我们类的声明，使其表明它将实现这个接口。为此，只需将`GameWindow`类的开头从`public
    class GameWindow`更改为`public class GameWindow : IDisposable`。'
- en: 'This tells the compiler that this class implements the `IDisposable` interface.
    Now we have to adhere to this interface. It has one method that we need to implement.
    This method will perform cleanup operations when the game window is closed. There
    isn''t much in this function at the moment, but here it is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器这个类实现了`IDisposable`接口。现在我们必须遵守这个接口。它有一个我们需要实现的方法。这个方法将在游戏窗口关闭时执行清理操作。目前这个函数里没有太多内容，但这里它是：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Dispose(bool)` method is protected because we do not want it to be called
    from outside of the `GameWindow` class. Instead, we will create the second `Dispose()`
    method that is `public` and has no parameters. This way we can tell the object
    that we are done with it by calling this public method, and it will take care
    of cleaning up after itself. The `Dispose(bool)` method starts by checking to
    see if the game window has already been disposed of. If not, then it checks to
    see if the `disposing` parameter is set to `true`. This parameter simply indicates
    whether the game window is disposing of itself or whether it is being disposed
    of by the **Garbage Collector**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispose(bool)`方法被声明为受保护的，因为我们不希望它从`GameWindow`类外部被调用。相反，我们将创建第二个`Dispose()`方法，它是`public`的，没有参数。这样我们就可以通过调用这个公共方法来告诉对象我们已经完成了它，它将负责清理。`Dispose(bool)`方法首先检查游戏窗口是否已经被释放。如果没有，它将检查`disposing`参数是否设置为`true`。这个参数简单地指示游戏窗口是正在自行释放还是被**垃圾回收器**释放。'
- en: The Garbage Collector is a part of managed languages such as C#. When your program
    is no longer using an object, the Garbage Collector will reclaim the memory that
    object was using so that it can be used for something else. This will only happen
    if the program no longer has any references to the object. However, the Garbage
    Collector is not guaranteed to reclaim that memory immediately.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器是C#等托管语言的一部分。当你的程序不再使用一个对象时，垃圾回收器将回收该对象占用的内存，以便它可以用于其他目的。这只会发生在程序不再有任何对该对象的引用时。然而，垃圾回收器并不保证立即回收该内存。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should avoid creating large numbers of objects that you only use for a short
    time. This can keep the Garbage Collector much busier and you will pay the price
    in the form of lower FPS or lag spikes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该避免创建大量仅用于短时间内的对象。这可能会让垃圾回收器更加忙碌，你将付出以降低FPS或延迟波动的代价。
- en: If the `disposing` parameter is set to `true`, then the code inside the `if`
    statement will unregister events and call the `Dispose()` method on any managed
    objects it is using. Currently, it only unregisters the `Closed` event that we
    previously subscribed to. Then, the code following the `if` statement cleans up
    any unmanaged objects that it may be using. We won't have any unmanaged objects
    since we are using only **managed** code. Managed means that memory management
    is handled automatically for us for the most part.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`disposing`参数设置为`true`，则`if`语句内的代码将注销事件并调用它所使用的任何托管对象的`Dispose()`方法。目前，它只注销了我们之前订阅的`Closed`事件。然后，`if`语句之后的代码清理它可能正在使用的任何非托管对象。由于我们只使用**托管**代码，所以我们将没有非托管对象。托管意味着大部分情况下内存管理是由我们自动处理的。
- en: Lastly, at the end of this method, the `m_IsDisposed` member variable is set
    to `true`. This indicates that the window has been disposed of so the `RenderScene()`
    method will know that it should not try to render anything anymore, as doing so
    can cause the program to crash. We'll discuss the `RenderScene()` method in a
    moment, but first we need to finish with `IDisposable`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个方法的末尾，将`m_IsDisposed`成员变量设置为`true`。这表示窗口已经被销毁，因此`RenderScene()`方法将知道它不应该再尝试渲染任何内容，因为这样做可能会导致程序崩溃。我们稍后会讨论`RenderScene()`方法，但首先我们需要完成`IDisposable`的处理。
- en: 'Now we have to implement the public `Dispose()` method, which is a very short
    method as you can see in the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须实现公共的`Dispose()`方法，正如你可以在下面的代码片段中看到的那样，这是一个非常简短的方法：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method calls the `Dispose(bool)` method to dispose of the game window.
    The value `true` is passed in because this method is part of the `GameWindow`
    class, and thus the `GameWindow` class is disposing of itself in this case. Then
    we call `GC.SuppressFinalize(this)` to tell the Garbage Collector that this object
    has already been disposed of. You may have noticed that we never implemented `Finalizer`
    in this class. This is because the `Finalize()` method is used to clean up unmanaged
    resources in the object. It is called automatically by the Garbage Collector before
    it destroys the object. This allows it to clean up its unmanaged resources before
    it is destroyed. As such, we do not need to implement this method since we are
    only using managed code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法调用`Dispose(bool)`方法来销毁游戏窗口。传递的值是`true`，因为此方法是`GameWindow`类的一部分，因此在这种情况下`GameWindow`类正在销毁自己。然后我们调用`GC.SuppressFinalize(this)`来告诉垃圾回收器此对象已经被销毁。你可能已经注意到我们没有在这个类中实现`Finalizer`。这是因为`Finalize()`方法用于清理对象中的非托管资源。它在垃圾回收器销毁对象之前自动调用。这允许它在被销毁之前清理其非托管资源。因此，我们不需要实现此方法，因为我们只使用托管代码。
- en: The GameLoop method
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环方法
- en: 'Now we need to create our game loop. As mentioned earlier, the game loop is
    the main block of code that repeats endlessly until we close our game. It calls
    the code that will process and draw each frame, so it is essentially the heart
    of the game. We will create a new `GameLoop()` method that will be our game loop.
    Here is the code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们的游戏循环。如前所述，游戏循环是代码的主要块，它会无限重复，直到我们关闭游戏。它调用处理和绘制每个帧的代码，因此它是游戏的核心。我们将创建一个新的`GameLoop()`方法，它将成为我们的游戏循环。以下是代码：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this function, we first take the value of `m_CurrFrameTime` and copy it
    into `m_LastFrameTime`. Each time this function is called, we are processing a
    new frame. This means the value in `m_CurrFrameTime` now is the time for the previous
    frame. So we copy it into that variable. Next, we get the current time from the
    high performance timer and store it in `m_CurrFrameTime` via the `StopWatch` class.
    This class uses the high performance hardware timer, if it is available. Most
    PCs now have them, so this should not be a problem. Next, we go ahead and call
    the `UpdateScene()` and `RenderFrame()` methods. The `UpdateScene()` method is
    just an empty method for now, as shown in the following code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先将`m_CurrFrameTime`的值复制到`m_LastFrameTime`。每次调用这个函数时，我们都在处理一个新的帧。这意味着`m_CurrFrameTime`中的值现在是上一个帧的时间。因此，我们将它复制到那个变量中。接下来，我们从高性能计时器获取当前时间，并通过`StopWatch`类将其存储在`m_CurrFrameTime`中。这个类使用高性能硬件计时器，如果可用。现在大多数PC都有这些计时器，所以这应该不会成问题。接下来，我们继续调用`UpdateScene()`和`RenderFrame()`方法。`UpdateScene()`方法目前只是一个空方法，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Lastly, we calculate our FPS based on the duration of the previous frame. We
    simply take `StopWatch.Frequency` and divide it by the duration of the previous
    frame.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据上一帧的持续时间计算我们的FPS。我们只需将`StopWatch.Frequency`除以上一帧的持续时间。
- en: 'The parameter of the `UpdateScene()` method is the amount of time that has
    elapsed since the last time `UpdateScene()` was called. So we calculate that by
    subtracting the previous frame''s time from the current frame''s time. We then
    divide by `StopWatch.Frequency` to convert the result into seconds. This is necessary
    because the `StopWatch.GetTimeStamp()` function returns the current time in ticks.
    Essentially, it is a count of how many ticks have elapsed on the system timer
    since Windows was last booted up. The `StopWatch.Frequency` property tells us
    how many ticks our system timer does in one second. This is important because
    the timer in one computer may be faster or slower than the timer in another. The
    `RenderScene()` method is mostly empty for now too, but it does have a simple
    `if` statement in it though. Here is its code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateScene()`方法的参数是自上次调用`UpdateScene()`以来经过的时间量。我们通过从当前帧的时间减去上一帧的时间来计算这个值。然后我们除以`StopWatch.Frequency`将结果转换为秒。这是必要的，因为`StopWatch.GetTimeStamp()`函数返回当前时间的时间戳。本质上，它是在Windows上次启动以来系统计时器上经过的时间戳的总数。`StopWatch.Frequency`属性告诉我们系统计时器在一秒钟内进行多少次时间戳。这很重要，因为一台计算机的计时器可能比另一台计算机的计时器快或慢。现在`RenderScene()`方法也大多是空的，但它确实在其中有一个简单的`if`语句。以下是它的代码：'
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `if` statement in the `RenderScene()` method checks to see if the game window
    is ready for rendering. If the game window has not been initialized yet, or if
    the game window has been disposed of, then we simply return out of this function.
    This is important because it prevents possible crashing when the game window first
    starts up and when it shuts down.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RenderScene()`方法中的`if`语句检查游戏窗口是否已准备好进行渲染。如果游戏窗口尚未初始化，或者如果游戏窗口已被销毁，那么我们只需从这个函数中返回。这很重要，因为它可以防止游戏窗口首次启动和关闭时可能发生的崩溃。
- en: Note that `IsInitialized` and `IsDisposed` are two of the properties we talked
    about earlier for our member variables.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IsInitialized`和`IsDisposed`是我们之前讨论的成员变量属性中的两个。
- en: 'We almost have a functional `GameWindow` class now. But we need to add a `StartGameLoop()`
    method. This method is called to start up the game loop. It only contains the
    following few lines of code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎有了功能齐全的`GameWindow`类。但我们需要添加一个`StartGameLoop()`方法。这个方法被调用以启动游戏循环。它只包含以下几行代码：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, this function checks if the game window has already been initialized.
    If so, then we simply return out of this function. Otherwise, we set the `m_IsInitialized`
    member variable to `true` to indicate that it has been initialized. This function
    is essentially the initialization function for our game loop. And lastly, it calls
    `MessagePump.Run` passing in our `RenderForm` object (the game window itself)
    and our `GameLoop()` function. This will cause the `GameLoop()` function to be
    called repeatedly until we close the game window. (`RenderForm` and `MessagePump`
    are SlimDX classes.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数检查游戏窗口是否已经初始化。如果是这样，那么我们只需从这个函数中返回。否则，我们将`m_IsInitialized`成员变量设置为`true`以表示它已经被初始化。这个函数本质上是我们游戏循环的初始化函数。最后，它调用`MessagePump.Run`，传入我们的`RenderForm`对象（即游戏窗口本身）和我们的`GameLoop()`函数。这将导致`GameLoop()`函数被反复调用，直到我们关闭游戏窗口。（`RenderForm`和`MessagePump`是SlimDX类。）
- en: So why do we need `MessagePump`? In Windows, applications receive messages,
    which are just notifications that something has occurred. For example, a key press
    will generate a key pressed message. These messages are sent to whichever window
    is currently active. That program can then process and respond to the message.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们需要`MessagePump`呢？在Windows中，应用程序接收消息，这些消息只是通知某个事件已经发生。例如，按键会产生按键消息。这些消息被发送到当前活动的任何窗口。然后该程序可以处理并响应这些消息。
- en: In a game, we want a loop that runs continuously to simulate and draw each frame
    immediately after the previous one. We still have to handle messages from Windows
    though, or our game window will not work correctly anymore. For example, if we
    just had the program stuck in a loop, never checking Windows messages, then nothing
    will happen when you try to close the window since the program will never process
    the close message. So, we use this `MessagePump` class to handle Windows messages
    for us while running our game loop.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们希望有一个持续运行的循环来模拟和绘制每一帧，紧接着上一帧之后立即进行。尽管如此，我们仍然需要处理来自Windows的消息，否则我们的游戏窗口将无法正确工作。例如，如果我们只是让程序陷入循环，从不检查Windows消息，那么当你尝试关闭窗口时，由于程序永远不会处理关闭消息，所以将不会发生任何操作。因此，我们使用这个`MessagePump`类来在我们运行游戏循环的同时为我们处理Windows消息。
- en: Testing our game window
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的游戏窗口
- en: It is now time for us to test our game window! We will add a second project
    to our solution. With the `SlimFramework` solution still open, open the **FILE**
    menu, and select **New Project...**. Name the new project, for example, `Ch01`.
    Make sure you change the selected project type to **Windows Forms Application**.
    Also, it is very important that you make sure that the **Solution** drop-down
    list at the bottom of the window is set to **Add to solution** or Visual Studio
    will create a new solution instead of adding this project to our existing solution.
    If this option is not present, then it will add the new project to this solution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们测试游戏窗口的时候了！我们将向我们的解决方案中添加第二个项目。在`SlimFramework`解决方案仍然打开的情况下，打开**文件**菜单，并选择**新建项目...**。为新项目命名，例如，`Ch01`。确保将选定的项目类型更改为**Windows窗体应用程序**。同样，确保窗口底部的**解决方案**下拉列表设置为**添加到解决方案**，否则Visual
    Studio将创建一个新的解决方案而不是将此项目添加到我们的现有解决方案中。如果此选项不存在，则它将把新项目添加到这个解决方案中。
- en: Click on **OK** and the new project will be created and added to our solution.
    Right-click on it in the **Solution Explorer** pane and choose **Set as StartUp
    Project**. By doing this, we've told Visual Studio that this is the project we
    want to start up when we tell it to run our code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**确定**，新项目将被创建并添加到我们的解决方案中。在**解决方案资源管理器**窗格中右键单击它，并选择**设置为启动项目**。通过这样做，我们已经告诉Visual
    Studio，这是我们想要在告诉它运行我们的代码时启动的项目。
- en: The `SlimFramework` project can't be the startup project since it is just a
    class library, and therefore cannot execute on its own. This is because the `Class
    Library` project type does not have the `Main` method, like a `Console Application`
    or `Windows Forms Application` does. A Main Method is the first method that is
    called when the program starts up. So it is essentially the starting point of
    the program. You should also delete the `Form1.cs` file from this new project
    since we don't need it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`SlimFramework`项目不能作为启动项目，因为它只是一个类库，因此不能独立执行。这是因为`类库`项目类型没有`Main`方法，就像`控制台应用程序`或`Windows窗体应用程序`那样。`Main`方法是在程序启动时首先被调用的方法。因此，它是程序的起点。你还应该从这个新项目中删除`Form1.cs`文件，因为我们不需要它。'
- en: Now we need to add a reference to our project. Right-click on the **References**
    heading for the `Ch01` project in the **Solution Explorer** pane. Then click on
    **Add Reference...**. In the **Reference Manager** window, select the **Projects**
    category. Now check the checkbox next to the `SlimFramework` project. Click on
    **OK** and Visual Studio will add a reference to the `SlimFramework` project into
    the `Ch01` project. We can now use classes defined in the `SlimFramework` project
    in `Ch01`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将我们的项目添加引用。在**解决方案资源管理器**窗格中，右键单击`Ch01`项目的**引用**标题。然后单击**添加引用...**。在**引用管理器**窗口中，选择**项目**类别。现在勾选`SlimFramework`项目旁边的复选框。单击**确定**，Visual
    Studio将把`SlimFramework`项目的引用添加到`Ch01`项目中。我们现在可以在`Ch01`中使用`SlimFramework`项目中定义的类。
- en: 'Next, we need to add a couple of lines of code to the `Main` method in our
    new `Ch01` project. Here is the code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的新`Ch01`项目中的`Main`方法中添加几行代码。以下是代码：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code is fairly simple. The first two lines were already there, created
    by Visual Studio. I removed the third line that Visual Studio added—which made
    a call to `Application.Run()`—since we don't need it. The next line simply creates
    a new `GameWindow` object and passes in parameters to specify the title of the
    window, the width and height of the window, and lastly whether or not we want
    to run it in fullscreen mode. In this case, we set the window title to `Our First
    Game Window`, and the window size to `640x480`. And lastly, we pass in the value
    `false` for the last parameter since we do not want to run in fullscreen mode,
    as we haven't implemented it yet anyway. The last line of code in this method
    calls the `GameWindow` class's `StartGameLoop()` method to start up the game loop.
    The parameter of the `Main()` method is simply a `String` array that contains
    any command-line arguments that were passed in when the application was started.
    You would simply add code somewhere that would process the passed in command-line
    arguments, if any. This is how you would add some command-line switches to your
    game.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当简单。前两行是Visual Studio创建的。我移除了Visual Studio添加的第三行——它调用`Application.Run()`——因为我们不需要它。下一行简单地创建了一个新的`GameWindow`对象，并传入参数来指定窗口的标题、窗口的宽度和高度，最后是否要以全屏模式运行。在这种情况下，我们将窗口标题设置为`Our
    First Game Window`，窗口大小设置为`640x480`。最后，我们将最后一个参数的值设置为`false`，因为我们不想以全屏模式运行，因为我们还没有实现它。此方法中的最后一行代码调用`GameWindow`类的`StartGameLoop()`方法来启动游戏循环。`Main()`方法的参数只是一个`String`数组，它包含在应用程序启动时传入的任何命令行参数。如果你想要处理传入的命令行参数，你只需在某个地方添加代码即可。这就是你如何向你的游戏添加一些命令行开关的方法。
- en: We are now ready to compile and run our code. To do this, click on the **Start**
    button on Visual Studio's toolbar. This button has a green triangle icon beside
    it. The following screenshot shows what our game window looks like when you run
    the program. You may recall that we set black as our default background color,
    but the background of this window is not very black. This is not a bug, it is
    simply because we have no drawing code yet.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编译和运行我们的代码了。为此，点击Visual Studio工具栏上的**启动**按钮。这个按钮旁边有一个绿色的三角形图标。以下截图显示了运行程序时我们的游戏窗口的样子。你可能还记得，我们将黑色设置为默认背景颜色，但这个窗口的背景并不是非常黑。这并不是一个错误，只是因为我们还没有绘制代码。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you get an error stating that **A project with an Output Type of Class Library
    cannot be started directly** when you try to run the program, it means that you
    forgot to set `Ch01` as the startup project as mentioned earlier.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试运行程序时，如果出现错误信息表明**无法直接启动具有类库输出类型的项目**，这意味着你忘记按照前面提到的将`Ch01`设置为启动项目了。
- en: 'The following screenshot shows our game window in action:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的游戏窗口的实际运行情况：
- en: '![Testing our game window](img/7389OS_01_05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的游戏窗口](img/7389OS_01_05.jpg)'
- en: The game window in action
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏窗口的实际运行情况
- en: It's not that impressive now, but it won't be too much longer before we can
    start rendering some graphics on the screen, which makes things a lot more interesting.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来并不那么令人印象深刻，但不久我们就可以开始在屏幕上渲染一些图形了，这将使事情变得更加有趣。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got Visual Studio and SlimDX set up and ready to go. We
    created a project to work in and built the beginnings of our little framework.
    It consists only of our `GameWindow` class for now, which creates a game window
    for us to draw our game on. We gave our `GameWindow` class a constructor and also
    covered the `GameLoop` function. We gave it `UpdateScene()` and `RenderScene()`
    methods for updating and drawing our game world at each frame. We also covered
    interfaces, specifically the `IDisposable` interface, and gave the game window
    a `ToggleFullscreen()` method. And finally, we tested our game window and saw
    it in action for the first time. In the next chapter, we will dive into user input
    and how to respond to the player's actions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设置了Visual Studio和SlimDX，使其准备就绪。我们创建了一个项目来工作，并构建了我们小型框架的起点。目前它只包含我们的`GameWindow`类，它为我们创建了一个游戏窗口，以便我们在上面绘制游戏。我们为`GameWindow`类提供了一个构造函数，并介绍了`GameLoop`函数。我们为它提供了`UpdateScene()`和`RenderScene()`方法，用于在每一帧更新和绘制我们的游戏世界。我们还介绍了接口，特别是`IDisposable`接口，并为游戏窗口提供了一个`ToggleFullscreen()`方法。最后，我们测试了我们的游戏窗口，并第一次看到了它的实际运行情况。在下一章中，我们将深入探讨用户输入以及如何响应用户的动作。
