- en: Customization in Qt Quick
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick 中的自定义
- en: In the previous chapter, you learned how to use controls and layouts provided
    by Qt Quick to build the user interface of your application. Qt contains numerous
    QML types that can serve as building blocks for your game, providing rich functionality
    and a nice appearance. However, sometimes you need to create a custom component
    that satisfies the needs of your game. In this chapter, we will show a couple
    of convenient ways to extend your QML project with custom components. By the end
    of this chapter, you will know how to perform custom painting on a canvas, handle
    various input events, and implement lazy loading for your components. We will
    also see how to integrate a C++ object into QML's object tree.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用 Qt Quick 提供的控件和布局来构建应用程序的用户界面。Qt 包含许多 QML 类型，可以作为你游戏的构建块，提供丰富的功能和高雅的外观。然而，有时你需要创建一个满足你游戏需求的自定义组件。在本章中，我们将展示一些方便的方法来通过自定义组件扩展你的
    QML 项目。到本章结束时，你将知道如何在画布上执行自定义绘图，处理各种输入事件，并为你的组件实现延迟加载。我们还将看到如何将 C++ 对象集成到 QML
    的对象树中。
- en: 'The main topics covered in this chapter are as listed:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: Creating a custom component
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义组件
- en: Handling mouse, touch, keyboard, and gamepad events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理鼠标、触摸、键盘和游戏手柄事件
- en: Dynamic and lazy loading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态和延迟加载
- en: Painting on Canvas using JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 在画布上绘图
- en: Creating a custom QML component
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义 QML 组件
- en: We already touched the topic of custom components when we worked with the form
    editor in the previous chapter. Our QML files implemented reusable components
    with a clean interface that can be used in the rest of the application. We will
    now take a more low-level approach and create a new QML component directly from
    QML code using the basic Qt Quick building blocks. Our component will be a button
    with a rounded shape and a nice background. The button will hold definable text
    and an icon. Our component should look good for different texts and icons.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当使用表单编辑器时，我们已经接触到了自定义组件的话题。我们的 QML 文件实现了具有干净界面的可重用组件，可以在应用程序的其余部分中使用。现在，我们将采用更底层的策略，直接从
    QML 代码中使用基本的 Qt Quick 构建块创建一个新的 QML 组件。我们的组件将是一个具有圆角和良好背景的按钮。按钮将包含可定义的文本和图标。我们的组件应该对不同文本和图标都具有良好的外观。
- en: Time for action – Creating a button component
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 - 创建按钮组件
- en: Start by creating a new project in Qt Creator. Choose Qt Quick Application -
    Empty as the project template. Name the project `custom_button` and leave the
    rest of the options unchanged.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在 Qt Creator 中创建一个新的项目。选择 Qt Quick Application - Empty 作为项目模板。将项目命名为 `custom_button`
    并保持其余选项不变。
- en: 'At this point, you should end up with a QML document containing an empty window.
    Let''s start by creating the button frame. Edit the `main.qml` file to add a new `Rectangle` item
    to the window:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经拥有一个包含空窗口的 QML 文档。让我们先创建按钮框架。编辑 `main.qml` 文件，向窗口添加一个新的 `Rectangle`
    项目：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After running the project, you should see a result similar to the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目后，你应该看到以下类似的结果：
- en: '![](img/479fb0fc-08a6-4fe3-afdd-0705da063a8d.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/479fb0fc-08a6-4fe3-afdd-0705da063a8d.png)'
- en: What just happened?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: You can see that the rectangle is centered in the window using a `centerIn` anchor
    binding that we didn't mention before. This is one of the two special anchors
    that are provided for convenience, to avoid having to write too much code. Using `centerIn` is
    equivalent to setting both `horizontalCenter` and `verticalCenter`. The other
    convenience binding is `fill`, which makes one item occupy the whole area of another
    item (similar to setting the left, right, top, and bottom anchors to their respective
    anchor lines in the destination item).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，使用我们之前未提及的 `centerIn` 锚点绑定，矩形在窗口中居中。这是两个特殊锚点之一，提供便利，以避免编写过多的代码。使用 `centerIn`
    等同于设置 `horizontalCenter` 和 `verticalCenter`。另一个便利绑定是 `fill`，它使一个项目占据另一个项目的整个区域（类似于在目标项目中将左、右、上、下锚点设置为相应的锚线）。
- en: Instead of setting a solid color for the button, we declared the background
    to be a linear gradient. We bound a `Gradient` element to the `gradient` property
    and defined two `GradientStop` elements as its children, where we specified two
    colors to blend between. `Gradient` does not inherit from `Item` and thus is not
    a visual Qt Quick element. Instead, it is just a QML object that serves as a data
    holder for the gradient definition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与为按钮设置纯色背景不同，我们声明背景为线性渐变。我们将一个`Gradient`元素绑定到`gradient`属性，并定义了两个`GradientStop`元素作为其子元素，其中我们指定了两种颜色进行混合。`Gradient`不继承自`Item`，因此不是一个可视的Qt
    Quick元素。相反，它只是一个作为渐变定义数据持有者的QML对象。
- en: The `Item` type has a property called `children` that contains a list of the
    visual children (`Item` instances) of an item and another property called `resources`,
    which contains a list of non-visual objects (such as `Gradient` or `GradientStop`)
    for an item. Normally, you don't need to use these properties when adding visual
    or non-visual objects to an item, as the item will automatically assign child
    objects to appropriate properties. Note that in our code, the `Gradient` object
    is not a child object of the `Rectangle`; it is just assigned to its `gradient` property.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`类型有一个名为`children`的属性，它包含一个项目可视子项（`Item`实例）的列表，还有一个名为`resources`的属性，它包含一个项目非可视对象（如`Gradient`或`GradientStop`）的列表。通常，在向项目添加可视或非可视对象时，你不需要使用这些属性，因为项目会自动将子对象分配到适当的属性中。请注意，在我们的代码中，`Gradient`对象不是`Rectangle`的子对象；它只是被分配到其`gradient`属性。'
- en: Time for action – Adding button content
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 添加按钮内容
- en: The next step is to add text and an icon to the button. First, copy the icon
    file to the project directory. In Qt Creator, locate the `qml.qrc` resource file
    in the project tree. In the context menu of the resource file, select Add Existing
    Files and select your icon file. The file will be added to the resources and will
    appear in the project tree. Our example file is called `edit-undo.png`, and the
    corresponding resource URL is `qrc:/edit-undo.png`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向按钮添加文本和图标。首先，将图标文件复制到项目目录中。在Qt Creator中，在项目树中定位`qml.qrc`资源文件。在资源文件的上下文菜单中选择“添加现有文件”，并选择你的图标文件。文件将被添加到资源中，并出现在项目树中。我们的示例文件名为`edit-undo.png`，相应的资源URL为`qrc:/edit-undo.png`。
- en: You can get the resource path or URL of a file by locating that file in the
    project tree and using the Copy Path or Copy URL option in its context menu.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在项目树中定位该文件并使用其上下文菜单中的“复制路径”或“复制URL”选项来获取文件的资源路径或URL。
- en: 'Next, we will add the icon and the text to our button using another item type
    called `Row`, as shown:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用另一个名为`Row`的项目类型将图标和文本添加到我们的按钮中，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You''ll get the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![](img/995933a6-b01b-4bb2-bd3d-14d3b60dfafc.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/995933a6-b01b-4bb2-bd3d-14d3b60dfafc.png)'
- en: What just happened?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: '`Row` is a **positioner** QML type provided by the `QtQuick` module. Its purpose
    is similar to the `RowLayout` type from the `QtQuick.Layouts` module. The `Row` item
    spreads its children in a horizontal row. It makes it possible to position a series
    of items without using anchors. `Row` has the `spacing` property that dictates
    how much space to leave between items.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Row`是`QtQuick`模块提供的**定位器**QML类型。其目的是与`QtQuick.Layouts`模块中的`RowLayout`类型类似。`Row`项目将其子项在水平行中展开。它使得在不使用锚点的情况下定位一系列项目成为可能。`Row`具有`spacing`属性，它决定了项目之间应留多少空间。'
- en: The `QtQuick` module also contains the `Column` type that arranges children
    in a column, the `Grid` type that creates a grid of items, and the `Flow` type
    that positions its children side by side, wrapping as necessary.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtQuick`模块还包含`Column`类型，它将子项排列成一列，`Grid`类型创建一个项目网格，以及`Flow`类型，它将子项并排放置，并在必要时进行换行。'
- en: Time for action – Sizing the button properly
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 正确设置按钮大小
- en: 'Our current panel definition still doesn''t behave well when it comes to sizing
    the button. If the button content is very small (for example, the icon doesn''t
    exist or the text is very short), the button will not look good. Typically, push
    buttons enforce a minimum size—if the content is smaller than a specified size,
    the button will be expanded to the minimum size allowed. Another problem is that
    the user might want to override the width or height of the item. In such cases,
    the content of the button should not overflow past the border of the button. Let''s
    fix these two issues by replacing the `width` and `height` property bindings with
    the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到按钮的大小调整时，我们当前的面板定义仍然表现不佳。如果按钮内容非常小（例如，图标不存在或文本非常短），按钮看起来就不会很好。通常，按钮强制执行最小尺寸——如果内容小于指定的大小，按钮将扩展到允许的最小尺寸。另一个问题是，用户可能想要覆盖项的宽度和高度。在这种情况下，按钮的内容不应超出按钮的边界。让我们通过用以下代码替换
    `width` 和 `height` 属性绑定来解决这两个问题：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What just happened?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `implicitWidth` and `implicitHeight` properties can contain the desired
    size the item wants to have. It's a direct equivalent of `sizeHint()` from Qt
    Widgets. By using these two properties instead of `width` and `height` (which
    are bound to `implicitWidth` and
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`implicitWidth` 和 `implicitHeight` 属性可以包含项想要具有的期望大小。它是 Qt Widgets 中的 `sizeHint()`
    的直接等效。通过使用这两个属性而不是 `width` 和 `height`（它们绑定到 `implicitWidth` 和'
- en: '`implicitHeight` by default), we allow the user of our component to override
    those implicit values. When this happens and the user does not set the width or
    height big enough to contain the icon and text of the button, we prevent the content
    from crossing the boundaries of the parent item by setting the `clip` property
    to `true`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`implicitHeight`），我们允许我们的组件用户覆盖这些隐式值。当这种情况发生且用户没有设置足够宽或高的宽度或高度以包含按钮的图标和文本时，我们通过将
    `clip` 属性设置为 `true` 来防止内容超出父项的边界。
- en: Clipping can reduce performance of your game, so use it only when necessary.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 剪裁可能会降低游戏性能，因此仅在必要时使用。
- en: Time for action – Making the button a reusable component
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 将按钮制作成可重用组件
- en: So far, we have been working on a single button. Adding another button by copying
    the code, changing the identifiers of all components, and setting different bindings
    to properties is a very tedious task. Instead, we can make our button item a real
    component, that is, a new QML type that can be instantiated on demand as many
    times as required.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理单个按钮。通过复制代码、更改所有组件的标识符以及设置不同的属性绑定来添加另一个按钮是一项非常繁琐的任务。相反，我们可以将我们的按钮项变成一个真正的组件，即一个可以在需要时实例化多次的新
    QML 类型。
- en: 'First, position the text cursor in the beginning of our `Rectangle` item and
    press *Alt* + *Enter* on the keyboard to open the refactoring menu, like in the
    following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将文本光标定位在我们的 `Rectangle` 项的开头，然后在键盘上按 `Alt` + `Enter` 打开重构菜单，就像以下截图所示：
- en: '![](img/4c4e5a63-dcf9-48c9-b5f0-85aff19c09e6.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c4e5a63-dcf9-48c9-b5f0-85aff19c09e6.png)'
- en: 'From the menu, choose Move Component into Separate File. In the popup, type
    in a name for the new type (for example, `Button`) and check `anchors.centerIn`
    in the Property assignments for main.qml list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜单中选择 `将组件移动到单独的文件`。在弹出窗口中，为新的类型输入一个名称（例如，`Button`），并在 `main.qml` 的属性分配列表中勾选
    `anchors.centerIn`：
- en: '![](img/7257c266-1ae3-45cd-8d12-2fb70bf177ad.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7257c266-1ae3-45cd-8d12-2fb70bf177ad.png)'
- en: Accept the dialog by clicking on the OK button.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击 `OK` 按钮接受对话框。
- en: What just happened?
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'You can see that we have a new file called `Button.qml` in the project, which
    contains everything the button item used to have, with the exception of the `id`
    and `anchors.centerIn` properties. The main file was simplified to the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在项目中有一个名为 `Button.qml` 的新文件，它包含按钮项曾经拥有的所有内容，除了 `id` 和 `anchors.centerIn`
    属性。主文件被简化为以下内容：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Button` has become a component—a definition of a new type of element that
    can be used the same way as standard QML element types. Remember that QML component
    names, as well as names of files representing them, need to begin with a capital
    letter! If you name a file `button.qml` instead of `Button.qml`, then you will
    not be able to use `Button` as a component name, and trying to use "button" will
    result in an error message. This works both ways—every QML file starting with
    a capital letter can be treated as a component definition.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button` 已经成为一个组件——一个新类型元素的定义，可以像标准 QML 元素类型一样使用。记住，QML 组件名称，以及代表它们的文件名称，需要以大写字母开头！如果你将文件命名为
    `button.qml` 而不是 `Button.qml`，那么你将无法将 `Button` 作为组件名称使用，尝试使用 "button" 将会导致错误信息。这同样适用于两种情况——每个以大写字母开头的
    QML 文件都可以被视为组件定义。'
- en: Since we checked `anchors.centerIn` in the dialog, this property was not moved
    to `Button.qml`. The reason for that choice is that our button can be put anywhere,
    so it can't possibly know how it should be positioned. Instead, positioning of
    the button should be done at the location where we use the component. Now we can
    edit `main.qml` to put the button into a layout or use other positioning properties
    without having to change the component's code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在对话框中检查了 `anchors.centerIn`，因此这个属性没有被移动到 `Button.qml`。选择这个方案的原因是我们的按钮可以放在任何地方，所以它不可能知道它应该如何定位。相反，按钮的定位应该在组件使用的地方完成。现在我们可以编辑
    `main.qml`，将按钮放入布局或使用其他定位属性，而无需更改组件的代码。
- en: Importing components
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入组件
- en: A component definition can be used directly by other QML files residing in the
    same directory as the component definition. In our example, the `main.qml` and
    `Button.qml` files are located in the same directory, so you can use the `Button`
    QML type inside `main.qml` without having to import anything.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 组件定义可以直接由位于组件定义同一目录中的其他 QML 文件使用。在我们的例子中，`main.qml` 和 `Button.qml` 文件位于同一目录中，因此你可以在
    `main.qml` 中使用 `Button` QML 类型，而无需进行任何导入。
- en: 'If you need to access a component definition from a file residing elsewhere,
    you will have to first import the module containing the component in the file
    where you want to use it. The definition of a module is very simple—it is just
    a relative path to the *directory* containing QML files. This means that if you
    have a file named `Baz.qml` in a directory called `Base/Foo/Bar` and you want
    to use the `Baz` component from within the  `Base/Foo/Ham.qml` file, you will
    have to put the following import statement in `Ham.qml`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要访问一个位于其他文件中的组件定义，你将不得不首先导入包含该组件的模块，在你想使用它的文件中。模块的定义非常简单——它只是一个指向包含 QML
    文件的 *目录* 的相对路径。这意味着如果你有一个名为 `Baz.qml` 的文件位于名为 `Base/Foo/Bar` 的目录中，并且你想要在 `Base/Foo/Ham.qml`
    文件中使用 `Baz` 组件，你将不得不在 `Ham.qml` 中放置以下导入语句：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want to use the same component from within the `Base/Spam.qml` file,
    you will have to replace the import statement with this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在 `Base/Spam.qml` 文件中使用相同的组件，你必须将导入语句替换为以下内容：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Importing a module makes all its components available for use. You can then
    declare objects of types imported from a certain module.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 导入一个模块会使它的所有组件都可用于使用。然后你可以声明从某个模块导入的类型对象。
- en: QML and virtual resource paths
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML 和虚拟资源路径
- en: Our project uses a Qt resource file to make our QML files embedded into the
    binary and ensure that they are always available to the application, even if the
    source directory is not present at the computer. During startup, we refer to the
    main QML file using the `qrc:/main.qml` URL. This means that the runtime only
    sees the file hierarchy in the resource file, and the actual source directory
    of the project is not taken into account.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目使用 Qt 资源文件将我们的 QML 文件嵌入到二进制文件中，并确保它们始终可用于应用程序，即使源目录在计算机上不存在。在启动期间，我们使用
    `qrc:/main.qml` URL 引用主 QML 文件。这意味着运行时只看到资源文件中的文件层次结构，而不会考虑项目的实际源目录。
- en: The other QML file has the `qrc:/Button.qml` URL, so Qt considers them to be
    in the same virtual directory and everything still works. However, if you create
    a QML file but forget to add it to the project's resources, Qt will be unable
    to load that file. Even if the file is present in the same real directory as `main.qml`,
    Qt will only look for it in the virtual `qrc:/` directory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 QML 文件具有 `qrc:/Button.qml` URL，因此 Qt 将它们视为同一虚拟目录，一切仍然正常。然而，如果你创建了一个 QML
    文件但忘记将其添加到项目的资源中，Qt 将无法加载该文件。即使该文件与 `main.qml` 位于同一真实目录中，Qt 也只会搜索虚拟的 `qrc:/` 目录。
- en: It's possible to add a file to the resources with a prefix, in which case it
    can have an URL like `qrc:/some/prefix/Button.qml`, and the runtime will consider
    it to be in another virtual directory. That being said, unless you explicitly
    create a new prefix, you should be fine. If your QML files are arranged in subdirectories,
    their hierarchy will be preserved when you add them to the resource file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能将带有前缀的文件添加到资源中，在这种情况下，它可以有一个类似于`qrc:/some/prefix/Button.qml`的URL，并且运行时将其视为另一个虚拟目录。话虽如此，除非你明确创建一个新的前缀，否则你应该没问题。如果你的QML文件组织在子目录中，当你将它们添加到资源文件时，它们的层次结构将被保留。
- en: Event handlers
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理器
- en: Qt Quick is meant to be used for creating user interfaces that are highly interactive.
    It offers a number of elements for taking input events from the user. In this
    section, we will go through them and see how you can use them effectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick旨在用于创建高度交互的用户界面。它提供了一些元素来从用户那里获取输入事件。在本节中，我们将介绍它们，并了解如何有效地使用它们。
- en: Time for action – Making the button clickable
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使按钮可点击
- en: So far, our component only looks like a button. The next task is to make it
    respond to mouse input.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的组件看起来就像一个按钮。下一个任务是让它对鼠标输入做出响应。
- en: The `MouseArea` QML type defines a transparent rectangle that exposes a number
    of properties and signals related to mouse input. Commonly used signals include `clicked`, `pressed`,
    and `released`. Let's do a couple of exercises to see how the element can be used.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseArea` QML类型定义了一个透明的矩形，它公开了与鼠标输入相关的多个属性和信号。常用的信号包括`clicked`、`pressed`和`released`。让我们做一些练习，看看这个元素如何使用。'
- en: 'Open the `Button.qml` file and add a `MouseArea` child item to the button and
    use anchors to make it fill the whole area of the button. Call the element `buttonMouseArea`.
    Put the following code in the body of the item:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Button.qml`文件，并将一个`MouseArea`子项添加到按钮中，使用锚点使其填充按钮的整个区域。将此元素命名为`buttonMouseArea`。在项的主体中放入以下代码：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In addition to this, set the following declaration in the button object just
    after its ID is declared:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在按钮对象中ID声明之后设置以下声明：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To test the modification, go to the `main.qml` file and add a signal handler
    to the button:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试修改，请转到`main.qml`文件并为按钮添加一个信号处理器：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, run the program and click on the button. You'll see your message printed
    to the Qt Creator's console.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行程序并点击按钮。你会在Qt Creator的控制台中看到你的消息被打印出来。
- en: What just happened?
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: With the `signal clicked()` statement, we declared that the button object can
    emit a signal called `clicked`. With the `MouseArea` item, we defined a rectangular
    area (covering the whole button) that reacts to mouse events. Then, we defined `onClicked`,
    which is a signal handler. For every signal an object has, a script can be bound
    to a handler named like the signal and prefixed with "on"; hence, for the `clicked` signal,
    the handler is called `onClicked`, and, for `valueChanged`, it is called `onValueChanged`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`signal clicked()`语句，我们声明按钮对象可以发出一个名为`clicked`的信号。使用`MouseArea`项，我们定义了一个矩形区域（覆盖整个按钮），它对鼠标事件做出反应。然后，我们定义了`onClicked`，这是一个信号处理器。对于对象拥有的每个信号，都可以将一个脚本绑定到以信号名称命名并以前缀“on”开头的处理器；因此，对于`clicked`信号，处理器被调用为`onClicked`，对于`valueChanged`，它被调用为`onValueChanged`。
- en: In this particular case, we have two handlers defined—one for the button where
    we write a simple statement to the console, and the other for the `MouseArea` element
    where we call the button's signal function, effectively emitting that signal.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们定义了两个处理器——一个用于按钮，我们在控制台中写入一个简单的语句；另一个用于`MouseArea`元素，我们调用按钮的信号函数，实际上发出了该信号。
- en: '`MouseArea` has even more features, so now let''s try putting them to the right
    use to make our button more feature-rich.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseArea`具有更多功能，因此现在让我们尝试正确使用它们，使我们的按钮功能更丰富。'
- en: Time for action – Visualizing button states
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 可视化按钮状态
- en: 'Currently, there is no visual reaction to clicking on the button. In the real
    world, the button has some depth and when you push it and look at it from above,
    its contents seems to shift a little toward the right and downward. Let''s mimic
    this behavior by making use of the pressed property `MouseArea` has, which denotes
    whether the mouse button is currently being pressed (note that the pressed property
    is different from the pressed signal that was mentioned earlier). The content
    of the button is represented by the `Row` element, so add the following statements
    inside its definition:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，点击按钮时没有视觉反应。在现实世界中，按钮有一定的深度，当你按下它并从上方看时，其内容似乎会稍微向右和向下移动。让我们通过利用 `MouseArea`
    具有的表示鼠标按钮是否当前被按下的 `pressed` 属性来模拟这种行为（注意，`pressed` 属性与之前提到的 `pressed` 信号不同）。按钮的内容由
    `Row` 元素表示，因此在其定义内添加以下语句：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also make the text change color when the mouse cursor hovers over the
    button. For this, we have to do two things. First, let''s enable receiving hover
    events on the `MouseArea` by setting its `hoverEnabled` property:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在鼠标光标悬停在按钮上时改变文本颜色。为此，我们必须做两件事。首先，让我们通过设置 `MouseArea` 的 `hoverEnabled`
    属性来启用接收悬停事件：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When this property is set, `MouseArea` will be setting its `containsMouse` property
    to `true` whenever it detects the mouse cursor over its own area. We can use this
    value to set the text color:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当此属性被设置时，`MouseArea` 将在检测到鼠标光标在其自身区域上方时，将其 `containsMouse` 属性设置为 `true`。我们可以使用这个值来设置文本颜色：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What just happened?
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'In the last exercise, we learned to use some properties and signals from `MouseArea` to
    make the button component more interactive. However, the element is much richer
    in features. In particular, if hover events are enabled, you can get the current
    mouse position in the item''s local coordinate system through the `mouseX` and `mouseY` properties
    that return values. The cursor position can also be reported by handling the `positionChanged` signal.
    Speaking of signals, most `MouseArea` signals carry a `MouseEvent` object as their
    argument. This argument is called `mouse` and contains useful information about
    the current state of the mouse, including its position and buttons currently pressed.
    By default, `MouseArea` only reacts to the left mouse button, but you can use the `acceptedButtons` property
    to select which buttons it should handle. These features are shown in the following
    example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个练习中，我们学习了如何使用 `MouseArea` 的一些属性和信号来使按钮组件更具交互性。然而，该元素具有更多功能。特别是，如果启用了悬停事件，你可以通过返回值的
    `mouseX` 和 `mouseY` 属性在项目的局部坐标系中获取当前鼠标位置。也可以通过处理 `positionChanged` 信号来报告光标位置。说到信号，大多数
    `MouseArea` 信号都携带一个 `MouseEvent` 对象作为其参数。这个参数被称为 `mouse`，并包含有关鼠标当前状态的有用信息，包括其位置和当前按下的按钮。默认情况下，`MouseArea`
    只对左键鼠标按钮做出反应，但你可以使用 `acceptedButtons` 属性来选择它应该处理哪些按钮。以下示例展示了这些功能：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Time for action – Notifying the environment about button states
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 - 通知环境按钮状态
- en: We have added some code to make the button look more natural by changing its
    visual aspects. Now, let's extend the button programming interface so that developers
    can use more features of the button.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些代码，通过改变其视觉特性使按钮看起来更自然。现在，让我们扩展按钮编程接口，以便开发者可以使用更多按钮功能。
- en: 'The first thing we can do is make button colors definable by introducing some
    new properties for the button. Let''s put the highlighted code at the beginning
    of the button component definition:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是通过引入一些新的属性来使按钮颜色可定义。让我们将高亮代码放在按钮组件定义的开始部分：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we''ll use the new definitions for the background gradient:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用新的背景渐变定义：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now for the text color:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是文本颜色：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can note, we used the `pressed` property of `MouseArea` to detect whether
    a mouse button is currently being pressed on the area. We can equip our button
    with a similar property. Add the following code to the top level `Rectangle` of
    the `Button` component:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，我们使用了 `MouseArea` 的 `pressed` 属性来检测当前是否在区域上按下鼠标按钮。我们可以给我们的按钮配备一个类似的属性。将以下代码添加到
    `Button` 组件的顶级 `Rectangle` 中：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What just happened?
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The first set of changes introduced four new properties defining four colors
    that we later used in statements defining gradient and text colors for the button.
    In QML, you can define new properties for objects with the `property` keyword.
    The keyword should be followed by the property type and property name. QML understands
    many property types, the most common being `int`, `real`, `string`, `font`, and `color`.
    Property definitions can contain an optional default value for the property, preceded
    with a colon. The situation is different with the pressed property definition.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组更改引入了四个新属性，定义了四种颜色，我们在稍后用于定义按钮的渐变和文本颜色的语句中使用了这些颜色。在QML中，您可以使用`property`关键字为对象定义新属性。关键字后面应跟属性类型和属性名。QML理解许多属性类型，最常见的是`int`、`real`、`string`、`font`和`color`。属性定义可以包含一个可选的默认值，用冒号开头。对于按下属性的定义，情况则不同。
- en: You can see that for the property type, the definition contains the word `alias`.
    It is not a property type but an indicator that the property is really an alias
    to another property—each time the `pressed` property of the button is accessed,
    the value of the `buttonMouseArea.pressed` property is returned, and every time
    the property is changed, it is the mouse area's property that really gets changed.
    With a regular property declaration, you can provide any valid expression as the
    default value because the expression is bound to the property. With a property
    alias, it is different—the value is mandatory and has to be pointing to an existing
    property of the same or another object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，对于属性类型，定义中包含单词`alias`。它不是一个属性类型，而是一个指示符，表示该属性实际上是另一个属性的别名——每次访问按钮的`pressed`属性时，都会返回`buttonMouseArea.pressed`属性的值，并且每次属性值改变时，实际上是鼠标区域的属性发生了变化。使用常规属性声明时，您可以提供任何有效的表达式作为默认值，因为表达式绑定到属性上。而对于属性别名，情况则不同——值是强制性的，并且必须指向相同或另一个对象中存在的属性。
- en: 'Consider the following two definitions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个定义：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At first glance, they are similar as they point to the same property and therefore
    the values returned for the properties are the same. However, the properties are
    really very different, which becomes apparent if you try to modify their values:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，它们似乎很相似，因为它们指向相同的属性，因此返回的属性值也相同。然而，实际上这两个属性非常不同，如果您尝试修改它们的值，这一点就会变得明显：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first property actually has an expression bound to it, so assigning `7` to `foo` simply
    releases the binding and assigns the value `7` to the `foo` property, leaving `someobject.prop` with
    its original value. The second statement, however, is an alias; therefore, assigning
    a new value applies the modification to the `someobject.prop` property the alias
    is really pointing to.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性实际上绑定了一个表达式，因此将`7`赋值给`foo`只是释放了绑定，并将值`7`赋给`foo`属性，而`someobject.prop`保持其原始值。然而，第二个语句是一个别名；因此，赋值新值将修改应用到别名实际指向的`someobject.prop`属性。
- en: 'Speaking of properties, there is an easy way to react when a property value
    is modified. For each existing property, there is a handler available that is
    executed whenever the property value is modified. The handler name is `on` followed
    by the property name, then followed by the word `Changed`, all in camel case—thus,
    for a `foo` property, it becomes `onFooChanged` and for `topColor`, it becomes `onTopColorChanged`.
    To log the current press state of the button to the console, all we need to do
    is implement the property change handler for this property:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到属性，当属性值被修改时，有一个简单的方法可以做出反应。对于每个现有的属性，都有一个处理程序可用，每当属性值被修改时就会执行。处理程序名称是`on`后跟属性名，然后是单词`Changed`，全部使用驼峰式命名法——因此，对于`foo`属性，它变为`onFooChanged`，对于`topColor`，它变为`onTopColorChanged`。要将按钮的当前按下状态记录到控制台，我们只需要为这个属性实现属性更改处理程序：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we created a fully functional custom QML component. Our button
    reacts to mouse input and exposes some useful properties and signals to the user.
    This makes it a reusable and customizable object. In a real project, always think
    of the repeating parts of your UI and consider moving them into a single component
    to reduce code duplication.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个功能齐全的自定义QML组件。我们的按钮能够响应鼠标输入，并向用户公开一些有用的属性和信号。这使得它成为一个可重用和可定制的对象。在实际项目中，始终考虑UI中的重复部分，并考虑将它们移动到单个组件中，以减少代码重复。
- en: Touch input
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸输入
- en: '`MouseArea` is the simplest of input event elements. Nowadays, more and more
    devices have touch capabilities and Qt Quick can handle them as well. Currently,
    we have three ways of handling touch input.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseArea` 是输入事件元素中最简单的。如今，越来越多的设备具有触摸功能，Qt Quick 也能处理它们。目前，我们有三种处理触摸输入的方法。'
- en: First of all, simple touch events are also reported as mouse events. Tapping
    and sliding a finger on the screen can be handled using `MouseArea`, just like
    mouse input.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，简单的触摸事件也被报告为鼠标事件。在屏幕上轻触和滑动手指可以使用 `MouseArea` 处理，就像鼠标输入一样。
- en: Time for action – Dragging an item around
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 - 在周围拖动项
- en: 'Create a new Qt Quick Application - Empty project. Edit the `main.qml` file
    to add a circle to the window:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Qt Quick 应用程序 - 空项目。编辑 `main.qml` 文件，向窗口添加一个圆圈：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, add a `MouseArea` to the circle and use its `drag` property to enable
    moving the circle by touch (or mouse):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向圆圈添加一个 `MouseArea` 并使用其 `drag` 属性通过触摸（或鼠标）启用圆圈的移动：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, you can start the application and begin moving the circle around.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以启动应用程序并开始移动圆圈。
- en: What just happened?
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: A circle was created by defining a rectangle with its height equal to width,
    making it a square and rounding the borders to half the side length. The `drag` property
    can be used to tell `MouseArea` to manage a given item's position using input
    events flowing into this `MouseArea` element. We denote the item to be dragged
    using the `target` subproperty. You can use other subproperties to control the
    axis the item is allowed to move along or constrain the move to a given area.
    An important thing to remember is that the item being dragged cannot be anchored
    for the axis on which the drag is requested; otherwise, the item will respect
    the anchor and not the drag. We didn't anchor our circle item at all since we
    want it to be draggable along both axes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个高度等于宽度的矩形来创建一个圆圈，使其成为正方形，并将边框圆滑到边长的一半。可以使用 `drag` 属性来告诉 `MouseArea` 使用输入事件来管理给定项的位置，这些事件流入此
    `MouseArea` 元素。我们使用 `target` 子属性来表示要拖动的项。您可以使用其他子属性来控制项可以移动的轴或限制移动到给定区域。需要记住的一个重要事情是，正在拖动的项不能在请求拖动的轴上锚定；否则，项将尊重锚点而不是拖动。我们没有将圆圈项锚定，因为我们希望它可以在两个轴上拖动。
- en: 'The second approach to handling touch input in Qt Quick applications is to
    use `PinchArea`, which is an item similar to `MouseArea`, but rather than dragging
    an item around, it allows you to rotate or scale it using two fingers (with a
    so called "pinch" gesture), as shown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 Qt Quick 应用程序中触摸输入的第二种方法是使用 `PinchArea`，它是一个类似于 `MouseArea` 的项，但不是拖动项，而是允许您使用两个手指（所谓的“捏合”手势）旋转或缩放它，如图所示：
- en: '![](img/aceb744d-bcdc-470b-b636-76654417b369.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aceb744d-bcdc-470b-b636-76654417b369.png)'
- en: Be aware that `PinchArea` reacts only to touch input, so to test the example,
    you will need a real multitouch capable device.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`PinchArea` 只对触摸输入做出反应，因此要测试示例，您需要一个真正的多点触控设备。
- en: Time for action – Rotating and scaling a picture by pinching
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 - 通过捏合旋转和缩放图片
- en: 'Start a new Qt Quick Application - Empty project. Add an image file to the
    resources, just like we previously did in the button project. In the `main.qml` file,
    add an image to the window and make it centered in its parent:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的 Qt Quick 应用程序 - 空项目。向资源中添加一个图像文件，就像我们在之前的按钮项目中做的那样。在 `main.qml` 文件中，向窗口添加一个图像并将其居中在其父元素中：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we will add a `PinchArea` element. This kind of item can be used in two
    ways—either by manually implementing signal handlers `onPinchStarted`, `onPinchUpdated`,
    and `onPinchFinished` to have total control over the functionality of the gesture,
    or using a simplified interface similar to the `drag` property of `MouseArea`.
    Since the simplified interface does exactly what we want, there is no need to
    handle pinch events manually. Let''s add the following declaration to the file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个 `PinchArea` 元素。这种类型的项可以用两种方式使用——要么通过手动实现信号处理程序 `onPinchStarted`、`onPinchUpdated`
    和 `onPinchFinished` 来完全控制手势的功能，要么使用类似于 `MouseArea` 的 `drag` 属性的简化接口。由于简化接口正好符合我们的需求，因此不需要手动处理捏合事件。让我们将以下声明添加到文件中：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You''ll get an output similar to the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下截图类似的输出：
- en: '![](img/12e68796-9807-4696-93d9-c65d6fdf5c94.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12e68796-9807-4696-93d9-c65d6fdf5c94.png)'
- en: What just happened?
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: Our simple application loads an image and centers it in the view. Then, there
    is a `PinchArea` item filling the view area that is told to operate on the image
    object. We define the range of the scaling and rotating of the item. The rest
    is left to the `PinchArea` item itself. If you start interacting with the application,
    you will see the item rotate and scale. What really happens behind the scenes
    is that `PinchArea` modifies the values of the two properties each Qt Quick item
    has—`rotation` and `scale`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的应用程序加载一张图片并将其在视图中居中。然后，有一个`PinchArea`项目填充视图区域，它被指示对图像对象进行操作。我们定义了项目缩放和旋转的范围。其余的由`PinchArea`项目本身处理。如果你开始与该应用程序交互，你会看到项目旋转和缩放。实际上幕后的操作是`PinchArea`修改了每个Qt
    Quick项目所拥有的两个属性值——`rotation`和`scale`。
- en: '`PinchArea` can also control the dragging of the item with `pinch.dragAxis`,
    just like `MouseArea` does with drag, but for simplicity, we didn''t use this
    part of the API. Feel free to experiment with it in your own code.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`PinchArea`也可以通过`pinch.dragAxis`控制项目的拖动，就像`MouseArea`通过拖动一样，但为了简单起见，我们没有使用这个API的部分。请随意在你的代码中实验它。'
- en: Have a go hero – Rotating and scaling with a mouse
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战英雄——使用鼠标旋转和缩放
- en: Of course, you don't have to use `PinchArea` to rotate or scale an item. Properties
    controlling those aspects are regular properties that you can read and write at
    any time. Try replacing `PinchArea` with `MouseArea` to obtain a result similar
    to what we just did by modifying the scale and rotation properties as a result
    of receiving mouse events—when the user drags the mouse while pressing the left
    button, the image is scaled and when the user does the same while pressing the
    right button, the image is rotated.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必使用`PinchArea`来旋转或缩放项目。控制这些方面的属性是常规属性，你可以在任何时候读取和写入它们。尝试将`PinchArea`替换为`MouseArea`，以获得类似我们刚刚通过修改缩放和旋转属性来修改的结果——当用户在按下左键的同时拖动鼠标时，图像被缩放；当用户在按下右键的同时做同样的事情时，图像被旋转。
- en: If you manage to do the task, try replacing `MouseArea` with `PinchArea` again,
    but then, instead of using the `pinch` property, handle events manually to obtain
    the same effect (the event object is called `pinch` and has a number of properties
    you can play with).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了这个任务，尝试再次将`MouseArea`替换为`PinchArea`，但这次，不是使用`pinch`属性，而是手动处理事件以获得相同的效果（事件对象称为`pinch`，它具有许多你可以操作的属性）。
- en: A third approach to handling touch input is using the `MultiPointTouchArea` item.
    It provides a low-level interface to gestures by reporting each touch point separately.
    It can be used to create custom high-level gesture handlers similar to `PinchArea`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 处理触摸输入的第三种方法是使用`MultiPointTouchArea`项目。它通过分别报告每个触摸点提供对手势的低级接口。它可以用来创建类似于`PinchArea`的自定义高级手势处理器。
- en: Keyboard input
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘输入
- en: So far, we've been dealing with pointer input, but user input is not just that—we
    can also handle keyboard input. This is quite simple and basically boils down
    to two easy steps.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理指针输入，但用户输入不仅仅是那样——我们还可以处理键盘输入。这相当简单，基本上可以归结为两个简单的步骤。
- en: 'First, you have to enable receiving keyboard events by stating that a particular
    item has keyboard focus:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须通过声明特定项目具有键盘焦点来启用接收键盘事件：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, you can start handling events by writing handlers in a similar fashion
    as for mouse events. However, `Item` doesn't provide its own handler for manipulating
    keys that is a counterpart for `keyPressEvent` and `keyReleaseEvent` of `QWidget`.
    Instead, adequate handlers are provided by the `Keys` attached property.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过以类似鼠标事件的方式编写处理程序来开始处理事件。然而，`Item`没有提供自己的处理程序来操作键，这是`QWidget`的`keyPressEvent`和`keyReleaseEvent`的对应物。相反，`Keys`附加属性提供了适当的处理程序。
- en: Attached properties are provided by elements that are not used as standalone
    elements but provide properties to other objects by getting attached to them as
    well. This is a way of adding support for new properties without modifying the
    API of the original element (it doesn't add new properties through an **is-a** relation,
    but rather through a **has-a** one). Each object that references an attached property
    gets its own copy of the attaching object that then handles the extra properties.
    We will come back to attached properties later in the chapter. For now, you just
    need to remember that in certain situations, an element can obtain additional
    properties that are not part of its API.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 附加属性是由不作为独立元素使用但通过附加到其他对象来提供属性的元素提供的。这是在不修改原始元素API的情况下添加对新属性支持的一种方式（它不是通过一个**is-a**关系添加新属性，而是通过一个**has-a**关系）。每个引用附加属性的对象都会获得一个附加对象的副本，然后处理额外的属性。我们将在本章的后面回到附加属性。现在，你只需要记住，在某些情况下，一个元素可以获取不属于其API的附加属性。
- en: 'Let''s go back to implementing event handlers for keyboard input. As we said
    earlier, each Item has a `Keys` attached property that allows us to install our
    own keyboard handlers. The basic two signals `Keys` adds to `Item` are `pressed`
    and `released`; therefore, we can implement the `onPressed` and `onReleased` handlers
    that have a `KeyEvent` argument providing similar information as `QKeyEvent` in
    the widget world. As an example, we can see an item that detects when the spacebar
    was pressed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到实现键盘输入的事件处理器。正如我们之前所说的，每个Item都有一个名为`Keys`的附加属性，它允许我们安装自己的键盘处理器。`Keys`为`Item`添加的基本两个信号是`pressed`和`released`；因此，我们可以实现带有`KeyEvent`参数的`onPressed`和`onReleased`处理器，这些参数提供的信息与在控件世界中`QKeyEvent`类似。作为一个例子，我们可以看到一个检测空格键被按下的项目：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It might become problematic if you want to handle many different keys in the
    same item, as the `onPressed` handler would likely contain a giant switch section
    with branches for every possible key. Fortunately, `Keys` offers more properties.
    Most of the commonly used keys (but not letters) have their own handlers that
    are called when the particular key is pressed. Thus, we can easily implement an
    item that takes a different color depending on which key was pressed last:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在同一个项目中处理许多不同的键，这可能会变得有问题，因为`onPressed`处理器可能包含一个巨大的switch部分，为每个可能的键提供分支。幸运的是，`Keys`提供了更多的属性。大多数常用的键（但不是字母）都有它们自己的处理器，当特定键被按下时会被调用。因此，我们可以轻松实现一个项目，根据最后按下的键来改变不同的颜色：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the `released` signal will still be emitted for every released key
    even if the key has its own pressed signal.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使键有自己的按下信号，`released`信号也会为每个释放的键发出。
- en: 'Now, consider another example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑另一个例子：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We would expect that when we press and hold the spacebar, we will see the text
    change from `0` to `1` and stay on that value until we release the key. If you
    run the example, you will see that instead, the number keeps incrementing as long
    as you hold down the key. This is because by default, the keys autorepeat—when
    you hold the key, the operating system keeps sending a sequence of press-release
    events for the key (you can verify that by adding the `console.log()` statements
    to the `Keys.onPressed` and `Keys.onReleased` handlers). To counter this effect,
    you can differentiate between autorepeat and regular events. In Qt Quick, you
    can do this easily, as each key event carries the appropriate information. Simply
    replace the handler from the last example with the following one:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预期当我们按下并保持空格键时，我们会看到文本从`0`变为`1`并保持在那个值，直到我们释放键。如果你运行示例，你会看到相反的情况，数字会一直增加，只要你按住键。这是因为默认情况下，键会自动重复——当你按住键时，操作系统会持续发送一系列的按键-释放事件（你可以通过在`Keys.onPressed`和`Keys.onReleased`处理器中添加`console.log()`语句来验证这一点）。为了抵消这种效果，你可以区分自动重复和常规事件。在Qt
    Quick中，你可以轻松地做到这一点，因为每个按键事件都携带适当的信息。只需用以下处理器替换上一个示例中的处理器：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The event variable we use here is the name of the parameter of the `spacePressed` signal.
    As we cannot declare our own names for the parameters like we can do in C++, for
    each signal handler, you will have to look up the name of the argument in the
    documentation. You can search for `Keys` in the documentation index to open the Keys
    QML Type page. The signal list will contain type and name of the signal's parameter,
    for example, `spacePressed(KeyEvent event)`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的事件变量是 `spacePressed` 信号的参数名称。由于我们无法像在 C++ 中那样为参数声明自己的名称，对于每个信号处理程序，您将不得不在文档中查找参数的名称。您可以在文档索引中搜索
    `Keys` 以打开 `Keys QML 类型` 页面。信号列表将包含信号参数的类型和名称，例如，`spacePressed(KeyEvent event)`。
- en: 'Whenever you process an event, you should mark it as accepted to prevent it
    from being propagated to other elements and handled by them:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理事件时，您应该将其标记为已接受，以防止其传播到其他元素并由它们处理：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, if you use a handler dedicated to an individual button (like `onSpacePressed`),
    you don't need to accept the event, as Qt will do that for you automatically.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您使用针对单个按钮的专用处理程序（如 `onSpacePressed`），则不需要接受事件，因为 Qt 会自动为您处理。
- en: 'In standard C++ applications, we usually use the *Tab* key to navigate through
    focusable items. With games (and fluid user interfaces in general), it is more
    common to use arrow keys for item navigation. Of course, we can handle this situation
    using the `Keys` attached property and adding `Keys.onRightPressed`, `Keys.onTabPressed`,
    and other signal handlers to each of our items where we want to modify the focus
    property of the desired item, but it would quickly clutter our code. Qt Quick
    comes to our help once again by providing a `KeyNavigation` attached property,
    which is meant to handle this specific situation and allows us to greatly simplify
    the needed code. Now, we can just specify which item should get into focus when
    a specific key is triggered:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的 C++ 应用程序中，我们通常使用 *Tab* 键在可聚焦项之间导航。在游戏（以及通用的流体用户界面）中，更常见的是使用箭头键进行项目导航。当然，我们可以通过使用
    `Keys` 附加属性，并为每个我们想要修改所需项目焦点属性的项添加 `Keys.onRightPressed`、`Keys.onTabPressed` 和其他信号处理程序来处理这种情况，但这会使我们的代码很快变得杂乱。Qt
    Quick 再次伸出援手，通过提供 `KeyNavigation` 附加属性，旨在处理这种特定情况，并允许我们极大地简化所需的代码。现在，我们只需指定在触发特定键时哪个项目应该获得焦点：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we made the first item get into focus in the beginning by explicitly
    setting the `focus` property. By setting the `KeyNavigation.right` property, we
    instruct Qt to focus on the specified item when this item receives a right key
    press event. The reverse transition is added automatically—when the left key is
    pressed on the second item, the first item will receive focus. Besides `right`,
    `KeyNavigation` contains the `left`, `down`, `up`, `tab`, and `backtab` (*Shift*
    + *Tab*) properties.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过显式设置 `focus` 属性，使第一个项目在开始时获得焦点。通过设置 `KeyNavigation.right` 属性，我们指示 Qt
    在此项目接收到右键按下事件时关注指定的项目。反向转换会自动添加——当在第二个项目上按下左键时，第一个项目将获得焦点。除了 `right`，`KeyNavigation`
    还包含 `left`、`down`、`up`、`tab` 和 `backtab` (*Shift* + *Tab*) 属性。
- en: Both the `Keys` and `KeyNavigation` attached properties have a way to define
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Keys` 和 `KeyNavigation` 附加属性都有一种定义的方式'
- en: the order in which each of the mechanisms receive the events. This is handled
    by the `priority` property, which can be set to either `BeforeItem` or `AfterItem`.
    By default, `Keys` will get the event first (`BeforeItem`), then the internal
    event handling can take place and finally, `KeyNavigation` will have a chance
    of handling the event (`AfterItem`). Note that if the key is handled by one of
    the mechanisms, the event is accepted and the remaining mechanisms will not receive
    that event.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每个机制接收事件顺序。这由 `priority` 属性处理，可以设置为 `BeforeItem` 或 `AfterItem`。默认情况下，`Keys`
    将首先获取事件（`BeforeItem`），然后进行内部事件处理，最后 `KeyNavigation` 将有机会处理该事件（`AfterItem`）。请注意，如果事件被其中一个机制处理，则事件被接受，其余机制将不会收到该事件。
- en: Have a go hero – Practicing key-event propagation
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄——练习键事件传播
- en: As an exercise, you can expand our last example by building a larger array of
    items (you can use the `Grid` element to position them) and defining a navigation
    system that makes use of the `KeyNavigation` attached property. Have some of the
    items handle events themselves using the `Keys` attached property. See what happens
    when the same key is handled by both mechanisms. Try influencing the behavior
    using the `priority` property.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以通过构建一个更大的项目数组（你可以使用`Grid`元素来定位它们）并定义一个使用`KeyNavigation`附加属性的导航系统来扩展我们最后的例子。让一些项目使用`Keys`附加属性自行处理事件。看看当相同的键由两种机制处理时会发生什么。尝试使用`priority`属性来影响行为。
- en: When you set the `focus` property of an item to `true`, any previously used
    item loses focus. This becomes a problem when you try to write a reusable component
    that needs to set focus to its children. If you add multiple instances of such
    a component to a single window, their focus requests will conflict with each other.
    Only the last item will have focus because it was created last. To overcome this
    problem, Qt Quick introduces a concept of **focus scopes**. By wrapping your component
    into a `FocusScope` item, you gain ability to set focus to an item inside the
    component without influencing the global focus directly. When an instance of your
    component receives focus, the internal focused item will also receive focus and
    will be able to handle keyboard events. A good explanation of this feature is
    given on the Keyboard Focus in Qt Quick documentation page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将项目的`focus`属性设置为`true`时，任何之前使用的项目都会失去焦点。当你尝试编写一个需要将其子项设置为焦点的可重用组件时，这会成为一个问题。如果你将此类组件的多个实例添加到单个窗口中，它们的焦点请求将相互冲突。只有最后一个创建的项目将具有焦点，因为它是最先创建的。为了克服这个问题，Qt
    Quick引入了**焦点域**的概念。通过将你的组件包裹在一个`FocusScope`项目中，你将获得在组件内部设置焦点而不直接影响全局焦点的能力。当你的组件实例收到焦点时，内部聚焦的项目也将收到焦点，并将能够处理键盘事件。关于此功能的良好解释可以在Qt
    Quick中的键盘焦点文档页面上找到。
- en: Text input fields
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本输入字段
- en: 'Apart from the attached properties we described, Qt Quick provides built-in
    elements for handling keyboard input. The two most basic types are `TextInput` and `TextEdit`,
    which are QML equivalents of `QLineEdit` and `QTextEdit`. The former are used
    for single-line text input, while the latter serves as its multiline counterpart.
    They both offer cursor handling, undo-redo functionality, and text selections.
    You can validate text typed into `TextInput` by assigning a validator to the `validator` property.
    For example, to obtain an item where the user can input a dot-separated IP address,
    we can use the following declaration:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们描述的附加属性之外，Qt Quick还提供了处理键盘输入的内置元素。其中两种最基本类型是`TextInput`和`TextEdit`，它们是`QLineEdit`和`QTextEdit`的QML等价物。前者用于单行文本输入，而后者作为其多行对应物。它们都提供光标处理、撤销-重做功能和文本选择。你可以通过将验证器分配给`validator`属性来验证`TextInput`中输入的文本。例如，为了获取一个用户可以输入点分隔IP地址的项目，我们可以使用以下声明：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The regular expression only verifies the format of the address. The user can
    still insert bogus numbers. You should either do a proper check before using the
    address or provide a more complex regular expression that will constrain the range
    of numbers the user can enter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式仅验证地址的格式。用户仍然可以插入无效的数字。你应该在使用地址之前进行适当的检查，或者提供一个更复杂的正则表达式，以限制用户可以输入的数字范围。
- en: 'One thing to remember is that neither `TextInput` nor `TextEdit` has any visual
    appearance (apart from the text and cursor they contain), so if you want to give
    the user some visual hint as to where the item is positioned, the easiest solution
    is to wrap it in a styled rectangle:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，无论是`TextInput`还是`TextEdit`都没有任何视觉外观（除了它们包含的文本和光标），因此如果你想要给用户一些视觉提示以表明项目所在的位置，最简单的解决方案是将它包裹在一个样式化的矩形中：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the highlighted code—the `clip` property of `textInput`—is enabled
    such that by default, if the text entered in the box doesn't fit in the item,
    it will overflow it and remain visible outside the actual item. By enabling clipping,
    we explicitly say that anything that doesn't fit the item should not be drawn.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，高亮显示的代码——`textInput`的`clip`属性——被启用，这样默认情况下，如果框中输入的文本不适合项目，它将溢出并保持可见，超出实际项目之外。通过启用裁剪，我们明确表示任何不适合项目的任何内容都不应该被绘制。
- en: '![](img/b2e5449b-d3b5-4db5-a7b5-089516765a84.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2e5449b-d3b5-4db5-a7b5-089516765a84.png)'
- en: The `QtQuick.Controls` module provides more advanced text input controls, such
    as `TextField` and `TextArea`. We've already used them in our project in [Chapter
    11](b81d9c47-58fa-49dd-931a-864c7be05840.xhtml), *Introduction to Qt Quick*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtQuick.Controls` 模块提供了更高级的文本输入控件，例如 `TextField` 和 `TextArea`。我们已经在 [第 11
    章](b81d9c47-58fa-49dd-931a-864c7be05840.xhtml)，*Qt Quick 简介* 中使用了它们。'
- en: Gamepad input
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏手柄输入
- en: Handling gamepad events is a very common task when developing a game. Fortunately,
    Qt provides Qt Gamepad module for this purpose. We already learned how to use
    it in C++. Now let's see how to do this in QML applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 处理游戏手柄事件是在开发游戏时一个非常常见的任务。幸运的是，Qt 提供了 Qt Gamepad 模块来实现这一目的。我们已经在 C++ 中学习了如何使用它。现在让我们看看如何在
    QML 应用程序中实现这一点。
- en: 'To enable Qt Gamepad module, add `QT += gamepad` to the project file. Next,
    import the QML module by adding the following line at the beginning of your QML
    file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 Qt Gamepad 模块，请在项目文件中添加 `QT += gamepad`。接下来，在您的 QML 文件开头添加以下行以导入 QML 模块：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This import allows you to declare objects of the `Gamepad` type. Add the following
    object inside your top-level QML object:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此导入允许您声明 `Gamepad` 类型的对象。在您的顶级 QML 对象内部添加以下对象：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `GamepadManager` object allows us to list identifiers of gamepads available
    in the system. We use the first available gamepad if any are present in the system.
    If you want the game to pick up a connected gamepad on the fly, use the following
    code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamepadManager` 对象允许我们列出系统中可用的游戏手柄标识符。如果系统中存在任何游戏手柄，我们将使用第一个可用的游戏手柄。如果您希望游戏动态地拾取连接的游戏手柄，请使用以下代码片段：'
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What just happened?
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The preceding code simply adds a signal handler for the `gamepadConnected` signal
    of the `GamepadManager` object. The usual way to add a signal handler is to declare
    it directly in the section of the sender. However, we can't do that in this case,
    since  `GamepadManager` is an existing global object that is not part of our QML
    object tree. Thus, we use the `Connections` QML type that allows us to specify
    an arbitrary sender (using the `target` property) and attach a signal handler
    to it. You can think of `Connections` as a declarative version of `QObject::connect`
    calls.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅为 `GamepadManager` 对象的 `gamepadConnected` 信号添加了一个信号处理器。通常，添加信号处理器的做法是直接在发送者的部分声明它。然而，在这种情况下我们无法这样做，因为
    `GamepadManager` 是一个现有的全局对象，它不属于我们的 QML 对象树。因此，我们使用 `Connections` QML 类型，它允许我们指定一个任意的发送者（使用
    `target` 属性）并将其信号处理器附加到它。您可以将 `Connections` 视为 `QObject::connect` 调用的声明性版本。
- en: The initialization is done, so we can now use the `gamepad` object to request
    information about the gamepad input. There are two ways to do that.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化已完成，因此我们现在可以使用 `gamepad` 对象来请求有关游戏手柄输入的信息。有两种方法可以实现这一点。
- en: 'First, we can use property bindings to set properties of other objects depending
    on the buttons pressed on the gamepad:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用属性绑定来根据游戏手柄上按下的按钮设置其他对象的属性：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Whenever the start button is pressed or released on the gamepad, the value of
    the `gamepad.buttonStart` property will be set to `true` or `false`, and the QML
    engine will automatically update the displayed text.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在游戏手柄上按下或释放开始按钮时，`gamepad.buttonStart` 属性的值将被设置为 `true` 或 `false`，并且 QML 引擎将自动更新显示的文本。
- en: 'The second way is to add a signal handler to detect when a property changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是添加一个信号处理器来检测属性何时发生变化：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Gamepad` QML type has a separate property and signal for each gamepad button,
    just like the `QGamepad` C++ class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gamepad` QML 类型为每个游戏手柄按钮都提供了一个单独的属性和信号，就像 `QGamepad` C++ 类一样。'
- en: 'You can also use the `GamepadKeyNavigation` QML type to introduce gamepad support
    to a game that supports keyboard input:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `GamepadKeyNavigation` QML 类型将游戏手柄支持引入支持键盘输入的游戏：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When this object is declared in your QML file, gamepad events provided by the `gamepad`
    object will be automatically converted to key events. By default, `GamepadKeyNavigation`
    is able to emulate up, down, left, right, back, forward, and return keys when
    the corresponding gamepad buttons are pressed. However, you can override the default
    mapping or add your own mapping for other gamepad buttons. In the preceding example,
    we tell `GamepadKeyNavigation` that the start key on the gamepad should act as
    if the *S* key was pressed on the keyboard. You can now handle these events just
    as any regular keyboard event.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当在您的 QML 文件中声明此对象时，`gamepad` 对象提供的游戏手柄事件将自动转换为按键事件。默认情况下，`GamepadKeyNavigation`
    能够在按下相应的游戏手柄按钮时模拟上、下、左、右、后退、前进和回车键。但是，您可以覆盖默认映射或为其他游戏手柄按钮添加自己的映射。在上面的示例中，我们告诉
    `GamepadKeyNavigation`，游戏手柄上的开始键应像按下键盘上的 *S* 键一样工作。现在您可以像处理任何常规键盘事件一样处理这些事件。
- en: Sensor input
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传感器输入
- en: Qt is reaching out to more and more platforms that are used nowadays. This includes
    a number of popular mobile platforms. Mobile devices are usually equipped with
    additional hardware, less often seen on desktop systems. Let's see how to handle
    sensor input in Qt so that you can use it in your games.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 正在扩展到更多现在使用的平台。这包括许多流行的移动平台。移动设备通常配备有额外的硬件，这些硬件在桌面系统中较少见。让我们看看如何在 Qt 中处理传感器输入，以便您可以在游戏中使用它。
- en: Most of the features discussed in this section are not usually available on
    desktops. If you want to play with them, you need to set up running Qt applications
    on a mobile device. This requires a few configuration steps that depend on your
    target platform. Please refer to Qt documentation for exact instructions, as they
    will offer complete and up-to-date information that wouldn't be possible to provide
    in a book. Good starting points are Getting Started with Qt for Android  and Qt
    for iOS documentation pages.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中讨论的大多数功能通常在桌面上不可用。如果您想尝试它们，您需要在移动设备上设置运行 Qt 应用程序。这需要一些配置步骤，这些步骤取决于您的目标平台。请参阅
    Qt 文档以获取确切说明，因为它们将提供完整且最新的信息，这在书中是无法提供的。良好的起点是“Qt for Android 入门”和“Qt for iOS”文档页面。
- en: 'Access to sensors present on mobile devices is provided by the Qt Sensors module
    and must be imported before it can be used:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Qt Sensors 模块提供对移动设备上传感器的访问，在使用之前必须导入：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are a lot of QML types you can use to interact with sensors. Have a look
    at this impressive list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 QML 类型可以用来与传感器交互。看看这个令人印象深刻的列表：
- en: '| **QML type** | **Description** |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| **QML 类型** | **描述** |'
- en: '| --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Accelerometer` | Reports the device''s linear acceleration along the *x*, *y*,
    and *z* axes. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `Accelerometer` | 报告设备沿 *x*、*y* 和 *z* 轴的线性加速度。|'
- en: '| `Altimeter` | Reports the altitude in meters relative to mean sea level.
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `Altimeter` | 报告相对于平均海平面的高度，单位为米。|'
- en: '| `AmbientLightSensor` | Reports the intensity of the ambient light. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `AmbientLightSensor` | 报告环境光的强度。|'
- en: '| `AmbientTemperatureSensor` | Reports the temperature in degree Celsius of
    the current device''s ambient. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `AmbientTemperatureSensor` | 报告当前设备环境的温度，单位为摄氏度。|'
- en: '| `Compass` | Reports the azimuth of the device''s top as degrees from magnetic
    north. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `Compass` | 报告设备顶部的方位角，单位为从磁北方向起的度数。|'
- en: '| `DistanceSensor` | Reports distance in cm from an object to the device. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `DistanceSensor` | 报告从对象到设备的距离，单位为厘米。|'
- en: '| `Gyroscope` | Reports the device''s movement around its axes in degrees per
    second. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `Gyroscope` | 报告设备在其轴上的运动，单位为每秒度数。|'
- en: '| `HolsterSensor` | Reports if the device is holstered in a specific pocket.
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `HolsterSensor` | 报告设备是否被放置在特定的口袋中。|'
- en: '| `HumiditySensor` | Reports on humidity. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `HumiditySensor` | 报告湿度。|'
- en: '| `IRProximitySensor` | Reports the reflectance of the outgoing infrared light.
    The range is from 0 (zero reflection) to 1 (total reflection). |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `IRProximitySensor` | 报告发出的红外光的反射率。范围从 0（无反射）到 1（完全反射）。|'
- en: '| `LidSensor` | Reports on whether a device is closed. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `LidSensor` | 报告设备是否关闭。|'
- en: '| `LightSensor` | Reports the intensity of light in lux. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `LightSensor` | 报告光的强度，单位为勒克斯。|'
- en: '| `Magnetometer` | Reports the device''s magnetic flux density along its axes.
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `Magnetometer` | 报告设备沿其轴线的磁通密度。|'
- en: '| `OrientationSensor` | Reports the orientation of the device. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `OrientationSensor` | 报告设备的方向。|'
- en: '| `PressureSensor` | Reports the atmospheric pressure in Pascals. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `PressureSensor` | 报告大气压力，单位为帕斯卡。|'
- en: '| `ProximitySensor` | Reports if an object is close to the device. Which distance
    is considered "close" depends on the device. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `ProximitySensor` | 报告对象是否靠近设备。被认为是“靠近”的距离取决于设备。|'
- en: '| `RotationSensor` | Reports the three angles that define the orientation of
    the device in a three-dimensional space. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `RotationSensor` | 报告定义设备在三维空间中方向的三个角度。|'
- en: '| `TapSensor` | Reports if a device was tapped. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `TapSensor` | 报告设备是否被轻触。|'
- en: '| `TiltSensor` | Reports the angle of tilt in degrees along the device''s axes.
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `TiltSensor` | 报告设备轴上的倾斜角度（以度为单位）。|'
- en: Unfortunately, not all sensors are supported on all platforms. Check out the Compatibility
    Map documentation page to see which sensors are supported on your target platforms
    before trying to use them.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有平台都支持所有传感器。在尝试使用它们之前，请查看兼容性映射文档页面，以了解您的目标平台支持哪些传感器。
- en: All these types inherit the `Sensor` type and provide similar API. First, create
    a sensor object and activate it by setting its `active` property to `true`. When
    the hardware reports new values, they are assigned to the sensor's `reading` property.
    As with any property in QML, you can choose between using the property directly,
    using it in a property binding, or using the `onReadingChanged` handler to react
    to each new value of the property.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型都继承自 `Sensor` 类型，并提供类似的 API。首先，创建一个传感器对象，并通过将其 `active` 属性设置为 `true` 来激活它。当硬件报告新值时，它们将被分配给传感器的
    `reading` 属性。与 QML 中的任何属性一样，您可以选择直接使用属性、在属性绑定中使用它或使用 `onReadingChanged` 处理器来对属性的每个新值做出反应。
- en: The type of the `reading` object corresponds to the type of the sensor. For
    example, if you use a tilt sensor, you'll receive a `TiltReading` object that provides
    suitable properties to access the angle of tilt around the *x* (`xRotation`) and *y* (`yRotation`)
    axes. For each sensor type, Qt provides a corresponding reading type that contains
    the sensor data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`reading` 对象的类型对应于传感器的类型。例如，如果您使用倾斜传感器，您将收到一个 `TiltReading` 对象，该对象提供适当的属性来访问围绕
    `x`（`xRotation`）和 `y`（`yRotation`）轴的倾斜角度。对于每种传感器类型，Qt 都提供相应的读取类型，其中包含传感器数据。'
- en: All readings also have the `timestamp` property that contains the number of
    microseconds since some fixed point. That point can be different for different
    sensor objects, so you can only use it to calculate time intervals between two
    readings of the same sensor.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所有读取都还有一个 `timestamp` 属性，它包含自某个固定点以来的微秒数。这个点对于不同的传感器对象可能不同，因此您只能用它来计算同一传感器两次读取之间的时间间隔。
- en: 'The following QML code contains a complete example of using a tilt sensor:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 QML 代码包含使用倾斜传感器的完整示例：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When this application receives a new reading, the text on screen will be automatically
    updated. You can also use the `onReadingChanged` handler to process new data in
    another way.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当此应用程序接收到新的读数时，屏幕上的文本将自动更新。您还可以使用 `onReadingChanged` 处理器以其他方式处理新数据。
- en: Detecting device location
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测设备位置
- en: 'Some modern games require information about the player''s geographic location
    and other related data, such as movement speed. The Qt Positioning module allows
    you to access this information. Let''s see a basic QML example of determining
    the location:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一些现代游戏需要关于玩家地理位置和其他相关数据的信息，例如移动速度。Qt 定位模块允许您访问这些信息。让我们看看一个基本的 QML 示例，用于确定位置：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, we import the `QtPositioning` module into scope. Next, we create a `PositionSource`
    object and set its `active` property to true. The `position` property of the `PositionSource`
    object will be automatically updated as new information is available. In addition
    to latitude and longitude, this property also contains information about altitude,
    direction and speed of travel, and accuracy of location. Since some of values
    may not be available, each value is accompanied with a Boolean property that indicates
    if the data is present. For example, if `directionValid` is true, then `direction`
    value was set.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `QtPositioning` 模块导入作用域。接下来，我们创建一个 `PositionSource` 对象并将其 `active` 属性设置为
    `true`。当有新信息可用时，`PositionSource` 对象的 `position` 属性将自动更新。除了纬度和经度外，此属性还包含有关海拔、方向、速度和位置准确性的信息。由于某些值可能不可用，每个值都附带一个布尔属性，指示数据是否存在。例如，如果
    `directionValid` 为 `true`，则 `direction` 值已设置。
- en: There are multiple ways to determine the player's location. The `PositionSource`
    type has a few properties that allow you to specify the source of the data. First,
    the `preferredPositioningMethods`  property allows you to choose between satellite
    data, non-satellite data, or using both of them. The `supportedPositioningMethods`
    property holds information about currently available methods. You can also use
    the `nmeaSource` property to provide an NMEA position-specification data file
    which overrides any other data sources and can be used to simulate the device's
    location and movement which is very useful during development and testing of the
    game.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以确定玩家的位置。`PositionSource`类型有几个属性，允许你指定数据的来源。首先，`preferredPositioningMethods`属性允许你在卫星数据、非卫星数据或同时使用两者之间进行选择。`supportedPositioningMethods`属性包含有关当前可用方法的信息。你还可以使用`nmeaSource`属性提供一个NMEA位置指定数据文件，该文件覆盖任何其他数据源，并可用于模拟设备的位置和移动，这在游戏开发和测试期间非常有用。
- en: Creating advanced QML components
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建高级QML组件
- en: By now, you should be familiar with the very basics of QML and Qt Quick. Now,
    we can start combining what you know and fill the gaps with more information to
    build more advanced QML components. Our target will be to display an analog clock.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉了QML和Qt Quick的非常基础的知识。现在，我们可以开始结合你所知道的知识，并用更多信息来填补空白，以构建更高级的QML组件。我们的目标是显示一个模拟时钟。
- en: Time for action – A simple analog clock application
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候动手做一个简单的模拟时钟应用程序了
- en: 'Create a new Qt Quick Application - Empty project. To create a clock, we will
    implement a component representing the clock needle, and we will use instances
    of that component in the actual clock element. In addition to this, we will make
    the clock a reusable component; therefore, we will create it in a separate file
    and instantiate it from within `main.qml`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Qt Quick应用程序 - 空项目。为了创建一个时钟，我们将实现一个代表时钟指针的组件，并且我们将在实际的时钟元素中使用该组件的实例。除此之外，我们还将使时钟成为一个可重用的组件；因此，我们将它创建在一个单独的文件中，并在`main.qml`内部实例化它：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We use the `anchors` property group to expand the item to fit the whole window
    except for the 20-pixel margin for all four sides.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`anchors`属性组来扩展项目，使其适应整个窗口，除了四周各20像素的边距。
- en: Before this code works, however, we need to add a new QML file for the `Clock` component.
    Locate the `qml.qrc` resource file in the project tree and select Add New... in
    its context menu. From the Qt category, select QML File (Qt Quick 2), input `Clock` as
    the name and confirm the operation. A new file called `Clock.qml` will be created
    and added to the resources list.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这段代码工作之前，我们需要为`Clock`组件添加一个新的QML文件。在项目树中定位`qml.qrc`资源文件，并在其上下文菜单中选择“添加新...”。从“Qt”类别中选择“QML文件（Qt
    Quick 2）”，输入`Clock`作为名称，并确认操作。将创建一个名为`Clock.qml`的新文件，并将其添加到资源列表中。
- en: 'Let''s start by declaring a circular clock plate:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从声明一个圆形钟表盘开始：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you run the program now, you''ll see a plain gray circle hardly resembling
    a clock plate:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行程序，你会看到一个朴素的灰色圆圈，几乎无法与钟表盘相提并论：
- en: '![](img/9f396b5d-9020-41ce-a194-7a811e1c2543.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f396b5d-9020-41ce-a194-7a811e1c2543.png)'
- en: 'The next step is to add marks dividing the plate into 12 sections. We can do
    this by putting the following declaration inside the `plate` object:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加将盘面分成12个部分的标记。我们可以通过在`plate`对象内部放置以下声明来实现：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Running the program should now give the following result, looking much more
    like a clock plate:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序现在应该给出以下结果，看起来更像是一个钟表盘：
- en: '![](img/f9920416-1d71-4d85-a249-cca203a92d26.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9920416-1d71-4d85-a249-cca203a92d26.png)'
- en: What just happened?
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The code we just created introduces a couple of new features. Let's go through
    them one by one.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才创建的代码引入了一些新功能。让我们逐一介绍它们。
- en: First of all, we used a new element called `Repeater`. It does exactly what
    its name says—it repeats items declared within it using a given model. For each
    entry in the model, it creates an instance of a component assigned to a property
    called `delegate` (the property name means that it contains an entity to which
    the caller delegates some responsibility, such as describing a component to be
    used as a stencil by the caller). `Item` declared in `Repeater` describes the
    delegate even though we cannot see it explicitly assigned to a property. This
    is because `delegate` is a default property of the `Repeater` type, which means
    anything unassigned to any property explicitly gets implicitly assigned to the
    default property of the type.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用了一个名为 `Repeater` 的新元素。它确实如其名所示—使用给定的模型重复其内部声明的项。对于模型中的每个条目，它都会为名为 `delegate`
    的属性分配的组件创建一个实例（属性名意味着它包含一个实体，调用者将一些责任委托给它，例如描述一个调用者用作模板的组件）。在 `Repeater` 中声明的
    `Item` 描述了代理，尽管我们无法明确看到它被分配给任何属性。这是因为 `delegate` 是 `Repeater` 类型的默认属性，这意味着任何未明确分配给任何属性的任何内容都会隐式地分配给类型的默认属性。
- en: The `Item` type also has a default property called `data`. It holds a list of
    elements that gets automatically split into two "sublists"—the list of the item's
    children (which creates the hierarchy of `Item` instances in Qt Quick) and another
    list called resources, which contains all "child" elements that do not inherit
    from `Item`. You have direct access to all three lists, which means calling `children[2]` will
    return the third `Item` element declared in the item, and `data[5]` will return
    the sixth element declared in the `Item`, regardless of whether the given element
    is a visual item (that inherits `Item`) or not.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item` 类型还有一个默认属性称为 `data`。它包含一个元素列表，该列表会自动拆分为两个 "子列表"—一个是项的子元素列表（这创建了 Qt Quick
    中 `Item` 实例的层次结构）和另一个名为资源的列表，其中包含所有不继承自 `Item` 的 "子" 元素。你可以直接访问这三个列表，这意味着调用 `children[2]`
    将返回在项中声明的第三个 `Item` 元素，而 `data[5]` 将返回在 `Item` 中声明的第六个元素，无论给定的元素是否是一个视觉项（继承自 `Item`）。'
- en: The model can be a number of things, but in our case, it is simply a number
    denoting how many times the delegate should be repeated. The component to be repeated
    is a transparent item containing a rectangle. The item has a property declared
    called `hour` that has the `index` variable bound to it. The latter is a property
    assigned by `Repeater` to each instance of the delegate component. The value it
    contains is the index of the instance in the `Repeater` object—since we have a
    model containing twelve elements, `index` will hold values within a range of `0` to `11`.
    The item can make use of the `index` property to customize instances created by `Repeater`.
    In this particular case, we use `index` to provide values for a `rotation` property
    and by multiplying the index by `30`, we get values starting from `0` for the
    first instance and ending at `330` for the last one.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 模型可以是一系列事物，但就我们而言，它仅仅是一个数字，表示代理应该重复的次数。要重复的组件是一个包含矩形的透明项。该项有一个名为 `hour` 的属性，它与
    `index` 变量绑定。后者是由 `Repeater` 分配给每个代理组件实例的属性。它包含的值是实例在 `Repeater` 对象中的索引—由于我们有一个包含十二个元素的模型，`index`
    将在 `0` 到 `11` 的范围内持有值。项可以利用 `index` 属性来定制由 `Repeater` 创建的实例。在这种情况下，我们使用 `index`
    为 `rotation` 属性提供值，并通过将索引乘以 `30`，我们得到从第一个实例的 `0` 开始到最后的 `330` 结束的值。
- en: The `rotation` property brings us to the second most important subject—item
    transformations. Each item can be transformed in a number of ways, including rotating
    the item and scaling it in two-dimensional space, as we already mentioned earlier.
    Another property called `transformOrigin` denotes the origin point around which
    scale and rotation are applied. By default, it points to `Item.Center`, which
    makes the item scale and rotate around its center, but we can change it to eight
    other values, such as `Item.TopLeft` for the top-left corner or `Item.Right` for
    the middle of the right edge of the item. In the code we crafted, we rotate each
    item clockwise around its bottom edge. Each item is positioned horizontally in
    the middle of the plate using the `plate.width / 2` expression and vertically
    at the top of the plate with the default width of `0` and the height of half the
    plate's height; thus, each item is a thin vertical line spanning from within the
    top to the center of the plate. Then, each item is rotated around the center of
    the plate (each item's bottom edge) by 30 degrees more than a previous item effectively
    laying items evenly on the plate.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotation`属性引出了第二个最重要的主题——项目变换。每个项目都可以以多种方式变换，包括旋转项目和在二维空间中缩放项目，正如我们之前提到的。另一个名为`transformOrigin`的属性表示应用缩放和旋转的原点。默认情况下，它指向`Item.Center`，这使得项目围绕其中心缩放和旋转，但我们可以将其更改为其他八个值，例如`Item.TopLeft`用于左上角或`Item.Right`用于项目右侧边缘的中间。在我们的代码中，我们围绕每个项目的底部边缘顺时针旋转每个项目。每个项目使用`plate.width
    / 2`表达式水平居中在盘子的中间，并垂直位于盘子的顶部，默认宽度为`0`和高度为盘子高度的一半；因此，每个项目是从顶部到盘子中心的细长垂直线。然后，每个项目围绕盘子的中心（每个项目的底部边缘）旋转比前一个项目多30度，从而有效地将项目均匀地放置在盘子上。'
- en: Finally, each item has a gray `Rectangle` attached to the top edge (offset by `4`)
    and horizontally centered in the transparent parent. Transformations applied to
    an item influence the item's children similar to what we have seen in Graphics
    View; thus, the effective rotation of the rectangle follows that of its parent.
    The height of the rectangle depends on the value of `hour`, which maps to the
    index of the item in `Repeater`. Here, you cannot use `index` directly as it is
    only visible within the topmost item of the delegate. That's why we create a real
    property called `hour` that can be referenced from within the whole delegate item
    hierarchy.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个项目都附有一个灰色的`矩形`，位于顶部边缘（偏移`4`个单位）并在透明父元素中水平居中。应用于项目的变换会影响项目的子元素，类似于我们在图形视图中看到的情况；因此，矩形的实际旋转跟随其父元素的旋转。矩形的高度取决于`hour`的值，它映射到`Repeater`中项目的索引。在这里，你不能直接使用`index`，因为它只在委托的最顶层项目内可见。这就是为什么我们创建了一个真正的属性`hour`，它可以从整个委托项目层次结构中引用。
- en: If you want more control over item transformations, then we are happy to inform
    you that apart from rotation and scale properties, each item can be assigned an
    array of elements such as `Rotation`, `Scale`, and `Translate` to a property called `transform`,
    which are applied in order, one at a time. These types have properties for fine-grained
    control over the transformation. For instance, using `Rotation`, you can implement
    rotation over any of the three axes and around a custom origin point (instead
    of being limited to nine predefined origin points as when using the `rotation` property
    of `Item`).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要对项目变换有更多的控制，那么我们很高兴地告诉你，除了旋转和缩放属性之外，每个项目都可以分配一个元素数组，如`Rotation`、`Scale`和`Translate`到名为`transform`的属性中，这些变换按顺序逐个应用。这些类型具有用于精细控制变换的属性。例如，使用`Rotation`，你可以实现沿任意三个轴的旋转以及围绕自定义原点（而不是像使用`Item`的`rotation`属性时那样限制在九个预定义的原点）。
- en: Time for action – Adding needles to the clock
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 向时钟添加针
- en: 'The next step is to add the hour, minute, and second needles to the clock.
    Let''s start by creating a new component called `Needle` in a file called `Needle.qml` (remember
    that component names and files representing them need to start with a capital
    letter):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将小时、分钟和秒针添加到时钟中。让我们首先在名为`Needle.qml`的文件中创建一个新的组件，名为`Needle`（记住，组件名称和表示它们的文件名需要以大写字母开头）：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`Needle` is basically a rectangle anchored to the center of its parent by its
    bottom edge, which is also the item''s pivot. It also has the `value` and `granularity` properties
    driving the rotation of the item, where `value` is the current value the needle
    shows and `granularity` is the number of different values it can display. Also,
    anti-aliasing for the needle is enabled as we want the tip of the needle nicely
    rounded. Having such a definition, we can use the component to declare the three
    needles inside the clock plate object:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Needle`基本上是一个矩形，通过其底部边缘锚定到父元素的中心，这也是项目的支点。它还具有驱动项目旋转的`value`和`granularity`属性，其中`value`是当前针显示的值，而`granularity`是它可以显示的不同值的数量。此外，针的抗锯齿功能已启用，因为我们希望针尖圆润。有了这样的定义，我们可以使用该组件在时钟盘对象内部声明三个针：'
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The three needles make use of the `hours`, `minutes`, and `seconds` properties
    of clock, so these need to be declared as well:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 三个针使用了时钟的`hours`、`minutes`和`seconds`属性，因此这些也需要声明：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'By assigning different values to the properties of `Clock` in `main.qml`, you
    can make the clock show a different time:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为`main.qml`中`Clock`的属性分配不同的值，你可以使时钟显示不同的时间：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You''ll get an output as shown:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到如下所示的输出：
- en: '![](img/349cc52a-3655-4afb-93e9-37089402cf32.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/349cc52a-3655-4afb-93e9-37089402cf32.png)'
- en: What just happened?
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Most `Needle` functionality is declared in the component itself, including geometry
    and transformations. Then, whenever we want to use the component, we declare an
    instance of `Needle` and optionally customize the `length` and `color` properties
    as well as set its `value` and `granularity` to obtain the exact functionality
    we need.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`Needle`功能都在组件本身中声明，包括几何形状和变换。然后，无论何时我们想要使用该组件，我们都会声明一个`Needle`实例，并可选择自定义`length`和`color`属性，以及设置其`value`和`granularity`以获得所需的确切功能。
- en: Time for action – Making the clock functional
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使时钟功能化
- en: 'The final step in creating a clock is to make it actually show the current
    time. In JavaScript, we can query the current time using the `Date` object:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建时钟的最终步骤是让它实际显示当前时间。在JavaScript中，我们可以使用`Date`对象查询当前时间：
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Therefore, the first thing that comes to mind is to use the preceding code
    to show the current time on the clock:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先想到的是使用前面的代码在时钟上显示当前时间：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will indeed show the current time once you start the application, but the
    clock will not be updating itself as the time passes. This is because `new Date()` returns
    an object representing one particular moment in time (the date and time at the
    moment when the object was instantiated). While QML usually is capable of automatically
    updating a property when the value of the bound expression changes, it's unable
    to do so in this case. Even if QML was smart enough to see that the `new Date()` property
    always returns a different date, it doesn't know how often we want to update the
    value, and updating it as frequently as possible is generally a bad idea. Thus,
    we need a way to manually schedule periodic execution of an action.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实会在你启动应用程序时显示当前时间，但时钟不会随着时间流逝而更新自己。这是因为`new Date()`返回一个表示特定时刻的对象（对象实例化的那一刻的日期和时间）。虽然QML通常能够在绑定的表达式值变化时自动更新属性，但它无法在此情况下做到。即使QML足够聪明，能够看到`new
    Date()`属性总是返回不同的日期，它也不知道我们希望多久更新一次值，而尽可能频繁地更新通常是一个坏主意。因此，我们需要一种手动安排定期执行操作的方法。
- en: 'To obtain this effect in QML, we can use a `Timer` element that is an equivalent
    of `QTimer` in C++ and lets us periodically execute some code. Let''s modify the
    code to use a timer:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要在QML中获得这种效果，我们可以使用一个`Timer`元素，它是C++中`QTimer`的等效物，并允许我们定期执行一些代码。让我们修改代码以使用计时器：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: What just happened?
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: By setting the `interval` property, we ask the timer to emit the `triggered` signal
    every 500 ms, causing our `currentDate` property to be updated with a new `Date` 
    object representing the current time. The clock is also given the `running` property
    (pointing to its equivalent in the timer) that can control whether updates should
    be enabled. The timer's `repeat`
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`interval`属性，我们要求计时器每500毫秒发出`triggered`信号，从而使我们的`currentDate`属性更新为一个新的`Date`对象，表示当前时间。时钟还获得了`running`属性（指向计时器中的等效属性），可以控制是否启用更新。计时器的`repeat`
- en: property is set to `true`; otherwise, it will trigger just once.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 属性设置为`true`；否则，它将只触发一次。
- en: To briefly sum up what you have learned so far, we can say that you know how
    to create hierarchies of objects by declaring their instances, and you also know
    how to program new types in separate files, making definitions available as components
    to be instantiated in other QML files. You can even use the `Repeater` element
    to declare a series of objects based on a common stencil.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 简要总结到目前为止你所学的，我们可以这样说：你知道如何通过声明实例来创建对象层次结构，你也知道如何在单独的文件中编程新类型，使定义作为组件在其他 QML
    文件中实例化。你甚至可以使用 `Repeater` 元素根据一个共同的模板声明一系列对象。
- en: Dynamic and lazy loading of QML objects
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML 对象的动态和延迟加载
- en: All our previous QML projects contain an explicit declaration of the object
    tree. We usually create a window and place multiple specific elements into it
    in specific order. The QML engine creates these objects on startup and keeps them
    alive until the application terminates. This is a very convenient approach that
    allows you to save a lot of time, as you could see in our previous examples. However,
    sometimes you need the object tree to be more flexible—for example, if you don't
    know upfront which elements should be created. QML offers a few ways to create
    objects dynamically and to delay creating an object until you really need it.
    Utilizing these features can make your QML application more performant and flexible.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前所有的 QML 项目都包含一个显式的对象树声明。我们通常创建一个窗口，并将多个特定元素按照特定顺序放入其中。QML 引擎在启动时创建这些对象，并在应用程序终止前保持它们的活动状态。这是一个非常方便的方法，可以节省你大量的时间，正如你可以在我们之前的示例中看到的那样。然而，有时你需要一个更灵活的对象树——例如，如果你事先不知道应该创建哪些元素。QML
    提供了几种动态创建对象和延迟创建对象直到真正需要的方法。利用这些功能可以使你的 QML 应用程序更高效和灵活。
- en: Creating objects on request
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按需创建对象
- en: The problem with predeclaring objects directly in a QML file is that you need
    to know upfront how many objects you will need. More often than not, you will
    want to dynamically add and remove objects to your scene, for example, in an alien
    invasion game, where, as the player progresses, new alien saucers will be entering
    the game screen and other saucers will be getting shot down and destroyed. Also,
    the player's ship will be "producing" new bullets streaking in front of the ship,
    eventually running out of fuel or otherwise disappearing from the game scene.
    By putting a good amount of effort into the problem, you will be able to use `Repeater` to
    obtain this effect, but there is a better tool at hand.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QML 文件中直接预先声明对象的问题在于，你需要事先知道你需要多少个对象。更常见的情况是，你将想要动态地向场景中添加和删除对象，例如，在一个外星人入侵游戏中，随着玩家的进步，新的外星飞碟将进入游戏屏幕，而其他飞碟将被击落并摧毁。此外，玩家的飞船将“生产”新的子弹，在飞船前方划过，最终耗尽燃料或以其他方式从游戏场景中消失。通过在解决这个问题上投入大量精力，你将能够使用
    `Repeater` 来获得这种效果，但手头还有更好的工具。
- en: QML offers us another element type called `Component`, which is another way
    to teach the engine about a new element type by declaring its contents in QML.
    There are basically two approaches to doing this.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: QML 给我们提供了另一种元素类型，称为 `Component`，这是通过在 QML 中声明其内容来向引擎介绍新元素类型的一种方法。基本上有两种实现这种方法的途径。
- en: 'The first approach is to declare a `Component` element instance in the QML
    file and inline the definition of the new type directly inside the element:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是在 QML 文件中声明一个 `Component` 元素实例，并将新类型的定义直接内联在元素中：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The other approach is to load the component definition from an existing QML
    file. Let''s say that we have a `Circle.qml` file with the following content:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是加载组件定义自现有的 QML 文件。假设我们有一个 `Circle.qml` 文件，其内容如下：
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Such code declares a component that defines a circle and exposes its `diameter`, `color`,
    and `border` properties. Let's see how we can create instances of this component
    dynamically.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码声明了一个组件，它定义了一个圆，并公开了其 `diameter`（直径）、`color`（颜色）和 `border`（边框）属性。让我们看看我们如何可以动态地创建这个组件的实例。
- en: 'QML exposes a special global object called `Qt`, which provides a set of interesting
    methods. One of the methods allows the caller to create a component passing the
    URL of an existing QML document:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: QML 提供了一个特殊的全局对象 `Qt`，它提供了一套有趣的方法。其中一种方法允许调用者通过传递现有 QML 文档的 URL 来创建一个组件：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'An interesting note is that `createComponent` can not only accept a local file
    path but also a remote URL, and if it understands the network scheme (for example, `http`),
    it will download the document automatically. In this case, you have to remember
    that it takes time to do that, so the component may not be ready immediately after
    calling  `createComponent`. Since the current loading status is kept in the `status` property,
    you can connect to the `statusChanged` signal to be notified when this happens.
    A typical code path looks similar to the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的注意事项是`createComponent`不仅可以接受本地文件路径，还可以接受远程URL，并且如果它理解网络方案（例如，`http`），它将自动下载文档。在这种情况下，您必须记住这需要时间，因此组件在调用`createComponent`后可能不会立即准备好。由于当前的加载状态保存在`status`属性中，您可以通过连接到`statusChanged`信号来通知这种情况。一个典型的代码路径看起来类似于以下：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this example, we use the `Component.onCompleted` handler to run the code
    as soon as the window object is created. This handler is available in all Qt Quick
    items and is often used to perform initialization. You can also use any other
    signal handler here. For example, you can start loading the component when a button
    is pressed or a timer has expired.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`Component.onCompleted`处理程序在窗口对象创建后立即运行代码。这个处理程序在所有Qt Quick项中都是可用的，通常用于执行初始化。您也可以在这里使用任何其他信号处理程序。例如，您可以在按钮按下或计时器到期时开始加载组件。
- en: The counterpart of the `completed()` signal of `Component` is `destruction()`.
    You can use the `Component.onDestruction` handler to perform actions such as saving
    the state of the object to persistent storage or otherwise cleaning the object
    up.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component`的`completed()`信号的对应物是`destruction()`。您可以使用`Component.onDestruction`处理程序执行诸如将对象的状态保存到持久存储或以其他方式清理对象等操作。'
- en: 'If the component definition is incorrect or the document cannot be retrieved,
    the status of the object will change to `Error`. In that case, you can make use
    of the `errorString()` method to see what the actual problem is:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件定义不正确或无法检索文档，对象的状态将变为`错误`。在这种情况下，您可以使用`errorString()`方法查看实际的问题是什么：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Once you are sure that the component is ready, you can finally start creating
    objects from it. For this, the component exposes a method called `createObject`.
    In its simplest form, it accepts an object that is to become the parent of the
    newly born instance (similar to widget constructors accepting a pointer to a parent
    widget) and returns the new object itself so that you can assign it to some variable. Then,
    you can start setting the object''s properties:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确定组件已准备好，您就可以开始从它创建对象。为此，组件公开了一个名为`createObject`的方法。在其最简单形式中，它接受一个将成为新创建实例的父对象的对象（类似于小部件构造函数接受父小部件的指针）并返回新对象本身，以便您可以将其分配给某个变量。然后，您可以开始设置对象的属性：
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A more complex invocation lets us do both these operations (create the object
    and set its properties) in a single call by passing a second parameter to `createObject`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的调用允许我们在一个调用中执行这两个操作（创建对象并设置其属性）通过向`createObject`传递第二个参数：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The second parameter is a JavaScript object whose properties are to be applied
    to the object being created. The advantage of the latter syntax is that all property
    values are applied to the object as one atomic operation and they won't trigger
    property change handlers (just like when the item is declared in a QML document)
    instead of a series of separate operations, each of which sets the value for a
    single property, possibly causing an avalanche of change handler invocations in
    the object.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个JavaScript对象，其属性将被应用到正在创建的对象上。这种语法的好处是所有属性值都作为一个原子操作应用到对象上，并且它们不会触发属性更改处理程序（就像在QML文档中声明项时一样），而不是一系列单独的操作，每个操作都设置单个属性的值，这可能会在对象中引发一系列更改处理程序的调用。
- en: After creation, the object becomes a first-class citizen of the scene, acting
    in the same way as items declared directly in the QML document. The only difference
    is that a dynamically created object can also be dynamically destructed by calling
    its `destroy()` method, which is similar to calling `delete` on C++ objects. When
    speaking of destroying dynamic items, we have to point out that when you assign
    a result of `createObject` to a variable (like `circle`, in our example) and that
    variable goes out of scope, the item will not be released and garbage collected
    as its parent still holds a reference to it, preventing it from being recycled.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，对象成为场景的一等公民，以与在 QML 文档中直接声明的项目相同的方式行事。唯一的区别是，动态创建的对象也可以通过调用其`destroy()`方法动态销毁，这与在
    C++ 对象上调用`delete`类似。当谈到销毁动态项目时，我们必须指出，当您将`createObject`的结果分配给一个变量（如我们的例子中的`circle`）并且该变量超出作用域时，项目将不会被释放和垃圾回收，因为其父对象仍然持有对该项目的引用，从而阻止其被回收。
- en: We didn't mention this explicitly before, but we have already used inline component
    definitions earlier in this chapter when we introduced the `Repeater` element.
    The repeated item defined within the repeater is in fact not a real item, but
    a component definition that is instantiated as many times as needed by the repeater.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有明确提到这一点，但我们已经在本章介绍`Repeater`元素时使用过内联组件定义。实际上，在`Repeater`中定义的重复项不是一个真实的项目，而是一个组件定义，该定义由`Repeater`根据需要实例化多次。
- en: Delaying item creation
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟项目创建
- en: Another recurring scenario is that you do know how many elements you will need,
    but the problem is that you cannot determine upfront what type of elements they
    will be. At some point during the lifetime of your application, you will learn
    that information and will be able to instantiate an object. Until you gain the
    knowledge about the given component, you will need some kind of item placeholder
    where you will later put the real item. You can, of course, write some code to
    use the `createObject()` functionality of the component, but this is cumbersome.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的场景是，您确实知道需要多少个元素，但问题是您无法提前确定它们的类型。在应用程序的生命周期中的某个时刻，您将了解到这些信息，并将能够实例化一个对象。在您获得有关给定组件的知识之前，您将需要一个某种类型的项目占位符，您将在其中放置真实的项目。当然，您可以编写一些代码来使用组件的`createObject()`功能，但这很麻烦。
- en: 'Fortunately, Qt Quick offers a nicer solution in the form of a `Loader` item.
    This item type is exactly what we described it to be—a temporary placeholder for
    a real item that will be loaded on demand from an existing component. You can
    put `Loader` in place of another item and when you need to create this item, one
    way is to set the URL of a component to the `source` property:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Qt Quick 提供了一个更好的解决方案，即一个`Loader`项目。这种项目类型正是我们所描述的——一个临时占位符，用于在需要时从现有组件中加载真实项目。您可以将`Loader`放在另一个项目的位置，当您需要创建此项目时，一种方法是将组件的URL设置为`source`属性：
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can also directly attach a real component to the `sourceComponent` of a
    `Loader`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以直接将一个真实组件附加到`Loader`的`sourceComponent`上：
- en: '[PRE60]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Immediately afterward, the magic begins and an instance of the component appears
    in the loader. If the `Loader` object has its size set explicitly (for example,
    by anchoring or setting the width and height), then the item will be resized to
    the size of the loader. If an explicit size is not set, then `Loader` will instead
    be resized to the size of the loaded element once the component is instantiated.
    In the following code, the loader has its size set explicitly, so when its item
    is created, it will respect the anchors and sizes declared here:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，魔法开始发挥作用，组件的实例在加载器中显示出来。如果`Loader`对象的大小被明确设置（例如，通过锚定或设置宽度和高度），则项目的大小将调整为加载器的大小。如果没有设置明确的大小，则一旦组件实例化，`Loader`将调整为加载元素的大小。在下面的代码中，加载器的大小被明确设置，因此当其项目创建时，它将尊重这里声明的锚点和大小：
- en: '[PRE61]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Imperative painting on Canvas using JavaScript
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JavaScript 在 Canvas 上进行命令式绘制
- en: Declaring graphical items is nice and easy, but as programmers, we're more used
    to writing imperative code, and some things are easier expressed as an algorithm
    rather than as a description of the final result to be achieved. It is easy to
    use QML to encode a definition of a primitive shape such as a rectangle in a compact
    way—all we need is to mark the origin point of the rectangle, its width, height,
    and optionally, a color. Writing down a declarative definition of a complex shape
    consisting of many control points positioned in given absolute coordinates, possibly
    with an outline in some parts of it, maybe accompanied by an image or two, is
    still possible in a language such as QML; however, this will result in a much
    more verbose and much less readable definition. This is a case where using an
    imperative approach might prove more effective. HTML (being a declarative language)
    already exposes a proven imperative interface for drawing different primitives
    called a `Canvas` that is widely used in web applications. Fortunately, Qt Quick
    provides us with its own implementation of a `Canvas` interface similar to the
    one from the web by letting us instantiate `Canvas` items. Such items can be used
    to draw straight and curved lines, simple and complex shapes, and graphs and graphic
    images. It can also add text, colors, shadows, gradients, and patterns. It can
    even perform low-level pixel operations. Finally, the output may be saved as an
    image file or serialized to a URL usable as source for an `Image` item. There
    are many tutorials and papers available out there on using an HTML canvas, and
    they can usually be easily applied to a Qt Quick canvas as well (the reference
    manual even includes a list of aspects you need to pay attention to when porting
    HTML canvas applications to a Qt Quick Canvas), so here we will just give you
    the very basics of imperative drawing in Qt Quick.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 声明图形项既方便又简单，但作为程序员，我们更习惯于编写命令式代码，有些事情用算法表达比用达到最终结果的描述更容易。使用 QML 以紧凑的方式编码原始形状的定义，如矩形，很容易——我们只需要标记矩形的原点、宽度、高度，以及可选的颜色。在
    QML 这样的语言中，写下由许多控制点在给定绝对坐标中定位的复杂形状的声明性定义，可能在其某些部分有轮廓，可能还伴随一些图像，仍然是可能的；然而，这将导致一个更加冗长且可读性更差的定义。在这种情况下，使用命令式方法可能更有效。HTML（作为一种声明性语言）已经暴露了一个用于绘制不同原始形状的经过验证的命令式接口，称为
    `Canvas`，它在网络应用中被广泛使用。幸运的是，Qt Quick 通过允许我们实例化 `Canvas` 项为我们提供了自己的 `Canvas` 接口实现，类似于网络中的实现。这些项可以用来绘制直线和曲线、简单和复杂的形状、图表和图形图像。它还可以添加文本、颜色、阴影、渐变和图案。它甚至可以执行低级像素操作。最后，输出可以保存为图像文件或序列化为一个可用的
    URL，用作 `Image` 项的源。关于使用 HTML canvas 的许多教程和论文都可以找到，并且它们通常可以很容易地应用于 Qt Quick canvas（参考手册甚至包括在将
    HTML canvas 应用程序移植到 Qt Quick Canvas 时需要关注的一些方面），因此在这里我们只给出 Qt Quick 中命令式绘图的基础知识。
- en: Consider a game where the player's health is measured by the condition of his
    heart—the slower the beat, the healthier the player is. We will use this kind
    of visualization as our exercise in practicing painting using the `Canvas` element.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个游戏，玩家的健康状态通过心脏的状况来衡量——心跳越慢，玩家就越健康。我们将使用这种可视化作为我们练习使用 `Canvas` 元素进行绘画的练习。
- en: Time for action – Preparing Canvas for heartbeat visualization
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 准备 Canvas 用于心跳可视化
- en: 'Let''s start with simple things by creating an empty Qt Quick project. Add
    the following code to the `main.qml` file:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个空的 Qt Quick 项目开始，做一些简单的事情。将以下代码添加到 `main.qml` 文件中：
- en: '[PRE62]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When you run the project, you will see a window containing a rectangle:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行项目时，你会看到一个包含矩形的窗口：
- en: '![](img/0b1553a2-ae63-4fcd-ac97-abd0e997ff27.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b1553a2-ae63-4fcd-ac97-abd0e997ff27.png)'
- en: What just happened?
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: In the preceding code, we created a basic boilerplate code for using a canvas.
    First, we created a `Canvas` instance with an implicit width and height set. There,
    we created a handler for the `paint` signal that is emitted whenever the canvas
    needs to be redrawn. The code placed there retrieves a context for the canvas,
    which can be thought of as an equivalent to the `QPainter` instance we used when
    drawing on Qt widgets. We inform the canvas that we want its 2D context, which
    gives us a way to draw in two dimensions. A 2D context is the only context currently
    present for the `Canvas` element, but you still have to identify it explicitly—similar
    to HTML. Having the context ready, we tell it to clear the whole area of the canvas.
    This is different from the widget world in which when the `paintEvent` handler
    was called, the widget was already cleared for us and everything had to be redrawn
    from scratch. With `Canvas`, it is different; the previous content is kept by
    default so that you can draw over it if you want. Since we want to start with
    a clean sheet, we call `clearRect()` on the context. Finally, we use the `strokeRect()` convenience
    method that draws a rectangle on the canvas.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个基本的模板代码，用于使用canvas。首先，我们创建了一个具有隐式宽度和高度的`Canvas`实例。在那里，我们创建了一个处理程序，用于处理每当画布需要重绘时发出的`paint`信号。放置在那里的代码检索画布的上下文，这可以被视为我们在Qt小部件上绘图时使用的`QPainter`实例的等价物。我们通知画布我们想要其2D上下文，这为我们提供了在二维中绘制的方式。2D上下文是目前`Canvas`元素唯一存在的上下文，但你仍然需要明确地识别它——类似于HTML。有了上下文准备就绪，我们告诉它清除画布的整个区域。这与小部件世界不同，在`paintEvent`处理程序被调用时，小部件已经为我们清除了，并且必须从头开始重绘一切。使用`Canvas`时，情况不同；默认情况下保留先前内容，以便您可以覆盖它。由于我们想要从一张干净的画布开始，我们在上下文中调用`clearRect()`。最后，我们使用`strokeRect()`便利方法在画布上绘制矩形。
- en: Time for action - drawing a heartbeat
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 绘制心电图
- en: We will extend our component now and implement its main functionality—drawing
    a heartbeat-like diagram.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将扩展我们的组件并实现其主要功能——绘制类似心电图的图形。
- en: 'Add the following property declarations to the `canvas` object:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下属性声明添加到`canvas`对象中：
- en: '[PRE63]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Inside the `Canvas` section, add a declaration for a timer that will trigger
    updates of the picture:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Canvas`部分中，添加一个定时器的声明，该定时器将触发图片的更新：
- en: '[PRE64]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then again, inside the `Canvas` section, define the handler for when the value
    of `arg` is modified:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次在`Canvas`部分中，定义当`arg`的值被修改时的处理程序：
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This handler uses a custom JavaScript function—`func()`. Place the implementation
    of the function just above the handler:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序使用自定义JavaScript函数——`func()`。将函数的实现放置在处理程序之上：
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, modify the `onPaint` signal handler:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，修改`onPaint`信号处理程序：
- en: '[PRE67]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, you can run the code and see a heartbeat-like diagram appear on the canvas:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以运行代码，并看到类似心电图的图形出现在画布上：
- en: '![](img/e6e910ae-4a56-41bf-bad2-d87807ec3e5e.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6e910ae-4a56-41bf-bad2-d87807ec3e5e.png)'
- en: What just happened?
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We added two kinds of properties to the element. By introducing `lineWidth`,
    we can manipulate the width of the line that visualizes the heartbeat. The `points` variable
    stores an array of already calculated function values. We initialize it to an
    empty array. The `arg` variable stores the function argument that was last evaluated.
    The argument of the function should be in the range from −π to +π; thus, we initialize `arg` to `-Math.PI`.
    Then, we add a timer that ticks in regular intervals, incrementing `arg` by 1°
    until it reaches +π, in which case it is reset to the initial value.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向元素添加了两种属性。通过引入`lineWidth`，我们可以操纵可视化心电的线条宽度。`points`变量存储已计算出的函数值数组。我们将其初始化为空数组。`arg`变量存储最后评估的函数参数。函数的参数应在从-π到+π的范围内；因此，我们将`arg`初始化为`-Math.PI`。然后，我们添加一个定时器，以固定间隔进行滴答，将`arg`增加1°，直到它达到+π，在这种情况下，它将重置为初始值。
- en: Changes to `arg` are intercepted in the handler we implement next. In there,
    we push a new item to the array of points. The value is calculated by the `func` function, which
    is quite complicated, but it is sufficient to say that it returns a value from
    within a range of −1 to +1\. The oldest records are removed from the array of
    points using `Array.slice()` so that at most, the last `canvas.width` items remain
    in the array. This is so that we can plot one point for each pixel of the width
    of the canvas, and we don't have to store any more data than required. At the
    end of the function, we invoke `requestPaint()`, which is an equivalent of `QWidget::update()` and
    schedules a repaint of the canvas.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现的处理器中，对`arg`的更改会被拦截。在那里，我们将一个新项目推送到点的数组中。这个值是通过`func`函数计算的，该函数相当复杂，但可以简单地说它返回一个在-1到+1范围内的值。使用`Array.slice()`从点的数组中删除最旧的记录，这样数组中最多只保留`canvas.width`个最后的项目。这样做是为了我们可以为画布宽度的每个像素绘制一个点，而且我们不需要存储比所需更多的数据。在函数的末尾，我们调用`requestPaint()`，这相当于`QWidget::update()`，并安排画布的重绘。
- en: That, in turn, calls our `onPaint` signal handler. There, after retrieving the
    context, we reset the canvas to its initial state and then calculate an array
    of points that is to be drawn again using `slice()`. Then, we prepare the canvas
    by translating and scaling it in the vertical axis so that the origin is moved
    to half of the height of the canvas (that's the reason for calling `reset()` at
    the beginning of the procedure—to revert this transformation). After that, `beginPath()` is
    called to inform the context that we are starting to build a new path. Then, the
    path is built segment by segment by appending lines. Each value is multiplied
    by `canvas.height / 2` so that values from the point array are scaled to the size
    of the item. The value is negated as the vertical axis of the canvas grows to
    the bottom, and we want positive values to be above the origin line. After that,
    we set the width of the pen and draw the path by calling `stroke()`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这会调用我们的`onPaint`信号处理器。在那里，在检索上下文后，我们将画布重置到其初始状态，然后使用`slice()`计算要再次绘制的点的数组。然后，我们通过在垂直轴上平移和缩放画布来准备画布，以便将原点移动到画布高度的一半（这就是为什么在程序开始时调用`reset()`的原因——为了撤销这种转换）。之后，调用`beginPath()`来通知上下文我们开始构建一个新的路径。然后，通过附加线条分段构建路径。每个值都乘以`canvas.height
    / 2`，以便将点数组的值缩放到项目的大小。由于画布的垂直轴增长到底部，我们想要正值在原点线上方，因此该值被取反。之后，我们设置笔的宽度并通过调用`stroke()`来绘制路径。
- en: Time for action – Hiding properties
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 隐藏属性
- en: If we convert our heartbeat canvas to a QML component, the `points` and `arg` properties
    will be the public properties visible to the user of the component. However, they
    are really implementation details we want to hide. We should only expose properties
    that make sense to the user of the component, such as `lineWidth` or `color`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将心跳画布转换为QML组件，`points`和`arg`属性将是组件用户可见的公共属性。然而，它们实际上是我们要隐藏的实现细节。我们应该只公开对组件用户有意义的属性，例如`lineWidth`或`color`。
- en: 'Since the `Timer` object inside the `Canvas` is not exported as public property,
    that timer object will be unavailable from the outside, so we can attach properties
    to the timer instead of attaching them to the top-level `Canvas` object. However,
    the properties do not belong to the timer logically, so this solution will be
    confusing. For such cases, there is a convention that you should create an empty `QtObject` child
    in the top-level object and move properties into it:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Canvas`内部的`Timer`对象没有作为公共属性导出，因此该定时器对象将无法从外部访问，因此我们可以将属性附加到定时器而不是顶级`Canvas`对象。然而，从逻辑上讲，这些属性不属于定时器，因此这种解决方案可能会令人困惑。对于这种情况，有一个约定，你应该在顶级对象中创建一个空的`QtObject`子对象并将属性移动到其中：
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`QtObject` is the QML representation of the `QObject` class. It is a QML type
    that doesn''t have any particular functionality, but can hold properties. As part
    of the convention, we set `id` of this object to `d`. The `onArgChanged` handler
    is moved to the private object as well. In the `onTriggered` and `onPaint` handlers,
    we should now refer to the internal properties as `d.points` and `d.arg`. Consider
    this example:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtObject`是`QObject`类的QML表示。它是一个没有特定功能但可以持有属性的QML类型。作为约定的一部分，我们将此对象的`id`设置为`d`。`onArgChanged`处理器也被移动到私有对象。在`onTriggered`和`onPaint`处理器中，我们现在应该引用内部属性为`d.points`和`d.arg`。考虑以下示例：'
- en: '[PRE69]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `points` and `arg` properties are now unavailable from the outside, leading
    to clean public interface of our heartbeat object.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`points` 和 `arg` 属性现在从外部不可用，这导致我们的心跳对象具有干净的外部接口。'
- en: Time for action – Making the diagram more colorful
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使图表更加多彩
- en: 'The diagram serves its purpose, but it looks a bit dull. Add some shine to
    it by defining three new color properties in the canvas object—`color`, `topColor`, `bottomColor`—and
    setting their default values to `black`, `red`, and `blue`, respectively:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表完成了其目的，但看起来有点单调。通过在画布对象中定义三个新的颜色属性——`color`、`topColor` 和 `bottomColor`——并分别将它们的默认值设置为
    `black`、`red` 和 `blue` 来给它添加一些光泽：
- en: '[PRE70]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, let''s make use of these properties by extending `onPaint` implementation:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们通过扩展 `onPaint` 实现来利用这些属性：
- en: '[PRE71]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Upon running the preceding code snippet, you get the following output:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码片段后，你将得到以下输出：
- en: '![](img/a9ce7759-007e-440c-9c3c-a6df4b2b1b81.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9ce7759-007e-440c-9c3c-a6df4b2b1b81.png)'
- en: What just happened?
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The modifications to `onPaint` that we implemented are creating another path
    and using that path to fill an area using a gradient. The path is very similar
    to the original one, but it contains two additional points that are the first
    and last points drawn projected onto the horizontal axis. This ensures that the
    gradient fills the area properly. Note that the canvas uses imperative code for
    drawing; therefore, the order of drawing the fill and the stroke matters—the fill
    has to be drawn first so that it doesn't obscure the stroke.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `onPaint` 实现所做的修改是创建另一个路径，并使用该路径通过渐变填充一个区域。该路径与原始路径非常相似，但它包含两个额外的点，即第一个和最后一个绘制到水平轴上的点。这确保了渐变能够正确填充区域。请注意，画布使用命令式代码进行绘图；因此，填充和描边的绘制顺序很重要——填充必须先绘制，以免遮挡描边。
- en: Using C++ classes as QML components
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++类作为QML组件
- en: In the next exercise, we will implement a car dashboard that can be used in
    a racing game and will show a number of parameters such as current speed and motor
    revolutions per minute. The input data will be provided by a C++ object. We'll
    see how to include this object into the QML object tree and use property bindings
    to implement the dashboard.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将实现一个可用于赛车游戏的汽车仪表盘，并显示当前速度和每分钟发动机转速等参数。输入数据将由一个C++对象提供。我们将看到如何将此对象包含到QML对象树中，并使用属性绑定来实现仪表盘。
- en: 'The final result will look similar to the following:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将类似于以下内容：
- en: '![](img/a197c586-48c3-456d-b365-297c88d58738.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a197c586-48c3-456d-b365-297c88d58738.png)'
- en: Time for action – Self-updating car dashboard
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 自更新汽车仪表盘
- en: We will start with the C++ part. Set up a new Qt Quick application. This will
    generate the main function for you that instantiates `QGuiApplication`   and 
    `QQmlApplicationEngine` and sets them up to load a QML document.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从C++部分开始。设置一个新的Qt Quick应用程序。这将为你生成主函数，该函数实例化 `QGuiApplication` 和 `QQmlApplicationEngine`
    并将它们设置为加载QML文档。
- en: 'Use the File menu to create New file or Project and create a new Qt Designer
    form class. Call it `CarInfo` and choose the `Widget` template. We will use this
    class for modifying values of different parameters so that we may observe how
    they influence what the Qt Quick scene displays. In the class declaration, add
    the following properties:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `文件` 菜单创建 `新建文件或项目` 并创建一个新的Qt Designer表单类。将其命名为 `CarInfo` 并选择 `Widget` 模板。我们将使用此类来修改不同参数的值，以便我们可以观察它们如何影响Qt
    Quick场景的显示。在类声明中，添加以下属性：
- en: '[PRE72]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The properties are read-only, and the `NOTIFY` clause defines signals emitted
    when the respective property values change. Go ahead and implement the appropriate
    functions for each property. Apart from the getter, also implement a setter as
    a public slot. Here''s an example for a property controlling the speed of the
    car:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是只读的，`NOTIFY` 子句定义了在相应属性值更改时发出的信号。继续为每个属性实现相应的函数。除了获取器之外，还实现一个公共槽作为设置器。以下是一个控制汽车速度的属性的示例：
- en: '[PRE73]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You should be able to follow the example for the remaining properties on your
    own.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够自己跟随示例来处理剩余的属性。
- en: 'Since we want to use the widget to tweak property values, design the user interface
    for it using the form editor. It can look like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望使用小部件来调整属性值，因此使用表单编辑器设计其用户界面。它可以看起来像这样：
- en: '![](img/b5191e3b-b1a6-41fd-9a29-5e297308d7c9.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5191e3b-b1a6-41fd-9a29-5e297308d7c9.png)'
- en: Make appropriate signal-slot connections in the widget so that modifying any
    of the widgets for a given parameter or using the setter slot directly updates
    all the widgets for that parameter.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在小部件中建立适当的信号-槽连接，以便修改给定参数的任何小部件或直接使用设置器槽更新该参数的所有小部件。
- en: Instead of adding member variables to the `CarInfo` class for properties such
    as `speed`, `rpm`, `distance`, or `gear`, you can operate directly on the widgets
    placed on the `ui` form, as shown further.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在 `CarInfo` 类中为 `speed`、`rpm`、`distance` 或 `gear` 等属性添加成员变量，你可以直接在 `ui` 表单上放置的小部件上操作，如进一步所示。
- en: 'For example, a getter for the `distance` property will look like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`distance` 属性的获取器将看起来像这样：
- en: '[PRE74]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The setter would then be modified to the following:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将设置器修改为以下内容：
- en: '[PRE75]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You will then need to add `connect()` statements to the constructor to ensure
    that signals are propagated from the ui form:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要向构造函数中添加 `connect()` 语句，以确保信号从 ui 表单传播：
- en: '[PRE76]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, you can test your work by running the widget. To do this, you have to
    alter the main function to look as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以通过运行小部件来测试你的工作。为此，你必须修改主函数，使其看起来如下：
- en: '[PRE77]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Since we are using widgets, we have to replace `QGuiApplication` with  `QApplication` 
    and enable the widgets module by placing `QT += widgets` in the project file (remember
    to run `qmake` from the project's context menu afterward). Ensure that everything
    works as expected (that is, that moving sliders and changing spinbox values reflect
    the changes to widget properties) before moving on to the next step.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用小部件，我们必须将 `QGuiApplication` 替换为 `QApplication`，并通过在项目文件中放置 `QT += widgets`
    启用小部件模块（记得在项目上下文菜单中运行 `qmake`）。在继续下一步之前，确保一切按预期工作（即，移动滑块和更改微调框值反映小部件属性的变化）。
- en: 'We will now add Qt Quick to the equation, so let''s start by updating our main
    function to display our scene. Introduce the highlighted changes to the code:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将 Qt Quick 加入到等式中，所以让我们首先更新我们的主函数以显示我们的场景。向代码中引入以下高亮显示的更改：
- en: '[PRE78]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The modifications create a QML engine for our scene, export the `CarInfo` instance
    to the global context of the QML engine, and load and display the scene from a
    file located in a resource.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这些修改创建了一个用于场景的 QML 引擎，将 `CarInfo` 实例导出到 QML 引擎的全局上下文中，并从资源中的文件加载并显示场景。
- en: It is important to first export all the objects and only then load the scene.
    This is because we want all the names to be already resolvable when the scene
    is being initialized so that they can be used right away. If we reversed the order
    of calls, we would get a number of warnings on the console about the identities
    being undefined.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导出所有对象，然后才加载场景，这是非常重要的。这是因为我们希望在场景初始化时所有名称都已可解析，以便它们可以立即使用。如果我们颠倒调用顺序，我们会在控制台得到许多关于身份未定义的警告。
- en: Finally, we can focus on the QML part. Look at the picture of the result we
    want to be shown at the beginning of the exercise. For the black background, we
    used a bitmap image created in a graphical editor (you can find the file in the
    materials for this book), but you can obtain a similar effect by composing three
    black rounded rectangles directly in Qt Quick—the two outer parts are perfect
    circles, and the inner module is a horizontally stretched ellipse.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以专注于 QML 部分。看看练习开始时我们想要显示的结果的图片。对于黑色背景，我们使用了一个在图形编辑器中创建的位图图像（你可以在本书的材料中找到该文件），但你也可以通过在
    Qt Quick 中直接组合三个黑色圆角矩形来获得类似的效果——两个外部分是完美的圆形，而内部模块是一个水平拉伸的椭圆。
- en: 'If you decide to use our background file (or make your own prettier image),
    you should add it to the project''s resources and put the following code into
    `main.qml`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用我们的背景文件（或制作你自己的更漂亮的图片），你应该将其添加到项目的资源中，并将以下代码放入 `main.qml`：
- en: '[PRE79]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: What we do here is add the image to the window and create three items to serve
    as containers for different elements of the dashboard. The containers are all
    centered in the parent, and we use a `horizontalCenterOffset` property to move
    the two outer items sideways. The values of the offset as well as the widths are
    based on the background image's geometry (note that all three containers are perfect
    squares). If instead of using our file, you settle for creating the three parts
    yourself using Qt Quick items, the containers will simply be anchored to the centers
    of the three black items.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是在窗口中添加图像并创建三个项目作为仪表盘不同元素的容器。这些容器都居中于父容器中，我们使用 `horizontalCenterOffset` 属性将两个外部的项目向侧面移动。偏移量和宽度的值都基于背景图像的几何形状（注意，所有三个容器都是完美的正方形）。如果你不使用我们的文件，而是决定自己使用
    Qt Quick 项目创建这三个部分，容器将简单地锚定到三个黑色项目的中心。
- en: The dials look complicated, but in reality, they are very easy to implement,
    and you have already learned everything you need to design them.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 表盘看起来很复杂，但实际上，它们非常容易实现，你已经学到了设计它们所需的一切。
- en: 'Let''s start with the needle. Use the context menu of the resource file to
    create a new QML file and call it `Needle.qml`. Open the file and place the following
    content:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从指针开始。使用资源文件的上下文菜单创建一个新的 QML 文件，并将其命名为 `Needle.qml`。打开文件并放置以下内容：
- en: '[PRE80]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The document defines an item with four attributes—the length of the needle (defaults
    to 80% of the dial's radius), the color of the needle, `middleColor`, which stands
    for the color of the needle's fixing, and the size, which defines how wide the
    needle is. The code is self-explanatory. The item itself does not have any dimensions
    and only acts as an anchor for visual elements—the needle itself is a thin rectangle
    oriented vertically with a fixing 20 units from the end. The fixing is a circle
    of the same color as the needle with a smaller circle in the middle that uses
    a different fill color. The smaller radius of the inner circle is obtained by
    filling the outer circle with a 25% margin from each side.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 文档定义了一个具有四个属性的项目——指针的长度（默认为表盘半径的 80%）、指针的颜色、`middleColor`，它代表指针固定的颜色，以及大小，它定义了指针有多宽。代码是自我解释的。项目本身没有尺寸，仅作为视觉元素的锚点——指针本身是一个垂直方向的细长矩形，从末端固定
    20 个单位。固定是一个与指针颜色相同的圆圈，中间有一个使用不同填充颜色的较小圆圈。内圆的较小半径是通过从每侧填充 25% 的外圆来获得的。
- en: As for the dials, we will put their code inline in the main file since we just
    have two of them and they differ a bit, so the overhead of creating a separate
    component with a well-designed set of properties will outweigh the benefits of
    having nicely encapsulated objects.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 至于表盘，由于我们只有两个，它们略有不同，所以创建一个具有精心设计的属性集的单独组件的开销将超过拥有良好封装对象的优点。
- en: 'If you think about what needs to be done to have the dial displayed and working,
    it seems that the hardest thing is to lay out the numbers nicely on the circle,
    so let''s start with that. Here''s an implementation of a function for calculating
    the position along a circle circumference, based on the radius of the circle and
    angle (in degrees) where an item should be positioned:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一下要完成哪些工作才能使表盘显示并正常工作，似乎最困难的事情是将数字整齐地排列在圆周上，所以让我们从这里开始。这是一个基于圆的半径和角度（以度为单位）计算圆周上位置的函数实现：
- en: '[PRE81]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The function converts degrees to radians and returns the desired point. The
    function expects the `width` property to be available that helps calculate the
    center of the circle and in case a radius was not given, serves as a means to
    calculate a feasible value for it.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将度数转换为弧度，并返回所需点。该函数期望 `width` 属性可用，这有助于计算圆的中心，如果没有给出半径，则作为计算其可行值的手段。
- en: 'With such a function available, we can use the already familiar `Repeater` element
    to position items where we want them. Let''s put the function in `middleContainer` and
    declare the dial for car speed:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样的函数可用后，我们可以使用已经熟悉的 `Repeater` 元素将项目放置在我们想要的位置。让我们将函数放在 `middleContainer` 中，并声明汽车速度表：
- en: '[PRE82]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You might have noted that we used an element called `Label`. We created it
    to avoid having to set the same property values for all the texts we use in the
    user interface:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们使用了一个名为 `Label` 的元素。我们创建它是为了避免在用户界面中使用的所有文本都需要设置相同的属性值：
- en: '[PRE83]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The dial consists of a repeater that will create 12 elements. Each element is
    an item positioned using the earlier described function. The item has a label
    anchored to it that displays the given speed. We use `120 + index * 12 * 2` as
    the angle expression as we want "0" to be positioned at 120 degrees and each following
    item positioned 24 degrees further.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 旋钮由一个重复器组成，将创建12个元素。每个元素都是使用之前描述的函数定位的项目。项目有一个标签与之锚定，显示给定的速度。我们使用`120 + index
    * 12 * 2`作为角度表达式，因为我们希望“0”位于120度，每个后续项目再额外24度。
- en: The needle is given rotation based on the value read from the `carData` object.
    Since the angular distance between consecutive 20 kph labels is 24 degrees, the
    distance for one kph is 1.2 and thus we multiply `carData.speed` by that factor.
    Item rotation is calculated with 0 degrees "pointing right"; therefore, we add
    90 to the initial 120 degree offset of the first label to obtain starting coordinates
    matching those of the label system.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的旋转是基于从`carData`对象读取的值。由于连续20公里每小时标签之间的角度距离是24度，因此每1公里每小时的距离是1.2，所以我们把`carData.speed`乘以这个系数。项目旋转是以0度“指向右”为基准计算的；因此，我们将第一个标签的初始120度偏移量加上90度，以获得与标签系统匹配的起始坐标。
- en: 'As you can see in the image of the final result at the beginning of this section,
    the speed dial contains small lines every 2 kph, with those divisible by 10 kph
    longer than others. We can use another `Repeater` to declare such ticks:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本文节开头的结果图像中看到的那样，速度旋钮每2公里每小时有细线，那些可以被10公里每小时整除的比其他的长。我们可以使用另一个`Repeater`来声明这样的刻度：
- en: '[PRE84]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Finally, we can put a label for the dial:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以为旋钮添加一个标签：
- en: '[PRE85]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Ensure that the label is declared before the dial needle, or give the needle
    a higher *z* value so that the label doesn't overpaint the needle.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在旋钮指针之前声明标签，或者给指针一个更高的`z`值，这样标签就不会覆盖指针。
- en: 'Next, repeat the process on your own for the left container by creating an
    RPM dial reading values from the `carData.rpm` property. The dial also displays
    the current gear of the car''s engine. Place the following code inside the `leftContainer` object
    definition:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过创建一个读取自`carData.rpm`属性的RPM旋钮，在自己的左侧容器上重复此过程。旋钮还显示汽车发动机的当前档位。将以下代码放在`leftContainer`对象定义内：
- en: '[PRE86]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The only part needing explanation is highlighted. It defines an array of gear
    labels starting with reverse, going through neutral, and then through five forward
    gears. The array is then indexed with the current gear and the text for that value
    is applied to the label. Note that the value is incremented by 1, which means
    the 0th index of the array will be used when `carData.gear` is set to `1`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解释的唯一部分已突出显示。它定义了一个从倒档开始，经过空档，然后通过五个前进档的档位标签数组。然后，该数组以当前档位进行索引，并将该值的文本应用于标签。请注意，值增加了1，这意味着当`carData.gear`设置为`1`时，将使用数组的0索引。
- en: We will not show how to implement the right container. You can do that easily
    yourself now with the use of the `Grid` positioner to lay out the labels and their
    values. To display the series of controls on the bottom of the right container
    (with texts `ABS`, `ESP`, `BRK`, and `CHECK`), you can use `Row` of `Label` instances.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会展示如何实现正确的容器。现在，您可以使用`Grid`定位器轻松地自己布局标签及其值。要显示右侧容器底部（带有文本`ABS`、`ESP`、`BRK`和`CHECK`）的控制系列，您可以使用`Label`实例的`Row`。
- en: Now, start the program and begin moving the sliders on the widget. See how the
    Qt Quick scene follows the changes.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动程序并开始移动小部件上的滑块。看看Qt Quick场景是如何跟随变化的。
- en: What just happened?
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have created a very simple `QObject` instance and exposed it as our "data
    model" to QML. The object has a number of properties that can receive different
    values. Changing a value results in emitting a signal, which in turn notifies
    the QML engine and causes bindings containing those properties to be reevaluated.
    As a result, our user interface gets updated.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常简单的`QObject`实例，并将其作为我们的“数据模型”暴露给QML。该对象有多个属性可以接收不同的值。更改一个值会导致发出一个信号，该信号反过来通知QML引擎，并导致包含这些属性的绑定被重新评估。因此，我们的用户界面得到更新。
- en: Time for action – Grouping engine properties
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 对发动机属性进行分组
- en: The data interface between the QML and C++ worlds that we created is very simple
    and has a small number of properties. However, as the amount of data we want to
    expose grows, the object can become cluttered. Of course, we can counter that
    effect by dividing it into multiple smaller objects, each having separate responsibilities
    and then exporting all those objects to QML, but that is not always desirable.
    In our case, we can see that `rpm` and `gear` are properties of the engine subsystem,
    so we can move them to a separate object; however, in reality, their values are
    tightly coupled with the speed of the car and to calculate the speed, we will
    need to know the values of those two parameters. However, the speed also depends
    on other factors such as the slope of the road, so putting the speed into the
    engine subsystem object just doesn't seem right. Fortunately, there is a nice
    solution to that problem.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 QML 和 C++ 世界之间的数据接口非常简单，并且属性数量很少。然而，随着我们想要公开的数据量增加，对象可能会变得杂乱。当然，我们可以通过将其分成多个更小的对象来抵消这种效果，每个对象都有各自的责任，然后将所有这些对象导出到
    QML 中，但这种方法并不总是可取的。在我们的例子中，我们可以看到 `rpm` 和 `gear` 是发动机子系统的属性，因此我们可以将它们移动到单独的对象中；然而，在现实中，它们的值与汽车的速度紧密相关，要计算速度，我们需要知道这两个参数的值。然而，速度还取决于其他因素，如道路的坡度，所以将速度放入发动机子系统对象中似乎并不合适。幸运的是，有一个很好的解决方案来解决这个问题。
- en: QML has a concept called grouped properties. You already know a number of them—the
    `border` property of the `Rectangle` element or the `anchors` property of the `Item` element,
    for example. Let's see how to define such properties for our exposed object.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: QML 有一个称为分组属性的概念。你已经知道其中的一些——例如 `Rectangle` 元素的 `border` 属性或 `Item` 元素的 `anchors`
    属性。让我们看看如何为我们的公开对象定义这样的属性。
- en: 'Create a new `QObject`-derived class and call it `CarInfoEngine`. Move the
    property definitions of `rpm` and `gear` to that new class along with their getters,
    setters, and change signals. Add the following property declaration to `CarInfo`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `QObject` 派生类，并将其命名为 `CarInfoEngine`。将 `rpm` 和 `gear` 的属性定义及其获取器、设置器和更改信号移动到这个新类中。向
    `CarInfo` 添加以下属性声明：
- en: '[PRE87]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Implement the getter and the private field:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 实现获取器和私有字段：
- en: '[PRE88]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We will not use the signal right now. However, we had to declare it; otherwise,
    QML would complain we were binding expressions that depend on properties that
    are non-notifiable:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会使用这个信号。但是，我们必须声明它；否则，QML 会抱怨我们正在绑定依赖于非可通知属性的表达示：
- en: '[PRE89]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Initialize `m_engine` in the constructor of `CarInfo`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CarInfo` 的构造函数中初始化 `m_engine`：
- en: '[PRE90]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Next, update the code of `CarInfo` to modify properties of `m_engine` whenever
    respective sliders on the widget are moved. Provide a link the other way as well—if
    the property value is changed, update the user interface accordingly.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 `CarInfo` 的代码，以便在部件上的相应滑块移动时修改 `m_engine` 的属性。也要提供反向链接——如果属性值发生变化，相应地更新用户界面。
- en: 'Update the QML document and replace `carData.gear` with `carData.engine.gear`.
    Do the same for `carData.rpm` and `carData.engine.rpm`. You should end up with
    something along the lines of the following:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 QML 文档，将 `carData.gear` 替换为 `carData.engine.gear`。对 `carData.rpm` 和 `carData.engine.rpm`
    也做同样的处理。你应该得到以下类似的内容：
- en: '[PRE91]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: What just happened?
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Essentially, what we did is expose a property in `CarInfo` that is itself an
    object that exposes a set of properties. This object of the `CarInfoEngine` type is
    bound to the `CarInfo` instance it refers to.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们所做的是在 `CarInfo` 中公开了一个属性，该属性本身是一个对象，它公开了一组属性。这个 `CarInfoEngine` 类型的对象绑定到它所引用的
    `CarInfo` 实例。
- en: Time for action – Registering C++ class as QML type
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 将 C++ 类注册为 QML 类型
- en: So far, what we did was expose ourselves to QML single objects created and initialized
    in C++. However, we can do much more—the framework allows us to define new QML
    types. These can either be generic `QObject`-derived QML elements or items specialized
    for Qt Quick.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的是公开了在 C++ 中创建和初始化的单个 QML 对象。然而，我们可以做更多——框架允许我们定义新的 QML 类型。这些类型可以是通用的
    `QObject` 派生 QML 元素，或者针对 Qt Quick 专门化的项目。
- en: We will start with something simple—exposing the `CarInfo` type to QML so that
    instead of instantiating it in C++ and then exposing it in QML, we can directly
    declare the element in QML and still allow the changes made to the widget to be
    reflected in the scene.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的事情开始——将 `CarInfo` 类型公开给 QML，这样我们就可以直接在 QML 中声明元素，而不是在 C++ 中实例化它并在 QML
    中公开，同时仍然允许对部件所做的更改反映在场景中。
- en: 'To make a certain class (derived from `QObject`) instantiable in QML, all that
    is required is to register that class with the declarative engine using the `qmlRegisterType` template
    function. This function takes the class as its template parameter along a number
    of function arguments: the module `uri`, the major and minor version numbers,
    and the name of the QML type we are registering. The following call will register
    the `FooClass` class as the QML type `Foo`, available after importing `foo.bar.baz` in
    Version 1.0:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 要使某个类（从`QObject`派生）在QML中可实例化，所需的所有操作就是使用`qmlRegisterType`模板函数将该类注册到声明性引擎中。这个函数接受类作为其模板参数以及一系列函数参数：模块`uri`、主版本号和次版本号，以及我们正在注册的QML类型名称。以下调用将`FooClass`类注册为QML类型`Foo`，在导入`foo.bar.baz`后，在版本1.0中可用：
- en: '[PRE92]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'You can place this invocation anywhere in your C++ code; just ensure that this
    is before you try to load a QML document that might contain declarations of `Foo` objects.
    A typical place to put the function call is in the program''s main function. Afterward,
    you can start declaring objects of the `Foo` type in your documents. Just remember
    that you have to import the respective module first:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的C++代码中的任何地方放置这个调用；只需确保这在你尝试加载可能包含`Foo`对象声明的QML文档之前。一个典型的放置函数调用的地方是程序的主函数。之后，你可以在你的文档中开始声明`Foo`类型的对象。只需记住，你必须首先导入相应的模块：
- en: '[PRE93]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Time for action – Making CarInfo instantiable from QML
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——使`CarInfo`可从QML实例化
- en: 'First, we will update the QML document to create an instance of `CarInfo` present
    in the `CarInfo 1.0` module:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更新QML文档以创建`CarInfo 1.0`模块中存在的`CarInfo`实例：
- en: '[PRE94]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As for registering `CarInfo`, it might be tempting to simply call `qmlRegisterType` on `CarInfo` and
    congratulate ourselves for a job well done:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 至于注册`CarInfo`，可能会让人想简单地调用`qmlRegisterType`在`CarInfo`上，并为自己做得很好而庆祝：
- en: '[PRE95]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In general, this would work (yes, it is as simple as that). However, it will
    not work with widgets. It''s not possible to include `QWidget`-based objects into
    a QML object tree because a `QWidget` object can only have another `QWidget` object
    as its parent, and QML needs to set the outer QML object as the parent. To resolve
    this conflict, we need to ensure that what we instantiate is not a widget. For
    that, we will use a proxy object that will forward our calls to the actual widget.
    Therefore, create a new class called `CarInfoProxy` derived from `QObject` and
    make it have the same properties as `CarInfo`. Consider this example:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这会起作用（是的，就这么简单）。然而，它不适用于小部件。无法将基于`QWidget`的对象包含到QML对象树中，因为`QWidget`对象只能将另一个`QWidget`对象作为其父对象，而QML需要将外部QML对象设置为父对象。为了解决这个冲突，我们需要确保我们实例化的不是小部件。为此，我们将使用一个代理对象，该对象将转发我们的调用到实际的小部件。因此，创建一个新的类`CarInfoProxy`，它从`QObject`派生，并使其具有与`CarInfo`相同的属性。考虑以下示例：
- en: '[PRE96]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Declare one more property that will let us show and hide the widget on demand:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个额外的属性，它将允许我们根据需要显示和隐藏小部件：
- en: '[PRE97]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Then, we can place the widget as a member variable of the proxy so that it
    is created and destroyed alongside its proxy:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将小部件作为代理的一个成员变量放置，这样它就会与代理一起创建和销毁：
- en: '[PRE98]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This way, the `CarInfo` widget will have `nullptr` parent, so it will be displayed
    as a top-level window. The QML engine will create an object of the `CarInfoProxy`
    class and set its parent to be another QML object, but this will not affect the
    parent of the widget.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`CarInfo`小部件将没有父对象`nullptr`，因此它将作为一个顶级窗口显示。QML引擎将创建一个`CarInfoProxy`类的对象，并将其父对象设置为另一个QML对象，但这不会影响小部件的父对象。
- en: 'Next, implement the missing interface. For simplicity, we are showing you code
    for some of the properties. The others are similar, so you can fill in the gaps
    on your own:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现缺失的接口。为了简单起见，我们展示了部分属性的代码。其他属性类似，所以你可以自己填补空白：
- en: '[PRE99]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You can see that we reuse the `CarInfoEngine` instance from the widget instead
    of duplicating it in the proxy class. Finally, we can register `CarInfoProxy` as `CarInfo`:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们重用了小部件中的`CarInfoEngine`实例，而不是在代理类中复制它。最后，我们可以将`CarInfoProxy`注册为`CarInfo`：
- en: '[PRE100]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If you run the code now, you will see that it works—`CarInfo` has become a
    regular QML element. Due to this, its properties can be set and modified directly
    in the document, right? If you try setting the speed or the distance, it will
    work just fine. However, try to set a property grouped in the `engine` property:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行代码，你会看到它起作用——`CarInfo`已经成为了一个常规的QML元素。因此，它的属性可以直接在文档中设置和修改，对吧？如果你尝试设置速度或距离，它将正常工作。然而，尝试设置分组在`engine`属性中的属性：
- en: '[PRE101]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'QML runtime will complain with a message similar to the following one:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: QML 运行时会发出类似于以下的消息：
- en: '[PRE102]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This is because the runtime does not understand the `engine` property—we declared
    it as `QObject` and yet we are using a property this class doesn't have. To avoid
    this issue, we have to teach the runtime about `CarInfoEngine`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为运行时不理解 `engine` 属性——我们将其声明为 `QObject`，但我们使用了一个这个类没有的属性。为了避免这个问题，我们必须让运行时了解
    `CarInfoEngine`。
- en: 'First, let''s update the property declaration macro to use `CarInfoEngine` instead
    of `QObject`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新属性声明宏，使用 `CarInfoEngine` 而不是 `QObject`：
- en: '[PRE103]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Also, the getter function itself:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，获取函数本身：
- en: '[PRE104]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You should make these changes in both the `CarInfo` and `CarInfoProxy` classes.
    Then, we should teach the runtime about the type:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 `CarInfo` 和 `CarInfoProxy` 类中做出这些更改。然后，我们应该让运行时了解这个类型：
- en: '[PRE105]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: What just happened?
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: In this exercise, we let the QML runtime know about two new elements. One of
    them is `CarInfo`, which is a proxy to our widget class. We told the engine that
    this is a full-featured class that is instantiable from QML. The other class, `CarInfoEngine`,
    also became known to QML; however, the difference is that every attempt to declare
    an object of this type in QML fails with a given warning message. There are other
    functions available for registering types in QML, but they are rarely used, so
    we will not be describing them here. If you are curious about them, type in `qmlRegister`
    in the Index tab of Creator's Help pane.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们让 QML 运行时了解两个新元素。其中一个是 `CarInfo`，它是我们小部件类的代理。我们告诉引擎这是一个功能齐全的类，可以从 QML
    中实例化。另一个类 `CarInfoEngine` 也被 QML 所知；然而，区别在于在 QML 中尝试声明此类对象的每个尝试都会以一个给定的警告消息失败。QML
    中还有其他用于注册类型的函数，但它们很少使用，所以我们不会在这里描述它们。如果你对此感兴趣，可以在 Creator 的“帮助”面板的索引标签中输入 `qmlRegister`。
- en: Pop quiz
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which QML type allows you to create a placeholder for an object that will
    be instantiated later?
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 哪种 QML 类型允许你为稍后实例化的对象创建一个占位符？
- en: '`Repeater`'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Repeater`'
- en: '`Loader`'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Loader`'
- en: '`Component`'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Component`'
- en: Q2\. Which QML type provides low-level access to individual touch events?
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 哪种 QML 类型提供了对单个触摸事件的低级访问？
- en: '`PinchArea`'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PinchArea`'
- en: '`MouseArea`'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MouseArea`'
- en: '`MultiPointTouchArea`'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MultiPointTouchArea`'
- en: Q3\. When can you access a component defined in another QML file without an
    import statement?
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 在什么情况下，你可以访问另一个 QML 文件中定义的组件而不需要导入语句？
- en: You can do that if the component is registered using the `qmlRegisterType` function
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用 `qmlRegisterType` 函数注册了组件，你可以这样做
- en: You can do that if the component file is added to the project resources
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将组件文件添加到项目资源中，你可以这样做
- en: You can do that if the component file is in the same directory as the current
    file
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将组件文件放在与当前文件相同的目录中，你可以这样做
- en: Summary
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: You are now familiar with multiple methods that can be used to extend Qt Quick
    with your own item types. You learned to use JavaScript to create custom visual
    items. You also know how to use C++ classes as non-visual QML elements fully integrated
    with your UI. We also discussed how to handle mouse, touch, keyboard, and gamepad
    events in Qt Quick applications. However, so far, despite us talking about "fluid"
    and "dynamic" interfaces, you haven't seen much of them. Do not worry; in the
    next chapter, we will focus on animations in Qt Quick as well as fancy graphics
    and applying what you learned in this chapter for creating nice-looking and interesting
    games. So, read on!
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经熟悉了多种可以用来扩展 Qt Quick 以添加自定义项目类型的方法。你学习了如何使用 JavaScript 创建自定义视觉项目。你还知道如何使用
    C++ 类作为完全集成到你的 UI 中的非视觉 QML 元素。我们还讨论了如何在 Qt Quick 应用程序中处理鼠标、触摸、键盘和游戏手柄事件。然而，到目前为止，尽管我们谈论了“流畅”和“动态”的界面，但你还没有看到很多这样的界面。不要担心；在下一章中，我们将专注于
    Qt Quick 中的动画以及华丽的图形，并将本章所学应用于创建看起来漂亮且有趣的游戏。所以，继续阅读吧！
