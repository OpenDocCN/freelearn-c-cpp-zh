<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor164"/>4</h1>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor165"/>Bringing Structure with Methods and Classes</h1>
			<p>In <a href="B19358_03.xhtml#_idTextAnchor100"><em class="italic">Chapter 3</em></a>, we learned about collection types and loops. These powerful concepts helped us to structure our data and run code an arbitrary number of times.</p>
			<p>Being able to reuse code in a loop is great, but what if we want to reuse this code at any arbitrary moment in time? And what if we want to reuse whole structures of code and data, such as – for example – enemies or vehicles?</p>
			<p>Methods and classes are exactly the concepts that will help us achieve this level of reuse!</p>
			<p>Over the course of this chapter, we’ll see the last few basic concepts of programming. By the end, we will have learned everything that is needed to call ourselves real programmers.</p>
			<p>In this chapter, we cover the following main topics:</p>
			<ul>
				<li>Functions</li>
				<li>Classes</li>
				<li>Type hinting</li>
				<li>Object-oriented programming (OOP)</li>
			</ul>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor166"/>Technical requirements</h1>
			<p>If you get stuck anywhere, don’t forget that you can find an example of everything we do in this chapter in the <code>chapter04</code> folder of the repository. You can find the repository here: <a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter04">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter04</a>.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor167"/>Methods are reusable bits of code</h1>
			<p>In <a href="B19358_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, we learned to <a id="_idIndexMarker195"/>write code with the <code>_ready()</code> method of a node. We saw that the code contained in this function would be executed from the moment <a id="_idIndexMarker196"/>our game started to run. Now, let’s look closer at what functions are and how we can use them.</p>
			<p class="callout-heading">Method versus function</p>
			<p class="callout">The terminologies <em class="italic">method</em> and <em class="italic">function</em> are often used interchangeably. They denote two very <a id="_idIndexMarker197"/>similar concepts but applied in different ways. In this <a id="_idIndexMarker198"/>book, we’ll use both interchangeab<a id="_idTextAnchor168"/>ly.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor169"/>What is a function?</h1>
			<p>A <code>find()</code> function:</p>
			<pre class="source-code">
var inventory = ["Amulet", "Bananas", "Candles"]
print(inventory.find("Bananas"))</pre>			<p>Under the hood, the interpreter looks up the code block that is associated with the <code>find</code> function, executes it with the <code>Bananas</code> string as input, and then returns the result to us.</p>
			<p>In the preceding case, we would print out the result. Note that the <code>print</code> statement we use in that code is also just a function!</p>
			<p>The input data <a id="_idIndexMarker200"/>we give to a function is called <strong class="bold">arguments</strong>.</p>
			<p>To oversimplify the technical aspects, a function is just a detour that our program makes from its normal path of execution – a sidetrack through another code b<a id="_idTextAnchor170"/>lock.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor171"/>Defining a function</h2>
			<p>Let’s have <a id="_idIndexMarker201"/>a look at a function that lowers the player’s h<a id="_idTextAnchor172"/>ealth:</p>
			<pre class="source-code">
func lower_player_health(am<a id="_idTextAnchor173"/>ount):
   player_health -= amount</pre>			<p>As you can see, to define a function, we need the following parts:</p>
			<ul>
				<li>The <code>func</code> keyword. This indicates to GDScript that we are about to define a new function, such as the <code>var</code> keyword for variables.</li>
				<li>A name. This is the name we will be using to call the function, <code>lower_player_health()</code> in this case. Make sure you select a descriptive name, just like with variable names.</li>
				<li>A list of parameters <a id="_idIndexMarker202"/>that are separated by commas and surrounded by parentheses; in this case, we only have one parameter: <code>amount</code>. These are the pieces of data we want the user of the function to provide us. It is not mandatory to have any parameters.</li>
				<li>The code block that gets executed when we call the function. Within this code block, we can use the parameters of the function as if they were normal variables.</li>
			</ul>
			<p class="callout-heading">Arguments and parameters</p>
			<p class="callout">Attentive readers might have noticed that when we call a function, the input data is called <strong class="bold">arguments</strong>, and while <a id="_idIndexMarker203"/>inside the function, we call them <strong class="bold">parameters</strong>. Parameters <a id="_idIndexMarker204"/>are basically the input variables of a function, while arguments are specific values with which we call upon the function.</p>
			<p class="callout">But don’t worry about mixing the terminology up; almost every programmer does, and everyone will know what you are talking about.</p>
			<p>The basic syntax of a function looks like this:</p>
			<pre class="source-code">
func &lt;function_name&gt;(&lt;parameter1&gt;, &lt;parameter2&gt;):
   &lt;code_block&gt;</pre>			<p>It’s good to note that the number of defined parameters can vary. In the syntax example, we defined two parameters, but we could define none or even a hundred.</p>
			<p>As an example, here is <a id="_idIndexMarker205"/>a function that simply prints out <code>Hello, World</code>:</p>
			<pre class="source-code">
func say_hello():
   print("Hello, World")</pre>			<h2 id="_idParaDest-97"><a id="_idTextAnchor174"/>Naming a function</h2>
			<p>Function <a id="_idIndexMarker206"/>names have the same constraints as variable names:</p>
			<ul>
				<li>They contain only alphanumerical characters.</li>
				<li>There should be no spaces.</li>
				<li>They can’t begin with a number.</li>
				<li>They should not be named after existing keywords.</li>
			</ul>
			<p>But unlike variable names, it is important that a function’s name reflects what the code within the function does. This way, you know what to expect when running a function.</p>
			<p>Here are some examples of good function names:</p>
			<pre class="source-code">
calculate_player_health()
apply_velocity()
prepare_race()</pre>			<p>And here are some examples of bad function names:</p>
			<pre class="source-code">
do_the_thing()
calculate()
a()</pre>			<p>Naming functions, just like naming anything while programming, is difficult but important. But it is necessary to give everything clear descriptive names.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor175"/>The return keyword</h2>
			<p>In <code>for</code> and <code>while</code> loops, we used the <code>break</code> keyword to prematurely exit the loop. In functions, we have a very similar keyword: <code>return</code>. This keyword will make the execution exit <a id="_idIndexMarker207"/>the function immediately. And to be fair, if you put a <code>return</code> statement within a loop, it will also stop that loop because we are no longer executing the function in general.</p>
			<p>Put it anywhere <a id="_idIndexMarker208"/>in a function and we can return to where we called the function, even if that means there is certain code that will never<a id="_idTextAnchor176"/> be executed:</p>
			<pre class="source-code">
func a_coo<a id="_idTextAnchor177"/>l_function():
   print("This piece of code will <a id="_idTextAnchor178"/>be executed")
   <strong class="bold">return</strong>
   print("This piece of code will NEVER EVER be executed")</pre>			<p>Functions can also return values, just like we saw with the <code>find()</code> function for arrays, which returned the index of the value we were searching for. To return a value, we use the <code>return</code> keyword again, but this time, we specify the value we want to return ri<a id="_idTextAnchor179"/>ght after it:</p>
			<pre class="source-code">
func minimum(number1, number2):
   if numb<a id="_idTextAnchor180"/>er1 &lt; number2:
      <strong class="bold">return number1</strong>
   else:
      <code>minimum()</code> function to get the smallest of th<a id="_idTextAnchor181"/>e two values:</p>
			<pre class="source-code">
print(m<a id="_idTextAnchor182"/>inimum(5, 2))
var lowest_number = minimum(1, 300)</pre>			<p>Running this snippet of code will print the number <code>2</code> and will populate the <code>lowest_number</code> variable with the number <code>1</code>.</p>
			<p>In this section, we implemented our own <code>minimum()</code> function, but this function actually already exists in the engine, called <code>min()</code>. So, from now on, you can use the one that the engine provides to find the smallest number.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor183"/>The pass keyword</h2>
			<p>When creating <a id="_idIndexMarker209"/>a new script, we’ve already seen the <code>_ready()</code> function structured like this:</p>
			<pre class="source-code">
func _ready():
   <code>pass</code> keyword comes in. It is a line of code that does nothing at all. We can thus use it to create a code block that carries no logic. This way, we can create empty functions.</p>
			<p>Empty functions are very useful in OOP, which we will talk abou<a id="_idTextAnchor184"/>t in <a href="B19358_05.xhtml#_idTextAnchor365"><em class="italic">Chapter 5</em></a>.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor185"/>Optional parameters</h2>
			<p>To make a function more flexible, you can decide to specify some parameters as optional. This way, you can later choose to provide the arguments or not. To do this, we must provide <a id="_idIndexMarker211"/>a default value for that argument.</p>
			<p>If you don’t <a id="_idIndexMarker212"/>give a value for these parameters while calling the function, GDScript will take the default values we specified.</p>
			<p>We can use this technique to extend our previous function about removing life from the health tot<a id="_idTextAnchor186"/>al of the pla<a id="_idTextAnchor187"/>y<a id="_idTextAnchor188"/>er:</p>
			<pre class="source-code">
extends Node
var <a id="_idTextAnchor189"/>p<a id="_idTextAnchor190"/>layer_health = 2
func lower_player_he<a id="_idTextAnchor191"/>alth(amount<strong class="bold"> = 1</strong>):
   player_health -= amount</pre>			<p>In the preceding example, the <code>lower_player_health()</code> function has one parameter, <code>amount</code>, which is optional. We know it is optional because we give it a default value within the definition using the equals sign. If we call this function and give it an argument, it will use that argument to fill in the amount. If we don’t give it any argument, it will default to <code>1</code> as the value for the amount. We can use this <a id="_idTextAnchor192"/>function like so:</p>
			<pre class="source-code">
lower_player_health(5) # Will subtract 5 from th<a id="_idTextAnchor193"/>e player's health
lower_player_health(2) # Will subtract 2 from th<a id="_idTextAnchor194"/>e player's health
lower_player_health() # Will subtract 1 from the player's health</pre>			<p>If a function <a id="_idIndexMarker213"/>has multiple parameters, of which one or more are optional, the optional parameters should always come last in the definition. This is because if you <a id="_idIndexMarker214"/>leave out one of the arguments, GDScript cannot guess which one and just assumes it is the last one. If we accidentally misorder the parameters, we’ll get an error from the code editor to tell us to properly order them.</p>
			<p>Let’s say we have to write a function that moves the player at a certain angle, with a certain speed, and we also have to specify if the player is running and can collide with t<a id="_idTextAnchor195"/>hings in the world:</p>
			<pre class="source-code">
func move_player(angle, is_running, speed = 20, c<a id="_idTextAnchor196"/>an_collide = true):
   # function body</pre>			<p>This <code>move_player()</code> function can be used in more diverse ways than the <code>lower_player<a id="_idTextAnchor197"/>_health()</code> function:</p>
			<pre class="source-code">
move_player(.5, true) # Fill none of the <a id="_idTextAnchor198"/>optional parameters
move_player(.5, true, 100) # Fill one of the <a id="_idTextAnchor199"/>optional parameters
move_player(.5, true, 1, false) # Fill two of the optional parameters</pre>			<p>As you can see, we can choose which optional parameters to fill out, as long as we always give them in the order they were specified in the function definition.</p>
			<p>Functions are <a id="_idIndexMarker215"/>the basis of all programming. Many programs <a id="_idIndexMarker216"/>work with just the data types we have learned about until now and functions. But let’s take it one step further and learn how we can group data and functions into one cohesiv<a id="_idTextAnchor200"/>e unit using classes.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor201"/>Classes group code and data together</h1>
			<p>Finally, we made it to one of the most important revolutions in computer science, something that shook the world of programming languages in the mid-60s: <strong class="bold">classes</strong>.</p>
			<p>Some smart <a id="_idIndexMarker217"/>computer engineers thought about how we use data and functions and saw that we often use a select set of functions on a select set of data. This led them to group these two together so that they would live very closely with one another. Such a group is called a class.</p>
			<p>In games, classes often model specific separate entities. We could have a class for the following:</p>
			<ul>
				<li>The player</li>
				<li>Enemies</li>
				<li>Collectibles</li>
				<li>Obstacles</li>
			</ul>
			<p>Each of these classes contains and manages its own data. The player class could manage the health and inventory of the player, while the collectibles manage what kind of collectibles they are and what effect they have on the player.</p>
			<p>In essence, each class is a custom data type, just like the ones we saw before. But now, we put in the data and functions ourselves! This is a very powerful concept,<a id="_idTextAnchor202"/> so let’s get started!</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor203"/>Defining a class</h2>
			<p>To create a simple class, we just use the <code>class</code> keyword with the name we would like the class to <a id="_idIndexMarker218"/>have. After that, we can start putting the class together by defining the variables and metho<a id="_idTextAnchor204"/>ds that it encompasses:</p>
			<pre class="source-code">
<strong class="bold">class Enemy:</strong>
   var damage<a id="_idTextAnchor205"/> = 5
   var health = 10
   func take_damage(amount):
      health -= amount
      if heal<a id="_idTextAnchor206"/>th &lt;= 0:
         die()
   func die():
      print("Aaargh I died!")</pre>			<p>Here, we see a class called <code>Enemy</code>; it has two member variables, <code>damage</code> and <code>health</code>, and two member methods, <code>t<a id="_idTextAnchor207"/>ake_damage()</code> and <code>die()</code>.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor208"/>Instancing a class</h2>
			<p>You can see the class as a blueprint or template of our custom data type. So, once we have a class <a id="_idIndexMarker219"/>with member variables and functions defined, we can make a new instance from it. We call this instance an <code>.new()</code> function on it:</p>
			<pre class="source-code">
var enemy = Enemy.new()</pre>			<p>Now, this variable contains an object of our very own <code>Enemy</code> class! With this object, we can access its member variables<a id="_idTextAnchor210"/> and call its functi<a id="_idTextAnchor211"/>ons:</p>
			<pre class="source-code">
print(enemy.damage)
enemy.take_damage(20)</pre>			<p>We can also use this object in container types such as arrays and dictionaries and can pass it as a<a id="_idTextAnchor212"/>n argument to functions:</p>
			<pre class="source-code">
var list_of_enemies = [
   Enem<a id="_idTextAnchor213"/>y.<a id="_idTextAnchor214"/>new(),
   Enemy.new(),
]
var dict_of_enemies = {
   <a id="_idTextAnchor215"/>"<a id="_idTextAnchor216"/>Enemy1": Enemy.new(),
}
<a id="_idTextAnchor217"/>
var enemy = Enemy.new()
any_function(enemy)</pre>			<p>You can see <a id="_idIndexMarker220"/>that instances of a class can be used just like an<a id="_idTextAnchor218"/>y other kind of variable.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor219"/>Naming a class</h2>
			<p>Classes need names, just like variables and methods. Although the name of a class has the same <a id="_idIndexMarker221"/>restrictions as that of a variable, the convention is to glue the words within the name against each other and capitalize the first letter of each. We call this <strong class="bold">Pascal case</strong> or <strong class="bold">PascalCase</strong> because it <a id="_idIndexMarker222"/>was popularized in Pascal, a programming language from 197<a id="_idTextAnchor220"/>0. Her<a id="_idTextAnchor221"/>e are a few ex<a id="_idTextAnchor222"/>amples:</p>
			<pre class="source-code">
Enemy
HealthTracker
InventoryItem</pre>			<p>These are all great class names. In <a href="B19358_05.xhtml#_idTextAnchor365"><em class="italic">Chapter 5</em></a>, we’ll go over some more<a id="_idTextAnchor223"/> tips about naming classes.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor224"/>Extending a class</h2>
			<p>We can also create <a id="_idIndexMarker223"/>a new class by extending an already existing one. This is called <strong class="bold">inheritance</strong> because we <a id="_idIndexMarker224"/>inherit all the data and logic from a parent class into a child class and extend upon it with new data and logic.</p>
			<p>To create a new enemy based on the previous one, for examp<a id="_idTextAnchor225"/>le, we follow this structure:</p>
			<pre class="source-code">
class BuffEnemy extends Enemy:
   fun<a id="_idTextAnchor226"/>c<a id="_idTextAnchor227"/> _init():
      health = 100
   func die():
      print("How did you defeat me?!?")</pre>			<p>You can see that we follow the new class’s name with the <code>extends</code> keyword and then the class we want to inherit from. To overwrite the variables of the original class, we have to set them within the <code>_init()</code> function. This is a special function, called the <code>BuffEnemy</code> class is created. The constructor should initialize the object so that it is ready to be used.</p>
			<p>You can also see that we can redefine methods, as I overwrite the <code>die</code> function to print out a different string. When the <code>BuffEnemy</code> class takes damage and dies, it will call the <code>die</code> function of the inherited class and not of the parent class.</p>
			<p>If we create an object of the <code>BuffEnemy</code> class, we can see that its health is indeed <code>100</code> and it will not die from <code>20</code> points of damage, and when the enemy dies, it will print out the new string <a id="_idTextAnchor228"/>from the overwritten function:</p>
			<pre class="source-code">
va<a id="_idTextAnchor229"/>r<a id="_idTextAnchor230"/> buff_enemy = BuffEnemy.n<a id="_idTextAnchor231"/>ew()
print(buff_enemy.dama<a id="_idTextAnchor232"/>g<a id="_idTextAnchor233"/>e)
buff_enemy.take_damage<a id="_idTextAnchor234"/>(<a id="_idTextAnchor235"/>20)
print(buff_enemy.health)
buff_enemy.take_damage(80)</pre>			<p>As an experiment, try creating <a id="_idIndexMarker226"/>a new enemy by exte<a id="_idTextAnchor236"/>nding the <code>Enemy</code> class yourself.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor237"/>Each script is a class!</h2>
			<p>I’ll let you in on a little secret. Each script we have written until now is already a class! You might <a id="_idIndexMarker227"/>already have realized this after reading the <em class="italic">Extending a class</em> section because the first line of each script we have written was to extend the <code>Node</code> class! This class is the base class for each type of node in the Godot engine.</p>
			<p>This <code>Node</code> class has a bunch of boilerplate data and code that Godot needs to use it during the game. Most of this is not of interest to us at the moment. But some that are of interest include the following:</p>
			<ul>
				<li><strong class="bold">Life-cycle methods</strong>: These are methods that get executed at certain times within the node’s life cycle – when it gets created, destroyed, or updated, for example.</li>
				<li><strong class="bold">The child and parent nodes</strong>: In Godot, nodes follow a hierarchical structure, and each node has a reference to its children and parent nodes. Having access to these helps a lot when dealing with a given hierarchical structure.</li>
			</ul>
			<p>The node we attach the script to gets paired with that script, and so with the script’s data and logic, and is basically an instanced object of the script.</p>
			<p>In <a href="B19358_07.xhtml#_idTextAnchor523"><em class="italic">Chapter 7</em></a>, we’ll also learn to extend more specific nodes, such as <code>Node2D</code> or <code>Sprite</code>.</p>
			<p>While normal classes are required to have a name, the class that is derived from a script does not, although it is possible to do so. Just use the <code>class_name</code> k<a id="_idTextAnchor238"/>eyword at the top of the<a id="_idTextAnchor239"/> script:</p>
			<pre class="source-code">
<strong class="bold">clas<a id="_idTextAnchor240"/>s_name</strong> MyCustomNode
extends Node
# Rest of the class</pre>			<p>Godot makes it<a id="_idTextAnchor241"/> easy for us to start a new class.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor242"/>When are certain variables available?</h2>
			<p>You may have already noticed, but the variables we define are not accessible from everywhere. Each <a id="_idIndexMarker228"/>variable has a certain domain within which you can use it. Let’s take a closer look at the following piece of code:</p>
			<pre class="source-code">
func _ready():
   var player_health = 5
   if player_health &gt; 2:
      var damage = 2
   player_health -= damage</pre>			<p>If you type this code out in the script editor, which I encourage you to do, you’ll see an error pop up at the last line saying that the variable called <code>damage</code> is not in scope. This means that the variable is not available to us and we cannot use it.</p>
			<p>In general, there are five scenarios in which a variable is available to us:</p>
			<ul>
				<li>The variable was defined within the same code block as where we use the variable, like so:<pre class="source-code">
var player_health = 2
print(player_health)</pre></li>				<li>The variable was defined in a code block that is a parent to the current code block, like so:<pre class="source-code">
var player_health = 2
if player_health &gt; 1:
   print(player_health)</pre></li>				<li>The variable was defined w<a id="_idTextAnchor243"/>ithin the cur<a id="_idTextAnchor244"/>r<a id="_idTextAnchor245"/>ent class, like so:<pre class="source-code">
ex<a id="_idTextAnchor246"/>t<a id="_idTextAnchor247"/>ends Node
var player_health = 2
func _ready():
   print(player_health)</pre></li>				<li>The variable was defined globally. We’ll learn more about this kind of variable in <a href="B19358_10.xhtml#_idTextAnchor632"><em class="italic">Chapter 10</em></a>. But it suffices <a id="_idIndexMarker229"/>to say that this kind of variable is available anywhere any time, in any script, even in the editor itself. This kind of variable is very useful for storing information used by many different processes. We call these <strong class="bold">autoloads</strong>.</li>
				<li>The variable was built into the engine. These variables are exposed to us on a global level; we did not define them ourselves. You can find a list of these global constants and functions here: <a href="https://docs.godotengine.org/en/stable/classes/class_%40globalscope.html">https://docs.godotengine.org/en/stable/classes/class_%40globalscope.html</a>.</li>
			</ul>
			<p>Here are a few examples:</p>
			<pre class="source-code">
PI # Carries the constant of pi, about 3.1415
Time
OS</pre>			<p>The domain within <a id="_idIndexMarker230"/>which a variable is accessible is called its <strong class="bold">scope</strong>.</p>
			<p>While it is not possible to define two variables with the same name within the same scope, it is possible to define two variables with the same name when one is outside the current function and the other inside it. We call this <strong class="bold">shadowing</strong> because one lives in the shadow of the other. For example, one variable is defined within the class as a member variable and th<a id="_idTextAnchor248"/>e other withi<a id="_idTextAnchor249"/>n<a id="_idTextAnchor250"/> a function, li<a id="_idTextAnchor251"/>k<a id="_idTextAnchor252"/>e so:</p>
			<pre class="source-code">
extends Node
<strong class="bold">var damage = 3</strong>
func a_function():
   <strong class="bold">var damage = 100</strong>
   print(damage)</pre>			<p>If you run the <a id="_idIndexMarker231"/>preceding code, you will see it print out <code>100</code>, because when in doubt, GDScript will always take the closest defined variable:</p>
			<div><div><img alt="Figure 4.1 – A warning that tells us the damage variable is defined within the script and within the function" src="img/B19358_04_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – A warning that tells us the damage variable is defined within the script and within the function</p>
			<p>However, as shown in <em class="italic">Figure 4</em><em class="italic">.1</em>, you will also see that the engine throws a warning telling us about the double usage of the variable name, which could lead<a id="_idTextAnchor253"/> to confusion for us as developers.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor254"/>The scope of a function</h2>
			<p>Functions also have a certain scope, though a little more restricted than the scope of a variable. You can <a id="_idIndexMarker232"/>use a function in the following scenarios:</p>
			<ul>
				<li>The function was defined within the class we are using.</li>
				<li>The function was defined within any parent class that our class inherits from.</li>
				<li>The function was built into the engine; these are availab<a id="_idTextAnchor255"/>le from anywh<a id="_idTextAnchor256"/>ere. Here’s an example:</li>
			</ul>
			<pre class="source-code">
print("Hey")
max(5, 3) # Re<a id="_idTextAnchor257"/>turns the highest of the two numbers
sin(PI) # Returns the sinus value for an angle</pre>			<p>But, as we saw earlier, we can also call a class function of an object. This way, the scope of that functi<a id="_idTextAnchor258"/>on is as big as the object’s scope.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor259"/>Types help us to know how to use a variable</h1>
			<p>We saw different data types and even know how to create our own. But there was one big problem! Variables <a id="_idIndexMarker233"/>could change type mid-execution. This is particularly annoying because if we use the wrong type of data in a ce<a id="_idTextAnchor260"/>rtain situation, the gam<a id="_idTextAnchor261"/>e will crash!</p>
			<pre class="source-code">
var num<a id="_idTextAnchor262"/>b<a id="_idTextAnchor263"/>er_of_lives = 5
<strong class="bold">number_of_lives += 1</strong>
number_of_lives = {
   p<a id="_idTextAnchor264"/>la<a id="_idTextAnchor265"/>yer_lives = 5,
   enemie_lives = 1,
}
<code>1</code> to the value <code>5</code>, another number, while in the second instance, we try to add <code>1</code> to a whole dictionary. This operation is not supported and thus crashes the game.</p>
			<p>Luckily, there is a way we can leverage our knowledge of what data type we expect for certain operations or functions. This is what we will l<a id="_idTextAnchor266"/>earn over the course of this section.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor267"/>What is type hinting?</h1>
			<p>Other popular languages such as C++, C#, Java, Golang, and Rust solve the problem of not knowing <a id="_idIndexMarker234"/>what data type a variable is by implicitly specifying what type it will carry from the moment it is defined. There is (almost) no way of defining a variable without locking it to a certain type. Also, the type of a variable, unlike in GDScript, cannot be changed over the course of a program in those other languages.</p>
			<p>In GDScript, there is a system to do something such as this too, but less restrictive. This system is called <strong class="bold">type hinting</strong> because we give a hint of what type we would like a variable to be in. This helps GDScript to determine beforehand if an operation will work or is going to crash the game.</p>
			<p>Let’s have a look at different ways to type hint in GDScript.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor268"/>Type hinting variables</h2>
			<p>For example, if we want <a id="_idIndexMarker235"/>to specify that the player’s number of lives will always be a whole number, aka an <em class="italic">integer</em>, we can give a<a id="_idTextAnchor269"/> hint of this variable’s type, like so:</p>
			<pre class="source-code">
var number_of_lives<strong class="bold">: int</strong> = 5</pre>			<p>We can do the<a id="_idTextAnchor270"/> same for different data types as<a id="_idTextAnchor271"/> well:</p>
			<pre class="source-code">
var player_name<strong class="bold">: String</strong> = "Erik"
var inventory<strong class="bold">: Array</strong> = ["Cool glasses", "Drinks"]</pre>			<p>If we try to assign a value of a different type to a type-hinted variable, as in the following example, the code editor will give us a warning before we run <a id="_idTextAnchor272"/>the game and an error while running it:</p>
			<pre class="source-code">
var invent<a id="_idTextAnchor273"/>ory: Array = ["Cool glasses", "Drinks"]
inventory = 100</pre>			<p>Note that we can only type hint a variable while defining it. After the definition, we can freely use the variable, and the engine needs to know if it is a specific type. That is why we cannot just add a type or change it later on.</p>
			<p>Type hinting helps us to catch bugs before they happen!</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor274"/>Type hinting arrays</h2>
			<p>On top of specifying that a certain variable is an <code>Array</code> type, we can also specify the type of values <a id="_idIndexMarker236"/>we can find within this array. This is very useful and makes it easy for us to know what kind of data to expect within an array.</p>
			<p>To specify what data types can be found within an array, just mention this type within square brackets after the <code>Array</code> type, like so:</p>
			<pre class="source-code">
var cool_numbers: Array<code>cool_numbers</code> is an array of floating-point numbers, and thus every element of this array should be treated as a floating-point number.</p>
			<p>As an <a id="_idIndexMarker237"/>experiment, try the fo<a id="_idTextAnchor275"/>llowing line of code. It will error; why?</p>
			<pre class="source-code">
var inventory: Array[String] = ["Cool glasses", "Drinks", 100]</pre>			<p>If you try it out, you’ll see this will error because we are hinting that the <code>inventory</code> variable is an array filled with strings. But one of the values within the array is a number. T<a id="_idTextAnchor276"/>he engine will see this and give an error.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor277"/>Learning about the Variant type</h2>
			<p>In the background, GDScript will use <code>Variant</code> as, almost, every variable’s type. The <code>Variant</code> class can <a id="_idIndexMarker238"/>hold almost any other data type; that is why we can switch the type of a variable mid-execution when we don’t specify a type at its creation.</p>
			<p>Also, variables that <a id="_idIndexMarker239"/>we type hinted are <code>Variant</code> types. But they have extra type requirements attached to them, such as that their value should be an integer or a dictionary.</p>
			<p>In GDScript, we never deal directly with the functionality of the <code>Variant</code> class. GDScript wraps it nicely around whatever value we assign it, and thus we don’t have to worry about the <code>Variant</code> type. We can just reason about the data type of the data we are storing in the variable.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor278"/>Type hinting function parameters</h2>
			<p>In addition <a id="_idIndexMarker240"/>to hinting the type of a variable, we can also hint the type of the <a id="_idTextAnchor279"/>parameters of a function in the same manner:</p>
			<pre class="source-code">
func take_damage(amount<strong class="bold">: int</strong>):
   player_health -= amount</pre>			<p>Now, if you try to call this function with an argument that is not an integer, the editor will warn you that you are making a mistake. For example, take a look at the following line of code, which uses the <code>take_damag<a id="_idTextAnchor280"/>e()</code> function from the previous code snippet:</p>
			<pre class="source-code">
take_damage("Two")</pre>			<p>Here, the engine <a id="_idIndexMarker241"/>will throw an error because the <code>take_damage()</code> function expects an integer value, and a string is not compatible with an integer.</p>
			<p class="callout-heading">Automatic conversion of variables</p>
			<p class="callout">When you try <code>take_damage(1.5)</code>, you’ll see that the editor doesn’t show a warning or throw an error. This is because GDScript automatically converts certain variables from one type to <a id="_idIndexMarker242"/>another. This is called <strong class="bold">implicit conversion</strong>.</p>
			<p class="callout">One of these conversions happens between floating-point and integer numbers. In this case, GDScript will round the floating-point number down to the nearest integer value. For our little example at the start of this callout, this means that <code>1.5</code> will be rounded down to an integer value of <code>1</code>.</p>
			<p>Type hinting can also be combined with a default value for the parameter; just put the type h<a id="_idTextAnchor281"/>int first and specify the default value after:</p>
			<pre class="source-code">
func take_damage(amount: int<strong class="bold"> = 1</strong>):
   player_health -= amount</pre>			<p>The <code>take_damage()</code> function now takes one parameter, <code>amount</code>, which is type hint<a id="_idTextAnchor282"/>ed as an integer and has a default value of <code>1</code>.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor283"/>Type hinting function returns</h2>
			<p>We can also <a id="_idIndexMarker243"/>type hint the value that will be returned by a function. This is very useful because it gives us a lot of information about what to expect fro<a id="_idTextAnchor284"/>m that function. The way to do this is like so:</p>
			<pre class="source-code">
func minimum(number_1: float, number_2: float)<strong class="bold"> -&gt; float</strong>:
   if number_1 &lt; number_2:
      return number_1
   else:
      return number_2</pre>			<p>This <code>minimum()</code> function will always have to return a floating-point number, no matter which <code>return</code> statement does so.</p>
			<p>As an <a id="_idIndexMarker244"/>experiment, try returning nothing in a function that is type hinted to return a floating-point number; you’ll see <a id="_idTextAnchor285"/>that we get an error thrown at us by the engine.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor286"/>Using void as a function return</h2>
			<p>Sometimes, a function does not return a value at all. In that case, we can type hint the return <a id="_idIndexMarker245"/>value of that function using the <code>void</code> type. <code>void</code> cannot be used for variables, only in function definitions. So, <code>void</code> indi<a id="_idTextAnchor287"/>cates that the function doe<a id="_idTextAnchor288"/>s<a id="_idTextAnchor289"/> not return anything:</p>
			<pre class="source-code">
var player_health: int = 5
func subtract_amount_from_health(amount: int)<strong class="bold"> -&gt; void</strong>:
   player_health -= amount</pre>			<p>However, most people will omit the <code>void</code> type hint when a function doesn’t return anything and only type hint the function when it actually does return something. It is good to know that the <code>void</code> <a id="_idTextAnchor290"/>type hint exists when you encounter it somewhere.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor291"/>Inferred types</h2>
			<p>There is a second way of typing a variable without explicitly giving it a type. This method leverages <a id="_idIndexMarker246"/>the type recognition of the engine itself. We can namely use the type of the first value assigned to the variable as the type of that variable for <a id="_idTextAnchor292"/>the rest of the execution. We can do that like so:</p>
			<pre class="source-code">
var number_of_lives <strong class="bold">:=</strong> 5</pre>			<p>This looks very similar to a regular, untyped, variable definition. But this time, we put a colon before the equals sign. This will lock the type of the variable to the type of the value we are assigning to it.</p>
			<p>This technique <a id="_idIndexMarker247"/>is called <strong class="bold">type inferring</strong> because GDScript is just taking the type of the value we are passing it during assignment.</p>
			<p>Note that, just like with normal variable type hinting, we can only infer a variable’s type while<a id="_idTextAnchor293"/> defining it. So, th<a id="_idTextAnchor294"/>e following code will not work:</p>
			<pre class="source-code">
var number_of_lives
number_of_lives := 5 # This will error</pre>			<p>Type inferring <a id="_idIndexMarker248"/>can make it easier for us to type hint variables with<a id="_idTextAnchor295"/>out having to think about the actual type in advance.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor296"/>null can be any type</h2>
			<p>Knowing what <a id="_idIndexMarker249"/>type a variable carries does not mean we don’t have to look out for variables that are <code>null</code>. <code>null</code> can be assigned to any kind of variable that is not a basic type (<code>int</code>, <code>float</code>, <code>String</code>, and so on). So, arrays, dictionaries, self-defined classes, and th<a id="_idTextAnchor297"/>e like can still be <code>null</code> if they are not initialized:</p>
			<pre class="source-code">
var inve<a id="_idTextAnchor298"/>ntory: Array[String] = ["Bananas"<a id="_idTextAnchor299"/>, "Cinder", "Drake"]
inventory = <strong class="bold">null</strong> # This is legal
inventory.find("Drake") # This will crash the game</pre>			<p><code>nul<a id="_idTextAnchor300"/>l</code> is often used to reset variables to an empty state.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor301"/>Autocompletion</h2>
			<p>Another great perk of typing our variables is that the text editor will help us out when we want to <a id="_idIndexMarker250"/>call a function or get to a member variable of a class by providing autocompletion. For example, if we have a string and we start typing to call a function on it, a little popup will show all the possible functions we are trying to get to. We can then just keep typing or use the arrow keys to select the right function and press <em class="italic">Enter</em> to select one. This helps tremendously if you know what you want to do but are not completely sure what the function was called, or just to speed up typing out long function names:</p>
			<div><div><img alt="Figure 4.2 – The code editor will help us out with autocompletion when using type hinting" src="img/B19358_04_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The code editor will help us out with autocompletion when using type hinting</p>
			<p>Autocomplete <a id="_idIndexMarker251"/>is our friend in general, so making the autocomplete, well<a id="_idTextAnchor302"/>, more complete will only help us out in the long run.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor303"/>Using type hinting for named classes</h2>
			<p>In addition to built-in types, we can also type hint our own custom classes. But for that, we first <a id="_idIndexMarker252"/>have to register a name for the type of our class. To register the name, we can use the <code>class_name</code> keyword followed by the name we would like the data typ<a id="_idTextAnchor304"/>e of our class to <a id="_idTextAnchor305"/>have at the t<a id="_idTextAnchor306"/>o<a id="_idTextAnchor307"/>p of the file, like so<a id="_idTextAnchor308"/>:<a id="_idTextAnchor309"/></p>
			<pre class="source-code">
class_name Player
extends Node
var player_health = 2
func _ready():
   print(player_health)</pre>			<p>Here, we see that we name our class <code>Player</code>. We can now use this type to type hint variables of the <code>Player</code> class and even u<a id="_idTextAnchor310"/>se it to initiate a new instance o<a id="_idTextAnchor311"/>f the class, like so:</p>
			<pre class="source-code">
var player: <strong class="bold">Player</strong> = Player.new()
player.player_health += 1</pre>			<p>Naming classes is an easy way to ty<a id="_idTextAnchor312"/>pe hint variables with instances of our custom classes.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor313"/>Performance</h2>
			<p>In addition to catching bugs before they happen and having autocompletion, type hinting has <a id="_idIndexMarker253"/>one last big advantage up its sleeve. If you type the variables in your game, the engine will be able to work with them way easier, resulting in better performance.</p>
			<p>Because the engine doesn’t need to check if a variable will be able to perform certain operations, it can do more of these operations per second<a id="_idTextAnchor314"/>. In some cases, this will make your code twice as fast!</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor315"/>Editor adding type hints</h2>
			<p>As a last <a id="_idIndexMarker254"/>tip around type hinting, I would like to show you that the editor can help you out too! If you go into <strong class="bold">Editor Settings</strong> | <strong class="bold">Text Editor</strong> | <strong class="bold">Completion</strong>, there is a setting called <strong class="bold">Add Type Hints</strong>. This setting will let the editor autocomplete certain parts of your code with type hints. I recommend you turn it on:</p>
			<div><div><img alt="Figure 4.3 – The Add Type Hints setting" src="img/B19358_04_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The Add Type Hints setting</p>
			<p>With this setting enabled, the editor will automatically fill out type hints whenever it has to generate <a id="_idIndexMarker255"/>any code for us – for example, when generating an empty script.</p>
			<p>In this section, we learned a lot about type hinting and saw how it can enhance our coding experience. Next, let’s take<a id="_idTextAnchor316"/> a look at a very important concepts in programming: OOP.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor317"/>OOP primer</h1>
			<p>So far in <a id="_idIndexMarker256"/>this chapter, we have learned about functions, classes, and objects. These concepts are very powerful: they give us a completely different way of working with data and the logic that accompanies it.</p>
			<p>In programming, there are multiple different paradigms of structuring code and data, one of them is <strong class="bold">Object Oriented Programming</strong> (<strong class="bold">OOP</strong>). GDScript is an <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) and <strong class="bold">imperative</strong> programming language, which means that we group data and its <a id="_idIndexMarker257"/>accompanying logic within classes and objects. The logic <a id="_idIndexMarker258"/>we write consists of statements that tell the <a id="_idIndexMarker259"/>computer fairly exactly what to do and how to do it for us. Each statement changes the internal state of the program. Most game engines and their accompanying programming languages are OO and imperative.</p>
			<p>OOP is built upon four key principles: inheritance, abstraction, enc<a id="_idTextAnchor318"/>apsulation, and polymorphism. So, let’s have a look at these.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor319"/>Inheritance</h2>
			<p>OOP allows classes to inherit from one another. This means that we get all the functionality <a id="_idIndexMarker260"/>from the parent class for free and can extend it with extra logic. This makes reusing code very easy.</p>
			<p>For example, while there could be a lot of different enemies within a game, most of those would <a id="_idIndexMarker261"/>share some quite common code, and more common code would then differentiate them. Pathfinding, dealing damage, health management, inventory management, and so on would be shared by almost any enemy. So, we could define one class, <code>Enemy</code>, that encapsulates all of these functionalities and from which all other enemies can inherit.</p>
			<p>From here, we can define enemies that do the following:</p>
			<ol>
				<li>Walk up to the player and use melee attacks.</li>
				<li>Stay at a distance and shoot projectiles at the player.</li>
				<li>Move around a lot and heal other enemies.</li>
				<li>And so forth…</li>
			</ol>
			<p>This list is non-exhaustive and shows that we can base a diverse cast of enemies on the same base <code>Enemy</code> class.</p>
			<p>We can visually represent this inheritance, just like we do with humans and their families, using an inheritance tree:</p>
			<div><div><img alt="Figure 4.4 – Different kinds of enemies can easily be derived from the base Enemy class" src="img/B19358_04_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Different kinds of enemies can easily be derived from the base Enemy class</p>
			<p><em class="italic">Figure 4</em><em class="italic">.4</em> clearly shows <a id="_idIndexMarker262"/><a id="_idTextAnchor320"/>how certain classes are related and/or differ from <a id="_idIndexMarker263"/>one another.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor321"/>Abstraction</h2>
			<p>A class <a id="_idIndexMarker264"/>hides its internal implementation, abstracting its functionality only by exposing higher-level functions. The user <a id="_idIndexMarker265"/>of the class doesn’t care how certain results are accomplished; for all the outside world knows, the actual process to get certain results could be pure magic.</p>
			<p>For the <code>Enemy</code> class example from earlier, this could mean that we can ask an enemy to move toward a certain point in the world, but not how. We have no business in how the enemy does its pathfinding or how it moves around the world. That is the enemy’s business:</p>
			<div><div><img alt="Figure 4.5 – Public and private member variables and methods tell the outside world how to interact with a class" src="img/B19358_04_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Public and private member variables and methods tell the outside world how to interact with a class</p>
			<p>In most <a id="_idIndexMarker266"/>programming languages, abstraction comes in the form of public and <a id="_idIndexMarker267"/>private member functions and variables. They work like this:</p>
			<ul>
				<li><code>public</code> and used to interact with the object.</li>
				<li><code>private</code> are inaccessible by the outside world and can only be used by the class itself. These support the internal functionality of the class.</li>
			</ul>
			<p>In GDScript, however, there is no way to explicitly mark variables or functions as public or private. Everything is public by default and accessible to the outside world. But there is a convention that GDScript developers took over from Python developers: we put an underscore (<code>_</code>) in front of variable and function names that are supposed to be private. This way, we can signal that a variable or method is supposed t<a id="_idTextAnchor322"/>o be private <a id="_idTextAnchor323"/>a<a id="_idTextAnchor324"/>nd should not be used by anything outs<a id="_idTextAnchor325"/>ide of the class:</p>
			<pre class="source-code">
extends Node
var health: int =<a id="_idTextAnchor326"/> <a id="_idTextAnchor327"/>2 # Public variable
var <strong class="bold">_</strong>weapon: String = "Sword" # Private variable
func take_<a id="_idTextAnchor328"/>d<a id="_idTextAnchor329"/>amage(amount: float): # Public function
   # Take damage in some way
func <strong class="bold">_</strong>calculate_damage() -&gt; float: # Private function
   # Calculate damage in some way</pre>			<p>The engine <a id="_idIndexMarker270"/>will not enforce such private <a id="_idIndexMarker271"/>members, so you can still call them, but this is a very bad practice. You can see this distinction between public and private members built into the scripts we’ve already written with functions that are already present in the nodes, such as <code>_ready()</code> and <code>_update()</code>.</p>
			<p>Abstraction <a id="_idIndexMarker272"/>has multiple advantages:</p>
			<ul>
				<li><strong class="bold">Security</strong>: Because the user of the class knows only to use public methods and variables, there is a lower chance of them accidentally misusing the class.</li>
				<li><strong class="bold">Maintainability</strong>: Because the functionality of the class is hidden behind a few public functions, we can easily rewrite that functionality if needed without breaking other pieces of code.<p class="list-inset">This protects against other classes or pieces of code meddling too much with the internals of a class. Because what if we rewrite the pathfinding of enemies? If we properly encapsulate this code, there is no problem, but if other pieces of code call upon the enemies’ pathfinding directly, we will have to rewrite all of these as well.</p></li>
				<li><strong class="bold">Hiding complexity</strong>: Some code can be very complex, but by using classes, we can hide this behind easy-to-use methods and member variables.</li>
			</ul>
			<p>Now that we lea<a id="_idTextAnchor330"/>rned about abstraction, let’s look at the last principle: encapsulation.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor331"/>Encapsulation</h2>
			<p>A well-written <a id="_idIndexMarker273"/>class should encapsulate all important information within <a id="_idIndexMarker274"/>itself so that the user of the class doesn’t have to worry about the nitty-gritty details. This means that a class should only expose select information to the outside world.</p>
			<p>Encapsulation is an extension of abstraction but homed in on a class’s data. The less the outside world has to deal with member var<a id="_idTextAnchor332"/>iables of a class directly and the more with member functions, the better.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor333"/>Polymorphism</h2>
			<p>The <a id="_idIndexMarker275"/>last principle of OOP is polymorphism, which <a id="_idIndexMarker276"/>says that objects and methods can morph into multiple different forms. In<a id="_idTextAnchor334"/> GDScript, this happens in two distinct ways: over objects and over methods.</p>
			<h3>Object polymorphism</h3>
			<p>Let’s say <a id="_idIndexMarker277"/>we have a class structure such as the one in the earlier <a id="_idIndexMarker278"/>example: a base en<a id="_idTextAnchor335"/>emy from which other enemies inherit. The code could lo<a id="_idTextAnchor336"/>o<a id="_idTextAnchor337"/>k something like this:</p>
			<pre class="source-code">
class Enemy:
   var damage: float
   var he<a id="_idTextAnchor338"/>alth: float
class BuffEnemy extends Enemy:
   var att<a id="_idTextAnchor339"/>a<a id="_idTextAnchor340"/>ck_distance: float = 50
   func _ready():
      damage = 2
      health = 10
class StrongEnemy extends Enemy:
   func _ready():
      damage = 10
      health = 1</pre>			<p>Now, when we make instances of the <code>BuffEnemy</code> and <code>StrongEnemy</code> classes, we can type<a id="_idTextAnchor341"/> hint them as such, but we can also type hin<a id="_idTextAnchor342"/>t them as their base clas<a id="_idTextAnchor343"/>s<a id="_idTextAnchor344"/>, <code>Enemy</code>:</p>
			<pre class="source-code">
var buff_enemy: <strong class="bold">BuffE<a id="_idTextAnchor345"/>nemy</strong> = BuffEnemy.new()
print(buff_enemy.damage)
var enemy: <strong class="bold">Enemy = buff_enemy</strong>
print(enemy.damage)</pre>			<p>This works <a id="_idIndexMarker279"/>because everything that inherits from the <code>Enemy</code> class should have the same member variables and functions at its core, so it can <a id="_idIndexMarker280"/>be put in a variable of the parent class.</p>
			<p>But you cannot assign an object from the <code>Enemy</code> type to a v<a id="_idTextAnchor346"/>ariable that is typed as one of its child classes. So, the next line will error:</p>
			<pre class="source-code">
var buff_enemy: BuffEnemy = Enemy.new()</pre>			<p><a id="_idTextAnchor347"/>The two child classes are also not compatible. So, the next line will error too:</p>
			<pre class="source-code">
var buff_enemy: BuffEnemy = StrongEnemy.new()</pre>			<p>These preceding two examples don’t work because you are not guaranteed that the member variables and functions within the <code>Enemy</code> and <code>StrongEnemy</code> classes will be the same as those in the <code>BuffEnemy</code> class. And indeed, we can see that the <code>BuffEnemy</code> class has another member variable, <code>attack_distance</code>, that the <code>Enemy</code> and <code>StrongEnemy</code> classes do not have.</p>
			<p>A good analogy for the concept of polymorphism is vehicles in the real world. Let’s say we have three vehicles:</p>
			<ul>
				<li>Cars</li>
				<li>Bikes</li>
				<li>Trucks</li>
			</ul>
			<p>Although all three vehicles can move you from one point to another, have a certain number of wheels, and are made of metal, there is a certain hierarchy:</p>
			<div><div><img alt="Figure 4.6 – The class structure of simple vehicles" src="img/B19358_04_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The class structure of simple vehicles</p>
			<p>A bike needs <a id="_idIndexMarker281"/>somebody to power it, while a car and a truck have motors. Furthermore, we could take the car as a template for the truck and say that the <a id="_idIndexMarker282"/>truck is a kind of long, big car.</p>
			<p>The truck is also unique from the car because it has a place to transport larger ca<a id="_idTextAnchor348"/>rgo. This makes it so that we can say a truck is a car, but a car is not a truck.</p>
			<h3>Method overriding</h3>
			<p>Then, there is also the possibility to override methods from the parent class. This will completely <a id="_idIndexMarker283"/>replace the original function with a new one, but only <a id="_idIndexMarker284"/>for the given child class. This is very useful when the child class needs some logic to be slightly or even drastically different from that of the parent class. To do this in GDScript, the method in the child class should adhere to the following conventions:</p>
			<ul>
				<li>Have the same name</li>
				<li>Have the same number of parameters</li>
				<li>If the parameters are typed, have the same types</li>
				<li>Have exactly the same default values, if any</li>
			</ul>
			<p>You see that we need to be exact when we want to override a method. If we are not, the engine will recognize it as a separate function or error because the overriding was done incorrectly.</p>
			<p>Let’s look at two <a id="_idIndexMarker285"/>classes that demonstrate this. A base class, <code>Enemy</code>, has a <a id="_idIndexMarker286"/>function called <code>die()</code> that prints out <code>"Aaargh!"</code>. This <code>die</code> function just prints out an exclamation when the enemy dies. Then, we inherit the <code>BuffEnemy</code> class fr<a id="_idTextAnchor349"/>om this base and override the <code>die()</code> function to pri<a id="_idTextAnchor350"/>n<a id="_idTextAnchor351"/>t out <code>"How did you </code><code>defeat me?!?"</code>:</p>
			<pre class="source-code">
class Enemy:
   func die():
      print("Aaargh!")
class BuffEnemy extends Enemy:
   func die():
      print("How did you defeat me?!?")</pre>			<p>If you call the <code>die()</code> function of each<a id="_idTextAnchor352"/> enemy type, you’ll see that th<a id="_idTextAnchor353"/>ey each have<a id="_idTextAnchor354"/> their own implementation of the function:</p>
			<pre class="source-code">
var enemy: Enemy = Enemy.new()
enemy.die()</pre>			<p>T<a id="_idTextAnchor355"/>he preceding code will print out <code>"Aaargh!"</code>, <a id="_idTextAnchor356"/>as expected. Now for the <code>BuffEnemy</code> class:</p>
			<pre class="source-code">
var buff_enemy: BuffEnemy = BuffEnemy.new()
buff_enemy.die()</pre>			<p>Now, we execute the overridden <code>die()</code> function, and the printout will read <code>"How did you </code><code>defeat me?!?"</code>.</p>
			<p>Even if you put the <code>BuffEnemy</code> object in a<a id="_idTextAnchor357"/>n <code>Enemy</code> variable, it will still use<a id="_idTextAnchor358"/> the overridden function from the <code>BuffEnemy</code> class:</p>
			<pre class="source-code">
var enemy: Enemy = BuffEnemy.new()
enemy.die()</pre>			<p>Again, we’ll see <code>"How did you defeat me?!?"</code> printed out. This is because the <code>BuffEnemy</code> class inherits from <code>Enemy</code> and thus is of type <code>Enemy</code>, but the implementation of its functions can still be overridden.</p>
			<p>We learned <a id="_idIndexMarker287"/>a lot about OOP and its principles. It’s a very <a id="_idIndexMarker288"/>interesting but complex subject. Don’t worry too much about getting all principles perfect directly. Knowing they exist is already half the work. Let’s wrap the chapter up with some extra exercises in the next section.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor359"/>Additional exercises – Sharpening the axe</h1>
			<ol>
				<li>Write a function, <code>limit_inventory()</code>, that takes an array representing an inventory and an integer. The function checks if the array is longer than the provided integer; if it is, it should remove all items that are too much. Lastly, the function returns the resulting array:<pre class="source-code">
var inventory: Array = ["Boots", "Sword", "Grapes", "Cuffs", "Potion"]
var limited_inventory: Array = <strong class="bold">limit_inventory(inventory, 2)</strong>
print(limited_inventory)</pre><p class="list-inset">This example should print out <code>["</code><code>Boots", "Sword"]</code>.</p></li>				<li>Rewrite the previous function so that the integer it takes has a default value of 3 for the following code to work:<pre class="source-code">
var inventory: Array = ["Boots", "Sword", "Grapes", "Cuffs", "Potion"]
var limited_inventory: Array = limit_inventory(inventory)
print(limited_inventory)</pre><p class="list-inset">This should print out <code>["Boots", "</code><code>Sword", "Grapes"]</code>.</p></li>				<li>Rewrite this code so that it does not error anymore:<pre class="source-code">
func _ready():
   var player_health = 5
   if player_health &gt; 2:
      var damage = 2
   player_health -= damage</pre></li>				<li>Write <code>Player</code> and <code>Enemy</code> classes that make the following code work. In this code, the player and enemy will damage each other until one of them has a health that is equal to or less than zero. See it as a primitive battle:<pre class="source-code">
var player: Player = Player.new()
var enemy: Enemy = Enemy.new()
while player.health &gt; 0 and enemy.health &gt; 0:
   enemy.take_damage(player.damage)
   player.take_damage(enemy.damage)</pre></li>				<li>Rewrite the <code>P<a id="_idTextAnchor360"/>layer</code> and <code>Enemy</code> classes from the previous exercise to inherit from the same base class.</li>
			</ol>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor361"/>Summary</h1>
			<p>With functions, classes, and type hinting in our toolkit, we have finally learned all the basic building blocks of programming! From now on, the possibilities are endless!</p>
			<p>In the next chapter, we will learn how to write an<a id="_idTextAnchor362"/>d structur<a id="_idTextAnchor363"/>e our code in a clean way so that it’s easy to use and understand for others.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor364"/>Quiz time</h1>
			<ul>
				<li>Why do we use functions and classes?</li>
				<li>For which two purposes can the <code>return</code> keyword be used in functions?</li>
				<li>What is the scope of a variable? What are the different tiers?</li>
				<li>What is the scope of a function?</li>
				<li>Is a class a group of variables and functions?</li>
				<li>Given the following code, how do we make a new instance of the <code>Enemy</code> class?<pre class="source-code">
class Enemy:
   var damage: int = 5
   # Rest of the class
var new_enemy: Enemy = ...</pre></li>				<li>How do we call the instance of a class?</li>
				<li>What is type hinting?</li>
				<li>Add type hinting to the following variables:<ul><li><code>var player_health = 5</code></li><li><code>var can_take_damage = </code><code>true</code></li><li><code>var sword = { "damage_type": "fire", "damage": </code><code>6 }</code></li></ul></li>
				<li>In addition to autocompletion and increased performances, what is the final benefit of using type hinting?</li>
			</ul>
		</div>
	</body></html>