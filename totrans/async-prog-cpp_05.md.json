["```cpp\nint counter {0};\nint main() {\n    counter++;\n    return 0;\n}\n```", "```cpp\n    Mov    eax, DWORD PTR counter[rip]\n    Add    eax, 1\n    Move    DWORD PTR counter[rip], eax\n```", "```cpp\n#include <atomic>\nstd::atomic<int> counter {0};\nint main() {\n    counter++;\n    return 0;\n}\n```", "```cpp\n    lock add    DWORD PTR counter[rip], 1\n```", "```cpp\nvoid func_a(int& a, int& b) {\n    a += 1;\n    b += 10;\n    a += 2;\n}\n```", "```cpp\nvoid func_a(int& a, int& b) {\n    a += 1;\n    b += 10 + a;\n    a += 2;\n}\n```", "```cpp\n    mov    eax, [var1]  ; load variable var1 into reg eax\n    inc    eax          ; eax += 1\n    mov    [var1], eax  ; store reg eax into var1\n    xor    ecx, ecx     ; ecx = 0\n    inc    ecx          ; ecx += 1\n    add    eax, ecx     ; eax = eax + ecx\n```", "```cpp\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <string>\n#include <thread>\nstd::string message;\nstd::atomic<bool> ready{false};\nvoid reader() {\n    using namespace std::chrono::literals;\n    while (!ready.load()) {\n        std::this_thread::sleep_for(1ms);\n    }\n    std::cout << \"Message received = \" << message << std::endl;\n}\nvoid writer() {\n    message = \"Hello, World!\";\n    ready.store(true);\n}\nint main() {\n    std::thread t1(reader);\n    std::thread t2(writer);\n    t1.join();\n    t2.join();\n    return 0;\n}\n```", "```cpp\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <thread>\nstd::atomic<bool> x{ false };\nstd::atomic<bool> y{ false };\nstd::atomic<int> z{ 0 };\nvoid write_x() {\n    x.store(true, std::memory_order_seq_cst);\n}\nvoid write_y() {\n    y.store(true, std::memory_order_seq_cst);\n}\nvoid read_x_then_y() {\n    while (!x.load(std::memory_order_seq_cst)) {}\n    if (y.load(std::memory_order_seq_cst)) {\n        ++z;\n    }\n}\nvoid read_y_then_x()\n{\n    while (!y.load(std::memory_order_seq_cst)) {}\n    if (x.load(std::memory_order_seq_cst)) {\n        ++z;\n    }\n}\nint main() {\n    std::thread t1(write_x);\n    std::thread t2(write_y);\n    std::thread t3(read_x_then_y);\n    std::thread t4(read_y_then_x);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n    if (z.load() == 0) {\n        std::cout << \"This will never happen\\n\";\n    }\n    {\n        std::cout << \"This will always happen and z = \" << z << \"\\n\";\n    }\n    return 0;\n}\n```", "```cpp\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <thread>\nstd::atomic<bool> x{ false };\nstd::atomic<bool> y{ false };\nstd::atomic<int> z{ 0 };\nvoid write_x() {\n    x.store(true, std::memory_order_release);\n}\nvoid write_y() {\n    y.store(true, std::memory_order_release);\n}\nvoid read_x_then_y() {\n    while (!x.load(std::memory_order_acquire)) {}\n    if (y.load(std::memory_order_acquire)) {\n        ++z;\n    }\n}\nvoid read_y_then_x() {\n    while (!y.load(std::memory_order_acquire)) {}\n    if (x.load(std::memory_order_acquire)) {\n        ++z;\n    }\n}\nint main() {\n    std::thread t1(write_x);\n    std::thread t2(write_y);\n    std::thread t3(read_x_then_y);\n    std::thread t4(read_y_then_x);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n    if (z.load() == 0) {\n        std::cout << \"This will never happen\\n\";\n    }\n    {\n        std::cout << \"This will always happen and z = \" << z << \"\\n\";\n    }\n    return 0;\n}\n```", "```cpp\n#include <atomic>\n#include <iostream>\nstd::atomic<int> counter {0};\nint main() {\n    // Using member functions\n    int count = counter.load();\n    std::cout << count << std::endl;\n    count++;\n    counter.store(count);\n    // Using free functions\n    count = std::atomic_load(&counter);\n    std::cout << count << std::endl;\n    count++;\n    std::atomic_store(&counter, count);\n    return 0;\n}\n```", "```cpp\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <thread>\n#include <vector>\nclass spin_lock {\npublic:\n    spin_lock() = default;\n    spin_lock(const spin_lock &) = delete;\n    spin_lock &operator=(const spin_lock &) = delete;\n    void lock() {\n        while  (flag.test_and_set(std::memory_order_acquire)) {\n        }\n    }\n    void unlock() {\n        flag.clear(std::memory_order_release);\n    }\nprivate:\n    std::atomic_flag flag = ATOMIC_FLAG_INIT;\n};\n```", "```cpp\nstd::atomic_flag flag = ATOMIC_FLAG_INIT;\n```", "```cpp\nvoid unlock()\n{\n    flag.clear(std::memory_order_release);\n}\n```", "```cpp\nvoid lock()\n{\n    while (flag.test_and_set(std::memory_order_acquire)) {}\n}\n```", "```cpp\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <thread>\nconstexpr int NUM_ITEMS{100000};\nint main() {\n    std::atomic<int> progress{0};\n    std::thread worker([&progress] {\n        for (int i = 1; i <= NUM_ITEMS; ++i) {\n            progress.store(i, std::memory_order_relaxed);\n            std::this_thread::sleep_for(std::chrono::milliseconds(1));\n        }\n    });\n    while (true) {\n        int processed_items = progress.load(std::memory_order_relaxed);\n        std::cout << \"Progress: \"\n                  << processed_items << \" / \" << NUM_ITEMS\n                  << std::endl;\n        if (processed_items == NUM_ITEMS) {\n            break;\n        }\n        std::this_thread::sleep_for(std::chrono::seconds(10));\n    }\n    worker.join();\n    return 0;\n}\n```", "```cpp\nstd::atomic<int> processed_items{0};\nstd::atomic<float> total_time{0.0f};\nstd::atomic<double> average_time{0.0};\n```", "```cpp\nprocessed_items.fetch_add(1, std::memory_order_relaxed);\ntotal_time.fetch_add(elapsed_s, std::memory_order_relaxed);\naverage_time.store(total_time.load() / processed_items.load(), std::memory_order_relaxed);\n```", "```cpp\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <random>\n#include <thread>\nconstexpr int NUM_ITEMS{10000};\nvoid process() {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(1, 20);\n    int sleep_duration = dis(gen);\n        std::this_thread::sleep_for(std::chrono::milliseconds(sleep_duration));\n}\nint main() {\n    std::atomic<int> processed_items{0};\n    std::atomic<float> total_time{0.0f};\n    std::atomic<double> average_time{0.0};\n    std::thread worker([&] {\n        for (int i = 1; i <= NUM_ITEMS; ++i) {\n            auto now = std::chrono::high_resolution_clock::now();\n            process();\n            auto elapsed = \n                std::chrono::high_resolution_clock::now() - now;\n            float elapsed_s =\n                std::chrono::duration<float>(elapsed).count();\n            processed_items.fetch_add(1, std::memory_order_relaxed);\n            total_time.fetch_add(elapsed_s, std::memory_order_relaxed);\n            average_time.store(total_time.load() / processed_items.load(), std::memory_order_relaxed);\n        }\n    });\n    while (true) {\n        int items = processed_items.load(std::memory_order_relaxed);\n        std::cout << \"Progress: \" << items << \" / \" << NUM_ITEMS << std::endl;\n        float time = total_time.load(std::memory_order_relaxed);\n        std::cout << \"Total time: \" << time << \" sec\" << std::endl;\n        double average = average_time.load(std::memory_order_relaxed);\n        std::cout << \"Average time: \" << average * 1000 << \" ms\" << std::endl;\n        if (items == NUM_ITEMS) {\n            break;\n        }\n        std::this_thread::sleep_for(std::chrono::seconds(5));\n    }\n    worker.join();\n    return 0;\n}\n```", "```cpp\n#include <atomic>\n#include <iostream>\nstruct no_lock_free {\n    int a[128];\n    no_lock_free() {\n        for (int i = 0; i < 128; ++i) {\n            a[i] = i;\n        }\n    }\n};\nint main() {\n    std::atomic<no_lock_free> s;\n    std::cout << \"Size of no_lock_free: \" << sizeof(no_lock_free) << \" bytes\\n\";\n    std::cout << \"Size of std::atomic<no_lock_free>: \" << sizeof(s) << \" bytes\\n\";\n    std::cout << \"Is std::atomic<no_lock_free> always lock-free: \" << std::boolalpha\n              << std::atomic<no_lock_free>::is_always_lock_free << std::endl;\n    std::cout << \"Is std::atomic<no_lock_free> lock-free: \" << std::boolalpha << s.is_lock_free() << std::endl;\n    no_lock_free s1;\n    s.store(s1);\n    return 0;\n}\n```", "```cpp\n#include <atomic>\n#include <iostream>\n#include <random>\n#include <thread>\n#include <vector>\nconstexpr int NUM_THREADS{8};\nvoid process() {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(1, 1000000);\n    int sleep_duration = dis(gen);\n    std::this_thread::sleep_for(std::chrono::microseconds(sleep_duration));\n}\nint main() {\n    std::atomic<int> init_thread{0};\n    auto worker = [&init_thread](int i) {\n        process();\n        int init_value = init_thread.load(std::memory_order::seq_cst);\n        if (init_value == 0) {\n            int expected = 0;\n            if (init_thread.compare_exchange_strong(expected, i, std::memory_order::seq_cst)) {\n                std::cout << \"Previous value of init_thread: \" << expected << \"\\n\";\n                std::cout << \"Thread \" << i << \" initialized\\n\";\n            } else {\n                // init_thread was already initialized\n            }\n        } else {\n            // init_thread was already initialized\n        }\n    };\n    std::vector<std::thread> threads;\n    for (int i = 1; i <= NUM_THREADS; ++i) {\n        threads.emplace_back(worker, i);\n    }\n    for (auto &t: threads) {\n        t.join();\n    }\n    std::cout << \"Thread: \" << init_thread.load() << \" initialized\\n\";\n    return 0;\n}\n```", "```cpp\nsize_t next_index = (curr_index + 1) % N;\n```", "```cpp\nnext_index = (3 + 1) % 4 = 4 % 4 = 0;\n```", "```cpp\nsize_t next_index = curr_index & (N – 1);\n```", "```cpp\nconst std::size_t capacity_; // power of two buffer size\nstd::vector<T> buffer_; // buffer to store queue items handled like a ring buffer\nstd::atomic<std::size_t> head_{ 0 };\nstd::atomic<std::size_t> tail_{ 0 };\n```", "```cpp\nbool push(const T& item) {\n    std::size_t tail =\n        tail_.load(std::memory_order_relaxed);\n    std::size_t next_tail =\n       (tail + 1) & (capacity_ - 1);\n    if (next_tail != head_.load(std::memory_order_acquire)) {\n        buffer_[tail] = item;\n        tail_.store(next_tail, std::memory_order_release);\n        return true;\n    }\n    return false;\n}\n```", "```cpp\nbool pop(T& item) {\n    std::size_t head =\n        head_.load(std::memory_order_relaxed);\n    if (head == tail_.load(std::memory_order_acquire)) {\n        return false;\n    }\n    item = buffer_[head];\n    head_.store((head + 1) & (capacity_ - 1), std::memory_order_release);\n    return true;\n}\n```", "```cpp\n#include <atomic>\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <thread>\ntemplate<typename T>\nclass spsc_lock_free_queue {\npublic:\n    // capacity must be power of two to avoid using modulo operator when calculating the index\n    explicit spsc_lock_free_queue(size_t capacity) : capacity_(capacity), buffer_(capacity) {\n        assert((capacity & (capacity - 1)) == 0 && \"capacity must be a power of 2\");\n    }\n    spsc_lock_free_queue(const spsc_lock_free_queue &) = delete;\n    spsc_lock_free_queue &operator=(const spsc_lock_free_queue &) = delete;\n    bool push(const T &item) {\n        std::size_t tail = tail_.load(std::memory_order_relaxed);\n        std::size_t next_tail = (tail + 1) & (capacity_ - 1);\n        if (next_tail != head_.load(std::memory_order_acquire)) {\n            buffer_[tail] = item;\n            tail_.store(next_tail, std::memory_order_release);\n            return true;\n        }\n        return false;\n    }\n    bool pop(T &item) {\n        std::size_t head = head_.load(std::memory_order_relaxed);\n        if (head == tail_.load(std::memory_order_acquire)) {\n            return false;\n        }\n        item = buffer_[head];\n        head_.store((head + 1) & (capacity_ - 1), std::memory_order_release);\n        return true;\n    }\nprivate:\n    const std::size_t capacity_;\n    std::vector<T> buffer_;\n    std::atomic<std::size_t> head_{0};\n    std::atomic<std::size_t> tail_{0};\n};\n```"]