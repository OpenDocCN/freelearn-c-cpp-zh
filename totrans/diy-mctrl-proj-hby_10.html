<html><head></head><body>
		<div id="_idContainer142">
			<h1 id="_idParaDest-130"><em class="italic"><a id="_idTextAnchor135"/>Chapter 10</em>: IoT Plant Pot Moisture Sensor</h1>
			<p>With the advent of the <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>), we are immersed in the new industrial revolution—the so-called <strong class="bold">Industry 4.0</strong>. One of the industries that have benefited the most from these technologies is agriculture (Chalimov, 2020). Agricultural IoT applications range from autonomous harvesting to sensors to recognize pests and diseases or to measure humidity. We can take advantage of these advances in our homes—for instance, monitoring our ornamental plants to have more efficient care.</p>
			<p>In this chapter, you will put into practice information learned in <a href="B16413_09_Final_NM_ePub.xhtml#_idTextAnchor122"><em class="italic">Chapter 9</em></a>, <em class="italic">IoT Temperature-Logging System</em>, about how to connect and program an internet connection, but this time we will introduce a <strong class="bold">NodeMCU microcontroller</strong> to facilitate the ESP8266 programming. You will learn how to create a digital device to monitor a plant pot, reading data from a soil moisture sensor and determining whether it needs water, and then sending an alert to notify that it is too dry.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Connecting a soil moisture sensor to the Blue Pill board</li>
				<li>Reading data from the soil moisture sensor module</li>
				<li>Coding a program to send the sensed data to the internet</li>
				<li>Showing sensor data results over the internet</li>
			</ul>
			<p>By completing this chapter, you will discover how to read the soil's moisture amount through a sensor connected to the STM32 Blue Pill board. You will also learn how to send this information to the internet through the NodeMCU development board and visualize the sensor values from a responsive web page.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor136"/>Technical requirements</h1>
			<p>The hardware components that will be needed to develop the plant pot moisture system are listed as follows:</p>
			<ul>
				<li>One solderless breadboard.</li>
				<li>One Blue Pill microcontroller board.</li>
				<li>One NodeMCU microcontroller.</li>
				<li>One ST-Link/V2 electronic interface, needed for uploading the compiled code to the Blue Pill board. Bear in mind that the ST-Link/V2 interface requires four female-to-female jumper wires.</li>
				<li>One soil moisture sensor. </li>
				<li>One ESP8266 Wi-Fi module.</li>
				<li>Male-to-male jumper wires.</li>
				<li>Power source.</li>
			</ul>
			<p>These components can be easily obtained from your favorite supplier. Additionally, you will require the Arduino <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) and the GitHub repository for this chapter, which can be found at <a href="https://github.com/PacktPublishing/DIY-Microcontroller-Projects-for-Hobbyists/tree/master/Chapter10">https://github.com/PacktPublishing/DIY-Microcontroller-Projects-for-Hobbyists/tree/master/Chapter10</a></p>
			<p>The Code in Action video for this chapter can be found here: <a href="https://bit.ly/3d9CmNM">https://bit.ly/3d9CmNM</a></p>
			<p>The next section presents an introduction to a soil moisture sensor and how to use it with the STM32 Blue Pill microcontroller board.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor137"/>Connecting a soil moisture sensor to the Blue Pill board</h1>
			<p>We <a id="_idIndexMarker474"/>will start this section by learning<a id="_idIndexMarker475"/> how to use a sensor to measure soil humidity in a plant pot, and you will later learn how to connect it to the <strong class="bold">STM32 Blue Pill</strong> board to build a plant pot moisture-monitoring system.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor138"/>Introducing soil moisture sensors</h2>
			<p>A <strong class="bold">soil moisture sensor</strong> consists<a id="_idIndexMarker476"/> of two pads that measure the amount of water in the soil. The sensed value is acquired by allowing the the electric current running through the soil to pass through, and according to resistance, this shows the level of humidity in the plant pot.</p>
			<p>You can find a generic breakout module that is pretty straightforward to use. This is shown in the following photo: </p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/Figure_10.1_B16413.jpg" alt="Figure 10.1 – Soil moisture sensor breakout board"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Soil moisture sensor breakout board</p>
			<p>The pads are<a id="_idIndexMarker477"/> connected to the breakout board with the included female-to-female jumper wires. The breakout board connects to the STM32 Blue Pill board with four pins, outlined as follows:</p>
			<ul>
				<li><strong class="bold">Analog output</strong> (<strong class="bold">AO</strong>): This pin generates an analog signal and must be connected to an analog input of the microcontroller.</li>
				<li><strong class="bold">Digital output</strong> (<strong class="bold">DO</strong>): This pin generates a digital signal and must be connected to a digital input of the microcontroller.</li>
				<li><strong class="bold">VCC</strong>: Pin to supply power to the sensor (3.3 <strong class="bold">volts</strong> (<strong class="bold">V</strong>)-5 V).</li>
				<li><strong class="bold">Ground</strong> (<strong class="bold">GND</strong>): Ground connection.</li>
			</ul>
			<p>To simplify the development of our project, we will use a DO pin to build our system because it only generates binary data depending on the humidity.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor139"/>Connecting the components </h2>
			<p>We will use a<a id="_idIndexMarker478"/> solderless breadboard to connect the sensor and the STM32 Blue Pill microcontroller, and finally wire to connect the components. Follow these steps:</p>
			<ol>
				<li>Place the soil moisture sensor and the STM32 Blue Pill board on the solderless breadboard with enough space to add the wiring layer.</li>
				<li>Connect the ground (GND) pin of the sensor to a GND terminal of the SMT32 Blue Pill board.</li>
				<li>Next, you need to connect the voltage (VCC) pin to the 3V3 bus of the STM32 Blue Pill board. The sensor DO must be connected to a digital input on the STM32 Blue Pill board, so connect the DO pin of the sensor to pin B12 of the Blue Pill, as shown in the following photo: <div id="_idContainer128" class="IMG---Figure"><img src="image/Figure_10.2_B16413.jpg" alt="Figure 10.2 – Soil moisture sensor connection to the Blue Pill"/></div><p class="figure-caption">Figure 10.2 – Soil moisture sensor connection to the Blue Pill</p></li>
				<li>Finally, you<a id="_idIndexMarker479"/> will need a power source to power up the board. Use the ST-LINK to upload the scripts to the STM32 Blue Pill microcontroller board. The following screenshot summarizes all the hardware connections:</li>
			</ol>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/Figure_10.3_B16413.jpg" alt="Figure 10.3 – Circuit for soil moisture sensor connection"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Circuit for soil moisture sensor connection</p>
			<p>The following screenshot presents a schematic diagram for this project:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/Figure_10.4_B16413.jpg" alt="Figure 10.4 – Schematic diagram for soil moisture sensor connection"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Schematic diagram for soil moisture sensor connection</p>
			<p><em class="italic">Figure 10.4</em> shows <a id="_idIndexMarker480"/>an electric diagram for this part of the project. The ground pin of the sensor was connected to the GND pin of the Blue Pill, while the VCC pin was connected to the Blue Pill's 3V3 bus. Finally, the DO of the sensor was plugged into the B12 pin of the STM32 microcontroller. The following photo shows the plant pot moisture system:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/Figure_10.5_B16413.jpg" alt="Figure 10.5 – Plant pot moisture system"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Plant pot moisture system</p>
			<p>In the previous <a id="_idIndexMarker481"/>photo, we can see how the humidity monitoring system's deployment is carried out. As we can see, we built a compact electronic circuit to monitor the moisture of the soil in a plant pot.</p>
			<p>In this section, we understood the concept of a humidity sensor and its components. Furthermore, we learned how to connect the sensor to a microcontroller through a breadboard, and finally learned how to connect the complete system to a plant pot.</p>
			<p>It's time to move on to the next section, which will show you how to write C code to complete the IoT humidity monitoring system's first functionality.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor140"/>Reading data from the soil moisture sensor module</h1>
			<p>You will now <a id="_idIndexMarker482"/>learn how to code a program that<a id="_idIndexMarker483"/> reads the information from the moisture sensor and shows on the serial monitor if the plant pot needs watering or is moist enough.</p>
			<p>Let's start developing the program to collect the sensor data from the STM32 Blue Pill, as follows:</p>
			<ol>
				<li value="1">Let's get started writing the code. This time, we won't need any additional libraries. Define which of the STM32 Blue Pill card pins will be used as input for reading the sensor data. Also, declare a variable to save the reading data from the sensor, as follows:<p class="source-code">const int <strong class="bold">sensorPin = PB12</strong>;</p><p class="source-code">int <strong class="bold">sensorValue = 0</strong>;</p><p>The input pin will be the <strong class="source-inline">PB12</strong> pin (labeled B12 on the Blue Pill). Also, we initialize the <strong class="source-inline">sensorValue</strong> variable to a value of <strong class="source-inline">0</strong>.</p></li>
				<li>Next, in the <strong class="source-inline">setup()</strong> part, we need to start the serial data transmission and assign the speed of the transfer (as usual, we will use 9,600 <strong class="bold">bits per second</strong> (<strong class="bold">bps</strong>) as the standard value). Here is the code to do this:<p class="source-code">void setup() {</p><p class="source-code">  <strong class="bold">Serial.begin(9600);</strong></p><p class="source-code">}</p></li>
				<li>Indicate to the microcontroller the type of pin assigned to <strong class="source-inline">PB12</strong> by running the following code:<p class="source-code">void setup() {</p><p class="source-code">  Serial.begin(9600);</p><p class="source-code">  <strong class="bold">pinMode(sensorPin, INPUT);</strong></p><p class="source-code">}</p></li>
				<li>The rest of the sketch is in the <strong class="source-inline">loop()</strong> part. The first lines read the input pin's data <a id="_idIndexMarker484"/>sensor and display its value in <a id="_idIndexMarker485"/>the serial console. The code is shown in the following snippet:<p class="source-code">void loop() {</p><p class="source-code">  sensorValue = digitalRead(sensorPin);</p><p class="source-code">  Serial.print("Sensor value: ");</p><p class="source-code">  Serial.println(sensorValue);</p><p class="source-code">  if (sensorValue == 1) {</p><p class="source-code">    Serial.println("Soil is too dry");</p><p class="source-code">    delay(1000);</p><p class="source-code">  } else  {</p><p class="source-code">    Serial.println("Soil is moist enough");</p><p class="source-code">    delay(1000);</p><p class="source-code">  }</p><p class="source-code">}</p><p>The value read from the sensor could be <strong class="source-inline">1</strong> or <strong class="source-inline">0</strong>; remember, we are reading a digital value. If the value is <strong class="source-inline">1</strong>, then the plant pot needs water; otherwise, it is moist enough.</p><p>The code is now complete. You can find the complete sketch in the <strong class="source-inline">Chapter10/moisture</strong> folder in the GitHub repository.</p></li>
				<li>Now that the sketch is complete, you can upload it to the Blue Pill board and insert the sensor pads into a plant pot. Now, you can see in the <strong class="bold">serial monitor</strong> that the soil is too dry, as shown in the following screenshot: <div id="_idContainer132" class="IMG---Figure"><img src="image/Figure_10.6_B16413.jpg" alt="Figure 10.6 – Serial monitor readings with dry soil"/></div><p class="figure-caption">Figure 10.6 – Serial monitor readings with dry soil</p></li>
				<li>Now, add <a id="_idIndexMarker486"/>water to the plant pot, taking<a id="_idIndexMarker487"/> care not to get any electronic components wet. The serial monitor's information will change as soon as the soil gets wet, as illustrated in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/Figure_10.7_B16413.jpg" alt="Figure 10.7 – Serial monitor readings upon moistening the soil"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – Serial monitor readings upon moistening the soil</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In recent macOS versions, the <strong class="bold">Universal Serial Bus</strong> (<strong class="bold">USB</strong>) port may not appear in the Arduino IDE, and it therefore may not be possible to see the serial monitor. To solve this, it is necessary to install the <a id="_idIndexMarker488"/>USB-UART drivers (where <strong class="bold">UART</strong> stands for <strong class="bold">Universal Asynchronous Receiver/Transmitter</strong>) from <a href="https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers">https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers</a>.</p>
			<p>Let's recap<a id="_idIndexMarker489"/> what we have learned so far. We<a id="_idIndexMarker490"/> learned about a sensor to measure soil humidity. We learned how to connect it to our STM32 Blue Pill microcontroller in the <em class="italic">Connecting a soil moisture sensor to the Blue Pill board</em> section. In this section, we wrote the code to obtain its data and display it on the serial monitor. </p>
			<p>The skills you have acquired so far in this chapter will allow you to create other electronic systems that require digital reading of data generated in sensors, enabling you to use this sensor in additional projects where it is required to measure soil moisture.</p>
			<p>Coming up next, we will learn about the NodeMCU microcontroller, which will facilitate connection to the internet with its integrated ESP8266 module.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor141"/>Coding a program to send the sensed data to the internet</h1>
			<p>If you remember, in <a href="B16413_09_Final_NM_ePub.xhtml#_idTextAnchor122"><em class="italic">Chapter 9</em></a>, <em class="italic">IoT Temperature-Logging System</em>, we found that an ESP-01 module <a id="_idIndexMarker491"/>was used because it integrates Wi-Fi communication through ESP8266. This module was <a id="_idIndexMarker492"/>programmed using <strong class="bold">AT commands</strong> through the STM32 Blue Pill microcontroller (where <strong class="bold">AT</strong> stands for <strong class="bold">Attention</strong>). As mentioned at the beginning of the chapter, we will use<a id="_idIndexMarker493"/> the <strong class="bold">NodeMCU development board</strong>, which is depicted in the following photo:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/Figure_10.8_B16413.jpg" alt="Figure 10.8 – NodeMCU development board"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – NodeMCU development board</p>
			<p>This board is also based on the ESP8266 microcontroller. However, unlike the SP-01 module, this can be programmed directly from its micro USB port using different development IDEs and various<a id="_idIndexMarker494"/> programming languages such as Lua and C. It also includes <strong class="bold">general-purpose input/output</strong> (<strong class="bold">GPIO</strong>) pins to be programmed according to the developer's needs. These characteristics make the NodeMCU microcontroller one of the most popular IoT platforms today.</p>
			<p>The NodeMCU associates with both firmware and development boards, and in conjunction offers the most popular open source IoT platform. The development board is based on the ESP-12 module that, as with the ESP-01 module, gives us the Wi-Fi connection functionality and adds the functionality of the development board, with the following features: </p>
			<ul>
				<li>Micro USB port and serial-USB converter </li>
				<li>Simple programming via micro USB </li>
				<li>Power via USB terminals (pins) for easy connection </li>
				<li>Integrated reset button and <strong class="bold">light-emitting diode</strong> (<strong class="bold">LED</strong>)</li>
			</ul>
			<p>Using its pins, we<a id="_idIndexMarker495"/> can easily place it on a solderless breadboard to connect the electronic components required by the projects we will carry out. The NodeMCU enables Wi-Fi communication <a id="_idIndexMarker496"/>using the <strong class="bold">Transmission Control Protocol/Internet Protocol</strong> (<strong class="bold">TCP/IP</strong>) stack.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">To program the NodeMCU, the steps to add this type of board indicated in the <em class="italic">Showing sensor data results over the internet</em> section of <a href="B16413_09_Final_NM_ePub.xhtml#_idTextAnchor122"><em class="italic">Chapter 9</em></a>, <em class="italic">IoT Temperature-Logging System</em>, must already have been carried out.</p>
			<p>Let's create a program to connect the NodeMCU to the internet. Follow these steps:</p>
			<ol>
				<li value="1">First, include the Wi-Fi library for the ESP8266. You will need two string-type variables for the Wi-Fi network's <strong class="bold">service set identifier</strong> (<strong class="bold">SSID</strong>) and password (don't forget to change these<a id="_idIndexMarker497"/> to your actual values). Also, define an input pin and default value to read the sensor data from the STM32. The possible values gathered from the sensor are listed as follows:<ul><li><strong class="source-inline">0</strong>: Moist</li><li><strong class="source-inline">1</strong>: Dry</li><li><strong class="source-inline">2</strong>: Without reading. Hardcoded here, not from the sensor<p>The code is illustrated in the following snippet:</p><p class="source-code"><strong class="bold">#include &lt;ESP8266WiFi.h&gt;</strong></p><p class="source-code">const char* ssid = "<strong class="bold">Your_SSID</strong>";</p><p class="source-code">const char* password = "<strong class="bold">Your_Password</strong>";</p><p class="source-code">const int <strong class="bold">fromStm32Pin</strong> = 4;</p><p class="source-code">int <strong class="bold">sensorValue</strong> = 2;</p></li></ul></li>
				<li>We will create a web server to receive the sensor data. The server will be listening on port <strong class="source-inline">80</strong>. Here is the code to do this: <p class="source-code">WiFiServer server(80);</p></li>
				<li>In the <strong class="source-inline">setup()</strong> part, we<a id="_idIndexMarker498"/> need to start the serial data transmission and assign the speed of the transfer (this time, we will use 115,200 bps). The code is shown in the following snippet:<p class="source-code">void setup() {</p><p class="source-code">  Serial.begin(115200);</p><p class="source-code">}</p></li>
				<li>Indicate to the NodeMCU board the type of pin for reading the STM32, as follows:<p class="source-code">void setup() {</p><p class="source-code">  Serial.begin(115200);</p><p class="source-code">  pinMode(fromStm32Pin, INPUT);</p><p class="source-code">}</p></li>
				<li>The rest of the <strong class="source-inline">setup()</strong> part will configure the Wi-Fi network, and upon a successful connection will send the IP address to the serial monitor. The code can be seen here:<p class="source-code">void setup() {</p><p class="source-code">  Serial.begin(115200);</p><p class="source-code">  pinMode(fromStm32Pin, INPUT);</p><p class="source-code">  Serial.print("Connecting to WiFi network: ");</p><p class="source-code">  Serial.println(ssid);</p><p class="source-code">  WiFi.begin(ssid, password);</p><p class="source-code">  while (WiFi.status() != WL_CONNECTED) {</p><p class="source-code">    delay(500);</p><p class="source-code">    Serial.print(".");</p><p class="source-code">  }</p><p class="source-code">  Serial.println("");</p><p class="source-code">  Serial.println("WiFi connected.");</p><p class="source-code">  Serial.println("IP address: ");</p><p class="source-code">  Serial.println(WiFi.localIP());</p><p class="source-code">  server.begin();}</p><p>The <strong class="source-inline">loop()</strong> part was built into three functionalities. First, start the web server. Then, read the sensor data from the STM32. Finally, display a responsive web app to visualize the sensor monitoring.</p><p>For the complete<a id="_idIndexMarker499"/> sketch, refer to the <strong class="source-inline">Chapter10/webserver</strong> folder in the GitHub repository.</p></li>
				<li>The web server will be listening for incoming connections from clients. After a client connects, we catch it on the <strong class="source-inline">if</strong> condition, as illustrated in the following code snippet:<p class="source-code">void loop() {</p><p class="source-code">  <strong class="bold">WiFiClient client = server.available();</strong></p><p class="source-code">  if (client) {</p><p class="source-code">    // Code to serve the responsive webapp.</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>After a client connects, the code verifies that is receiving a <strong class="source-inline">GET</strong> request with a command to read the sensor data, as illustrated in the following code snippet:<p class="source-code">void loop() {</p><p class="source-code">  WiFiClient client = server.available();</p><p class="source-code">  if (client) {</p><p class="source-code">    <strong class="bold">if (header.indexOf("GET /4/read") &gt;= 0) {</strong></p><p class="source-code"><strong class="bold">      Serial.println("Reading the sensor");</strong></p><p class="source-code"><strong class="bold">      sensorValue = digitalRead(fromStm32Pin);</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>If the request <a id="_idIndexMarker500"/>received by the client asks the sensor value, the NodeMCU will take from the STM32 Blue Pill a reading of the sensor.<p>To make this bridge between the NodeMCU and the STM32, it will be necessary to add the additional connections shown in the following screenshot:</p><div id="_idContainer135" class="IMG---Figure"><img src="image/Figure_10.9_B16413.jpg" alt="Figure 10.9 – Circuit for microcontrollers' interconnection"/></div><p class="figure-caption">Figure 10.9 – Circuit for microcontrollers' interconnection</p><p>Here is a<a id="_idIndexMarker501"/> schematic diagram of the microcontrollers' interconnection:</p><div id="_idContainer136" class="IMG---Figure"><img src="image/Figure_10.10_B16413.jpg" alt="Figure 10.10 – Schematic diagram of microcontrollers' interconnection"/></div><p class="figure-caption">Figure 10.10 – Schematic diagram of microcontrollers' interconnection</p><p>Connect a male-to-male jumper wire from NodeMCU GPIO 4 (D2) to the GPIO PC13 pin of the STM32.</p><p>The following<a id="_idIndexMarker502"/> photo shows how everything was connected in the actual system:</p><div id="_idContainer137" class="IMG---Figure"><img src="image/Figure_10.11_B16413.jpg" alt="Figure 10.11 – STM32 and NodeMCU connection"/></div><p class="figure-caption">Figure 10.11 – STM32 and NodeMCU connection</p></li>
				<li>Now, to complete the connection between the NodeMCU and the STM32, it's necessary to add a few new lines of code to the <strong class="source-inline">Chapter10/moisture</strong> sketch.<p>Add a new constant to store the output pin used to send the data to the NodeMCU, as follows:</p><p class="source-code">const int sensorPin = PB12;</p><p class="source-code">int sensorValue = 0;</p><p class="source-code"><strong class="bold">const int toInternetPin = PC13;</strong></p><p>The output pin will be the <strong class="source-inline">PC13</strong> pin (labeled C13 on the Blue Pill). </p></li>
				<li>In <a id="_idIndexMarker503"/>the <strong class="source-inline">setup()</strong> part, indicate the pin type for <strong class="source-inline">PC13</strong>, as follows:<p class="source-code">void setup() {</p><p class="source-code">  Serial.begin(9600);</p><p class="source-code">  pinMode(sensorPin, INPUT);</p><p class="source-code">  pinMode(toInternetPin, OUTPUT);</p><p class="source-code">}</p></li>
				<li>Modify the <strong class="source-inline">if</strong> condition in the <strong class="source-inline">loop()</strong> part, as follows:<p class="source-code">void loop() {</p><p class="source-code">  if (sensorValue == 1) {</p><p class="source-code">    <strong class="bold">digitalWrite(toInternetPin, HIGH);</strong></p><p class="source-code">    Serial.println("Soil is too dry");</p><p class="source-code">    delay(1000);</p><p class="source-code">  } else  {</p><p class="source-code">    <strong class="bold">digitalWrite(toInternetPin, LOW);</strong></p><p class="source-code">    Serial.println("Soil is moist enough");</p><p class="source-code">    delay(1000);</p><p class="source-code">  }}</p><p>With the preceding code, the STM32 Blue Pill will send the value <strong class="source-inline">1</strong> (<strong class="source-inline">HIGH</strong>) or <strong class="source-inline">0</strong> (<strong class="source-inline">LOW</strong>) according to the humidity sensor. Now, we can upload <strong class="source-inline">Chapter10/moisture</strong> to the STM32 and close the sketch and continue working in <strong class="source-inline">Chapter10/webserver</strong>.</p></li>
				<li>The final step to complete our web server is to serve a responsive web app after a client request. In this way, any device connected to the same Wi-Fi network and a web browser will be able to access the sensor reading remotely.<p>But first, we <a id="_idIndexMarker504"/>will learn a few concepts of <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>): the<a id="_idIndexMarker505"/> markup language to create a web page.</p><p>A basic structure of an HTML document could look like this:</p><p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;head&gt;</p><p class="source-code">    &lt;meta name="viewport" content="width=device-width,       initial-scale=1"&gt;</p><p class="source-code">    &lt;title&gt;Page Title&lt;/title&gt;</p><p class="source-code">  &lt;/head&gt;</p><p class="source-code">  &lt;body&gt;</p><p class="source-code">    &lt;h1&gt;A heading&lt;/h1&gt;</p><p class="source-code">    &lt;p&gt;A paragraph.&lt;/p&gt;</p><p class="source-code">    &lt;img src="anImage.jpg" &gt;</p><p class="source-code">    &lt;button&gt;A button.&lt;/button&gt;</p><p class="source-code">  &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>As we build a responsive web app, it is essential to pay attention to the <strong class="source-inline">&lt;meta&gt;</strong> tag with the <strong class="source-inline">name</strong> property that has a <strong class="source-inline">viewport</strong> value. This tag will be responsible for adjusting our app's layout according to the device with which we are browsing, so we can do it from a desktop PC to a mobile device.</p><p>To give it the desired visual style, we can do it in two ways: importing a <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) file or <a id="_idIndexMarker506"/>including the styles within <strong class="source-inline">&lt;style&gt;&lt;/style&gt;</strong> tags, both within the <strong class="source-inline">&lt;head&gt;</strong> tag, as illustrated in the following code snippet:</p><p class="source-code">&lt;link rel="stylesheet" href="styleFile.css"&gt;</p><p class="source-code">&lt;style&gt;Some styles&lt;/style&gt;</p><p>For our web app, we<a id="_idIndexMarker507"/> are going to need a button. If we do not know much about giving CSS visual style, we can use tools freely available on the internet, such as <a href="https://www.bestcssbuttongenerator.com/">https://www.bestcssbuttongenerator.com/</a>, which will visually generate the style CSS of our buttons.</p><p>To include HTML code in our sketch, we will use the following sentence:</p><p class="source-code">client.println("&lt;html tags&gt;");</p><p>The code for visualizing the sensor value on our web app prints a paragraph indicating to the user whether the soil is dry or not, and a graphical indicator to better understand our plant pot state, as illustrated in the following code snippet:</p><p class="source-code">if (sensorValue == 1) {</p><p class="source-code">  client.println("&lt;p&gt;Soil is too dry&lt;/p&gt;");</p><p class="source-code">  client.println("&lt;p&gt;&lt;img width=\"50\" height=\"60\"    src=\"https://raw.githubusercontent.com/      PacktPublishing/Creative-DIY-Microcontroller-        Projects/master/Chapter10/images/          dry_plant.png\"&gt;&lt;/p&gt;");</p><p class="source-code">} else if (sensorValue == 0)  {</p><p class="source-code">  client.println("&lt;p&gt;Soil is moist enough&lt;/p&gt;");</p><p class="source-code">  client.println("&lt;p&gt;&lt;img width=\"50\" height=\"60\"    src=\"https://raw.githubusercontent.com/      PacktPublishing/Creative-DIY-Microcontroller-        Projects/master/Chapter10/images/          green_plant.png\"&gt;&lt;/p&gt;");</p><p class="source-code">} else {</p><p class="source-code">  client.println("&lt;p&gt;Press the button to read the     sensor&lt;/p&gt;");</p><p class="source-code">}</p><p class="source-code">client.println("&lt;p&gt;&lt;a href=\"/4/read\"&gt;  &lt;button class=\"sensorButton\"&gt;&lt;i class=\"fas fa-    satellite-dish\"&gt;&lt;/i&gt; Read sensor&lt;/button&gt;      &lt;/a&gt;&lt;/p&gt;");</p><p>To allow the<a id="_idIndexMarker508"/> user to gather the sensor reading, we included a button to press each time they need to know their plant's status. Remember—the complete code for this part of the project is available in the <strong class="source-inline">Chapter10/webserver</strong> GitHub folder.</p><p class="callout-heading">Important note</p><p class="callout">If you need to use free images and icons, you can find them on the internet repositories such as the following: </p><p class="callout"><a href="https://pixabay.com/">https://pixabay.com/</a></p><p class="callout"><a href="https://fontawesome.com/icons">https://fontawesome.com/icons</a></p></li>
			</ol>
			<p>The sketch<a id="_idIndexMarker509"/> is now complete, so upload it to the NodeMCU board and reset it after completing the upload. Now, you can see in the <strong class="bold">serial monitor</strong> the IP address to connect our client, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/Figure_10.12_B16413.jpg" alt="Figure 10.12 – IP address on the serial monitor"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12 – IP address on the serial monitor</p>
			<p>It's now time to move on to the next section, which will show you how to visualize the data over the internet.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor142"/>Showing sensor data results over the internet</h1>
			<p>Having<a id="_idIndexMarker510"/> objects connected to the internet will allow you to access their data from anywhere that has a connection to that network.</p>
			<p>This is why we gave our project the ability to become a web server and thus be able to access the state of the plant pot from any web browser.</p>
			<p>For this project, access can only be from our Wi-Fi network. To test its operation, we are going to access the developed web app from any mobile or desktop web browser. Proceed as follows:</p>
			<ol>
				<li value="1">Open a web browser and go to the IP address of our server (see <em class="italic">Figure 10.12</em>). You<a id="_idIndexMarker511"/> should see our landing page to monitor our plant pot, as shown in the following screenshot: <div id="_idContainer139" class="IMG---Figure"><img src="image/Figure_10.13_B16413.jpg" alt="Figure 10.13 – Web app landing page"/></div><p class="figure-caption">Figure 10.13 – Web app landing page</p></li>
				<li>On the landing page, you can simply press the button every time you want to measure the humidity of the plant pot. If the soil is dry, we will see a representative<a id="_idIndexMarker512"/> image and a legend stating <strong class="bold">Soil is too dry</strong>, as illustrated in the following screenshot:<div id="_idContainer140" class="IMG---Figure"><img src="image/Figure_10.14_B16413.jpg" alt="Figure 10.14 – Web app screen for dry soil"/></div><p class="figure-caption">Figure 10.14 – Web app screen for dry soil</p></li>
				<li>Otherwise, if the <a id="_idIndexMarker513"/>soil has good humidity, we get a legend stating <strong class="bold">Soil is moist enough</strong> along with a representative image, as illustrated in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/Figure_10.15_B16413.jpg" alt="Figure 10.15 – Web app screen for moist soil"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.15 – Web app screen for moist soil</p>
			<p>You can<a id="_idIndexMarker514"/> monitor your plant pots with this IoT device and application from anywhere in your home, as long as you are connected to your local Wi-Fi network.</p>
			<p>We have reached the end of this chapter. Well done! Let's see what we learned in this project.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor143"/>Summary</h1>
			<p>At the beginning of the project, you saw how to interface a soil moisture sensor to your STM32 board. Then, we created a simple sketch to collect the sensor readings and tested it to ensure it worked properly.</p>
			<p>We also learned how to connect a NodeMCU card to the internet and read the sensor data from the STM32. Finally, in the last part of the project, we built a web app to control the IoT device from any web browser, either mobile or desktop.</p>
			<p>The IoT area is growing quickly, so talented people with the right skills in this technology can easily access jobs in this exciting area. With this in mind, after completing this chapter, we now have a stronger foundation for creating IoT devices and applications.</p>
			<p>In the next chapter, we will learn how to connect our electronic devices to the internet and make them available outside our local Wi-Fi network.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor144"/>Further reading</h1>
			<p>Chalimov, A, <em class="italic">IoT in agriculture: 8 technology use cases for smart farming (and challenges to consider)</em>. Eastern Peak, 2020: <a href="https://easternpeak.com/blog/iot-in-agriculture-technology-use-cases-for-smart-farming-and-challenges-to-consider/">https://easternpeak.com/blog/iot-in-agriculture-technology-use-cases-for-smart-farming-and-challenges-to-consider/</a></p>
		</div>
	</body></html>