- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Writing Generic Containers with Implicit Memory Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用隐式内存管理编写泛型容器
- en: In the previous chapter, we wrote a working (if simple) implementation of a
    `std::vector<T>`-like type in `Vector<T>`, as well as a working (if, again, simple)
    implementation of a `std::forward_list<T>`-like type in `ForwardList<T>`. Not
    bad!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在`Vector<T>`中编写了一个工作（尽管简单）的类似`std::vector<T>`类型的实现，以及在`ForwardList<T>`中编写了一个工作（尽管，再次，简单）的类似`std::forward_list<T>`类型的实现。不错！
- en: In the case of our `Vector<T>` type, after an initial effort that led to a working
    but sometimes inefficient implementation, we made the effort to separate allocation
    from construction, something that reduced the amount of redundant effort required
    at runtime but came at the cost of a more subtle implementation. In this more
    sophisticated implementation, we distinguished parts of the underlying storage
    that are initialized from those that are not and, of course, operated on both
    parts appropriately (treating objects as objects and raw memory as such). For
    example, we used assignment (and algorithms that use the assignment operator)
    to replace the contents of existing objects but preferred placement `new` (and
    algorithms that rely on this mechanism) to create objects in raw memory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`Vector<T>`类型的情况下，经过最初的努力，我们得到了一个工作但有时效率不高的实现，然后我们努力将分配与构造分离，这样做减少了运行时所需的冗余工作量，但代价是更复杂的实现。在这个更复杂的实现中，我们区分了底层存储中已初始化的部分和未初始化的部分，并且当然，对这两部分都进行了适当的操作（将对象视为对象，将原始内存视为原始内存）。例如，我们使用赋值（以及使用赋值运算符的算法）来替换现有对象的内容，但更倾向于使用placement
    `new`（以及依赖于此机制的算法）在原始内存中创建对象。
- en: Our `Vector<T>` implementation from the previous chapter is a class expressed
    with a sizable amount of source code. One of the reasons for this situation is
    the explicit memory management we have been doing. Indeed, we have made a `Vector<T>`
    object responsible for both the management of the underlying memory block and
    the objects stored therein, and this double responsibility came with a cost. In
    this chapter, we will revisit that design by making memory management *implicit*
    and we will discuss the consequences of this new approach. Hopefully, dear reader,
    this will lead you toward a possible simplification and refinement of your coding
    practices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中我们的`Vector<T>`实现是一个用大量源代码表达出的类。这种情况的原因之一是我们所进行的显式内存管理。确实，我们使`Vector<T>`对象负责管理底层内存块以及存储其中的对象，这种双重责任带来了成本。在本章中，我们将通过使内存管理*隐式*来重新审视这种设计，并将讨论这种新方法的影响。希望，亲爱的读者，这将引导你走向可能的简化和对编码实践的改进。
- en: 'In this chapter, our goals will be as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的目标将是以下内容：
- en: To adapt a hand-written container such as `Vector<T>` in such a way as to significantly
    simplify its memory management responsibilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了以这种方式适应手写的容器，如`Vector<T>`，从而显著简化其内存管理责任
- en: To understand the consequences of our design on source code complexity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了理解我们的设计对源代码复杂性的影响
- en: To understand the consequences of our design on exception safety
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了理解我们的设计对异常安全性的影响
- en: We will spend most of our energy on revisiting the `Vector<T>` container, but
    we will also revisit `ForwardList<T>` to see if we can apply the same kind of
    reasoning to both container types. By the end of this chapter, at least in the
    case of `Vector<T>`, we will still have a hand-written container that manages
    memory efficiently and distinguishes raw memory from constructed objects, but
    our implementation will be significantly simpler than the one we produced in [*Chapter
    12*](B21071_12.xhtml#_idTextAnchor172).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大部分精力放在重新审视`Vector<T>`容器上，但我们也会重新审视`ForwardList<T>`，看看我们是否可以将同样的推理应用于这两种容器类型。到本章结束时，至少在`Vector<T>`的情况下，我们仍然有一个手写的容器，它能够有效地管理内存并将原始内存与构造对象区分开来，但我们的实现将比我们在[*第12章*](B21071_12.xhtml#_idTextAnchor172)中产生的实现简单得多。
- en: Note that with respect to `Vector<T>`, this chapter will compare two versions.
    One will be named the “*naïve* version” and will be the initial implementation
    that uses objects of type `T` throughout the underlying storage. The other will
    be named the “*sophisticated* version” and will be the implementation that considers
    the underlying storage as being made of two (potentially empty) “sections,” with
    objects of type `T` at the beginning and raw memory at the end.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，关于`Vector<T>`，本章将比较两个版本。一个将被命名为“*天真*版本”，它将是使用底层存储中`T`类型对象的初始实现。另一个将被命名为“*复杂*版本”，它将考虑底层存储由两个（可能为空）的“部分”组成，`T`类型对象位于开始处，原始内存位于末尾。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter13](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter13).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到本章的代码文件：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter13](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter13)。
- en: Some words about the code excerpts in this chapter
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章代码摘录的一些说明
- en: This chapter will for the most part revisit and modify (hopefully simplifying!)
    the code examples from [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172), using
    ideas from previous chapters (notably [*Chapter 5*](B21071_05.xhtml#_idTextAnchor079)
    and [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096)) along the way. Since a lot
    of the code used for `Vector<T>` and `ForwardList<T>` will not change, we will
    not write the entire classes all over again to avoid undue repetition.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将主要回顾和修改（希望简化！）[*第12章*](B21071_12.xhtml#_idTextAnchor172)中的代码示例，在过程中使用前几章（特别是[*第5章*](B21071_05.xhtml#_idTextAnchor079)和[*第6章*](B21071_06.xhtml#_idTextAnchor096)）中的想法。由于用于`Vector<T>`和`ForwardList<T>`的大部分代码不会改变，我们不会重写整个类，以避免不必要的重复。
- en: Instead, we will concentrate on the most meaningful modifications made to the
    previous versions of those classes, sometimes comparing implementations “before”
    and “after” modifications have been made. Of course, the code samples in the GitHub
    repository are complete and can be used to “complete the picture.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将专注于对那些类先前版本所做的最有意义的修改，有时会比较修改“之前”和“之后”的实现。当然，GitHub仓库中的代码示例是完整的，可以用来“完善画面”。
- en: Why explicit memory management complicates our implementation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么显式内存管理使我们的实现复杂化
- en: 'Let’s look for a moment at one of the constructors for `Vector<T>` as written
    in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172). For simplicity, we will use
    the constructor that accepts a number of elements and an initial value for these
    elements as arguments. If we limit ourselves to the naïve version where `elems`
    points to a sequence of `T` objects and put aside for the moment the more sophisticated
    version where `elems` points to a block of memory that holds `T` objects at the
    beginning and raw memory at the end, we have the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时看看`Vector<T>`的一个构造函数，正如在[*第12章*](B21071_12.xhtml#_idTextAnchor172)中所写的。为了简单起见，我们将使用接受元素数量和这些元素的初始值的构造函数。如果我们只限于`elems`指向`T`对象序列的简单版本，并暂时不考虑`elems`指向在开始处包含`T`对象和末尾包含原始内存的内存块的更复杂版本，我们就有以下内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This constructor allocates an array of `T` objects, initializes them through
    a sequence of assignments, “handles” exceptions, and so on. The `try` block and
    its corresponding `catch` block are part of our implementation, but not because
    we want to handle exceptions raised by the constructors of `T` objects. Indeed:
    how could we know what exceptions it could throw if we do not know what `T` is?
    We insert these blocks because we need to explicitly deallocate and destroy the
    array if we are to avoid leaks. The situation gets even more complicated if we
    look at the more sophisticated version that distinguishes allocation from construction:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数分配一个`T`对象的数组，通过一系列赋值初始化它们，处理异常等。`try`块及其相应的`catch`块是我们实现的一部分，但并非因为我们想处理`T`对象构造函数抛出的异常。实际上：如果我们不知道`T`是什么，我们怎么知道它可能会抛出什么异常呢？我们插入这些块是因为如果我们想避免泄漏，我们需要显式地分配和销毁数组。如果我们查看区分分配和构造的更复杂版本，情况会变得更加复杂：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, we do this work because we decided that `Vector<T>` would be
    the *owner* of that memory. And we are totally allowed to do so! But what if we
    made something else responsible for our memory?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们这样做是因为我们决定`Vector<T>`将是那个内存的*所有者*。我们完全有权利这样做！但是，如果我们让其他东西负责我们的内存会怎样呢？
- en: Implicit memory management with a smart pointer
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能指针的隐式内存管理
- en: 'In C++, the simplest way to change our `Vector<T>` implementation from one
    that manually manages memory to one that does so implicitly is through a smart
    pointer. The idea here is, essentially, to change the type of the `elems` data
    member of `Vector<T>` from `T*` to `std::unique_ptr<T[]>`. We will look at this
    from two angles:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，将我们的`Vector<T>`实现从手动管理内存更改为隐式管理内存的最简单方法是通过智能指针。这里的想法本质上是将`Vector<T>`的`elems`数据成员的类型从`T*`更改为`std::unique_ptr<T[]>`。我们将从两个角度来探讨这个问题：
- en: How does this change impact the naïve version of `Vector<T>`? As a reminder,
    our naïve version from [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172) did not
    distinguish between objects and raw memory in the underlying storage, and thus
    only stored objects. This led to a simpler implementation, but also one that needlessly
    constructed objects on many occasions and was much slower than the more sophisticated
    implementation for non-trivially constructible types.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种变化如何影响`Vector<T>`的原始版本？作为提醒，我们来自[*第12章*](B21071_12.xhtml#_idTextAnchor172)的原始版本没有在底层存储中区分对象和原始内存，因此只存储对象。这导致了一个更简单的实现，但也是一个在许多场合不必要地构建对象，并且对于非平凡构造类型来说比更复杂的实现慢得多的实现。
- en: How does this change impact the sophisticated version of `Vector<T>` that avoided
    the performance trap of constructing unnecessary objects at the cost of a somewhat
    more complicated implementation?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种变化如何影响避免了在实现上稍微复杂的情况下构建不必要的对象的性能陷阱的`Vector<T>`的复杂版本？
- en: In both cases, we will examine selected member functions that are indicative
    of the impact of this change. The full implementations of both the naïve and the
    sophisticated implementations of `Vector<T>` are available to peruse and use in
    the GitHub repository associated with this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们将检查一些成员函数，这些函数可以表明这种变化的影响。`Vector<T>`的原始和复杂实现的完整实现都可以在本书相关的GitHub仓库中查看和使用。
- en: Impact on the naïve Vector<T> implementation
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对原始`Vector<T>`实现的影响
- en: 'If we were basing our simplification effort on the initial, naïve version of
    [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172) where `elems` simply pointed
    to a contiguous sequence of `T` objects, this would be rather simple, as we could
    change:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的简化工作基于最初的、原始的[*第12章*](B21071_12.xhtml#_idTextAnchor172)版本，其中`elems`简单地指向一个连续的`T`对象序列，这将相当简单，因为我们可以改变：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '… to:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: …变为：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '… and then change the implementation of the `begin()` member functions from
    this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: …然后改变`begin()`成员函数的实现，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '… to this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: …更改为以下内容：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Just doing this would be sufficient to significantly simplify the implementation
    of type `Vector<T>` as deallocating memory would become implicit. For example,
    we could simplify each constructor by removing the exception handling altogether,
    changing, for example, the following implementation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 仅做这一点就足以显著简化`Vector<T>`类型的实现，因为释放内存将变得隐式。例如，我们可以通过完全删除异常处理来简化每个构造函数，例如，将以下实现更改为以下内容：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '… for this significantly simpler one:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: …变为这个显著更简单的版本：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The reason for this simplification is the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化的原因如下：
- en: 'If the `Vector<T>` object is responsible for the allocated memory, then deleting
    the array will be done implicitly when the destructor is called, but for a destructor
    to be called, there needs to be an object to destroy: a `Vector<T>` constructor
    needs to have succeeded! That explains why we need to catch whatever exception
    was thrown, manually delete the array, and re-throw whatever exception was thrown:
    until the closing brace of a destructor is reached, there is no `Vector<T>` object
    to destruct and all resource management has to be done explicitly.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Vector<T>`对象负责分配的内存，那么在调用析构函数时将隐式地删除数组，但是为了调用析构函数，需要有一个要销毁的对象：`Vector<T>`构造函数必须成功！这就解释了为什么我们需要捕获抛出的任何异常，手动删除数组，并重新抛出抛出的任何异常：直到达到析构函数的结束括号，没有`Vector<T>`对象可以销毁，所有资源管理都必须显式完成。
- en: 'On the other hand, if `elems` is a smart pointer, then it becomes responsible
    for the pointee as soon as the smart pointer itself has been constructed, and
    this occurs *before* the opening brace of the `Vector<T>` constructor. This means
    that once `elems` has been constructed, it *will* be destructed if an exception
    leaves the constructor, freeing the `Vector<T>` object-to-be from the task of
    destructing the array. To be clear: when we reach the opening brace of the constructor
    of `Vector<T>`, the data members of `*this` have been constructed, and for that
    reason, they will be destructed if an exception is thrown, even if the construction
    of `*this` itself does not conclude. The object model of C++ is truly wonderful
    in such situations.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果 `elems` 是智能指针，那么一旦智能指针本身被构造，它就负责被指向的对象，这发生在 `Vector<T>` 构造函数的开括号之前。这意味着一旦
    `elems` 被构造，如果发生异常导致构造函数退出，它将被销毁，从而释放即将成为 `Vector<T>` 对象的任务，不再需要销毁数组。为了明确：当我们到达
    `Vector<T>` 构造函数的开括号时，`*this` 的数据成员已经被构造，因此，即使 `*this` 本身的构造没有完成，如果抛出异常，它们也将被销毁。C++
    的对象模型在这种情况下确实很奇妙。
- en: The more astute among you, dear readers, will have noticed that even if one
    was writing code for a company where exceptions are disallowed or frowned upon,
    the exception-safety we gained from using a smart pointer remains. We have (discretely)
    written exception-safe code without writing the words `try` or `catch`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 亲爱的读者，你们中更有洞察力的人可能会注意到，即使你为一家不允许或反对使用异常的公司编写代码，使用智能指针所获得的异常安全性仍然存在。我们（隐式地）编写了异常安全的代码，而没有使用
    `try` 或 `catch` 语句。
- en: 'Other examples of simplification through the introduction of implicit memory
    management would include move operations and the destructor of `Vector<T>`, which
    would change from this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入隐式内存管理来简化的一些其他示例包括移动操作和 `Vector<T>` 的析构函数，这将从以下内容变为：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '… to simply this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: …简化如下：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Making move operations `=default` works because type `std::unique_ptr` does
    “the right thing” when moving and transfers ownership of the pointee from the
    source to the destination.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将移动操作设置为 `=default` 之所以有效，是因为类型 `std::unique_ptr` 在移动时“做正确的事情”，并将所有者的所有权从源传递到目的地。
- en: Something to be aware of
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的事情
- en: By making the move operations `=default`, we induced a slight semantic change
    in our `Vector<T>` implementation. The C++ standard recommends that a moved-from
    is in a valid yet unspecified state but does not go into detail as to what “valid”
    means. Our hand-written move operations restored the moved-from object to the
    equivalent of a default-constructed `Vector<T>` object, but the “defaulted” one
    leaves the moved-from object with a null `elems` but with potentially non-zero
    size and capacity. This still works in practice as long as user code does not
    use the moved-from object unless it has first been reassigned to, but it is a
    semantic change that deserves to be acknowledged.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将移动操作设置为 `=default`，我们在 `Vector<T>` 实现中引起了一点点语义变化。C++ 标准建议移动后的对象处于有效但未指定的状态，但并未详细说明“有效”的含义。我们编写的移动操作将移动后的对象恢复到与默认构造的
    `Vector<T>` 对象等效的状态，但“默认”的移动操作将移动后的对象留下一个空的 `elems`，但可能具有非零的大小和容量。只要用户代码在使用移动后的对象之前将其重新赋值，这在实践中仍然有效，但这是一个值得认可的语义变化。
- en: 'Yet another interesting simplification would be the implementation of the `resize()`
    member function. In the original, naïve `Vector<T>` implementation, we had the
    following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有趣的简化方法将是实现 `resize()` 成员函数。在原始的、天真的 `Vector<T>` 实现中，我们有以下内容：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, again, we are faced with the possibility of an exception being thrown
    from the copy assignment of a `T` object to a `T` object and need to handle exceptions
    in order to avoid leaking resources. Going from explicit resource handling to
    implicit resource handling, we get the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次面临从 `T` 对象到 `T` 对象的复制赋值操作中抛出异常的可能性，并需要处理异常以避免资源泄露。从显式资源管理到隐式资源管理，我们得到以下内容：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the entire exception handling code is gone. Object `p` owns
    the new array and will destroy it when the function concludes execution. Once
    the copies (or the moves, depending on whether the move assignment of type `T`
    is or is not marked as `noexcept`) are completed, `elems` lets go of the previously
    owned array through `reset()` (destroying it at the same time) and “steals” ownership
    of the array released by `p` through `release()`. Note that writing `elems = std::move(p);`
    would have had a similar effect.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，整个异常处理代码已经消失。对象 `p` 拥有新的数组，并在函数执行结束时销毁它。一旦复制（或移动，取决于类型 `T` 的移动赋值是否标记为 `noexcept`）完成，`elems`
    通过 `reset()` 放弃之前拥有的数组（同时销毁它）并通过 `release()` “窃取”由 `p` 释放的数组所有权。请注意，编写 `elems
    = std::move(p);` 会有类似的效果。
- en: Applying this simplification process throughout `Vector<T>`, source code gradually
    shrinks and, on a container like the naïve version of `Vector<T>` that only contains
    objects, no raw memory block at the end of the underlying storage, we can save
    almost 25% of the number of source code lines (going from roughly 180 lines to
    140 lines for this academic implementation). Try it and see for yourself!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个简化过程应用到 `Vector<T>` 中，源代码逐渐减少，对于一个像 `Vector<T>` 的原始版本这样的容器，它只包含对象，没有底层存储末尾的原始内存块，我们可以节省大约25%的源代码行数（对于这个学术实现，从大约180行减少到140行）。试试看，看看你自己能发现什么！
- en: Impact on the sophisticated Vector<T> implementation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对复杂的 Vector<T> 实现的影响
- en: 'Applying the same technique to the more sophisticated `Vector<T>` will require
    a bit more work as the default behavior of the destructor of an object of type
    `std::unique_ptr<T[]>` will be to apply `operator delete[]` to the pointer it
    owns. As we know at this point, our sophisticated implementation can be conceptualized
    as being made of two (potentially empty) “sections”: an initial section made of
    `T` objects manually placed into raw memory followed by another section of uninitialized,
    raw memory devoid of objects. As such, we need to handle each “section” in a different
    manner.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的技巧应用到更复杂的 `Vector<T>` 上将需要更多的工作，因为 `std::unique_ptr<T[]>` 类型对象的析构函数的默认行为是将
    `operator delete[]` 应用于它拥有的指针。正如我们所知，我们的复杂实现可以概念化为由两个（可能为空）的“部分”组成：一个由 `T` 对象手动放置到原始内存中的初始部分，后面跟着一个未初始化的、没有对象的原始内存部分。因此，我们需要以不同的方式处理每个“部分”。
- en: We will still use a `std::unique_ptr<T[]>` object to manage the memory, but
    we will need to use a `custom deleter` object (something we discussed in [*Chapter
    5*](B21071_05.xhtml#_idTextAnchor079) and in [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096))
    to take into account the specifics of our implementation. This object will need
    knowledge of the runtime state of the `Vector<T>` object it will accompany since
    it will have to know where each “section” of the underlying storage starts as
    well as where it ends, and that is something that changes as the code is executing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然会使用 `std::unique_ptr<T[]>` 对象来管理内存，但我们需要使用一个 `自定义删除器` 对象（在[*第5章*](B21071_05.xhtml#_idTextAnchor079)和[*第6章*](B21071_06.xhtml#_idTextAnchor096)中讨论过）来考虑我们实现的特定细节。这个对象需要了解它将伴随的
    `Vector<T>` 对象的运行时状态，因为它必须知道底层存储的每个“部分”从哪里开始以及在哪里结束，而这些都是随着代码执行而变化的。
- en: 'The first important point of this implementation, and this is a point that
    has been recurring but that we probably did not insist upon enough, is that we
    want our implementations to expose the same interface to client code, regardless
    of implementation variations. This is sometimes impossible or unreasonable to
    achieve, but it is nonetheless a meaningful and worthwhile target. This includes
    our choice of internal public types: for example, the fact that we use a smart
    pointer to manage the underlying memory does not change the fact that a pointer
    to an element is a `T*`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的一个重要观点，这是一个反复出现但可能我们没有足够坚持的观点，是我们希望我们的实现向客户端代码暴露相同的接口，无论实现有何变化。这有时可能是不可能的或不合理的，但无论如何，这是一个有意义且值得追求的目标。这包括我们选择内部公共类型：例如，我们使用智能指针来管理底层内存的事实并不改变指向元素的指针是一个
    `T*` 的事实：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, since we want to define `elems` as being a smart pointer that owns and
    manages the underlying storage instead of being a raw pointer, we will need to
    define the custom deleter that will be used by that smart pointer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们希望将 `elems` 定义为一个智能指针，它拥有并管理底层存储，而不是一个原始指针，因此我们需要定义一个将被该智能指针使用的自定义删除器。
- en: 'An important aspect of this problem is that the custom deleter will need to
    know the state of the `Vector<T>` object to know what part of the underlying storage
    holds objects. For this reason, the custom deleter of our `std::unique_ptr<T[]>`
    will be stateful and store a reference named `source` to the `Vector<T>` object.
    Through `source`, The function call operator of the `deleter` object will have
    access to the sequence of objects in the container (the half-open sequence from
    `source.begin()` to `source.end()`) and will be able to `destroy()` these objects
    before freeing the underlying storage:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的一个重要方面是，自定义删除器需要知道`Vector<T>`对象的状态，以便知道底层存储中哪些部分持有对象。因此，我们的`std::unique_ptr<T[]>`的自定义删除器将是状态化的，并存储一个名为`source`的`Vector<T>`对象的引用。通过`source`，`deleter`对象的函数调用操作符将能够访问容器中的对象序列（从`source.begin()`到`source.end()`的半开序列）并在释放底层存储之前`destroy()`这些对象：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `elems` data member knows that the type of the custom deleter will be `deleter`,
    but the actual object that will play the role of deleter will have to know what
    `Vector<T>` object it will interact with. The constructors of a `Vector<T>` will
    be responsible for providing this information, and we will need to be careful
    with the ways in which we implement our move operations in order to make sure
    we do not transfer the `deleter` object’s state and make our code incoherent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`elems`数据成员知道自定义删除器的类型将是`deleter`，但实际上将扮演删除器角色的对象必须知道它将与之交互的`Vector<T>`对象。`Vector<T>`的构造函数将负责提供此信息，并且我们需要小心地实现我们的移动操作，以确保我们不会传递删除器对象的状态并使我们的代码不一致。'
- en: 'As mentioned with the naïve version, we need to adapt the `begin()` member
    functions to take into account the fact that `elems` is a smart pointer but that
    our `iterator` interface relies on raw pointers:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在简单版本中提到的，我们需要调整`begin()`成员函数，以考虑到`elems`是一个智能指针，但我们的`iterator`接口依赖于原始指针：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our constructors will need to adapt to the fact that we have a custom deleter
    that will clean up if anything bad happens, or if the program concludes normally.
    Three examples of `Vector<T>` constructors follow:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数需要适应这样一个事实，即我们有一个自定义删除器，它会在发生任何不良情况或程序正常结束时进行清理。以下是`Vector<T>`构造函数的三个示例：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Please note that we are not expressing the move constructor with `=default`
    in this case as we do not want to transfer the custom deleter, our implementation
    having associated this object with a specific `Vector<T>` object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里没有使用`=default`来表示移动构造函数，因为我们不希望传递自定义删除器，我们的实现已经将此对象与特定的`Vector<T>`对象关联起来。
- en: 'A small note is in order here: we are passing `*this` to the constructor of
    the `deleter` object, but we are doing so *before* the construction of `*this`
    has been completed, so *anything* done by the `deleter` object before the construction
    of `*this` concludes (before the closing brace of its constructor) deserves care
    and attention.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要一个小注解：我们在`deleter`对象的构造函数中传递了`*this`，但是我们在`*this`的构造完成之前就进行了这一操作，所以`deleter`对象在`*this`构造完成（在其构造函数的闭合括号之前）所做的任何操作都值得注意和关注。
- en: In our case, the `deleter` object will come into play if the destructor of `elems`
    comes into play, which will happen if the constructor of an object of type `T`
    throws. We need to make sure that the values of the data members of `*this` are
    coherent whenever there is a possibility that the `deleter` object intervenes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，如果类型`T`的对象的构造函数抛出异常，`deleter`对象将发挥作用。我们需要确保在`deleter`对象可能介入的情况下，`*this`的数据成员的值始终保持一致。
- en: 'In our case, since the `begin()` and `end()` member functions return iterators
    that define a half-open range of objects and, as we now know, `std::uninitialized_fill()`
    calls the constructors and (if an exception is thrown) destroys the objects that
    have been constructed, we have to make sure that `nelems==0` until all of the
    objects have been constructed. Note that we defined the range to initialize as
    `begin()` and `begin()+n`, and waited until after the call to `std::uninitialized_fill()`
    to change `nelems`: this way, `begin()==end()` if an exception is thrown, and
    the `deleter` object will not try to destruct “non-objects.”'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，由于`begin()`和`end()`成员函数返回定义对象半开范围的迭代器，并且正如我们所知，`std::uninitialized_fill()`调用构造函数（如果抛出异常）则销毁已构造的对象，我们必须确保`nelems==0`直到所有对象都构造完成。请注意，我们定义了从`begin()`到`begin()+n`的范围进行初始化，并在调用`std::uninitialized_fill()`之后改变`nelems`：这样，如果抛出异常，则`begin()==end()`，并且`deleter`对象不会尝试销毁“非对象”。
- en: Other constructors of class `Vector<T>` are likewise simplified; we will not
    show them here so consider them as not-so-dreaded “exercises left to the reader.”
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Vector<T>`的其他构造函数同样被简化；我们在这里不会展示它们，所以请将它们视为不那么令人畏惧的“留给读者的练习。”
- en: 'The simplification of `Vector<T>` is made evident with some of the special
    member functions that now require little or no effort on our part. Of note in
    this regard is the destructor, which can now be defaulted; as mentioned with the
    move constructor earlier in this section, we do not default the move assignment
    to avoid transferring the custom deleter’s internal state, as can be seen in the
    following code excerpt:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector<T>`的简化通过一些现在需要我们付出很少或几乎不需要努力的特设成员函数变得明显。在这方面值得注意的是析构函数，现在它可以被默认；如本节前面提到的移动构造函数，我们不默认移动赋值操作，以避免转移自定义删除器的内部状态，如下面的代码片段所示：'
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Member functions `swap()` and `operator[]` have been shown to make it clear
    that `std::unique_ptr<T[]>` behaves in many ways like a “regular” array of `T`
    objects. Many other member functions of `Vector<T>` remain unchanged, such as
    `front()`, `back()`, `operator==()`, `operator!=()`, `grow()`, `push_back()`,
    and `emplace_back()`. Please refer to [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172)
    for details on these functions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数`swap()`和`operator[]`已被证明表明`std::unique_ptr<T[]>`在许多方面表现得像`T`对象的“常规”数组。`Vector<T>`的许多其他成员函数保持不变，例如`front()`、`back()`、`operator==()`、`operator!=()`、`grow()`、`push_back()`和`emplace_back()`。请参阅[*第12章*](B21071_12.xhtml#_idTextAnchor172)以了解这些函数的详细信息。
- en: The `reserve()` and `resize()` functions can also be simplified through the
    use of smart pointers, as we can get rid of explicit exception management and
    yet remain exception-safe since `std::unique_ptr<T[]>` is an **RAII** type and
    handles memory for us.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用智能指针，`reserve()`和`resize()`函数也可以简化，因为我们可以消除显式的异常管理，同时由于`std::unique_ptr<T[]>`是一个**RAII**类型，它会为我们处理内存，所以我们仍然保持异常安全。
- en: 'In the case of `reserve()`, we now use smart pointer `p` to hold the allocated
    memory, then either `move()` or `copy()` the objects from `elems` to `p`. Once
    this is done, we `destroy()` the objects left in `elems`, after which `p` relinquishes
    its pointer and transfers it to `elems`, and the only thing left to do is to update
    the container’s capacity:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reserve()`的情况下，我们现在使用智能指针`p`来持有分配的内存，然后将`elems`中的对象通过`move()`或`copy()`操作移动到`p`。一旦完成这些操作，我们就`destroy()`掉`elems`中剩余的对象，之后`p`放弃其指针并将其转移到`elems`，剩下的唯一事情就是更新容器的容量：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the case of `resize()`, we now use smart pointer `p` to hold the allocated
    memory, then either `move()` or `copy()` the objects from `elems` to `p` and construct
    default `T` objects in the remaining part of the memory block. Once this is done,
    we `destroy()` the objects left in `elems`, after which `p` relinquishes its pointer
    and transfers it to `elems`, and the only thing left to do is to update the container’s
    capacity:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`resize()`的情况下，我们现在使用智能指针`p`来持有分配的内存，然后将`elems`中的对象通过`move()`或`copy()`操作移动到`p`，并在内存块的剩余部分构造默认的`T`对象。一旦完成这些操作，我们就`destroy()`掉`elems`中剩余的对象，之后`p`放弃其指针并将其转移到`elems`，剩下的唯一事情就是更新容器的容量：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The magic of it all, or so to speak, is that our other member functions such
    as `insert()` and `erase()` are built on top of basic abstractions such as `reserve()`,
    `begin()`, `end()`, and so on, which means they do not have to be modified to
    take into account this representational change.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切的魔力，或者说，可以这样讲，就是我们的其他成员函数，如`insert()`和`erase()`，是建立在基本抽象如`reserve()`、`begin()`、`end()`等之上的，这意味着它们不需要修改以考虑这种表示变化。
- en: Consequences of this redesign
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新设计的后果
- en: 'What are the consequences of this “redesign” of sorts? They have been mentioned
    along the way, but let’s summarize:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“重新设计”的后果是什么？它们在过程中已经提到，但让我们总结一下：
- en: 'For user code, consequences are essentially none: an object of type `Vector<T>`
    occupies the same space in memory with the implicit memory management implementation
    and almost the same space with the explicit memory management implementation (where
    the custom deleter is stateful), and each exposes the same public interface.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于用户代码来说，后果基本上没有：`Vector<T>` 类型的对象在内存管理实现中占据相同的空间，与显式内存管理实现（其中自定义删除器是状态化的）几乎占据相同的空间，并且每个都公开了相同的接口。
- en: 'There are essentially no speed costs either, for reasons explained in [*Chapter
    5*](B21071_05.xhtml#_idTextAnchor079): in code compiled with optimization levels
    other than the basic, made-for-debugging ones, going through `std::unique_ptr<T>`
    will, due to function call inlining, lead to code that is as efficient as going
    through a `T*`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在 [*第5章*](B21071_05.xhtml#_idTextAnchor079) 中解释的原因，基本上没有速度成本：在除基本、专为调试编译的优化级别之外编译的代码中，通过
    `std::unique_ptr<T>` 进行操作，由于函数内联调用，将导致与通过 `T*` 进行操作一样高效的代码。
- en: 'The implementation is made significantly simpler: fewer instructions, no explicit
    exception handling code, more member functions that can be defaulted…'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现变得更加简单：指令更少，没有显式的异常处理代码，更多的成员函数可以省略默认值…
- en: 'An important aspect of this implicit memory management implementation is that
    it is exception-safe even in the absence of explicit `try` and `catch` blocks.
    This can make a difference in many situations: for example, you might be in a
    situation where exceptions are not allowed but find yourself using a library where
    exceptions are a possibility… or can simply call `operator new()` in a situation
    where memory is constrained. Our implementation with implicit memory management
    would be safe under such circumstances, but an implementation taking a manual
    memory management approach with no exception handling code would not be so “lucky.”'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个隐式内存管理实现的 重要方面在于，即使在没有显式的 `try` 和 `catch` 块的情况下，它也是异常安全的。这可能在许多情况下都会产生影响：例如，你可能处于不允许异常的情况，但发现自己正在使用一个可能抛出异常的库…或者可以在内存受限的情况下简单地调用
    `operator new()`。在我们的隐式内存管理实现中，在这种情况下将是安全的，但一个采用手动内存管理方法且没有异常处理代码的实现则不会这么“幸运”。
- en: The effort involved in implementing the custom deleter seems to be a sound investment
    with `Vector<T>`. Now, you might wonder whether the situation is similar with
    node-based containers, so we will explore this question by revisiting the naïve
    `ForwardList<T>` implementation from [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Vector<T>` 中实现自定义删除器的努力似乎是一个值得的投资。现在，你可能想知道这种情况是否与基于节点的容器相似，因此我们将通过回顾 [*第12章*](B21071_12.xhtml#_idTextAnchor172)
    中的原始 `ForwardList<T>` 实现来探索这个问题。
- en: Generalizing to ForwardList<T>?
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推广到 ForwardList<T>？
- en: We now know that we can adapt the implementation of `Vector<T>`, transforming
    it from an explicit memory management model to an implicit one, and that so doing
    has lots of advantages. It is tempting to do the same with other containers, but
    before embarking on such an adventure, it might be wise to analyze the problem
    a little.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道我们可以调整 `Vector<T>` 的实现，将其从显式内存管理模型转换为隐式模型，并且这样做有很多优点。将同样的方法应用于其他容器很诱人，但在开始这样的冒险之前，分析问题可能更明智。
- en: We implemented a node-based container with explicit memory management named
    `ForwardList<T>` in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172). What would
    be the impact of trying to change the implementation of this container to make
    it more implicit?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第12章*](B21071_12.xhtml#_idTextAnchor172) 中实现了名为 `ForwardList<T>` 的具有显式内存管理的基于节点的容器。尝试改变这个容器的实现以使其更加隐式会有什么影响？
- en: Attempt - making each node responsible for its successor
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试 - 使每个节点对其后续节点负责
- en: In our exploration of ways in which we could try to make memory management in
    a node-based container more implicit, one possible approach could be to change
    the definition of `ForwardList<T>::Node` such that the `next` data member becomes
    a `std::unique_ptr<Node>` instead of a `Node*`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索如何使基于节点的容器中的内存管理更加隐式的方法中，一个可能的方法是改变 `ForwardList<T>::Node` 的定义，使得 `next`
    数据成员变为 `std::unique_ptr<Node>` 而不是 `Node*`。
- en: 'As a synopsis, we would get the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 概括来说，我们会得到以下结果：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This might seem like an improvement at first glance, since it would simplify
    the destructor of `ForwardList<T>` down to the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这似乎是一个改进，因为它将`ForwardList<T>`析构函数简化为以下内容：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This simplification would induce a kind of “domino effect”: since the `next`
    data member of a node becomes the owner of its successor node in the list, and
    since this is true for every node in the chain (except for `head` itself), then
    destructing the first node ensures the destruction of its successor, and of that
    successor’s successor, and so on.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化将引发一种“多米诺效应”：由于节点的`next`数据成员成为列表中其后继节点的所有者，并且这对于链中的每个节点（除了`head`本身）都是真的，因此销毁第一个节点确保了其后继节点以及其后继节点的销毁，依此类推。
- en: 'This apparent simplification hides a tricky fact: when calling `delete head;`
    under this implementation, *we might be provoking a stack overflow*. Indeed, we
    replaced a loop that applied `delete` on each node in succession with something
    that’s essentially a recursive call, meaning that the impact on stack usage changed
    from something that was fixed to something that is proportional to the number
    of nodes in the list. That’s unpleasant news indeed!'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种明显的简化隐藏了一个棘手的事实：在这个实现下调用`delete head;`时，*我们可能会引发堆栈溢出*。确实，我们用一个本质上相当于递归调用的东西替换了逐个节点应用`delete`的循环，这意味着对堆栈使用的影响从固定变为与列表中节点数量成比例。这确实是个不愉快的消息！
- en: At this point, dear reader, maybe you are thinking “Well, I was only going to
    use this `ForwardList<T>` type for small lists anyway, so I’m not worried.” If
    that expresses your line of thinking, maybe we should explore other implications
    of this implementation decision in our `ForwardList<T>` class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，亲爱的读者，你可能正在想：“嗯，我本来只是打算用这个`ForwardList<T>`类型来处理小列表，所以我不担心。”如果这反映了你的思考方式，那么也许我们应该探索一下在`ForwardList<T>`类中这个实现决策的其他潜在影响。
- en: 'One such implication is that iterators get a little bit more complicated: we
    do not want an iterator over nodes to be the sole owner of the node it is traversing.
    That would be destructive indeed, as nodes would be destroyed as we are iterating
    over the list. For this reason, `ForwardList<T>::Node<U>` (where `U` is either
    `T` or `const T`) would still have a `T*` data member, meaning that `operator++()`,
    for example, would need to obtain the underlying pointer of the `std::unique_ptr<T>`
    data member in each node:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个影响是迭代器会变得稍微复杂一些：我们不希望遍历节点的迭代器成为该节点的唯一所有者。这确实会破坏结构，因为当我们在列表中遍历节点时，节点会被销毁。因此，`ForwardList<T>::Node<U>`（其中`U`是`T`或`const
    T`）仍然有一个`T*`数据成员，这意味着例如`operator++()`需要获取每个节点中`std::unique_ptr<T>`数据成员的底层指针：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That’s a slight complexity increase, but nothing that is impossible to manage.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是略微增加了复杂性，但并不是无法管理的。
- en: 'In [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172), we made most of our `ForwardList<T>`
    constructors converge towards the more general sequence constructor that takes
    a pair of forward iterators of some type `It` as arguments. This constructor would
    become in part more complex, as chaining nodes would now require knowledge that
    we are using smart pointers inside each node, but cleanup in case an exception
    is thrown would only require deleting the head node and letting the aforementioned
    “domino effect” take place:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B21071_12.xhtml#_idTextAnchor172)中，我们将大多数`ForwardList<T>`构造函数收敛到更通用的序列构造函数，该构造函数接受一对某种类型`It`的前向迭代器作为参数。这个构造函数将变得部分复杂，因为现在连接节点需要我们知道每个节点内部使用了智能指针，但抛出异常时的清理只需要删除头节点并让上述“多米诺效应”发生：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Most member functions of `ForwardList<T>` would remain unchanged. There would
    be slight adjustments to such things as `push_front()`, for example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForwardList<T>`的大多数成员函数将保持不变。例如，`push_front()`这样的操作会有细微的调整：'
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As can be seen, we need to distinguish code that uses the `head` data member
    from code that uses the other nodes in the chain. Similar adjustments would apply
    to any member function that modifies the structure of the list, including, notably,
    insertions and suppressions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，我们需要区分使用`head`数据成员的代码和使用链中其他节点的代码。类似的调整将适用于任何修改列表结构的成员函数，包括，值得注意的是，插入和删除操作。
- en: 'A more interesting, and probably more enlightening, member function would be
    the `insert_after()` member function that inserts one element after a given iterator
    in the list. Let’s look at this function in detail:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣、也许更有启发的成员函数将是`insert_after()`成员函数，它在列表中给定迭代器之后插入一个元素。让我们详细看看这个函数：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Hum, that’s quite a lot of updated text! How did this function get so complicated?
    Looking at the “lettered” comments, we have the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是相当多的更新文本！这个函数怎么会变得这么复杂？看看“字母注释”，我们有以下内容：
- en: On line *A*, we create a `std::unique_ptr<Node>` object named `p` for the value
    to be inserted. We know the newly created node will not be the first node in the
    list since the function is `insert_after()`, and requires an iterator to an existing
    “before” node (named `pos` here), so that makes sense. For the same reason, we
    know that `pos` is not `end()`, which, by definition, does not point to a valid
    node in our container.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行 *A* 上，我们为要插入的值创建一个名为 `p` 的 `std::unique_ptr<Node>` 对象。我们知道新创建的节点不会是列表中的第一个节点，因为函数是
    `insert_after()`，需要一个指向现有“之前”节点的迭代器（在这里命名为 `pos`），所以这是有意义的。同样地，我们也知道 `pos` 不是
    `end()`，根据定义，它不会指向容器中的有效节点。
- en: On line *B*, we do what is required to make the successor of `p` the successor
    of `pos`. That requires some care since `pos.cur->next` is guaranteed to be a
    `std::unique_ptr<Node>` (it obviously cannot be `head` as `pos.cur` is “before”
    `pos.cur->next`) and we made `p` a `std::unique_ptr<Node>`. We are displacing
    responsibility over the successor node of `pos.cur` to `p->next`, effectively
    inserting `pos->next` after `p` (albeit in a complicated way).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行 *B* 上，我们做必要的操作，使 `p` 的后继成为 `pos` 的后继。这需要一些小心，因为 `pos.cur->next` 保证是一个 `std::unique_ptr<Node>`（显然它不能是
    `head`，因为 `pos.cur` 是“在” `pos.cur->next` 之前），我们使 `p` 成为一个 `std::unique_ptr<Node>`。我们正在将
    `pos.cur` 的后继节点的责任转移到 `p->next`，实际上是在 `p` 之后插入 `pos->next`（尽管方式复杂）。
- en: On line *C*, we are ensuring that `pos.cur` relinquishes its responsibility
    over `pos.cur->next`. This is important since, if we did not do so, then replacing
    that `std::unique_ptr<Node>` would destroy the pointee. Line *B* ensured that
    `pos.cur->next` and `p->next` would lead to the same object, which would have
    been disastrous had we stopped there (two objects responsible for the same pointee
    is a semantic problem we do not need).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线 *C* 上，我们确保 `pos.cur` 放弃对 `pos.cur->next` 的责任。这是很重要的，因为我们如果不这样做，那么替换那个 `std::unique_ptr<Node>`
    将会破坏其指针指向的对象。行 *B* 确保了 `pos.cur->next` 和 `p->next` 将指向同一个对象，如果我们就此停止（两个对象负责同一个指针指向是一个我们不希望出现的语义问题）。
- en: Once `pos.cur->next` has been disconnected, we move to line *D* where we make
    it point to the raw pointer underneath `p`. This would, again, lead to a shared
    responsibility over a `Node`, so we continue with line *E* where we disconnect
    `p` from its underlying pointer.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦 `pos.cur->next` 被断开连接，我们就转到行 *D*，在那里让它指向 `p` 下的原始指针。这又会再次导致对 `Node` 的共享责任，所以我们继续到行
    *E*，在那里将 `p` 从其基础指针断开连接。
- en: Line *F* concludes the work in this function by returning the expected iterator
    to a raw (thus non-owning) pointer.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 *F* 通过返回一个指向原始（因此非所有者）指针的预期迭代器来结束这个函数的工作。
- en: That is… complicated. The main reason why this is complicated is that most of
    the effort in this function is the transfer of ownership. A `std::unique_ptr<T>`
    object represents sole ownership over a `T*`, after all, and in a linked list,
    each and every insertion or suppression requires moving pointers around, thus
    transferring ownership between nodes. We simplified an occasional situation (deletion
    of the nodes) by complicating most of the operations in our type. That’s… sad.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那是…复杂的。这个函数之所以复杂的主要原因是我们在这个函数中的大部分努力都是所有权的转移。毕竟，`std::unique_ptr<T>` 对象代表了对
    `T*` 的唯一所有权，在一个链表中，每个插入或删除操作都需要移动指针，从而在节点之间转移所有权。我们通过在类型的大多数操作中增加复杂性来简化偶尔的情况（节点的删除）。那是…悲哀的。
- en: On meaning and responsibility semantics
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于意义和责任语义
- en: Smart pointers are all about encoding meaning and responsibility in the type
    system. Simplifying user code is important, but it’s not the main point of these
    types. In a `ForwardList<T>`object, the real owner of the `T` objects is the `ForwardList<T>`
    object, and the `ForwardList<T>::Node<U>` objects are (from the `ForwardList<T>`
    object’s perspective) essentially a storage facility. Trying to change this can
    be made to work, but the ensuing complexity is an indication that something’s
    suspicious.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针都是关于在类型系统中编码意义和责任。简化用户代码很重要，但这不是这些类型的主要目的。在 `ForwardList<T>` 对象中，`T` 对象的真正所有者是
    `ForwardList<T>` 对象，而 `ForwardList<T>::Node<U>` 对象（从 `ForwardList<T>` 对象的角度来看）基本上是一个存储设施。尝试改变这一点可以使其工作，但随之而来的复杂性表明有些可疑。
- en: When writing a class, especially a container class, it’s essential that we have
    a clear view of the role intended for each type. We know that iterators are non-owning
    by nature (we could, however, envision `shared_ptr<T>` objects that co-own the
    pointee in some use cases). As far as containers and their underlying representation
    goes, the important point is that the responsibilities of each type need to be
    clear if our design is going to be manageable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写一个类，尤其是容器类时，我们必须清楚地了解每种类型的预期角色。我们知道迭代器本质上是非拥有的（然而，在某些用例中，我们可以设想`shared_ptr<T>`对象与指针共同拥有）。至于容器及其底层表示，重要的是每种类型的责任需要明确，如果我们的设计要可管理。
- en: Okay, so making a node responsible for its successor did not work. Would simply
    making the `head` member of a `ForwardList<T>` object responsible for the other
    nodes in the list make our lives better?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以让节点负责其后续节点并没有奏效。仅仅让`ForwardList<T>`对象的`head`成员负责列表中的其他节点，会让我们过得更好吗？
- en: 'Attempt: making the head pointer responsible for the other nodes'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试：让头指针负责其他节点
- en: As seen in the previous section, making each node responsible for its successor
    is semantically incorrect. It leads to complex, involved, and error-prone code,
    and the aspects of the implementation that are simplified by this transformation
    are mostly outweighed by the added complexity in other places.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，让每个节点负责其后续节点在语义上是不正确的。这会导致复杂、繁琐且容易出错的代码，而通过这种转换简化的实现方面通常被其他地方增加的复杂性所抵消。
- en: Maybe just making the `head` node a `std::unique_ptr<Node>` object with a custom
    deleter responsible for deleting the entire list would be beneficial? Well, we
    can assuredly try this approach.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 也许仅仅让`head`节点成为一个`std::unique_ptr<Node>`对象，并使用一个自定义删除器负责删除整个列表会更有益？嗯，我们可以肯定地尝试这种方法。
- en: 'As a synopsis, we would now get the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 作为摘要，我们现在会得到以下内容：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: // ...
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: void clear() noexcept {
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: void clear() noexcept {
- en: for (auto p = head.get(); p; ) { // <--
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: for (auto p = head.get(); p; ) { // <--
- en: auto q = p->next;
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: auto q = p->next;
- en: delete p;
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: delete p;
- en: p = q;
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: p = q;
- en: '}'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: nelems = 0;
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: nelems = 0;
- en: '}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: // ...
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: iterator begin() { return { head.get() }; } // <--
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: iterator begin() { return { head.get() }; } // <--
- en: const_iterator begin() const {
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: const_iterator begin() const {
- en: return { head.get() }; // <--
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: return { head.get() }; // <--
- en: '}'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: // ...
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: template <std::forward_iterator It>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: template <std::forward_iterator It>
- en: ForwardList(It b, It e) {
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ForwardList(It b, It e) {
- en: if(b == e) return;
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: if(b == e) return;
- en: head.reset(new Node{ *b }); // <--
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: head.reset(new Node{ *b }); // <--
- en: auto q = head.get(); // <--
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: auto q = head.get(); // <--
- en: ++nelems;
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ++nelems;
- en: for(++b; b != e; ++b) {
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: for(++b; b != e; ++b) {
- en: q->next = new Node{ *b };
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: q->next = new Node{ *b };
- en: q = q->next;
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: q = q->next;
- en: ++nelems;
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ++nelems;
- en: '}'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: // ...
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: void push_front(const_reference val) {
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: void push_front(const_reference val) {
- en: auto p = new Node{ val };
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = new Node{ val };
- en: p->next = head.get(); // <--
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: p->next = head.get(); // <--
- en: head.release(); // <--
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: head.release(); // <--
- en: head.reset(p); // <--
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: head.reset(p); // <--
- en: ++nelems;
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ++nelems;
- en: '}'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void push_front(T&& val) {
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: void push_front(T&& val) {
- en: auto p = new Node{ std::move(val) };
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = new Node{ std::move(val) };
- en: p->next = head.get(); // <--
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: p->next = head.get(); // <--
- en: head.release(); // <--
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: head.release(); // <--
- en: head.reset(p); // <--
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: head.reset(p); // <--
- en: ++nelems;
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ++nelems;
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
