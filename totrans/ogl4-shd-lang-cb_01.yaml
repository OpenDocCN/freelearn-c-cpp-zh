- en: Getting Started with GLSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a loading library to access the latest OpenGL functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GLM for mathematics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the GLSL and OpenGL version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling a shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking a shader program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading a shader binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading a SPIR-V shader program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **OpenGL Shading Language** (**GLSL**) Version 4 brings unprecedented power
    and flexibility to programmers interested in creating modern, interactive, and
    graphical programs. It allows us to harness the power of modern **Graphics Processing
    Units** (**GPUs**) in a straightforward way by providing a simple yet powerful
    language and API. Of course, the first step toward using GLSL is to create a program
    that utilizes the OpenGL API. GLSL programs don't stand on their own; they must
    be a part of a larger OpenGL program. In this chapter, we will provide some tips
    and techniques for getting started. We'll cover how to load, compile, link, and
    export a GLSL shader program. First, let's start with some background.
  prefs: []
  type: TYPE_NORMAL
- en: GLSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GLSL is a fundamental and integral part of the OpenGL API. Every program
    written using the OpenGL API will internally utilize one or several GLSL programs.
    These "mini-programs" are referred to as **shader programs**. A shader program
    usually consists of several components called **shaders**. Each shader executes
    within a different stage of the OpenGL pipeline. Each shader runs on the GPU,
    and as the name implies, they (typically) implement the algorithms related to
    lighting and shading effects. However, shaders are capable of doing much more
    than just shading. They can perform animation, generate additional geometry, tessellate
    geometry, or even perform generalized computation.
  prefs: []
  type: TYPE_NORMAL
- en: The field of study called **General Purpose Computing on Graphics Processing
    Units** (**GPGPU**) is concerned with the utilization of GPUs (often using specialized
    APIs such as CUDA or OpenCL) to perform general-purpose computations such as fluid
    dynamics, molecular dynamics, and cryptography. With compute shaders, introduced
    in OpenGL 4.3, we can now do GPGPU within OpenGL. See [Chapter 11](d67e01c8-8212-4d49-937f-6b1c62a57744.xhtml),
    *Using Compute Shaders*, for details about using compute shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Shader programs are designed for direct execution on the GPU and are executed
    in parallel. For example, a fragment shader might be executed once for every pixel,
    with each execution running simultaneously. The number of processors on the graphics
    card determines how many can be executed at one time. This makes shader programs
    incredibly efficient, and provides the programmer with a simple API for implementing
    highly-parallel computation.
  prefs: []
  type: TYPE_NORMAL
- en: Shader programs form essential parts of the *OpenGL pipeline*. Prior to OpenGL
    Version 2.0, the shading algorithm was *hardcoded* into the pipeline and had only
    limited configurability. When we wanted to implement custom effects, we used various
    tricks to force the fixed-function pipeline into being more flexible than it really
    was. With the advent of GLSL, we now have the ability to replace this hardcoded
    functionality with our own programs written in GLSL, thus giving us a great deal
    of additional flexibility and power. For more details on this programmable pipeline,
    see the introduction to [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml),
    *The Basics of GLSL Shaders*.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, OpenGL Version 3.2 and above not only provide this capability, but
    they require shader programs as part of every OpenGL program. The old fixed-function
    pipeline has been deprecated in favor of a new programmable pipeline, a key part
    of which is the shader program written in GLSL.
  prefs: []
  type: TYPE_NORMAL
- en: Profiles – core versus compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL Version 3.0 introduced a **deprecation model**, which allowed for the
    gradual removal of functions from the OpenGL specification. Functions or features
    can be marked as deprecated, meaning that they are expected to be removed from
    a future version of OpenGL. For example, immediate mode-rendering using `glBegin`/`glEnd`
    was marked as deprecated in version 3.0 and removed in version 3.1.
  prefs: []
  type: TYPE_NORMAL
- en: In order to maintain backwards compatibility, **compatibility profiles** were
    introduced with OpenGL 3.2\. A programmer that is writing code for a particular
    version of OpenGL (with older features removed) would use the **core profile**.
    Those who wanted to maintain compatibility with older functionality could use
    the compatibility profile.
  prefs: []
  type: TYPE_NORMAL
- en: It may be somewhat confusing that there is also the concept of a **forward-compatible** context,
    which is distinguished slightly from the concept of a core/compatibility profile.
    A context that is considered forward-compatible basically indicates that all deprecated
    functionality has been removed. In other words, if a context is forward-compatible,
    it only includes functions that are in the core, but not those that were marked
    as deprecated. Some Windows APIs provide the ability to select a forward-compatible
    status along with the profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for selecting a core or compatibility profile depend on the Windows
    system''s API. For example, with GLFW, one can select a forward-compatible, 4.6
    core profile using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All programs in this book are designed to be compatible with a forward-compatible
    OpenGL 4.6 core profile. However, many of them can be used with older versions
    or even compatibility profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Using a loading library to access the latest OpenGL functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenGL **application binary interface** (**ABI**) is frozen to OpenGL Version
    1.1 on Windows. Unfortunately for Windows developers, that means that it is not
    possible to link directly to functions that are provided in newer versions of
    OpenGL. Instead, one must gain access to the OpenGL functions by acquiring a function
    pointer at runtime. Getting access to the function pointers is not difficult,
    but requires somewhat tedious work, and has a tendency to clutter code. Additionally,
    Windows typically comes with a standard OpenGL `gl.h` file that also conforms
    to OpenGL 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenGL wiki states that Microsoft has no plans to ever update the `gl.h`
    and `opengl32.lib` that come with their compilers. Thankfully, others have provided
    libraries that manage all of this for us by transparently providing the needed
    function pointers, while also exposing the needed functionality in header files.
    Such a library is called an **OpenGL Loading Library** (or **OpenGL function loader**),
    and there are several such libraries available. One of the oldest is **OpenGL
    Extension Wrangler** (**GLEW**). However, there are a few issues with GLEW. First,
    it provides one large header file that includes everything from all versions of
    OpenGL. It might be preferable to have a more streamlined header file that only
    includes functions that we might use. Second, GLEW is distributed as a library
    that needs to be compiled separately and linked into our project. I find it preferable
    to have a loader that can be included into a project simply by adding the source
    files and compiling them directly into our executable, avoiding the need to support
    another link-time dependency.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll use a loader generator named GLAD, available from [https://github.com/Dav1dde/glad](https://github.com/Dav1dde/glad).
    This very flexible and efficient library can generate a header that includes only
    the needed functionality, and also generates just a few files (a source file and
    a few headers) that we can add directly into our project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use GLAD, you can either download and install it using `pip` (or from [https://github.com/Dav1dde/glad](https://github.com/Dav1dde/glad) ),
    or you can use the web service available here: [http://glad.dav1d.de/](http://glad.dav1d.de/).
    If you choose to install it, you'll need Python. The install is simple and described
    in detail on the GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to generate the header and source files for the OpenGL version
    and profile of your choice. For this example, we''ll generate files for an OpenGL
    4.6 core profile. We can then copy the files into our project and compile them
    directly alongside our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the header and source files, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous step will generate its output into a directory named `GL`. There
    will be two directories: `GL/include` and `GL/src`. You can move the GL directory
    into your project as is, or move the individual files into appropriate locations.
    Include `GL/src/glad.c` in your build, and put `GL/include` into your `include`
    path. Within your program code, include `glad/glad.h` whenever you need access
    to the OpenGL functions. Note that this fully replaces `gl.h`, so there is no
    need to include that.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to initialize the function pointers, you need to make sure to call
    a function that does so. The needed function is `gladLoadGL()`. Somewhere just
    after the GL context is created (typically in an initialization function), and
    before any OpenGL functions are called, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's all there is to it!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command in step 1 generates a few header files and a source file. The header
    provides prototypes for all of the selected OpenGL functions, redefines them as
    function pointers, and defines all of the OpenGL constants as well. The source
    file provides initialization code for the function pointers as well as some other
    utility functions. We can include the `glad/glad.h` header file wherever we need
    prototypes for OpenGL functions, so all function entry points are available at
    compile time. At runtime, the `gladLoadGL()` call will initialize all available
    function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Some function pointers may not be successfully initialized. This might happen
    if your driver does not support the requested OpenGL version. If that happens,
    calling the functions will fail.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line arguments available to GLAD are fully documented on the GitHub
    site and are available via `glad -h`. One can select any OpenGL version, select
    core/compatibility profiles, include desired extensions, and/or create debug callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GLAD provides a web service at [http://glad.dav1d.de/](http://glad.dav1d.de/)
    that makes it easy to generate the loader source and header files without installing
    GLAD. Simply visit the URL, select the desired configuration, and the loader files
    will be generated and downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ingredients/scenerunner.h` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GLEW, an older, popular loader and extension manager, available from [http://glew.sourceforge.net](http://glew.sourceforge.net)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GLM for mathematics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mathematics is the core to all of computer graphics. In earlier versions, OpenGL
    provided support for managing coordinate transformations and projections using
    the standard matrix stacks (`GL_MODELVIEW` and `GL_PROJECTION`). In modern versions
    of core OpenGL however, all of the functionality supporting the matrix stacks
    has been removed. Therefore, it is up to us to provide our own support for the
    usual transformation and projection matrices, and then pass them into our shaders.
    Of course, we could write our own matrix and vector classes to manage this, but
    some might prefer to use a ready-made, robust library.
  prefs: []
  type: TYPE_NORMAL
- en: One such library is **OpenGL Mathematics** (**GLM**), written by Christophe
    Riccio. Its design is based on the GLSL specification, so the syntax will be familiar
    to anyone using GLSL. Additionally, it provides extensions that include functionality
    similar to some of the much-missed OpenGL utility functions, such as `glOrtho`,
    `glRotate`, or `gluLookAt`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since GLM is a header-only library, the installation is simple. Download the
    latest GLM distribution from [http://glm.g-truc.net](http://glm.g-truc.net). Then,
    unzip the archive file, and copy the `glm` directory contained inside to anywhere
    in your compiler's include path.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the GLM libraries, include the core header file, and headers for any
    extensions. For this example, we''ll include the matrix transform extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The GLM classes are available in the `glm` namespace. The following is an example
    of how you might go about making use of some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GLM library is a header-only library. All of the implementation is included
    within the header files. It doesn't require separate compilation and you don't
    need to link your program to it. Just placing the header files in your include
    path is all that's required!
  prefs: []
  type: TYPE_NORMAL
- en: The previous example first creates `vec4` (a four-component vector), which represents
    a position. Then, it creates a 4 x 4 view matrix by using the `glm::lookAt` function.
    This works in a similar fashion to the old `gluLookAt` function. Here, we set
    the camera's location at (0, 0, 5), looking toward the origin, with the *up* direction
    in the direction of the positive *y* axis. We then go on to create the model matrix
    by first storing the identity matrix in the `model` variable (via the single-argument
    constructor), and multiplying it by a rotation matrix using the `glm::rotate`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The multiplication here is implicitly done by the `glm::rotate` function. It
    multiplies its first parameter by the rotation matrix (on the right) that is generated
    by the function. The second parameter is the angle of rotation (in degrees), and
    the third parameter is the axis of rotation. Since before this statement, `model`
    is the identity matrix, the net result is that `model` becomes a rotation matrix
    of 90 degrees around the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create our model-view matrix (`mv`) by multiplying the `view` and
    `model` variables, and then use the combined matrix to transform the position.
    Note that the multiplication operator has been overloaded to behave in the expected
    way.
  prefs: []
  type: TYPE_NORMAL
- en: The order is important here. Typically, the model matrix represents a transformation
    from object space to world space, and the view matrix is a transformation from
    world space to camera space. So to get a single matrix that transforms from object
    space to camera space, we want the model matrix to apply first. Therefore, the
    model matrix is multiplied on the right-hand side of the view matrix.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is *not recommended* to import all of the GLM namespaces using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will most likely cause a number of namespace clashes. Instead, it is preferable
    to import symbols one at a time with the `using` statements as needed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using the GLM types as input to OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GLM supports directly passing a GLM type to OpenGL using one of the OpenGL
    vector functions (with the `v` suffix). For example, to pass `mat4` named `proj`
    to OpenGL, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, rather than using the ampersand operator, we can use the `glm::value_ptr`
    function to get a pointer to the content of the GLM type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The latter version requires including the header file `glm/gtc/type_ptr.hpp`.
    The use of `value_ptr` is arguably cleaner, and works for any GLM type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt SDK includes many classes for vector/matrix mathematics, and is another
    good option if you're already using Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GLM website ([http://glm.g-truc.net](http://glm.g-truc.net)) has additional
    documentation and examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the GLSL and OpenGL version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to support a wide range of systems, it is essential to be able to
    query for the supported OpenGL and GLSL version of the current driver. It is quite
    simple to do so, and there are two main functions involved: `glGetString` and
    `glGetIntegerv`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that these functions must be called after the OpenGL context has been created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code will print the version information to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that there are two different ways to retrieve the OpenGL version: using
    `glGetString` and `glGetIntegerv`. The former can be useful for providing readable
    output, but may not be as convenient for programmatically checking the version
    because of the need to parse the string. The string provided by `glGetString(GL_VERSION)`
    should always begin with the major and minor versions separated by a dot, however,
    the minor version could be followed with a vendor-specific build number. Additionally,
    the rest of the string can contain additional vendor-specific information and
    may also include information about the selected profile (see the *Introduction*
    section of this chapter). It is important to note that the use of `glGetIntegerv`
    to query for version information requires OpenGL 3.0 or greater.'
  prefs: []
  type: TYPE_NORMAL
- en: The queries for `GL_VENDOR` and `GL_RENDERER` provide additional information
    about the OpenGL driver. The `glGetString(GL_VENDOR)` call returns the company
    responsible for the OpenGL implementation. The call to `glGetString(GL_RENDERER)`
    provides the name of the renderer, which is specific to a particular hardware
    platform (such as the ATI Radeon HD 5600 Series). Note that both of these do not
    vary from release to release, so they can be used to determine the current platform.
  prefs: []
  type: TYPE_NORMAL
- en: Of more importance to us in the context of this book is the call to `glGetString(GL_SHADING_LANGUAGE_VERSION)`, which
    provides the supported GLSL version number. This string should begin with the
    major and minor version numbers separated by a period, but similar to the `GL_VERSION`
    query, may include other vendor-specific information.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is often useful to query for the supported extensions of the current OpenGL
    implementation.  Extension names are indexed and can be individually queried by
    index. We use the `glGetStringi` variant for this. For example, to get the name
    of the extension stored at index `i`, we use `glGetStringi(GL_EXTENSIONS, i)`.
    To print a list of all extensions, we could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Compiling a shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we need to know how to compile our GLSL shaders. The GLSL compiler
    is built right into the OpenGL library, and shaders can only be compiled within
    the context of a running OpenGL program.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL 4.1 added the ability to save compiled shader programs to a file, enabling
    OpenGL programs to avoid the overhead of shader compilation by loading precompiled
    shader programs (see the *Saving and loading a shader binary* recipe). OpenGL
    4.6 added the ability to load shader programs compiled to (or written in) SPIR-V,
    an intermediate language for defining shaders. See the *Loading an SPIR-V shader* recipe
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiling a shader involves creating a shader object, providing the source
    code (as a string or set of strings) to the shader object, and asking the shader
    object to compile the code. The process is roughly represented by the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90cfaa2f-79fa-495e-ae00-ce05d1b0152a.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile a shader, we''ll need a basic example to work with. Let''s start
    with the following simple vertex shader. Save it in a file named `basic.vert.glsl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In case you're curious about what this code does, it works as a "pass-through"
    shader. It takes the `VertexPosition` and `VertexColor` input attributes and passes
    them to the fragment shader via the `gl_Position` and `Color` output variables.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll need to build a basic shell for an OpenGL program using a Window
    toolkit that supports OpenGL. Examples of cross-platform toolkits include GLFW,
    GLUT, FLTK, Qt, and wxWidgets. Throughout this text, I'll make the assumption
    that you can create a basic OpenGL program with your favorite toolkit. Virtually
    all toolkits have a hook for an initialization function, a resize callback (called
    upon resizing the window), and a drawing callback (called for each window refresh).
    For the purposes of this recipe, we need a program that creates and initializes
    an OpenGL context; it need not do anything other than display an empty OpenGL
    window. Note that you'll also need to load the OpenGL function pointers (refer
    to the *Using a loading library to access the latest OpenGL functionality* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, load the shader source code into `std::string` (or the char array).
    The following example assumes that the `shaderCode` variable is `std::string`
    containing the shader source code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile a shader, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the shader object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the source code into the shader object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the compilation status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to create the shader object using the `glCreateShader` function.
    The argument is the type of shader, and can be one of the following: `GL_VERTEX_SHADER`,
    `GL_FRAGMENT_SHADER`, `GL_GEOMETRY_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_TESS_CONTROL_SHADER`,
    or (as of version 4.3) `GL_COMPUTE_SHADER`. In this case, since we are compiling
    a vertex shader, we use `GL_VERTEX_SHADER`. This function returns the value used
    for referencing the vertex shader object, sometimes called the **object handle**.
    We store that value in the `vertShader` variable. If an error occurs while creating
    the shader object, this function will return 0, so we check for that and if it
    occurs, we print an appropriate message and terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: Following the creation of the shader object, we load the source code into the
    shader object using the `glShaderSource` function. This function is designed to
    accept an array of strings (as opposed to just a single one) in order to support
    the option of compiling multiple sources (files, strings) at once. So before we
    call `glShaderSource`, we place a pointer to our source code into an array named
    `sourceArray`.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `glShaderSource` is the handle to the shader object. The
    second is the number of source code strings that are contained in the array. The
    third argument is a pointer to an array of source code strings. The final argument
    is an array of `GLint` values that contain the length of each source code string
    in the previous argument.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, we pass a value of `NULL`, which indicates that each source
    code string is terminated by a null character. If our source code strings were
    not null terminated, then this argument must be a valid array. Note that once
    this function returns, the source code has been copied into the OpenGL internal
    memory, so the memory used to store the source code can be freed.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to compile the source code for the shader. We do this by simply
    calling `glCompileShader`, and passing the handle to the shader that is to be
    compiled. Of course, depending on the correctness of the source code, the compilation
    may fail, so the next step is to check whether the compilation was successful.
  prefs: []
  type: TYPE_NORMAL
- en: We can query for the compilation status by calling `glGetShaderiv`, which is
    a function for querying the attributes of a shader object. In this case, we are
    interested in the compilation status, so we use `GL_COMPILE_STATUS` as the second
    argument. The first argument is of course the handle to the shader object, and
    the third argument is a pointer to an integer where the status will be stored.
    The function provides a value of either `GL_TRUE` or `GL_FALSE` in the third argument,
    indicating whether the compilation was successful.
  prefs: []
  type: TYPE_NORMAL
- en: If the compile status is `GL_FALSE`, we can query for the shader log, which
    will provide additional details about the failure. We do so by first querying
    for the length of the log by calling `glGetShaderiv` again with a value of `GL_INFO_LOG_LENGTH`.
    This provides the length of the log in the `logLen` variable. Note that this includes
    the null termination character. We then allocate space for the log, and retrieve
    the log by calling `glGetShaderInfoLog`. The first parameter is the handle to
    the shader object, the second is the size of the character buffer for storing
    the log, the third argument is a pointer to an integer where the number of characters
    actually written (excluding the null terminator character) will be stored, and
    the fourth argument is a pointer to the character buffer for storing the log itself.
    Once the log is retrieved, we print it to `stderr` and free its memory space.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example only demonstrated how to compile a vertex shader. There
    are several other types of shaders, including fragment, geometry, and tessellation
    shaders. The technique for compiling is nearly identical for each shader type.
    The only significant difference is the argument to `glCreateShader`.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that shader compilation is only the first step.
    Similar to a language like C++, we need to link the program. While shader programs
    can consist of a single shader, for many use cases we have to compile two or more
    shaders, and then the shaders must be linked together into a shader program object.
    We'll see the steps involved in linking in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a shader object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shader objects can be deleted when no longer needed by calling `glDeleteShader`.
    This frees the memory used by the shader and invalidates its handle. Note that
    if a shader object is already attached to a program object (refer to the *Linking
    a shader program* recipe), it will not be immediately deleted, but flagged for
    deletion when it is detached from the program object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter01/scenebasic.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Linking a shader program* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking a shader program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have compiled our shaders and before we can actually install them into
    the OpenGL pipeline, we need to link them together into a shader program. Among
    other things, the linking step involves making the connections between input variables
    from one shader to output variables of another, and making the connections between
    the input/output variables of a shader to appropriate locations in the OpenGL
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linking involves steps that are similar to those involved in compiling a shader.
    We attach each shader object to a new shader program object and then tell the
    shader program object to link (making sure that the shader objects are compiled
    before linking):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c60725c9-ea4e-48c4-bc30-0ac5979bc266.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll assume that you've already compiled two shader objects
    whose handles are stored in the `vertShader` and `fragShader` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this and a few other recipes in this chapter, we''ll use the following
    source code for the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For the vertex shader, we'll use the source code from the previous recipe, *Compiling
    a shader*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our OpenGL initialization function, and after the compilation of shader
    objects referred to by `vertShader` and `fragShader`, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the program object using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach the shaders to the program object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Link the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the link status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If linking is successful, we can install the program into the OpenGL pipeline
    with `glUseProgram`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of whether the link was successful, it is a good idea to clean up
    our shader objects. Once the program is linked, they are not needed anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by calling `glCreateProgram` to create an empty program object. This
    function returns a handle to the program object, which we store in a variable
    named `programHandle`. If an error occurs with program creation, the function
    will return 0\. We check for that, and if it occurs, we print an error message
    and exit.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we attach each shader to the program object using `glAttachShader`. The
    first argument is the handle to the program object, and the second is the handle
    to the shader object to be attached.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we link the program by calling `glLinkProgram`, providing the handle to
    the program object as the only argument. As with compilation, we check for the
    success or failure of the link, with the subsequent query.
  prefs: []
  type: TYPE_NORMAL
- en: We check the status of the link by calling `glGetProgramiv`. Similar to `glGetShaderiv`,
    `glGetProgramiv` allows us to query various attributes of the shader program.
    In this case, we ask for the status of the link by providing `GL_LINK_STATUS`
    as the second argument. The status is returned in the location pointed to by the
    third argument, in this case named `status`.
  prefs: []
  type: TYPE_NORMAL
- en: The link status is either `GL_TRUE` or `GL_FALSE`, indicating the success or
    failure of the link. If the value of the status is `GL_FALSE`, we retrieve and
    display the program information log, which should contain additional information
    and error messages. The program log is retrieved by the call to `glGetProgramInfoLog`.
    The first argument is the handle to the program object, the second is the size
    of the buffer to contain the log, the third is a pointer to a `GLsizei` variable
    where the number of bytes written to the buffer will be stored (excluding the
    null terminator), and the fourth is a pointer to the buffer that will store the
    log. The buffer can be allocated based on the size returned by the call to `glGetProgramiv`
    with the `GL_INFO_LOG_LENGTH` parameter. The string that is provided in `log`
    will be properly null terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the link is successful, we install the program into the OpenGL pipeline
    by calling `glUseProgram`, providing the handle to the program as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to detach and delete the shader object, regardless of whether
    the link is successful. However, if the shader objects might be needed to link
    another program, you should detach it from this program and skip deletion until
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the simple fragment shader from this recipe and the vertex shader from
    the previous recipe compiled, linked, and installed into the OpenGL pipeline,
    we have a complete OpenGL pipeline and are ready to begin rendering. Drawing a
    triangle and supplying different values for the `Color` attribute yields an image
    of a multi-colored triangle where the vertices are red, green, and blue, and inside
    the triangle, the three colors are interpolated, causing a blending of colors
    throughout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/701126dc-268e-476c-8980-95009dce1ceb.png)'
  prefs: []
  type: TYPE_IMG
- en: For details on how to render the triangle, see [Chapter 2](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml),
    *Working with GLSL Programs*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use multiple shader programs within a single OpenGL program. They can
    be swapped in and out of the OpenGL pipeline by calling `glUseProgram` to select
    the desired program.
  prefs: []
  type: TYPE_NORMAL
- en: Shader input/output variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that the `Color` variable is used to send data from the
    vertex shader to the fragment shader. There is an output variable (`out vec3`)
    in the vertex shader and an input variable (`in vec3`) in the fragment shader,
    both with the same name. The value that the fragment shader receives is a value
    that is interpolated from the values of the corresponding output variable for
    each of the vertices (hence the blended colors in the earlier image). This interpolation
    is automatically done by hardware rasterizer before the execution of the fragment
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: When linking a shader program, OpenGL makes the connections between input and
    output variables in the vertex and fragment shaders (among other things). If a
    vertex shader's output variable has the same name and type as a fragment shader's
    input variable, OpenGL will automatically *link* them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to connect (link) variables that do not have the same name or
    type by using layout qualifiers. With a layout qualifier, we can specify the location
    for each variable specifically. For example, suppose that I used this set of output
    variables in my vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'I could use these variables in the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Despite the fact that these have different names (and for `Color`, types), they
    will be connected by the linker when the program is linked due to the fact that
    they are assigned the same locations. In this example, `VertColor` will be linked
    to `Color`, and `VertNormal` will be linked to `Normal`. This makes things more
    convenient. We're not required to use the same names for input/output variables,
    which gives us the flexibility to use names that might be more descriptive in
    each shader stage. More importantly, it is part of a larger framework, called
    **separate shader objects**. A full example of separate shader objects can be
    found in the *Using program pipelines* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this use of layout qualifiers to specify variable locations *is required*
    when compiling to SPIR-V (see the *Loading an SPIR-V shader program* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a shader program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a program is no longer needed, it can be deleted from OpenGL memory by calling
    `glDeleteProgram`, providing the program handle as the only argument. This invalidates
    the handle and frees the memory used by the program. Note that if the program
    object is currently in use, it will not be immediately deleted, but will be flagged
    for deletion when it is no longer in use.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the deletion of a shader program detaches the shader objects that were
    attached to the program but does not delete them unless those shader objects have
    already been flagged for deletion by a previous call to `glDeleteShader`. Therefore,
    as mentioned before, it is a good idea to detach and delete them immediately,
    as soon as the program is linked, to avoid accidentally leaking shader objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter01/scenebasic.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Compiling a shader* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using program pipelines* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Loading an SPIR-V shader program* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading a shader binary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL 4.1 introduced the `glGetProgramBinary` and `glProgramBinary` functions,
    which allow us to save and load compiled shader program binaries. Note that this
    functionality is still quite dependent on the OpenGL driver, and is not widely
    supported. For example, the Intel drivers on macOS do not support any binary formats.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Apple has deprecated OpenGL in macOS Mojave.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll outline the steps involved in saving and loading a compiled
    shader program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll begin assuming that a shader program has been successfully compiled, and
    its ID is in the `program` variable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To save the shader binary, first verify that the driver supports at least one
    shader binary format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, assuming at least one binary format is available, use `glGetProgramBinary`
    to retrieve the compiled shader code and write it to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To load and use a shader binary, retrieve the compiled program from storage,
    and use `glProgramBinary` to load it into the OpenGL context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drivers can support zero or more binary formats. The call to `glGetIntegerv`
    with the `GL_NUM_PROGRAM_BINARY_FORMATS` constant queries the driver to see how
    many are available. If this number is zero, the OpenGL driver does not support
    reading or writing shader binaries. If the value is one or more, we're good to
    go.
  prefs: []
  type: TYPE_NORMAL
- en: If at least one binary format is available, we can use `glGetProgramBinary`
    to retrieve the compiled shader code shown earlier. The function will write the
    binary format used to the location pointed to by the fourth parameter. In the
    preceding example, the data is stored in the vector named `buffer`.
  prefs: []
  type: TYPE_NORMAL
- en: To load the shader binary, we can use `glProgramBinary`. This function will
    load a previously saved shader binary. It requires the binary format to be passed
    as the second parameter. We can then check `GL_LINK_STATUS` to verify that it
    was loaded without error.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter01/scenebasic.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Loading an SPIR-V shader program* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading a SPIR-V shader program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Standard, Portable Intermediate Representation - V** (**SPIR-V**) is an intermediate
    language designed and standardized by the Khronos Group for shaders. It is intended
    to be a compiler target for a number of different languages. In the Vulkan API,
    shaders are required to be compiled to SPIR-V before they can be loaded. SPIR-V
    is intended to provide developers with the freedom to develop their shaders in
    any language they want (as long as it can be compiled to SPIR-V), and avoid the
    need for an OpenGL (or Vulkan) implementation to provide compilers for multiple
    languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Support for SPIR-V shader binaries was added to OpenGL core with version 4.6,
    but is also available via the `ARB_gl_spirv` extension for earlier OpenGL versions.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the Khronos Group provides a reference compiler for compiling GLSL
    to SPIR-V. It is available on GitHub at [https://github.com/KhronosGroup/glslang](https://github.com/KhronosGroup/glslang).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll go through the steps involved in precompiling a GLSL shader
    pair to SPIR-V, and then load it into an OpenGL program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download and compile the OpenGL shader validator from [https://github.com/KhronosGroup/glslang](https://github.com/KhronosGroup/glslang).
    Make sure that the `glslangValidator` binary is available in your `PATH` command
    line. In this example, we'll use the shader pair located in the `basic.vert.glsl`
    and `basic.frag.glsl` files.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you'll need to use explicit locations for all of your input/output
    variables in the shaders. For details, see the *Linking a shader program* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: All variables used for input/output interfaces (in/out variables) must have
    a location assigned.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by compiling the shader pair into SPIR-V using the `glslangValidator`
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If successful, this produces the `basic.vert.spv` and `basic.frag.spv` SPIR-V
    output files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load your SPIR-V shaders into an OpenGL program, use `glShaderBinary` and
    `glSpecializeShader`. With `glShaderBinary`, use `GL_SHADER_BINARY_FORMAT_SPIR_V`
    as the binary format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The process is nearly exactly the same for the fragment shader; just use `GL_FRAGMENT_SHADER`
    instead of `GL_VERTEX_SHADER` on the first line.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create the program object, attach the shaders, and link. This process
    is identical to that shown in the *Linking a shader program* recipe, so we won't
    reproduce it here.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `glShaderBinary` function provides us with the ability to load shaders that
    have been compiled to the SPIR-V format. This part is fairly straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The function that might be a bit more confusing is `glSpecializeShader`. We
    are required to call this function before the shader stage can be linked. This
    call is needed because a single SPIR-V file can have multiple entry points, and
    SPIR-V files can have *specialization constants*, which are parameters that the
    user can provide before it is compiled into native code.
  prefs: []
  type: TYPE_NORMAL
- en: At a minimum, we need to define the entry point for our shader. Since the source
    language is GLSL, the entry point is `main`. We specify the entry point(s) via
    the second argument. For GLSL, we simply use the `main` constant string. The last
    three parameters can be used to define the specialization constants. The first
    of the three is the number of constants, the next is a pointer to an array of
    constant indices, and the last is a pointer to an array of constant values.
  prefs: []
  type: TYPE_NORMAL
- en: The process of specializing an SPIR-V shader is similar to compiling a GLSL
    shader. Before calling `glSpecializeShader`, or if specialization fails, the compile
    status will be `GL_FALSE`. If specialization succeeds, the compile status will
    be `GL_TRUE`. As with GLSL shaders, we can query the shader info log to get detailed
    error messages (see the *Compiling a shader* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SPIR-V appears to be the future of shader programming in the Vulkan/OpenGL space.
    However, GLSL is not going away anytime soon. GLSL compilers still ship with OpenGL
    and there's currently no sign that they will be removed or deprecated. The OpenGL
    specification still considers GLSL to be the primary shading language.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you're interested in getting on board with SPIR-V early, or you
    have an interest in moving toward Vulkan, it might be valuable to you to start
    working with SPIR-V now in OpenGL. Fortunately, that's possible, at least in recent
    versions of OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: The future of SPIR-V is very bright. There is already a (mostly complete) compiler
    for HLSL that targets SPIR-V, and it is likely that other languages will be developed
    soon. It's an exciting time for shader programming!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter01/scenebasic.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Compiling a shader* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Linking a shader program* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
