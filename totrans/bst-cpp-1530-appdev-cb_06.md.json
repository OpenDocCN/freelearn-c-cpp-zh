["```cpp\n    #include <boost/thread/thread.hpp>\n\n    namespace detail {\n\n      template <class T>\n      struct task_wrapped {\n      private:\n        T task_unwrapped_;\n\n      public:\n        explicit task_wrapped(const T& task_unwrapped)\n          : task_unwrapped_(task_unwrapped)\n        {}\n\n        void operator()() const {\n          // resetting interruption\n          try {\n            boost::this_thread::interruption_point();\n          } catch(const boost::thread_interrupted&){}\n\n          try {\n            // Executing task\n            task_unwrapped_();\n          } catch (const std::exception& e) {\n            std::cerr<< \"Exception: \" << e.what() << '\\n';\n          } catch (const boost::thread_interrupted&) {\n            std::cerr<< \"Thread interrupted\\n\";\n          } catch (...) {\n            std::cerr<< \"Unknown exception\\n\";\n          }\n        }\n      };\n    ```", "```cpp\n      template <class T>\n      task_wrapped<T> make_task_wrapped(const T& task_unwrapped)\n      {\n        return task_wrapped<T>(task_unwrapped);\n      }\n\n    } // namespace detail\n    ```", "```cpp\n    #include <boost/asio/io_service.hpp>\n    class tasks_processor: private boost::noncopyable {\n      boost::asio::io_service         ios_;\n      boost::asio::io_service::work   work_;\n      tasks_processor()\n        : ios_()\n        , work_(ios_)\n      {}\n    public:\n      static tasks_processor& get();\n    ```", "```cpp\n      template <class T>\n      inline void push_task(const T& task_unwrapped) {\n        ios_.post(detail::make_task_wrapped(task_unwrapped));\n      }\n    ```", "```cpp\n      void start() {\n        ios_.run();\n      }\n      void stop() {\n        ios_.stop();\n      }\n    }; // tasks_processor\n    ```", "```cpp\n    int g_val = 0;\n    void func_test() {\n      ++ g_val;\n      if (g_val == 3) {\n        throw std::logic_error(\"Just checking\");\n      }\n\n      boost::this_thread::interruption_point();\n      if (g_val == 10) {\n        // Emulation of thread interruption.\n        // Will be caught and won't stop execution.\n        throw boost::thread_interrupted();\n      }\n      if (g_val == 90) {\n        tasks_processor::get().stop();\n      }\n    }\n    ```", "```cpp\n    int main () {\n      static const std::size_t tasks_count = 100;\n      // stop() is called at 90\n      BOOST_STATIC_ASSERT(tasks_count > 90);\n      for (std::size_t i =0; i < tasks_count; ++i) {\n        tasks_processor::get().push_task(&func_test);\n      }\n\n      // We can also use result of boost::bind call\n      // as a task\n      tasks_processor::get().push_task(\n        boost::bind(std::plus<int>(), 2, 2) // counting 2 + 2\n      );\n\n      // Processing was not started.\n      assert(g_val == 0);\n\n      // Will not throw, but blocks till\n      // one of the tasks it is owning\n      // calls stop().\n      tasks_processor::get().start();\n      assert(g_val== 90);\n    }\n    ```", "```cpp\n    try {\n      boost::this_thread::interruption_point();\n    } catch(const boost::thread_interrupted&){}\n```", "```cpp\n      typedef boost::asio::deadline_timer::time_type time_type;\n\n      template <class Functor>\n      void run_at(time_type time, const Functor& f) {\n        detail::make_timer_task(ios_, time, f)\n          .push_task();\n      }\n    ```", "```cpp\n      typedef boost::asio::deadline_timer::duration_type \n        duration_type;\n\n      template <class Functor>\n      void run_after(duration_type duration, const Functor& f) {\n        detail::make_timer_task(ios_, duration, f)\n          .push_task();\n      }\n    ```", "```cpp\n    namespace detail {\n      template <class Time, class Functor>\n      inline timer_task<Functor> make_timer_task(\n        boost::asio::io_service& ios,\n        const Time& duration_or_time,\n        const Functor& task_unwrapped)\n      {\n        return timer_task<Functor>(ios, duration_or_time,\n          task_unwrapped);\n      }\n    }\n    ```", "```cpp\n    #include <boost/asio/io_service.hpp>\n    #include <boost/asio/deadline_timer.hpp>\n    #include <boost/system/error_code.hpp>\n    #include <boost/make_shared.hpp>\n    #include <iostream>\n\n    namespace detail {\n\n      typedef boost::asio::deadline_timer::duration_type duration_type;\n\n      template <class Functor>\n      struct timer_task: public task_wrapped<Functor> {\n      private:\n        typedef task_wrapped<Functor> base_t;\n        boost::shared_ptr<boost::asio::deadline_timer> timer_;\n\n      public:\n        template <class Time>\n        explicit timer_task(\n          boost::asio::io_service& ios,\n          const Time& duration_or_time,\n          const Functor& task_unwrapped)\n            : base_t(task_unwrapped)\n            , timer_(boost::make_shared<boost::asio::deadline_timer>(\n              boost::ref(ios), duration_or_time\n          ))\n        {}\n\n        void push_task() const {\n          timer_->async_wait(*this);\n        }\n\n        void operator()(const boost::system::error_code& error) const {\n          if (!error) {\n            base_t::operator()();\n          } else {\n            std::cerr << error << '\\n';\n          }\n        }\n      };\n    } // namespace detail\n    ```", "```cpp\n    tcp_connection_ptr create_connection(const char* addr, \n      unsigned short port_num) \n    {\n      return tcp_connection_ptr(\n        ios_, \n        boost::asio::ip::tcp::endpoint(\n          boost::asio::ip::address_v4::from_string(addr), port_num\n        )\n      );\n    }\n    ```", "```cpp\n    #include <boost/asio/ip/tcp.hpp>\n    #include <boost/asio/placeholders.hpp>\n    #include <boost/asio/write.hpp>\n    #include <boost/asio/read.hpp>\n    #include <boost/shared_ptr.hpp>\n    #include <boost/function.hpp>\n    #include <boost/enable_shared_from_this.hpp>\n    ```", "```cpp\n    class tcp_connection_ptr {\n      boost::shared_ptr<boost::asio::ip::tcp::socket> socket_;\n\n    public:\n      explicit tcp_connection_ptr(\n        boost::shared_ptr<boost::asio::ip::tcp::socket> socket)\n        : socket_(socket) \n      {}\n\n      explicit tcp_connection_ptr(\n        boost::asio::io_service& ios, \n        const boost::asio::ip::tcp::endpoint& endpoint)\n        : socket_(boost::make_shared<boost::asio::ip::tcp::socket>(\n          boost::ref(ios)\n        ))\n      {\n        socket_->connect(endpoint);\n      }\n    ```", "```cpp\n      template <class Functor>\n      void async_read(\n        const boost::asio::mutable_buffers_1& buf, \n        const Functor& f, \n        std::size_t at_least_bytes) const \n      {\n        boost::asio::async_read(\n          *socket_, buf, boost::asio::transfer_at_least(\n            at_least_bytes\n          ), f\n        );\n      }\n    ```", "```cpp\n      template <class Functor>\n      void async_write(\n        const boost::asio::const_buffers_1& buf, const Functor& f) const \n      {\n        boost::asio::async_write(*socket_, buf, f);\n      }\n\n      template <class Functor>\n      void async_write(\n        const boost::asio::mutable_buffers_1& buf, const Functor& f) const \n      {\n        boost::asio::async_write(*socket_, buf, f);\n      }\n    ```", "```cpp\n      void shutdown() const {\n        socket_->shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n        socket_->close();\n      }\n    };\n    ```", "```cpp\n    const unsigned short g_port_num = 65001;\n\n    void send_auth_task() {\n      tcp_connection_ptr soc = tasks_processor::get().create_connection(\"127.0.0.1\", g_port_num);\n\n      boost::shared_ptr<std::string> data = boost::make_shared<std::string>(\"auth_name\");\n\n      soc.async_write( \n        boost::asio::buffer(*data),\n        boost::bind(\n          &recieve_auth_task, \n          boost::asio::placeholders::error,\n          soc, \n          data\n        )\n      );\n    }\n    ```", "```cpp\n    void recieve_auth_task(\n        const boost::system::error_code& err, \n        const tcp_connection_ptr& soc, \n        const boost::shared_ptr<std::string>& data) \n    {\n        if (err) {\n          std::cerr << \"recieve_auth_task: Client error on recieve: \" \n                    << err.message() << '\\n';\n          assert(false);\n        }\n\n      soc.async_read( \n        boost::asio::buffer(&(*data)[0], data->size()),\n        boost::bind(\n          &finsh_socket_auth_task, \n          boost::asio::placeholders::error,\n          boost::asio::placeholders::bytes_transferred,\n          soc, \n          data\n        ),\n        1\n      );\n    }\n    ```", "```cpp\n    bool g_authed = false;\n\n    void finsh_socket_auth_task(\n        const boost::system::error_code& err, \n        std::size_t bytes_transfered, \n        const tcp_connection_ptr& soc, \n        const boost::shared_ptr<std::string>& data) \n    {\n      if (err && err != boost::asio::error::eof) {\n        std::cerr << \"finsh_socket_auth_task: Client error \"\n                  << \"on recieve: \" << err.message() << '\\n';\n        assert(false);\n      }\n\n      if (bytes_transfered != 2) {\n        std::cerr << \"finsh_socket_auth_task: wrong bytes count\\n\";\n        assert(false);\n      }\n\n      data->resize(bytes_transfered);\n      if (*data != \"OK\") {\n        std::cerr << \"finsh_socket_auth_task: wrong response: \" << *data << '\\n';\n        assert(false);\n      }\n\n      g_authed = true;\n      soc.shutdown();\n      tasks_processor::get().stop();\n    }\n    ```", "```cpp\ntcp_connection_ptr soc = tasks_processor::get()\n    .create_connection(\"127.0.0.1\", g_port_num);\n\nboost::shared_ptr<std::string> data \n    = boost::make_shared<std::string>(\"auth_name\");\n\nsoc.async_write( \n  boost::asio::buffer(*data),\n  boost::bind(\n    &recieve_auth_task, \n    boost::asio::placeholders::error,\n    soc, \n    data\n  )\n);\n```", "```cpp\n      template <class Functor>\n      void add_listener(unsigned short port_num, const Functor& f) {\n        listeners_map_t::const_iterator it = listeners_.find(port_num);\n        if (it != listeners_.end()) {\n          throw std::logic_error(\n            \"Such listener for port '\" \n            + boost::lexical_cast<std::string>(port_num) \n            + \"' already created\"\n          );\n        }\n\n      listeners_[port_num] \n        = boost::make_shared<detail::tcp_listener>(\n            boost::ref(ios_), port_num, f\n        );\n        listeners_[port_num]->push_task(); // Start accepting\n      }\n    ```", "```cpp\n      typedef std::map<\n        unsigned short,\n        boost::shared_ptr<detail::tcp_listener>\n      > listeners_map_t;\n\n      listeners_map_t listeners_;\n    ```", "```cpp\n      void remove_listener(unsigned short port_num) {\n        listeners_map_t::iterator it = listeners_.find(port_num);\n        if (it == listeners_.end()) {\n          throw std::logic_error(\n            \"No listener for port '\" \n            + boost::lexical_cast<std::string>(port_num) \n            + \"' created\"\n          );\n        }\n\n        (*it).second->stop();\n        listeners_.erase(it);\n      }\n    ```", "```cpp\n    namespace detail {\n      class tcp_listener\n        : public boost::enable_shared_from_this<tcp_listener> \n      {\n        typedef boost::asio::ip::tcp::acceptor acceptor_t;\n        acceptor_t acceptor_;\n    ```", "```cpp\n        boost::function<void(tcp_connection_ptr)> func_;\n      public:\n        template <class Functor>\n        tcp_listener(\n          boost::asio::io_service& io_service,\n          unsigned short port,\n          const Functor& task_unwrapped)\n        : acceptor_(io_service,boost::asio::ip::tcp::endpoint(\n          boost::asio::ip::tcp::v4(), port\n        ))\n        , func_(task_unwrapped)\n        {}\n    ```", "```cpp\n        void push_task() {\n          if (!acceptor_.is_open()) {         return;\n          }\n\n          typedef boost::asio::ip::tcp::socket socket_t;\n          boost::shared_ptr<socket_t> socket \n            = boost::make_shared<socket_t>(\n              boost::ref(acceptor_.get_io_service())\n            );\n\n          acceptor_.async_accept(*socket, boost::bind(\n            &tcp_listener::handle_accept,\n            this->shared_from_this(),\n            tcp_connection_ptr(socket),\n            boost::asio::placeholders::error\n          ));\n        }\n    ```", "```cpp\n        void stop() {\n          acceptor_.close();\n        }\n    ```", "```cpp\n      private:\n        void handle_accept(\n          const tcp_connection_ptr& new_connection,\n          const boost::system::error_code& error)\n        {\n          push_task();\n\n          if (!error) {\n            make_task_wrapped(boost::bind(func_, new_connection))\n            (); // Run the task\n          } else {\n            std::cerr << error << '\\n';\n          }\n        }\n      }; // class tcp_listener\n    } // namespace detail\n    ```", "```cpp\n    boost::bind(\n      &tcp_listener::handle_accept,\n      this->shared_from_this(),\n      tcp_connection_ptr(socket),\n      boost::asio::placeholders::error\n    )\n```", "```cpp\nboost::asio::socket_base::reuse_address option(true);\nacceptor_.set_option(option);\n```", "```cpp\n#include <boost/thread/thread.hpp>\n\n// Default value will attempt to guess optimal count of threads\nvoid start_multiple(std::size_t threads_count = 0) {\n  if (!threads_count) {\n    threads_count = (std::max)(static_cast<int>(\n      boost::thread::hardware_concurrency()), 1\n    );\n  }\n\n  // one thread is the current thread\n  -- threads_count;\n  boost::thread_group tg;\n  for (std::size_t i = 0; i < threads_count; ++i) {\n    tg.create_thread(boost::bind(\n      &boost::asio::io_service::run, boost::ref(ios_)\n    ));\n  }\n\n  ios_.run();\n  tg.join_all();\n}\n```", "```cpp\n// global variables\ntasks_queue queue; \nsubsystem1 subs1;\nsubsystem2 subs2;\n\ntasks_queue& operator<< (tasks_queue&, data_packet& data) {\n  decoded_data d_decoded = decode_data(data);\n  compressed_data c_data = compress_data(d_decoded);\n  subs2.send_data(c_data);\n}\n\nvoid start_data_accepting() {\n  while (!subs1.is_stopped()) {\n    queue << subs1.get_data();\n  }\n}\n\n#include <boost/thread/thread.hpp>\nint main() {\n  // Getting data packets from first device\n  // and putting them to queue\n  boost::thread t(&start_data_accepting);\n  // Which data packet will be processed first in\n  // multi-threaded environment?\n  // packet #2 may be processed before packet #1,\n  // no guarantee that packets will be processed in\n  // order of their appearance\n  queue.run_multiple();\n  t.join();\n}\n```", "```cpp\n    workqueue decoding_queue, compressing_queue, sending_queue;\n    ```", "```cpp\n    #include <boost/bind.hpp>\n\n    void do_decode(const data_packet& packet);\n    void start_data_accepting() {\n      while (!subs1.is_stopped()) {\n        decoding_queue.push_task(boost::bind(\n          &do_decode, subs1.get_data()\n        ));\n      }\n    }\n\n    void do_compress(const decoded_data& packet);\n    void do_decode(const data_packet& packet) {\n      compressing_queue.push_task(boost::bind(\n        &do_compress, decode_data(packet)\n      ));\n    }\n\n    void do_compress(const decoded_data& packet) {\n      sending_queue.push_task(boost::bind(\n        &subsystem2::send_data,\n        boost::ref(subs2),\n        compress_data(packet)\n      ));\n    }\n    ```", "```cpp\n    // class work_queue from chapter 5\n    #include <deque>\n    #include <boost/function.hpp>\n    #include <boost/thread/mutex.hpp>\n    #include <boost/thread/locks.hpp>\n    #include <boost/thread/condition_variable.hpp>\n\n    class work_queue {\n    public:\n      typedef boost::function<void()> task_type;\n\n    private:\n      std::deque<task_type>   tasks_;\n      boost::mutex            mutex_;\n      boost::condition_variable cond_;\n      bool                    is_stopped_;\n\n    public:\n      work_queue() \n        : is_stopped_(false)\n      {}\n\n      void stop() {\n        boost::unique_lock<boost::mutex> lock(mutex_);\n        is_stopped_ = true;\n        lock.unlock();\n        cond_.notify_all();\n      }\n\n      void push_task(const task_type& task) {\n        boost::unique_lock<boost::mutex> lock(mutex_);\n        if (is_stopped_) {\n          return;\n        }\n        tasks_.push_back(task);\n        lock.unlock();\n        cond_.notify_one();\n      }\n\n      task_type pop_task() {\n        boost::unique_lock<boost::mutex> lock(mutex_);\n        while (tasks_.empty()) {\n          if (is_stopped_) {\n            return task_type();\n          }\n          cond_.wait(lock);\n        }\n\n        task_type ret = tasks_.front();\n        tasks_.pop_front();\n        return ret;\n      }\n    };\n    ```", "```cpp\n    void run_while_not_stopped(work_queue& queue) {\n      work_queue::task_type task;\n      while (task = queue.pop_task()) {\n        task();\n      }\n    }\n    ```", "```cpp\n    #include <boost/thread/thread.hpp>\n    int main() {\n      // Getting data packets from first device and putting them\n      // to queue\n      boost::thread t_data_accepting(&start_data_accepting);\n\n      boost::thread t_data_decoding(boost::bind(\n        &run_while_not_stopped, boost::ref(decoding_queue)\n      ));\n\n      boost::thread t_data_compressing(boost::bind(\n        &run_while_not_stopped, boost::ref(compressing_queue)\n      ));\n\n      boost::thread t_data_sending(boost::bind(\n        &run_while_not_stopped, boost::ref(sending_queue)\n      ));\n    ```", "```cpp\n      t_data_accepting.join();\n      decoding_queue.stop();\n      t_data_decoding.join();\n      compressing_queue.stop();\n      t_data_compressing.join();\n      sending_queue.stop();\n      t_data_sending.join();\n    ```", "```cpp\n#include <cstddef>\nstatic const std::size_t data_length = 10000;\n\n#include <boost/array.hpp>\nstruct vector_type : public boost::array<std::size_t, data_length> {\n  void* alignment;\n};\n\ntypedef boost::array<vector_type, 4> data_t;\nvoid fill_data(vector_type& data);\nvoid compute_send_data(data_t& data);\n\n#include <boost/thread/barrier.hpp>\nvoid runner(std::size_t thread_index, boost::barrier& data_barrier, data_t& data) {\n  for (std::size_t i = 0; i < 1000; ++ i) {\n    fill_data(data.at(thread_index));\n    data_barrier.wait();\n    if (!thread_index) {\n      compute_send_data(data);\n    }\n    data_barrier.wait();\n  }\n}\n\n#include <boost/thread/thread.hpp>\nint main() {\n  // Initing barriers\n  boost::barrier data_barrier(data_t::static_size);\n\n  // Initing data\n  data_t data;\n\n  // Run on 4 threads\n  boost::thread_group tg;\n  for (std::size_t i = 0; i < data_t::static_size; ++i) {\n    tg.create_thread(boost::bind(\n      &runner, \n      i, \n      boost::ref(data_barrier),\n      boost::ref(data)\n    ));\n  }\n\n  tg.join_all();\n}\n```", "```cpp\n    #include <boost/atomic.hpp>\n    typedef boost::atomic<unsigned int> atomic_count_t;\n    ```", "```cpp\n    void clever_runner(\n      std::size_t thread_index, \n      std::size_t iteration, \n      atomic_count_t& counter, \n      data_t& data) \n    {\n      fill_data(data.at(thread_index));\n\n      if (++counter == data_t::static_size) {\n        compute_send_data(data);\n        ++ iteration;\n\n        if (iteration == 1000) {\n          // exiting, because 1000 iterations are done\n          tasks_processor::get().stop();\n          return;\n        }\n\n        counter = 0;\n        for (std::size_t i = 0; i < data_t::static_size; ++ i) {\n          tasks_processor::get().push_task(boost::bind(\n            clever_runner, \n            i,\n            iteration, \n            boost::ref(counter), \n            boost::ref(data)\n          ));\n        }\n\n      }\n    }\n    ```", "```cpp\n    // Initing counter\n    atomic_count_t counter(0);\n\n    // Initing data\n    data_t data;\n\n    // Run on 4 threads\n    tasks_processor& tp = tasks_processor::get();\n    for (std::size_t i = 0; i < data_t::static_size; ++i) {\n      tp.push_task(boost::bind(\n        &clever_runner, \n        i, \n        0, // first run\n        boost::ref(counter),\n        boost::ref(data)\n      ));\n    }\n\n    tp.start();\n    ```", "```cpp\n    #include <boost/exception_ptr.hpp>\n    #include <boost/lexical_cast.hpp>\n    void func_test2(); // Forward declaration\n\n    void process_exception(const boost::exception_ptr& exc) {\n      try {\n        boost::rethrow_exception(exc);\n      } catch (const boost::bad_lexical_cast& /*e*/) {\n        std::cout << \"Lexical cast exception detected\\n\" << std::endl;\n\n        // Pushing another task to execute\n        tasks_processor::get().push_task(&func_test2);\n      } catch (...) {\n        std::cout << \"Can not handle such exceptions:\\n\" \n          << boost::current_exception_diagnostic_information() \n          << std::endl;\n\n        // Stopping\n        tasks_processor::get().stop();\n      }\n    }\n    ```", "```cpp\n    void func_test1() {\n      try {\n        boost::lexical_cast<int>(\"oops!\");\n      } catch (...) {\n        tasks_processor::get().push_task(boost::bind(\n          &process_exception, boost::current_exception()\n        ));\n      }\n    }\n\n    #include <stdexcept>\n    void func_test2() {\n      try {\n        // Some code goes here\n        BOOST_THROW_EXCEPTION(std::logic_error(\n          \"Some fatal logic error\"\n        ));\n        // Some code goes here\n      } catch (...) {\n        tasks_processor::get().push_task(boost::bind(\n          &process_exception, boost::current_exception()\n        ));\n      }\n    }\n    ```", "```cpp\n      tasks_processor::get().push_task(&func_test1);\n      tasks_processor::get().start();\n    ```", "```cpp\n    Lexical cast exception detected\n\n    Can not handle such exceptions:\n    ../../../BoostBook/Chapter6/exception_ptr/main.cpp(109): Throw in function void func_test2()\n    Dynamic exception type: boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::logic_error> >\n    std::exception::what: Some fatal logic error\n    ```", "```cpp\nvoid run_throw(boost::exception_ptr& ptr) {\n  try {\n    // A lot of code goes here\n  } catch (...) {\n    ptr = boost::current_exception();\n  }\n}\n\nint main () {\n  boost::exception_ptr ptr;\n  // Do some work in parallel\n  boost::thread t(boost::bind(\n    &run_throw, \n    boost::ref(ptr)\n  ));\n\n  // Some code goes here\n  // …\n\n  t.join();\n\n  // Checking for exception\n  if (ptr) {\n    // Exception occured in thread\n    boost::rethrow_exception(ptr);\n  }\n}\n```", "```cpp\n    #include <boost/asio/signal_set.hpp>\n    #include <boost/function.hpp>\n    ```", "```cpp\n    private:\n        boost::asio::signal_set signals_;\n        boost::function<void(int)>   users_signal_handler_;\n    ```", "```cpp\n        // private\n        void handle_signals(\n                const boost::system::error_code& error,\n                int signal_number)\n        {\n          if (error) {\n            std::cerr << \"Error in signal handling: \" \n              << error << '\\n';\n          } else {\n             // If signals occurs while there is no \n             // waiting handlers, signal notification\n             // is queued, so it won't be missed\n             // while we are running \n             // the users_signal_handler_\n             detail::make_task_wrapped(boost::bind(\n               boost::ref(users_signal_handler_), \n               signal_number\n             ))(); // make and run task_wrapped\n          }\n\n            signals_.async_wait(boost::bind(\n                &tasks_processor::handle_signals, this, _1, _2\n            ));\n        }\n    ```", "```cpp\n        tasks_processor()\n            : ios_()\n            , work_(ios_)\n            , signals_(ios_)\n        {}\n    ```", "```cpp\n        // This function is not threads safe!\n        // Must be called before all the 'start()' calls\n        // Function can be called only once\n        template <class Func>\n        void register_signals_handler(\n                const Func& f,\n                const std::vector<int>& signals_to_wait)\n        {\n            // Making sure that this is the first call\n            assert(!users_signal_handler_); \n\n            users_signal_handler_ = f;\n            std::for_each(\n                signals_to_wait.begin(),\n                signals_to_wait.end(),\n                boost::bind(\n                    &boost::asio::signal_set::add, &signals_, _1\n                )\n            );\n\n            signals_.async_wait(boost::bind(\n                &tasks_processor::handle_signals, this, _1, _2\n            ));\n        }\n    ```", "```cpp\n    void accept_3_signals_and_stop(int signal) {\n        static int signals_count = 0;\n        assert(signal == SIGINT);\n        ++ signals_count;\n        std::cout << \"Captured \" << signals_count << \" SIGINT\\n\"; \n        if (signals_count == 3) {\n            tasks_processor::get().stop();\n        }\n    }\n\n    int main () {\n        tasks_processor::get().register_signals_handler(\n            &accept_3_signals_and_stop,\n            std::vector<int>(1, SIGINT) // vector containing 1 element\n        );\n\n        tasks_processor::get().start();\n    }\n    ```", "```cpp\n    Captured 1 SIGINT\n    Captured 2 SIGINT\n    Captured 3 SIGINT\n    Press any key to continue . . .\n    ```"]