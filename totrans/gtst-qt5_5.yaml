- en: Managing Events, Custom Signals, and Slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the concept of events. To maintain a working state,
    messages are passed around from the windowing system to the application, and within
    the application itself. These messages may contain data that could be useful when
    delivered at some destination. The messages being talked about here are referred
    to as events in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag and drop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Qt, all events that occur are encapsulated in objects that inherit from the `QEvent` abstract
    class. An example of an event that has occurred is when a window has been resized
    or moved. The change in the state of the application will be noticed, and an appropriate
    `QEvent` object will be created to represent it.
  prefs: []
  type: TYPE_NORMAL
- en: The application event loop delivers this object to certain objects that inherit
    from `QObject`. This `QEvent` object is handled by means of a method call that
    will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of events. When a mouse is clicked, a `QMouseEvent`
    object is created to represent this. The object will contain additional information,
    such as the specific mouse button that was clicked, together with the location
    where that event occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All `QObjects` have an `event()` method that receives events. For `QWidgets`,
    this method will relay the event object to more specific event handlers. It is
    possible to redefine what an event handler should do by sub-classing the widget
    of interest and re-implementing that event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an application where we shall re-implement an event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder containing the `main.cpp`, `mainwindow.cpp`, and `mainwindow.h`
    files. The `mainwindow.h` file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have only sub-classed `QMainWindow`. A default constructor
    is declared and the event handler that we want to override, or re-implement, is
    the `moveEvent(QMoveEvent *event)` handler.
  prefs: []
  type: TYPE_NORMAL
- en: When a window is moved, the `event()` method of the `QMainWindow` object will
    be called. The event will be further encapsulated in a `QMoveEvent` object and
    forwarded to the `moveEvent()` event handler. Since we are interested in changing
    the behavior of the window when it is moved, we define our own `moveEvent()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `mainwindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the default constructor, the title of the window is set. The event object
    carries the coordinates of where the window currently is. Then `event->pos().x()`
    is called to obtain the *x *coordinate, likewise the *y* coordinate is obtained
    by calling `event->pos().y()`.
  prefs: []
  type: TYPE_NORMAL
- en: We convert `yCord` and `xCord` to text and store them in `text`. To access the
    status bar of the window, `statusBar()` is called and `text` is passed to the
    `showMessage()` method of the status bar object returned from the call to `statusBar()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.cpp` file will contain, as usual, the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the application. Note how the status bar changes when you move
    the application window.
  prefs: []
  type: TYPE_NORMAL
- en: Here are two screenshots showing how the status bar, located at the bottom of
    the window, changed when the window was moved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first state of the window is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcc84278-9975-45c0-ae38-1367731496d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the window was moved, it later showed the output as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94e24190-451d-4f1a-8523-1fd3787c6caf.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the very bottom of the window and how it has changed. Continuously move
    the window around and observe how the status bar changes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write another example to improve our understanding of Qt events.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the events generated by the windowing system, other events are generated
    by Qt. The example here will illustrate how to tell Qt to send our application
    timer-based events at certain intervals.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we shall start with the three main files we usually create, that is,
    `main.cpp`, `mainwindow.cpp`, and `mainwindow.h`. The project builds upon the
    previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `mainwindow.h` file, insert the following lines of codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To receive the timer events, we shall implement our own `timerEvent` method,
    which will be the destination of the event that is given off when a timer expires.
    That is the essence of adding the void `timerEvent(QTimerEvent *event)` signature.
    The `QLabel` `currentDateTimeLabel` instance will be used to display the date
    and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `mainwindow.cpp` file, the default constructor is defined by the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The title for the window is set. An instance of `QLabel` is created and the
    call to `setAlignment` ensures that its content says centered. Then `currentDateTimeLabel`
    is passed to the `setCentralWidget()` method. The `startTimer(1000)` method starts
    a timer and will trigger a `QTimerEvent` object every second, represented by `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: For each second, we now need to define what should happen by re-implementing
    the `timerEvent()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `mainwindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Every second, the `timerEvent()` will be called and passed an instance of `QTimerEvent`.
    The `Q_UNUSED (event)` is used to keep the compiler from complaining that `event()` is
    not being used in any way. A string representation of the current date and time
    is passed to `dateTime` and set as the text for the `currentDateTimeLabel` instance
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.cpp` file remains the same as before. As a reference it is presented
    once more, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the application, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c283a6a-eaf6-4f51-9148-708fddfb35ab.png)'
  prefs: []
  type: TYPE_IMG
- en: The application will initially show the text, current date, and time, but after
    a second it should change and display the updated time. Every second that passes
    will cause text to be updated too.
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we shall put together a simple application that can handle
    drag and drop operations from an external source into an application.
  prefs: []
  type: TYPE_NORMAL
- en: The application is a small text editor. When a text file is dropped into the
    text area, it will open and insert the contents of that text file into the text
    area. The status of the window will show the number of characters in the text
    area, which is an instance of a `QTextEdit`.
  prefs: []
  type: TYPE_NORMAL
- en: This example application also illustrates a very important point about events.
    To customize a widget, one has to change the existing behavior of that widget
    by overriding its event handlers. Signals and slots are not considered when trying
    to customize widgets (except events).
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin this project, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder with a name of your choice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `main.cpp`, `mainwindow.cpp`, `mainwindow.h`, `dragTextEdit.h`, and
    `dragTextEdit.cpp` files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `dragTextEdit.h` and `dragTextEdit.cpp` files will contain the definition
    of our custom widget. The `mainwindow.cpp` and `mainwindow.h` files will be used
    to construct the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the custom `QTextEdit` widget. Insert the following lines
    of code into `dragTextEdit.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DragTextEdit` custom widget, inherits from `QTextEdit`. The default constructor
    is declared. In order to accept a drop event, we need to override the following
    methods to ensure proper behavior, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the header file has been created, open the `dragTextEdit.cpp` file
    and add the definition of the default constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `#include` directive imports the header file, after which the default constructor
    is defined. In order for our widget to accept a drop event, we need to say so
    by calling the `setAcceptDrops(true)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have to add the definition of the methods we want to override. Add the
    following lines to `dragTextEdit.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These event handlers deal with the major steps involved when there is going
    to be a drop action. The  `acceptProposedAction()` method is called on the event
    object in the `dragEnterEvent()` and `dragMoveEvent()` methods. These events are
    called when the cursor in drag mode is on the boundary of the widget that calls
    the `setAcceptDrops()` method. If you refuse to call the `acceptProposedAction()`
    method, the drop behavior may misbehave.
  prefs: []
  type: TYPE_NORMAL
- en: The `dragMoveEvent()` event handler is called when the cursor is within the
    widget of interest. But to define what happens when the drop event happens we
    need to define the `dropEvent()` handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `dragTextEdit.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The mime data of the file, encapsulated within the event object, is obtained
    by calling `event->mimeData()`. If it contains text data, we extract the contents
    of the file and call the `setText()` method belonging to `QTextEdit`. This will
    populate the `DragTextEdit` instance with that text. Note the fact that we continue
    to call `event->acceptProposedAction()` to tell Qt that we have handled this event.
    If, on the other hand, `event->ignore()` is called, it is taken as an unwanted
    event or action and is, as such, propagated to a parent widget.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the implementation of custom `QTextEdit`. Now we need to create
    `mainwindow.h` and `mainwindow.cpp` that will construct the main application window
    and make use of `DragTextEdit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `mainwindow.h` file and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `QMainWindow`, `QLabel` class with the other usual classes are imported
    along with the `dragTextEdit.h` header file, which allows the inclusion of our
    custom class. A slot that will be called **anytime text** is added or removed
    from the `DragTextEdit` widget and is declared. Lastly, an instance of `DragTextEdit`
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and open the `mainwindow.cpp` file and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor,  `QWidget` and the `QVBoxLayout` objects are created to
    hold the main widget and layout. This widget will then be inserted with the call
    to `setCentralWdiget()`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of the  `DragTextEdit` custom class is created and passed to `slateDragTextEdit`.
    This widget is added to our main layout, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The status bar of the window is set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Anytime the `slateDragTextEdit` emits the `textChanged()` signal, a call to
    the `updateStatusBar()` slot will be called. In this slot, the characters within
    `slateDragTextEdit` will be extracted and counted. The status bar will thus be
    updated when a character is added to or removed from `slateDragTextEdit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.cpp` file will contain only the following few lines of code to instantiate
    the window and display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the project, you should have five (5) files in your folder. To
    compile the project, issue the following commands within the folder on the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to add `QT += widgets` to the generated `.pro` file. The `.pro`
    file should contain the header files and program files. It should look like the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue to issue the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A running program will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fff52ff4-47db-48f9-a15a-5483b1fbb4f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Since there are no characters when the program is executed, the status bar will
    read 0, as in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type some input into the text area and find out how, with every keystroke,
    the status bar is updated, as we have in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9eed95ff-fa3c-443f-8852-bd80c08131f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The example in this section illustrates how the text area can accept items
    external to the application. Drag and drop any  text (`.txt`) file, or any file
    containing text, onto the text area and see how its content is used to populate
    the textbox, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d887219-00d7-4797-aab9-a5177730da6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, the content of the `sometext.txt` file, which
    contains text, will be pasted into the text area as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2767e320-a8e6-4759-a354-a33fcb5ab6c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Experiment by removing the call to `acceptProposedAction()` and `accept()` and
    see how the drag and drop changes.
  prefs: []
  type: TYPE_NORMAL
- en: The last section of this chapter will touch on the creation of a custom signal.
  prefs: []
  type: TYPE_NORMAL
- en: Custom signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we saw how to use slots and create custom slots to implement
    some functionality in response to a signal being emitted. Now, in this section,
    we will look at how to create custom signals that can be emitted and connected
    to other slots.
  prefs: []
  type: TYPE_NORMAL
- en: To create a custom signal, one needs to declare a method signature and mark
    it as a signal with the aid of the `Q_OBJECT` macro. When declared, signals don't
    have a return type, but they can accept parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get our feet wet with a project. As usual, a new folder should be created
    with the three (3) files, namely, `main.cpp`, `mainwindow.cpp`, and `mainwindow.h`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we shall override `mousePressEvent` and emit a custom signal
    that will be connected to a slot to perform a number of updates on a window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `mainwindow.h` file, insert the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom signal here is declared with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When this signal is emitted, it will pass an instance of `QPoint` as an argument.
    If we didn't want our signal to pass any argument, it would have been written
    with as `void` `mouseMoved()`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom signals should return nothing. The signal will be emitted when we re-implement
    the `mousePressEvent()` handler.
  prefs: []
  type: TYPE_NORMAL
- en: The `void updateMousePosition(QPoint pos)`, slot will be connected to the custom
    signal. Its definition is found in `mainwindow.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: The member pointer, `mousePosition`, will display the coordinates of the mouse
    when it is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `mainwindow.cpp` file, we shall define three (3) methods. These are
    the default constructor, the slot `updateMousePosition()`, and the `mousePressEvent()
    override` methods, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `include` statement has to be at the very top of the file. In this `override` method,
    we obtain the coordinate where the mouse press event was generated by calling
    `event->pos()`.
  prefs: []
  type: TYPE_NORMAL
- en: The points `x` and `y` coordinates are obtained by calling `x()` and `y()`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `emit mouseMoved(event->pos())` line is used to emit the signal we declared
    in the header file. Furthermore, `event->pos()` will return a `QPoint` object,
    which conforms with the signature of the signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the slot is defined in the `mainwindow.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `QPoint` instance is received by the slot as a parameter. It's `x` and `y`
    coordinates are obtained by calling `point.x()` and `point.y()`, respectively.
    A `QString` instance `text` is used to concatenate the two values, `xCord` and
    `yCord`, into a longer string.
  prefs: []
  type: TYPE_NORMAL
- en: The `QLabel` instance, `mousePosition`, will be used to display this coordinate
    by calling its `setText()` method. Similarly, the status bar of the window will
    be set by calling `statusBar()->showMessage(text)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do the plumbing of connecting the custom signal to our slot, we need to
    define the default constructor. Add the following lines to `mainwindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Like we have been doing, the `windowCentralWidget` is used as the main widget
    in our application. `QLabel` is added to its layout, `innerLayout`. The status
    bar is given an initial value of `"Ready"`.
  prefs: []
  type: TYPE_NORMAL
- en: The `mouseMoved(QPoint)` signal is connected to the `updateMousePosition(QPoint)`
    slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.cpp` file, we shall instantiate our window and start the main
    event loop, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the executable, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1da79e9-cc58-4aff-b720-ea53646bf223.png)'
  prefs: []
  type: TYPE_IMG
- en: The status bar reads Ready, while the `QLabel` making up the main widget in
    the window reads Mouse Position. Now, click on any part within the window, and
    see the status bar and label change to display the coordinates of the mouse where
    the click was generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following screenshot as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51548fa3-126b-4072-8339-236bb3314c50.png)'
  prefs: []
  type: TYPE_IMG
- en: The location of the cursor is 145, 157, where 145 is on the *x* axi*s* and 157
    is on the *y* axis. When the cursor is moved, this value will not change. However,
    when the mouse is clicked, the `mouseMoved()` signal will be emitted along with
    the coordinates to update the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter shed more light on how to use events in Qt. We understood the different
    situations that call for the use of events instead of the signal-slot mechanism.
    The first examples touched on how to override and implement custom event handlers.
    The events we implemented captured the position of a window and also redefined
    what should happen every second in an example application.
  prefs: []
  type: TYPE_NORMAL
- en: With the aid of events, we also implemented a simple drop event in the drag
    and drop action, where a simple text editor was created to accept files that are
    dropped in the text area. Lastly, the chapter illustrated how to create a custom
    signal that is emitted when an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](bfdfd852-205f-4c4b-bb41-d798fdc865f7.xhtml), *Connecting Qt with
    Databases*, we will focus on the various ways to store data and retrieve it when
    building Qt applications.
  prefs: []
  type: TYPE_NORMAL
