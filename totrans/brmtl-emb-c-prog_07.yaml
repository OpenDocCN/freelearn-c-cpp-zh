- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The General-Purpose Input/Output (GPIO) Peripheral
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the **General-Purpose Input/Output** (**GPIO**)
    peripheral, an essential component in microcontrollers. This peripheral is crucial
    for interfacing with microcontrollers, making it fundamental to embedded systems
    development.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by exploring the organization of GPIO ports and pins, covering
    both the general-purpose and alternate functions of these pins. Next, we will
    examine the key registers associated with the GPIO peripheral in STM32 microcontrollers.
    Finally, we will apply this knowledge to develop input and output drivers using
    the detailed register information we learn in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the GPIO peripheral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STM32 GPIO registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing input and output drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use the GPIO peripheral to interface
    effectively with microcontrollers, which will enable you to handle various input
    and output tasks with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the GPIO peripheral
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we introduced the GPIO peripheral in [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039),
    this section will reiterate the key points to remember regarding GPIOs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microcontroller pins are grouped into ports. For instance, a microcontroller
    might have ports named **GPIOA**, **GPIOB**, and **GPIOC**. See *Figure 2**.10*
    in [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039). Each port is composed of individual
    pins, which are referred to by their port name, followed by their pin number.
    The following are examples of this naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: PA1 refers to port A, pin 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PD7 refers to port D, pin 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This naming convention helps in identifying and configuring specific pins for
    various functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STM32F411xC/E microcontroller series features six ports: **PORTA**, **PORTB**,
    **PORTC**, **PORTD**, **PORTE**, and **PORTH**. Each port is equipped with a comprehensive
    set of registers to manage configuration, data handling, and functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These ports offer a variety of features designed for versatility and performance.
    The features offered include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**I/O control**: They allow us to manage up to 16 input/output pins per port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output states**: Pins can be configured for push-pull or open-drain modes,
    with optional pull-up or pull-down resistors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOx_ODR` register when the pin is configured as a general-purpose output.
    For alternate function configurations, the associated peripheral drives the output
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed selection**: The operating speed for each I/O pin can be set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input states**: Pins can be configured as floating, pull-up, pull-down, or
    analog inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOx_IDR` register or an associated peripheral when configured for alternate
    function input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOx_LCKR` register can be used to lock the I/O configuration, preventing
    accidental changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alternate function selection**: Up to 16 alternate functions per I/O pin
    can be configured, providing flexibility in pin usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we shall explore some of the GPIO registers of the STM32F411
    microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32 GPIO registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the characteristics and functions of some of
    the common registers within the GPIO peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each GPIO port includes a set of 32-bit registers essential for configuration
    and control. The configuration registers comprise the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOx_MODER` (mode register)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOx_OTYPER` (output type register)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOx_OSPEEDR` (output speed register)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOx_PUPDR` (pull-up/pull-down register)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data registers include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOx_IDR` (input data register)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOx_ODR` (output data register)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOx_BSRR` (the bit-set/reset register) and `GPIOx_LCKR` (the locking register)
    are used to control pin states and access. Additionally, the alternate function
    selection registers, `GPIOx_AFRH` and `GPIOx_AFRL`, manage the alternate function
    assignments for the pins within the GPIO port.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the GPIO mode register.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO mode register (GPIOx_MODER)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GPIO port mode register (`GPIOx_MODER`) is an important register for configuring
    the mode of each pin in the GPIO port. This register allows us to set each pin
    in different modes, such as **input**, **output**, **alternate function**, or
    **analog**.
  prefs: []
  type: TYPE_NORMAL
- en: It is a 32-bit register divided into 16 pairs of bits. Each pair of bits corresponds
    to a specific pin in the GPIO port, allowing the individual configuration of each
    pin. See *Figure 2**.17* in [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039).
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible configurations for these bits are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**00**: Input mode (reset state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this mode, the pin is configured as an input, which can be used to read signals
    from external devices such as a push button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**01**: General-purpose output mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This mode configures the pin as an output, which can be used to drive external
    signals or components such as an LED.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**10**: Alternate function mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This mode sets the pin to an alternate function, allowing it to interface with
    various peripherals such as UART, SPI, or I2C.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**11**: Analog mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This mode configures the pin for analog input, which is useful for **analog-to-digital
    converter** (**ADC**) operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s see a practical example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider configuring a pin (e.g., **PA5**) on port A:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set **PA5** as a general-purpose output (**01**), we can follow these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the bit pair corresponding to **PA5 (MODER5[1:0])**; these are **bit11**
    and **bit10**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write **0** to **bit11** and **1** to **bit10**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To set **PA5** as an alternate function (**10**), we should write **1** to **bit11**
    and **0** to **bit10**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To set **PA5** as an analog input (**11**), we should write **1** to **bit11**
    and **1** to **bit10**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is all there is to know about the `GPIOx_MODER` register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to examine two other important registers: the output data register
    (`GPIOx_ODR`) and the input data register (`GPIOx_IDR`).'
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO output data register (GPIOx_ODR) and the GPIO input data register (GPIOx_IDR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GPIO output data register (`GPIOx_ODR`) and GPIO input data register (`GPIOx_IDR`)
    are essential for managing the data flow through the GPIO pins. These registers
    allow for reading the state of pins and setting the state of pins, enabling our
    microcontroller to interact with external devices effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOx_ODR` is a 32-bit register, but only the lower 16 bits are used to control
    the output state of the pins. Each bit in the register corresponds to a pin in
    the GPIO port.'
  prefs: []
  type: TYPE_NORMAL
- en: By writing to this register, we can set the logic level (high or low) of each
    pin configured as an output. *Figure 7**.1* shows the structure of the GPIO **output
    data register** (**ODR**) extracted from the reference manual.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: GPIO ODR](img/B21914_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: GPIO ODR'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing `bit5(ODR5)` sets **PA5** to a high state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing `bit5(ODR5)` sets **PA5** to a low state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How about the GPIO input* *data register?*'
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO input data register (`GPIOx_IDR`) is used to read the current state
    of the GPIO pins configured as inputs. By reading from this register, we can determine
    whether each input is at a high or low logic level.
  prefs: []
  type: TYPE_NORMAL
- en: It is a 32-bit register, but similar to the ODR, only the lower 16 bits are
    used to read the state of the pins. Each bit in the register corresponds to a
    pin in the GPIO port.
  prefs: []
  type: TYPE_NORMAL
- en: A bit value of **1** indicates that the corresponding pin is at a high logic
    level, while a bit value of **0** indicates that it is at a low logic level.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.2* shows the structure of the GPIO input data register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: GPIO input data register](img/B21914_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: GPIO input data register'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: If `bit5(IDR5)` reads **1**, **PA5** is at a high state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `bit5(IDR5)` reads **0**, **PA5** is at a low state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another commonly used register is the GPIO bit set/reset register (`GPIOx_BSRR`).
    Let’s examine this register in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO bit-set/reset register (GPIOx_BSRR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GPIO bit-set/reset register (`GPIOx_BSRR`) is a crucial register for controlling
    the state of GPIO pins. It provides atomic bitwise operations to set or reset
    individual bits, which ensures that no interrupts can disrupt the operation, maintaining
    data integrity during modifications.
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOx_BSRR` is a 32-bit register divided into two 16-bit sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bits 15:0 (BSy)**: These bits are used to set the corresponding GPIO pin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bits 31:16 (BRy)**: These bits are used to reset the corresponding GPIO pin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 7**.3* shows the structure of the GPIO **bit-set/reset** **register**
    (**BSRR**).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: BSRR](img/B21914_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: BSRR'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the bits in the register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bits 31:16 (BRy)**: Writing **1** to any of the upper 16 bits resets the
    corresponding pin to a low state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bits 15:0 (BSy)**: Writing **1** to any of the lower 16 bits sets the corresponding
    pin to a high state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let’s see how to set PA5 as high and low using the BSRR:'
  prefs: []
  type: TYPE_NORMAL
- en: To set PA5 as `GPIOA_BSRR` register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set PA5 as `GPIOA_BSRR` register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GPIO BSRR (`GPIOx_BSRR`) provides a robust mechanism for controlling the
    state of GPIO pins. By understanding its structure and functionality, we can perform
    efficient and atomic operations to set or reset individual pins.
  prefs: []
  type: TYPE_NORMAL
- en: Another pair of commonly used GPIO registers are the GPIO alternate function
    high and alternate function low registers. Let’s explore them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO alternate function registers (GPIOx_AFRL and GPIOx_AFRH)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GPIO **alternate function registers** (**AFRs**) are important for configuring
    the alternate functions of the GPIO pins in STM32 microcontrollers. These registers
    allow each pin to be assigned a specific peripheral function, enhancing the versatility
    and functionality of the microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each GPIO port has two AFRs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GPIOx_AFRL**: **Alternate function low register** (**AFRL**), for pins 0
    to 7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPIOx_AFRH**: **Alternate function high register** (**AFRH**), for pins 8
    to 15'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These registers enable the selection of alternate functions for each pin, facilitating
    the use of the pins for various peripheral interfaces such as UART, I2C, and SPI.
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOx_AFRL` is a 32-bit register, divided into eight 4-bit fields. Each 4-bit
    field corresponds to one pin in the range of pins 0 to 7 in the GPIO port.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOx_AFRH` is also a 32-bit register, divided into eight 4-bit fields. Here,
    each 4-bit field corresponds to one pin in the range of pins 8 to 15 in the GPIO
    port.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Alternate function low register](img/B21914_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Alternate function low register'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.4* illustrates the AFRL. To understand the various alternate functions
    each pin can assume based on the values of the corresponding 4-bit fields, we
    will refer to *Figure 7**.5* as our guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Alternate function selection](img/B21914_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Alternate function selection'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.5* shows a diagram with two multiplexers. The first multiplexer
    represents the selector for the AFRL, while the second represents the selector
    for the AFRH. This diagram is sourced from page 150 of the reference manual. It
    effectively demonstrates how to configure GPIO pins for alternate functions on
    STM32F411 microcontrollers using these registers.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down what we see.
  prefs: []
  type: TYPE_NORMAL
- en: 'For both `GPIOx_AFRL` and `GPIOx_AFRH`, the diagram provides a list of the
    possible alternate functions that can be selected for each pin. The alternate
    functions are designated by **AF0** through **AF15**, each associated with specific
    peripheral functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Alternate** **function description** | **Binary value** |'
  prefs: []
  type: TYPE_TB
- en: '| AF0: System functions | 0000 |'
  prefs: []
  type: TYPE_TB
- en: '| AF1: TIM1/TIM2 | 0001 |'
  prefs: []
  type: TYPE_TB
- en: '| AF2: TIM3/TIM4/TIM5 | 0010 |'
  prefs: []
  type: TYPE_TB
- en: '| AF3: TIM9/TIM10/TIM11 | 0011 |'
  prefs: []
  type: TYPE_TB
- en: '| AF4: I2C1/I2C2/I2C3 | 0100 |'
  prefs: []
  type: TYPE_TB
- en: '| AF5: SPI1/SPI2/SPI3/SPI4 | 0101 |'
  prefs: []
  type: TYPE_TB
- en: '| AF6: SPI3/SPI4/SPI5 | 0110 |'
  prefs: []
  type: TYPE_TB
- en: '| AF7: USART1/USART2 | 0111 |'
  prefs: []
  type: TYPE_TB
- en: '| AF8: USART6 | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| AF9: I2C2/I2C3 | 1001 |'
  prefs: []
  type: TYPE_TB
- en: '| AF10: OTG_FS | 1010 |'
  prefs: []
  type: TYPE_TB
- en: '| AF11: Reserved | 1011 |'
  prefs: []
  type: TYPE_TB
- en: '| AF12: SDIO | 1100 |'
  prefs: []
  type: TYPE_TB
- en: '| AF13: Reserved | 1101 |'
  prefs: []
  type: TYPE_TB
- en: '| AF14: Reserved | 1110 |'
  prefs: []
  type: TYPE_TB
- en: '| AF15: EVENTOUT | 1111 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.1: Alternate function selection'
  prefs: []
  type: TYPE_NORMAL
- en: For example, to configure pin 5 (`GPIOA_AFRL` register. We use `GPIOA_AFRL`
    because PA5 falls within the range of pins 0 to 7, which are managed by this register.
    To configure pin 10 (`GPIOA_AFRH` register. This is because `GPIOA_AFRH` register.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the characteristics and functions of several essential
    registers within the STM32 GPIO peripheral. We began with the GPIO mode register
    (`GPIOx_MODER`), which configures the mode of each GPIO pin, allowing settings
    for the input, output, alternate function, or analog mode. We then examined the
    GPIO output data register (`GPIOx_ODR`) and input data register (`GPIOx_IDR`),
    which manage the data flow through the GPIO pins by setting and reading pin states.
    Next, we looked at the GPIO BSRR (`GPIOx_BSRR`), which provides atomic operations
    for setting and resetting individual pin states. Finally, we covered the GPIO
    alternate function registers (`GPIOx_AFRL` and `GPIOx_AFRH`), which assign specific
    peripheral functions to each pin, enhancing the microcontroller’s versatility.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will develop GPIO drivers using the knowledge gained
    in this section. Specifically, we will focus on creating input and output drivers.
    We will explore the practical usage of the alternate function registers in the
    chapters dedicated to communication peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: Developing input and output drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will apply the knowledge gained about the GPIO peripheral
    to develop practical input and output drivers for STM32 microcontrollers. Since
    we are already familiar with developing the output driver to toggle an LED using
    the ODR, this section will focus on developing the output driver using the BSRR.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO output driver using the BSRR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by making a copy of our last project in our IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the last project and select **Copy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the **Project Explorer** pane and select **Paste**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the copied project to `GpioInput-Output`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will modularize our code by creating dedicated files for the GPIO
    driver code:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Src` folder in the project and select **New** | **File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `gpio.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we will create the corresponding header file:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Inc` folder in the project and select **New** | **File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `gpio.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our next task is to implement the driver code in the `gpio.c` file and declare
    the public functions in the `gpio.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Populate your `gpio.c` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the unique elements of the `gpio.c` file, focusing on the
    usage of the BSRR. We start with the header file inclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This line includes the `gpio.h` header file, which in turn includes `stm32fxx.h`
    to provide access to the register definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define all the macros we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break these macros down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOAEN`: This macro is used to enable the clock for GPIOA by writing to the
    `AHB1ENR` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LED_BS5`: This macro represents the bit-set operation for pin PA5\. Writing
    this value to the BSRR sets PA5 to high, turning the LED on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LED_BR5`: This macro represents the bit-reset operation for pin PA5\. Writing
    this value to the BSRR resets PA5 to low, turning the LED off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we implement the function for turning on the LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `GPIOA->BSRR |= LED_BS5` line uses the BSRR to set PA5 to high. Writing
    **1** to bit 5 of the BSRR sets the corresponding pin (PA5) to high, turning the
    LED on.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then we implement the function to turn the LED off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, `GPIOA->BSRR |= LED_BR5` uses the BSRR to reset PA5 to low. Writing
    **1** to bit 21 of the BSRR resets the corresponding pin (PA5) to low, turning
    the LED off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content for the `gpio.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down, starting with the header guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The header guards prevent multiple inclusions of the same header file, which
    can lead to errors and redundant declarations. The `#ifndef GPIO_H_` directive
    checks whether `GPIO_H_` has been defined yet. If it hasn’t, it proceeds to define
    `GPIO_H_` and includes the rest of the file. The `#endif` directive at the end
    closes the conditional directive that began with `#ifndef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `include` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This directive includes the `stm32f4xx.h` header file, which in turn includes
    the `stm32f411xe.h` header file, which provides definitions and declarations for
    all the registers in our microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then we have the function declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These declarations allow us to access the functions defined in the `gpio.c`
    file from other files, such as `main.c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our GPIO output driver for PA5 is complete, let’s test it by updating
    the `main.c` file to call the functions defined in the `gpio.c` file. Here is
    the updated `main.c` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code begins by including the `gpio.h` header file to access the GPIO functions
    defined in `gpio.c`. Within the `main` function, it first calls `led_init()` to
    initialize PA5 as an output pin. Then, it enters an infinite loop where it alternately
    turns the LED on and off by calling `led_on()` and `led_off()`, respectively.
    We use simple delay loops between these calls to keep the LED on and off for visible
    durations, effectively making the LED blink continuously.
  prefs: []
  type: TYPE_NORMAL
- en: Proceed to build the project and run it on the development board. You should
    see the green LED blinking.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we shall develop the GPIO input driver using **PC13**.
    We are using **PC13** because the blue push button of the development board is
    connected to this pin.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO input driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by analyzing the initialization function. Add this function to
    the `gpio.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This function enables clock access to GPIO port C and configures pin PC13 as
    an input pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GPIOC->MODER**: This is the GPIO port mode register for port C. Each pair
    of bits in this register corresponds to the mode configuration of a specific pin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clearing bits 26 and 27**: The bits corresponding to pin 13 in the **GPIOC->MODER**
    register are bits **26** and **27**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bitwise AND operator combined with the bitwise NOT operator (**&=~**) clears
    these bits, setting them to **00**. As we learned earlier, configuring these bits
    to **00** sets PC13 as an input pin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add the function for reading the state of the pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function reads the state of the button. The button is internally connected
    as an active-low input. This means the pin reads at a low logic level (0) when
    the button is pressed and a high logic level (1) when it is not pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '**GPIOC->IDR**: This is the input data register for GPIO port C. It holds the
    current state of all the pins in the port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise AND Operator (&)**: This checks whether the bit corresponding to
    **BTN_PIN** in the IDR register is set to high.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false`: If the bit is set, the button is not pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`true`: If the bit is not set, the button is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to access these new functions from other files, such as `main.c`,
    we need to add their prototypes to the `gpio.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to `gpio.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s test the new functions by updating the `main.c` file to call them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the updated `main.c` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool btn_state`: This variable holds the state of the push button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`led_init()`: Configures PA5 as an output pin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`button_init()`: Configures PC13 as an input pin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while(1){…}`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuously reads the state of the push button using `get_btn_state()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Turns the LED on if the button is pressed (`btn_state` is true)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Turns the LED off if the button is not pressed (`btn_state` is false)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the project and run it on the development board. You should see the green
    LED light up only when you press the push button.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the GPIO peripheral, a critical peripheral in microcontrollers
    that is essential for interfacing with various external components. We began by
    understanding the organization of GPIO ports and pins, covering both general-purpose
    and alternate functions.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F411 microcontroller series features several ports, each equipped with
    registers to manage configuration, data handling, and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced the registers associated with the GPIO peripheral, including configuration
    registers such as `GPIOx_MODER`, `GPIOx_OTYPER`, `GPIOx_OSPEEDR`, and `GPIOx_PUPDR`,
    as well as data registers such as `GPIOx_IDR` and `GPIOx_ODR`. We also covered
    `GPIOx_BSRR` (bit-set/reset register) for atomic pin state control and `GPIOx_LCKR`
    (locking register) for preventing accidental configuration changes. Additionally,
    we explored the GPIO alternate function registers (`GPIOx_AFRL` and `GPIOx_AFRH`),
    which enable versatile pin usage by assigning specific peripheral functions.
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, we developed both output and input drivers. We first created
    an output driver using the `GPIOx_BSRR` register to control the LED connected
    to pin PA5\. This involved setting up the necessary macros, implementing initialization
    and control functions, and testing the driver by making the LED blink. We then
    developed an input driver for reading the state of the push button connected to
    pin PC13\. This included configuring PC13 as an input pin, implementing a function
    to read the button state, and testing the driver by making the LED respond to
    button presses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we shall explore another important peripheral: the **system
    tick** (**SysTick**) timer.'
  prefs: []
  type: TYPE_NORMAL
