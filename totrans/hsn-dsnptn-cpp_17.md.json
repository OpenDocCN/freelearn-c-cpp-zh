["```cpp\nclass Base {\n  virtual void f() = 0;\n};\nclass Derived1 : public Base {\n  void f() override;\n};\nclass Derived2 : public Base {\n  void f() override;\n};\n```", "```cpp\nclass Base {\n  virtual void f(Base* p) = 0;\n};\nclass Derived1 : public Base {\n  void f(Base* p) override;\n};\nclass Derived2 : public Base {\n  void f(Base* p) override;\n};\n```", "```cpp\n// Example 01\nclass Pet {\n  public:\n  virtual ~Pet() {}\n  Pet(std::string_view color) : color_(color) {}\n  const std::string& color() const { return color_; }\n  private:\n  const std::string color_;\n};\nclass Cat : public Pet {\n  public:\n  Cat(std::string_view color) : Pet(color) {}\n};\nclass Dog : public Pet {\n  public:\n  Dog(std::string_view color) : Pet(color) {}\n};\n```", "```cpp\n// Example 01\nclass Cat;\nclass Dog;\nclass PetVisitor {\n  public:\n  virtual void visit(Cat* c) = 0;\n  virtual void visit(Dog* d) = 0;\n};\n```", "```cpp\n// Example 01\nclass Pet {\n  public:\n  virtual void accept(PetVisitor& v) = 0;\n  ...\n};\nclass Cat : public Pet {\n  public:\n  void accept(PetVisitor& v) override { v.visit(this); }\n  ...\n};\nclass Dog : public Pet {\n  public:\n  void accept(PetVisitor& v) override { v.visit(this); }\n  ...\n};\n```", "```cpp\n// Example 01\nclass FeedingVisitor : public PetVisitor {\n  public:\n  void visit(Cat* c) override {\n    std::cout << \"Feed tuna to the \" << c->color()\n              << \" cat\" << std::endl;\n  }\n  void visit(Dog* d) override {\n    std::cout << \"Feed steak to the \" << d->color()\n              << \" dog\" << std::endl;\n  }\n};\nclass PlayingVisitor : public PetVisitor {\n  public:\n  void visit(Cat* c) override {\n    std::cout << \"Play with a feather with the \"\n              << c->color() << \" cat\" << std::endl;\n  }\n  void visit(Dog* d) override {\n    std::cout << \"Play fetch with the \" << d->color()\n              << \" dog\" << std::endl;\n  }\n};\n```", "```cpp\n// Example 01\nCat c(\"orange\");\nFeedingVisitor fv;\nc.accept(fv); // Feed tuna to the orange cat\n```", "```cpp\n// Example 02\nstd::unique_ptr<Pet> p(new Cat(\"orange\"));\n...\nFeedingVisitor fv;\np->accept(fv);\n```", "```cpp\n// Example 03\nstd::unique_ptr<Pet> p(new Cat(\"orange\"));\nstd::unique_ptr<PetVisitor> v(new FeedingVisitor);\n...\np->accept(*v);\n```", "```cpp\n// Example 03\nvoid dispatch(Pet& p, PetVisitor& v) { p.accept(v); }\nstd::unique_ptr<Pet> p = ...;\nstd::unique_ptr<PetVisitor> v = ...;\ndispatch(*p, *v); // Double dispatch\n```", "```cpp\n// Example 04\nclass Pet {\n  public:\n  ..\n  void add_child(Pet* p) { children_.push_back(p); }\n  virtual void accept(PetVisitor& v, Pet* p = nullptr) = 0;\n  private:\n  std::vector<Pet*> children_;\n};\n```", "```cpp\n// Example 04\nclass Cat : public Pet {\n  public:\n  Cat(std::string_view color) : Pet(color) {}\n  void accept(PetVisitor& v, Pet* p = nullptr) override {\n    v.visit(this, p);\n  }\n};\nclass Dog : public Pet {\n  public:\n  Dog(std::string_view color) : Pet(color) {}\n  void accept(PetVisitor& v, Pet* p = nullptr) override {\n    v.visit(this, p);\n  }\n};\n```", "```cpp\n// Example 04\nclass BirthVisitor : public PetVisitor {\n  public:\n  void visit(Cat* c, Pet* p) override {\n    assert(dynamic_cast<Cat*>(p));\n    c->add_child(p);\n  }\n  void visit(Dog* d, Pet* p) override {\n    assert(dynamic_cast<Dog*>(p));\n    d->add_child(p);\n  }\n};\n```", "```cpp\nPet* parent; // A cat\nBirthVisitor bv;\nPet* child(new Cat(\"calico\"));\nparent->accept(bv, child);\n```", "```cpp\n// Example 04\nclass FamilyTreeVisitor : public PetVisitor {\n  public:\n  void visit(Cat* c, Pet*) override {\n    std::cout << \"Kittens: \";\n    for (auto k : c->children_) {\n      std::cout << k->color() << \" \";\n    }\n    std::cout << std::endl;\n  }\n  void visit(Dog* d, Pet*) override {\n    std::cout << \"Puppies: \";\n    for (auto p : d->children_) {\n      std::cout << p->color() << \" \";\n    }\n    std::cout << std::endl;\n  }\n};\n```", "```cpp\nclass Pet {\n  ...\n  friend class FamilyTreeVisitor;\n};\n```", "```cpp\nPet* parent; // A cat\n...\namilyTreeVisitor tv;\nparent->accept(tv); // Prints kitten colors\n```", "```cpp\n// Example 05\nclass FamilyTreeVisitor : public PetVisitor {\n  public:\n  FamilyTreeVisitor() : child_count_(0) {}\n  void reset() { child_count_ = 0; }\n  size_t child_count() const { return child_count_; }\n  void visit(Cat* c, Pet*) override {\n    visit_impl(c, \"Kittens: \");\n  }\n  void visit(Dog* d, Pet*) override {\n    visit_impl(d, \"Puppies: \");\n  }\n  private:\n  template <typename T>\n  void visit_impl(T* t, const char* s) {\n    std::cout << s;\n    for (auto p : t->children_) {\n      std::cout << p->color() << \" \";\n        ++child_count_;\n      }\n      std::cout << std::endl;\n  }\n  size_t child_count_;\n};\nFamilyTreeVisitor tv;\nparent->accept(tv);\nstd::cout << tv.child_count() << \" kittens total\"\n          << std::endl;\n```", "```cpp\n// Example 06\nclass Shelter {\n  public:\n  void add(Pet* p) {\n    pets_.emplace_back(p);\n  }\n  void accept(PetVisitor& v) {\n    for (auto& p : pets_) {\n      p->accept(v);\n    }\n  }\n  private:\n  std::vector<std::unique_ptr<Pet>> pets_;\n};\n```", "```cpp\n// Example 07\nclass Family {\n  public:\n  Family(const char* cat_color, const char* dog_color) :\n  cat_(cat_color), dog_(dog_color) {}\n  void accept(PetVisitor& v) {\n    cat_.accept(v);\n    dog_.accept(v);\n  }\n  private: // Other family members not shown for brevity\n  Cat cat_;\n  Dog dog_;\n};\n```", "```cpp\n// Example 08\nclass Geometry {\n  public:\n  virtual ~Geometry() {}\n};\nclass Point : public Geometry {\n  public:\n  Point() = default;\n  Point(double x, double y) : x_(x), y_(y) {}\n  private:\n  double x_ {};\n  double y_ {};\n};\nclass Circle : public Geometry {\n  public:\n  Circle() = default;\n  Circle(Point c, double r) : c_(c), r_(r) {}\n  private:\n  Point c_;\n  double r_ {};\n};\nclass Line : public Geometry {\n  public:\n  Line() = default;\n  Line(Point p1, Point p2) : p1_(p1), p2_(p2) {}\n  private:\n  Point p1_;\n  Point p2_;\n};\n```", "```cpp\n// Example 08\nclass Visitor {\npublic:\n  virtual void visit(double& x) = 0;\n  virtual void visit(Point& p) = 0;\n  virtual void visit(Circle& c) = 0;\n  virtual void visit(Line& l) = 0;\n};\n```", "```cpp\n// Example 08\nclass Geometry {\n  public:\n  virtual ~Geometry() {}\n  virtual void accept(Visitor& v) = 0;\n};\n```", "```cpp\n// Example 08\nvoid Point::accept(Visitor& v) {\n  v.visit(x_); // double\n  v.visit(y_); // double\n}\nvoid Circle::accept(Visitor& v) {\n  v.visit(c_); // Point\n  v.visit(r_); // double\n}\nvoid Point::accept(Visitor& v) {\n  v.visit(p1_); // Point\n  v.visit(p2_); // Point\n}\n```", "```cpp\n// Example 08\nclass StringSerializeVisitor : public Visitor {\npublic:\n  void visit(double& x) override { S << x << \" \"; }\n  void visit(Point& p) override { p.accept(*this); }\n  void visit(Circle& c) override { c.accept(*this); }\n  void visit(Line& l) override { l.accept(*this); }\n  std::string str() const { return S.str(); }\n  private:\n  std::stringstream S;\n};\n```", "```cpp\n// Example 08\nLine l(...);\nCircle c(...);\nStringSerializeVisitor serializer;\nserializer.visit(l);\nserializer.visit(c);\nstd::string s(serializer.str());\n```", "```cpp\n// Example 08\nclass StringDeserializeVisitor : public Visitor {\n  public:\n  StringDeserializeVisitor(const std::string& s) {\n    S.str(s);\n  }\n  void visit(double& x) override { S >> x; }\n  void visit(Point& p) override { p.accept(*this); }\n  void visit(Circle& c) override { c.accept(*this); }\n  void visit(Line& l) override { l.accept(*this); }\n  private:\n  std::stringstream S;\n};\n```", "```cpp\n// Example 08\nLine l1;\nCircle c1;\n// s is the string from a serializer\nStringDeserializeVisitor deserializer(s);\ndeserializer.visit(l1); // Restored Line l\ndeserializer.visit(c1); // Restored Circle c\n```", "```cpp\n// Example 09\nclass Intersection : public Geometry {\n  public:\n  Intersection() = default;\n  Intersection(Geometry* g1, Geometry* g2) :\n    g1_(g1), g2_(g2) {}\n  void accept(Visitor& v) override {\n    g1_->accept(v);\n    g2_->accept(v);\n  }\n  private:\n  std::unique_ptr<Geometry> g1_;\n  std::unique_ptr<Geometry> g2_;\n};\n```", "```cpp\n// Example 09\nclass Geometry {\n  public:\n  enum type_tag {POINT = 100, CIRCLE, LINE, INTERSECTION};\n  virtual type_tag tag() const = 0;\n};\nclass Visitor {\n  public:\n  static Geometry* make_geometry(Geometry::type_tag tag);\n  virtual void visit(Geometry::type_tag& tag) = 0;\n  ...\n};\n```", "```cpp\n// Example 09\nclass Point : public Geometry {\n  public:\n  ...\n  type_tag tag() const override { return POINT; }\n};\n```", "```cpp\n// Example 09\nGeometry* Visitor::make_geometry(Geometry::type_tag tag) {\n  switch (tag) {\n    case Geometry::POINT: return new Point;\n    case Geometry::CIRCLE: return new Circle;\n    case Geometry::LINE: return new Line;\n    case Geometry::INTERSECTION: return new Intersection;\n  }\n}\n```", "```cpp\n// Example 09\nclass Intersection : public Geometry {\n  public:\n  void accept(Visitor& v) override {\n    Geometry::type_tag tag;\n    if (g1_) tag = g1_->tag();\n    v.visit(tag);\n    if (!g1_) g1_.reset(Visitor::make_geometry(tag));\n    g1_->accept(v);\n    if (g2_) tag = g2_->tag();\n    v.visit(tag);\n    if (!g2_) g2_.reset(Visitor::make_geometry(tag));\n    g2_->accept(v);\n  }\n  ...\n};\n```", "```cpp\n// Example 09\nclass StringSerializeVisitor : public Visitor {\n  public:\n  void visit(Geometry::type_tag& tag) override {\n    S << size_t(tag) << \" \";\n  }\n  ...\n};\n```", "```cpp\n// Example 09\nclass StringDeserializeVisitor : public Visitor {\n  public:\n  void visit(Geometry::type_tag& tag) override {\n    size_t t;\n    S >> t;\n    tag = Geometry::type_tag(t);\n  }\n  ...\n};\n```", "```cpp\n// Example 10\nclass Pet {\n  public:\n  virtual ~Pet() {}\n  virtual void accept(PetVisitor& v) = 0;\n  ...\n};\n```", "```cpp\n// Example 10\nclass PetVisitor {\n  public:\n  virtual ~PetVisitor() {}\n};\n```", "```cpp\n// Example 10\nclass Cat;\nclass CatVisitor {\n  public:\n  virtual void visit(Cat* c) = 0;\n};\nclass Cat : public Pet {\n  public:\n  Cat(std::string_view color) : Pet(color) {}\n  void accept(PetVisitor& v) override {\n    if (CatVisitor* cv = dynamic_cast<CatVisitor*>(&v)) {\n      cv->visit(this);\n    } else { // Handle error\n      assert(false);\n    }\n  }\n};\n```", "```cpp\n// Example 10\nclass FeedingVisitor : public PetVisitor,\n                       public CatVisitor,\n                       public DogVisitor {\n  public:\n  void visit(Cat* c) override {\n    std::cout << \"Feed tuna to the \" << c->color()\n              << \" cat\" << std::endl;\n  }\n  void visit(Dog* d) override {\n    std::cout << \"Feed steak to the \" << d->color()\n              << \" dog\" << std::endl;\n  }\n};\n```", "```cpp\n// Example 10\nclass BathingVisitor : public PetVisitor,\n                       public DogVisitor\n                       { // But no CatVisitor\n  public:\n  void visit(Dog* d) override {\n    std::cout << \"Wash the \" << d->color()\n              << \" dog\" << std::endl;\n  }\n  // No visit(Cat*) here!\n};\n```", "```cpp\n// Example 10\nstd::unique_ptr<Pet> c(new Cat(\"orange\"));\nstd::unique_ptr<Pet> d(new Dog(\"brown\"));\nFeedingVisitor fv;\nc->accept(fv);\nd->accept(fv);\nBathingVisitor bv;\n//c->accept(bv); // Error\nd->accept(bv);\n```", "```cpp\nclass Cat : public Pet {\n  void accept(PetVisitor& v) override { v.visit(this); }\n};\n```", "```cpp\n// Example 11\nclass Pet { // Same as before\n  public:\n  virtual ~Pet() {}\n  Pet(std::string_view color) : color_(color) {}\n  const std::string& color() const { return color_; }\n  virtual void accept(PetVisitor& v) = 0;\n  private:\n  std::string color_;\n};\ntemplate <typename Derived>\nclass Visitable : public Pet {\n  public:\n  using Pet::Pet;\n  void accept(PetVisitor& v) override {\n    v.visit(static_cast<Derived*>(this));\n  }\n};\n```", "```cpp\n// Example 11\nclass Cat : public Visitable<Cat> {\n  using Visitable<Cat>::Visitable;\n};\nclass Dog : public Visitable<Dog> {\n  using Visitable<Dog>::Visitable;\n};\n```", "```cpp\n// Example 12\ntemplate <typename ... Types> class Visitor;\ntemplate <typename T> class Visitor<T> {\n  public:\n  virtual void visit(T* t) = 0;\n};\ntemplate <typename T, typename ... Types>\nclass Visitor<T, Types ...> : public Visitor<Types ...> {\n  public:\n  using Visitor<Types ...>::visit;\n  virtual void visit(T* t) = 0;\n};\n```", "```cpp\n// Example 12\n```", "```cpp\nclass Cat;\nclass Dog;\nusing PetVisitor = Visitor<Cat, Dog>;\n```", "```cpp\ntemplate <typename Derived>\nclass Visitable : public Pet {...};\nclass Cat : public Visitable<Cat> {...};\n```", "```cpp\nclass SiameseCat : public Cat,\n                   public Visitable<SiameseCat> {...};\n```", "```cpp\nauto v(lambda_visitor<PetVisitor>(\n  [](Cat* c) { std::cout << \"Let the \" << c->color()\n                         << \" cat out\" << std::endl;\n  },\n  [](Dog* d) { std::cout << \"Take the \" << d->color()\n                         << \" dog for a walk\" << std::endl;\n  }\n));\npet->accept(v);\n```", "```cpp\nusing PetVisitor = Visitor<class Cat, class Dog>;\n```", "```cpp\n// Example 13\ntemplate <typename Base, typename...>\nclass LambdaVisitor;\n```", "```cpp\n// Example 13\ntemplate <typename Base, typename T1, typename F1>\nclass LambdaVisitor<Base, Visitor<T1>, F1> :\n  private F1, public Base\n{\n  public:\n  LambdaVisitor(F1&& f1) : F1(std::move(f1)) {}\n  LambdaVisitor(const F1& f1) : F1(f1) {}\n  using Base::visit;\n  void visit(T1* t) override { return F1::operator()(t); }\n};\n```", "```cpp\n// Example 13\ntemplate <typename Base,\n          typename T1, typename... T,\n          typename F1, typename... F>\nclass LambdaVisitor<Base, Visitor<T1, T...>, F1, F...> :\n  private F1,\n  public LambdaVisitor<Base, Visitor<T ...>, F ...>\n{\n  public:\n  LambdaVisitor(F1&& f1, F&& ... f) :\n    F1(std::move(f1)),\n    LambdaVisitor<Base, Visitor<T...>, F...>(\n      std::forward<F>(f)...)\n  {}\n  LambdaVisitor(const F1& f1, F&& ... f) :\n    F1(f1),\n    LambdaVisitor<Base, Visitor<T...>, F...>(\n      std::forward<F>(f) ...)\n  {}\n  using LambdaVisitor<Base, Visitor<T ...>, F ...>::visit;\n  void visit(T1* t) override { return F1::operator()(t); }\n};\n```", "```cpp\n// Example 13\ntemplate <typename Base, typename ... F>\nauto lambda_visitor(F&& ... f) {\n  return LambdaVisitor<Base, Base, F...>(\n    std::forward<F>(f) ...);\n}\n```", "```cpp\n// Example 13\nvoid walk(Pet& p) {\n  auto v(lambda_visitor<PetVisitor>(\n  [](Cat* c){std::cout << \"Let the \" << c->color()\n                         << \" cat out\" << std::endl;},\n  [](Dog* d){std::cout << \"Take the \" << d->color()\n                       << \" dog for a walk\" << std::endl;}\n  ));\n  p.accept(v);\n}\n```", "```cpp\n// Example 14\ntemplate <typename Base, typename F1, typename... F>\nclass LambdaVisitor<Base, std::tuple<F1, F...>> :\n  public F1, public LambdaVisitor<Base, std::tuple<F...>>;\n```", "```cpp\n// Example 10\nclass Cat : public Pet {\n  public:\n  void accept(PetVisitor& v) override {\n    if (CatVisitor* cv = dynamic_cast<CatVisitor*>(&v)) {\n      cv->visit(this);\n    } else { // Handle error\n      assert(false);\n    }\n  }\n};\n```", "```cpp\nclass CatVisitor {\n  public:\n  virtual void visit(Cat* c) = 0;\n};\n```", "```cpp\nclass PetVisitor {\n  public:\n  virtual ~PetVisitor() {}\n};\n```", "```cpp\n// Example 15\nclass VisitorBase {\n  public:\n  virtual ~VisitorBase() {}\n};\n```", "```cpp\n// Example 15\ntemplate <typename Visitable> class Visitor {\n  public:\n  virtual void visit(Visitable* p) = 0;\n};\n```", "```cpp\n// Example 15\nclass Pet {\n  ...\n  virtual void accept(VisitorBase& v) = 0;\n};\n```", "```cpp\n// Example 15\ntemplate <typename Visitable>\nclass PetVisitable : public Pet {\n  public:\n  using Pet::Pet;\n  void accept(VisitorBase& v) override {\n    if (Visitor<Visitable>* pv =\n        dynamic_cast<Visitor<Visitable>*>(&v)) {\n      pv->visit(static_cast<Visitable*>(this));\n    } else { // Handle error\n      assert(false);\n    }\n }\n};\n```", "```cpp\n// Example 15\nclass Cat : public PetVisitable<Cat> {\n  using PetVisitable<Cat>::PetVisitable;\n};\nclass Dog : public PetVisitable<Dog> {\n  using PetVisitable<Dog>::PetVisitable;\n};\n```", "```cpp\n// Example 15\nclass FeedingVisitor : public VisitorBase,\n                       public Visitor<Cat>,\n                       public Visitor<Dog>\n{\n  public:\n  void visit(Cat* c) override {\n    std::cout << \"Feed tuna to the \" << c->color()\n              << \" cat\" << std::endl;\n  }\n  void visit(Dog* d) override {\n    std::cout << \"Feed steak to the \" << d->color()\n              << \" dog\" << std::endl;\n  }\n};\n```", "```cpp\n// Example 16\ntemplate <typename Base, typename Visitable>\nclass VisitableBase : public Base {\n  public:\n  using Base::Base;\n  void accept(VisitorBase& vb) override {\n    if (Visitor<Visitable>* v = \n        dynamic_cast<Visitor<Visitable>*>(&vb)) {\n      v->visit(static_cast<Visitable*>(this));\n    } else { // Handle error\n      assert(false);\n    }\n  }\n};\n```", "```cpp\n// Example 16\ntemplate <typename Visitable>\nusing PetVisitable = VisitableBase<Pet, Visitable>;\n```", "```cpp\n// Example 17\ntemplate <typename ... V> struct Visitors;\ntemplate <typename V1>\nstruct Visitors<V1> : public Visitor<V1> {};\ntemplate <typename V1, typename ... V>\nstruct Visitors<V1, V ...> : public Visitor<V1>,\n                             public Visitors<V ...> {};\n```", "```cpp\n// Example 17\nclass FeedingVisitor :\n  public VisitorBase, public Visitors<Cat, Dog>\n{\n  ...\n};\n```", "```cpp\ntemplate <typename T1, typename T2> auto f(T1 t1, T2 t2);\n```", "```cpp\n// Example 18\nclass Pet {\n  std::string color_;\n  public:\n  Pet(std::string_view color) : color_(color) {}\n  const std::string& color() const { return color_; }\n  template <typename Visitable, typename Visitor>\n  static void accept(Visitable& p, Visitor& v) {\n    v.visit(p);\n  }\n};\n```", "```cpp\n// Example 18\nclass Cat : public Pet {\n  public:\n  using Pet::Pet;\n};\nclass Dog : public Pet {\n  public:\n  using Pet::Pet;\n};\n```", "```cpp\n// Example 18\nclass FeedingVisitor {\n  public:\n  void visit(Cat& c) {\n    std::cout << \"Feed tuna to the \" << c.color()\n              << \" cat\" << std::endl;\n  }\n  void visit(Dog& d) {\n    std::cout << \"Feed steak to the \" << d.color()\n              << \" dog\" << std::endl;\n  }\n};\n```", "```cpp\n// Example 18\nCat c(\"orange\");\nDog d(\"brown\");\nFeedingVisitor fv;\nPet::accept(c, fv);\nPet::accept(d, fv);\n```", "```cpp\n// Example 19\nclass Point {\n  public:\n  Point() = default;\n  Point(double x, double y) : x_(x), y_(y) {}\n  template <typename This, typename Visitor>\n  static void accept(This& t, Visitor& v) {\n    v.visit(t.x_);\n    v.visit(t.y_);\n  }\n  private:\n  double x_ {};\n  double y_ {};\n};\n```", "```cpp\n// Example 19\nclass Line {\n  public:\n  Line() = default;\n  Line(Point p1, Point p2) : p1_(p1), p2_(p2) {}\n  template <typename This, typename Visitor>\n  static void accept(This& t, Visitor& v) {\n    v.visit(t.p1_);\n    v.visit(t.p2_);\n  }\n  private:\n  Point p1_;\n  Point p2_;\n};\n```", "```cpp\n// Example 19\ntemplate <typename G1, typename G2>\nclass Intersection {\n  public:\n  Intersection() = default;\n  Intersection(G1 g1, G2 g2) : g1_(g1), g2_(g2) {}\n  template <typename This, typename Visitor>\n  static void accept(This& t, Visitor& v) {\n    v.visit(t.g1_);\n    v.visit(t.g2_);\n  }\n  private:\n  G1 g1_;\n  G2 g2_;\n};\n```", "```cpp\n// Example 19\nclass BinarySerializeVisitor {\n  public:\n  BinarySerializeVisitor(char* buffer, size_t size) :\n    buf_(buffer), size_(size) {}\n  void visit(double x) {\n    if (size_ < sizeof(x))\n      throw std::runtime_error(\"Buffer overflow\");\n    memcpy(buf_, &x, sizeof(x));\n    buf_ += sizeof(x);\n    size_ -= sizeof(x);\n  }\n  template <typename T> void visit(const T& t) {\n    T::accept(t, *this);\n  }\n  private:\n  char* buf_;\n  size_t size_;\n};\n```", "```cpp\n// Example 19\nclass BinaryDeserializeVisitor {\n  public:\n  BinaryDeserializeVisitor(const char* buffer, size_t size)\n    : buf_(buffer), size_(size) {}\n  void visit(double& x) {\n    if (size_ < sizeof(x))\n      throw std::runtime_error(\"Buffer overflow\");\n    memcpy(&x, buf_, sizeof(x));\n    buf_ += sizeof(x);\n    size_ -= sizeof(x);\n  }\n  template <typename T> void visit(T& t) {\n    T::accept(t, *this);\n  }\n  private:\n  const char* buf_;\n  size_t size_;\n};\n```", "```cpp\n// Example 19\n// On the sender machine:\nLine l = ...;\nCircle c = ...;\nIntersection<Circle, Circle> x = ...;\nchar buffer[1024];\nBinarySerializeVisitor serializer(buffer, sizeof(buffer));\nserializer.visit(l);\nserializer.visit(c);\nserializer.visit(x);\n... send the buffer to the receiver ...\n// On the receiver machine:\nLine l;\nCircle c;\nIntersection<Circle, Circle> x;\nBinaryDeserializeVisitor deserializer(buffer, \n  sizeof(buffer));\ndeserializer.visit(l);\ndeserializer.visit(c);\ndeserializer.visit(x);\n```", "```cpp\n// Example 20\nclass BinarySerializeVisitor {\n  public:\n  void operator()(double x);\n  template <typename T> void operator()(const T& t);\n  ...\n};\n```", "```cpp\n// Example 20\nclass Point {\n  public:\n  static void accept(This& t, Visitor& v) {\n    v(t.x_);\n    v(t.y_);\n  }\n  ...\n};\n```", "```cpp\n// Example 20\nSomeVisitor v;\nObject1 x; Object2 y; ...\nvisitation(v, x, y, z);\n```", "```cpp\n// Example 20\ntemplate <typename V, typename T>\nvoid visitation(V& v, T& t) {\n  v(t);\n}\ntemplate <typename V, typename T, typename... U>\nvoid visitation(V& v, T& t, U&... u) {\n  v(t);\n  visitation(v, u ...);\n}\n```", "```cpp\n// Example 20\ntemplate <typename V, typename T, typename... U>\nvoid visitation(V& v, U&... u) {\n  (v(u), ...);\n}\n```", "```cpp\ntemplate <typename V, typename T, typename... U>\nvoid visitation(V& v, U&... u) {\n  using fold = int[];\n  (void)fold { 0, (v(u), 0)... };\n}\n```", "```cpp\nunion { int i; double d; std::string s; } u;\nu.i = 0;\n++u.i;               // OK\nstd::cout << u.d;     // Undefined behavior\n```", "```cpp\nstd::variant<int, double, std::string> v;\nstd::get<int>(v) = 0;     // Initialized as int\nstd::cout << v.index();     // 0 is the index of int\n++std::get<0>(v);     // OK, int is 0th type\nstd::get<1>(v);          // throws std::bad_variant_access\n```", "```cpp\nstd::variant<int, double, std::string> v;\nstruct Print {\n  void operator()(int i) { std::cout << i; }\n  void operator()(double d) { std::cout << d; }\n  void operator()(const std::string& s) { std::cout << s; }\n} print;\nstd::visit(print, v);\n```", "```cpp\nstd::variant<int, double, std::string> v;\nstd::visit([](const auto& x) { std::cout << x;}, v);\n```", "```cpp\n// Example 21\nusing Pet = \n  std::variant<class Cat, class Dog, class Lorikeet>;\n```", "```cpp\n// Example 21\nclass PetBase {\n  public:\n  PetBase(std::string_view color) : color_(color) {}\n  const std::string& color() const { return color_; }\n  private:\n  const std::string color_;\n};\nclass Cat : private PetBase {\n  public:\n  using PetBase::PetBase;\n  using PetBase::color;\n};\nclass Dog : private PetBase {\n  ... similar to Cat ...\n};\nclass Lorikeet {\n  public:\n  Lorikeet(std::string_view body, std::string_view head) :\n    body_(body), head_(head) {}\n  std::string color() const {\n    return body_ + \" and \" + head_;\n  }\n  private:\n  const std::string body_;\n  const std::string head_;\n};\n```", "```cpp\n// Example 21\nclass FeedingVisitor {\n  public:\n  void operator()(const Cat& c) {\n    std::cout << \"Feed tuna to the \" << c.color()\n              << \" cat\" << std::endl;\n  }\n  void operator()(const Dog& d) {\n    std::cout << \"Feed steak to the \" << d.color()\n              << \" dog\" << std::endl;\n  }\n  void operator()(const Lorikeet& l) {\n    std::cout << \"Feed grain to the \" << l.color()\n              << \" bird\" << std::endl;\n  }\n};\n```", "```cpp\n// Example 21\nPet p = Cat(\"orange\");\nFeedingVisitor v;\nstd::visit(v, p);\n```", "```cpp\n// Example 22\n#define SAME(v, T) \\\n  std::is_same_v<std::decay_t<decltype(v)>, T>\nauto fv = [](const auto& p) {\n  if constexpr (SAME(p, Cat)) {\n    std::cout << \"Feed tuna to the \" << p.color()\n              << \" cat\" << std::endl; }\n  else if constexpr (SAME(p, Dog)) {\n    std::cout << \"Feed steak to the \" << p.color()\n              << \" dog\" << std::endl; }\n  else if constexpr (SAME(p, Lorikeet)) {\n    std::cout << \"Feed grain to the \" << p.color()\n              << \" bird\" << std::endl; }\n  else abort();\n};\n```", "```cpp\n// Example 22\ntemplate <typename... T> struct overloaded : T... {\n  using T::operator()...;\n};\ntemplate <typename... T>\noverloaded( T...)->overloaded<T...>;\nauto pv = overloaded {\n  [](const Cat& c) {\n    std::cout << \"Play with feather with the \" << c.color()\n              << \" cat\" << std::endl; },\n  [](const Dog& d) {\n    std::cout << \"Play fetch with the \" << d.color()\n              << \" dog\" << std::endl; },\n  [](const Lorikeet& l) {\n    std::cout << \"Teach words to the \" << l.color()\n              << \" bird\" << std::endl; }\n};\n```", "```cpp\n// Example 22\nPet l = Lorikeet(\"yellow\", \"green\");\nstd::visit(pv, l);\n```", "```cpp\n// Example 23\nusing Pet = std::variant<class Cat, class Dog>;\nPet c1 = Cat(\"orange\");\nPet c2 = Cat(\"black\");\nPet d = Dog(\"brown\");\nCareVisitor cv;\nstd::visit(cv, c1, c2);      // Two cats\nstd::visit(cv, c1, d);     // Cat and dog\n```", "```cpp\nclass CareVisitor {\n  public:\n  void operator()(const Cat& c1, const Cat& c2) {\n    std::cout << \"Let the \" << c1.color() << \" and the \"\n              << c2.color() << \" cats play\" << std::endl; }\n  void operator()(const Dog& d, const Cat& c) {\n    std::cout << \"Keep the \" << d.color()\n              << \" dog safe from the vicious \" << c.color()\n              << \" cat\" << std::endl; }\n  void operator()(const Cat& c, const Dog& d) {\n    (*this)(d, c);\n  }\n  void operator()(const Dog& d1, const Dog& d2) {\n    std::cout << \"Take the \" << d1.color() << \" and the \"\n              << d2.color() << \" dogs for a walk\"\n              << std::endl; }\n};\n```"]