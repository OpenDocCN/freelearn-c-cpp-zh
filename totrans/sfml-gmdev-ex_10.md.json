["```cpp\nenum class GUI_ElementState{ Neutral, Focused, Clicked };\n```", "```cpp\nstruct GUI_Style{\n    ...\n    sf::Vector2f m_size; // Element size.\n    // Background properties.\n    sf::Color m_backgroundColor;\n    sf::Color m_elementColor;\n    std::string m_backgroundImage;\n    sf::Color m_backgroundImageColor;\n    // Text properties.\n    sf::Color m_textColor;\n    std::string m_textFont;\n    sf::Vector2f m_textPadding;\n    unsigned int m_textSize;\n    bool m_textCenterOrigin;\n    // Glyph properties.\n    std::string m_glyph;\n    sf::Vector2f m_glyphPadding;\n};\n```", "```cpp\nGUI_Style(): m_textSize(12), m_textCenterOrigin(false),\n  m_backgroundImageColor(255,255,255,255)\n{\n  sf::Color none    = sf::Color(0, 0, 0, 0);\n  m_backgroundColor = none;\n  m_elementColor    = none;\n  m_textColor       = none;\n}\n```", "```cpp\nstruct GUI_Visual{\n    sf::RectangleShape m_backgroundSolid;\n    sf::Sprite m_backgroundImage;\n    sf::Sprite m_glyph;\n    sf::Text m_text;\n};\n```", "```cpp\ninline void ReadQuotedString(std::stringstream& l_stream, \n  std::string& l_string)\n{\n  l_stream >> l_string;\n  if (l_string.at(0) == '\"'){\n    while (l_string.at(l_string.length() - 1) != '\"' ||\n      !l_stream.eof())\n    {\n      std::string str;\n      l_stream >> str;\n      l_string.append(\" \" + str);\n    }\n  }\n  l_string.erase(std::remove(l_string.begin(),\n    l_string.end(), '\"'), l_string.end());\n}\n```", "```cpp\nclass FontManager : public ResourceManager<FontManager, sf::Font>{\npublic:\n  FontManager() : ResourceManager(\"fonts.cfg\"){}\n\n  sf::Font* Load(const std::string& l_path){\n    sf::Font* font = new sf::Font();\n    if (!font->loadFromFile(\n      Utils::GetWorkingDirectory() + l_path))\n    {\n      delete font;\n      font = nullptr;\n      std::cerr << \"! Failed to load font: \"\n        << l_path << std::endl;\n    }\n    return font;\n  }\n};\n```", "```cpp\nenum class GUI_ElementType{ Window, Label, Button, Scrollbar,\n  Textfield };\n```", "```cpp\nusing ElementStyles = std::unordered_map<\n  GUI_ElementState, GUI_Style>;\n```", "```cpp\nclass GUI_Interface;\n```", "```cpp\nclass GUI_Element{\n  friend class GUI_Interface;\npublic:\n  GUI_Element(const std::string& l_name, \n    const GUI_ElementType& l_type, GUI_Interface* l_owner);\n  virtual ~GUI_Element();\n\n  // Event methods.\n  virtual void ReadIn(std::stringstream& l_stream) = 0;\n  virtual void OnClick(const sf::Vector2f& l_mousePos) = 0;\n  virtual void OnRelease() = 0;\n  virtual void OnHover(const sf::Vector2f& l_mousePos) = 0;\n  virtual void OnLeave() = 0;\n  virtual void Update(float l_dT) = 0;\n  virtual void Draw(sf::RenderTarget* l_target) = 0;\n\n  virtual void UpdateStyle(const GUI_ElementState& l_state,\n    const GUI_Style& l_style);\n  virtual void ApplyStyle();\n  ... // Getters/setters\n  friend std::stringstream& operator >>(\n    std::stringstream& l_stream, GUI_Element& b)\n  {\n    b.ReadIn(l_stream);\n    return l_stream;\n  }\nprotected:\n  void ApplyTextStyle();\n  void ApplyBgStyle();\n  void ApplyGlyphStyle();\n\n  void RequireTexture(const std::string& l_name);\n  void RequireFont(const std::string& l_name);\n  void ReleaseTexture(const std::string& l_name);\n  void ReleaseFont(const std::string& l_name);\n  void ReleaseResources();\n  std::string m_name;\n  sf::Vector2f m_position;\n  ElementStyles m_style; // Style of drawables.\n  GUI_Visual m_visual; // Drawable bits.\n  GUI_ElementType m_type;\n  GUI_ElementState m_state;\n  GUI_Interface* m_owner;\n\n  bool m_needsRedraw;\n  bool m_active;\n  bool m_isControl;\n};\n```", "```cpp\nGUI_Element::GUI_Element(const std::string& l_name,\n  const GUI_ElementType& l_type, GUI_Interface* l_owner)\n  : m_name(l_name), m_type(l_type), m_owner(l_owner),\n  m_state(GUI_ElementState::Neutral), m_needsRedraw(false),\n  m_active(true), m_isControl(false){}\n```", "```cpp\nGUI_Element::~GUI_Element(){ ReleaseResources(); }\n```", "```cpp\nvoid GUI_Element::ReleaseResources(){\n  for (auto &itr : m_style){\n    ReleaseTexture(itr.second.m_backgroundImage);\n    ReleaseTexture(itr.second.m_glyph);\n    ReleaseFont(itr.second.m_textFont);\n  }\n}\n```", "```cpp\nvoid GUI_Element::ReleaseTexture(const std::string& l_name){\n  if (l_name == \"\"){ return; }\n  m_owner->GetManager()->GetContext()->\n    m_textureManager->ReleaseResource(l_name);\n}\n```", "```cpp\nvoid GUI_Element::UpdateStyle(const GUI_ElementState& l_state, \n  const GUI_Style& l_style)\n{\n  // Resource management.\n  if (l_style.m_backgroundImage !=\n    m_style[l_state].m_backgroundImage)\n  {\n    ReleaseTexture(m_style[l_state].m_backgroundImage);\n    RequireTexture(l_style.m_backgroundImage);\n  }\n\n  if (l_style.m_glyph != m_style[l_state].m_glyph){\n    ReleaseTexture(m_style[l_state].m_glyph);\n    RequireTexture(l_style.m_glyph);\n  }\n\n  if (l_style.m_textFont != m_style[l_state].m_textFont){\n    ReleaseFont(m_style[l_state].m_textFont);\n    RequireFont(l_style.m_textFont);\n  }\n  // Style application.\n  m_style[l_state] = l_style;\n  if (l_state == m_state){ SetRedraw(true); ApplyStyle(); }\n}\n```", "```cpp\nvoid GUI_Element::RequireTexture(const std::string& l_name){\n  if (l_name == \"\"){ return; }\n  m_owner->GetManager()->GetContext()->\n    m_textureManager->RequireResource(l_name);\n}\n```", "```cpp\nvoid GUI_Element::ApplyStyle(){\n  ApplyTextStyle();\n  ApplyBgStyle();\n  ApplyGlyphStyle();\n  if (m_owner != this && !IsControl()){\n    m_owner->AdjustContentSize(this);\n  }\n}\n```", "```cpp\nvoid GUI_Element::ApplyTextStyle(){\n  FontManager* fonts = m_owner->GetManager()->\n    GetContext()->m_fontManager;\n  const GUI_Style& CurrentStyle = m_style[m_state];\n  if (CurrentStyle.m_textFont != \"\"){\n    m_visual.m_text.setFont(\n      *fonts->GetResource(CurrentStyle.m_textFont));\n    m_visual.m_text.setColor(CurrentStyle.m_textColor);\n    m_visual.m_text.setCharacterSize(CurrentStyle.m_textSize);\n    if (CurrentStyle.m_textCenterOrigin){\n      sf::FloatRect rect = m_visual.m_text.getLocalBounds();\n      m_visual.m_text.setOrigin(rect.left + rect.width / 2.0f,\n        rect.top + rect.height / 2.0f);\n    } else {\n      m_visual.m_text.setOrigin(0.f, 0.f);\n    }\n  }\n  m_visual.m_text.setPosition(m_position +\n    CurrentStyle.m_textPadding);\n}\n```", "```cpp\nvoid GUI_Element::ApplyBgStyle(){\n  TextureManager* textures = m_owner->GetManager()->\n    GetContext()->m_textureManager;\n  const GUI_Style& CurrentStyle = m_style[m_state];\n  if (CurrentStyle.m_backgroundImage != \"\"){\n    m_visual.m_backgroundImage.setTexture(\n      *textures->GetResource(CurrentStyle.m_backgroundImage));\n    m_visual.m_backgroundImage.setColor(\n      CurrentStyle.m_backgroundImageColor);\n  }\n  m_visual.m_backgroundImage.setPosition(m_position);\n  m_visual.m_backgroundSolid.setSize(\n    sf::Vector2f(CurrentStyle.m_size));\n  m_visual.m_backgroundSolid.setFillColor(\n    CurrentStyle.m_backgroundColor);\n  m_visual.m_backgroundSolid.setPosition(m_position);\n}\n```", "```cpp\nvoid GUI_Element::ApplyGlyphStyle(){\n  const GUI_Style& CurrentStyle = m_style[m_state];\n  TextureManager* textures = m_owner->GetManager()->\n    GetContext()->m_textureManager;\n  if (CurrentStyle.m_glyph != \"\"){\n    m_visual.m_glyph.setTexture(\n      *textures->GetResource(CurrentStyle.m_glyph));\n  }\n  m_visual.m_glyph.setPosition(m_position +\n    CurrentStyle.m_glyphPadding);\n}\n```", "```cpp\nvoid GUI_Element::SetState(const GUI_ElementState& l_state){\n  if (m_state == l_state){ return; }\n  m_state = l_state;\n  SetRedraw(true);\n}\n```", "```cpp\nvoid GUI_Element::SetPosition(const sf::Vector2f& l_pos){\n  m_position = l_pos;\n  if (m_owner == nullptr || m_owner == this){ return; }\n  const auto& padding = m_owner->GetPadding();\n  if (m_position.x < padding.x){ m_position.x = padding.x; }\n  if (m_position.y < padding.y){ m_position.y = padding.y; }\n}\n```", "```cpp\nbool GUI_Element::IsInside(const sf::Vector2f& l_point) const{\n   sf::Vector2f position = GetGlobalPosition();\n   return(l_point.x >= position.x &&\n      l_point.y >= position.y &&\n      l_point.x <= position.x + m_style.at(m_state).m_size.x &&\n      l_point.y <= position.y + m_style.at(m_state).m_size.y);\n}\n```", "```cpp\nsf::Vector2f GUI_Element::GetGlobalPosition() const{\n  sf::Vector2f position = GetPosition();\n  if (m_owner == nullptr || m_owner == this){ return position; }\n  position += m_owner->GetGlobalPosition();\n  if (IsControl()){ return position; }\n  position.x -= m_owner->m_scrollHorizontal;\n  position.y -= m_owner->m_scrollVertical;\n  return position;\n}\n```", "```cpp\nConst sf::Vector2f& GUI_Element::GetSize() const{ \n    return m_style.at(m_state).m_size;\n}\nvoid GUI_Element::SetActive(const bool& l_active){ \n    if (l_active != m_active){\n     m_active = l_active; \n        SetRedraw(true);\n    }\n}\nstd::string GUI_Element::GetText() const{ \n    return m_visual.m_text.getString();\n}\nvoid GUI_Element::SetText(const std::string& l_text){ \n    m_visual.m_text.setString(l_text);\n    SetRedraw(true);\n}\n```", "```cpp\nenum class GUI_EventType{ None, Click, Release, Hover, Leave };\n```", "```cpp\nstruct ClickCoordinates{\n    float x, y;\n};\n\nstruct GUI_Event{\n    GUI_EventType m_type;\n    const char* m_element;\n    const char* m_interface;\n    union{\n        ClickCoordinates m_clickCoords;\n    };\n};\n```", "```cpp\nusing Elements = std::unordered_map<std::string,GUI_Element*>;\n```", "```cpp\nclass GUI_Manager;\n```", "```cpp\nclass GUI_Interface : public GUI_Element{\n  friend class GUI_Element;\n  friend class GUI_Manager;\npublic:\n  ...\nprivate:\n  void DefocusTextfields();\n  Elements m_elements;\n  sf::Vector2f m_elementPadding;\n\n  GUI_Interface* m_parent;\n  GUI_Manager* m_guiManager;\n\n  sf::RenderTexture* m_backdropTexture;\n  sf::Sprite m_backdrop;\n\n  // Movement.\n  sf::RectangleShape m_titleBar;\n  sf::Vector2f m_moveMouseLast;\n  bool m_showTitleBar;\n  bool m_movable;\n  bool m_beingMoved;\n  bool m_focused;\n\n  // Variable size.\n  void AdjustContentSize(const GUI_Element* l_reference= nullptr);\n  void SetContentSize(const sf::Vector2f& l_vec);\n  sf::RenderTexture* m_contentTexture;\n  sf::Sprite m_content;\n  sf::Vector2f m_contentSize;\n  int m_scrollHorizontal;\n  int m_scrollVertical;\n  bool m_contentRedraw;\n\n  // Control layer.\n  sf::RenderTexture* m_controlTexture;\n  sf::Sprite m_control;\n  bool m_controlRedraw;\n};\n```", "```cpp\nGUI_Interface::GUI_Interface(const std::string& l_name,\n  GUI_Manager* l_guiManager)\n  : GUI_Element(l_name, GUI_ElementType::Window, this),\n  m_parent(nullptr), m_guiManager(l_guiManager), m_movable(false),\n  m_beingMoved(false), m_showTitleBar(false), m_focused(false),\n  m_scrollHorizontal(0),m_scrollVertical(0),m_contentRedraw(true),\n  m_controlRedraw(true)\n{\n  m_backdropTexture = new sf::RenderTexture();\n  m_contentTexture = new sf::RenderTexture();\n  m_controlTexture = new sf::RenderTexture();\n}\n```", "```cpp\nGUI_Interface::~GUI_Interface(){\n  delete m_backdropTexture;\n  delete m_contentTexture;\n  delete m_controlTexture;\n  for (auto &itr : m_elements){\n    delete itr.second;\n  }\n}\n```", "```cpp\nvoid GUI_Interface::SetPosition(const sf::Vector2f& l_pos){\n    GUI_Element::SetPosition(l_pos);\n    m_backdrop.setPosition(l_pos);\n    m_content.setPosition(l_pos);\n    m_control.setPosition(l_pos);\n    m_titleBar.setPosition(m_position.x, m_position.y - m_titleBar.getSize().y);\n    m_visual.m_text.setPosition(m_titleBar.getPosition() + m_style[m_state].m_textPadding);\n}\n```", "```cpp\nbool GUI_Interface::AddElement(const GUI_ElementType& l_type, \n  const std::string& l_name)\n{\n  if (m_elements.find(l_name) != m_elements.end()){return false;}\n  GUI_Element* element = nullptr;\n  element = m_guiManager->CreateElement(l_type, this);\n  if (!element){ return false; }\n  element->SetName(l_name);\n  element->SetOwner(this);\n  m_elements.emplace(l_name, element);\n  m_contentRedraw = true;\n  m_controlRedraw = true;\n  return true;\n}\n```", "```cpp\nGUI_Element* GUI_Interface::GetElement(const std::string& l_name)\nconst{\n  auto itr = m_elements.find(l_name);\n  return(itr != m_elements.end() ? itr->second : nullptr);\n}\n```", "```cpp\nbool GUI_Interface::RemoveElement(const std::string& l_name){\n  auto itr = m_elements.find(l_name);\n  if (itr == m_elements.end()){ return false; }\n  delete itr->second;\n  m_elements.erase(itr);\n  m_contentRedraw = true;\n  m_controlRedraw = true;\n  AdjustContentSize();\n  return true;\n}\n```", "```cpp\nbool GUI_Interface::IsInside(const sf::Vector2f& l_point) const{\n    if (GUI_Element::IsInside(l_point)){ return true; }\n    return m_titleBar.getGlobalBounds().contains(l_point);\n}\n```", "```cpp\nvoid GUI_Interface::ReadIn(std::stringstream& l_stream){\n    std::string movableState;\n    std::string titleShow;\n    std::string title;\n    l_stream >> m_elementPadding.x >> m_elementPadding.y >> movableState >> titleShow;\n    Utils::ReadQuotedString(l_stream, title);\n    m_visual.m_text.setString(title);\n    if (movableState == \"Movable\"){ m_movable = true; }\n    if (titleShow == \"Title\"){ m_showTitleBar = true; }\n}\n```", "```cpp\nvoid GUI_Interface::OnClick(const sf::Vector2f& l_mousePos){\n  DefocusTextfields();\n  if (m_titleBar.getGlobalBounds().contains(l_mousePos) &&\n    m_movable && m_showTitleBar)\n  {\n    m_beingMoved = true;\n  } else {\n    GUI_Event event;\n    event.m_type = GUI_EventType::Click;\n    event.m_interface = m_name.c_str();\n    event.m_element = \"\";\n    event.m_clickCoords.x = l_mousePos.x;\n    event.m_clickCoords.y = l_mousePos.y;\n    m_guiManager->AddEvent(event);\n    for (auto &itr : m_elements){\n      if (!itr.second->IsInside(l_mousePos)){ continue; }\n      itr.second->OnClick(l_mousePos);\n      event.m_element = itr.second->m_name.c_str();\n      m_guiManager->AddEvent(event);\n    }\n    SetState(GUI_ElementState::Clicked);\n  }\n}\n```", "```cpp\nvoid GUI_Interface::OnRelease(){\n  GUI_Event event;\n  event.m_type = GUI_EventType::Release;\n  event.m_interface = m_name.c_str();\n  event.m_element = \"\";\n  m_guiManager->AddEvent(event);\n  for (auto &itr : m_elements){\n    if (itr.second->GetState() != GUI_ElementState::Clicked)\n    {\n      continue;\n    }\n    itr.second->OnRelease();\n    event.m_element = itr.second->m_name.c_str();\n    m_guiManager->AddEvent(event);\n  }\n  SetState(GUI_ElementState::Neutral);\n}\n```", "```cpp\nvoid GUI_Interface::OnTextEntered(const char& l_char){\n  for (auto &itr : m_elements){\n    if (itr.second->GetType() != GUI_ElementType::Textfield){\n      continue;\n    }\n    if (itr.second->GetState() != GUI_ElementState::Clicked){\n      continue;\n    }\n    if (l_char == 8){\n      // Backspace.\n      const auto& text = itr.second->GetText();\n      itr.second->SetText(text.substr(0, text.length() -1));\n      return;\n    }\n    if (l_char < 32 || l_char > 126){ return; }\n    std::string text = itr.second->GetText();\n    text.push_back(l_char);\n    itr.second->SetText(text);\n    return;\n  }\n}\n```", "```cpp\nvoid GUI_Interface::DefocusTextfields(){\n  GUI_Event event;\n  event.m_type = GUI_EventType::Release;\n  event.m_interface = m_name.c_str();\n  event.m_element = \"\";\n  for (auto &itr : m_elements){\n    if (itr.second->GetType() != GUI_ElementType::Textfield){\n      continue;\n    }\n    itr.second->SetState(GUI_ElementState::Neutral);\n    event.m_element = itr.second->m_name.c_str();\n    m_guiManager->AddEvent(event);\n  }\n}\n```", "```cpp\nvoid GUI_Interface::OnHover(const sf::Vector2f& l_mousePos){\n  GUI_Event event;\n  event.m_type = GUI_EventType::Hover;\n  event.m_interface = m_name.c_str();\n  event.m_element = \"\";\n  event.m_clickCoords.x = l_mousePos.x;\n  event.m_clickCoords.y = l_mousePos.y;\n  m_guiManager->AddEvent(event);\n\n  SetState(GUI_ElementState::Focused);\n}\nvoid GUI_Interface::OnLeave(){\n  GUI_Event event;\n  event.m_type = GUI_EventType::Leave;\n  event.m_interface = m_name.c_str();\n  event.m_element = \"\";\n  m_guiManager->AddEvent(event);\n\n  SetState(GUI_ElementState::Neutral);\n}\n```", "```cpp\nvoid GUI_Interface::Update(float l_dT){\n   sf::Vector2f mousePos = sf::Vector2f(\n      m_guiManager->GetContext()->m_eventManager->GetMousePos(\n      m_guiManager->GetContext()->m_wind->GetRenderWindow()));\n\n   if (m_beingMoved && m_moveMouseLast != mousePos){\n      sf::Vector2f difference = mousePos - m_moveMouseLast;\n      m_moveMouseLast = mousePos;\n      sf::Vector2f newPosition = m_position + difference;\n      SetPosition(newPosition);\n   }\n   ...\n}\n```", "```cpp\nfor (auto &itr : m_elements){\n  if (itr.second->NeedsRedraw()){\n    if (itr.second->IsControl()){ m_controlRedraw = true; } \n    else { m_contentRedraw = true; }\n  }\n  if (!itr.second->IsActive()){ continue; }\n  itr.second->Update(l_dT);\n  if (m_beingMoved){ continue; }\n  GUI_Event event;\n  event.m_interface = m_name.c_str();\n  event.m_element = itr.second->m_name.c_str();\n  event.m_clickCoords.x = mousePos.x;\n  event.m_clickCoords.y = mousePos.y;\n  if (IsInside(mousePos) && itr.second->IsInside(mousePos) \n    && !m_titleBar.getGlobalBounds().contains(mousePos))\n  {\n    if (itr.second->GetState() != GUI_ElementState::Neutral){\n      continue;\n    }\n    itr.second->OnHover(mousePos);\n    event.m_type = GUI_EventType::Hover;\n  } else if (itr.second->GetState() == GUI_ElementState::Focused){\n    itr.second->OnLeave();\n    event.m_type = GUI_EventType::Leave;\n  }\n  m_guiManager->AddEvent(event);\n}\n```", "```cpp\nvoid GUI_Interface::Draw(sf::RenderTarget* l_target){\n  l_target->draw(m_backdrop);\n  l_target->draw(m_content);\n  l_target->draw(m_control);\n\n  if (!m_showTitleBar){ return; }\n  l_target->draw(m_titleBar);\n  l_target->draw(m_visual.m_text);\n}\n```", "```cpp\nvoid GUI_Interface::BeginMoving(){\n  if (!m_showTitleBar || !m_movable){ return; }\n  m_beingMoved = true;\n  SharedContext* context = m_guiManager->GetContext();\n  m_moveMouseLast = sf::Vector2f(context->m_eventManager->\n    GetMousePos(context->m_wind->GetRenderWindow()));\n}\n```", "```cpp\nvoid GUI_Interface::StopMoving(){ m_beingMoved = false; }\n```", "```cpp\nsf::Vector2f GUI_Interface::GetGlobalPosition() const{\n    sf::Vector2f pos = m_position;\n    GUI_Interface* i = m_parent;\n    while (i){\n        pos += i->GetPosition();\n        i = i->m_parent;\n    }\n    return pos;\n}\n```", "```cpp\nvoid GUI_Interface::ApplyStyle(){\n    GUI_Element::ApplyStyle(); // Call base method.\n    m_visual.m_backgroundSolid.setPosition(0.f,0.f);\n    m_visual.m_backgroundImage.setPosition(0.f,0.f);\n    m_titleBar.setSize(sf::Vector2f(m_style[m_state].m_size.x, 16.f));\n    m_titleBar.setPosition(m_position.x,m_position.y - m_titleBar.getSize().y);\n    m_titleBar.setFillColor(m_style[m_state].m_elementColor);\n    m_visual.m_text.setPosition(m_titleBar.getPosition() + m_style[m_state].m_textPadding);\n    m_visual.m_glyph.setPosition(m_titleBar.getPosition() + m_style[m_state].m_glyphPadding);\n}\n```", "```cpp\nvoid GUI_Interface::Redraw(){\n  if (m_backdropTexture->getSize().x!=m_style[m_state].m_size.x ||\n    m_backdropTexture->getSize().y != m_style[m_state].m_size.y)\n  {\n    m_backdropTexture->create(m_style[m_state].m_size.x,\n      m_style[m_state].m_size.y);\n  }\n  m_backdropTexture->clear(sf::Color(0, 0, 0, 0));\n  ApplyStyle();\n  m_backdropTexture->draw(m_visual.m_backgroundSolid);\n\n  if (m_style[m_state].m_backgroundImage != \"\"){\n    m_backdropTexture->draw(m_visual.m_backgroundImage);\n  }\n\n  m_backdropTexture->display();\n  m_backdrop.setTexture(m_backdropTexture->getTexture());\n  m_backdrop.setTextureRect(sf::IntRect(0, 0,\n    m_style[m_state].m_size.x, m_style[m_state].m_size.y));\n  SetRedraw(false);\n}\n```", "```cpp\nvoid GUI_Interface::RedrawContent(){\n  if (m_contentTexture->getSize().x != m_contentSize.x ||\n    m_contentTexture->getSize().y != m_contentSize.y)\n  {\n    m_contentTexture->create(m_contentSize.x, m_contentSize.y);\n  }\n\n  m_contentTexture->clear(sf::Color(0, 0, 0, 0));\n\n  for (auto &itr : m_elements){\n    GUI_Element* element = itr.second;\n    if (!element->IsActive() || element->IsControl()){ continue; }\n    element->ApplyStyle();\n    element->Draw(m_contentTexture);\n    element->SetRedraw(false);\n  }\n\n  m_contentTexture->display();\n  m_content.setTexture(m_contentTexture->getTexture());\n\n  m_content.setTextureRect(sf::IntRect(\n    m_scrollHorizontal, m_scrollVertical,\n    m_style[m_state].m_size.x, m_style[m_state].m_size.y));\n  m_contentRedraw = false;\n}\n```", "```cpp\nvoid GUI_Interface::RedrawControls(){\n  if (m_controlTexture->getSize().x!=m_style[m_state].m_size.x ||\n    m_controlTexture->getSize().y != m_style[m_state].m_size.y)\n  {\n    m_controlTexture->create(m_style[m_state].m_size.x,\n      m_style[m_state].m_size.y);\n  }\n  m_controlTexture->clear(sf::Color(0, 0, 0, 0));\n\n  for (auto &itr : m_elements){\n    GUI_Element* element = itr.second;\n    if (!element->IsActive() || !element->IsControl()){ continue; }\n    element->ApplyStyle();\n    element->Draw(m_controlTexture);\n    element->SetRedraw(false);\n  }\n\n  m_controlTexture->display();\n  m_control.setTexture(m_controlTexture->getTexture());\n  m_control.setTextureRect(sf::IntRect(0, 0,\n    m_style[m_state].m_size.x, m_style[m_state].m_size.y));\n  m_controlRedraw = false;\n}\n```", "```cpp\nvoid GUI_Interface::UpdateScrollHorizontal(\nunsigned int l_percent)\n{\n  if (l_percent > 100){ return; }\n  m_scrollHorizontal = ((m_contentSize.x - GetSize().x) / 100) *\n    l_percent;\n  sf::IntRect rect = m_content.getTextureRect();\n  m_content.setTextureRect(sf::IntRect(\n    m_scrollHorizontal, m_scrollVertical,rect.width,rect.height));\n}\n\nvoid GUI_Interface::UpdateScrollVertical(unsigned int l_percent){\n  if (l_percent > 100){ return; }\n  m_scrollVertical = ((m_contentSize.y - GetSize().y) / 100) *\n    l_percent;\n  sf::IntRect rect = m_content.getTextureRect();\n  m_content.setTextureRect(sf::IntRect(\n    m_scrollHorizontal, m_scrollVertical,rect.width,rect.height));\n}\n```", "```cpp\nvoid GUI_Interface::AdjustContentSize(\n  const GUI_Element* l_reference)\n{\n  if (l_reference){\n    sf::Vector2f bottomRight = \n      l_reference->GetPosition() + l_reference->GetSize();\n    if (bottomRight.x > m_contentSize.x){\n      m_contentSize.x = bottomRight.x;\n      m_controlRedraw = true;\n    }\n    if (bottomRight.y > m_contentSize.y){\n      m_contentSize.y = bottomRight.y;\n      m_controlRedraw = true;\n    }\n    return;\n  }\n\n  sf::Vector2f farthest = GetSize();\n\n  for (auto &itr : m_elements){\n    GUI_Element* element = itr.second;\n    if (!element->IsActive() || element->IsControl()){ continue; }\n    sf::Vector2f bottomRight =\n      element->GetPosition() + element->GetSize();\n    if (bottomRight.x > farthest.x){\n      farthest.x = bottomRight.x;\n      m_controlRedraw = true;\n    }\n    if (bottomRight.y > farthest.y){\n      farthest.y = bottomRight.y;\n      m_controlRedraw = true;\n    }\n  }\n  SetContentSize(farthest);\n}\n```", "```cpp\nvoid AdjustContentSize(const GUI_Element* l_reference = nullptr);\n```"]