- en: Advanced Domain-Specific Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级领域特定语言
- en: 'In the previous chapter, we developed a **domain-specific language** (**DSL**).
    In this chapter, we will improve the language in several ways:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开发了一个**领域特定语言**（**DSL**）。在本章中，我们将以几种方式改进语言：
- en: We will add **selection** and **iteration**. More specifically, we will add
    the `if` and `while` instructions. In the language of the previous chapter, the
    actions were executed in a straightforward manner. In this chapter, it is possible
    to select between alternatives and to iterate over a part of the code.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将添加**选择**和**迭代**。更具体地说，我们将添加`if`和`while`指令。在上一章的语言中，动作以直接的方式执行。在本章中，可以在不同的选择之间进行选择，并遍历代码的一部分。
- en: We will add **variables**. In the previous chapter, we could assign values to
    a name once. In this chapter, however, values are assigned to names that can be
    reassigned during the execution of the program.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将添加**变量**。在上一章中，我们可以将值赋给一个名称一次。然而，在本章中，值被赋给可以在程序执行过程中重新赋值的名称。
- en: We add **functions**, with parameters and return values. In the previous chapter,
    a program was made up of a sequence of instructions. In this chapter, it is a
    sequence of functions. Similar to C++, there must be a `main` function where the
    execution starts.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将添加**函数**，带有参数和返回值。在上一章中，一个程序由一系列指令组成。在本章中，它是一系列函数。类似于C++，必须有`main`函数作为执行开始的地方。
- en: Finally, we will add another module in the process from the source code to the viewer.
    In the previous chapter, the parser generated a sequence of actions that were
    displayed by the viewer. In this chapter, the parser generates a sequence of **directives**,
    which in turn are evaluated to actions by the **evaluator**.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将在从源代码到查看器的过程中添加另一个模块。在上一章中，解析器生成了一系列由查看器显示的动作。在本章中，解析器生成的是一系列**指令**，这些指令随后由**评估器**评估为动作。
- en: Since the language of this chapter supports selection, iteration, variables,
    and functions calls, it starts to look like a traditional programming language.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于本章的语言支持选择、迭代、变量和函数调用，它开始看起来像一种传统的编程语言。
- en: 'Topics we will cover in this chapter include:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: Just as in the previous chapter, we will informally look into the source code
    of our DSL by looking at an example. However, in this example we will use variables
    and function calls, we will also use the `if` and `while` instructions.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如上一章一样，我们将通过查看一个示例来非正式地研究我们的领域特定语言（DSL）的源代码。然而，在这个示例中，我们将使用变量和函数调用，我们还将使用`if`和`while`指令。
- en: We will then formally define our language with **grammar**. The grammar is an
    extension of the grammar of the last chapter. We will add instructions for functions
    definitions, calls, and returns, as well as selection (`if`) and iteration (`while`).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将正式定义我们的语言，使用**语法**。这个语法是上一章语法的扩展。我们将添加函数定义、调用和返回的指令，以及选择（`if`）和迭代（`while`）的指令。
- en: When we have defined the grammar, we will write the **scanner**. The scanner
    of this chapter is almost identical to the scanner of the previous chapter. The
    only difference is that we will add a few keywords.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们定义了语法后，我们将编写**扫描器**。本章的扫描器几乎与上一章的扫描器相同。唯一的区别是我们将添加一些关键字。
- en: When we have written the scanner, we will write the **parser**. The parser is
    an extension of the parser of the previous chapter, we add methods for functions,
    selection, and iteration. However, the parser of the previous chapter generated
    a sequence of **actions**, which were read and executed by the **viewer**. In
    this chapter, however, the parser instead generates a sequence of directives that
    are read by the evaluator.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们编写了扫描器后，我们将编写**解析器**。解析器是上一章解析器的扩展，我们添加了用于函数、选择和迭代的函数。然而，上一章的解析器生成了一系列**动作**，这些动作由**查看器**读取并执行。然而，在本章中，解析器生成的是一系列由**评估器**读取的指令。
- en: In this chapter, the next step is the evaluator rather than the viewer. The
    evaluator takes the directive sequence generated by the parser, and generates
    a sequence of actions which are read and executed by the viewer. The evaluator
    works with maps that assign values to names. There is a **stack of value maps**
    that make sure that each called function gets its own fresh value map. There is
    also a **value stack** that stores temporary values when evaluating expressions.
    Finally, there is the **call stack**, holding return addresses for function calls.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，下一步是评估者而不是查看者。评估者接收解析器生成的指令序列，并生成一系列动作，这些动作由查看者读取和执行。评估者与将值分配给名称的映射一起工作。有一个**值映射栈**确保每个被调用的函数都得到它自己的新值映射。还有一个**值栈**，用于在评估表达式时存储临时值。最后，还有一个**调用栈**，用于存储函数调用的返回地址。
- en: Finally, the viewer works in the same way as in the previous chapter. It iterates
    through the action list generated by the evaluator and displays the graphical
    objects in a Qt widget.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，查看者与上一章中的工作方式相同。它遍历评估者生成的动作列表，并在 Qt 小部件中显示图形对象。
- en: Improving the source language – an example
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进源语言 – 一个例子
- en: Let's look at a new example, where we define and call a function named `triangle`
    that draws a triangle with different pens in different sizes. Note that the functions
    do not have to occur in any particular order.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个新的例子，其中我们定义并调用一个名为`triangle`的函数，该函数使用不同大小和不同笔触绘制三角形。请注意，函数不必按任何特定顺序出现。
- en: 'We start by setting the `left` and `length` variables to `50`. They hold the
    *x* coordinate of the left-most corner of the first triangle, and its base length.
    We also set the `index` variable to zero; its value will be used in the `while`
    iteration:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`left`和`length`变量设置为`50`。它们持有第一个三角形最左边的*x*坐标和其底边长度。我们还设置了`index`变量为零；其值将在`while`循环中使用：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We continue to iterate as long as `index` is less than four. Note that in this
    chapter we add Boolean values to the `Value` class. When `index` holds an even
    value, we set the pen style to a solid line, and when it holds an odd value, we
    set the pen style to a dashed line. Note that we have extended the language with
    relational expressions and the modulus (`%`) operator:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会一直迭代，直到`index`小于四。注意，在本章中，我们向`Value`类添加了布尔值。当`index`持有偶数值时，我们将画笔样式设置为实线，而当它持有奇数值时，我们将画笔样式设置为虚线。注意，我们已经通过关系表达式和取模运算符（`%`）扩展了语言：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We set the top-left point of the triangle, and call the `drawTriangle` function
    to perform the actual drawing of the triangle:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置三角形的左上角，并调用`drawTriangle`函数来执行三角形的实际绘制：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the call to `triangle`, we increase the base length of the next triangle,
    and the left-most corner:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`triangle`之后，我们增加下一个三角形的底边长度和最左边的角：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `drawTriangle` function, we call `getTopRight` and `getBottomMiddle`
    functions to obtain the top-right and bottom-middle points of the triangle. Finally,
    we draw the three lines of the triangle by calling `drawLine`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`drawTriangle`函数中，我们调用`getTopRight`和`getBottomMiddle`函数来获取三角形的右上角和底中点。最后，我们通过调用`drawLine`来绘制三角形的三条线：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `getTopRight` function extracts the *x* and *y* coordinate of the top-left
    point, and returns a point where the *x* coordinate has been increased by the
    length of the base of the triangle:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTopRight`函数提取左上角的*x*和*y*坐标，并返回一个*x*坐标增加了三角形底边长度的点：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `getBottomMiddle` function also extracts the *x* and *y* coordinates of
    the top-left point. Then it calculates the *x* and *y* coordinates of the middle-bottom
    point and returns `point`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBottomMiddle`函数也提取左上角的*x*和*y*坐标。然后它计算中间底部的*x*和*y*坐标，并返回`point`：'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the execution of the code is shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行的输出显示在下述屏幕截图：
- en: '![](img/2f238186-dcca-40cf-8b90-2a24bbf9da4d.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f238186-dcca-40cf-8b90-2a24bbf9da4d.png)'
- en: Improving the grammar
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进语法
- en: 'In this chapter, we will improve the grammar of our language. To begin with,
    a program is made up by a sequence of functions rather than instructions. Technically,
    a program can hold zero functions. However, a semantic error will report that
    the `main` function is missing:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将改进我们语言的语法。首先，一个程序由一系列函数组成，而不是指令。技术上，一个程序可以包含零个函数。然而，语义错误会报告`main`函数缺失：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The definition of a function is made up by the keyword `function`, a list of
    names enclosed by parentheses and a list of instructions enclosed by brackets.
    The `nameList` is made up of zero or more names, separated by commas:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的定义由关键字 `function`、括号内的名称列表和括号内的指令列表组成。`nameList` 由零个或多个名称组成，名称之间用逗号分隔：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When it comes to instructions, we add the calling of a function. We can either
    call the function directly, as an instruction (`call``drawTriangle` in the preceding
    example), or as a part of an expression (`callgetTopRight` and `call``getBottomMiddle`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到指令时，我们添加了函数调用的功能。我们可以直接作为指令调用函数，例如前面的例子中的 `call` `drawTriangle`，或者作为表达式的一部分（`callgetTopRight`
    和 `call` `getBottomMiddle`）。
- en: 'We also add the `while` instruction and the `if` instructions, with or without
    the `else` part. Finally, there is also the block instruction: a list of instructions
    enclosed by brackets:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了 `while` 指令和带有或不带有 `else` 部分的 `if` 指令。最后，还有块指令：由括号包围的指令列表：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When it comes to expressions, the only difference is that we have added function
    calls. The `expressionList` is a list of zero or more expressions, separated by
    commas:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到表达式时，唯一的区别是我们增加了函数调用。`expressionList` 是由逗号分隔的零个或多个表达式的列表：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Token and the Scanner
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记和扫描器
- en: Similar to the previous chapter, the final target code of the language is the
    actions, even though they are generated by an evaluator rather than the parser.
    The `Action` class is identical to the class of the previous chapter. So are the
    `Value` and `ViewerWidget` classes, as well as the colors and error handling.
    However, the `Token` and `Scanner` classes have been extended. The `TokenId` enumeration
    has been extended with more token identities.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章类似，该语言的最终目标代码是动作，尽管它们是由评估器而不是解析器生成的。`Action` 类与上一章的类相同。同样，`Value` 和 `ViewerWidget`
    类，以及颜色和错误处理也是如此。然而，`Token` 和 `Scanner` 类已被扩展。`TokenId` 枚举已被扩展以包含更多的标记标识符。
- en: '**Token.h:**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Token.h:**'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the same way, `init` in `Scanner` has been extended with the keywords.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`Scanner` 中的 `init` 已通过关键字扩展。
- en: '**Scanner.cpp:**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scanner.cpp:**'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The parser
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析器
- en: The parser has been extended with methods corresponding to the new rules of
    the grammar. Moreover, the parser of this chapter does not generate actions; instead,
    it generates **directives**. The reason for this is that, while the source code
    of the previous chapter holds instructions that were executed from the beginning
    to the end, the source code of this chapter holds selection, iteration, and function
    calls that can alter the flow of the instructions. Therefore, it makes sense to
    introduce a middle layer—the parser generates directives that are evaluated to
    become actions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器已通过对应于新语法规则的方法进行扩展。此外，本章的解析器不生成动作；相反，它生成 **指令**。这是因为，尽管上一章的源代码包含从开始到结束执行的指令，但本章的源代码包含选择、迭代和可以改变指令流程的函数调用。因此，引入一个中间层是有意义的——解析器生成指令，这些指令被评估为动作。
- en: Since the language of this chapter supports functions, we need the `Function`
    class to store the functions. It stores the names of the formal parameters and
    the start address of the function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的语言支持函数，我们需要 `Function` 类来存储函数。它存储了形式参数的名称和函数的起始地址。
- en: '**Function.h:**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**Function.h:**'
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Function.cpp` file holds the definitions of the methods of the `Function`
    class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function.cpp` 文件包含 `Function` 类方法的定义。'
- en: '**Function.cpp:**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Function.cpp:**'
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the parser in this chapter generates a sequence of directives rather than
    actions, we also need the `Directive` class to hold the directives. In most cases,
    a `Directive` object only holds its identity of the `TokenId` enumeration. However,
    in the case of a function call, we need to store the name of the function and
    the number of actual parameters. In the case of a function definition, we store
    a reference to the `Function` object. In the case of an expression made up by
    a name of a value, we need to store the name or value. Finally, there are several
    kinds of jump directives, in which case we need to store the address.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章中的解析器生成的是一系列指令而不是动作，因此我们还需要 `Directive` 类来保存指令。在大多数情况下，一个 `Directive` 对象只保存
    `TokenId` 枚举的身份标识。然而，在函数调用的例子中，我们需要存储函数名称和实际参数的数量。在函数定义的情况下，我们存储对 `Function` 对象的引用。在由值名称组成的表达式中，我们需要存储名称或值。最后，还有几种跳转指令，在这种情况下，我们需要存储地址。
- en: '**Directive.h:**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Directive.h:**'
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Directive.cpp` file holds the definitions of the methods of the `Directive`
    class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Directive.cpp`文件包含`Directive`类方法的定义。'
- en: '**Directive.cpp:**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**Directive.cpp:**'
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In most cases, we only create an object of the `Directive` class with a directive
    identity:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们只创建一个带有指令身份的`Directive`类对象：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The jump directives need the jump address:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转指令需要跳转地址：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When assigning a value to a variable, we need the name of the variable. However,
    we do not need the value since it will be stored on a stack. Also, when an expression
    is made up of a name, we need to store the name:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当给变量赋值时，我们需要变量的名称。然而，我们不需要值，因为它将被存储在栈上。此外，当表达式由一个名称组成时，我们需要存储该名称：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The directive for function calls needs the name of the function and the number
    of actual parameters:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用指令需要函数名称和实际参数的数量：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When an expression is made up simply of a value, we just store the value in
    the directive:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式仅由一个值组成时，我们只需将值存储在指令中：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, in a function definition we store an object of the `Function` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在函数定义中，我们存储一个`Function`类的对象：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Parser` class has been extended with the methods for the new rules in
    the grammar: function definitions and the `if`, `while`, `call`, and `return`
    instructions.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parser`类已经通过新语法规则的方法扩展：函数定义和`if`、`while`、`call`和`return`指令。'
- en: '**Parser.h:**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parser.h:**'
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `nameList` method gathers the formal parameters of the function, while
    `expressionList` gathers the actual parameters of the function call:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameList`方法收集函数的形式参数，而`expressionList`收集函数调用的实际参数：'
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `callExpression` method has also been added to the `Parser` class, since
    a function can be explicitly called as an **instruction**, or as a part of an
    expression:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`callExpression`方法也被添加到`Parser`类中，因为函数可以作为**指令**或表达式的一部分显式调用：'
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Parser.cpp` file holds the definitions of the methods of the `Parser` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parser.cpp`文件包含`Parser`类方法的定义。'
- en: The start method of the parser of this chapter is `functionDefinitionList`.
    It calls `functionDefinition` as long as it does not reach end-of-file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解析器的`start`方法为`functionDefinitionList`。只要没有达到文件末尾，它就会调用`functionDefinition`。
- en: '**Parser.cpp:**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parser.cpp:**'
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `functionDefinition` method parses a function definition. We start by matching
    the `function` keyword and store the name of the function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`functionDefinition`方法解析函数定义。我们首先匹配`function`关键字并存储函数的名称：'
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The function name is followed by the parameter name list enclosed by parenthesis.
    We store the name list in the `nList` field. We cannot call the field `nameList`,
    since that name has already been taken by the method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名称后面跟着括号内的参数名称列表。我们将名称列表存储在`nList`字段中。我们不能将字段命名为`nameList`，因为该名称已经被方法占用：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We store the current size of the directive list size as the start address of
    the function, create a `Function` object with the name list and start address,
    and add a `Directive` object with the function to the directive list:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指令列表的当前大小存储为函数的起始地址，创建一个带有名称列表和起始地址的`Function`对象，并将一个带有函数的`Directive`对象添加到指令列表中：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The name list is followed by a list of instructions enclosed by brackets:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 名称列表后面跟着一个由括号括起来的指令列表：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Just to be sure the function really returns the controls back to the calling
    function, we add a `Directive` object with the `return` token identity:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保函数确实将控制权返回给调用函数，我们添加了一个带有`return`标记身份的`Directive`对象：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the function has been defined, we check that there is no other function
    with the same name:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被定义后，我们检查没有其他函数具有相同的名称：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the function is named `"main"`, it is the start function of the program
    and it cannot have parameters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数名为`"main"`，它是程序的开始函数，并且它不能有参数：
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we add the function to the `functionMap`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将函数添加到`functionMap`中：
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `nameList` method parses a comma-separated list of names enclosed in parentheses:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameList`方法解析括号内逗号分隔的名称列表：'
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We continue as long as we do not encounter a right parenthesis:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会继续，直到遇到右括号：
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After we have matched the name, we check whether the next token is a right
    parenthesis. If it is, we have reached the end of the name list and break the
    iteration:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配名称后，我们检查下一个标记是否为右括号。如果是，则表示名称列表的末尾，并中断迭代：
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the next token is not a right parenthesis, we instead assume that it is
    a comma, match it, and continue to iterate with the next expression:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下一个标记不是右括号，我们则假设它是一个逗号，匹配它，并继续使用下一个表达式迭代：
- en: '[PRE38]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, before we return the name list, we need to check that no name occurs
    twice in the name list. We iterate through the name list and add the names to
    a set:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们返回名称列表之前，我们需要检查名称列表中没有任何名称重复。我们遍历名称列表并将名称添加到一个集合中：
- en: '[PRE39]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `instructionList` method looks a little bit different in this chapter since
    it is placed inside a block of instructions. We iterate as long as we do not encounter
    a right bracket:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，`instructionList` 方法看起来略有不同，因为它被放置在指令块内部。我们迭代，直到遇到右括号为止：
- en: '[PRE40]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As a function can be explicitly called as an instruction, or as part of an
    expression, we simply call `callExpression` and match the semicolon in the case
    of a call instruction:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数可以作为指令显式调用，或者作为表达式的一部分，我们只需调用 `callExpression` 并在调用指令的情况下匹配分号：
- en: '[PRE41]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the return instruction, we match the `return` keyword and check whether
    it is followed by a semicolon. If it is not followed by a semicolon, we parse
    an expression and then assume that the next token is a semicolon. Note that we
    do not store the result of the expression. The evaluator will place its value
    on a stack later in the process:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回指令中，我们匹配 `return` 关键字并检查它是否后面跟着分号。如果没有跟着分号，我们解析一个表达式，然后假设下一个标记是一个分号。注意，我们不会存储表达式的结果。评估器将在处理过程中稍后将其值放置在栈上：
- en: '[PRE42]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the case of the `if` keyword, we match it and parse an expression enclosed
    by parentheses:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 关键字的情况下，我们匹配它并解析括号内的表达式：
- en: '[PRE43]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the expression becomes evaluated to a false value, we shall jump over the
    instruction following the `if` expression. Therefore, we add a `IfNotGoto` directive,
    intending to jump over the instruction following the `if` keyword:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式评估为假值，我们将跳过 `if` 表达式之后的指令。因此，我们添加一个 `IfNotGoto` 指令，目的是跳过 `if` 关键字之后的指令：
- en: '[PRE44]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the instruction is followed by the `else` keyword, we match it and add a
    `Goto` directive, that is intended to jump over the `else` part in the case of
    a true value of the expression of the `if` instruction:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指令后面跟着 `else` 关键字，我们匹配它并添加一个 `Goto` 指令，目的是在 `if` 指令表达式的真值情况下跳过 `else` 部分：
- en: '[PRE45]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then set the jump address of the preceding `IfNotTrue` directive. If the
    expression is not true, the program shall jump to this point:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置前一个 `IfNotTrue` 指令的跳转地址。如果表达式不为真，程序将跳转到这个点：
- en: '[PRE46]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On the other hand, if the expression of the `if` instruction is true, the program
    shall jump over the `else` part to this point:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果 `if` 指令的表达式为真，程序将跳过 `else` 部分跳转到这个点：
- en: '[PRE47]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the `if` instruction is not followed by the `else` keyword, it shall jump
    to this point in the program if the expression is not true:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `if` 指令后面没有跟 `else` 关键字，如果表达式不为真，它将跳转到程序的这个点：
- en: '[PRE48]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the case of the `while` keyword, we match it and store the current index
    of the directive list in order for the program to jump back to this point after
    every iteration:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 关键字的情况下，我们匹配它并将指令列表的当前索引存储起来，以便程序在每次迭代后跳回到这个点：
- en: '[PRE49]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We then parse the expression and its enclosing parentheses:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们解析表达式及其括号：
- en: '[PRE50]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the case that the expression is not true, we add an `IfNotGoto` directive
    in order for the program to jump out of the iteration:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式不为真，我们添加一个 `IfNotGoto` 指令，以便程序跳出迭代：
- en: '[PRE51]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We add a `Goto` directive after the instruction following the `while` expression,
    so that the program can jump back to the expression at the end of each iteration:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 表达式之后的指令后添加一个 `Goto` 指令，这样程序就可以在每次迭代结束时跳回到表达式：
- en: '[PRE52]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we set the address of the `IfNotTrue` directive at the beginning of
    the `while` instruction, so that it can jump to this point in the program if the
    expression is not true:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `IfNotTrue` 指令的地址设置在 `while` 指令的开始处，这样如果表达式不为真，程序就可以跳转到这个程序点：
- en: '[PRE53]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the case of a left bracket, we have a sequence of instructions enclosed
    by brackets. We parse the pair of brackets and call `instructionList`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在左括号的情况下，我们有一个由括号包围的指令序列。我们解析这对括号并调用 `instructionList`：
- en: '[PRE54]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, in the case of a name, we have an assignment. We match the `name`
    keyword, and the assignment operator (`=`), parse the expression, and match the
    semicolon. We then add an `Assign` object to the directive list holding the name
    to be assigned a value. Note that we do not store the value of the expression,
    since it will be pushed on a value stack by the evaluator:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在名称的情况下，我们有一个赋值操作。我们匹配 `name` 关键字和赋值运算符（`=`），解析表达式，并匹配分号。然后我们向指令列表添加一个包含要赋予值的名称的
    `Assign` 对象。请注意，我们不会存储表达式的值，因为它将被评估器推入值栈：
- en: '[PRE55]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `callExpression` method matches the `call` keyword, stores the name of
    the function, parses the parameter expressions, and adds a `Directive` object
    holding the call to the directive list. Note that we do not check whether the
    function exists or count the number of parameters at this point, since the function
    may be not yet defined. All type checking is taken care of by the evaluator later
    in the process:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`callExpression` 方法匹配 `call` 关键字，存储函数的名称，解析参数表达式，并将包含调用的 `Directive` 对象添加到指令列表中。请注意，在此点我们不会检查函数是否存在或计算参数的数量，因为函数可能尚未定义。所有类型检查都由评估器在后续过程中处理：'
- en: '[PRE56]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `expressionList` method parses a list of expressions. Unlike the preceding
    name list case, we do not return the list itself, only its size. The expressions
    generate directives of their own, their values are stored on a stack by the evaluator
    later in the process:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`expressionList` 方法解析表达式列表。与前面的名称列表情况不同，我们不返回列表本身，只返回其大小。表达式生成自己的指令，其值在后续过程中由评估器存储在栈上：'
- en: '[PRE57]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We iterate as long as we do not encounter a right parenthesis:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会一直迭代，直到遇到右括号：
- en: '[PRE58]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After parsing the expression, we check whether the next token is a right parenthesis.
    If it is, the expression list is finished and we break the iteration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解析表达式后，我们检查下一个标记是否是右括号。如果是，表达式列表就完成了，我们中断迭代：
- en: '[PRE59]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the next token is not a right parenthesis, we assume it is a comma, match
    it, and continue the iteration:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下一个标记不是右括号，我们假设它是一个逗号，匹配它，并继续迭代：
- en: '[PRE60]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, after the iteration, we return the number of expressions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，经过迭代后，我们返回表达式的数量：
- en: '[PRE61]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The evaluator
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估器
- en: The **evaluator** evaluates a sequence of directives and generates a list of
    actions that are later read and executed by the viewer. The evaluation starts
    with the directive on the first line, which is a jump to the start address of
    the `main` function. The evaluation stops when it encounters a `return` directive
    without a return address. In that case, we have reached the end of `main` and
    the execution shall be finished.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**评估器**评估一系列指令并生成一个列表，该列表稍后由查看器读取和执行。评估从第一行的指令开始，该指令是跳转到 `main` 函数的起始地址。评估在遇到没有返回地址的
    `return` 指令时停止。在这种情况下，我们已经到达 `main` 的末尾，执行应该完成。'
- en: The evaluator works against a stack of values. Each time a value has been evaluated
    it is pushed on the stack, and each time values are needed to evaluate an expression
    they are popped from the stack.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 评估器针对值栈进行操作。每次评估一个值时，它就会被推入栈中，每次需要值来评估表达式时，它们就会从栈中弹出。
- en: '**Evaluator.h:**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**Evaluator.h:** '
- en: '[PRE62]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The constructor of the `Evaluator` class evaluates the directive list with
    the help of the functions map:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evaluator` 类的构造函数使用函数映射评估指令列表：'
- en: '[PRE63]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `checkType` and `evaluate` methods are identical to the previous chapter.
    They have been moved from `Parser` to `Evaluator`. The `checkType` methods check
    that the expressions associated with the token have the correct types, and the
    `evaluate` methods evaluates the expressions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkType` 和 `evaluate` 方法与上一章相同。它们已从 `Parser` 移至 `Evaluator`。`checkType`
    方法检查与标记关联的表达式是否具有正确的类型，而 `evaluate` 方法评估表达式：'
- en: '[PRE64]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When an expression is being evaluated, its value is pushed on `m_valueStack`.
    When a variable is assigned a value, its name and the value are stored in `m_valueMap`.
    Note that, in this chapter, a value can be assigned to a variable more than once.
    When a function calls another function, the value map of the calling function
    is pushed on `m_valueMapStack` in order to give the called function a fresh value
    map, and the return address is pushed on `m_returnAddressStack`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当评估一个表达式时，其值会被推入 `m_valueStack`。当一个变量被赋予一个值时，其名称和值会被存储在 `m_valueMap` 中。请注意，在本章中，一个值可以被赋予一个变量多次。当一个函数调用另一个函数时，调用函数的值映射会被推入
    `m_valueMapStack` 以给被调用函数提供一个全新的值映射，并且返回地址会被推入 `m_returnAddressStack`：
- en: '[PRE65]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `Evaluator.cpp` file holds the definitions of the methods of the `Evaluator`
    class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evaluator.cpp`文件包含`Evaluator`类的方法定义：'
- en: '**Evaluator.cpp:**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Evaluator.cpp:** '
- en: '[PRE66]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The constructor of the `Evaluator` class can be regarded as the heart of the
    evaluator.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evaluator`类的构造函数可以被视为评估器的核心。'
- en: 'The `directiveIndex` field in the constructor is the index of the current `Directive`
    object in the directive list. Normally, it is increased for each iteration. However,
    it can be assigned different values due to `if` or `while` instructions as well
    as function calls and returns:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的`directiveIndex`字段是指令列表中当前`Directive`对象的索引。通常，它会在每次迭代中增加。然而，由于`if`或`while`指令以及函数调用和返回，它也可以被赋予不同的值：
- en: '[PRE67]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When a function is called, we start by looking up the function name in the
    function map and report a semantic error if we do not find it. Then we check that
    the number of actual parameters equals the number of formal parameters (the size
    of the name list in the `Function` object):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，我们首先在函数映射中查找函数名，如果没有找到则报告语义错误。然后我们检查实际参数的数量是否等于形式参数的数量（`Function`对象中名称列表的大小）：
- en: '[PRE68]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When we call the function, we push the index of the next directive on the return
    address stack, so that the called function can return to the correct address.
    We push the value map of the calling function at the value map stack, so we can
    retrieve it after the call. We then clear the value map so that it is fresh to
    be used by the called function. Finally, we set the directive index to the start
    address of the called function, which moves the control to the beginning of the
    called function. Note that we do nothing about the actual parameter expressions.
    They have already been evaluated, and their values are pushed at the value stack:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，我们在返回地址栈上推送下一个指令的索引，以便被调用的函数可以返回到正确的地址。我们在值映射栈上推送调用函数的值映射，以便在调用后检索它。然后我们清除值映射，以便它对被调用的函数是新鲜的。最后，我们将指令索引设置为被调用函数的起始地址，这会将控制权转移到被调用函数的开始处。请注意，我们对实际参数表达式没有做任何事情。它们已经被评估，并且它们的值被推送到值栈上：
- en: '[PRE69]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'At the beginning of a function, we pop the value stack for each parameter and
    associate each parameter name with its value in the value map. Remember that the
    parameter expressions were evaluated before the call to the function, and that
    their values were pushed on the value stack. Also remember that the first parameter
    was pushed first and is placed below the other parameters in the stack, which
    is why we assign the parameters in reverse order. Finally, remember that the value
    map of the calling function was pushed on the value map stack, and that the value
    stack was cleared during the function call, so that the current value map is empty
    at the beginning of the function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开始时，我们为每个参数弹出值栈，并将每个参数名与其值在值映射中关联。记住，在调用函数之前已经评估了参数表达式，并且它们的值被推送到值栈上。还要记住，第一个参数首先被推送到栈上，并且位于其他参数的下方，这就是为什么我们以相反的顺序分配参数。最后，记住调用函数时值映射被推送到值映射栈上，值栈在函数调用期间被清除，因此在函数开始时当前值映射为空：
- en: '[PRE70]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When returning from a function, we first check whether the return address stack
    is empty. If it is not empty, we perform a normal function return. We restore
    the value map of the calling function by popping the value map stack. We also
    set the directive index to the address following the function call by popping
    the return address stack:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当从函数返回时，我们首先检查返回地址栈是否为空。如果不为空，我们执行正常的函数返回。通过弹出值映射栈，我们恢复调用函数的值映射。我们还通过弹出返回地址栈将指令索引设置为函数调用后的地址：
- en: '[PRE71]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the return address stack is empty, however, we have a special case—we have
    reached the end of the `main` function. In that case, we shall not return to a
    calling function (there is no calling function). Instead, we shall just finish
    the execution of the evaluator by calling return. Remember that we are in the
    constructor of the `Evaluator` class, and that we return from the constructor:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果返回地址栈为空，我们有一个特殊情况——我们已经到达了`main`函数的末尾。在这种情况下，我们不应返回到调用函数（没有调用函数）。相反，我们应通过调用返回来完成评估器的执行。记住，我们处于`Evaluator`类的构造函数中，并且从构造函数返回：
- en: '[PRE72]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `IfNotGoto` directive has been added by the parser when parsing the `if`
    or `while` instructions. We pop the value stack; if it is false we perform a jump
    by setting the directive index by calling the `address` method of the directive.
    Remember that we, in this chapter, have added Boolean values to the `Value` class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`IfNotGoto` 指令是在解析 `if` 或 `while` 指令时由解析器添加的。我们弹出值栈；如果值为假，我们通过调用指令的 `address`
    方法来设置指令索引以执行跳转。记住，在本章中，我们已经向 `Value` 类添加了布尔值：'
- en: '[PRE73]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If the value is true, we do not perform a jump; we simply increase the directive
    index:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值为真，我们不执行跳转；我们只是简单地增加指令索引：
- en: '[PRE74]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `Goto` directive performs an unconditional jump; we simply set the new
    directive index. Since the `IfNotGoto` and `Goto` directives have been generated
    by the parser, we do not need to perform any type checking:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Goto` 指令执行无条件跳转；我们只需设置新的指令索引。由于 `IfNotGoto` 和 `Goto` 指令是由解析器生成的，我们不需要执行任何类型检查：'
- en: '[PRE75]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The set directives work in a way corresponding to the parser of the previous
    chapter. The value of the expression has been pushed to the value stack during
    the evaluation of an earlier directive. We pop the value of the value stack and
    check that it holds the correct type. Then we add the action with the value to
    the action list and increase the directive index:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 设置指令的工作方式与上一章中的解析器相对应。在早期指令的评估过程中，表达式的值已经推入值栈。我们从值栈中弹出值并检查它是否包含正确的类型。然后我们将带有值的操作添加到操作列表中并增加指令索引：
- en: '[PRE76]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Also, the draw directives are similar to the parser in the previous chapter.
    Their first and second value are popped in reverse order, since the first value
    was pushed first and thereby is placed below the second value on the stack. We
    then check that the values have correct types, add the action to the action list,
    and increase the directive index:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，绘图指令与上一章中的解析器类似。它们的第一个和第二个值以相反的顺序弹出，因为第一个值首先被推入，因此位于栈中的第二个值下方。然后我们检查值是否具有正确的类型，将操作添加到操作列表中，并增加指令索引：
- en: '[PRE77]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The assignment directive associates a name with the value in the value map.
    Note that if the name already has been associated with a value, the previous value
    is overwritten. Also note that the value map is local to the current function,
    potential calling functions have their own value maps pushed on the value map
    stack:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值指令将名称与值映射中的值关联起来。请注意，如果名称已经与一个值关联，则之前的值将被覆盖。另外请注意，值映射是当前函数的局部变量，潜在的调用函数有自己的值映射推入值映射栈：
- en: '[PRE78]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In an expression with one value, its value is popped from the stack, its type
    is checked, and the resulting value of the expression is evaluated and pushed
    on the value stack. Finally, the directive index is increased:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含一个值的表达式中，其值从栈中弹出，检查其类型，并计算表达式的结果值并将其推入值栈。最后，增加指令索引：
- en: '[PRE79]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In an expression with two values, its first and second value are popped from
    the stack (in reverse order), their types are checked, and the resulting value
    of the expression is evaluated and pushed on the value stack. Finally, the directive
    index is increased:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含两个值的表达式中，其第一个和第二个值从栈中弹出（顺序相反），检查它们的类型，并计算表达式的结果值并将其推入值栈。最后，增加指令索引：
- en: '[PRE80]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In a color expression, the red, green, and blue component values are popped
    from the value stack (in reverse order), their types are checked, and the resulting
    color is pushed on the value stack. Finally, the directive index is increased:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在颜色表达式中，红色、绿色和蓝色组件值从值栈中弹出（顺序相反），检查它们的类型，并将结果颜色推入值栈。最后，增加指令索引：
- en: '[PRE81]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In a font expression, the values of the name and size are popped from the value
    stack (in reverse order) and their types are checked. The resulting font is pushed
    on the value stack and the directive index is increased:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在字体表达式中，名称和大小值从值栈中弹出（顺序相反）并检查它们的类型。然后将结果字体推入值栈并增加指令索引：
- en: '[PRE82]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In the case of a name, we look up its value and push it on the value stack
    and increase the directive index. If there is no value associated with the name,
    a semantic error is reported:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称的情况下，我们查找其值并将其推入值栈，并增加指令索引。如果没有与名称关联的值，则报告语义错误：
- en: '[PRE83]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Finally, when we have a value, we just push it on the value stack and increase
    the directive index:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们有一个值时，我们只需将其推入值栈并增加指令索引：
- en: '[PRE84]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The main function
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: Finally, the `main` function is almost identical to the previous function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main` 函数几乎与上一个函数相同。
- en: '**Main.cpp:**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE85]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The only difference is that the parser generates a sequence of directives rather
    than actions, as well as a function map, which is sent to the evaluator that generates
    the final action list that is read and executed by the viewer that displays the
    graphical objects:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于，解析器生成一系列指令而不是动作，以及一个函数映射，这些被发送到评估器，评估器生成最终的动作列表，该列表被读取和执行以显示图形对象：
- en: '[PRE86]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have improved the DSL that we started to work on in the
    previous chapter. We have added selection, iteration, variables, and function
    calls. We have also added the evaluator, which takes the directives generated
    by the parser and generates the actions read and executed by the viewer. When
    the directives are being executed, the values of the expressions are stored on
    a stack, the values assigned to names are stored in a map, and the return address
    of function calls are stored on a stack.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们改进了我们在上一章开始工作的领域特定语言（DSL）。我们添加了选择、迭代、变量和函数调用。我们还添加了评估器，它接收解析器生成的指令，并生成由查看器读取和执行的动作。当指令正在执行时，表达式的值存储在栈上，分配给名称的值存储在映射中，函数调用的返回地址存储在栈上。
- en: This was the final chapter, I hope you have enjoyed the book!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最后一章了，希望你喜欢这本书！
