- en: Advanced Domain-Specific Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we developed a **domain-specific language** (**DSL**).
    In this chapter, we will improve the language in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: We will add **selection** and **iteration**. More specifically, we will add
    the `if` and `while` instructions. In the language of the previous chapter, the
    actions were executed in a straightforward manner. In this chapter, it is possible
    to select between alternatives and to iterate over a part of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will add **variables**. In the previous chapter, we could assign values to
    a name once. In this chapter, however, values are assigned to names that can be
    reassigned during the execution of the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add **functions**, with parameters and return values. In the previous chapter,
    a program was made up of a sequence of instructions. In this chapter, it is a
    sequence of functions. Similar to C++, there must be a `main` function where the
    execution starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will add another module in the process from the source code to the viewer.
    In the previous chapter, the parser generated a sequence of actions that were
    displayed by the viewer. In this chapter, the parser generates a sequence of **directives**,
    which in turn are evaluated to actions by the **evaluator**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the language of this chapter supports selection, iteration, variables,
    and functions calls, it starts to look like a traditional programming language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Topics we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Just as in the previous chapter, we will informally look into the source code
    of our DSL by looking at an example. However, in this example we will use variables
    and function calls, we will also use the `if` and `while` instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will then formally define our language with **grammar**. The grammar is an
    extension of the grammar of the last chapter. We will add instructions for functions
    definitions, calls, and returns, as well as selection (`if`) and iteration (`while`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have defined the grammar, we will write the **scanner**. The scanner
    of this chapter is almost identical to the scanner of the previous chapter. The
    only difference is that we will add a few keywords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have written the scanner, we will write the **parser**. The parser is
    an extension of the parser of the previous chapter, we add methods for functions,
    selection, and iteration. However, the parser of the previous chapter generated
    a sequence of **actions**, which were read and executed by the **viewer**. In
    this chapter, however, the parser instead generates a sequence of directives that
    are read by the evaluator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, the next step is the evaluator rather than the viewer. The
    evaluator takes the directive sequence generated by the parser, and generates
    a sequence of actions which are read and executed by the viewer. The evaluator
    works with maps that assign values to names. There is a **stack of value maps**
    that make sure that each called function gets its own fresh value map. There is
    also a **value stack** that stores temporary values when evaluating expressions.
    Finally, there is the **call stack**, holding return addresses for function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the viewer works in the same way as in the previous chapter. It iterates
    through the action list generated by the evaluator and displays the graphical
    objects in a Qt widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the source language – an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a new example, where we define and call a function named `triangle`
    that draws a triangle with different pens in different sizes. Note that the functions
    do not have to occur in any particular order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by setting the `left` and `length` variables to `50`. They hold the
    *x* coordinate of the left-most corner of the first triangle, and its base length.
    We also set the `index` variable to zero; its value will be used in the `while`
    iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue to iterate as long as `index` is less than four. Note that in this
    chapter we add Boolean values to the `Value` class. When `index` holds an even
    value, we set the pen style to a solid line, and when it holds an odd value, we
    set the pen style to a dashed line. Note that we have extended the language with
    relational expressions and the modulus (`%`) operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the top-left point of the triangle, and call the `drawTriangle` function
    to perform the actual drawing of the triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the call to `triangle`, we increase the base length of the next triangle,
    and the left-most corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `drawTriangle` function, we call `getTopRight` and `getBottomMiddle`
    functions to obtain the top-right and bottom-middle points of the triangle. Finally,
    we draw the three lines of the triangle by calling `drawLine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getTopRight` function extracts the *x* and *y* coordinate of the top-left
    point, and returns a point where the *x* coordinate has been increased by the
    length of the base of the triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getBottomMiddle` function also extracts the *x* and *y* coordinates of
    the top-left point. Then it calculates the *x* and *y* coordinates of the middle-bottom
    point and returns `point`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the execution of the code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f238186-dcca-40cf-8b90-2a24bbf9da4d.png)'
  prefs: []
  type: TYPE_IMG
- en: Improving the grammar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will improve the grammar of our language. To begin with,
    a program is made up by a sequence of functions rather than instructions. Technically,
    a program can hold zero functions. However, a semantic error will report that
    the `main` function is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of a function is made up by the keyword `function`, a list of
    names enclosed by parentheses and a list of instructions enclosed by brackets.
    The `nameList` is made up of zero or more names, separated by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to instructions, we add the calling of a function. We can either
    call the function directly, as an instruction (`call``drawTriangle` in the preceding
    example), or as a part of an expression (`callgetTopRight` and `call``getBottomMiddle`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also add the `while` instruction and the `if` instructions, with or without
    the `else` part. Finally, there is also the block instruction: a list of instructions
    enclosed by brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to expressions, the only difference is that we have added function
    calls. The `expressionList` is a list of zero or more expressions, separated by
    commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Token and the Scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the previous chapter, the final target code of the language is the
    actions, even though they are generated by an evaluator rather than the parser.
    The `Action` class is identical to the class of the previous chapter. So are the
    `Value` and `ViewerWidget` classes, as well as the colors and error handling.
    However, the `Token` and `Scanner` classes have been extended. The `TokenId` enumeration
    has been extended with more token identities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Token.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, `init` in `Scanner` has been extended with the keywords.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scanner.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The parser has been extended with methods corresponding to the new rules of
    the grammar. Moreover, the parser of this chapter does not generate actions; instead,
    it generates **directives**. The reason for this is that, while the source code
    of the previous chapter holds instructions that were executed from the beginning
    to the end, the source code of this chapter holds selection, iteration, and function
    calls that can alter the flow of the instructions. Therefore, it makes sense to
    introduce a middle layer—the parser generates directives that are evaluated to
    become actions.
  prefs: []
  type: TYPE_NORMAL
- en: Since the language of this chapter supports functions, we need the `Function`
    class to store the functions. It stores the names of the formal parameters and
    the start address of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Function.cpp` file holds the definitions of the methods of the `Function`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the parser in this chapter generates a sequence of directives rather than
    actions, we also need the `Directive` class to hold the directives. In most cases,
    a `Directive` object only holds its identity of the `TokenId` enumeration. However,
    in the case of a function call, we need to store the name of the function and
    the number of actual parameters. In the case of a function definition, we store
    a reference to the `Function` object. In the case of an expression made up by
    a name of a value, we need to store the name or value. Finally, there are several
    kinds of jump directives, in which case we need to store the address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Directive.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Directive.cpp` file holds the definitions of the methods of the `Directive`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Directive.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In most cases, we only create an object of the `Directive` class with a directive
    identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The jump directives need the jump address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When assigning a value to a variable, we need the name of the variable. However,
    we do not need the value since it will be stored on a stack. Also, when an expression
    is made up of a name, we need to store the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The directive for function calls needs the name of the function and the number
    of actual parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When an expression is made up simply of a value, we just store the value in
    the directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in a function definition we store an object of the `Function` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Parser` class has been extended with the methods for the new rules in
    the grammar: function definitions and the `if`, `while`, `call`, and `return`
    instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parser.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nameList` method gathers the formal parameters of the function, while
    `expressionList` gathers the actual parameters of the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `callExpression` method has also been added to the `Parser` class, since
    a function can be explicitly called as an **instruction**, or as a part of an
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `Parser.cpp` file holds the definitions of the methods of the `Parser` class.
  prefs: []
  type: TYPE_NORMAL
- en: The start method of the parser of this chapter is `functionDefinitionList`.
    It calls `functionDefinition` as long as it does not reach end-of-file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parser.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `functionDefinition` method parses a function definition. We start by matching
    the `function` keyword and store the name of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The function name is followed by the parameter name list enclosed by parenthesis.
    We store the name list in the `nList` field. We cannot call the field `nameList`,
    since that name has already been taken by the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We store the current size of the directive list size as the start address of
    the function, create a `Function` object with the name list and start address,
    and add a `Directive` object with the function to the directive list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The name list is followed by a list of instructions enclosed by brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to be sure the function really returns the controls back to the calling
    function, we add a `Directive` object with the `return` token identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When the function has been defined, we check that there is no other function
    with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function is named `"main"`, it is the start function of the program
    and it cannot have parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the function to the `functionMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nameList` method parses a comma-separated list of names enclosed in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue as long as we do not encounter a right parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have matched the name, we check whether the next token is a right
    parenthesis. If it is, we have reached the end of the name list and break the
    iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If the next token is not a right parenthesis, we instead assume that it is
    a comma, match it, and continue to iterate with the next expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, before we return the name list, we need to check that no name occurs
    twice in the name list. We iterate through the name list and add the names to
    a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `instructionList` method looks a little bit different in this chapter since
    it is placed inside a block of instructions. We iterate as long as we do not encounter
    a right bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As a function can be explicitly called as an instruction, or as part of an
    expression, we simply call `callExpression` and match the semicolon in the case
    of a call instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the return instruction, we match the `return` keyword and check whether
    it is followed by a semicolon. If it is not followed by a semicolon, we parse
    an expression and then assume that the next token is a semicolon. Note that we
    do not store the result of the expression. The evaluator will place its value
    on a stack later in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the `if` keyword, we match it and parse an expression enclosed
    by parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If the expression becomes evaluated to a false value, we shall jump over the
    instruction following the `if` expression. Therefore, we add a `IfNotGoto` directive,
    intending to jump over the instruction following the `if` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If the instruction is followed by the `else` keyword, we match it and add a
    `Goto` directive, that is intended to jump over the `else` part in the case of
    a true value of the expression of the `if` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We then set the jump address of the preceding `IfNotTrue` directive. If the
    expression is not true, the program shall jump to this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if the expression of the `if` instruction is true, the program
    shall jump over the `else` part to this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `if` instruction is not followed by the `else` keyword, it shall jump
    to this point in the program if the expression is not true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the `while` keyword, we match it and store the current index
    of the directive list in order for the program to jump back to this point after
    every iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We then parse the expression and its enclosing parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case that the expression is not true, we add an `IfNotGoto` directive
    in order for the program to jump out of the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a `Goto` directive after the instruction following the `while` expression,
    so that the program can jump back to the expression at the end of each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set the address of the `IfNotTrue` directive at the beginning of
    the `while` instruction, so that it can jump to this point in the program if the
    expression is not true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a left bracket, we have a sequence of instructions enclosed
    by brackets. We parse the pair of brackets and call `instructionList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the case of a name, we have an assignment. We match the `name`
    keyword, and the assignment operator (`=`), parse the expression, and match the
    semicolon. We then add an `Assign` object to the directive list holding the name
    to be assigned a value. Note that we do not store the value of the expression,
    since it will be pushed on a value stack by the evaluator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `callExpression` method matches the `call` keyword, stores the name of
    the function, parses the parameter expressions, and adds a `Directive` object
    holding the call to the directive list. Note that we do not check whether the
    function exists or count the number of parameters at this point, since the function
    may be not yet defined. All type checking is taken care of by the evaluator later
    in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `expressionList` method parses a list of expressions. Unlike the preceding
    name list case, we do not return the list itself, only its size. The expressions
    generate directives of their own, their values are stored on a stack by the evaluator
    later in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate as long as we do not encounter a right parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After parsing the expression, we check whether the next token is a right parenthesis.
    If it is, the expression list is finished and we break the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If the next token is not a right parenthesis, we assume it is a comma, match
    it, and continue the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after the iteration, we return the number of expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The evaluator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **evaluator** evaluates a sequence of directives and generates a list of
    actions that are later read and executed by the viewer. The evaluation starts
    with the directive on the first line, which is a jump to the start address of
    the `main` function. The evaluation stops when it encounters a `return` directive
    without a return address. In that case, we have reached the end of `main` and
    the execution shall be finished.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluator works against a stack of values. Each time a value has been evaluated
    it is pushed on the stack, and each time values are needed to evaluate an expression
    they are popped from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Evaluator.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of the `Evaluator` class evaluates the directive list with
    the help of the functions map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkType` and `evaluate` methods are identical to the previous chapter.
    They have been moved from `Parser` to `Evaluator`. The `checkType` methods check
    that the expressions associated with the token have the correct types, and the
    `evaluate` methods evaluates the expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When an expression is being evaluated, its value is pushed on `m_valueStack`.
    When a variable is assigned a value, its name and the value are stored in `m_valueMap`.
    Note that, in this chapter, a value can be assigned to a variable more than once.
    When a function calls another function, the value map of the calling function
    is pushed on `m_valueMapStack` in order to give the called function a fresh value
    map, and the return address is pushed on `m_returnAddressStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Evaluator.cpp` file holds the definitions of the methods of the `Evaluator`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Evaluator.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of the `Evaluator` class can be regarded as the heart of the
    evaluator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `directiveIndex` field in the constructor is the index of the current `Directive`
    object in the directive list. Normally, it is increased for each iteration. However,
    it can be assigned different values due to `if` or `while` instructions as well
    as function calls and returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'When a function is called, we start by looking up the function name in the
    function map and report a semantic error if we do not find it. Then we check that
    the number of actual parameters equals the number of formal parameters (the size
    of the name list in the `Function` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the function, we push the index of the next directive on the return
    address stack, so that the called function can return to the correct address.
    We push the value map of the calling function at the value map stack, so we can
    retrieve it after the call. We then clear the value map so that it is fresh to
    be used by the called function. Finally, we set the directive index to the start
    address of the called function, which moves the control to the beginning of the
    called function. Note that we do nothing about the actual parameter expressions.
    They have already been evaluated, and their values are pushed at the value stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of a function, we pop the value stack for each parameter and
    associate each parameter name with its value in the value map. Remember that the
    parameter expressions were evaluated before the call to the function, and that
    their values were pushed on the value stack. Also remember that the first parameter
    was pushed first and is placed below the other parameters in the stack, which
    is why we assign the parameters in reverse order. Finally, remember that the value
    map of the calling function was pushed on the value map stack, and that the value
    stack was cleared during the function call, so that the current value map is empty
    at the beginning of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'When returning from a function, we first check whether the return address stack
    is empty. If it is not empty, we perform a normal function return. We restore
    the value map of the calling function by popping the value map stack. We also
    set the directive index to the address following the function call by popping
    the return address stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If the return address stack is empty, however, we have a special case—we have
    reached the end of the `main` function. In that case, we shall not return to a
    calling function (there is no calling function). Instead, we shall just finish
    the execution of the evaluator by calling return. Remember that we are in the
    constructor of the `Evaluator` class, and that we return from the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IfNotGoto` directive has been added by the parser when parsing the `if`
    or `while` instructions. We pop the value stack; if it is false we perform a jump
    by setting the directive index by calling the `address` method of the directive.
    Remember that we, in this chapter, have added Boolean values to the `Value` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value is true, we do not perform a jump; we simply increase the directive
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Goto` directive performs an unconditional jump; we simply set the new
    directive index. Since the `IfNotGoto` and `Goto` directives have been generated
    by the parser, we do not need to perform any type checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The set directives work in a way corresponding to the parser of the previous
    chapter. The value of the expression has been pushed to the value stack during
    the evaluation of an earlier directive. We pop the value of the value stack and
    check that it holds the correct type. Then we add the action with the value to
    the action list and increase the directive index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the draw directives are similar to the parser in the previous chapter.
    Their first and second value are popped in reverse order, since the first value
    was pushed first and thereby is placed below the second value on the stack. We
    then check that the values have correct types, add the action to the action list,
    and increase the directive index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The assignment directive associates a name with the value in the value map.
    Note that if the name already has been associated with a value, the previous value
    is overwritten. Also note that the value map is local to the current function,
    potential calling functions have their own value maps pushed on the value map
    stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In an expression with one value, its value is popped from the stack, its type
    is checked, and the resulting value of the expression is evaluated and pushed
    on the value stack. Finally, the directive index is increased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In an expression with two values, its first and second value are popped from
    the stack (in reverse order), their types are checked, and the resulting value
    of the expression is evaluated and pushed on the value stack. Finally, the directive
    index is increased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'In a color expression, the red, green, and blue component values are popped
    from the value stack (in reverse order), their types are checked, and the resulting
    color is pushed on the value stack. Finally, the directive index is increased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In a font expression, the values of the name and size are popped from the value
    stack (in reverse order) and their types are checked. The resulting font is pushed
    on the value stack and the directive index is increased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a name, we look up its value and push it on the value stack
    and increase the directive index. If there is no value associated with the name,
    a semantic error is reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when we have a value, we just push it on the value stack and increase
    the directive index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, the `main` function is almost identical to the previous function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference is that the parser generates a sequence of directives rather
    than actions, as well as a function map, which is sent to the evaluator that generates
    the final action list that is read and executed by the viewer that displays the
    graphical objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have improved the DSL that we started to work on in the
    previous chapter. We have added selection, iteration, variables, and function
    calls. We have also added the evaluator, which takes the directives generated
    by the parser and generates the actions read and executed by the viewer. When
    the directives are being executed, the values of the expressions are stored on
    a stack, the values assigned to names are stored in a map, and the return address
    of function calls are stored on a stack.
  prefs: []
  type: TYPE_NORMAL
- en: This was the final chapter, I hope you have enjoyed the book!
  prefs: []
  type: TYPE_NORMAL
