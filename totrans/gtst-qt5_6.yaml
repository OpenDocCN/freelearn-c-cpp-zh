- en: Connecting Qt with Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Qt与数据库连接
- en: In recent times, most applications integrate with some database for storing
    information for further processing and future use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，大多数应用程序都会集成一些数据库来存储信息，以便进行进一步处理和未来使用。
- en: Qt comes with modules and classes that make connecting to databases effortless.
    The MySql database will be used to illustrate the examples in this chapter, but
    the same principles will apply to other databases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qt附带了一些模块和类，使得连接到数据库变得轻而易举。本章将使用MySql数据库来演示示例，但相同的原理也适用于其他数据库。
- en: 'By the end of this chapter, you should be able to perform the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够执行以下操作：
- en: Connect and read from a database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到数据库并读取
- en: Display and edit database entries via widgets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过小部件显示和编辑数据库条目
- en: QtSql
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QtSql
- en: The QtSql module comes equipped with classes and drivers for accessing databases.
    To proceed beyond this point, you should have made the necessary configuration
    during the installation of Qt on your system to enable database access.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: QtSql模块配备了访问数据库的类和驱动程序。要继续前进，你应该在系统上安装Qt时进行了必要的配置，以启用数据库访问。
- en: For those on the macOS using Homebrew, remember to issue the command as previously
    described in [Chapter 1](a157893d-287f-42c4-8166-a7d414e09035.xhtml), *Introducing
    Qt 5*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用Homebrew的macOS用户，请记住按照[第1章](a157893d-287f-42c4-8166-a7d414e09035.xhtml)，“Qt
    5简介”中先前描述的命令执行。
- en: Linux users have to install the modules and enable the correct flags during
    compilation to make the QtSql module work, but, for the most part, the instructions
    in [Chapter 1](a157893d-287f-42c4-8166-a7d414e09035.xhtml), *Introducing Qt 5*,
    should suffice.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux用户，必须在编译时安装模块并启用正确的标志，以便QtSql模块能够工作，但大多数情况下，[第1章](a157893d-287f-42c4-8166-a7d414e09035.xhtml)，“Qt
    5简介”中的说明应该足够。
- en: 'The QtSql module is comprised of the following layers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: QtSql模块由以下层组成：
- en: UI layer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面层
- en: SQL API layer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL API层
- en: Driver layer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动层
- en: '![](img/06e23dc6-4fe5-42d8-bc5c-99a5b04d3d7c.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06e23dc6-4fe5-42d8-bc5c-99a5b04d3d7c.jpg)'
- en: Each level makes use of classes, as illustrated in the preceding diagram.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个级别都使用了类，如前图所示。
- en: Making the connection
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立连接
- en: We need to set the grounds for writing our applications, and, in this case,
    we need to have a running instance of MySql. XAMPP is a good candidate to install
    to have quick access to a working database.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为编写我们的应用程序奠定基础，在这种情况下，我们需要有一个运行中的MySql实例。XAMPP是一个很好的候选者，可以快速访问一个工作数据库。
- en: XAMPP is a free and open source, cross-platform web server solution stack package
    developed by Apache Friends, consisting mainly of the Apache HTTP Server, MariaDB
    (or MySql) database, and interpreters for scripts written in the PHP and Perl
    programming languages. Download the latest version from [https://www.apachefriends.org/download.html](https://www.apachefriends.org/download.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: XAMPP是由Apache Friends开发的一个免费开源、跨平台的Web服务器解决方案堆栈包，主要由Apache HTTP服务器、MariaDB（或MySql）数据库以及用于PHP和Perl编程语言脚本的解释器组成。从[https://www.apachefriends.org/download.html](https://www.apachefriends.org/download.html)下载最新版本。
- en: 'Let''s create a database with the following tables by issuing the following
    statements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下语句创建以下表的数据库：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The name of the database is `contact_db`, and it is assumed that you have created
    it in the MySql instance you installed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库名为`contact_db`，假设你已经在安装的MySql实例中创建了它。
- en: The SQL statements create a table called `contacts` with an auto-increment `id`
    field along with,  `last_name`, `first_name`, and `phone_number` fields that store
    characters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语句创建了一个名为`contacts`的表，其中包含一个自增的`id`字段，以及存储字符的`last_name`、`first_name`和`phone_number`字段。
- en: 'Now, create a new folder and add a file called `main.cpp`. Insert the following
    lines of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个新的文件夹，并添加一个名为`main.cpp`的文件。插入以下代码行：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To make database connections, we need to include `QtSql`. `QDebug` provides
    an output stream where we can write out useful (debugging) information during
    development to file, device, or standard output.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立数据库连接，我们需要包含`QtSql`。`QDebug`提供了一个输出流，我们可以在开发过程中将有用的（调试）信息写入文件、设备或标准输出。
- en: In the preceding code, the structure of the database table has been commented
    out, but serves as a reminder in case you have not created it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，数据库表的结构已被注释掉，但作为提醒，以防你没有创建它。
- en: To open a connection to a database, a call to `QSqlDatabase::addDatabase()`
    is made. The `QMYSQL` parameter is the driver type, and `contact_db` is the connection
    name. A program can have a number of connections to the same database. Furthermore,
    the `addDatabase()` call will return an instance of `QSqlDatabase`, which, in
    essence, is the connection to the database.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开到数据库的连接，将调用`QSqlDatabase::addDatabase()`。`QMYSQL`参数是驱动程序类型，`contact_db`是连接名称。一个程序可以与同一数据库有多个连接。此外，`addDatabase()`调用将返回一个`QSqlDatabase`实例，本质上就是数据库的连接。
- en: 'This connection, `db_conn`, is then initialized with the parameters to make
    the connection work. The hostname, specific database we want to connect to, username,
    password, and port number are set on the database connection object, `db_conn`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此连接`db_conn`随后使用使连接工作的参数进行初始化。主机名、我们想要连接的特定数据库、用户名、密码和端口号都设置在数据库连接对象`db_conn`上：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Depending on a number of situations, you may need to specify more than these
    parameters to gain access to a database, but, for the most part, this should work.
    Also, note that the password is an empty string. It is only for illustration purposes.
    You have to change the password as pertains to your database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据不同的情况，您可能需要指定比这些参数更多的信息才能访问数据库，但大多数情况下，这应该可以工作。此外，请注意，密码是一个空字符串。这只是为了说明目的。您必须根据您的数据库更改密码。
- en: 'To make the connection, we need to call `open()` on the connection object:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立连接，我们需要在连接对象上调用`open()`：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A call to `open()` will result in a bool being returned to determine whether
    the connection to the database was successful. `!db_conn.open()` tests whether
    the return value is `False`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`open()`将返回一个布尔值以确定数据库连接是否成功。`!db_conn.open()`测试返回值是否为`False`。
- en: Note the way in which we shall compile and run this program.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们编译和运行此程序的方式。
- en: 'Issue the following on the command line while you are in the folder where the
    `main.cpp` file is locate:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在您位于`main.cpp`文件所在的文件夹中时，在命令行上执行以下操作：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Open the resulting `.pro` file, and add the following lines:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 打开生成的`.pro`文件，并添加以下行：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We intend to use widgets in the course of this chapter, so it has been listed
    as the first module to be included. Likewise, we include the SQL module. Proceed
    with the following commands:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算在本章中使用小部件，因此它已被列为第一个要包含的模块。同样，我们也包括 SQL 模块。继续以下命令：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you get the `Database connection established!` response, then it means your
    program is able to connect to the database smoothly. On the other hand, you may
    get an error, which will describe the reason why the connection is unable to be
    established. Go through the following list to ensure you are on the right path
    when you encounter an error:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到`Database connection established!`的响应，那么这意味着您的程序能够顺利地连接到数据库。另一方面，您可能会收到一个错误，该错误将描述连接无法建立的原因。当您遇到错误时，请通过以下列表确保您处于正确的路径：
- en: Ensure the database service is running
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保数据库服务正在运行
- en: Ensure the database you are trying to connect actually exists
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您尝试连接的数据库实际上存在
- en: Ensure the table given by the schema exists
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保由模式给出的表存在
- en: Ensure the username and password for the database exists
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保数据库的用户名和密码存在
- en: Ensure the Qt was compiled with the MySql module
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保Qt已编译了MySql模块
- en: Now, let's update the program so that we can illustrate how to issue the various
    SQL statements in Qt.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新程序，以便我们可以展示如何在 Qt 中发出各种 SQL 语句。
- en: Listing records
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出记录
- en: In order to execute query statements against the database, we shall make use
    of the `QSqlQuery` class. These statements include data-altering statements, such
    as `INSERT`, `SELECT`, and `UPDATE`. Data definition statements such as `CREATE
    TABLE` can also be issued.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对数据库执行查询语句，我们将使用`QSqlQuery`类。这些语句包括数据更改语句，如`INSERT`、`SELECT`和`UPDATE`。也可以发出数据定义语句，如`CREATE
    TABLE`。
- en: 'Consider the following snippet of code to list all entries within the contacts
    table:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段以列出联系人表中的所有条目：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The query statement and the database connection are passed as parameters to
    an instance of the `QSqlQuery` statement. `QSqlRecord` is used to encapsulate
    a database row or view. We shall use its instance, `record`, to get the index
    of a column in a row. `statement.record()` returns field information for the current
    query.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语句和数据库连接作为参数传递给`QSqlQuery`语句的一个实例。`QSqlRecord`用于封装数据库行或视图。我们将使用其实例`record`来获取行中列的索引。`statement.record()`返回当前查询的字段信息。
- en: If there are any rows that match the query in `statement`, `statement.next()`
    will allow us to cycle through the returned rows. We can call `previous()`, `first()`,
    and `last()` to enable us to move back and forth with the returned rows or data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`statement`中有任何与查询匹配的行，`statement.next()`将允许我们遍历返回的行。我们可以调用`previous()`、`first()`和`last()`来使我们能够前后移动返回的行或数据。
- en: For each row that is returned and accessed by calling `statement.next()`, the
    `statement` object is used to get its corresponding data according to the code,
    `statement.value(0).toString()`. This should return the first column in the row
    converted to string to be stored in `firstName`. Instead of this approach, we
    can use `record`, to obtain the index of the column we are interested in. As such,
    to extract the first name column, we write `statement.value(record.indexOf("first_name")).toString()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每行通过调用`statement.next()`返回并访问的行，使用`statement`对象根据代码`statement.value(0).toString()`获取其对应的数据。这应该返回第一列转换为字符串以存储在`firstName`中。而不是这种方法，我们可以使用`record`来获取我们感兴趣的列的索引。因此，为了提取姓名列，我们编写`statement.value(record.indexOf("first_name")).toString()`。
- en: The `qDebug()` call helps to print out the data in `firstName`, `lastName`,
    and `phoneNumber`, similar to what we would have done using `cout`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`qDebug()`调用有助于打印出`firstName`、`lastName`和`phoneNumber`中的数据，类似于我们使用`cout`所做的那样。'
- en: The INSERT operation
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`INSERT`操作'
- en: To effect a database operation to store data into the database, there are a
    number of ways to issue out the `INSERT` statement.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行数据库操作并将数据存储到数据库中，有几种方式可以发出`INSERT`语句。
- en: 'Consider one form of the `INSERT` operation in Qt:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑Qt中`INSERT`操作的一种形式：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `QSqlQuery` object, `insert_statement`, is instantiated by passing the database
    connection. Next, the `INSERT` statement string is passed to a call to `prepare()`.
    Notice how incomplete our statement is with the use of the three (3) `?, ?, ?`
    (question marks). These question marks will be used as placeholders. To fill these
    placeholders, the `addBindValue()` method is called. The line, `insert_statement.addBindValue("Sidle")`,
    will be used to fill the data in the `last_name` column of the `contacts` table.
    The second call to `addBindValue("Sara")` will be used to fill the second placeholder.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSqlQuery`对象`insert_statement`通过传递数据库连接来实例化。接下来，将`INSERT`语句字符串传递给`prepare()`方法的调用。注意，我们如何使用三个（3）`?,
    ?, ?`（问号）来使我们的语句不完整。这些问号将被用作占位符。为了填充这些占位符，将调用`addBindValue()`方法。`insert_statement.addBindValue("Sidle")`这一行将用于填充`contacts`表中的`last_name`列中的数据。对`addBindValue("Sara")`的第二次调用将用于填充第二个占位符。'
- en: To execute the statement, the `insert_statement.exec()` must be called. The
    overall effect is that a new record will be inserted into the table.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行语句，必须调用`insert_statement.exec()`。整体效果是在表中插入一条新记录。
- en: 'To change the order in which the data is inserted, we can use the `insert_statement.bindValue()`
    function instead. The `INSERT` statement has three (3) positional placeholders,
    which number from `0` up to `2`. We can fill the last placeholder first by specifying
    it as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变插入数据顺序，我们可以使用`insert_statement.bindValue()`函数。`INSERT`语句有三个（3）位置占位符，编号从`0`到`2`。我们可以首先填充最后一个占位符，如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The placeholder for the phone number column is filled first by specifying `bind(2,
    "+144758849555")`, where `2` is the index of the `(phone_number)` placeholder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 电话号码列的占位符首先通过指定`bind(2, "+144758849555")`来填充，其中`2`是`(phone_number)`占位符的索引。
- en: 'An alternative to using the positions of the placeholders would be to name
    them. Consider the following `INSERT` statement:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用占位符的位置作为替代方案的一种方法是命名它们。考虑以下`INSERT`语句：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instead of using the index of the position when completing the SQL statement,
    named placeholders are used to reference the data in the `VALUES` part. That way,
    the name of the placeholders are passed with a corresponding value to every call
    to `bindValue()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成SQL语句时，而不是使用占位符的位置索引，使用命名占位符来引用`VALUES`部分中的数据。这样，占位符的名称与相应的值一起传递到每个`bindValue()`调用。
- en: To persist the data, the `insert_statement.exec()` function must be called.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要持久化数据，必须调用`insert_statement.exec()`函数。
- en: The DELETE operation
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`DELETE`操作'
- en: The `DELETE` operation is another operation that can be performed on a table.
    To do so, we shall pass a reference to the database connection and pass the `DELETE`
    statement to the `exec()` method of `QSqlQuery`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`操作是可以在表上执行的其他操作之一。为此，我们需要传递数据库连接的引用，并将`DELETE`语句传递给`QSqlQuery`的`exec()`方法。'
- en: 'Consider the following snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`numRowsAffected()` is a method that is used to figure out how many records
    were affected. One benefit of this method is that it helps determine whether our
    query has changed the database. If it returns `-1`, it means that the query''s
    operation produced indeterminate results.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`numRowsAffected()` 是一个用于确定影响了多少记录的方法。这个方法的一个好处是它有助于确定我们的查询是否改变了数据库。如果它返回 `-1`，则意味着查询的操作产生了不确定的结果。'
- en: The UPDATE operation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新操作
- en: 'The `UPDATE` operation follows the same logic as the `DELETE` operation. Consider
    the following lines of code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPDATE` 操作遵循与 `DELETE` 操作相同的逻辑。考虑以下代码行：'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The statement here sets the `first_name` of the record with an ID of `1` to
    `'Jude'`. `update_statement.numRowsAffected()` will return nothing, especially
    in the case where the first record in the table with `id=1` is missing. Do take
    note of this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的语句将 ID 为 `1` 的记录的 `first_name` 设置为 `'Jude'`。`update_statement.numRowsAffected()`
    将返回空值，尤其是在表中的第一条记录 `id=1` 缺失的情况下。请特别注意这一点。
- en: 'The full program to illustrate the major operations is outlined as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下概述了展示主要操作的完整程序：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of particular importance is how the database table is created. From the preceding
    code listing, the `QString` instance, `table_definition`, holds the structure
    of the table we are about to create. The table is created when `table_definition`
    and the database connection are passed to an instance of `QSqlQuery`. That's all
    it takes to create a table.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的是数据库表的创建方式。从前面的代码列表中，`QString` 实例 `table_definition` 保存了我们即将创建的表的结构。当 `table_definition`
    和数据库连接传递给 `QSqlQuery` 的一个实例时，表就创建了。这就是创建表的全部过程。
- en: Compile and run the program.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行程序。
- en: Remember to edit the `.pro` file to include the `sql` module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 记得编辑 `.pro` 文件以包含 `sql` 模块。
- en: 'A typical output of the program run from the command is given as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行程序的典型输出如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using a data model for database access
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据模型进行数据库访问
- en: There are two classes that can be used in accessing the database. These are
    the `QSqlTableModel` and  `QSqlQueryModel` classes. The `QSqlQueryModel` class
    only provides a read-only model to the database. `QSqlTableModel` provides both
    read and write model access to the database.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个类可以用于访问数据库。这些是 `QSqlTableModel` 和 `QSqlQueryModel` 类。`QSqlQueryModel` 类仅向数据库提供只读模型。`QSqlTableModel`
    提供对数据库的读写模型访问。
- en: In application development, you are confronted with the challenge of how to
    present data and to maintain a relationship between data and presentation (view)
    such that changes to the data are reflected in the view.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发中，你面临着一个挑战，那就是如何展示数据，以及如何维护数据与展示（视图）之间的关系，以便数据的变化反映在视图中。
- en: In the early days of the PHP language, data, presentation, and business logic
    were all jumbled up in one or more scripts. This made debugging and eventual code
    maintenance a nightmare. This same dilemma does crop up from time to time in language
    and framework design.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 语言的早期，数据、展示和业务逻辑都混杂在一个或多个脚本中。这使得调试和最终的代码维护变得噩梦般。这种困境有时也会出现在语言和框架设计中。
- en: The **Model-View-Controller** (**MVC**) approach is an attempt to solve this
    problem. It recognizes that one critical piece of software is data. By recognizing
    this, it abstracts the data into what is called a model. A model is basically
    a representation of the data in a software. This data can be a list of strings
    or integers. It can be the folders and files under a parent folder. The data can
    also be a list of rows that have been returned from a query against a database.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）方法试图解决这个问题。它认识到软件的一个关键部分是数据。通过认识到这一点，它将数据抽象为所谓的模型。模型基本上是软件中数据的表示。这些数据可以是字符串或整数的列表。它也可以是父文件夹下的文件夹和文件。数据也可以是从对数据库的查询返回的行列表。'
- en: 'This data that has been obtained needs to displayed or presented to the user.
    The component(s) through which the data is piped is called the view. For example,
    an HTML page showing a list of student names can be called a view. In Qt, there
    are a number of widgets that can be used to display data in a model. Some typical
    views for data presentation are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的数据需要显示或呈现给用户。通过这些组件传输数据的组件称为视图。例如，显示学生名单列表的 HTML 页面可以称为视图。在 Qt 中，有许多小部件可以用于在模型中显示数据。以下是一些典型的数据展示视图：
- en: '![](img/53964bc3-b460-4fb7-b758-6a1b0e60b01d.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53964bc3-b460-4fb7-b758-6a1b0e60b01d.png)'
- en: These view classes are optimized for the displaying of information such that,
    when they are associated with a model, a change in the model will cause the view
    to be automatically updated. The view maintains its own state and gets informed
    when there are changes in the model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图类针对显示信息进行了优化，因此当它们与模型关联时，模型的变化将导致视图自动更新。视图维护自己的状态，并在模型发生变化时得到通知。
- en: For instance, when a list of names is displayed in a `QListView`, a call to
    `remove()` on the model will both remove the item from the model's list and also
    update the view by reducing the number of items on display.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当在 `QListView` 中显示姓名列表时，对模型调用 `remove()` 将同时从模型列表中删除项目，并通过减少显示的项目数量来更新视图。
- en: 'Instead of writing code to update the view, the view class does so on our behalf.
    Let''s create a sample project that will make use of a model to access data from
    a database:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接编写代码来更新视图不同，视图类会代表我们这样做。让我们创建一个示例项目，该项目将使用模型从数据库中访问数据：
- en: 'Create a new folder and, within it, create a file named `main.cpp`. Copy over
    the following lines of code into `main.cpp`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并在其中创建一个名为 `main.cpp` 的文件。将以下代码行复制到 `main.cpp` 文件中：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The purpose of this program is to connect to a database, list the rows in a
    particular table, and issue a `SELECT` statement against it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的目的在于连接到数据库，列出特定表中的行，并对它发出一个 `SELECT` 语句。
- en: After establishing a connection to the database, we create an instance of `QSqlTableModel`
    with the line, `QSqlTableModel *contactsTableModel = new QSqlTableModel(0, db_conn);`.
    This instance receives as arguments a pointer to a parent object and a connection
    to the database connection. This `QSqlTableModel` model allows for editing of
    the rows in a table too.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立数据库连接后，我们使用以下行创建 `QSqlTableModel` 实例：`QSqlTableModel *contactsTableModel
    = new QSqlTableModel(0, db_conn);`。这个实例接收一个指向父对象的指针和数据库连接。这个 `QSqlTableModel`
    模型也允许编辑表中的行。
- en: To select the table within the database we wish to manipulate, a call to the
    `setTable()` method is called on `contactsTableModel`. The `contacts` string is
    passed as the name of the table.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择我们想要操作的数据库中的表，在 `contactsTableModel` 上调用 `setTable()` 方法。将 `contacts` 字符串传递为表名。
- en: 'To populate the `contactsTableModel` model with the information in the table,
    a call to `select()` is issued. A loop is now used to iterate over the data in
    the model:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要用表中的信息填充 `contactsTableModel` 模型，发出一个 `select()` 调用。现在使用循环遍历模型中的数据：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each row in the table is obtained by using an index. An index of `0` here refers
    to the first item in the model. This index is not tied to the **primary key**
    in the table. It is instead a simple way to reference the rows in the table.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引获取表中的每一行。这里的索引 `0` 指的是模型中的第一个项目。这个索引与表中的 **主键** 无关。它是一种简单地引用表中行的方法。
- en: The `rowCount()` method is useful as it helps in knowing the total row count
    associated with the latest `SELECT` statement.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`rowCount()` 方法很有用，因为它有助于了解与最新的 `SELECT` 语句关联的总行数。'
- en: To obtain each row in the table, the index in the loop, `i`, is passed to `contactsTableModel->record(i)`.
    The `QSqlRecord` instance will hold a reference to a row in the table, which was
    returned by calling `record(i)`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取表中的每一行，循环中的索引 `i` 被传递给 `contactsTableModel->record(i)`。`QSqlRecord` 实例将持有对表中行的引用，该行是通过调用
    `record(i)` 返回的。
- en: For each row, the value stored at the intersecting column is obtained by passing
    the name of the column to `value`. As such, `record.value("id")` will return the
    value stored in the column `id` of the contact table. `toString()` returns the
    output as a string. This same call is issued to obtain the values for `last_name`,
    `first_name`, and `phone_number` for each row (`QSqlRecord` record) in the table.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行，通过传递列名给 `value` 获取交叉列中存储的值。因此，`record.value("id")` 将返回存储在联系人表 `id` 列中的值。`toString()`
    将输出作为字符串返回。相同的调用用于获取表中每一行（`QSqlRecord` record）的 `last_name`、`first_name` 和 `phone_number`
    的值。
- en: The `qDebug()` statement is then used to output all the values for each row.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `qDebug()` 语句输出每一行的所有值。
- en: 'Since `QSqlTableModel` allows for editing of the table, the following statement
    inserts a new row with data:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `QSqlTableModel` 允许编辑表，以下语句插入了一个包含数据的新的行：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The total items in the table are obtained by calling `rowCount()`. To insert
    a single row into the table, a call to `insertRows(row, 1)` is made. The single
    row here is represented by `1` at position `row`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`rowCount()`获取表中的总项数。要向表中插入单行，请调用`insertRows(row, 1)`。这里的单行由位置`row`处的`1`表示。
- en: At column `1`, the `last_name` column of the new row gets the value `"Stokes"`,
    after the call to `setData()`. `contactsTableModel->index(row,1)` represents the
    index where `"Stokes"` is to be inserted.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在列`1`中，新行的`last_name`列在调用`setData()`后获得值`"Stokes"`。`contactsTableModel->index(row,1)`代表插入`"Stokes"`的索引位置。
- en: To persist the data, a call to `submitAll()` is issued. This will write off
    any changes that are lingering on in memory to the database.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持久化数据，将发出对`submitAll()`的调用。这将把内存中任何悬而未决的更改写入数据库。
- en: Note at this point that the model has become the interface for accessing the
    data in the database. We also do not need to know the specific query that the
    statements map to for the different kinds of database the application talks to.
    This is a huge advantage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此时模型已成为访问数据库中数据的接口。我们也不需要知道应用程序与不同类型的数据库交互时，语句映射到的特定查询。这是一个巨大的优势。
- en: If this model were associated with a view, the newly inserted row would be populated
    onto the screen without any code to perform such an operation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此模型与视图相关联，则新插入的行将自动填充到屏幕上，而无需执行此类操作的任何代码。
- en: 'In order to refine the select statement, the `setFilter()` method is used:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了细化选择语句，使用`setFilter()`方法：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `WHERE` clause part of the SQL statement is what is passed to `setFilter()`.
    The `WHERE` clause, in this case, is selecting rows from the table where the `id`
    is equal to `12` and the `last_name` field is `'Stokes'`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语句的`WHERE`子句部分是传递给`setFilter()`的。在这种情况下，`WHERE`子句是从表中选择`id`等于`12`且`last_name`字段为`'Stokes'`的行。
- en: To apply the filter, call the `select()` method on `contactsTableModel`. The
    loop is then used to iterate over the results.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用过滤器，请在`contactsTableModel`上调用`select()`方法。然后循环用于遍历结果。
- en: 'Compile and run the project:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Be sure to include the following line in the `.pro` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在`.pro`文件中包含以下行：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Compile and run the project:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Displaying the model
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示模型
- en: 'In the previous section, we saw how to access the database using the model
    as an abstraction. Now, we shall try to link it with a model for display. Using
    the code listing from the previous section, modify `main.cpp` to appear as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用模型作为抽象来访问数据库。现在，我们将尝试将其与用于显示的模型相链接。使用上一节中的代码列表，修改`main.cpp`如下所示：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Because we want to display the model, the widgets classes have been included.
    The database connections remain the same.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要显示模型，因此已包含小部件类。数据库连接保持不变。
- en: 'Now, add the following lines of code to `main.cpp`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码行添加到`main.cpp`中：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead of using magic numbers such as `0`, `1`, and so on, enumerators provide
    some context for the constants `0`, `1`, and so on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用如`0`、`1`等魔法数字相比，枚举提供了一些上下文，用于常数`0`、`1`等。
- en: An instance of `QSqlTableModel` is created using the connection object, `db_conn`.
    The database table, `contacts`, is selected for operations. When a model is being
    displayed, headers are used to label the columns. To set this, we pass the enumeration
    values and the name that the column should bear. For instance, calling `setHeaderData(FirstName,
    Qt::Horizontal, QObject::tr("First Name"))` will set the first column, `FirstName`
    (whose real value is 0), to display `"First Name"`, horizontally.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连接对象`db_conn`创建`QSqlTableModel`的实例。选择数据库表`contacts`进行操作。当模型被显示时，使用标题来标记列。为此，我们传递枚举值和列应显示的名称。例如，调用`setHeaderData(FirstName,
    Qt::Horizontal, QObject::tr("First Name"))`将第一列`FirstName`（其实际值为0）设置为水平显示`"First
    Name"`。
- en: 'We said that the `Model-View` concept has an added benefit in that changes
    made to the view can be made to reflect in the database without writing extra
    code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，`模型-视图`概念有一个额外的优点，即对视图所做的更改可以反映在数据库中，而无需编写额外的代码：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding lines stipulate that changes to the data displayed in the view
    should not be propagated to the database. Instead, an independent process should
    trigger the syncing of the view with the data in the database. In contrast to
    making the syncing process a manual one, replace the code that has been commented
    out:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行规定，不应将视图显示的数据更改传播到数据库。相反，应有一个独立的过程触发视图与数据库中数据的同步。与手动进行同步过程相比，替换已被注释掉的代码：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`setEditStrategy(QSqlTableModel::OnRowChange)` means that changes made to the
    data via the view will reflect in the database when the data in the row has changed.
    We will see more of this when we run the completed program.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`setEditStrategy(QSqlTableModel::OnRowChange)` 的意思是，通过视图对数据进行更改时，当行中的数据发生变化时，这些更改将反映在数据库中。我们将在运行完成的程序时看到更多关于这一点的内容。'
- en: 'Since we have created the model, it is time to add the view. Add the following
    lines of code to `main.cpp`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经创建了模型，现在是时候添加视图了。将以下代码行添加到 `main.cpp` 中：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To show the entries in the database table, the view class, `QTableView`, is
    used here. The `QTableView` class is special in that it is a class with an implementation
    of a model and view all-in-one. That means that internally, this class has an
    internal model where data can be inserted for display. For our purposes, we shall
    replace this model.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示数据库表中的条目，这里使用了视图类 `QTableView`。`QTableView` 类特别之处在于它是一个实现了模型和视图一体化的类。这意味着在内部，这个类有一个内部模型，可以插入数据以供显示。就我们的目的而言，我们将替换这个模型。
- en: '`QTableView` presents data in a tabular form with rows and columns. We are
    choosing to use this view since it resembles how data is organized in a relational
    database.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTableView` 以表格形式呈现数据，具有行和列。我们选择使用这个视图，因为它类似于关系数据库中数据的组织方式。'
- en: After an instance of `QTableView` has been instantiated, we set the model to
    `contactsTableModel`, which is the model we created by ourselves by calling the
    `setModel()` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 `QTableView` 后，我们将模型设置为 `contactsTableModel`，这是我们通过调用 `setModel()` 方法创建的模型。
- en: The selection of items in the table is restricted to a single item when the
    `setSelectionMode()` method is called. If we want to allow multiple selections
    in the table, then the `QAbstractItemView::MultiSelection` constant should be
    passed to `setSelectionMode()`. The selection, in this case, is made by clicking
    and dragging the mouse over the items in the table in which you have an interest.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `setSelectionMode()` 方法时，表格中项目的选择被限制为单个项目。如果我们想允许在表格中进行多选，则应将 `QAbstractItemView::MultiSelection`
    常量传递给 `setSelectionMode()`。在这种情况下，选择是通过点击并拖动鼠标到表格中你感兴趣的项目来进行的。
- en: In order to specify what can be selected, the `QAbstractItemView::SelectRows`
    constant is passed to `setSelectionBehavior()`. This constant allows for only
    entire rows to be selected.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定可以选择的内容，将 `QAbstractItemView::SelectRows` 常量传递给 `setSelectionBehavior()`。这个常量允许只选择整个行。
- en: When `QTableView` is rendered, there is unused space to the right of the widget.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `QTableView` 渲染时，在小部件右侧有未使用的空间。
- en: 'This problem is illustrated in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了这个问题：
- en: '![](img/73e108c7-9b95-4e45-a6c1-666b1d52811e.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73e108c7-9b95-4e45-a6c1-666b1d52811e.png)'
- en: Consider how the space marked Empty space presents a gaping hole in the interface.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下标记为“空空间”的区域在界面中呈现的巨大缺口。
- en: 'In order to make the last column stretch to fill the containing widget, we
    need to obtain an instance of the header object of `QTableView` and set the desired
    property, `setStretchLastSection()`, to `true`, as in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使最后一列扩展以填充包含的小部件，我们需要获取 `QTableView` 的标题对象实例，并将所需的属性 `setStretchLastSection()`
    设置为 `true`，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At this point, we need to construct a simple window and layout for the application.
    Add the following lines to `main.cpp`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要为应用程序构建一个简单的窗口和布局。将以下行添加到 `main.cpp` 中：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A `QVBoxLayout` instance will serve as the main layout for the application window.
    Changes made to the entries in the table will not be persisted to the database.
    We have intentionally made it thus, in order to use a button to manually write
    changes to the database. As such, a `QPushButton` instance is created. The table
    and button are added to the layout object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVBoxLayout` 实例将作为应用程序窗口的主要布局。对表格条目的更改不会持久化到数据库。我们有意这样做，以便使用按钮手动将更改写入数据库。因此，创建了一个
    `QPushButton` 实例。将表格和按钮添加到布局对象中。'
- en: 'The last lines of code for `main.cpp` are as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp` 的最后一行代码如下：'
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `clicked()` signal of the `saveToDbPushButton` object is connected to the
    `submitAll()` slot of the model, `contactsTableModel`. After making changes to
    the entries on the table in the application, clicking the Push button will write
    the changes to the database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveToDbPushButton` 对象的 `clicked()` 信号连接到了模型 `contactsTableModel` 的 `submitAll()`
    插槽。在应用程序中修改表格中的条目后，点击推送按钮会将更改写入数据库。'
- en: The rest of the code reads the same as always.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码与以往一样。
- en: 'To compile the application, perform the following commands:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译应用程序，执行以下命令：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Make sure the `QT` variable in the `.pro` file has the following line:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `.pro` 文件中的 `QT` 变量具有以下行：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Continue with the following commands:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行以下命令：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the application will populate a list in the table, assuming the
    contacts table is not empty:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设联系人表不为空，应用程序的输出将填充表格中的列表：
- en: '![](img/8c61b503-f8ac-4fad-a837-1ea0eee6eb38.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c61b503-f8ac-4fad-a837-1ea0eee6eb38.png)'
- en: Note how the last column has extended all the way to the edge of the window.
    From the preceding screenshot, you can see data that has already been persisted
    in the database. Double-click on any of the cells and edit its content. Click
    on the Save Changes button. When you visit the database, you will see that the
    changes in the application have been reflected in the app.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一列已经扩展到了窗口的边缘。从前面的屏幕截图可以看到已经持久化到数据库中的数据。双击任何单元格并编辑其内容。点击“保存更改”按钮。当你访问数据库时，你会看到应用程序中的更改已经反映在应用中。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter illustrated how to connect to databases when developing Qt applications.
    We learned how to use models to serve as an abstraction for manipulating data
    in a database. Finally, the information in the database table was displayed with
    the aid of `Model-View` classes. These classes make it easy to extract data for
    display, while allowing changes made in the view to be propagated to the database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章说明了在开发 Qt 应用程序时如何连接到数据库。我们学习了如何使用模型作为操作数据库中数据的抽象。最后，借助 `Model-View` 类展示了数据库表中的信息。这些类使得提取数据以供显示变得容易，同时允许在视图中做出的更改传播到数据库。
