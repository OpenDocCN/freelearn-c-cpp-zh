- en: Connecting Qt with Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent times, most applications integrate with some database for storing
    information for further processing and future use.
  prefs: []
  type: TYPE_NORMAL
- en: Qt comes with modules and classes that make connecting to databases effortless.
    The MySql database will be used to illustrate the examples in this chapter, but
    the same principles will apply to other databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should be able to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect and read from a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display and edit database entries via widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QtSql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The QtSql module comes equipped with classes and drivers for accessing databases.
    To proceed beyond this point, you should have made the necessary configuration
    during the installation of Qt on your system to enable database access.
  prefs: []
  type: TYPE_NORMAL
- en: For those on the macOS using Homebrew, remember to issue the command as previously
    described in [Chapter 1](a157893d-287f-42c4-8166-a7d414e09035.xhtml), *Introducing
    Qt 5*.
  prefs: []
  type: TYPE_NORMAL
- en: Linux users have to install the modules and enable the correct flags during
    compilation to make the QtSql module work, but, for the most part, the instructions
    in [Chapter 1](a157893d-287f-42c4-8166-a7d414e09035.xhtml), *Introducing Qt 5*,
    should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The QtSql module is comprised of the following layers:'
  prefs: []
  type: TYPE_NORMAL
- en: UI layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL API layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driver layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/06e23dc6-4fe5-42d8-bc5c-99a5b04d3d7c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each level makes use of classes, as illustrated in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Making the connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to set the grounds for writing our applications, and, in this case,
    we need to have a running instance of MySql. XAMPP is a good candidate to install
    to have quick access to a working database.
  prefs: []
  type: TYPE_NORMAL
- en: XAMPP is a free and open source, cross-platform web server solution stack package
    developed by Apache Friends, consisting mainly of the Apache HTTP Server, MariaDB
    (or MySql) database, and interpreters for scripts written in the PHP and Perl
    programming languages. Download the latest version from [https://www.apachefriends.org/download.html](https://www.apachefriends.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a database with the following tables by issuing the following
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The name of the database is `contact_db`, and it is assumed that you have created
    it in the MySql instance you installed.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL statements create a table called `contacts` with an auto-increment `id`
    field along with,  `last_name`, `first_name`, and `phone_number` fields that store
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new folder and add a file called `main.cpp`. Insert the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To make database connections, we need to include `QtSql`. `QDebug` provides
    an output stream where we can write out useful (debugging) information during
    development to file, device, or standard output.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the structure of the database table has been commented
    out, but serves as a reminder in case you have not created it.
  prefs: []
  type: TYPE_NORMAL
- en: To open a connection to a database, a call to `QSqlDatabase::addDatabase()`
    is made. The `QMYSQL` parameter is the driver type, and `contact_db` is the connection
    name. A program can have a number of connections to the same database. Furthermore,
    the `addDatabase()` call will return an instance of `QSqlDatabase`, which, in
    essence, is the connection to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This connection, `db_conn`, is then initialized with the parameters to make
    the connection work. The hostname, specific database we want to connect to, username,
    password, and port number are set on the database connection object, `db_conn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Depending on a number of situations, you may need to specify more than these
    parameters to gain access to a database, but, for the most part, this should work.
    Also, note that the password is an empty string. It is only for illustration purposes.
    You have to change the password as pertains to your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the connection, we need to call `open()` on the connection object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A call to `open()` will result in a bool being returned to determine whether
    the connection to the database was successful. `!db_conn.open()` tests whether
    the return value is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Note the way in which we shall compile and run this program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Issue the following on the command line while you are in the folder where the
    `main.cpp` file is locate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the resulting `.pro` file, and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We intend to use widgets in the course of this chapter, so it has been listed
    as the first module to be included. Likewise, we include the SQL module. Proceed
    with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get the `Database connection established!` response, then it means your
    program is able to connect to the database smoothly. On the other hand, you may
    get an error, which will describe the reason why the connection is unable to be
    established. Go through the following list to ensure you are on the right path
    when you encounter an error:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the database service is running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure the database you are trying to connect actually exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure the table given by the schema exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure the username and password for the database exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure the Qt was compiled with the MySql module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's update the program so that we can illustrate how to issue the various
    SQL statements in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Listing records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to execute query statements against the database, we shall make use
    of the `QSqlQuery` class. These statements include data-altering statements, such
    as `INSERT`, `SELECT`, and `UPDATE`. Data definition statements such as `CREATE
    TABLE` can also be issued.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following snippet of code to list all entries within the contacts
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The query statement and the database connection are passed as parameters to
    an instance of the `QSqlQuery` statement. `QSqlRecord` is used to encapsulate
    a database row or view. We shall use its instance, `record`, to get the index
    of a column in a row. `statement.record()` returns field information for the current
    query.
  prefs: []
  type: TYPE_NORMAL
- en: If there are any rows that match the query in `statement`, `statement.next()`
    will allow us to cycle through the returned rows. We can call `previous()`, `first()`,
    and `last()` to enable us to move back and forth with the returned rows or data.
  prefs: []
  type: TYPE_NORMAL
- en: For each row that is returned and accessed by calling `statement.next()`, the
    `statement` object is used to get its corresponding data according to the code,
    `statement.value(0).toString()`. This should return the first column in the row
    converted to string to be stored in `firstName`. Instead of this approach, we
    can use `record`, to obtain the index of the column we are interested in. As such,
    to extract the first name column, we write `statement.value(record.indexOf("first_name")).toString()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `qDebug()` call helps to print out the data in `firstName`, `lastName`,
    and `phoneNumber`, similar to what we would have done using `cout`.
  prefs: []
  type: TYPE_NORMAL
- en: The INSERT operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To effect a database operation to store data into the database, there are a
    number of ways to issue out the `INSERT` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider one form of the `INSERT` operation in Qt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `QSqlQuery` object, `insert_statement`, is instantiated by passing the database
    connection. Next, the `INSERT` statement string is passed to a call to `prepare()`.
    Notice how incomplete our statement is with the use of the three (3) `?, ?, ?`
    (question marks). These question marks will be used as placeholders. To fill these
    placeholders, the `addBindValue()` method is called. The line, `insert_statement.addBindValue("Sidle")`,
    will be used to fill the data in the `last_name` column of the `contacts` table.
    The second call to `addBindValue("Sara")` will be used to fill the second placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: To execute the statement, the `insert_statement.exec()` must be called. The
    overall effect is that a new record will be inserted into the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the order in which the data is inserted, we can use the `insert_statement.bindValue()`
    function instead. The `INSERT` statement has three (3) positional placeholders,
    which number from `0` up to `2`. We can fill the last placeholder first by specifying
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The placeholder for the phone number column is filled first by specifying `bind(2,
    "+144758849555")`, where `2` is the index of the `(phone_number)` placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to using the positions of the placeholders would be to name
    them. Consider the following `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the index of the position when completing the SQL statement,
    named placeholders are used to reference the data in the `VALUES` part. That way,
    the name of the placeholders are passed with a corresponding value to every call
    to `bindValue()`.
  prefs: []
  type: TYPE_NORMAL
- en: To persist the data, the `insert_statement.exec()` function must be called.
  prefs: []
  type: TYPE_NORMAL
- en: The DELETE operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DELETE` operation is another operation that can be performed on a table.
    To do so, we shall pass a reference to the database connection and pass the `DELETE`
    statement to the `exec()` method of `QSqlQuery`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`numRowsAffected()` is a method that is used to figure out how many records
    were affected. One benefit of this method is that it helps determine whether our
    query has changed the database. If it returns `-1`, it means that the query''s
    operation produced indeterminate results.'
  prefs: []
  type: TYPE_NORMAL
- en: The UPDATE operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UPDATE` operation follows the same logic as the `DELETE` operation. Consider
    the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The statement here sets the `first_name` of the record with an ID of `1` to
    `'Jude'`. `update_statement.numRowsAffected()` will return nothing, especially
    in the case where the first record in the table with `id=1` is missing. Do take
    note of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full program to illustrate the major operations is outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Of particular importance is how the database table is created. From the preceding
    code listing, the `QString` instance, `table_definition`, holds the structure
    of the table we are about to create. The table is created when `table_definition`
    and the database connection are passed to an instance of `QSqlQuery`. That's all
    it takes to create a table.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run the program.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to edit the `.pro` file to include the `sql` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical output of the program run from the command is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using a data model for database access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two classes that can be used in accessing the database. These are
    the `QSqlTableModel` and  `QSqlQueryModel` classes. The `QSqlQueryModel` class
    only provides a read-only model to the database. `QSqlTableModel` provides both
    read and write model access to the database.
  prefs: []
  type: TYPE_NORMAL
- en: In application development, you are confronted with the challenge of how to
    present data and to maintain a relationship between data and presentation (view)
    such that changes to the data are reflected in the view.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of the PHP language, data, presentation, and business logic
    were all jumbled up in one or more scripts. This made debugging and eventual code
    maintenance a nightmare. This same dilemma does crop up from time to time in language
    and framework design.
  prefs: []
  type: TYPE_NORMAL
- en: The **Model-View-Controller** (**MVC**) approach is an attempt to solve this
    problem. It recognizes that one critical piece of software is data. By recognizing
    this, it abstracts the data into what is called a model. A model is basically
    a representation of the data in a software. This data can be a list of strings
    or integers. It can be the folders and files under a parent folder. The data can
    also be a list of rows that have been returned from a query against a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This data that has been obtained needs to displayed or presented to the user.
    The component(s) through which the data is piped is called the view. For example,
    an HTML page showing a list of student names can be called a view. In Qt, there
    are a number of widgets that can be used to display data in a model. Some typical
    views for data presentation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53964bc3-b460-4fb7-b758-6a1b0e60b01d.png)'
  prefs: []
  type: TYPE_IMG
- en: These view classes are optimized for the displaying of information such that,
    when they are associated with a model, a change in the model will cause the view
    to be automatically updated. The view maintains its own state and gets informed
    when there are changes in the model.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, when a list of names is displayed in a `QListView`, a call to
    `remove()` on the model will both remove the item from the model's list and also
    update the view by reducing the number of items on display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing code to update the view, the view class does so on our behalf.
    Let''s create a sample project that will make use of a model to access data from
    a database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder and, within it, create a file named `main.cpp`. Copy over
    the following lines of code into `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this program is to connect to a database, list the rows in a
    particular table, and issue a `SELECT` statement against it.
  prefs: []
  type: TYPE_NORMAL
- en: After establishing a connection to the database, we create an instance of `QSqlTableModel`
    with the line, `QSqlTableModel *contactsTableModel = new QSqlTableModel(0, db_conn);`.
    This instance receives as arguments a pointer to a parent object and a connection
    to the database connection. This `QSqlTableModel` model allows for editing of
    the rows in a table too.
  prefs: []
  type: TYPE_NORMAL
- en: To select the table within the database we wish to manipulate, a call to the
    `setTable()` method is called on `contactsTableModel`. The `contacts` string is
    passed as the name of the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To populate the `contactsTableModel` model with the information in the table,
    a call to `select()` is issued. A loop is now used to iterate over the data in
    the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each row in the table is obtained by using an index. An index of `0` here refers
    to the first item in the model. This index is not tied to the **primary key**
    in the table. It is instead a simple way to reference the rows in the table.
  prefs: []
  type: TYPE_NORMAL
- en: The `rowCount()` method is useful as it helps in knowing the total row count
    associated with the latest `SELECT` statement.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain each row in the table, the index in the loop, `i`, is passed to `contactsTableModel->record(i)`.
    The `QSqlRecord` instance will hold a reference to a row in the table, which was
    returned by calling `record(i)`.
  prefs: []
  type: TYPE_NORMAL
- en: For each row, the value stored at the intersecting column is obtained by passing
    the name of the column to `value`. As such, `record.value("id")` will return the
    value stored in the column `id` of the contact table. `toString()` returns the
    output as a string. This same call is issued to obtain the values for `last_name`,
    `first_name`, and `phone_number` for each row (`QSqlRecord` record) in the table.
  prefs: []
  type: TYPE_NORMAL
- en: The `qDebug()` statement is then used to output all the values for each row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `QSqlTableModel` allows for editing of the table, the following statement
    inserts a new row with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The total items in the table are obtained by calling `rowCount()`. To insert
    a single row into the table, a call to `insertRows(row, 1)` is made. The single
    row here is represented by `1` at position `row`.
  prefs: []
  type: TYPE_NORMAL
- en: At column `1`, the `last_name` column of the new row gets the value `"Stokes"`,
    after the call to `setData()`. `contactsTableModel->index(row,1)` represents the
    index where `"Stokes"` is to be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: To persist the data, a call to `submitAll()` is issued. This will write off
    any changes that are lingering on in memory to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Note at this point that the model has become the interface for accessing the
    data in the database. We also do not need to know the specific query that the
    statements map to for the different kinds of database the application talks to.
    This is a huge advantage.
  prefs: []
  type: TYPE_NORMAL
- en: If this model were associated with a view, the newly inserted row would be populated
    onto the screen without any code to perform such an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to refine the select statement, the `setFilter()` method is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `WHERE` clause part of the SQL statement is what is passed to `setFilter()`.
    The `WHERE` clause, in this case, is selecting rows from the table where the `id`
    is equal to `12` and the `last_name` field is `'Stokes'`.
  prefs: []
  type: TYPE_NORMAL
- en: To apply the filter, call the `select()` method on `contactsTableModel`. The
    loop is then used to iterate over the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to include the following line in the `.pro` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to access the database using the model
    as an abstraction. Now, we shall try to link it with a model for display. Using
    the code listing from the previous section, modify `main.cpp` to appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Because we want to display the model, the widgets classes have been included.
    The database connections remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following lines of code to `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using magic numbers such as `0`, `1`, and so on, enumerators provide
    some context for the constants `0`, `1`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of `QSqlTableModel` is created using the connection object, `db_conn`.
    The database table, `contacts`, is selected for operations. When a model is being
    displayed, headers are used to label the columns. To set this, we pass the enumeration
    values and the name that the column should bear. For instance, calling `setHeaderData(FirstName,
    Qt::Horizontal, QObject::tr("First Name"))` will set the first column, `FirstName`
    (whose real value is 0), to display `"First Name"`, horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We said that the `Model-View` concept has an added benefit in that changes
    made to the view can be made to reflect in the database without writing extra
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines stipulate that changes to the data displayed in the view
    should not be propagated to the database. Instead, an independent process should
    trigger the syncing of the view with the data in the database. In contrast to
    making the syncing process a manual one, replace the code that has been commented
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`setEditStrategy(QSqlTableModel::OnRowChange)` means that changes made to the
    data via the view will reflect in the database when the data in the row has changed.
    We will see more of this when we run the completed program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have created the model, it is time to add the view. Add the following
    lines of code to `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To show the entries in the database table, the view class, `QTableView`, is
    used here. The `QTableView` class is special in that it is a class with an implementation
    of a model and view all-in-one. That means that internally, this class has an
    internal model where data can be inserted for display. For our purposes, we shall
    replace this model.
  prefs: []
  type: TYPE_NORMAL
- en: '`QTableView` presents data in a tabular form with rows and columns. We are
    choosing to use this view since it resembles how data is organized in a relational
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: After an instance of `QTableView` has been instantiated, we set the model to
    `contactsTableModel`, which is the model we created by ourselves by calling the
    `setModel()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The selection of items in the table is restricted to a single item when the
    `setSelectionMode()` method is called. If we want to allow multiple selections
    in the table, then the `QAbstractItemView::MultiSelection` constant should be
    passed to `setSelectionMode()`. The selection, in this case, is made by clicking
    and dragging the mouse over the items in the table in which you have an interest.
  prefs: []
  type: TYPE_NORMAL
- en: In order to specify what can be selected, the `QAbstractItemView::SelectRows`
    constant is passed to `setSelectionBehavior()`. This constant allows for only
    entire rows to be selected.
  prefs: []
  type: TYPE_NORMAL
- en: When `QTableView` is rendered, there is unused space to the right of the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73e108c7-9b95-4e45-a6c1-666b1d52811e.png)'
  prefs: []
  type: TYPE_IMG
- en: Consider how the space marked Empty space presents a gaping hole in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make the last column stretch to fill the containing widget, we
    need to obtain an instance of the header object of `QTableView` and set the desired
    property, `setStretchLastSection()`, to `true`, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we need to construct a simple window and layout for the application.
    Add the following lines to `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A `QVBoxLayout` instance will serve as the main layout for the application window.
    Changes made to the entries in the table will not be persisted to the database.
    We have intentionally made it thus, in order to use a button to manually write
    changes to the database. As such, a `QPushButton` instance is created. The table
    and button are added to the layout object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last lines of code for `main.cpp` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `clicked()` signal of the `saveToDbPushButton` object is connected to the
    `submitAll()` slot of the model, `contactsTableModel`. After making changes to
    the entries on the table in the application, clicking the Push button will write
    the changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code reads the same as always.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the application, perform the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure the `QT` variable in the `.pro` file has the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the application will populate a list in the table, assuming the
    contacts table is not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c61b503-f8ac-4fad-a837-1ea0eee6eb38.png)'
  prefs: []
  type: TYPE_IMG
- en: Note how the last column has extended all the way to the edge of the window.
    From the preceding screenshot, you can see data that has already been persisted
    in the database. Double-click on any of the cells and edit its content. Click
    on the Save Changes button. When you visit the database, you will see that the
    changes in the application have been reflected in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter illustrated how to connect to databases when developing Qt applications.
    We learned how to use models to serve as an abstraction for manipulating data
    in a database. Finally, the information in the database table was displayed with
    the aid of `Model-View` classes. These classes make it easy to extract data for
    display, while allowing changes made in the view to be propagated to the database.
  prefs: []
  type: TYPE_NORMAL
