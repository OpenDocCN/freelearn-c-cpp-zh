<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-79"><a id="_idTextAnchor079"/>5</h1>
<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/>Using Standard Smart Pointers</h1>
<p>C++ emphasizes programming with values. By default, your code uses objects, not indirections (references and pointers) to objects. Indirect access to objects is, of course, allowed, and rare is the program that never uses such semantics, but it is an opt-in and requires additional syntax. <a href="B21071_04.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a> explored the association of resource management with object lifetime through destructors and the RAII idiom, demonstrating one of C++’s main strengths in that essentially all resources (including memory) can be handled implicitly through the very mechanics of the language.</p>
<p>C++ allows the use of raw pointers in code but does not actively encourage it. Quite the contrary, in fact – raw pointers are a low-level facility, extremely efficient but easy to misuse, and for which it is not easy to infer responsibility about the <em class="italic">pointee</em> directly from the source code. Starting with the (now-removed) <code>auto_ptr&lt;T&gt;</code> facility of decades past, there has been an effort in the C++ community to define abstractions around lower-level facilities, such as raw pointers, through types that provide clear, well-defined semantics and reduce the risk of programming errors. This effort has met with significant success, in large part due to the expressiveness of the C++ language and its ability to create powerful and efficient abstractions, without losing speed or using more memory at runtime. For this reason, in contemporary C++, raw pointers are usually encapsulated underneath harder-to-misuse abstractions, examples of which include standard containers and smart pointers, such as the ones we will explore in this chapter; raw pointers that are not encapsulated are mostly used to mean “<em class="italic">Here’s a resource you can use but do </em><em class="italic">not own</em>.”</p>
<p>This chapter will look at how to use the standard smart pointer types of C++. We will first look at what they are, and then delve into ways to use the main smart pointer types efficiently. Finally, we will look at those moments where we need to “get our hands dirty” (so to speak) and use raw pointers, ideally (but not only) through the mediation of smart pointers. This should lead us to learn how to choose standard smart pointers for a given use case, how to use them appropriately, and how to handle resources that have to be freed through custom mechanisms. Throughout this journey, we will keep in mind and explain the costs of the choices we make.</p>
<p>In this chapter, we will do the following:</p>
<ul>
<li>Take a quick look at the general idea of standard smart pointers to develop an idea of their reason for being</li>
<li>Look more closely at <code>std::unique_ptr</code>, including how it can be used to handle scalars, arrays, and release resources that are allocated in atypical ways</li>
<li>Look at <code>std::shared_ptr</code> and the use cases for this essential but more costly type, in order to grasp when alternatives should be preferred</li>
<li>Take a quick look at <code>std::weak_ptr</code>, a companion to <code>std::shared_ptr</code> that is useful when there is a need to model temporary shared ownership</li>
<li>Look at cases where raw pointers should be used, as they still have their place in the C++ ecosystem</li>
</ul>
<p>Ready? Let’s dive in!</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/>Technical requirements</h1>
<p><a id="_idTextAnchor082"/>You can find the code files for this chapter in the book’s GitHub repository here: <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter5">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter5</a>.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor083"/>The standard smart pointers</h1>
<p>C++ has a<a id="_idIndexMarker260"/> relatively small <em class="italic">zoo</em> of smart pointers. Before looking at the set of options provided by the standard, let’s take a moment to show the problem we are trying to solve. Consider the following (deliberately incomplete) program. Do you see anything wrong with it?</p>
<pre class="source-code">
class X {
   // ...
};
X *f();
void g(X *p);
void h() {
   X *p = f();
   g(p);
   delete p;
}</pre> <p>This is code that is legal but not something you want to see in a contemporary program. There’s just so much that can go wrong here, such as the following from a non-exhaustive list of <a id="_idIndexMarker261"/>potential problems:</p>
<ul>
<li>We don’t know whether <code>g()</code> will call <code>delete p</code>, leading to a second <code>delete</code> (on a destroyed object!) in <code>h()</code> afterward</li>
<li>We don’t know whether <code>g()</code> might throw, in which case the <code>delete p;</code> instruction in <code>h()</code> will never be reached</li>
<li>We don’t know whether <code>h()</code> should be assumed to own <code>p</code>, in the sense that we do not know whether it should be responsible for calling <code>operator delete()</code> on <code>p</code> (maybe it’s meant to be the responsibility of <code>g()</code>, or some other function)</li>
<li>We do not know whether what <code>p</code> points to has been allocated with <code>new</code>, <code>new[]</code>, or something else (<code>malloc()</code>, some facility from another language, some custom utility in your code base, etc.)</li>
<li>We don’t even know whether what <code>p</code> points to has been dynamically allocated at all; <code>p</code> could point to a global or a <code>static</code> variable declared in <code>f()</code>, for example (a bad idea, but some people do that – for example, when implementing the singleton design pattern in a non-idiomatic way for C++)</li>
</ul>
<p>Compare, for example, two possible implementations of <code>f()</code> (there are many, many more we could consider, but these will suffice for now):</p>
<pre class="source-code">
X *f() { // here’s one possibility
   return new X;
}
X *f() { // here’s another
   static X x;
   return &amp;x;
}</pre> <p>In the first case, it <em class="italic">might</em> make sense to call <code>delete</code> on the returned pointer, but in the second case, it would be disastrous to do so. Nothing in the function’s signature clearly informs the client code whether we are facing one situation or the other, or even something else entirely.</p>
<p>As a “bonus” of sorts, what happens if someone calls <code>f()</code> without using the returned value? If <code>f()</code> is implemented as <code>return new X;</code> or something similar, then the code will leak – an unpleasant perspective indeed. Note that since C++17, you can mitigate this specific problem by annotating the return type of <code>f()</code> with the <code>[[nodiscard]]</code> attribute, but it’s still something you should be aware of. Returning raw pointers from a function is something we mostly try to avoid, even though we sometimes have to do so.</p>
<p>There are other possible pitfalls here, and they all have a common theme – using raw pointers, we traditionally cannot tell from the source code what the semantics are. More specifically, we cannot say for sure who is responsible for both the pointer and what it points to. The<a id="_idIndexMarker262"/> fact that raw pointers do not provide clear ownership information has been a recurring source of bugs in C++ over the years.</p>
<p>Now, for a different situation, consider the following code excerpt:</p>
<pre class="source-code">
// ...
void f() {
   X *p = new X;
   thread th0{ [p] { /* use *p */ };
   thread th1{ [p] { /* use *p */ };
   th0.detach();
   th1.detach();
}</pre> <p>In this case, <code>f()</code> allocates an <code>X</code> object pointed to by <code>p</code>, after which two threads, <code>th0</code> and <code>th1</code>, copy <code>p</code> (thus sharing the <code>X</code> object that <code>p</code> points to). Finally, <code>th0</code> and <code>th1</code> are detached, meaning that the threads will run until completion, even after <code>f()</code> is done. If we do not know in what order <code>th0</code> and <code>th1</code> will conclude, we cannot clearly state which one should be responsible for calling <code>operator delete()</code> on <code>p</code>. This is yet another issue of unclear responsibility over the <em class="italic">pointee</em> but of a different kind than our first example, and as such, it needs a different solution.</p>
<p>For the cases where there is a clearly identified last owner of a pointed-to object, regardless of whether the <em class="italic">pointee</em> is shared or not between pointers, you probably want to use <code>std::unique_ptr</code>. In the (more niche, but very real and quite subtle) case where the pointed-to object is shared by at least two “co-owners” and the order in which these owners will be destroyed is a priori unknown, <code>std::shared_ptr</code> is the tool of choice. The<a id="_idIndexMarker263"/> following sections go into the roles and meaning of these types in more detail, hopefully helping you make an informed choice when choosing a smart pointer type for a given use case.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor084"/>On the exposition of intent through function signatures</h2>
<p>Even though we<a id="_idIndexMarker264"/> have not looked in detail at the standard smart pointers yet, it might be appropriate to offer a few words on what they mean, in particular for <code>std::unique_ptr</code> and <code>std::shared_ptr</code>. These two types convey <em class="italic">ownership semantics</em> – <code>std::unique_ptr</code> represents <em class="italic">sole ownership</em> of the pointee, and <code>std::shared_ptr</code> represents <em class="italic">co-ownership</em> (or <em class="italic">shared ownership</em>) of the pointee. </p>
<p>It’s important to understand the difference between <em class="italic">owning</em> (in particular, <em class="italic">co-owning</em>) a pointee and <em class="italic">sharing</em> a pointee. Consider the following example, which uses <code>std::unique_ptr</code> (even though we have not covered it yet, but we’re getting there) and raw pointers <em class="italic">together</em> in order to inscribe ownership semantics in the type system:</p>
<pre class="source-code">
<strong class="bold">#include &lt;memory&gt;</strong>
#include &lt;iostream&gt;
<strong class="bold">// print_pointee() shares a pointer with the caller</strong>
<strong class="bold">// but does not take ownership</strong>
template &lt;class T&gt; void print_pointee(<strong class="bold">T *p</strong>) {
   if (p) std::cout &lt;&lt; *p &lt;&lt; ‘\n’;
}
<strong class="bold">std::unique_ptr&lt;T&gt;</strong> make_one(const T &amp;arg) {
   return std::make_unique&lt;T&gt;(arg);
}
int main() {
   auto p = make_one(3); // p is a std::unique_ptr&lt;int&gt;
<strong class="bold">   print_pointee(p.get()); // caller and callee share the</strong>
<strong class="bold">                           // pointer during this call</strong>
}</pre> <p>As mentioned when introducing this example, we used a <code>std::unique_ptr</code> object to model ownership – <code>make_one()</code> constructs <code>std::unique_ptr&lt;T&gt;</code> and transfers ownership to the caller; then, that caller keeps ownership of that object and shares the underlying pointer with others (here, <code>print_pointee()</code>) but does not relinquish ownership of the pointee. Using yet not owning is modeled by a raw pointer. This shows us in a highly simplified setting that there is a difference between owning and sharing a resource – <code>p</code> in <code>main()</code> owns the resource, yet it shares it with the non-owner, <code>p</code>, in <code>print_pointee()</code>. This is all safe and idiomatic C++ code.</p>
<p>Knowing that the<a id="_idIndexMarker265"/> standard smart pointer types model represents ownership, we know that as long as there is a single, clear last user of a resource, <code>std::unique_ptr</code> tends to be the type of choice; it is much more lightweight than <code>std::shared_ptr</code> (as we will see), and it provides the appropriate ownership semantics.</p>
<p>There are, of course, use cases where <code>std::unique_ptr</code> is not a good choice. Consider this simplified, not thread-safe, and incomplete code excerpt:</p>
<pre class="source-code">
class entity {
   bool taken{ false };
public:
   void take() { taken = true; }
   void release() { taken = false; }
   bool taken() const { return taken; }
   // ...
};
constexpr int N = ...;
<strong class="bold">// entities is where the entity objects live. We did</strong>
<strong class="bold">// not allocate them dynamically, but if we had we would</strong>
<strong class="bold">// have used unique_ptr&lt;entity&gt; as this will be the</strong>
<strong class="bold">// single last point of use for these objects</strong>
<strong class="bold">array&lt;entity,N&gt; entities;</strong>
class nothing_left{};
<strong class="bold">// this function returns a non-owning pointer (Chapter 6</strong>
<strong class="bold">// will cover more ergonomic options than a raw pointer)</strong>
<strong class="bold">entity *</strong> borrow_one() {
   if(auto p = find_if(begin(entities), end(entities),
               [](auto &amp;&amp; e) { return !e.taken(); };
      p != end(entities)) {
      p-&gt;take();
<strong class="bold">      return &amp;(*p); // non-owning pointer</strong>
   }
   throw nothing_left{};
}</pre> <p>Note that <code>borrow_one()</code> shares <a id="_idIndexMarker266"/>a pointer with the calling code but does not share <em class="italic">ownership</em> of that pointer – the provider of the <code>entity</code> objects remains solely responsible for the lifetime of these objects in this case. This would neither be a case for <code>std::unique_ptr</code> (the sole owner of the resource) nor <code>std::shared_ptr</code> (the co-owner of the resource). There are alternatives to using raw pointers to express a non-owning pointer, as we will see in <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>.</p>
<p>The important point here is that <em class="italic">function signatures convey meaning</em>, and it’s important to use the types that convey our intent. To do so, we have to understand that intent. Let’s keep <a id="_idIndexMarker267"/>that in mind as we explore how to use the standard smart pointers to our advantage in the following sections.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/>Type unique_ptr</h1>
<p>As its name <a id="_idIndexMarker268"/>suggests, a <code>unique_ptr&lt;T&gt;</code> object<a id="_idIndexMarker269"/> represents sole (unique) ownership of a pointed-to object. That happens to be a common case – maybe even the most common case – of ownership semantics when dealing with dynamically allocated memory.</p>
<p>Consider our first (still deliberately incomplete) example in this chapter, where ownership of the <em class="italic">pointee</em> was not something we could determine from the source code, and let’s rewrite it with <code>unique_ptr</code> objects instead of raw pointers:</p>
<pre class="source-code">
<strong class="bold">#include &lt;memory&gt;</strong>
class X {
   // ...
};
<strong class="bold">std::unique_ptr&lt;X&gt;</strong> f();
void g(<strong class="bold">std::unique_ptr&lt;X&gt;&amp;);</strong>
void h() {
   // we could write std::unique_ptr&lt;X&gt; instead of auto
   <strong class="bold">auto</strong> p = f();
   g(p);
} <code>f()</code> is responsible for the lifetime of the <code>X</code> object it points to, and it’s also clear that <code>g()</code> uses the enclosed <code>X*</code> without becoming responsible for the pointed-to <code>X</code> object. Add to this the fact that <code>p</code> is an object and, as such, will be destroyed if <code>g()</code> throws or if <code>f()</code> is called in such a way that the calling code forgets to use the return value, and you get an exception-safe program – one that’s shorter and simpler than the original one!</p>
<p class="callout-heading">Murphy and Machiavelli</p>
<p class="callout">You might be thinking, “<em class="italic">But I’m sure I could steal the pointer managed by the </em><code>std::unique_ptr</code> <em class="italic">in</em> <code>g()</code>,” and you would be correct. Not only is it possible but also easy, as <code>unique_ptr</code> gives you direct access to the underlying pointer in more than one way. However, the type system is designed to protect us from accidents and make reasonable well-written code work well. It will protect you from Murphy, the accidents that happen, not from Machiavelli, the deliberately hostile code.</p>
<p class="callout">If you write deliberately broken code, you will end up with a deliberately broken program. It’s pretty much what you would expect.</p>
<p>In terms of semantics, you could tell a story just with function signatures, using <code>std::unique_ptr</code> objects. Note <a id="_idIndexMarker270"/>that in the following <a id="_idIndexMarker271"/>example, the functions have been left deliberately incomplete to make it clear that we are concerned with their signatures only:</p>
<pre class="source-code">
// ...
// dynamically create an X or something derived from
// X and return it without risk of a leak
<strong class="bold">unique_ptr&lt;X&gt; factory(args);</strong>
// pass-by-value which means in practice pass-by-movement
// since unique_ptr is uncopiable
<strong class="bold">unique_ptr&lt;X&gt; borrowing(unique_ptr&lt;X&gt;);</strong>
// pass-by-reference to allow mutating the pointee. In
// practice, X* would be a better choice here
<strong class="bold">void possible_mutation(unique_ptr&lt;X&gt;&amp;);</strong>
// pass by reference-to-const to consult the pointee but
// not mutate it. In practice, prefer const X* here
<strong class="bold">void consult(const unique_ptr&lt;X&gt;&amp;);</strong>
// sink() consumes the object passed as argument : gets
// in, never gets out. This could use pass-by-value but
// intent is probably clearer with a rvalue-reference
<strong class="bold">void sink(unique_ptr&lt;X&gt; &amp;&amp;);</strong>
// ...</pre> <p>As we can see, function<a id="_idIndexMarker272"/> signatures talk to us. It’s <a id="_idIndexMarker273"/>better if we pay attention.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>Handling objects</h2>
<p>The <code>unique_ptr</code> type is<a id="_idIndexMarker274"/> a remarkable tool, one you should strive to get acquainted with if you have not done so already. Here are some interesting facts about that type and how it can be used to manage pointers to objects.</p>
<p>A <code>unique_ptr&lt;T&gt;</code> object is non-copyable, as its copy constructor and copy assignment member functions are marked as deleted. That’s why <code>g()</code> in the first example of the <em class="italic">Type unique_ptr</em> section takes its argument by reference – <code>g()</code> shares the pointee with the caller but does not take ownership of it. We could also have expressed <code>g()</code> as taking <code>X*</code> as an argument, with the contemporary acceptance that function arguments that are raw pointers are meant to model using a pointer but without owning it:</p>
<pre class="source-code">
#include &lt;memory&gt;
class X {
   // ...
};
std::unique_ptr&lt;X&gt; f();
<strong class="bold">void g(X*);</strong>
void h() {
   // we could write std::unique_ptr&lt;X&gt; instead of auto
   auto p = f();
   g(<strong class="bold">p.get()</strong>);
} // p implicitly releases the pointed-to X object here</pre> <p><code>unique_ptr&lt;T&gt;</code> is also movable – a moved-from <code>unique_ptr&lt;T&gt;</code> behaves like a null pointer, as the movement for this type semantically implements a transfer of ownership. This makes it simpler to implement various types that need to manage resources indirectly.</p>
<p>Consider, for example, the following <code>solar_system</code> class, which supposes a hypothetical <code>Planet</code> type <a id="_idIndexMarker275"/>as well as a hypothetical implementation for <code>create_planet()</code>:</p>
<pre class="source-code">
#include “planet.h”
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
std::unique_ptr&lt;Planet&gt;
   create_planet(std::string_view name);
class solar_system {
   <strong class="bold">std::vector&lt;std::unique_ptr&lt;Planet&gt;&gt;</strong> planets {
      create_planet(“mercury.data”),
      create_planet(“venus.data”), // etc.
   };
public:
<strong class="bold">   // solar_system is uncopyable by default</strong>
<strong class="bold">   // solar_system is movable by default</strong>
<strong class="bold">   // no need to write ~solar_system as planets</strong>
<strong class="bold">   // manages its resources implicitly</strong>
};</pre> <p>If we had decided to implement <code>solar_system</code> with <code>vector&lt;Planet*&gt;</code> or as <code>Planet*</code> instead, then the memory management of our type would have to be performed by <code>solar_system</code> itself, adding to the complexity of that type. Since we used a <code>vector&lt;unique_ptr&lt;Planet&gt;&gt;</code>, everything is implicitly correct by default. Of course, depending on what we are doing, <code>vector&lt;Planet&gt;</code> might be even better, but let’s suppose we need pointers for the sake of the example.</p>
<p>A <code>unique_ptr&lt;T&gt;</code> offers most of the same operations as <code>T*</code>, including <code>operator*()</code> and <code>operator-&gt;()</code>, as well as the ability to compare them with <code>==</code> or <code>!=</code> to see whether two <code>unique_ptr&lt;T&gt;</code> objects point to the same <code>T</code> object. The latter two might seem strange, as the type represents sole ownership of the <em class="italic">pointee</em>, but you could use<a id="_idIndexMarker276"/> references to <code>unique_ptr&lt;T&gt;</code>, in which case these functions make sense:</p>
<pre class="source-code">
#include &lt;memory&gt;
template &lt;class T&gt;
   bool point_to_same(const std::unique_ptr&lt;T&gt; &amp;p0,
                      const std::unique_ptr&lt;T&gt; &amp;p1) {
      return p0 == p1;
   }
template &lt;class T&gt;
   bool have_same_value(const std::unique_ptr&lt;T&gt; &amp;p0,
                        const std::unique_ptr&lt;T&gt; &amp;p1) {
      return p0 &amp;&amp; p1 &amp;&amp; *p0 == *p1;
   }
#include &lt;cassert&gt;
int main() {
   // two distinct pointers to objects with same value
   std::unique_ptr&lt;int&gt; a{ new int { 3 } };
   std::unique_ptr&lt;int&gt; b{ new int { 3 } };
   assert(point_to_same(a, a) &amp;&amp; have_same_value(a, a));
   assert(!point_to_same(a, b) &amp;&amp; have_same_value(a, b));
}</pre> <p>For good reasons, you cannot do pointer arithmetic on <code>unique_ptr&lt;T&gt;</code>. If you need to do pointer arithmetic (and we sometimes will – for example, when we write our own containers in <a href="B21071_13.xhtml#_idTextAnchor187"><em class="italic">Chapter 13</em></a>), it’s always possible to get to the raw pointer owned by a <code>unique_pointer&lt;T&gt;</code> through its <code>get()</code> member function. This is often useful when interfacing with C libraries, making system calls, or calling functions that use a raw pointer without taking ownership of it.</p>
<p>Oh, and here’s a fun fact – <code>sizeof(unique_ptr&lt;T&gt;)==sizeof(T*)</code> with a few exceptions that will be discussed later in this chapter. This means that there’s generally no cost in terms <a id="_idIndexMarker277"/>of memory space to using a smart pointer instead of a raw pointer. In other words, by default, the only state found in a <code>unique_ptr&lt;T&gt;</code> object is <code>T*</code>.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor087"/>Handling arrays</h2>
<p>A nice aspect <a id="_idIndexMarker278"/>of <code>unique_ptr</code> is that it offers a specialization to handle arrays. Consider the following:</p>
<pre class="source-code">
void f(int n) {
   // p points to an int of value 3
   std::unique_ptr&lt;int&gt; p{ new int{ 3 } };
   <strong class="bold">// q points to an array of n int objects</strong>
   <strong class="bold">// initialized to zero</strong>
   <strong class="bold">std::unique_ptr&lt;int[]&gt; q{ new int[n] {} };</strong>
   // example usage
   std::cout &lt;&lt; *p &lt;&lt; ‘\n’; // displays 3
   for(int i = 0; i != n; ++i) {
      <strong class="bold">// operator[] supported for unique_ptr&lt;T[]&gt;</strong>
<strong class="bold">      q[i] = i + 1;</strong>
   }
   // ...
} <strong class="bold">// the destructor of q calls delete [] on its pointee</strong>
  // the destructor of p calls delete on its pointee</pre> <p>What, you might think, is the use case for this? Well, it all depends on your needs. For example, if you require a variable-sized array of <code>T</code> that grows as needed, use <code>vector&lt;T&gt;</code>. It’s a wonderful tool and extremely efficient if used well.</p>
<p>If you want a fixed-sized array that’s small enough to fit on your execution stack where the number of elements, <code>N</code>, is known at compile time, use a raw array of <code>T</code> or an object of type <code>std::array&lt;T,N&gt;</code>.</p>
<p>If you want a fixed-sized array that’s either not small enough to fit on your execution stack or where the number of elements, <code>n</code>, is known at runtime, you can use <code>vector&lt;T&gt;</code>, but you’ll pay for facilities you might not require (<code>vector&lt;T&gt;</code> remains an awesome choice, that being said), or you could use <code>unique_ptr&lt;T[]&gt;</code>. Note that if you go for this latter option, you will end up having to track the size yourself, separately from the actual array, since <code>unique_ptr</code> does no such tracking. Alternatively, of<a id="_idIndexMarker279"/> course, you can wrap it in your own abstraction, such as <code>fixed_size_array&lt;T&gt;</code>, as follows:</p>
<pre class="source-code">
#include &lt;cstddef&gt;
#include &lt;memory&gt;
template &lt;class T&gt;
   class fixed_size_array {
      std::size_t nelems{};
<strong class="bold">      std::unique_ptr&lt;T[]&gt; elems {};</strong>
   public:
      fixed_size_array() = default;
      auto size() const { return nelems; }
      bool empty() const { return size() == 0; }
     fixed_size_array(std::size_t n)
         : nelems { n }, elems{ new T[n] {} } {
      }
      T&amp; operator[](int n) { return elems[n]; }
      const T&amp; operator[](int n) const { return elems[n]; }
      // etc.
   };</pre> <p>This is a naïve implementation that brings together knowledge of the number of elements with implicit ownership of the resource. Note that we don’t have to write the copy operations (unless we want to implement them!), the move operations, or the destructor, as they all implicitly do something reasonable. Also, this type will be relatively efficient if type <code>T</code> is trivially constructible but will (really) not be as efficient as <code>vector&lt;T&gt;</code> for numerous use cases. Why is that? Well, it so happens that <code>vector</code> does significantly better memory management than we do… but we’ll get there.</p>
<p>Note that, as with <a id="_idIndexMarker280"/>scalar types, the fact that <code>sizeof(unique_ptr&lt;T[]&gt;)</code> is equal to <code>sizeof(T*)</code> is also true, which I’m sure we can all appreciate.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor088"/>Custom deleters</h2>
<p>You might <a id="_idIndexMarker281"/>think, “<em class="italic">Well, in my code base, we don’t use </em><code>delete</code><em class="italic"> to deallocate objects because [insert your favorite reason here], so I cannot use </em><code>unique_ptr</code>.” There are indeed many situations where applying <code>operator delete</code> on a pointer to destroy the pointed-to object is not an option:</p>
<ul>
<li>Sometimes, <code>T::~T()</code> is <code>private</code> or <code>protected</code>, making it inaccessible to other classes such as <code>unique_ptr&lt;T&gt;</code>.</li>
<li>Sometimes, the finalization semantics require doing something else than calling <code>delete</code> – for example, calling a <code>destroy()</code> or <code>release()</code> member function</li>
<li>Sometimes, the expectation is to call a free function that will perform auxiliary work in addition to freeing a resource.</li>
</ul>
<p>No matter what the reasons are for freeing a resource in an unconventional manner, <code>unique_ptr&lt;T&gt;</code> can<a id="_idIndexMarker282"/> take a <code>T*</code> stored within <code>unique_ptr&lt;T&gt;</code> when the destructor of that smart pointer is called. Indeed, the actual signature of the <code>unique_ptr</code> template is as follows:</p>
<pre class="source-code">
template&lt;class T, <strong class="bold">class D = std::default_delete&lt;T&gt;&gt;</strong>
   class unique_ptr {
      // ...
   };</pre> <p>Here, <code>default_delete&lt;T&gt;</code> itself is essentially the following:</p>
<pre class="source-code">
template&lt;class T&gt; struct default_delete {
   constexpr default_delete() noexcept = default;
   // <strong class="bold">...</strong>
<strong class="bold">   constexpr void operator()(T *p) const { delete p; }</strong>
<code>};</code></pre> <p>The presence of a default type for <code>D</code> is what usually allows us to write code that ignores that parameter. The <code>D</code> parameter in the <code>unique_ptr&lt;T,D&gt;</code> signature is expected to be stateless, as it’s not stored within the <code>unique_ptr</code> object but instantiated as needed, and then it’s used as a function that takes the pointer and does whatever is required to finalize the <em class="italic">pointee</em>.</p>
<p>As such, imagine the following class with a <code>private</code> destructor, a common technique if you seek to prevent <a id="_idIndexMarker283"/>instantiation through other means than dynamic allocation (you cannot use an automatic or a static object of that type, since it cannot be implicitly destroyed):</p>
<pre class="source-code">
#include &lt;memory&gt;
class requires_dynamic_alloc {
   <strong class="bold">~requires_dynamic_alloc() = default; // private</strong>
<strong class="bold">   </strong><strong class="bold">// ...</strong>
<strong class="bold">   friend struct cleaner;</strong>
<strong class="bold">};</strong>
<strong class="bold">// ...</strong>
<strong class="bold">struct cleaner {</strong>
<strong class="bold">   template &lt;class T&gt;</strong>
<strong class="bold">      void operator()(T *p) const { delete p; }</strong>
<strong class="bold">};</strong>
int main() {
   using namespace std;
   // requires_dynamic_alloc r0; // no
   //auto p0 = unique_ptr&lt;requires_dynamic_alloc&gt;{
   //   new requires_dynamic_alloc
   //}; // no, as delete not available to default deleter
   auto p1 = <strong class="bold">unique_ptr&lt;requires_dynamic_alloc, cleaner&gt;</strong>{
      new requires_dynamic_alloc
   }; <strong class="bold">// ok, will use cleaner::operator() to delete pointee</strong>
}</pre> <p>Note that by making the <code>cleaner</code> functor its friend, the <code>requires_dynamic_alloc</code> class lets <code>cleaner</code> specifically access both its <code>protected</code> and <code>private</code> members, which includes access to its <code>private</code> destructor.</p>
<p>Imagine now that we are using an object through an interface that hides from client code information on whether we are the sole owner of the pointed-to resource, or whether we share that resource with others. Also, imagine that the potential sharing of that resource is <a id="_idIndexMarker284"/>done through intrusive means, as is done on many platforms, such that the way to signal that we are disconnecting from that resource is to call its <code>release()</code> member function, which will, in turn, either take into account that we have disconnected or free the resource if we were its last users. To simplify client code, our code base has a <code>release()</code> free function that calls the <code>release()</code> member function on such a pointer if it is non-null.</p>
<p>We can still use <code>unique_ptr</code> for this, but note the syntax, which is slightly different, as we will need to pass the function pointer as an argument to the constructor, since that pointer will be stored within. Thus, this specialization of <code>unique_ptr</code> with a function pointer as a <em class="italic">deleter</em> leads to a slight size increase:</p>
<pre class="source-code">
#include &lt;memory&gt;
struct releasable {
   void release() {
      // overly simplified for the sake of this example
      delete this;
   }
protected:
   ~releasable() = default;
};
class important_resource : public releasable {
   // ...
};
void release(releasable *p) {
   if(p) p-&gt;release();
}
int main() {
   using namespace std;
   <strong class="bold">auto p = unique_ptr&lt;</strong>important_resource,
                       <strong class="bold">void(*)(releasable*)&gt;{</strong>
      new important_resource<strong class="bold">, release</strong>
   <strong class="bold">}; // ok, will use release() to delete pointee</strong>
}</pre> <p>If the extra cost of <a id="_idIndexMarker285"/>a function pointer’s size (plus alignment) in the size of <code>unique_ptr</code> is unacceptable (for example, because you are on a resource-constrained platform or because you have a container with many <code>unique_ptr</code> objects, which makes the costs increase significantly faster), there’s a neat trick you can play by pushing the runtime use of the <code>deleter</code> function into the wonderful world of the type system:</p>
<pre class="source-code">
#include &lt;memory&gt;
struct releasable {
   void release() {
      // overly simplified for the sake of this example
      delete this;
   }
protected:
   ~releasable() = default;
};
class important_resource : public releasable {
   // ...
};
void release(releasable *p) {
   if(p) p-&gt;release();
}
int main() {
   using namespace std;
   auto p = unique_ptr&lt;important_resource,
                       <strong class="bold">void(*)(releasable*)</strong>&gt;{
      new important_resource, <strong class="bold">release</strong>
   }; // ok, will use release() to delete pointee
<strong class="bold">   static_assert(sizeof(p) &gt; sizeof(void*));</strong>
   auto q = unique_ptr&lt;
      important_resource,
      <strong class="bold">decltype([](auto p) { release(p); })</strong>&gt;{
      new important_resource
   };
   <strong class="bold">static_assert(sizeof(q) == sizeof(void*))</strong>;
}</pre> <p>As you can see, in the case of <code>p</code>, we used a function pointer as a deleter, which requires storing the address of the function, whereas with <code>q</code>, we replaced the function pointer with the <em class="italic">type of a hypothetical lambda</em>, which will, when instantiated, call that function, passing<a id="_idIndexMarker286"/> the pointer as an argument. It’s simple and can save space if used judiciously!</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor089"/>make_unique</h2>
<p>Since C++14, <code>unique_ptr&lt;T&gt;</code> has <a id="_idIndexMarker287"/>been accompanied by <a id="_idIndexMarker288"/>a factory function that perfectly forwards its arguments to a constructor of <code>T</code>, allocates and constructs the <code>T</code> as well as <code>unique_ptr&lt;T&gt;</code> to hold it, and returns the resulting object. That function is <code>std::make_unique&lt;T&gt;(args...)</code>, and a naïve implementation would be as follows:</p>
<pre class="source-code">
<code>template &lt;class T, class ... Args&gt;</code>
<code>   std::unique_ptr&lt;T&gt; make_unique(Args &amp;&amp;... args) {</code>
<code>      return std::unique_ptr&lt;T&gt;{</code>
<code>         new T(std::forward&lt;Args&gt;(args)...);</code>
<code>      }</code>
<code>   }</code></pre> <p>There are also variants to create a <code>T[]</code>, of course. You might wonder what the point of such a function is, and indeed, that function was not shipped along with <code>unique_ptr</code> initially (<code>unique_ptr</code> is a C++11 type), but consider the following (contrived) example:</p>
<pre class="source-code">
template &lt;class T&gt;
   class pair_with_alloc {
      T *p0, *p1;
   public:
      pair_with_alloc(const T &amp;val0, const T &amp;val1)
         : p0{ new T(val0) }, p1{ new T(val1) } {
      }
      ~pair_with_alloc() {
         delete p1; delete p0;
      }
      // copy and move operations left to your imagination
   };</pre> <p>We can suppose from this example that this class is used when, for some reason, client code prefers to dynamically allocate the <code>T</code> objects (in practice, using objects rather than pointers to objects makes your life simpler). Knowing that subobjects in a C++ object are constructed in order<a id="_idIndexMarker289"/> of declaration, we know that <code>p0</code> will be <a id="_idIndexMarker290"/>constructed before <code>p1</code>:</p>
<pre class="source-code">
// ...
      T *p0, *p1; <strong class="bold">// p0 declared before p1</strong>
   public:
<strong class="bold">// below:</strong>
<strong class="bold">// - new T(val0) will occur before construction of p0</strong>
<strong class="bold">// - new T(val1) will occur before construction of p1</strong>
<strong class="bold">// - construction of p0 will precede construction of p1</strong>
      pair_with_alloc(const T &amp;val0, const T &amp;val1)
         : p0{ new T(val0) }, p1{ new T(val1) } {
      }
// ...</pre> <p>However, suppose that the order of operations is <code>new T(val0)</code>, the construction of <code>p0</code>, <code>new T(val1)</code>, and the construction of <code>p1</code>. What happens then if <code>new T(val1)</code> throws an exception, either because <code>new</code> fails to allocate sufficient memory or because the constructor of <code>T</code> fails? You might be tempted to think that the destructor of <code>pair_with_alloc</code> will clean up, but that will not be the case – for a destructor to be called, the corresponding constructor must have completed first; otherwise, there is no object to destroy!</p>
<p>There are ways around this ,of course. One of them might be to use <code>unique_ptr&lt;T&gt;</code> instead of <code>T*</code>, which would be wonderful, given that this is what we’re currently discussing! Let’s rewrite <code>pair_with_alloc</code> that way:</p>
<pre class="source-code">
#include &lt;memory&gt;
template &lt;class T&gt;
   class pair_with_alloc {
      <strong class="bold">std::unique_ptr&lt;T&gt; p0, p1;</strong>
   public:
      pair_with_alloc(const T &amp;val0, const T &amp;val1)
         : p0{ new T(val0) }, p1{ new T(val1) } {
      }
      // destructor implicitly correct
      // copy and move operations implicitly work
      // or are left to your imagination
   };</pre> <p>With this version, if the<a id="_idIndexMarker291"/> order of operations is <code>new T(val0)</code>, the <a id="_idIndexMarker292"/>construction of <code>p0</code>, <code>new T(val1)</code>, the construction of <code>p1</code>, then if <code>new T(val1)</code> throws an exception, the <code>pair_with_alloc</code> object will still not be destroyed (it has not been constructed). However, <code>p0</code> itself <em class="italic">has</em> been constructed by that point, and as such, it will be destroyed. Our code has suddenly become simpler and safer!</p>
<p>What then has that to do with <code>make_unique&lt;T&gt;()</code>? Well, there’s a hidden trap here. Let’s look closer at the order of operations in our constructor:</p>
<pre class="source-code">
// ...
      std::unique_ptr&lt;T&gt; p0, p1; <strong class="bold">// p0 declared before p1</strong>
   public:
<strong class="bold">// below, suppose we identify the operations as follows:</strong>
<strong class="bold">// A: new T(val0)</strong>
<strong class="bold">// B: construction of p0</strong>
<strong class="bold">// C: new T(val1)</strong>
<strong class="bold">// D: construction of p1</strong>
<strong class="bold">// We know that:</strong>
<strong class="bold">// - A precedes B</strong>
<strong class="bold">// - C precedes D</strong>
<strong class="bold">// - B precedes D</strong>
      pair_with_alloc(const T &amp;val0, const T &amp;val1)
         : p0{ new T(val0) }, p1{ new T(val1) } {
      }
// ...</pre> <p>If you look at the rules laid out in the comments, you will see that we could have the operations in the following order, A→B→C→D, but we could also have them ordered as A→C→B→D or C→A→B→D, in which case the two calls to <code>new T(...)</code> would occur, followed by the two <code>unique_ptr&lt;T&gt;</code> constructors. If this happens, then an exception thrown by the second call to <code>new</code> or the associated constructor of <code>T</code> would still lead to a resource leak.</p>
<p>Now, that’s a<a id="_idIndexMarker293"/> shame. But <a id="_idIndexMarker294"/>that’s also the point of <code>make_unique&lt;T&gt;()</code> – with a factory function, client code never finds itself with “floating results from calls to <code>new</code>”; it either has a complete <code>unique_ptr&lt;T&gt;</code> object or not:</p>
<pre class="source-code">
#include &lt;memory&gt;
template &lt;class T&gt;
   class pair_with_alloc {
      <strong class="bold">std::unique_ptr&lt;T&gt; p0, p1;</strong>
   public:
      <strong class="bold">pair_with_alloc(const T &amp;val0, const T &amp;val1)</strong>
         <strong class="bold">: p0{ std::make_unique&lt;T&gt;(val0) },</strong>
           <strong class="bold">p1{ std::make_unique&lt;T&gt;(val1) } {</strong>
      <strong class="bold">}</strong>
      // destructor implicitly correct
      // copy and move operations implicitly work
      // or are left to your imagination
   };
#include &lt;string&gt;
#include &lt;random&gt;
#include &lt;iostream&gt;
class risky {
   std::mt19937 prng{ std::random_device{}() };
   std::uniform_int_distribution&lt;int&gt; penny{ 0,1 };
public:
   risky() = default;
   risky(const risky &amp;) {
      if(penny(prng)) throw 3; // throws 50% of the time
   }
   ~risky() {
      std::cout &lt;&lt; “~risky()\n”;
   }
};
int main() {
   // the following objects do not leak even if
   // an exception is thrown
   if(std::string s0, s1; std::cin &gt;&gt; s0 &gt;&gt; s1)
      try {
         pair_with_alloc a{ s0, s1 };
         pair_with_alloc b{ risky{}, risky{} };
      } catch(...) {
         std::cerr &lt;&lt; “Something was thrown...\n”;
      }
}</pre> <p>As you can see, <code>make_unique&lt;T&gt;()</code> is a security feature, mostly useful to avoid exposing ownerless resources in client code. As a bonus, <code>make_unique&lt;T&gt;()</code> allows us to limit how we repeat ourselves in source code. Check the following:</p>
<pre class="source-code">
unique_ptr&lt;some_type&gt; p0 { new some_type{ args } };
auto p1 = unique_ptr&lt;some_type&gt; { new some_type{ args } };
auto p2 = make_unique&lt;some_type&gt;(args);</pre> <p>As you can <a id="_idIndexMarker295"/>see, <code>p0</code> and <code>p1</code> require you to spell the name of the <a id="_idIndexMarker296"/>pointed-to type twice whereas <code>p2</code> only requires you to write it once. That’s always nice.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor090"/>Types shared_ptr and weak_ptr</h1>
<p>In most cases, <code>unique_ptr&lt;T&gt;</code> will <a id="_idIndexMarker297"/>be your smart <a id="_idIndexMarker298"/>pointer of<a id="_idIndexMarker299"/> choice. It’s<a id="_idIndexMarker300"/> small, fast, and does what most code requires. There are some specialized but important use cases where <code>unique_ptr&lt;T&gt;</code> is not what you need, and these have in common the following:</p>
<ul>
<li>The semantics being conveyed is the <em class="italic">shared ownership</em> of the resource</li>
<li>The last owner of the resource is not known a priori (which mostly happens in concurrent code)</li>
</ul>
<p>Note that if the execution is not concurrent, you will, in general, know who the last owner of the resource is – it’s the last object to observe the resource that will be destroyed in the program. This is an important point – you can have concurrent code that shares resources and still uses <code>unique_ptr</code> to manage the resource. Non-owning users of the resource, such as raw pointers, can access it without taking ownership (more on that later in this chapter), and this approach is sufficient.</p>
<p>You can, of course, have non-concurrent code where the last owner of a resource is not known a priori. An example might involve a protocol where the provider of the resource still holds on to it after returning it to the client, but they might be asked to release it at a later point while client code retains it, making the client the last owner from that point on, or they might never be asked to release it, in which case the provider might be the last owner of the resource. Such situations are highly specific, obviously, but they show that there might be reasons to use shared ownership semantics as expressed through <code>std::shared_ptr</code>, even in non-concurrent code.</p>
<p>Since concurrent code remains the posterchild for situations where the last owner of a shared resource is not known a priori, we will use this as a basis for our investigation. Remember this example from the beginning of this chapter:</p>
<pre class="source-code">
// ...
void f() {
   X *p = new X;
   thread th0{ [p] { /* use *p */ };
   thread th1{ [p] { /* use *p */ };
   th0.detach();
   th1.detach();
}</pre> <p>Here, <code>p</code> in <code>f()</code> does <a id="_idIndexMarker301"/>not own the <code>X</code> it points to, being <a id="_idIndexMarker302"/>a<a id="_idIndexMarker303"/> raw <a id="_idIndexMarker304"/>pointer, and both <code>th0</code> and <code>th1</code> copy that raw pointer, so neither is responsible for the pointee (at least on the basis of the rules enforced by the type system; you could envision acrobatics to make this work, but it’s involved, tricky, and bug-prone).</p>
<p>This example can be amended to have clear ownership semantics by shifting <code>p</code> from <code>X*</code> to <code>shared_ptr&lt;X&gt;</code>. Indeed, let’s consider the following:</p>
<pre class="source-code">
// ...
void f() {
   <strong class="bold">std::shared_ptr&lt;X&gt; p { new X };</strong>
   thread th0{ [<strong class="bold">p</strong>] { /* use *p */ };
   thread th1{ [<strong class="bold">p</strong>] { /* use *p */ };
   th0.detach();
   th1.detach();
}</pre> <p>In <code>f()</code>, the <code>p</code> object is initially the sole owner of the <code>X</code> it points to. When <code>p</code> is copied, as it is in the capture blocks of the lambdas executed by <code>th0</code> and <code>th1</code>, the mechanics of <code>shared_ptr</code> ensure that <code>p</code> and its two copies share both <code>X*</code> and an integral counter, used to determine how many shared owners there are for the resource.</p>
<p>The key functions of <code>shared_ptr</code> are its copy constructor (shares the resource and increments the counter), copy assignment (disconnects from the original resource, decrementing its counter, and then connects to the new resource, incrementing its counter), and the destructor (decrements the counter and destroys the resource if there’s no owner left). Each of these functions is subtle to implement; to help understand what the stakes are, we will provide simplified implementation examples in <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>. Move semantics, unsurprisingly, implement transfer of ownership semantics for <code>shared_ptr</code>.</p>
<p>Note that <code>shared_ptr&lt;T&gt;</code> implements extrusive (non-intrusive) shared ownership semantics. Type <code>T</code> could be a fundamental type and does not need to implement a particular interface <a id="_idIndexMarker305"/>for<a id="_idIndexMarker306"/> this <a id="_idIndexMarker307"/>type to work. This differs from the intrusive<a id="_idIndexMarker308"/> shared semantics that were mentioned earlier in this chapter, with the <code>releasable</code> type an example.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/>Usefulness and costs</h2>
<p>There <a id="_idIndexMarker309"/>are<a id="_idIndexMarker310"/> intrinsic costs to the <code>shared_ptr&lt;T&gt;</code> model. The most obvious one is that <code>sizeof(shared_ptr&lt;T&gt;)&gt;sizeof(unique_ptr&lt;T&gt;)</code> for any type <code>T</code>, since <code>shared_ptr&lt;T&gt;</code> needs to handle both a pointer to the shared resource and a pointer to the shared counter.</p>
<p>Another cost is that copying a <code>shared_ptr&lt;T&gt;</code> is not a cheap operation. Remember that <code>shared_ptr&lt;T&gt;</code> makes sense mostly in concurrent code, where you do not know a priori the last owner of a resource. For that reason, the increments and decrements of the shared counter require synchronization, meaning that the counter is typically an <code>atomic</code> integer, and mutating an <code>atomic&lt;int&gt;</code> object (for example) costs more than mutating an <code>int</code>.</p>
<p>Another non-negligible cost is the following:</p>
<pre class="source-code">
shared_ptr&lt;X&gt; p{ new X };</pre> <p>An instruction such as this one will lead to <em class="italic">two</em> allocations, not one – there will be one for the <code>X</code> object and another one (performed internally by the <code>shared_ptr</code>) for the counter. Since these two allocations will be done separately, one by the client code and one by the constructor itself, the two allocated objects might find themselves in distinct cache lines, potentially <a id="_idIndexMarker311"/>leading to a loss of efficiency <a id="_idIndexMarker312"/>when accessing the <code>shared_ptr</code> object.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/>make_shared()</h2>
<p>There is a way to <a id="_idIndexMarker313"/>alleviate the latter cost, and that is to <a id="_idIndexMarker314"/>make the same entity perform both allocations, instead of letting the client code do one and the constructor do the other. The standard tool to achieve this is the <code>std::make_shared&lt;T&gt;()</code> factory function.</p>
<p>Compare the following two instructions:</p>
<pre class="source-code">
shared_ptr&lt;X&gt; p{ new X(args) };
auto q = make_shared&lt;X&gt;(args);</pre> <p>When constructing <code>p</code>, <code>shared_ptr&lt;X&gt;</code> is provided an existing <code>X*</code> to manage, so it has no choice but to perform a second, separate allocation for the shared counter. Conversely, the call expressed as <code>make_shared&lt;X&gt;(args)</code> specifies the type <code>X</code> to construct along with the arguments <code>args</code> to forward directly to the constructor. It falls upon that function to create <code>shared_ptr&lt;X&gt;</code>, <code>X</code>, and the shared counter, which lets us put both <code>X</code> and the counter in the same contiguous <a id="_idIndexMarker315"/>space (the <strong class="bold">control block</strong>), using mechanisms such as a <em class="italic">union</em> or the <em class="italic">placement new</em> mechanism, which will be explored in <a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a>.</p>
<p>Clearly, given the same arguments used for construction, the preceding <code>p</code> and <code>q</code> will be equivalent <code>shared_ptr&lt;X&gt;</code> objects, but in general, <code>q</code> will perform better than <code>p</code>, as its two key components will be organized in a more cache-friendly manner.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor093"/>What about weak_ptr?</h2>
<p>If <code>shared_ptr&lt;T&gt;</code> is a type <a id="_idIndexMarker316"/>with a narrower (yet essential) niche than <code>unique_ptr&lt;T&gt;</code>, <code>weak_ptr&lt;T&gt;</code> occupies an even narrower (but still essential) niche. The role of <code>weak_ptr&lt;T&gt;</code> is to model the <em class="italic">temporary</em> ownership of <code>T</code>. Type <code>weak_ptr&lt;T&gt;</code> is meant to interact with <code>shared_ptr&lt;T&gt;</code> in a way that makes the continued existence of the <em class="italic">pointee</em> testable from client code.</p>
<p>A good example of <code>weak_ptr</code> usage, inspired by the excellent <code>cppreference</code> website (<a href="https://en.cppreference.com/w/cpp/memory/weak_ptr">https://en.cppreference.com/w/cpp/memory/weak_ptr</a>), is as follows:</p>
<pre class="source-code">
// inspired from a cppreference example
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;format&gt;
void observe(<strong class="bold">std::weak_ptr</strong>&lt;int&gt; w) {
   <strong class="bold">if (std::shared_ptr&lt;int&gt; sh = w.lock())</strong>
      std::cout &lt;&lt; std::format(“*sh == {}\n”, *sh);
   else
      std::cout &lt;&lt; “w is expired\n”;
} 
int main() {
   <strong class="bold">std::weak_ptr&lt;int&gt; w;</strong>
   {
      auto sh = std::make_shared&lt;int&gt;(3);
      <strong class="bold">w = sh; // weak_ptr made from shared_ptr</strong>
      <strong class="bold">// w points to a live shared_ptr&lt;int&gt; here</strong>
      <strong class="bold">observe(w);</strong>
   }
   <strong class="bold">// w points to an expired shared_ptr&lt;int&gt; here</strong>
   <strong class="bold">observe(w);</strong>
}</pre> <p>As this example shows, you can make <code>weak_ptr&lt;T&gt;</code> from <code>shared_ptr&lt;T&gt;</code>, but <code>weak_ptr</code> does not own the resource until you call <code>lock()</code> on it, yielding <code>shared_ptr&lt;T&gt;</code>, from which you can safely use the resource after having verified that it does not model an empty pointer.</p>
<p>Another use case for <code>std::weak_ptr</code> and <code>std::shared_ptr</code> would be a cache of resources such that the following occurs:</p>
<ul>
<li>The data in a <code>Resource</code> object is sufficiently big or costly to duplicate that it’s preferable to share it than to copy it</li>
<li>A <code>Cache</code> object shares the objects it stores, but it needs to invalidate them before replacing them when its capacity is reached</li>
</ul>
<p>In such a situation, a <code>Cache</code> object could hold <code>std::shared_ptr&lt;Resource&gt;</code> objects but provide its client code, <code>std::weak_ptr&lt;Resource&gt;</code>, on demand, such that the <code>Resource</code> objects can be disposed of when the <code>Cache</code> needs to do so, but the client code needs<a id="_idIndexMarker317"/> to be able to verify that the objects it points to have not yet been invalidated.</p>
<p>A full (simplified) example would be the following (see the GitHub repository for this book to get the full example):</p>
<pre class="source-code">
// ...
template &lt;auto Cap&gt;
   class Cache {
      using clock = std::chrono::system_clock;
      // a cache of capacity Cap that keeps the
      // most recently used Resource objects
      std::vector&lt;std::pair&lt;
         decltype(clock::now()),
         std::shared_ptr&lt;Resource&gt;
      &gt;&gt; resources;
      bool full() const { return resources.size() == Cap; }
      // precondition: !resources.empty()
      void expunge_one() {
         auto p = std::min_element(
            std::begin(resources), std::end(resources),
            [](auto &amp;&amp; a, auto &amp;&amp; b) {
               return a.first &lt; b.first;
            }
         );
         assert(p != std::end(resources));
<strong class="bold">         p-&gt;second.reset(); // relinquish ownership</strong>
<strong class="bold">         resources.erase(p);</strong>
      }
   public:
      void add(Resource *p) {
         const auto t = clock::now();
<strong class="bold">         if(full()) {</strong>
<strong class="bold">            expunge_one();</strong>
<strong class="bold">         }</strong>
<strong class="bold">         resources.emplace_back(</strong>
<strong class="bold">            t, std::shared_ptr&lt;Resource&gt;{ p }</strong>
<strong class="bold">         );</strong>
      }
      <strong class="bold">std::weak_ptr&lt;Resource&gt;</strong> obtain(Resource::id_type id){
         const auto t = clock::now();
         auto p = std::find_if(
            std::begin(resources),
            std::end(resources),
            [id](auto &amp;&amp; p) {
               return p.second-&gt;id() == id;
            }
         );
         if(p == std::end(resources))
<strong class="bold">            return {};</strong>
<strong class="bold">         p-&gt;first = t;</strong>
<strong class="bold">         return p-&gt;second; // make weak_ptr from shared_ptr</strong>
      }
   };
int main() {
   Cache&lt;5&gt; cache;
   for(int i = 0; i != 5; ++i)
      cache.add(new Resource{ i + 1 });
   // let’s take a pointer to resource 3
<strong class="bold">   auto p = cache.obtain(3);</strong>
<strong class="bold">   if(auto q = p.lock(); q)</strong>
      std::cout &lt;&lt; “Using resource “ &lt;&lt; q-&gt;id() &lt;&lt; ‘\n’;
   // things happen, resources get added, used, etc.
   for(int i = 6; i != 15; ++i)
      cache.add(new Resource{ i + 1 });
<strong class="bold">   if(auto q = p.lock(); q)</strong>
<strong class="bold">      std::cout &lt;&lt; “Using resource “ &lt;&lt; q-&gt;id() &lt;&lt; ‘\n’;</strong>
<strong class="bold">   else</strong>
<strong class="bold">      std::cout &lt;&lt; “Resource not available ...\n”;</strong>
}</pre> <p>After a sufficient number of additions to the cache, the object pointed to by <code>p</code> in <code>main()</code> becomes invalidated and erased from the set of resources, one of our requirements for this example (without that requirement, we could have simply used <code>std::shared_ptr</code> objects in this case). Yet, <code>main()</code> can test for the validity of the object pointed to by <code>p</code> through the construction of <code>std::shared_ptr</code> from the <code>std::weak_ptr</code> it holds.</p>
<p>In practice, <code>weak_ptr</code> is sometimes used to break cycles when <code>shared_ptr</code> objects refer to each other in some way. If you have two types whose objects mutually refer to one another (say, <code>X</code> and <code>Y</code>) and do not know which one will be destroyed first, then consider making one of them the owner (<code>shared_ptr</code>) and the other one the non-owner in a verifiable manner (<code>weak_ptr</code>), which will ensure that they will not keep each other alive<a id="_idIndexMarker318"/> forever. For example, this will conclude, but the <code>X</code> and <code>Y</code> destructors will never be called:</p>
<pre class="source-code">
#include &lt;memory&gt;
#include &lt;iostream&gt;
struct Y;
struct X {
  std::shared_ptr&lt;Y&gt; p;  
  ~X() { std::cout &lt;&lt; “~X()\n”; }
};
struct Y {
  std::shared_ptr&lt;X&gt; p;
  ~Y() { std::cout &lt;&lt; “~Y()\n”; }  
};
void oops() {
  auto x = std::make_shared&lt;X&gt;();
  auto y = std::make_shared&lt;Y&gt;();
  x-&gt;p = y;
  y-&gt;p = x;
}
int main() {
   oops();
   std::cout &lt;&lt; “Done\n”;
}</pre> <p>If you change either <code>X::p</code> or <code>Y::p</code> to <code>weak_ptr</code>, you will see both the <code>X</code> and <code>Y</code> destructors <a id="_idIndexMarker319"/>being called:</p>
<pre class="source-code">
#include &lt;memory&gt;
#include &lt;iostream&gt;
struct Y;
struct X {
  <strong class="bold">std::weak_ptr&lt;Y&gt; p;  </strong>
  ~X() { std::cout &lt;&lt; “~X()\n”; }
};
struct Y {
  std::shared_ptr&lt;X&gt; p;
  ~Y() { std::cout &lt;&lt; “~Y()\n”; }  
};
void oops() {
  auto x = std::make_shared&lt;X&gt;();
  auto y = std::make_shared&lt;Y&gt;();
  x-&gt;p = y;
  y-&gt;p = x;
}
int main() {
   oops();
   std::cout &lt;&lt; “Done\n”;
}</pre> <p>Of course, the easiest way not to get to the point where you face a cycle of <code>shared_ptr&lt;T&gt;</code> objects is to not build such a cycle, but when faced with external libraries and third-party<a id="_idIndexMarker320"/> tools, that’s sometimes easier said than done.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor094"/>When to use raw pointers</h1>
<p>We have seen that<a id="_idIndexMarker321"/> smart pointer types such as <code>unique_ptr&lt;T&gt;</code> and <code>shared_ptr&lt;T&gt;</code> shine when there is a need to describe ownership of a type <code>T</code> resource through the type system. Does that mean that <code>T*</code> has become useless?</p>
<p>No, of course not. The trick is to use it in controlled situations. The first is that for a function, being passed a <code>T*</code> as an argument should mean the function is <em class="italic">an observer, not an owner</em>, of that <code>T</code>. If your code base used raw pointers in that sense, you will most probably not run into trouble.</p>
<p>Secondly, you can use a raw pointer inside a class that implements your preferred ownership semantics. It’s fine to implement a container that manipulates objects through raw pointers (for example, a tree-like structure meant for various traversal orders), as long as that container implements clear copy and move semantics. What you don’t want to do is expose pointers to the internal nodes of your container to external code. Pay attention to the container’s interface.</p>
<p>Indeed, consider this single-linked list of (excerpt):</p>
<pre class="source-code">
template &lt;class T&gt;
   class single_linked_list {
      struct node {
         T value;
         node *next = nullptr;
         node(const T &amp;val) : value { val } {
      };
      node *head = nullptr;
      // ...
    public:
      // ...
      ~single_linked_list() {
         for(auto p = head; p;) {
            auto q = p-&gt;next;
            delete p;
            p = q;
         }
      }
   };</pre> <p>We will explore this example in greater detail in <a href="B21071_13.xhtml#_idTextAnchor187"><em class="italic">Chapter 13</em></a>. The destructor works fine and (supposing the rest of the class is reasonably well-written) the class is usable and useful. Now, suppose we decide to use <code>unique_ptr&lt;node&gt;</code> instead of <code>node*</code> as the <code>head</code> data member for <code>single_linked_list</code>, and as a replacement for the <code>next</code> member of the node. This seems like a<a id="_idIndexMarker322"/> good idea, except when you consider the consequences:</p>
<pre class="source-code">
template &lt;class T&gt;
   class single_linked_list {
      struct node {
         T value;
         <strong class="bold">unique_ptr&lt;node&gt; next; // good idea?</strong>
         node(const T &amp;val) : value { val } {
      };
      <strong class="bold">unique_ptr&lt;node&gt; head; // good idea?</strong>
      // ...
    public:
      // ...
      <strong class="bold">~single_linked_list() = default;</strong>
   };</pre> <p>This seems like a good idea on the surface, but it does not convey the proper semantics – it’s <em class="italic">not</em> true that a node <em class="italic">owns</em> and <em class="italic">is responsible for</em> the next node. We don’t want to make the removal of a node destroy the node that follows (and so on, recursively) and if that looks like a simplification in the destructor of <code>single_linked_list</code>, think about the consequences – this strategy leads to as many destructors recursively called as there are nodes in the list, which is a very good way to achieve a stack overflow!</p>
<p>Use a smart pointer when the use case matches the semantics it models. Of course, when the relationship modeled by your pointers is neither unique ownership nor shared ownership, you probably do not want smart pointer types that provide these semantics, resorting instead to either nonstandard and non-owning smart pointers or, simply, raw pointers.</p>
<p>Finally, you often need raw pointers to use lower-level interfaces – for example, when performing system calls. That does not disqualify higher-level abstractions, such as <code>vector&lt;T&gt;</code> or <code>unique_ptr&lt;T&gt;</code>, when writing system-level code – you can get access to the underlying array of <code>vector&lt;T&gt;</code> through its <code>data()</code> member function, just as you can get access to the underlying raw pointer of <code>unique_ptr&lt;T&gt;</code> through its <code>get()</code> member function. As long as it makes sense, see the called code as borrowing the pointer from the caller code for the duration of the call.</p>
<p>And if you have no other choice, use raw pointers. They exist, after all, and they work. Simply remember to use higher-level abstractions wherever possible – it will make your code <a id="_idIndexMarker323"/>simpler, safer, and (more often than you would think) faster. If you cannot define the higher-level semantics, maybe it’s still a bit early to write that part of the code, and you’ll get better results if you spend more time thinking about these semantics.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor095"/>Summary</h1>
<p>In this chapter, we saw how to use standard smart pointers. We discussed the ownership semantics they implement (sole ownership, shared co-ownership, and temporary co-ownership), saw examples of how they can be used, and discussed some ways in which they can be used while acknowledging that other, more appropriate options exist.</p>
<p>In the next chapter, we’ll take this a step further and write our own (usable, if naïve) versions of <code>unique_ptr&lt;T&gt;</code> and <code>shared_ptr&lt;T&gt;</code>, in order to get an intuitive grasp of what this entails, and we will write some nonstandard but useful smart pointers too. This will help us build a nicer, more interesting resource management toolset.</p>
</div>
</body></html>