<html><head></head><body>
<div epub:type="chapter" id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-79"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.2.1">Using Standard Smart Pointers</span></h1>
<p><span class="koboSpan" id="kobo.3.1">C++ emphasizes programming with values. </span><span class="koboSpan" id="kobo.3.2">By default, your code uses objects, not indirections (references and pointers) to objects. </span><span class="koboSpan" id="kobo.3.3">Indirect access to objects is, of course, allowed, and rare is the program that never uses such semantics, but it is an opt-in and requires additional syntax. </span><a href="B21071_04.xhtml#_idTextAnchor062"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.5.1"> explored the association of resource management with object lifetime through destructors and the RAII idiom, demonstrating one of C++’s main strengths in that essentially all resources (including memory) can be handled implicitly through the very mechanics of </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the language.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">C++ allows the use of raw pointers in code but does not actively encourage it. </span><span class="koboSpan" id="kobo.7.2">Quite the contrary, in fact – raw pointers are a low-level facility, extremely efficient but easy to misuse, and for which it is not easy to infer responsibility about the </span><em class="italic"><span class="koboSpan" id="kobo.8.1">pointee</span></em><span class="koboSpan" id="kobo.9.1"> directly from the source code. </span><span class="koboSpan" id="kobo.9.2">Starting with the (now-removed) </span><strong class="source-inline"><span class="koboSpan" id="kobo.10.1">auto_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.11.1"> facility of decades past, there has been an effort in the C++ community to define abstractions around lower-level facilities, such as raw pointers, through types that provide clear, well-defined semantics and reduce the risk of programming errors. </span><span class="koboSpan" id="kobo.11.2">This effort has met with significant success, in large part due to the expressiveness of the C++ language and its ability to create powerful and efficient abstractions, without losing speed or using more memory at runtime. </span><span class="koboSpan" id="kobo.11.3">For this reason, in contemporary C++, raw pointers are usually encapsulated underneath harder-to-misuse abstractions, examples of which include standard containers and smart pointers, such as the ones we will explore in this chapter; raw pointers that are not encapsulated are mostly used to mean “</span><em class="italic"><span class="koboSpan" id="kobo.12.1">Here’s a resource you can use but do </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.13.1">not own</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">.”</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">This chapter will look at how to use the standard smart pointer types of C++. </span><span class="koboSpan" id="kobo.15.2">We will first look at what they are, and then delve into ways to use the main smart pointer types efficiently. </span><span class="koboSpan" id="kobo.15.3">Finally, we will look at those moments where we need to “get our hands dirty” (so to speak) and use raw pointers, ideally (but not only) through the mediation of smart pointers. </span><span class="koboSpan" id="kobo.15.4">This should lead us to learn how to choose standard smart pointers for a given use case, how to use them appropriately, and how to handle resources that have to be freed through custom mechanisms. </span><span class="koboSpan" id="kobo.15.5">Throughout this journey, we will keep in mind and explain the costs of the choices </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">we make.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this chapter, we will do </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Take a quick look at the general idea of standard smart pointers to develop an idea of their reason </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">for being</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Look more closely at </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.23.1">, including how it can be used to handle scalars, arrays, and release resources that are allocated in </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">atypical ways</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.27.1"> and the use cases for this essential but more costly type, in order to grasp when alternatives should </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">be preferred</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Take a quick look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">std::weak_ptr</span></strong><span class="koboSpan" id="kobo.31.1">, a companion to </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.33.1"> that is useful when there is a need to model temporary </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">shared ownership</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Look at cases where raw pointers should be used, as they still have their place in the </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">C++ ecosystem</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.37.1">Ready? </span><span class="koboSpan" id="kobo.37.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">dive in!</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.39.1">Technical requirements</span></h1>
<p><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.40.1">You can find the code files for this chapter in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter5"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter5</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.44.1">The standard smart pointers</span></h1>
<p><span class="koboSpan" id="kobo.45.1">C++ has a</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.46.1"> relatively small </span><em class="italic"><span class="koboSpan" id="kobo.47.1">zoo</span></em><span class="koboSpan" id="kobo.48.1"> of smart pointers. </span><span class="koboSpan" id="kobo.48.2">Before looking at the set of options provided by the standard, let’s take a moment to show the problem we are trying to solve. </span><span class="koboSpan" id="kobo.48.3">Consider the following (deliberately incomplete) program. </span><span class="koboSpan" id="kobo.48.4">Do you see anything wrong </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">with it?</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.50.1">
class X {
   // ...
</span><span class="koboSpan" id="kobo.50.2">};
X *f();
void g(X *p);
void h() {
   X *p = f();
   g(p);
   delete p;
}</span></pre> <p><span class="koboSpan" id="kobo.51.1">This is code that is legal but not something you want to see in a contemporary program. </span><span class="koboSpan" id="kobo.51.2">There’s just so much that can go wrong here, such as the following from a non-exhaustive list of </span><a id="_idIndexMarker261"/><span class="No-Break"><span class="koboSpan" id="kobo.52.1">potential problems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.53.1">We don’t know whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">g()</span></strong><span class="koboSpan" id="kobo.55.1"> will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">delete p</span></strong><span class="koboSpan" id="kobo.57.1">, leading to a second </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">delete</span></strong><span class="koboSpan" id="kobo.59.1"> (on a destroyed object!) in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">h()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.61.1"> afterward</span></span></li>
<li><span class="koboSpan" id="kobo.62.1">We don’t know whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">g()</span></strong><span class="koboSpan" id="kobo.64.1"> might throw, in which case the </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">delete p;</span></strong><span class="koboSpan" id="kobo.66.1"> instruction in </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">h()</span></strong><span class="koboSpan" id="kobo.68.1"> will never </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">be reached</span></span></li>
<li><span class="koboSpan" id="kobo.70.1">We don’t know whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">h()</span></strong><span class="koboSpan" id="kobo.72.1"> should be assumed to own </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">p</span></strong><span class="koboSpan" id="kobo.74.1">, in the sense that we do not know whether it should be responsible for calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">operator delete()</span></strong><span class="koboSpan" id="kobo.76.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">p</span></strong><span class="koboSpan" id="kobo.78.1"> (maybe it’s meant to be the responsibility of </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">g()</span></strong><span class="koboSpan" id="kobo.80.1">, or some </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">other function)</span></span></li>
<li><span class="koboSpan" id="kobo.82.1">We do not know whether what </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">p</span></strong><span class="koboSpan" id="kobo.84.1"> points to has been allocated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">new</span></strong><span class="koboSpan" id="kobo.86.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">new[]</span></strong><span class="koboSpan" id="kobo.88.1">, or something else (</span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">malloc()</span></strong><span class="koboSpan" id="kobo.90.1">, some facility from another language, some custom utility in your code </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">base, etc.)</span></span></li>
<li><span class="koboSpan" id="kobo.92.1">We don’t even know whether what </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">p</span></strong><span class="koboSpan" id="kobo.94.1"> points to has been dynamically allocated at all; </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">p</span></strong><span class="koboSpan" id="kobo.96.1"> could point to a global or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">static</span></strong><span class="koboSpan" id="kobo.98.1"> variable declared in </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">f()</span></strong><span class="koboSpan" id="kobo.100.1">, for example (a bad idea, but some people do that – for example, when implementing the singleton design pattern in a non-idiomatic way </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">for C++)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.102.1">Compare, for example, two possible implementations of </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">f()</span></strong><span class="koboSpan" id="kobo.104.1"> (there are many, many more we could consider, but these will suffice </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">for now):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.106.1">
X *f() { // here’s one possibility
   return new X;
}
X *f() { // here’s another
   static X x;
   return &amp;x;
}</span></pre> <p><span class="koboSpan" id="kobo.107.1">In the first case, it </span><em class="italic"><span class="koboSpan" id="kobo.108.1">might</span></em><span class="koboSpan" id="kobo.109.1"> make sense to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">delete</span></strong><span class="koboSpan" id="kobo.111.1"> on the returned pointer, but in the second case, it would be disastrous to do so. </span><span class="koboSpan" id="kobo.111.2">Nothing in the function’s signature clearly informs the client code whether we are facing one situation or the other, or even something </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">else entirely.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">As a “bonus” of sorts, what happens if someone calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">f()</span></strong><span class="koboSpan" id="kobo.115.1"> without using the returned value? </span><span class="koboSpan" id="kobo.115.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">f()</span></strong><span class="koboSpan" id="kobo.117.1"> is implemented as </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">return new X;</span></strong><span class="koboSpan" id="kobo.119.1"> or something similar, then the code will leak – an unpleasant perspective indeed. </span><span class="koboSpan" id="kobo.119.2">Note that since C++17, you can mitigate this specific problem by annotating the return type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">f()</span></strong><span class="koboSpan" id="kobo.121.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">[[nodiscard]]</span></strong><span class="koboSpan" id="kobo.123.1"> attribute, but it’s still something you should be aware of. </span><span class="koboSpan" id="kobo.123.2">Returning raw pointers from a function is something we mostly try to avoid, even though we sometimes have to </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">There are other possible pitfalls here, and they all have a common theme – using raw pointers, we traditionally cannot tell from the source code what the semantics are. </span><span class="koboSpan" id="kobo.125.2">More specifically, we cannot say for sure who is responsible for both the pointer and what it points to. </span><span class="koboSpan" id="kobo.125.3">The</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.126.1"> fact that raw pointers do not provide clear ownership information has been a recurring source of bugs in C++ over </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">the years.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Now, for a different situation, consider the following </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">code excerpt:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
// ...
</span><span class="koboSpan" id="kobo.130.2">void f() {
   X *p = new X;
   thread th0{ [p] { /* use *p */ };
   thread th1{ [p] { /* use *p */ };
   th0.detach();
   th1.detach();
}</span></pre> <p><span class="koboSpan" id="kobo.131.1">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">f()</span></strong><span class="koboSpan" id="kobo.133.1"> allocates an </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">X</span></strong><span class="koboSpan" id="kobo.135.1"> object pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">p</span></strong><span class="koboSpan" id="kobo.137.1">, after which two threads, </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">th0</span></strong><span class="koboSpan" id="kobo.139.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">th1</span></strong><span class="koboSpan" id="kobo.141.1">, copy </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">p</span></strong><span class="koboSpan" id="kobo.143.1"> (thus sharing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">X</span></strong><span class="koboSpan" id="kobo.145.1"> object that </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">p</span></strong><span class="koboSpan" id="kobo.147.1"> points to). </span><span class="koboSpan" id="kobo.147.2">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">th0</span></strong><span class="koboSpan" id="kobo.149.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">th1</span></strong><span class="koboSpan" id="kobo.151.1"> are detached, meaning that the threads will run until completion, even after </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">f()</span></strong><span class="koboSpan" id="kobo.153.1"> is done. </span><span class="koboSpan" id="kobo.153.2">If we do not know in what order </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">th0</span></strong><span class="koboSpan" id="kobo.155.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">th1</span></strong><span class="koboSpan" id="kobo.157.1"> will conclude, we cannot clearly state which one should be responsible for calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">operator delete()</span></strong><span class="koboSpan" id="kobo.159.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">p</span></strong><span class="koboSpan" id="kobo.161.1">. </span><span class="koboSpan" id="kobo.161.2">This is yet another issue of unclear responsibility over the </span><em class="italic"><span class="koboSpan" id="kobo.162.1">pointee</span></em><span class="koboSpan" id="kobo.163.1"> but of a different kind than our first example, and as such, it needs a </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">different solution.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">For the cases where there is a clearly identified last owner of a pointed-to object, regardless of whether the </span><em class="italic"><span class="koboSpan" id="kobo.166.1">pointee</span></em><span class="koboSpan" id="kobo.167.1"> is shared or not between pointers, you probably want to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.169.1">. </span><span class="koboSpan" id="kobo.169.2">In the (more niche, but very real and quite subtle) case where the pointed-to object is shared by at least two “co-owners” and the order in which these owners will be destroyed is a priori unknown, </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.171.1"> is the tool of choice. </span><span class="koboSpan" id="kobo.171.2">The</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.172.1"> following sections go into the roles and meaning of these types in more detail, hopefully helping you make an informed choice when choosing a smart pointer type for a given </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">use case.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.174.1">On the exposition of intent through function signatures</span></h2>
<p><span class="koboSpan" id="kobo.175.1">Even though we</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.176.1"> have not looked in detail at the standard smart pointers yet, it might be appropriate to offer a few words on what they mean, in particular for </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.178.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">These two types convey </span><em class="italic"><span class="koboSpan" id="kobo.181.1">ownership semantics</span></em><span class="koboSpan" id="kobo.182.1"> – </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.184.1"> represents </span><em class="italic"><span class="koboSpan" id="kobo.185.1">sole ownership</span></em><span class="koboSpan" id="kobo.186.1"> of the pointee, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.188.1"> represents </span><em class="italic"><span class="koboSpan" id="kobo.189.1">co-ownership</span></em><span class="koboSpan" id="kobo.190.1"> (or </span><em class="italic"><span class="koboSpan" id="kobo.191.1">shared ownership</span></em><span class="koboSpan" id="kobo.192.1">) of the pointee. </span></p>
<p><span class="koboSpan" id="kobo.193.1">It’s important to understand the difference between </span><em class="italic"><span class="koboSpan" id="kobo.194.1">owning</span></em><span class="koboSpan" id="kobo.195.1"> (in particular, </span><em class="italic"><span class="koboSpan" id="kobo.196.1">co-owning</span></em><span class="koboSpan" id="kobo.197.1">) a pointee and </span><em class="italic"><span class="koboSpan" id="kobo.198.1">sharing</span></em><span class="koboSpan" id="kobo.199.1"> a pointee. </span><span class="koboSpan" id="kobo.199.2">Consider the following example, which uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.201.1"> (even though we have not covered it yet, but we’re getting there) and raw pointers </span><em class="italic"><span class="koboSpan" id="kobo.202.1">together</span></em><span class="koboSpan" id="kobo.203.1"> in order to inscribe ownership semantics in the </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">type system:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.205.1">#include &lt;memory&gt;</span></strong><span class="koboSpan" id="kobo.206.1">
#include &lt;iostream&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.207.1">// print_pointee() shares a pointer with the caller</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.208.1">// but does not take ownership</span></strong><span class="koboSpan" id="kobo.209.1">
template &lt;class T&gt; void print_pointee(</span><strong class="bold"><span class="koboSpan" id="kobo.210.1">T *p</span></strong><span class="koboSpan" id="kobo.211.1">) {
   if (p) std::cout &lt;&lt; *p &lt;&lt; ‘\n’;
}
</span><strong class="bold"><span class="koboSpan" id="kobo.212.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.213.1"> make_one(const T &amp;arg) {
   return std::make_unique&lt;T&gt;(arg);
}
int main() {
   auto p = make_one(3); // p is a std::unique_ptr&lt;int&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.214.1">   print_pointee(p.get()); // caller and callee share the</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.215.1">                           // pointer during this call</span></strong><span class="koboSpan" id="kobo.216.1">
}</span></pre> <p><span class="koboSpan" id="kobo.217.1">As mentioned when introducing this example, we used a </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.219.1"> object to model ownership – </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">make_one()</span></strong><span class="koboSpan" id="kobo.221.1"> constructs </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.223.1"> and transfers ownership to the caller; then, that caller keeps ownership of that object and shares the underlying pointer with others (here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">print_pointee()</span></strong><span class="koboSpan" id="kobo.225.1">) but does not relinquish ownership of the pointee. </span><span class="koboSpan" id="kobo.225.2">Using yet not owning is modeled by a raw pointer. </span><span class="koboSpan" id="kobo.225.3">This shows us in a highly simplified setting that there is a difference between owning and sharing a resource – </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">p</span></strong><span class="koboSpan" id="kobo.227.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">main()</span></strong><span class="koboSpan" id="kobo.229.1"> owns the resource, yet it shares it with the non-owner, </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">p</span></strong><span class="koboSpan" id="kobo.231.1">, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">print_pointee()</span></strong><span class="koboSpan" id="kobo.233.1">. </span><span class="koboSpan" id="kobo.233.2">This is all safe and idiomatic </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">C++ code.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Knowing that the</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.236.1"> standard smart pointer types model represents ownership, we know that as long as there is a single, clear last user of a resource, </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.238.1"> tends to be the type of choice; it is much more lightweight than </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.240.1"> (as we will see), and it provides the appropriate </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">ownership semantics.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">There are, of course, use cases where </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.244.1"> is not a good choice. </span><span class="koboSpan" id="kobo.244.2">Consider this simplified, not thread-safe, and incomplete </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">code excerpt:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
class entity {
   bool taken{ false };
public:
   void take() { taken = true; }
   void release() { taken = false; }
   bool taken() const { return taken; }
   // ...
</span><span class="koboSpan" id="kobo.246.2">};
constexpr int N = ...;
</span><strong class="bold"><span class="koboSpan" id="kobo.247.1">// entities is where the entity objects live. </span><span class="koboSpan" id="kobo.247.2">We did</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.248.1">// not allocate them dynamically, but if we had we would</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.249.1">// have used unique_ptr&lt;entity&gt; as this will be the</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.250.1">// single last point of use for these objects</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.251.1">array&lt;entity,N&gt; entities;</span></strong><span class="koboSpan" id="kobo.252.1">
class nothing_left{};
</span><strong class="bold"><span class="koboSpan" id="kobo.253.1">// this function returns a non-owning pointer (Chapter 6</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.254.1">// will cover more ergonomic options than a raw pointer)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.255.1">entity *</span></strong><span class="koboSpan" id="kobo.256.1"> borrow_one() {
   if(auto p = find_if(begin(entities), end(entities),
               [](auto &amp;&amp; e) { return !e.taken(); };
      p != end(entities)) {
      p-&gt;take();
</span><strong class="bold"><span class="koboSpan" id="kobo.257.1">      return &amp;(*p); // non-owning pointer</span></strong><span class="koboSpan" id="kobo.258.1">
   }
   throw nothing_left{};
}</span></pre> <p><span class="koboSpan" id="kobo.259.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">borrow_one()</span></strong><span class="koboSpan" id="kobo.261.1"> shares </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.262.1">a pointer with the calling code but does not share </span><em class="italic"><span class="koboSpan" id="kobo.263.1">ownership</span></em><span class="koboSpan" id="kobo.264.1"> of that pointer – the provider of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">entity</span></strong><span class="koboSpan" id="kobo.266.1"> objects remains solely responsible for the lifetime of these objects in this case. </span><span class="koboSpan" id="kobo.266.2">This would neither be a case for </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.268.1"> (the sole owner of the resource) nor </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.270.1"> (the co-owner of the resource). </span><span class="koboSpan" id="kobo.270.2">There are alternatives to using raw pointers to express a non-owning pointer, as we will see in </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.271.1">Chapter 6</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.272.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">The important point here is that </span><em class="italic"><span class="koboSpan" id="kobo.274.1">function signatures convey meaning</span></em><span class="koboSpan" id="kobo.275.1">, and it’s important to use the types that convey our intent. </span><span class="koboSpan" id="kobo.275.2">To do so, we have to understand that intent. </span><span class="koboSpan" id="kobo.275.3">Let’s keep </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.276.1">that in mind as we explore how to use the standard smart pointers to our advantage in the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">following sections.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.278.1">Type unique_ptr</span></h1>
<p><span class="koboSpan" id="kobo.279.1">As its name </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.280.1">suggests, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.282.1"> object</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.283.1"> represents sole (unique) ownership of a pointed-to object. </span><span class="koboSpan" id="kobo.283.2">That happens to be a common case – maybe even the most common case – of ownership semantics when dealing with dynamically </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">allocated memory.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">Consider our first (still deliberately incomplete) example in this chapter, where ownership of the </span><em class="italic"><span class="koboSpan" id="kobo.286.1">pointee</span></em><span class="koboSpan" id="kobo.287.1"> was not something we could determine from the source code, and let’s rewrite it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.289.1"> objects instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">raw pointers:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.291.1">#include &lt;memory&gt;</span></strong><span class="koboSpan" id="kobo.292.1">
class X {
   // ...
</span><span class="koboSpan" id="kobo.292.2">};
</span><strong class="bold"><span class="koboSpan" id="kobo.293.1">std::unique_ptr&lt;X&gt;</span></strong><span class="koboSpan" id="kobo.294.1"> f();
void g(</span><strong class="bold"><span class="koboSpan" id="kobo.295.1">std::unique_ptr&lt;X&gt;&amp;);</span></strong><span class="koboSpan" id="kobo.296.1">
void h() {
   // we could write std::unique_ptr&lt;X&gt; instead of auto
   </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">auto</span></strong><span class="koboSpan" id="kobo.298.1"> p = f();
   g(p);
} </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">// p implicitly releases the pointed-to X object here</span></strong></pre> <p><span class="koboSpan" id="kobo.300.1">With this code, it’s clear that the object returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">f()</span></strong><span class="koboSpan" id="kobo.302.1"> is responsible for the lifetime of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">X</span></strong><span class="koboSpan" id="kobo.304.1"> object it points to, and it’s also clear that </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">g()</span></strong><span class="koboSpan" id="kobo.306.1"> uses the enclosed </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">X*</span></strong><span class="koboSpan" id="kobo.308.1"> without becoming responsible for the pointed-to </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">X</span></strong><span class="koboSpan" id="kobo.310.1"> object. </span><span class="koboSpan" id="kobo.310.2">Add to this the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">p</span></strong><span class="koboSpan" id="kobo.312.1"> is an object and, as such, will be destroyed if </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">g()</span></strong><span class="koboSpan" id="kobo.314.1"> throws or if </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">f()</span></strong><span class="koboSpan" id="kobo.316.1"> is called in such a way that the calling code forgets to use the return value, and you get an exception-safe program – one that’s shorter and simpler than the </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">original one!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.318.1">Murphy and Machiavelli</span></p>
<p class="callout"><span class="koboSpan" id="kobo.319.1">You might be thinking, “</span><em class="italic"><span class="koboSpan" id="kobo.320.1">But I’m sure I could steal the pointer managed by the </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">std::unique_ptr</span></strong> <em class="italic"><span class="koboSpan" id="kobo.322.1">in</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.323.1">g()</span></strong><span class="koboSpan" id="kobo.324.1">,” and you would be correct. </span><span class="koboSpan" id="kobo.324.2">Not only is it possible but also easy, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.326.1"> gives you direct access to the underlying pointer in more than one way. </span><span class="koboSpan" id="kobo.326.2">However, the type system is designed to protect us from accidents and make reasonable well-written code work well. </span><span class="koboSpan" id="kobo.326.3">It will protect you from Murphy, the accidents that happen, not from Machiavelli, the deliberately </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">hostile code.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.328.1">If you write deliberately broken code, you will end up with a deliberately broken program. </span><span class="koboSpan" id="kobo.328.2">It’s pretty much what you </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">would expect.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">In terms of semantics, you could tell a story just with function signatures, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.332.1"> objects. </span><span class="koboSpan" id="kobo.332.2">Note </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.333.1">that in the following </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.334.1">example, the functions have been left deliberately incomplete to make it clear that we are concerned with their </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">signatures only:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
// ...
</span><span class="koboSpan" id="kobo.336.2">// dynamically create an X or something derived from
// X and return it without risk of a leak
</span><strong class="bold"><span class="koboSpan" id="kobo.337.1">unique_ptr&lt;X&gt; factory(args);</span></strong><span class="koboSpan" id="kobo.338.1">
// pass-by-value which means in practice pass-by-movement
// since unique_ptr is uncopiable
</span><strong class="bold"><span class="koboSpan" id="kobo.339.1">unique_ptr&lt;X&gt; borrowing(unique_ptr&lt;X&gt;);</span></strong><span class="koboSpan" id="kobo.340.1">
// pass-by-reference to allow mutating the pointee. </span><span class="koboSpan" id="kobo.340.2">In
// practice, X* would be a better choice here
</span><strong class="bold"><span class="koboSpan" id="kobo.341.1">void possible_mutation(unique_ptr&lt;X&gt;&amp;);</span></strong><span class="koboSpan" id="kobo.342.1">
// pass by reference-to-const to consult the pointee but
// not mutate it. </span><span class="koboSpan" id="kobo.342.2">In practice, prefer const X* here
</span><strong class="bold"><span class="koboSpan" id="kobo.343.1">void consult(const unique_ptr&lt;X&gt;&amp;);</span></strong><span class="koboSpan" id="kobo.344.1">
// sink() consumes the object passed as argument : gets
// in, never gets out. </span><span class="koboSpan" id="kobo.344.2">This could use pass-by-value but
// intent is probably clearer with a rvalue-reference
</span><strong class="bold"><span class="koboSpan" id="kobo.345.1">void sink(unique_ptr&lt;X&gt; &amp;&amp;);</span></strong><span class="koboSpan" id="kobo.346.1">
// ...</span></pre> <p><span class="koboSpan" id="kobo.347.1">As we can see, function</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.348.1"> signatures talk to us. </span><span class="koboSpan" id="kobo.348.2">It’s </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.349.1">better if we </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">pay attention.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.351.1">Handling objects</span></h2>
<p><span class="koboSpan" id="kobo.352.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.354.1"> type is</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.355.1"> a remarkable tool, one you should strive to get acquainted with if you have not done so already. </span><span class="koboSpan" id="kobo.355.2">Here are some interesting facts about that type and how it can be used to manage pointers </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">to objects.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.359.1"> object is non-copyable, as its copy constructor and copy assignment member functions are marked as deleted. </span><span class="koboSpan" id="kobo.359.2">That’s why </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">g()</span></strong><span class="koboSpan" id="kobo.361.1"> in the first example of the </span><em class="italic"><span class="koboSpan" id="kobo.362.1">Type unique_ptr</span></em><span class="koboSpan" id="kobo.363.1"> section takes its argument by reference – </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">g()</span></strong><span class="koboSpan" id="kobo.365.1"> shares the pointee with the caller but does not take ownership of it. </span><span class="koboSpan" id="kobo.365.2">We could also have expressed </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">g()</span></strong><span class="koboSpan" id="kobo.367.1"> as taking </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">X*</span></strong><span class="koboSpan" id="kobo.369.1"> as an argument, with the contemporary acceptance that function arguments that are raw pointers are meant to model using a pointer but without </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">owning it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
#include &lt;memory&gt;
class X {
   // ...
</span><span class="koboSpan" id="kobo.371.2">};
std::unique_ptr&lt;X&gt; f();
</span><strong class="bold"><span class="koboSpan" id="kobo.372.1">void g(X*);</span></strong><span class="koboSpan" id="kobo.373.1">
void h() {
   // we could write std::unique_ptr&lt;X&gt; instead of auto
   auto p = f();
   g(</span><strong class="bold"><span class="koboSpan" id="kobo.374.1">p.get()</span></strong><span class="koboSpan" id="kobo.375.1">);
} // p implicitly releases the pointed-to X object here</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.377.1"> is also movable – a moved-from </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.379.1"> behaves like a null pointer, as the movement for this type semantically implements a transfer of ownership. </span><span class="koboSpan" id="kobo.379.2">This makes it simpler to implement various types that need to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">resources indirectly.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Consider, for example, the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">solar_system</span></strong><span class="koboSpan" id="kobo.383.1"> class, which supposes a hypothetical </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Planet</span></strong><span class="koboSpan" id="kobo.385.1"> type </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.386.1">as well as a hypothetical implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">create_planet()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
#include “planet.h”
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
std::unique_ptr&lt;Planet&gt;
   create_planet(std::string_view name);
class solar_system {
   </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">std::vector&lt;std::unique_ptr&lt;Planet&gt;&gt;</span></strong><span class="koboSpan" id="kobo.392.1"> planets {
      create_planet(“mercury.data”),
      create_planet(“venus.data”), // etc.
</span><span class="koboSpan" id="kobo.392.2">   };
public:
</span><strong class="bold"><span class="koboSpan" id="kobo.393.1">   // solar_system is uncopyable by default</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.394.1">   // solar_system is movable by default</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.395.1">   // no need to write ~solar_system as planets</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.396.1">   // manages its resources implicitly</span></strong><span class="koboSpan" id="kobo.397.1">
};</span></pre> <p><span class="koboSpan" id="kobo.398.1">If we had decided to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">solar_system</span></strong><span class="koboSpan" id="kobo.400.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">vector&lt;Planet*&gt;</span></strong><span class="koboSpan" id="kobo.402.1"> or as </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">Planet*</span></strong><span class="koboSpan" id="kobo.404.1"> instead, then the memory management of our type would have to be performed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">solar_system</span></strong><span class="koboSpan" id="kobo.406.1"> itself, adding to the complexity of that type. </span><span class="koboSpan" id="kobo.406.2">Since we used a </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">vector&lt;unique_ptr&lt;Planet&gt;&gt;</span></strong><span class="koboSpan" id="kobo.408.1">, everything is implicitly correct by default. </span><span class="koboSpan" id="kobo.408.2">Of course, depending on what we are doing, </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">vector&lt;Planet&gt;</span></strong><span class="koboSpan" id="kobo.410.1"> might be even better, but let’s suppose we need pointers for the sake of </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">the example.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.414.1"> offers most of the same operations as </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">T*</span></strong><span class="koboSpan" id="kobo.416.1">, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">operator*()</span></strong><span class="koboSpan" id="kobo.418.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">operator-&gt;()</span></strong><span class="koboSpan" id="kobo.420.1">, as well as the ability to compare them with </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">==</span></strong><span class="koboSpan" id="kobo.422.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">!=</span></strong><span class="koboSpan" id="kobo.424.1"> to see whether two </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.426.1"> objects point to the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">T</span></strong><span class="koboSpan" id="kobo.428.1"> object. </span><span class="koboSpan" id="kobo.428.2">The latter two might seem strange, as the type represents sole ownership of the </span><em class="italic"><span class="koboSpan" id="kobo.429.1">pointee</span></em><span class="koboSpan" id="kobo.430.1">, but you could use</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.431.1"> references to </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.433.1">, in which case these functions </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">make sense:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
#include &lt;memory&gt;
template &lt;class T&gt;
   bool point_to_same(const std::unique_ptr&lt;T&gt; &amp;p0,
                      const std::unique_ptr&lt;T&gt; &amp;p1) {
      return p0 == p1;
   }
template &lt;class T&gt;
   bool have_same_value(const std::unique_ptr&lt;T&gt; &amp;p0,
                        const std::unique_ptr&lt;T&gt; &amp;p1) {
      return p0 &amp;&amp; p1 &amp;&amp; *p0 == *p1;
   }
#include &lt;cassert&gt;
int main() {
   // two distinct pointers to objects with same value
   std::unique_ptr&lt;int&gt; a{ new int { 3 } };
   std::unique_ptr&lt;int&gt; b{ new int { 3 } };
   assert(point_to_same(a, a) &amp;&amp; have_same_value(a, a));
   assert(!point_to_same(a, b) &amp;&amp; have_same_value(a, b));
}</span></pre> <p><span class="koboSpan" id="kobo.436.1">For good reasons, you cannot do pointer arithmetic on </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.438.1">. </span><span class="koboSpan" id="kobo.438.2">If you need to do pointer arithmetic (and we sometimes will – for example, when we write our own containers in </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.439.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.440.1">), it’s always possible to get to the raw pointer owned by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">unique_pointer&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.442.1"> through its </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">get()</span></strong><span class="koboSpan" id="kobo.444.1"> member function. </span><span class="koboSpan" id="kobo.444.2">This is often useful when interfacing with C libraries, making system calls, or calling functions that use a raw pointer without taking ownership </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Oh, and here’s a fun fact – </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">sizeof(unique_ptr&lt;T&gt;)==sizeof(T*)</span></strong><span class="koboSpan" id="kobo.448.1"> with a few exceptions that will be discussed later in this chapter. </span><span class="koboSpan" id="kobo.448.2">This means that there’s generally no cost in terms </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.449.1">of memory space to using a smart pointer instead of a raw pointer. </span><span class="koboSpan" id="kobo.449.2">In other words, by default, the only state found in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.451.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">T*</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.455.1">Handling arrays</span></h2>
<p><span class="koboSpan" id="kobo.456.1">A nice aspect </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.457.1">of </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.459.1"> is that it offers a specialization to handle arrays. </span><span class="koboSpan" id="kobo.459.2">Consider </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.461.1">
void f(int n) {
   // p points to an int of value 3
   std::unique_ptr&lt;int&gt; p{ new int{ 3 } };
   </span><strong class="bold"><span class="koboSpan" id="kobo.462.1">// q points to an array of n int objects</span></strong><span class="koboSpan" id="kobo.463.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">// initialized to zero</span></strong><span class="koboSpan" id="kobo.465.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">std::unique_ptr&lt;int[]&gt; q{ new int[n] {} };</span></strong><span class="koboSpan" id="kobo.467.1">
   // example usage
   std::cout &lt;&lt; *p &lt;&lt; ‘\n’; // displays 3
   for(int i = 0; i != n; ++i) {
      </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">// operator[] supported for unique_ptr&lt;T[]&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.469.1">      q[i] = i + 1;</span></strong><span class="koboSpan" id="kobo.470.1">
   }
   // ...
</span><span class="koboSpan" id="kobo.470.2">} </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">// the destructor of q calls delete [] on its pointee</span></strong><span class="koboSpan" id="kobo.472.1">
  // the destructor of p calls delete on its pointee</span></pre> <p><span class="koboSpan" id="kobo.473.1">What, you might think, is the use case for this? </span><span class="koboSpan" id="kobo.473.2">Well, it all depends on your needs. </span><span class="koboSpan" id="kobo.473.3">For example, if you require a variable-sized array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">T</span></strong><span class="koboSpan" id="kobo.475.1"> that grows as needed, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.477.1">. </span><span class="koboSpan" id="kobo.477.2">It’s a wonderful tool and extremely efficient if </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">used well.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">If you want a fixed-sized array that’s small enough to fit on your execution stack where the number of elements, </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">N</span></strong><span class="koboSpan" id="kobo.481.1">, is known at compile time, use a raw array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">T</span></strong><span class="koboSpan" id="kobo.483.1"> or an object of </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">std::array&lt;T,N&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">If you want a fixed-sized array that’s either not small enough to fit on your execution stack or where the number of elements, </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">n</span></strong><span class="koboSpan" id="kobo.489.1">, is known at runtime, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.491.1">, but you’ll pay for facilities you might not require (</span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.493.1"> remains an awesome choice, that being said), or you could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">unique_ptr&lt;T[]&gt;</span></strong><span class="koboSpan" id="kobo.495.1">. </span><span class="koboSpan" id="kobo.495.2">Note that if you go for this latter option, you will end up having to track the size yourself, separately from the actual array, since </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.497.1"> does no such tracking. </span><span class="koboSpan" id="kobo.497.2">Alternatively, of</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.498.1"> course, you can wrap it in your own abstraction, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">fixed_size_array&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.500.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.502.1">
#include &lt;cstddef&gt;
#include &lt;memory&gt;
template &lt;class T&gt;
   class fixed_size_array {
      std::size_t nelems{};
</span><strong class="bold"><span class="koboSpan" id="kobo.503.1">      std::unique_ptr&lt;T[]&gt; elems {};</span></strong><span class="koboSpan" id="kobo.504.1">
   public:
      fixed_size_array() = default;
      auto size() const { return nelems; }
      bool empty() const { return size() == 0; }
     fixed_size_array(std::size_t n)
         : nelems { n }, elems{ new T[n] {} } {
      }
      T&amp; operator[](int n) { return elems[n]; }
      const T&amp; operator[](int n) const { return elems[n]; }
      // etc.
</span><span class="koboSpan" id="kobo.504.2">   };</span></pre> <p><span class="koboSpan" id="kobo.505.1">This is a naïve implementation that brings together knowledge of the number of elements with implicit ownership of the resource. </span><span class="koboSpan" id="kobo.505.2">Note that we don’t have to write the copy operations (unless we want to implement them!), the move operations, or the destructor, as they all implicitly do something reasonable. </span><span class="koboSpan" id="kobo.505.3">Also, this type will be relatively efficient if type </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">T</span></strong><span class="koboSpan" id="kobo.507.1"> is trivially constructible but will (really) not be as efficient as </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.509.1"> for numerous use cases. </span><span class="koboSpan" id="kobo.509.2">Why is that? </span><span class="koboSpan" id="kobo.509.3">Well, it so happens that </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">vector</span></strong><span class="koboSpan" id="kobo.511.1"> does significantly better memory management than we do… but we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">get there.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">Note that, as with </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.514.1">scalar types, the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">sizeof(unique_ptr&lt;T[]&gt;)</span></strong><span class="koboSpan" id="kobo.516.1"> is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">sizeof(T*)</span></strong><span class="koboSpan" id="kobo.518.1"> is also true, which I’m sure we can </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">all appreciate.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.520.1">Custom deleters</span></h2>
<p><span class="koboSpan" id="kobo.521.1">You might </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.522.1">think, “</span><em class="italic"><span class="koboSpan" id="kobo.523.1">Well, in my code base, we don’t use </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">delete</span></strong><em class="italic"><span class="koboSpan" id="kobo.525.1"> to deallocate objects because [insert your favorite reason here], so I cannot use </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.527.1">.” </span><span class="koboSpan" id="kobo.527.2">There are indeed many situations where applying </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">operator delete</span></strong><span class="koboSpan" id="kobo.529.1"> on a pointer to destroy the pointed-to object is not </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">an option:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.531.1">Sometimes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">T::~T()</span></strong><span class="koboSpan" id="kobo.533.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">private</span></strong><span class="koboSpan" id="kobo.535.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">protected</span></strong><span class="koboSpan" id="kobo.537.1">, making it inaccessible to other classes such </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">unique_ptr&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.541.1">Sometimes, the finalization semantics require doing something else than calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">delete</span></strong><span class="koboSpan" id="kobo.543.1"> – for example, calling a </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">destroy()</span></strong><span class="koboSpan" id="kobo.545.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">release()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.547.1">member function</span></span></li>
<li><span class="koboSpan" id="kobo.548.1">Sometimes, the expectation is to call a free function that will perform auxiliary work in addition to freeing </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">a resource.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.550.1">No matter what the reasons are for freeing a resource in an unconventional manner, </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.552.1"> can</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.553.1"> take a </span><strong class="bold"><span class="koboSpan" id="kobo.554.1">custom deleter</span></strong><span class="koboSpan" id="kobo.555.1"> that will perform those custom resource deallocation tasks. </span><span class="koboSpan" id="kobo.555.2">A custom deleter can be a functor or a function that will be applied to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">T*</span></strong><span class="koboSpan" id="kobo.557.1"> stored within </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.559.1"> when the destructor of that smart pointer is called. </span><span class="koboSpan" id="kobo.559.2">Indeed, the actual signature of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.561.1"> template is </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
template&lt;class T, </span><strong class="bold"><span class="koboSpan" id="kobo.564.1">class D = std::default_delete&lt;T&gt;&gt;</span></strong><span class="koboSpan" id="kobo.565.1">
   class unique_ptr {
      // ...
</span><span class="koboSpan" id="kobo.565.2">   };</span></pre> <p><span class="koboSpan" id="kobo.566.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">default_delete&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.568.1"> itself is essentially </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
template&lt;class T&gt; struct default_delete {
   constexpr default_delete() noexcept = default;
   // </span><strong class="bold"><span class="koboSpan" id="kobo.571.1">...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.572.1">   constexpr void operator()(T *p) const { delete p; }</span></strong>
<strong class="source-inline"><span class="koboSpan" id="kobo.573.1">};</span></strong></pre> <p><span class="koboSpan" id="kobo.574.1">The presence of a default type for </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">D</span></strong><span class="koboSpan" id="kobo.576.1"> is what usually allows us to write code that ignores that parameter. </span><span class="koboSpan" id="kobo.576.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">D</span></strong><span class="koboSpan" id="kobo.578.1"> parameter in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">unique_ptr&lt;T,D&gt;</span></strong><span class="koboSpan" id="kobo.580.1"> signature is expected to be stateless, as it’s not stored within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.582.1"> object but instantiated as needed, and then it’s used as a function that takes the pointer and does whatever is required to finalize </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">the </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.584.1">pointee</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.586.1">As such, imagine the following class with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">private</span></strong><span class="koboSpan" id="kobo.588.1"> destructor, a common technique if you seek to prevent </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.589.1">instantiation through other means than dynamic allocation (you cannot use an automatic or a static object of that type, since it cannot be </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">implicitly destroyed):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
#include &lt;memory&gt;
class requires_dynamic_alloc {
   </span><strong class="bold"><span class="koboSpan" id="kobo.592.1">~requires_dynamic_alloc() = default; // private</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.593.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.594.1">// ...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.595.1">   friend struct cleaner;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.596.1">};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.597.1">// ...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.598.1">struct cleaner {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.599.1">   template &lt;class T&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.600.1">      void operator()(T *p) const { delete p; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.601.1">};</span></strong><span class="koboSpan" id="kobo.602.1">
int main() {
   using namespace std;
   // requires_dynamic_alloc r0; // no
   //auto p0 = unique_ptr&lt;requires_dynamic_alloc&gt;{
   //   new requires_dynamic_alloc
   //}; // no, as delete not available to default deleter
   auto p1 = </span><strong class="bold"><span class="koboSpan" id="kobo.603.1">unique_ptr&lt;requires_dynamic_alloc, cleaner&gt;</span></strong><span class="koboSpan" id="kobo.604.1">{
      new requires_dynamic_alloc
   }; </span><strong class="bold"><span class="koboSpan" id="kobo.605.1">// ok, will use cleaner::operator() to delete pointee</span></strong><span class="koboSpan" id="kobo.606.1">
}</span></pre> <p><span class="koboSpan" id="kobo.607.1">Note that by making the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">cleaner</span></strong><span class="koboSpan" id="kobo.609.1"> functor its friend, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">requires_dynamic_alloc</span></strong><span class="koboSpan" id="kobo.611.1"> class lets </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">cleaner</span></strong><span class="koboSpan" id="kobo.613.1"> specifically access both its </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">protected</span></strong><span class="koboSpan" id="kobo.615.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">private</span></strong><span class="koboSpan" id="kobo.617.1"> members, which includes access to its </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">private</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.619.1"> destructor.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">Imagine now that we are using an object through an interface that hides from client code information on whether we are the sole owner of the pointed-to resource, or whether we share that resource with others. </span><span class="koboSpan" id="kobo.620.2">Also, imagine that the potential sharing of that resource is </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.621.1">done through intrusive means, as is done on many platforms, such that the way to signal that we are disconnecting from that resource is to call its </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">release()</span></strong><span class="koboSpan" id="kobo.623.1"> member function, which will, in turn, either take into account that we have disconnected or free the resource if we were its last users. </span><span class="koboSpan" id="kobo.623.2">To simplify client code, our code base has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">release()</span></strong><span class="koboSpan" id="kobo.625.1"> free function that calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">release()</span></strong><span class="koboSpan" id="kobo.627.1"> member function on such a pointer if it </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">is non-null.</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">We can still use </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.631.1"> for this, but note the syntax, which is slightly different, as we will need to pass the function pointer as an argument to the constructor, since that pointer will be stored within. </span><span class="koboSpan" id="kobo.631.2">Thus, this specialization of </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.633.1"> with a function pointer as a </span><em class="italic"><span class="koboSpan" id="kobo.634.1">deleter</span></em><span class="koboSpan" id="kobo.635.1"> leads to a slight </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">size increase:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.637.1">
#include &lt;memory&gt;
struct releasable {
   void release() {
      // overly simplified for the sake of this example
      delete this;
   }
protected:
   ~releasable() = default;
};
class important_resource : public releasable {
   // ...
</span><span class="koboSpan" id="kobo.637.2">};
void release(releasable *p) {
   if(p) p-&gt;release();
}
int main() {
   using namespace std;
   </span><strong class="bold"><span class="koboSpan" id="kobo.638.1">auto p = unique_ptr&lt;</span></strong><span class="koboSpan" id="kobo.639.1">important_resource,
                       </span><strong class="bold"><span class="koboSpan" id="kobo.640.1">void(*)(releasable*)&gt;{</span></strong><span class="koboSpan" id="kobo.641.1">
      new important_resource</span><strong class="bold"><span class="koboSpan" id="kobo.642.1">, release</span></strong><span class="koboSpan" id="kobo.643.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.644.1">}; // ok, will use release() to delete pointee</span></strong><span class="koboSpan" id="kobo.645.1">
}</span></pre> <p><span class="koboSpan" id="kobo.646.1">If the extra cost of </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.647.1">a function pointer’s size (plus alignment) in the size of </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.649.1"> is unacceptable (for example, because you are on a resource-constrained platform or because you have a container with many </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.651.1"> objects, which makes the costs increase significantly faster), there’s a neat trick you can play by pushing the runtime use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">deleter</span></strong><span class="koboSpan" id="kobo.653.1"> function into the wonderful world of the </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">type system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.655.1">
#include &lt;memory&gt;
struct releasable {
   void release() {
      // overly simplified for the sake of this example
      delete this;
   }
protected:
   ~releasable() = default;
};
class important_resource : public releasable {
   // ...
</span><span class="koboSpan" id="kobo.655.2">};
void release(releasable *p) {
   if(p) p-&gt;release();
}
int main() {
   using namespace std;
   auto p = unique_ptr&lt;important_resource,
                       </span><strong class="bold"><span class="koboSpan" id="kobo.656.1">void(*)(releasable*)</span></strong><span class="koboSpan" id="kobo.657.1">&gt;{
      new important_resource, </span><strong class="bold"><span class="koboSpan" id="kobo.658.1">release</span></strong><span class="koboSpan" id="kobo.659.1">
   }; // ok, will use release() to delete pointee
</span><strong class="bold"><span class="koboSpan" id="kobo.660.1">   static_assert(sizeof(p) &gt; sizeof(void*));</span></strong><span class="koboSpan" id="kobo.661.1">
   auto q = unique_ptr&lt;
      important_resource,
      </span><strong class="bold"><span class="koboSpan" id="kobo.662.1">decltype([](auto p) { release(p); })</span></strong><span class="koboSpan" id="kobo.663.1">&gt;{
      new important_resource
   };
   </span><strong class="bold"><span class="koboSpan" id="kobo.664.1">static_assert(sizeof(q) == sizeof(void*))</span></strong><span class="koboSpan" id="kobo.665.1">;
}</span></pre> <p><span class="koboSpan" id="kobo.666.1">As you can see, in the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">p</span></strong><span class="koboSpan" id="kobo.668.1">, we used a function pointer as a deleter, which requires storing the address of the function, whereas with </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">q</span></strong><span class="koboSpan" id="kobo.670.1">, we replaced the function pointer with the </span><em class="italic"><span class="koboSpan" id="kobo.671.1">type of a hypothetical lambda</span></em><span class="koboSpan" id="kobo.672.1">, which will, when instantiated, call that function, passing</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.673.1"> the pointer as an argument. </span><span class="koboSpan" id="kobo.673.2">It’s simple and can save space if </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">used judiciously!</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.675.1">make_unique</span></h2>
<p><span class="koboSpan" id="kobo.676.1">Since C++14, </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.678.1"> has </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.679.1">been accompanied by </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.680.1">a factory function that perfectly forwards its arguments to a constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">T</span></strong><span class="koboSpan" id="kobo.682.1">, allocates and constructs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">T</span></strong><span class="koboSpan" id="kobo.684.1"> as well as </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.686.1"> to hold it, and returns the resulting object. </span><span class="koboSpan" id="kobo.686.2">That function is </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">std::make_unique&lt;T&gt;(args...)</span></strong><span class="koboSpan" id="kobo.688.1">, and a naïve implementation would be </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="source-inline"><span class="koboSpan" id="kobo.690.1">template &lt;class T, class ... </span><span class="koboSpan" id="kobo.690.2">Args&gt;</span></strong>
<strong class="source-inline"><span class="koboSpan" id="kobo.691.1">   std::unique_ptr&lt;T&gt; make_unique(Args &amp;&amp;... </span><span class="koboSpan" id="kobo.691.2">args) {</span></strong>
<strong class="source-inline"><span class="koboSpan" id="kobo.692.1">      return std::unique_ptr&lt;T&gt;{</span></strong>
<strong class="source-inline"><span class="koboSpan" id="kobo.693.1">         new T(std::forward&lt;Args&gt;(args)...);</span></strong>
<strong class="source-inline"><span class="koboSpan" id="kobo.694.1">      }</span></strong>
<strong class="source-inline"><span class="koboSpan" id="kobo.695.1">   }</span></strong></pre> <p><span class="koboSpan" id="kobo.696.1">There are also variants to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">T[]</span></strong><span class="koboSpan" id="kobo.698.1">, of course. </span><span class="koboSpan" id="kobo.698.2">You might wonder what the point of such a function is, and indeed, that function was not shipped along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.700.1"> initially (</span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.702.1"> is a C++11 type), but consider the following (</span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">contrived) example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.704.1">
template &lt;class T&gt;
   class pair_with_alloc {
      T *p0, *p1;
   public:
      pair_with_alloc(const T &amp;val0, const T &amp;val1)
         : p0{ new T(val0) }, p1{ new T(val1) } {
      }
      ~pair_with_alloc() {
         delete p1; delete p0;
      }
      // copy and move operations left to your imagination
   };</span></pre> <p><span class="koboSpan" id="kobo.705.1">We can suppose from this example that this class is used when, for some reason, client code prefers to dynamically allocate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">T</span></strong><span class="koboSpan" id="kobo.707.1"> objects (in practice, using objects rather than pointers to objects makes your life simpler). </span><span class="koboSpan" id="kobo.707.2">Knowing that subobjects in a C++ object are constructed in order</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.708.1"> of declaration, we know that </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">p0</span></strong><span class="koboSpan" id="kobo.710.1"> will be </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.711.1">constructed </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">before </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">p1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.715.1">
// ...
</span><span class="koboSpan" id="kobo.715.2">      T *p0, *p1; </span><strong class="bold"><span class="koboSpan" id="kobo.716.1">// p0 declared before p1</span></strong><span class="koboSpan" id="kobo.717.1">
   public:
</span><strong class="bold"><span class="koboSpan" id="kobo.718.1">// below:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.719.1">// - new T(val0) will occur before construction of p0</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.720.1">// - new T(val1) will occur before construction of p1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.721.1">// - construction of p0 will precede construction of p1</span></strong><span class="koboSpan" id="kobo.722.1">
      pair_with_alloc(const T &amp;val0, const T &amp;val1)
         : p0{ new T(val0) }, p1{ new T(val1) } {
      }
// ...</span></pre> <p><span class="koboSpan" id="kobo.723.1">However, suppose that the order of operations is </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">new T(val0)</span></strong><span class="koboSpan" id="kobo.725.1">, the construction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">p0</span></strong><span class="koboSpan" id="kobo.727.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">new T(val1)</span></strong><span class="koboSpan" id="kobo.729.1">, and the construction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">p1</span></strong><span class="koboSpan" id="kobo.731.1">. </span><span class="koboSpan" id="kobo.731.2">What happens then if </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">new T(val1)</span></strong><span class="koboSpan" id="kobo.733.1"> throws an exception, either because </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">new</span></strong><span class="koboSpan" id="kobo.735.1"> fails to allocate sufficient memory or because the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">T</span></strong><span class="koboSpan" id="kobo.737.1"> fails? </span><span class="koboSpan" id="kobo.737.2">You might be tempted to think that the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">pair_with_alloc</span></strong><span class="koboSpan" id="kobo.739.1"> will clean up, but that will not be the case – for a destructor to be called, the corresponding constructor must have completed first; otherwise, there is no object </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">to destroy!</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">There are ways around this ,of course. </span><span class="koboSpan" id="kobo.741.2">One of them might be to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.743.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">T*</span></strong><span class="koboSpan" id="kobo.745.1">, which would be wonderful, given that this is what we’re currently discussing! </span><span class="koboSpan" id="kobo.745.2">Let’s rewrite </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">pair_with_alloc</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.747.1">that way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.748.1">
#include &lt;memory&gt;
template &lt;class T&gt;
   class pair_with_alloc {
      </span><strong class="bold"><span class="koboSpan" id="kobo.749.1">std::unique_ptr&lt;T&gt; p0, p1;</span></strong><span class="koboSpan" id="kobo.750.1">
   public:
      pair_with_alloc(const T &amp;val0, const T &amp;val1)
         : p0{ new T(val0) }, p1{ new T(val1) } {
      }
      // destructor implicitly correct
      // copy and move operations implicitly work
      // or are left to your imagination
   };</span></pre> <p><span class="koboSpan" id="kobo.751.1">With this version, if the</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.752.1"> order of operations is </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">new T(val0)</span></strong><span class="koboSpan" id="kobo.754.1">, the </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.755.1">construction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">p0</span></strong><span class="koboSpan" id="kobo.757.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">new T(val1)</span></strong><span class="koboSpan" id="kobo.759.1">, the construction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">p1</span></strong><span class="koboSpan" id="kobo.761.1">, then if </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">new T(val1)</span></strong><span class="koboSpan" id="kobo.763.1"> throws an exception, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">pair_with_alloc</span></strong><span class="koboSpan" id="kobo.765.1"> object will still not be destroyed (it has not been constructed). </span><span class="koboSpan" id="kobo.765.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">p0</span></strong><span class="koboSpan" id="kobo.767.1"> itself </span><em class="italic"><span class="koboSpan" id="kobo.768.1">has</span></em><span class="koboSpan" id="kobo.769.1"> been constructed by that point, and as such, it will be destroyed. </span><span class="koboSpan" id="kobo.769.2">Our code has suddenly become simpler </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">and safer!</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">What then has that to do with </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">make_unique&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.773.1">? </span><span class="koboSpan" id="kobo.773.2">Well, there’s a hidden trap here. </span><span class="koboSpan" id="kobo.773.3">Let’s look closer at the order of operations in </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">our constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.775.1">
// ...
</span><span class="koboSpan" id="kobo.775.2">      std::unique_ptr&lt;T&gt; p0, p1; </span><strong class="bold"><span class="koboSpan" id="kobo.776.1">// p0 declared before p1</span></strong><span class="koboSpan" id="kobo.777.1">
   public:
</span><strong class="bold"><span class="koboSpan" id="kobo.778.1">// below, suppose we identify the operations as follows:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.779.1">// A: new T(val0)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.780.1">// B: construction of p0</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.781.1">// C: new T(val1)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.782.1">// D: construction of p1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.783.1">// We know that:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.784.1">// - A precedes B</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.785.1">// - C precedes D</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.786.1">// - B precedes D</span></strong><span class="koboSpan" id="kobo.787.1">
      pair_with_alloc(const T &amp;val0, const T &amp;val1)
         : p0{ new T(val0) }, p1{ new T(val1) } {
      }
// ...</span></pre> <p><span class="koboSpan" id="kobo.788.1">If you look at the rules laid out in the comments, you will see that we could have the operations in the following order, A→B→C→D, but we could also have them ordered as A→C→B→D or C→A→B→D, in which case the two calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">new T(...)</span></strong><span class="koboSpan" id="kobo.790.1"> would occur, followed by the two </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.792.1"> constructors. </span><span class="koboSpan" id="kobo.792.2">If this happens, then an exception thrown by the second call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">new</span></strong><span class="koboSpan" id="kobo.794.1"> or the associated constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">T</span></strong><span class="koboSpan" id="kobo.796.1"> would still lead to a </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">resource leak.</span></span></p>
<p><span class="koboSpan" id="kobo.798.1">Now, that’s a</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.799.1"> shame. </span><span class="koboSpan" id="kobo.799.2">But </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.800.1">that’s also the point of </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">make_unique&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.802.1"> – with a factory function, client code never finds itself with “floating results from calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">new</span></strong><span class="koboSpan" id="kobo.804.1">”; it either has a complete </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.806.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">or not:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.808.1">
#include &lt;memory&gt;
template &lt;class T&gt;
   class pair_with_alloc {
      </span><strong class="bold"><span class="koboSpan" id="kobo.809.1">std::unique_ptr&lt;T&gt; p0, p1;</span></strong><span class="koboSpan" id="kobo.810.1">
   public:
      </span><strong class="bold"><span class="koboSpan" id="kobo.811.1">pair_with_alloc(const T &amp;val0, const T &amp;val1)</span></strong><span class="koboSpan" id="kobo.812.1">
         </span><strong class="bold"><span class="koboSpan" id="kobo.813.1">: p0{ std::make_unique&lt;T&gt;(val0) },</span></strong><span class="koboSpan" id="kobo.814.1">
           </span><strong class="bold"><span class="koboSpan" id="kobo.815.1">p1{ std::make_unique&lt;T&gt;(val1) } {</span></strong><span class="koboSpan" id="kobo.816.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.817.1">}</span></strong><span class="koboSpan" id="kobo.818.1">
      // destructor implicitly correct
      // copy and move operations implicitly work
      // or are left to your imagination
   };
#include &lt;string&gt;
#include &lt;random&gt;
#include &lt;iostream&gt;
class risky {
   std::mt19937 prng{ std::random_device{}() };
   std::uniform_int_distribution&lt;int&gt; penny{ 0,1 };
public:
   risky() = default;
   risky(const risky &amp;) {
      if(penny(prng)) throw 3; // throws 50% of the time
   }
   ~risky() {
      std::cout &lt;&lt; “~risky()\n”;
   }
};
int main() {
   // the following objects do not leak even if
   // an exception is thrown
   if(std::string s0, s1; std::cin &gt;&gt; s0 &gt;&gt; s1)
      try {
         pair_with_alloc a{ s0, s1 };
         pair_with_alloc b{ risky{}, risky{} };
      } catch(...) {
         std::cerr &lt;&lt; “Something was thrown...\n”;
      }
}</span></pre> <p><span class="koboSpan" id="kobo.819.1">As you can see, </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">make_unique&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.821.1"> is a security feature, mostly useful to avoid exposing ownerless resources in client code. </span><span class="koboSpan" id="kobo.821.2">As a bonus, </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">make_unique&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.823.1"> allows us to limit how we repeat ourselves in source code. </span><span class="koboSpan" id="kobo.823.2">Check </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.825.1">
unique_ptr&lt;some_type&gt; p0 { new some_type{ args } };
auto p1 = unique_ptr&lt;some_type&gt; { new some_type{ args } };
auto p2 = make_unique&lt;some_type&gt;(args);</span></pre> <p><span class="koboSpan" id="kobo.826.1">As you can </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.827.1">see, </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">p0</span></strong><span class="koboSpan" id="kobo.829.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">p1</span></strong><span class="koboSpan" id="kobo.831.1"> require you to spell the name of the </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.832.1">pointed-to type twice whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">p2</span></strong><span class="koboSpan" id="kobo.834.1"> only requires you to write it once. </span><span class="koboSpan" id="kobo.834.2">That’s </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">always nice.</span></span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.836.1">Types shared_ptr and weak_ptr</span></h1>
<p><span class="koboSpan" id="kobo.837.1">In most cases, </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.839.1"> will </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.840.1">be your smart </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.841.1">pointer of</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.842.1"> choice. </span><span class="koboSpan" id="kobo.842.2">It’s</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.843.1"> small, fast, and does what most code requires. </span><span class="koboSpan" id="kobo.843.2">There are some specialized but important use cases where </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.845.1"> is not what you need, and these have in common </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.847.1">The semantics being conveyed is the </span><em class="italic"><span class="koboSpan" id="kobo.848.1">shared ownership</span></em><span class="koboSpan" id="kobo.849.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">the resource</span></span></li>
<li><span class="koboSpan" id="kobo.851.1">The last owner of the resource is not known a priori (which mostly happens in </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">concurrent code)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.853.1">Note that if the execution is not concurrent, you will, in general, know who the last owner of the resource is – it’s the last object to observe the resource that will be destroyed in the program. </span><span class="koboSpan" id="kobo.853.2">This is an important point – you can have concurrent code that shares resources and still uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.855.1"> to manage the resource. </span><span class="koboSpan" id="kobo.855.2">Non-owning users of the resource, such as raw pointers, can access it without taking ownership (more on that later in this chapter), and this approach </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">is sufficient.</span></span></p>
<p><span class="koboSpan" id="kobo.857.1">You can, of course, have non-concurrent code where the last owner of a resource is not known a priori. </span><span class="koboSpan" id="kobo.857.2">An example might involve a protocol where the provider of the resource still holds on to it after returning it to the client, but they might be asked to release it at a later point while client code retains it, making the client the last owner from that point on, or they might never be asked to release it, in which case the provider might be the last owner of the resource. </span><span class="koboSpan" id="kobo.857.3">Such situations are highly specific, obviously, but they show that there might be reasons to use shared ownership semantics as expressed through </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.859.1">, even in </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">non-concurrent code.</span></span></p>
<p><span class="koboSpan" id="kobo.861.1">Since concurrent code remains the posterchild for situations where the last owner of a shared resource is not known a priori, we will use this as a basis for our investigation. </span><span class="koboSpan" id="kobo.861.2">Remember this example from the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">this chapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.863.1">
// ...
</span><span class="koboSpan" id="kobo.863.2">void f() {
   X *p = new X;
   thread th0{ [p] { /* use *p */ };
   thread th1{ [p] { /* use *p */ };
   th0.detach();
   th1.detach();
}</span></pre> <p><span class="koboSpan" id="kobo.864.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">p</span></strong><span class="koboSpan" id="kobo.866.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">f()</span></strong><span class="koboSpan" id="kobo.868.1"> does </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.869.1">not own the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">X</span></strong><span class="koboSpan" id="kobo.871.1"> it points to, being </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.872.1">a</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.873.1"> raw </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.874.1">pointer, and both </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">th0</span></strong><span class="koboSpan" id="kobo.876.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">th1</span></strong><span class="koboSpan" id="kobo.878.1"> copy that raw pointer, so neither is responsible for the pointee (at least on the basis of the rules enforced by the type system; you could envision acrobatics to make this work, but it’s involved, tricky, </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">and bug-prone).</span></span></p>
<p><span class="koboSpan" id="kobo.880.1">This example can be amended to have clear ownership semantics by shifting </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">p</span></strong><span class="koboSpan" id="kobo.882.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">X*</span></strong><span class="koboSpan" id="kobo.884.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">shared_ptr&lt;X&gt;</span></strong><span class="koboSpan" id="kobo.886.1">. </span><span class="koboSpan" id="kobo.886.2">Indeed, let’s consider </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.888.1">
// ...
</span><span class="koboSpan" id="kobo.888.2">void f() {
   </span><strong class="bold"><span class="koboSpan" id="kobo.889.1">std::shared_ptr&lt;X&gt; p { new X };</span></strong><span class="koboSpan" id="kobo.890.1">
   thread th0{ [</span><strong class="bold"><span class="koboSpan" id="kobo.891.1">p</span></strong><span class="koboSpan" id="kobo.892.1">] { /* use *p */ };
   thread th1{ [</span><strong class="bold"><span class="koboSpan" id="kobo.893.1">p</span></strong><span class="koboSpan" id="kobo.894.1">] { /* use *p */ };
   th0.detach();
   th1.detach();
}</span></pre> <p><span class="koboSpan" id="kobo.895.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">f()</span></strong><span class="koboSpan" id="kobo.897.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">p</span></strong><span class="koboSpan" id="kobo.899.1"> object is initially the sole owner of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">X</span></strong><span class="koboSpan" id="kobo.901.1"> it points to. </span><span class="koboSpan" id="kobo.901.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">p</span></strong><span class="koboSpan" id="kobo.903.1"> is copied, as it is in the capture blocks of the lambdas executed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">th0</span></strong><span class="koboSpan" id="kobo.905.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">th1</span></strong><span class="koboSpan" id="kobo.907.1">, the mechanics of </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">shared_ptr</span></strong><span class="koboSpan" id="kobo.909.1"> ensure that </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">p</span></strong><span class="koboSpan" id="kobo.911.1"> and its two copies share both </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">X*</span></strong><span class="koboSpan" id="kobo.913.1"> and an integral counter, used to determine how many shared owners there are for </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">the resource.</span></span></p>
<p><span class="koboSpan" id="kobo.915.1">The key functions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">shared_ptr</span></strong><span class="koboSpan" id="kobo.917.1"> are its copy constructor (shares the resource and increments the counter), copy assignment (disconnects from the original resource, decrementing its counter, and then connects to the new resource, incrementing its counter), and the destructor (decrements the counter and destroys the resource if there’s no owner left). </span><span class="koboSpan" id="kobo.917.2">Each of these functions is subtle to implement; to help understand what the stakes are, we will provide simplified implementation examples in </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.918.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.919.1">. </span><span class="koboSpan" id="kobo.919.2">Move semantics, unsurprisingly, implement transfer of ownership semantics </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">shared_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.923.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.925.1"> implements extrusive (non-intrusive) shared ownership semantics. </span><span class="koboSpan" id="kobo.925.2">Type </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">T</span></strong><span class="koboSpan" id="kobo.927.1"> could be a fundamental type and does not need to implement a particular interface </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.928.1">for</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.929.1"> this </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.930.1">type to work. </span><span class="koboSpan" id="kobo.930.2">This differs from the intrusive</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.931.1"> shared semantics that were mentioned earlier in this chapter, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">releasable</span></strong><span class="koboSpan" id="kobo.933.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">an example.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.935.1">Usefulness and costs</span></h2>
<p><span class="koboSpan" id="kobo.936.1">There </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.937.1">are</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.938.1"> intrinsic costs to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.940.1"> model. </span><span class="koboSpan" id="kobo.940.2">The most obvious one is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">sizeof(shared_ptr&lt;T&gt;)&gt;sizeof(unique_ptr&lt;T&gt;)</span></strong><span class="koboSpan" id="kobo.942.1"> for any type </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">T</span></strong><span class="koboSpan" id="kobo.944.1">, since </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.946.1"> needs to handle both a pointer to the shared resource and a pointer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">shared counter.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">Another cost is that copying a </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.950.1"> is not a cheap operation. </span><span class="koboSpan" id="kobo.950.2">Remember that </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.952.1"> makes sense mostly in concurrent code, where you do not know a priori the last owner of a resource. </span><span class="koboSpan" id="kobo.952.2">For that reason, the increments and decrements of the shared counter require synchronization, meaning that the counter is typically an </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">atomic</span></strong><span class="koboSpan" id="kobo.954.1"> integer, and mutating an </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">atomic&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.956.1"> object (for example) costs more than mutating </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">an </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.960.1">Another non-negligible cost is </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.962.1">
shared_ptr&lt;X&gt; p{ new X };</span></pre> <p><span class="koboSpan" id="kobo.963.1">An instruction such as this one will lead to </span><em class="italic"><span class="koboSpan" id="kobo.964.1">two</span></em><span class="koboSpan" id="kobo.965.1"> allocations, not one – there will be one for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">X</span></strong><span class="koboSpan" id="kobo.967.1"> object and another one (performed internally by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">shared_ptr</span></strong><span class="koboSpan" id="kobo.969.1">) for the counter. </span><span class="koboSpan" id="kobo.969.2">Since these two allocations will be done separately, one by the client code and one by the constructor itself, the two allocated objects might find themselves in distinct cache lines, potentially </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.970.1">leading to a loss of efficiency </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.971.1">when accessing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">shared_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.973.1"> object.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.974.1">make_shared()</span></h2>
<p><span class="koboSpan" id="kobo.975.1">There is a way to </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.976.1">alleviate the latter cost, and that is to </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.977.1">make the same entity perform both allocations, instead of letting the client code do one and the constructor do the other. </span><span class="koboSpan" id="kobo.977.2">The standard tool to achieve this is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">std::make_shared&lt;T&gt;()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.979.1">factory function.</span></span></p>
<p><span class="koboSpan" id="kobo.980.1">Compare the following </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">two instructions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.982.1">
shared_ptr&lt;X&gt; p{ new X(args) };
auto q = make_shared&lt;X&gt;(args);</span></pre> <p><span class="koboSpan" id="kobo.983.1">When constructing </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">p</span></strong><span class="koboSpan" id="kobo.985.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">shared_ptr&lt;X&gt;</span></strong><span class="koboSpan" id="kobo.987.1"> is provided an existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">X*</span></strong><span class="koboSpan" id="kobo.989.1"> to manage, so it has no choice but to perform a second, separate allocation for the shared counter. </span><span class="koboSpan" id="kobo.989.2">Conversely, the call expressed as </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">make_shared&lt;X&gt;(args)</span></strong><span class="koboSpan" id="kobo.991.1"> specifies the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">X</span></strong><span class="koboSpan" id="kobo.993.1"> to construct along with the arguments </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">args</span></strong><span class="koboSpan" id="kobo.995.1"> to forward directly to the constructor. </span><span class="koboSpan" id="kobo.995.2">It falls upon that function to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">shared_ptr&lt;X&gt;</span></strong><span class="koboSpan" id="kobo.997.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">X</span></strong><span class="koboSpan" id="kobo.999.1">, and the shared counter, which lets us put both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">X</span></strong><span class="koboSpan" id="kobo.1001.1"> and the counter in the same contiguous </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.1002.1">space (the </span><strong class="bold"><span class="koboSpan" id="kobo.1003.1">control block</span></strong><span class="koboSpan" id="kobo.1004.1">), using mechanisms such as a </span><em class="italic"><span class="koboSpan" id="kobo.1005.1">union</span></em><span class="koboSpan" id="kobo.1006.1"> or the </span><em class="italic"><span class="koboSpan" id="kobo.1007.1">placement new</span></em><span class="koboSpan" id="kobo.1008.1"> mechanism, which will be explored in </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1009.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1011.1">Clearly, given the same arguments used for construction, the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">p</span></strong><span class="koboSpan" id="kobo.1013.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">q</span></strong><span class="koboSpan" id="kobo.1015.1"> will be equivalent </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">shared_ptr&lt;X&gt;</span></strong><span class="koboSpan" id="kobo.1017.1"> objects, but in general, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">q</span></strong><span class="koboSpan" id="kobo.1019.1"> will perform better than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">p</span></strong><span class="koboSpan" id="kobo.1021.1">, as its two key components will be organized in a more </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">cache-friendly manner.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.1023.1">What about weak_ptr?</span></h2>
<p><span class="koboSpan" id="kobo.1024.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1026.1"> is a type </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.1027.1">with a narrower (yet essential) niche than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1029.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">weak_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1031.1"> occupies an even narrower (but still essential) niche. </span><span class="koboSpan" id="kobo.1031.2">The role of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">weak_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1033.1"> is to model the </span><em class="italic"><span class="koboSpan" id="kobo.1034.1">temporary</span></em><span class="koboSpan" id="kobo.1035.1"> ownership of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">T</span></strong><span class="koboSpan" id="kobo.1037.1">. </span><span class="koboSpan" id="kobo.1037.2">Type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">weak_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1039.1"> is meant to interact with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1041.1"> in a way that makes the continued existence of the </span><em class="italic"><span class="koboSpan" id="kobo.1042.1">pointee</span></em><span class="koboSpan" id="kobo.1043.1"> testable from </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">client code.</span></span></p>
<p><span class="koboSpan" id="kobo.1045.1">A good example of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">weak_ptr</span></strong><span class="koboSpan" id="kobo.1047.1"> usage, inspired by the excellent </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">cppreference</span></strong><span class="koboSpan" id="kobo.1049.1"> website (</span><a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="koboSpan" id="kobo.1050.1">https://en.cppreference.com/w/cpp/memory/weak_ptr</span></a><span class="koboSpan" id="kobo.1051.1">), is </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
// inspired from a cppreference example
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;format&gt;
void observe(</span><strong class="bold"><span class="koboSpan" id="kobo.1054.1">std::weak_ptr</span></strong><span class="koboSpan" id="kobo.1055.1">&lt;int&gt; w) {
   </span><strong class="bold"><span class="koboSpan" id="kobo.1056.1">if (std::shared_ptr&lt;int&gt; sh = w.lock())</span></strong><span class="koboSpan" id="kobo.1057.1">
      std::cout &lt;&lt; std::format(“*sh == {}\n”, *sh);
   else
      std::cout &lt;&lt; “w is expired\n”;
} 
int main() {
   </span><strong class="bold"><span class="koboSpan" id="kobo.1058.1">std::weak_ptr&lt;int&gt; w;</span></strong><span class="koboSpan" id="kobo.1059.1">
   {
      auto sh = std::make_shared&lt;int&gt;(3);
      </span><strong class="bold"><span class="koboSpan" id="kobo.1060.1">w = sh; // weak_ptr made from shared_ptr</span></strong><span class="koboSpan" id="kobo.1061.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1062.1">// w points to a live shared_ptr&lt;int&gt; here</span></strong><span class="koboSpan" id="kobo.1063.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1064.1">observe(w);</span></strong><span class="koboSpan" id="kobo.1065.1">
   }
   </span><strong class="bold"><span class="koboSpan" id="kobo.1066.1">// w points to an expired shared_ptr&lt;int&gt; here</span></strong><span class="koboSpan" id="kobo.1067.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.1068.1">observe(w);</span></strong><span class="koboSpan" id="kobo.1069.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1070.1">As this example shows, you can make </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">weak_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1072.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1074.1">, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">weak_ptr</span></strong><span class="koboSpan" id="kobo.1076.1"> does not own the resource until you call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">lock()</span></strong><span class="koboSpan" id="kobo.1078.1"> on it, yielding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1080.1">, from which you can safely use the resource after having verified that it does not model an </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">empty pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.1082.1">Another use case for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">std::weak_ptr</span></strong><span class="koboSpan" id="kobo.1084.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.1086.1"> would be a cache of resources such that the </span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">following occurs:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1088.1">The data in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">Resource</span></strong><span class="koboSpan" id="kobo.1090.1"> object is sufficiently big or costly to duplicate that it’s preferable to share it than to </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">copy it</span></span></li>
<li><span class="koboSpan" id="kobo.1092.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">Cache</span></strong><span class="koboSpan" id="kobo.1094.1"> object shares the objects it stores, but it needs to invalidate them before replacing them when its capacity </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">is reached</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1096.1">In such a situation, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">Cache</span></strong><span class="koboSpan" id="kobo.1098.1"> object could hold </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">std::shared_ptr&lt;Resource&gt;</span></strong><span class="koboSpan" id="kobo.1100.1"> objects but provide its client code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">std::weak_ptr&lt;Resource&gt;</span></strong><span class="koboSpan" id="kobo.1102.1">, on demand, such that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">Resource</span></strong><span class="koboSpan" id="kobo.1104.1"> objects can be disposed of when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">Cache</span></strong><span class="koboSpan" id="kobo.1106.1"> needs to do so, but the client code needs</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.1107.1"> to be able to verify that the objects it points to have not yet </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">been invalidated.</span></span></p>
<p><span class="koboSpan" id="kobo.1109.1">A full (simplified) example would be the following (see the GitHub repository for this book to get the </span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">full example):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1111.1">
// ...
</span><span class="koboSpan" id="kobo.1111.2">template &lt;auto Cap&gt;
   class Cache {
      using clock = std::chrono::system_clock;
      // a cache of capacity Cap that keeps the
      // most recently used Resource objects
      std::vector&lt;std::pair&lt;
         decltype(clock::now()),
         std::shared_ptr&lt;Resource&gt;
      &gt;&gt; resources;
      bool full() const { return resources.size() == Cap; }
      // precondition: !resources.empty()
      void expunge_one() {
         auto p = std::min_element(
            std::begin(resources), std::end(resources),
            [](auto &amp;&amp; a, auto &amp;&amp; b) {
               return a.first &lt; b.first;
            }
         );
         assert(p != std::end(resources));
</span><strong class="bold"><span class="koboSpan" id="kobo.1112.1">         p-&gt;second.reset(); // relinquish ownership</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1113.1">         resources.erase(p);</span></strong><span class="koboSpan" id="kobo.1114.1">
      }
   public:
      void add(Resource *p) {
         const auto t = clock::now();
</span><strong class="bold"><span class="koboSpan" id="kobo.1115.1">         if(full()) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1116.1">            expunge_one();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1117.1">         }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1118.1">         resources.emplace_back(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1119.1">            t, std::shared_ptr&lt;Resource&gt;{ p }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1120.1">         );</span></strong><span class="koboSpan" id="kobo.1121.1">
      }
      </span><strong class="bold"><span class="koboSpan" id="kobo.1122.1">std::weak_ptr&lt;Resource&gt;</span></strong><span class="koboSpan" id="kobo.1123.1"> obtain(Resource::id_type id){
         const auto t = clock::now();
         auto p = std::find_if(
            std::begin(resources),
            std::end(resources),
            [id](auto &amp;&amp; p) {
               return p.second-&gt;id() == id;
            }
         );
         if(p == std::end(resources))
</span><strong class="bold"><span class="koboSpan" id="kobo.1124.1">            return {};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1125.1">         p-&gt;first = t;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1126.1">         return p-&gt;second; // make weak_ptr from shared_ptr</span></strong><span class="koboSpan" id="kobo.1127.1">
      }
   };
int main() {
   Cache&lt;5&gt; cache;
   for(int i = 0; i != 5; ++i)
      cache.add(new Resource{ i + 1 });
   // let’s take a pointer to resource 3
</span><strong class="bold"><span class="koboSpan" id="kobo.1128.1">   auto p = cache.obtain(3);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1129.1">   if(auto q = p.lock(); q)</span></strong><span class="koboSpan" id="kobo.1130.1">
      std::cout &lt;&lt; “Using resource “ &lt;&lt; q-&gt;id() &lt;&lt; ‘\n’;
   // things happen, resources get added, used, etc.
</span><span class="koboSpan" id="kobo.1130.2">   for(int i = 6; i != 15; ++i)
      cache.add(new Resource{ i + 1 });
</span><strong class="bold"><span class="koboSpan" id="kobo.1131.1">   if(auto q = p.lock(); q)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1132.1">      std::cout &lt;&lt; “Using resource “ &lt;&lt; q-&gt;id() &lt;&lt; ‘\n’;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1133.1">   else</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1134.1">      std::cout &lt;&lt; “Resource not available ...\n”;</span></strong><span class="koboSpan" id="kobo.1135.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1136.1">After a sufficient number of additions to the cache, the object pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">p</span></strong><span class="koboSpan" id="kobo.1138.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">main()</span></strong><span class="koboSpan" id="kobo.1140.1"> becomes invalidated and erased from the set of resources, one of our requirements for this example (without that requirement, we could have simply used </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.1142.1"> objects in this case). </span><span class="koboSpan" id="kobo.1142.2">Yet, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">main()</span></strong><span class="koboSpan" id="kobo.1144.1"> can test for the validity of the object pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">p</span></strong><span class="koboSpan" id="kobo.1146.1"> through the construction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.1148.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">std::weak_ptr</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1150.1">it holds.</span></span></p>
<p><span class="koboSpan" id="kobo.1151.1">In practice, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">weak_ptr</span></strong><span class="koboSpan" id="kobo.1153.1"> is sometimes used to break cycles when </span><strong class="source-inline"><span class="koboSpan" id="kobo.1154.1">shared_ptr</span></strong><span class="koboSpan" id="kobo.1155.1"> objects refer to each other in some way. </span><span class="koboSpan" id="kobo.1155.2">If you have two types whose objects mutually refer to one another (say, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">X</span></strong><span class="koboSpan" id="kobo.1157.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">Y</span></strong><span class="koboSpan" id="kobo.1159.1">) and do not know which one will be destroyed first, then consider making one of them the owner (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">shared_ptr</span></strong><span class="koboSpan" id="kobo.1161.1">) and the other one the non-owner in a verifiable manner (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">weak_ptr</span></strong><span class="koboSpan" id="kobo.1163.1">), which will ensure that they will not keep each other alive</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.1164.1"> forever. </span><span class="koboSpan" id="kobo.1164.2">For example, this will conclude, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">X</span></strong><span class="koboSpan" id="kobo.1166.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">Y</span></strong><span class="koboSpan" id="kobo.1168.1"> destructors will never </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">be called:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1170.1">
#include &lt;memory&gt;
#include &lt;iostream&gt;
struct Y;
struct X {
  std::shared_ptr&lt;Y&gt; p;  
  ~X() { std::cout &lt;&lt; “~X()\n”; }
};
struct Y {
  std::shared_ptr&lt;X&gt; p;
  ~Y() { std::cout &lt;&lt; “~Y()\n”; }  
};
void oops() {
  auto x = std::make_shared&lt;X&gt;();
  auto y = std::make_shared&lt;Y&gt;();
  x-&gt;p = y;
  y-&gt;p = x;
}
int main() {
   oops();
   std::cout &lt;&lt; “Done\n”;
}</span></pre> <p><span class="koboSpan" id="kobo.1171.1">If you change either </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">X::p</span></strong><span class="koboSpan" id="kobo.1173.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">Y::p</span></strong><span class="koboSpan" id="kobo.1175.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">weak_ptr</span></strong><span class="koboSpan" id="kobo.1177.1">, you will see both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">X</span></strong><span class="koboSpan" id="kobo.1179.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">Y</span></strong><span class="koboSpan" id="kobo.1181.1"> destructors </span><a id="_idIndexMarker319"/><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">being called:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1183.1">
#include &lt;memory&gt;
#include &lt;iostream&gt;
struct Y;
struct X {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1184.1">std::weak_ptr&lt;Y&gt; p;  </span></strong><span class="koboSpan" id="kobo.1185.1">
  ~X() { std::cout &lt;&lt; “~X()\n”; }
};
struct Y {
  std::shared_ptr&lt;X&gt; p;
  ~Y() { std::cout &lt;&lt; “~Y()\n”; }  
};
void oops() {
  auto x = std::make_shared&lt;X&gt;();
  auto y = std::make_shared&lt;Y&gt;();
  x-&gt;p = y;
  y-&gt;p = x;
}
int main() {
   oops();
   std::cout &lt;&lt; “Done\n”;
}</span></pre> <p><span class="koboSpan" id="kobo.1186.1">Of course, the easiest way not to get to the point where you face a cycle of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1188.1"> objects is to not build such a cycle, but when faced with external libraries and third-party</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.1189.1"> tools, that’s sometimes easier said </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">than done.</span></span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.1191.1">When to use raw pointers</span></h1>
<p><span class="koboSpan" id="kobo.1192.1">We have seen that</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.1193.1"> smart pointer types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1195.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1197.1"> shine when there is a need to describe ownership of a type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">T</span></strong><span class="koboSpan" id="kobo.1199.1"> resource through the type system. </span><span class="koboSpan" id="kobo.1199.2">Does that mean that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">T*</span></strong><span class="koboSpan" id="kobo.1201.1"> has </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">become useless?</span></span></p>
<p><span class="koboSpan" id="kobo.1203.1">No, of course not. </span><span class="koboSpan" id="kobo.1203.2">The trick is to use it in controlled situations. </span><span class="koboSpan" id="kobo.1203.3">The first is that for a function, being passed a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">T*</span></strong><span class="koboSpan" id="kobo.1205.1"> as an argument should mean the function is </span><em class="italic"><span class="koboSpan" id="kobo.1206.1">an observer, not an owner</span></em><span class="koboSpan" id="kobo.1207.1">, of that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">T</span></strong><span class="koboSpan" id="kobo.1209.1">. </span><span class="koboSpan" id="kobo.1209.2">If your code base used raw pointers in that sense, you will most probably not run </span><span class="No-Break"><span class="koboSpan" id="kobo.1210.1">into trouble.</span></span></p>
<p><span class="koboSpan" id="kobo.1211.1">Secondly, you can use a raw pointer inside a class that implements your preferred ownership semantics. </span><span class="koboSpan" id="kobo.1211.2">It’s fine to implement a container that manipulates objects through raw pointers (for example, a tree-like structure meant for various traversal orders), as long as that container implements clear copy and move semantics. </span><span class="koboSpan" id="kobo.1211.3">What you don’t want to do is expose pointers to the internal nodes of your container to external code. </span><span class="koboSpan" id="kobo.1211.4">Pay attention to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1212.1">container’s interface.</span></span></p>
<p><span class="koboSpan" id="kobo.1213.1">Indeed, consider this single-linked list </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">of (excerpt):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1215.1">
template &lt;class T&gt;
   class single_linked_list {
      struct node {
         T value;
         node *next = nullptr;
         node(const T &amp;val) : value { val } {
      };
      node *head = nullptr;
      // ...
</span><span class="koboSpan" id="kobo.1215.2">    public:
      // ...
</span><span class="koboSpan" id="kobo.1215.3">      ~single_linked_list() {
         for(auto p = head; p;) {
            auto q = p-&gt;next;
            delete p;
            p = q;
         }
      }
   };</span></pre> <p><span class="koboSpan" id="kobo.1216.1">We will explore this example in greater detail in </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1217.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.1218.1">. </span><span class="koboSpan" id="kobo.1218.2">The destructor works fine and (supposing the rest of the class is reasonably well-written) the class is usable and useful. </span><span class="koboSpan" id="kobo.1218.3">Now, suppose we decide to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1219.1">unique_ptr&lt;node&gt;</span></strong><span class="koboSpan" id="kobo.1220.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">node*</span></strong><span class="koboSpan" id="kobo.1222.1"> as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">head</span></strong><span class="koboSpan" id="kobo.1224.1"> data member for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">single_linked_list</span></strong><span class="koboSpan" id="kobo.1226.1">, and as a replacement for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">next</span></strong><span class="koboSpan" id="kobo.1228.1"> member of the node. </span><span class="koboSpan" id="kobo.1228.2">This seems like a</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.1229.1"> good idea, except when you consider </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">the consequences:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1231.1">
template &lt;class T&gt;
   class single_linked_list {
      struct node {
         T value;
         </span><strong class="bold"><span class="koboSpan" id="kobo.1232.1">unique_ptr&lt;node&gt; next; // good idea?</span></strong><span class="koboSpan" id="kobo.1233.1">
         node(const T &amp;val) : value { val } {
      };
      </span><strong class="bold"><span class="koboSpan" id="kobo.1234.1">unique_ptr&lt;node&gt; head; // good idea?</span></strong><span class="koboSpan" id="kobo.1235.1">
      // ...
</span><span class="koboSpan" id="kobo.1235.2">    public:
      // ...
</span><span class="koboSpan" id="kobo.1235.3">      </span><strong class="bold"><span class="koboSpan" id="kobo.1236.1">~single_linked_list() = default;</span></strong><span class="koboSpan" id="kobo.1237.1">
   };</span></pre> <p><span class="koboSpan" id="kobo.1238.1">This seems like a good idea on the surface, but it does not convey the proper semantics – it’s </span><em class="italic"><span class="koboSpan" id="kobo.1239.1">not</span></em><span class="koboSpan" id="kobo.1240.1"> true that a node </span><em class="italic"><span class="koboSpan" id="kobo.1241.1">owns</span></em><span class="koboSpan" id="kobo.1242.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1243.1">is responsible for</span></em><span class="koboSpan" id="kobo.1244.1"> the next node. </span><span class="koboSpan" id="kobo.1244.2">We don’t want to make the removal of a node destroy the node that follows (and so on, recursively) and if that looks like a simplification in the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">single_linked_list</span></strong><span class="koboSpan" id="kobo.1246.1">, think about the consequences – this strategy leads to as many destructors recursively called as there are nodes in the list, which is a very good way to achieve a </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">stack overflow!</span></span></p>
<p><span class="koboSpan" id="kobo.1248.1">Use a smart pointer when the use case matches the semantics it models. </span><span class="koboSpan" id="kobo.1248.2">Of course, when the relationship modeled by your pointers is neither unique ownership nor shared ownership, you probably do not want smart pointer types that provide these semantics, resorting instead to either nonstandard and non-owning smart pointers or, simply, </span><span class="No-Break"><span class="koboSpan" id="kobo.1249.1">raw pointers.</span></span></p>
<p><span class="koboSpan" id="kobo.1250.1">Finally, you often need raw pointers to use lower-level interfaces – for example, when performing system calls. </span><span class="koboSpan" id="kobo.1250.2">That does not disqualify higher-level abstractions, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1252.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1254.1">, when writing system-level code – you can get access to the underlying array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1256.1"> through its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">data()</span></strong><span class="koboSpan" id="kobo.1258.1"> member function, just as you can get access to the underlying raw pointer of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1260.1"> through its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">get()</span></strong><span class="koboSpan" id="kobo.1262.1"> member function. </span><span class="koboSpan" id="kobo.1262.2">As long as it makes sense, see the called code as borrowing the pointer from the caller code for the duration of </span><span class="No-Break"><span class="koboSpan" id="kobo.1263.1">the call.</span></span></p>
<p><span class="koboSpan" id="kobo.1264.1">And if you have no other choice, use raw pointers. </span><span class="koboSpan" id="kobo.1264.2">They exist, after all, and they work. </span><span class="koboSpan" id="kobo.1264.3">Simply remember to use higher-level abstractions wherever possible – it will make your code </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.1265.1">simpler, safer, and (more often than you would think) faster. </span><span class="koboSpan" id="kobo.1265.2">If you cannot define the higher-level semantics, maybe it’s still a bit early to write that part of the code, and you’ll get better results if you spend more time thinking about </span><span class="No-Break"><span class="koboSpan" id="kobo.1266.1">these semantics.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.1267.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1268.1">In this chapter, we saw how to use standard smart pointers. </span><span class="koboSpan" id="kobo.1268.2">We discussed the ownership semantics they implement (sole ownership, shared co-ownership, and temporary co-ownership), saw examples of how they can be used, and discussed some ways in which they can be used while acknowledging that other, more appropriate </span><span class="No-Break"><span class="koboSpan" id="kobo.1269.1">options exist.</span></span></p>
<p><span class="koboSpan" id="kobo.1270.1">In the next chapter, we’ll take this a step further and write our own (usable, if naïve) versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1272.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1274.1">, in order to get an intuitive grasp of what this entails, and we will write some nonstandard but useful smart pointers too. </span><span class="koboSpan" id="kobo.1274.2">This will help us build a nicer, more interesting resource </span><span class="No-Break"><span class="koboSpan" id="kobo.1275.1">management toolset.</span></span></p>
</div>
</body></html>