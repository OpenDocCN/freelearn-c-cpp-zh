["```cpp\n1 extern int a; \n\n2 int a = 1;\n```", "```cpp\n  bool checkConst(QualType QT) { \n\n    // Assigning to a const object has undefined behavior. \n\n    if (QT.isConstQualified()) { \n\n      Info.FFDiag(E, diag::note_constexpr_modify_const_type) << QT; \n\n      return false; \n\n    } \n\n    return true; \n\n  }\n```", "```cpp\n1using foo = int; \n\n2 typedef int bar;\n```", "```cpp\n2 project(\"declvisitor\") \n\n3  \n\n4 if ( NOT DEFINED ENV{LLVM_HOME}) \n\n5   message(FATAL_ERROR \"$LLVM_HOME is not defined\") \n\n6 else() \n\n7   message(STATUS \"$LLVM_HOME found: $ENV{LLVM_HOME}\") \n\n8   set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH \"Root of LLVM installation\") \n\n9   set(LLVM_LIB ${LLVM_HOME}/lib) \n\n10   set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) \n\n11   find_package(LLVM REQUIRED CONFIG) \n\n12   include_directories(${LLVM_INCLUDE_DIRS}) \n\n13   link_directories(${LLVM_LIBRARY_DIRS}) \n\n14   set(SOURCE_FILE DeclVisitor.cpp) \n\n15   add_executable(declvisitor ${SOURCE_FILE}) \n\n16   set_target_properties(declvisitor PROPERTIES COMPILE_FLAGS \"-fno-rtti\") \n\n17   target_link_libraries(declvisitor \n\n18     LLVMSupport \n\n19     clangAST \n\n20     clangBasic \n\n21     clangFrontend \n\n22     clangSerialization \n\n23     clangTooling \n\n24   )\n```", "```cpp\n1 #include \"clang/Tooling/CommonOptionsParser.h\" \n\n2 #include \"clang/Tooling/Tooling.h\" \n\n3 #include \"llvm/Support/CommandLine.h\" // llvm::cl::extrahelp \n\n4  \n\n5 #include \"FrontendAction.hpp\" \n\n6  \n\n7 namespace { \n\n8 llvm::cl::OptionCategory TestCategory(\"Test project\"); \n\n9 llvm::cl::extrahelp \n\n10     CommonHelp(clang::tooling::CommonOptionsParser::HelpMessage); \n\n11 } // namespace \n\n12  \n\n13 int main(int argc, const char **argv) { \n\n14   llvm::Expected<clang::tooling::CommonOptionsParser> OptionsParser = \n\n15       clang::tooling::CommonOptionsParser::create(argc, argv, TestCategory); \n\n16   if (!OptionsParser) { \n\n17     llvm::errs() << OptionsParser.takeError(); \n\n18     return 1; \n\n19   } \n\n20   clang::tooling::ClangTool Tool(OptionsParser->getCompilations(), \n\n21                                  OptionsParser->getSourcePathList()); \n\n22   return Tool.run(clang::tooling::newFrontendActionFactory< \n\n23                       clangbook::declvisitor::FrontendAction>() \n\n24                       .get()); \n\n25 }\n```", "```cpp\n1 #include \"Consumer.hpp\" \n\n2 #include \"clang/Frontend/FrontendActions.h\" \n\n3  \n\n4 namespace clangbook { \n\n5 namespace declvisitor { \n\n6 class FrontendAction : public clang::ASTFrontendAction { \n\n7 public: \n\n8   virtual std::unique_ptr<clang::ASTConsumer> \n\n9   CreateASTConsumer(clang::CompilerInstance &CI, \n\n10                     llvm::StringRef File) override { \n\n11     return std::make_unique<Consumer>(); \n\n12   } \n\n13 }; \n\n14 } // namespace declvisitor \n\n15 } // namespace clangbook\n```", "```cpp\n1 #include \"Visitor.hpp\" \n\n2 #include \"clang/Frontend/ASTConsumers.h\" \n\n3  \n\n4 namespace clangbook { \n\n5 namespace declvisitor { \n\n6 class Consumer : public clang::ASTConsumer { \n\n7 public: \n\n8   Consumer() : V(std::make_unique<Visitor>()) {} \n\n9  \n\n10   virtual void HandleTranslationUnit(clang::ASTContext &Context) override { \n\n11     V->Visit(Context.getTranslationUnitDecl()); \n\n12   } \n\n13  \n\n14 private: \n\n15   std::unique_ptr<Visitor> V; \n\n16 }; \n\n17 } // namespace declvisitor \n\n18 } // namespace clangbook\n```", "```cpp\n1 #include \"clang/AST/DeclVisitor.h\" \n\n2  \n\n3 namespace clangbook { \n\n4 namespace declvisitor { \n\n5 class Visitor : public clang::DeclVisitor<Visitor> { \n\n6 public: \n\n7   void VisitFunctionDecl(const clang::FunctionDecl *FD) { \n\n8     llvm::outs() << \"Function: ’\" << FD->getName() << \"’\\n\"; \n\n9     for (auto Param : FD->parameters()) { \n\n10       Visit(Param); \n\n11     } \n\n12   } \n\n13   void VisitParmVarDecl(const clang::ParmVarDecl *PVD) { \n\n14     llvm::outs() << \"\\tParameter: ’\" << PVD->getName() << \"’\\n\"; \n\n15   } \n\n16   void VisitTranslationUnitDecl(const clang::TranslationUnitDecl *TU) { \n\n17     for (auto Decl : TU->decls()) { \n\n18       Visit(Decl); \n\n19     } \n\n20   } \n\n21 }; \n\n22 } // namespace declvisitor \n\n23 } // namespace clangbook\n```", "```cpp\nexport LLVM_HOME=<...>/llvm-project/install\nmkdir build\ncd build\ncmake -G Ninja -DCMAKE_BUILD_TYPE=Debug ...\nninja\n```", "```cpp\ncmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD=\"X86\" -DLLVM_ENABLE_PROJECTS=\"clang\" -DLLVM_USE_LINKER=gold -DLLVM_USE_SPLIT_DWARF=ON -DBUILD_SHARED_LIBS=ON ../llvm\n```", "```cpp\n1 int max(int a, int b) { \n\n2   if (a > b) \n\n3     return a; \n\n4   return b; \n\n5 }\n```", "```cpp\n$ ./declvisitor max.cpp -- -std=c++17\n...\nFunction: ’max’\n        Parameter: ’a’\n        Parameter: ’b’\n```", "```cpp\n$ ./declvisitor max.cpp -p <path>\n```", "```cpp\n5 class Visitor : public clang::DeclVisitor<Visitor> {\n\n```", "```cpp\n7   void VisitFunctionDecl(const clang::FunctionDecl *FD) { \n\n8     llvm::outs() << \"Function: ’\" << FD->getName() << \"’\\n\"; \n\n9     for (auto Param : FD->parameters()) { \n\n10       Visit(Param); \n\n11     } \n\n12   }\n```", "```cpp\n13   void VisitParmVarDecl(const clang::ParmVarDecl *PVD) { \n\n14     llvm::outs() << \"\\tParameter: ’\" << PVD->getName() << \"’\\n\"; \n\n15   }\n```", "```cpp\n\n25   add_custom_command( \n\n26     OUTPUT ${SOURCE_FILE}.preprocessed \n\n27     COMMAND ${CMAKE_CXX_COMPILER} -E -I ${LLVM_HOME}/include ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCE_FILE} > ${SOURCE_FILE}.preprocessed \n\n28     DEPENDS ${SOURCE_FILE} \n\n29     COMMENT \"Preprocessing ${SOURCE_FILE}\" \n\n30   ) \n\n31   add_custom_target(preprocess ALL DEPENDS ${SOURCE_FILE}.preprocessed)\n```", "```cpp\n$ ninja preprocess\n```", "```cpp\n1RetTy Visit(typename Ptr<Decl>::type D) { \n\n2   switch (D->getKind()) { \n\n3    ... \n\n4    case Decl::ParmVar: return static_cast<ImplClass*>(this)->VisitParmVarDecl(static_cast<typename Ptr<ParmVarDecl>::type>(D)); \n\n5    ... \n\n6   } \n\n7 }\n```", "```cpp\n34 #define DISPATCH(NAME, CLASS) \\ \n\n35   return static_cast<ImplClass*>(this)->Visit##NAME(static_cast<PTR(CLASS)>(D))\n```", "```cpp\n1 cmake_minimum_required(VERSION 3.16) \n\n2 project(\"recursivevisitor\") \n\n3  \n\n4 if ( NOT DEFINED ENV{LLVM_HOME}) \n\n5   message(FATAL_ERROR \"$LLVM_HOME is not defined\") \n\n6 else() \n\n7   message(STATUS \"$LLVM_HOME found: $ENV{LLVM_HOME}\") \n\n8   set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH \"Root of LLVM installation\") \n\n9   set(LLVM_LIB ${LLVM_HOME}/lib) \n\n10   set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) \n\n11   find_package(LLVM REQUIRED CONFIG) \n\n12   include_directories(${LLVM_INCLUDE_DIRS}) \n\n13   link_directories(${LLVM_LIBRARY_DIRS}) \n\n14   set(SOURCE_FILE RecursiveVisitor.cpp) \n\n15   add_executable(recursivevisitor ${SOURCE_FILE}) \n\n16   set_target_properties(recursivevisitor PROPERTIES COMPILE_FLAGS \"-fno-rtti\") \n\n17   target_link_libraries(recursivevisitor \n\n18     LLVMSupport \n\n19     clangAST \n\n20     clangBasic \n\n21     clangFrontend \n\n22     clangSerialization \n\n23     clangTooling \n\n24   ) \n\n25 endif()\n```", "```cpp\n1 #include \"clang/Tooling/CommonOptionsParser.h\" \n\n2 #include \"clang/Tooling/Tooling.h\" \n\n3 #include \"llvm/Support/CommandLine.h\" // llvm::cl::extrahelp \n\n4  \n\n5 #include \"FrontendAction.hpp\" \n\n6  \n\n7 namespace { \n\n8 llvm::cl::OptionCategory TestCategory(\"Test project\"); \n\n9 llvm::cl::extrahelp \n\n10     CommonHelp(clang::tooling::CommonOptionsParser::HelpMessage); \n\n11 } // namespace \n\n12  \n\n13 int main(int argc, const char **argv) { \n\n14   llvm::Expected<clang::tooling::CommonOptionsParser> OptionsParser = \n\n15       clang::tooling::CommonOptionsParser::create(argc, argv, TestCategory); \n\n16   if (!OptionsParser) { \n\n17     llvm::errs() << OptionsParser.takeError(); \n\n18     return 1; \n\n19   } \n\n20   clang::tooling::ClangTool Tool(OptionsParser->getCompilations(), \n\n21                                  OptionsParser->getSourcePathList()); \n\n22   return Tool.run(clang::tooling::newFrontendActionFactory< \n\n23                       clangbook::recursivevisitor::FrontendAction>() \n\n24                       .get()); \n\n25 }\n```", "```cpp\n1 #include \"clang/AST/RecursiveASTVisitor.h\" \n\n2  \n\n3 namespace clangbook { \n\n4 namespace recursivevisitor { \n\n5 class Visitor : public clang::RecursiveASTVisitor<Visitor> { \n\n6 public: \n\n7   bool VisitFunctionDecl(const clang::FunctionDecl *FD) { \n\n8     llvm::outs() << \"Function: ’\" << FD->getName() << \"’\\n\"; \n\n9     return true; \n\n10   } \n\n11   bool VisitParmVarDecl(const clang::ParmVarDecl *PVD) { \n\n12     llvm::outs() << \"\\tParameter: ’\" << PVD->getName() << \"’\\n\"; \n\n13     return true; \n\n14   } \n\n15 }; \n\n16 } // namespace recursivevisitor \n\n17 } // namespace clangbook\n```", "```cpp\n$ ./recursivevisitor max.cpp -- -std=c++17\n...\nFunction: ’max’\n        Parameter: ’a’\n        Parameter: ’b’\n```", "```cpp\n1 cmake_minimum_required(VERSION 3.16) \n\n2 project(\"matchvisitor\") \n\n3  \n\n4 if ( NOT DEFINED ENV{LLVM_HOME}) \n\n5   message(FATAL_ERROR \"$LLVM_HOME is not defined\") \n\n6 else() \n\n7   message(STATUS \"$LLVM_HOME found: $ENV{LLVM_HOME}\") \n\n8   set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH \"Root of LLVM installation\") \n\n9   set(LLVM_LIB ${LLVM_HOME}/lib) \n\n10   set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) \n\n11   find_package(LLVM REQUIRED CONFIG) \n\n12   include_directories(${LLVM_INCLUDE_DIRS}) \n\n13   link_directories(${LLVM_LIBRARY_DIRS}) \n\n14   set(SOURCE_FILE MatchVisitor.cpp) \n\n15   add_executable(matchvisitor ${SOURCE_FILE}) \n\n16   set_target_properties(matchvisitor PROPERTIES COMPILE_FLAGS \"-fno-rtti\") \n\n17   target_link_libraries(matchvisitor \n\n18     LLVMFrontendOpenMP \n\n19     LLVMSupport \n\n20     clangAST \n\n21     clangASTMatchers \n\n22     clangBasic \n\n23     clangFrontend \n\n24     clangSerialization \n\n25     clangTooling \n\n26   ) \n\n27 endif()\n```", "```cpp\n1 #include \"clang/Tooling/CommonOptionsParser.h\" \n\n2 #include \"clang/Tooling/Tooling.h\" \n\n3 #include \"llvm/Support/CommandLine.h\" // llvm::cl::extrahelp \n\n4 #include \"MatchCallback.hpp\" \n\n5  \n\n6 namespace { \n\n7 llvm::cl::OptionCategory TestCategory(\"Test project\"); \n\n8 llvm::cl::extrahelp \n\n9     CommonHelp(clang::tooling::CommonOptionsParser::HelpMessage); \n\n10 } // namespace \n\n11  \n\n12 int main(int argc, const char **argv) { \n\n13   llvm::Expected<clang::tooling::CommonOptionsParser> OptionsParser = \n\n14       clang::tooling::CommonOptionsParser::create(argc, argv, TestCategory); \n\n15   if (!OptionsParser) { \n\n16     llvm::errs() << OptionsParser.takeError(); \n\n17     return 1; \n\n18   } \n\n19   clang::tooling::ClangTool Tool(OptionsParser->getCompilations(), \n\n20                                  OptionsParser->getSourcePathList()); \n\n21   clangbook::matchvisitor::MatchCallback MC; \n\n22   clang::ast_matchers::MatchFinder Finder; \n\n23   Finder.addMatcher(clangbook::matchvisitor::M, &MC); \n\n24   return Tool.run(clang::tooling::newFrontendActionFactory(&Finder).get()); \n\n25 }\n```", "```cpp\n1 #include \"clang/ASTMatchers/ASTMatchFinder.h\" \n\n2 #include \"clang/ASTMatchers/ASTMatchers.h\" \n\n3  \n\n4 namespace clangbook { \n\n5 namespace matchvisitor { \n\n6 using namespace clang::ast_matchers; \n\n7 static const char *MatchID = \"match-id\"; \n\n8 clang::ast_matchers::DeclarationMatcher M = \n\n9     functionDecl(decl().bind(MatchID), matchesName(\"max\")); \n\n10  \n\n11 class MatchCallback : public clang::ast_matchers::MatchFinder::MatchCallback { \n\n12 public: \n\n13   virtual void \n\n14   run(const clang::ast_matchers::MatchFinder::MatchResult &Result) final { \n\n15     if (const auto *FD = Result.Nodes.getNodeAs<clang::FunctionDecl>(MatchID)) { \n\n16       const auto &SM = *Result.SourceManager; \n\n17       const auto &Loc = FD->getLocation(); \n\n18       llvm::outs() << \"Found ’max’ function at \" << SM.getFilename(Loc) << \":\" \n\n19                    << SM.getSpellingLineNumber(Loc) << \":\" \n\n20                    << SM.getSpellingColumnNumber(Loc) << \"\\n\"; \n\n21     } \n\n22   } \n\n23 }; \n\n24  \n\n25 } // namespace matchvisitor \n\n26 } // namespace clangbook\n```", "```cpp\n8 clang::ast_matchers::DeclarationMatcher M = \n\n9     functionDecl(decl().bind(MatchID), matchesName(\"max\"));\n```", "```cpp\n1 int max(int a, int b) { \n\n2   if (a > b) return a; \n\n3   return b; \n\n4 } \n\n5  \n\n6 int min(int a, int b) { \n\n7   if (a > b) return b; \n\n8   return a; \n\n9 }\n```", "```cpp\n./matchvisitor minmax.cpp -- -std=c++17\n...\nFound the ’max’ function at minmax.cpp:1:5\n```", "```cpp\n$ ninja install-clang-query\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang-query minmax.cpp\n```", "```cpp\nclang-query> match functionDecl(decl().bind(\"match-id\"), matchesName(\"max\"))\nMatch #1:\nminmax.cpp:1:1: note: \"match-id\" binds here\nint max(int a, int b) {\n^~~~~~~~~~~~~~~~~~~~~~~\nminmax.cpp:1:1: note: \"root\" binds here\nint max(int a, int b) {\n^~~~~~~~~~~~~~~~~~~~~~~\n1  match.\nclang-query>\n```", "```cpp\nclang-query> set output dump\nclang-query> match parmVarDecl(hasName(\"a\"))\nMatch #1:\nBinding for \"root\":\nParmVarDecl 0x6775e48 <minmax.cpp:1:9, col:13> col:13 used a ’int’\nMatch #2:\nBinding for \"root\":\nParmVarDecl 0x6776218 <minmax.cpp:6:9, col:13> col:13 used a ’int’\n2  matches.\nclang-query>\n```", "```cpp\n1 int max(int a, int b) { \n\n2   if (a > b) { \n\n3     return ab; \n\n4   } \n\n5   return b; \n\n6 }\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang-query maxerr.cpp\n...\nmaxerr.cpp:3:12: error: use of undeclared identifier ’ab’\n    return ab;\n           ^\n```", "```cpp\nclang-query> set output dump\nclang-query> match returnStmt()\n```", "```cpp\nMatch #1:\nBinding for \"root\":\nReturnStmt 0x6b63230 <maxerr.cpp:5:3, col:10>\n‘-ImplicitCastExpr 0x6b63218 <col:10> ’int’ <LValueToRValue>\n  ‘-DeclRefExpr 0x6b631f8 <col:10> ’int’ lvalue ParmVar 0x6b62ec8 ’b’ ’int’\n\nMatch #2:\nBinding for \"root\":\nReturnStmt 0x6b631b0 <maxerr.cpp:3:5, col:12>\n‘-RecoveryExpr 0x6b63190 <col:12> ’<dependent type>’ contains-errors lvalue\n\n2  matches.\n```"]