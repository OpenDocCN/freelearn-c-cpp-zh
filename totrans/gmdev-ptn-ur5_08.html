<html><head></head><body>
<div id="_idContainer154">
<h1 class="chapter-number" id="_idParaDest-102"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-103"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.2.1">Building Design Patterns – Singleton, Command, and State</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Whereas the previous chapter looked at a methodology of code architecture design, this chapter will look at three design patterns you can build yourself that have applications across many </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">game genres.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The patterns being covered are </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Singleton pattern – understanding why it’s a Pandora’s box that often </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">gets overused</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Command pattern – how it has many uses beyond </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the obvious</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">The many levels of state machine traveling down the rabbit hole and seeing how far we can push </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">its concept</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.13.1">The aim of this will be to make some base classes that can be imported into any future project to speed up development. </span><span class="koboSpan" id="kobo.13.2">By the end of the chapter, you should understand why so many online resources overuse the Singleton pattern, what a hidden gem the Command pattern is, and how deep customization can go with the humble </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">state machine.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">This chapter will be building on the </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">real-time strategy</span></strong><span class="koboSpan" id="kobo.18.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.19.1">RTS</span></strong><span class="koboSpan" id="kobo.20.1">) framework project of previous chapters using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.21.1">chapter8</span></strong><span class="koboSpan" id="kobo.22.1"> branch on GitHub, which can be downloaded </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">from </span></span><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter08"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter08</span></span></a></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.25.1">Implementing a Singleton pattern – understanding why it’s a Pandora’s box</span></h1>
<p><span class="koboSpan" id="kobo.26.1">The official point of the </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.27.1">Singleton pattern is to ensure there is only one instance of a class in existence at any one time, hence the name “single”-ton. </span><span class="koboSpan" id="kobo.27.2">Unfortunately, this often gets packaged and confused with a public static variable to this one existing object. </span><span class="koboSpan" id="kobo.27.3">The actual idea of only having one object instance of a class makes sense. </span><span class="koboSpan" id="kobo.27.4">You might have a manager that needs to exist in every level, but if you don’t know the path the player took to get to this level, then you have no idea if one has been spawned yet. </span><span class="koboSpan" id="kobo.27.5">The solution is to make the manager a Singleton class and have a copy at every level. </span><span class="koboSpan" id="kobo.27.6">We can do this with the following code, using a static variable pointing to the one </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">that exists:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.29.1">Example Singleton.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.30.1">
UCLASS()
public Singleton : public AActor
{
    static TObjectPtr&lt;Singleton&gt; _instance;
public:
    void Init();
}</span></pre> <p><span class="koboSpan" id="kobo.31.1">We then have a choice on whether we delete the new one if it is a second or if it should assume the position of the instance, deleting what was previously there . </span><span class="koboSpan" id="kobo.31.2">The body file therefore </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">would be:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.33.1">Example Singleton.cpp excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.34.1">
void Singleton::Init()
{
    if (_instance == nullptr)
    {
        _instance = this;
    }
    else
    {
        this-&gt;Destroy();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.35.1">There is an</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.36.1"> innate question arising from this. </span><span class="koboSpan" id="kobo.36.2">Internally, our monologue could sound like: “If only one instance of this class will ever exist, then why does it need to be instanced in the first place? </span><span class="koboSpan" id="kobo.36.3">Surely, making the entire class static has the same effect and will take up less memory with the functions and variables only existing on the stack, negating the need for a Singleton pattern.” </span><span class="koboSpan" id="kobo.36.4">You could answer that with a situation. </span><span class="koboSpan" id="kobo.36.5">Perhaps there is a need to replace the object in the instance slot with every new level. </span><span class="koboSpan" id="kobo.36.6">That is one argument for a Singleton pattern, but the usage is limited and can usually be designed around using the pattern we discussed at great length in </span><a href="B18297_07.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.37.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.38.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">The other issue is that most implementations of the Singleton pattern use a public static variable for tracking the instance. </span><span class="koboSpan" id="kobo.39.2">This has led many people to think the purpose of this pattern is for an easy communication link between a top-level system and any object that needs it. </span><span class="koboSpan" id="kobo.39.3">Doing this potentially couples every class with the Singleton pattern, which we have established in previous chapters is a thing to be avoided. </span><span class="koboSpan" id="kobo.39.4">The effect can be seen clearly in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.40.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.41.1">.1</span></em><span class="koboSpan" id="kobo.42.1">, where every class aggregates the </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Singleton</span></strong><span class="koboSpan" id="kobo.44.1"> class into its memory footprint because it has one or more </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">references within:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer141">
<span class="koboSpan" id="kobo.46.1"><img alt="Figure 8.1 – UML﻿ diagram of a Singleton pattern being aggregated into lots of classes" src="image/Figure_08.01_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.47.1">Figure 8.1 – UML diagram of a Singleton pattern being aggregated into lots of classes</span></p>
<p><span class="koboSpan" id="kobo.48.1">The correct</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.49.1"> usage is a private static variable used to track the instance, as shown at the start of this section. </span><span class="koboSpan" id="kobo.49.2">Then, with the instance created by a manager, it fits into the hierarchical class tree shown in </span><a href="B18297_07.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.50.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">This manager can then distribute the direct reference to any classes under it via the initialization chain. </span><span class="koboSpan" id="kobo.51.3">This is what we know </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.52.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">dependency injection</span></strong><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">This does still create coupling, but the spread is much more controlled. </span><span class="koboSpan" id="kobo.54.3">An example custom initializer function for a unit in a grid-based game could have the dependency of the grid injected into it instead of making the grid a Singleton pattern that anything can access. </span><span class="koboSpan" id="kobo.54.4">Next, you can see an example of how this could be constructed and how little this method impacts the flow of </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">the code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.56.1">Dependency injection example</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.57.1">
void AUnit::Init(AGrid* grid)
{
    _GridRef = grid;
}
void AUnit::Move(FVector2 targetCoords)
{
    Path p = GridRef-&gt;GetPath(_CurrentCoords,
        targetCoords))
    if(p != nullptr)
{
        //Move the Unit
    }
}</span></pre> <p><span class="koboSpan" id="kobo.58.1">Overall, the actual concept and code for the Singleton pattern </span><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.59.1">is relatively simple; the problem lies in how it is used. </span><span class="koboSpan" id="kobo.59.2">Even with the cleaner implementation, most – if not all – cases where a Singleton pattern has been used can be replaced with a different pattern to make the code easier to expand. </span><span class="koboSpan" id="kobo.59.3">Aggregation may mean that this functionality can become a component, or there may need to be a shift in the structure to something more like a subclass sandbox pattern (to be discussed later, in </span><a href="B18297_09.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.60.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.61.1">) where the functionality is statically defined in a parent. </span><span class="koboSpan" id="kobo.61.2">Dependency injection takes most of the replacement duty, as the common use for a</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.62.1"> Singleton pattern will be a global utility class such as a </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">Fog of War</span></strong><span class="koboSpan" id="kobo.64.1"> manager on a tiled grid. </span><span class="koboSpan" id="kobo.64.2">This is better sent through the initialization chain as a dependency injection so that other clas</span><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.65.1">ses don’t also have access allowing other developers to incorrectly use </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the </span></span><span class="No-Break"><a id="_idIndexMarker309"/></span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Now that the temptation of the Singleton pattern has been expunged from our minds, we can move on to patterns that are useful in multiple scenarios, such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">Command pattern.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.70.1">Implementing the Command pattern for different use cases</span></h1>
<p><span class="koboSpan" id="kobo.71.1">The </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.72.1">Command pattern adds a layer of separation between the request for an action and that action being carried out. </span><span class="koboSpan" id="kobo.72.2">The implementation looks like what is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.73.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.74.1">.2</span></em><span class="koboSpan" id="kobo.75.1">, where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">Command</span></strong><span class="koboSpan" id="kobo.77.1"> class parent is abstract and only has a constructor, </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">execute()</span></strong><span class="koboSpan" id="kobo.79.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">undo()</span></strong><span class="koboSpan" id="kobo.81.1"> functions that all take no arguments. </span><span class="koboSpan" id="kobo.81.2">The idea is that the child classes are more specific and contain all the object references needed to </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">execute properly:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer142">
<span class="koboSpan" id="kobo.83.1"><img alt="Figure 8.2 – UML diagram showing the structure of a Command pattern base class" src="image/Figure_08.02_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.84.1">Figure 8.2 – UML diagram showing the structure of a Command pattern base class</span></p>
<p><span class="koboSpan" id="kobo.85.1">The purpose of a command is to reify the abstract idea of an action so that we can store it in a list. </span><span class="koboSpan" id="kobo.85.2">This list can have many uses, but the most identified is the undo queue that Microsoft made synonymous with its keyboard shortcut, </span><em class="italic"><span class="koboSpan" id="kobo.86.1">Ctrl</span></em><span class="koboSpan" id="kobo.87.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Z</span></em><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">When an action is performed, a Command object of the relevant type is created and added to the list. </span><span class="koboSpan" id="kobo.89.3">The command is executed and left in this list until it falls off the back; this keeps the list in chronological order. </span><span class="koboSpan" id="kobo.89.4">If the user presses the undo key, then the last command in the list has its undo function called, and a pointer for the most recent command moves back one. </span><span class="koboSpan" id="kobo.89.5">This is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.90.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.91.1">.3,</span></em><span class="koboSpan" id="kobo.92.1"> where you can see that creating a new command after some have been undone chops the undone commands off and inserts the new command as the head of </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">the list:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer143">
<span class="koboSpan" id="kobo.94.1"><img alt="Figure 8.3 – Diagram showing the process of adding, undoing, and branching commands" src="image/Figure_08.03_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.95.1">Figure 8.3 – Diagram showing the process of adding, undoing, and branching commands</span></p>
<p><span class="koboSpan" id="kobo.96.1">In games, we</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.97.1"> can use this functionality for a plethora of different scenarios. </span><span class="koboSpan" id="kobo.97.2">The most common are strategy games, where the player can queue up actions for their units to be executed in a certain order, each only executing after the last has finished. </span><span class="koboSpan" id="kobo.97.3">Surprisingly few strategy games make use of the Command pattern’s undo capabilities, but that may be because it would reduce the cost of actions. </span><span class="koboSpan" id="kobo.97.4">Undo is making more of an appearance in modern games in the form of a rewind mechanic; exploited in classics such as </span><em class="italic"><span class="koboSpan" id="kobo.98.1">Braid</span></em><span class="koboSpan" id="kobo.99.1"> and incorporated as a feature into AAA games such as the </span><em class="italic"><span class="koboSpan" id="kobo.100.1">Forza Horizon</span></em><span class="koboSpan" id="kobo.101.1"> series. </span><span class="koboSpan" id="kobo.101.2">This real-time application has varying methods of execution; it is likely that </span><em class="italic"><span class="koboSpan" id="kobo.102.1">Braid</span></em><span class="koboSpan" id="kobo.103.1"> simply records all moving objects’ positions on a timer as there is so little going on in the scene. </span><span class="koboSpan" id="kobo.103.2">This approach clearly wouldn’t work for a racing game with complex physics; instead, you could record each time the player’s input changes as a different command. </span><span class="koboSpan" id="kobo.103.3">The undo queue then has to run the game backward and understand when commands were added to the list to </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">preserve momentum.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Saving each of the players’ input actions into a list can also work as a sort of replay-saving mechanic. </span><span class="koboSpan" id="kobo.105.2">This works for games such as the </span><em class="italic"><span class="koboSpan" id="kobo.106.1">Trials</span></em><span class="koboSpan" id="kobo.107.1"> series and fighting games such as </span><em class="italic"><span class="koboSpan" id="kobo.108.1">Super Smash Bros.</span></em><span class="koboSpan" id="kobo.109.1"> because there are no elements of randomness in the mechanics. </span><span class="koboSpan" id="kobo.109.2">If you input the same action at the same time, you will have the same result every time. </span><span class="koboSpan" id="kobo.109.3">This</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.110.1"> could lead to large replay files, with each input axis saving potentially a value every frame. </span><span class="koboSpan" id="kobo.110.2">There are potential ways around this, such as only saving the result of these inputs when an action is performed that relies on the state of the driven element. </span><span class="koboSpan" id="kobo.110.3">This could mean instead of saving every mouse movement in </span><em class="italic"><span class="koboSpan" id="kobo.111.1">World of Tanks</span></em><span class="koboSpan" id="kobo.112.1">, the barrel rotation and time are saved every time a shell is fired and the barrel is hit. </span><span class="koboSpan" id="kobo.112.2">This way, all the little motions that add to zero are ignored from the </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">replay file.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.114.1">Command pattern for undo functionality in Blueprint Utilities</span></h2>
<p><span class="koboSpan" id="kobo.115.1">In </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.116.1">Unreal, we can make tools to use in the editor </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.117.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Blueprint Utilities</span></strong><span class="koboSpan" id="kobo.119.1"> (formerly known as Blutilities during early development). </span><span class="koboSpan" id="kobo.119.2">Blueprint Utilities can be created as either</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.120.1"> right-click menu actions or as Utility Widgets that operate in a floating window or can be docked into the UI and can manipulate assets (the files in the content browser) or actors (elements within the world) to complete repeated actions, to reduce the impact of workflow steps or simply to remove the requirement for user input to reduce opportunities </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">for mistakes.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">Editor Utilities can hold any number of tools within them, with each tool being created as its own function, having its own graph or a custom event within the standard Blueprint Event Graph. </span><span class="koboSpan" id="kobo.122.2">Actor and Asset Utility Widgets require us to define which class of actor or asset the tools will interact with, known as the </span><em class="italic"><span class="koboSpan" id="kobo.123.1">Supported Class</span></em><span class="koboSpan" id="kobo.124.1">, enabling them to be added contextually to the </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">right-click menus.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">We are going to explore implementing the Command pattern using transaction nodes in Blueprint to add the ability to undo the process a tool does. </span><span class="koboSpan" id="kobo.126.2">To do this, we are going to create a simple tool that rotates the selected objects in the level by </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">45 degrees.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">To begin with, let’s create a Utility Blueprint and define its </span><em class="italic"><span class="koboSpan" id="kobo.129.1">Supported Class</span></em><span class="koboSpan" id="kobo.130.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">Actor</span></strong><span class="koboSpan" id="kobo.132.1"> (so that we can use the tool on any actor in the world). </span><span class="koboSpan" id="kobo.132.2">To do this, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.134.1">Right-click in the content browser and navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">Editor Utilities</span></strong><span class="koboSpan" id="kobo.136.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Editor</span></strong> <span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.138.1">Utility Blueprint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.140.1">From the popup, expand the </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">All Classes</span></strong><span class="koboSpan" id="kobo.142.1"> rollout, select </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">ActorActionUtility</span></strong><span class="koboSpan" id="kobo.144.1">, and click the </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">Select</span></strong><span class="koboSpan" id="kobo.146.1"> button once it </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">becomes available.</span></span></li>
<li><span class="koboSpan" id="kobo.148.1">Give the new Blueprint an appropriate name such </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">EU_ActorTransformTools</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.152.1">Open the Blueprint, then on the left side, hover over the </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">Functions</span></strong><span class="koboSpan" id="kobo.154.1"> section of the </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">My Blueprint</span></strong><span class="koboSpan" id="kobo.156.1"> tab. </span><span class="koboSpan" id="kobo.156.2">This should reveal the </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">Override</span></strong><span class="koboSpan" id="kobo.158.1"> dropdown; from this, select </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">Get </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.160.1">Supported Class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.162.1">This should have automatically opened the </span><strong class="bold"><span class="koboSpan" id="kobo.163.1">Get Supported Class</span></strong><span class="koboSpan" id="kobo.164.1"> function graph. </span><span class="koboSpan" id="kobo.164.2">From here, delete the </span><strong class="bold"><span class="koboSpan" id="kobo.165.1">Parent: Get Supported Class</span></strong><span class="koboSpan" id="kobo.166.1"> node and, using the dropdown on the </span><strong class="bold"><span class="koboSpan" id="kobo.167.1">Return Node</span></strong><span class="koboSpan" id="kobo.168.1"> node, select </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">Actor</span></strong><span class="koboSpan" id="kobo.170.1"> as the supported class for any tools built in </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">this Blueprint:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer144">
<span class="koboSpan" id="kobo.172.1"><img alt="Figure 8.4 – The Get Supported Class function, overridden to set Actor as the supported class" src="image/Figure_08.04_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.173.1">Figure 8.4 – The Get Supported Class function, overridden to set Actor as the supported class</span></p>
<p><span class="koboSpan" id="kobo.174.1">With the </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.175.1">Blueprint set up, we can</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.176.1"> now add our tools to it. </span><span class="koboSpan" id="kobo.176.2">We can add tools either as functions or custom events, as mentioned earlier in this section. </span><span class="koboSpan" id="kobo.176.3">For this example, we will create our tool as a new function to keep the structure of the tools within the Utility </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">Blueprint tidy:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.178.1">With the Utility Blueprint open, click the </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">+</span></strong><span class="koboSpan" id="kobo.180.1"> sign on the </span><strong class="bold"><span class="koboSpan" id="kobo.181.1">Functions</span></strong><span class="koboSpan" id="kobo.182.1"> rollout to create a new function; call this </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">function </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">RotateSelected45</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.186.1">With the </span><strong class="bold"><span class="koboSpan" id="kobo.187.1">RotateSelected45</span></strong><span class="koboSpan" id="kobo.188.1"> graph open (which should happen automatically) in the </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">Details</span></strong><span class="koboSpan" id="kobo.190.1"> panel, set the </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">Call in Editor</span></strong><span class="koboSpan" id="kobo.192.1"> checkbox </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.194.1">On</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.196.1">With the function set up, let’s test that we’ve enabled the correct things and the function is appearing in the menus when we right-click on something in the viewport, </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">like so:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.198.1">Add some cubes to the level using the </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">Quickly Add to the Project</span></strong><span class="koboSpan" id="kobo.200.1"> button, navigating to </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">Shapes</span></strong><span class="koboSpan" id="kobo.202.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">Cube</span></strong><span class="koboSpan" id="kobo.204.1">, and dragging one into </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">the viewport.</span></span></li>
<li><span class="koboSpan" id="kobo.206.1">Duplicate the cube a few times by holding </span><em class="italic"><span class="koboSpan" id="kobo.207.1">Alt</span></em><span class="koboSpan" id="kobo.208.1"> and dragging the cube using the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.209.1">Move</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.210.1"> tool.</span></span></li>
<li><span class="koboSpan" id="kobo.211.1">Select all of the cubes and right-click on one of them. </span><span class="koboSpan" id="kobo.211.2">You should now be able to navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">Scripted Actor Actions</span></strong><span class="koboSpan" id="kobo.213.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">Rotate </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.215.1">Selected 45</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.217.1">At this point, nothing will happen because we have not yet created any logic in the </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">Blueprint function.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Next, we will </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.220.1">set up the functionality</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.221.1"> to rotate the actor (not worrying yet about implementing the Command pattern). </span><span class="koboSpan" id="kobo.221.2">The process here is to first identify which actors the user has selected, then use a </span><strong class="bold"><span class="koboSpan" id="kobo.222.1">For Each Loop</span></strong><span class="koboSpan" id="kobo.223.1"> node to rotate the actor in the world. </span><span class="koboSpan" id="kobo.223.2">To do this in Blueprint, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.225.1">Drag from the pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">Rotate Selected 45</span></strong><span class="koboSpan" id="kobo.227.1"> node and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">Get Selected </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Actors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.231.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">Return Value</span></strong><span class="koboSpan" id="kobo.233.1"> array pin and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">For Each </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">Loop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.237.1">Connect the output pin from the </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">Get Selected Actors</span></strong><span class="koboSpan" id="kobo.239.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">Exec</span></strong><span class="koboSpan" id="kobo.241.1"> pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">For Each </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.243.1">Loop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.244.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.245.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Array Element</span></strong><span class="koboSpan" id="kobo.247.1"> pin and add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">Add Actor World </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">Rotation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.250.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.251.1">Set the </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">Delta Rotation</span></strong><span class="koboSpan" id="kobo.253.1"> value to </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">X</span></strong><span class="koboSpan" id="kobo.255.1">:</span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">0</span></strong><span class="koboSpan" id="kobo.257.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">Y</span></strong><span class="koboSpan" id="kobo.259.1">:</span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">0</span></strong><span class="koboSpan" id="kobo.261.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.263.1">Z</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">:</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">45</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.267.1">Your function should now </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">look this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer145">
<span class="koboSpan" id="kobo.269.1"><img alt="Figure 8.5 – The Rotate Selected 45 function without undo functionality" src="image/Figure_08.05_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.270.1">Figure 8.5 – The Rotate Selected 45 function without undo functionality</span></p>
<p><span class="koboSpan" id="kobo.271.1">With the functionality set up, test the function again with the same process as before when we tested that the function was appearing. </span><span class="koboSpan" id="kobo.271.2">You should now see that the </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">box rotates.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.273.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.274.1">If you have </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">Realtime</span></strong><span class="koboSpan" id="kobo.276.1"> turned off in the viewport, you will not see the box rotate until you move the viewport for it </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">to update.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">With the</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.279.1"> functionality </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.280.1">now working, we want to add the ability to undo the action by implementing the Command pattern using the</span><strong class="bold"><span class="koboSpan" id="kobo.281.1"> Transaction</span></strong><span class="koboSpan" id="kobo.282.1"> system. </span><span class="koboSpan" id="kobo.282.2">To do this, we need to add three nodes: a </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">Begin Transaction</span></strong><span class="koboSpan" id="kobo.284.1"> node, to start the process of recording the actions, a </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">Transact Object</span></strong><span class="koboSpan" id="kobo.286.1"> node, which is used to identify objects that are about to have a property changed, and an </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">End Transaction</span></strong><span class="koboSpan" id="kobo.288.1"> node, which stops the process of recording actions. </span><span class="koboSpan" id="kobo.288.2">Follow </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.290.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Begin Transaction</span></strong><span class="koboSpan" id="kobo.292.1"> node at the start of the function, between the </span><strong class="bold"><span class="koboSpan" id="kobo.293.1">Rotate Selected 45</span></strong><span class="koboSpan" id="kobo.294.1"> node and the </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">Get Selected </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.296.1">Actors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.297.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.298.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Transact Object</span></strong><span class="koboSpan" id="kobo.300.1"> node as the first part of the for each loop, between the </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">For Each Loop</span></strong><span class="koboSpan" id="kobo.302.1"> node and the </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">Add Actor World Rotation</span></strong><span class="koboSpan" id="kobo.304.1"> node in the </span><strong class="bold"><span class="koboSpan" id="kobo.305.1">Loop </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.306.1">Body</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.307.1"> chain.</span></span></li>
<li><span class="koboSpan" id="kobo.308.1">Drag out from the </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">Completed</span></strong><span class="koboSpan" id="kobo.310.1"> pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.311.1">For Each Loop</span></strong><span class="koboSpan" id="kobo.312.1"> node and add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">End Transaction</span></strong><span class="koboSpan" id="kobo.314.1"> node, completing </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the function.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.316.1">Your function should now look like this; we’ve added some reroute nodes to the link between the </span><strong class="bold"><span class="koboSpan" id="kobo.317.1">For Each Loop</span></strong><span class="koboSpan" id="kobo.318.1"> node’s </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">Array Element</span></strong><span class="koboSpan" id="kobo.320.1"> pin and the </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">Target</span></strong><span class="koboSpan" id="kobo.322.1"> pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">Add Actor World </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.324.1">Rotation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1"> node:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer146">
<span class="koboSpan" id="kobo.326.1"><img alt="Figure 8.6 – The completed Rotate Selected 45 function with Transaction nodes" src="image/Figure_08.06_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.327.1">Figure 8.6 – The completed Rotate Selected 45 function with Transaction nodes</span></p>
<p><span class="koboSpan" id="kobo.328.1">With the function now complete, it is time to test it again. </span><span class="koboSpan" id="kobo.328.2">Repeat the steps from before, and the box should </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">still rotate.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">The </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.331.1">difference now is you </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.332.1">should be able to click </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Edit</span></strong><span class="koboSpan" id="kobo.334.1"> in the top toolbar and see that an option for </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">Undo Blutility Action</span></strong><span class="koboSpan" id="kobo.336.1"> has become available in the </span><strong class="bold"><span class="koboSpan" id="kobo.337.1">HISTORY</span></strong><span class="koboSpan" id="kobo.338.1"> section. </span><span class="koboSpan" id="kobo.338.2">If you select it, you should be able to see that any actors that were rotated by the tool return to their </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">previous state:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<span class="koboSpan" id="kobo.340.1"><img alt="Figure 8.7 – Undo Blutility Action in the HISTORY section of the Edit menu" src="image/Figure_08.07_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.341.1">Figure 8.7 – Undo Blutility Action in the HISTORY section of the Edit menu</span></p>
<p><span class="koboSpan" id="kobo.342.1">You can also see </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">Blutility Action</span></strong><span class="koboSpan" id="kobo.344.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">Transactions</span></strong><span class="koboSpan" id="kobo.346.1"> list when you select </span><strong class="bold"><span class="koboSpan" id="kobo.347.1">Undo History</span></strong><span class="koboSpan" id="kobo.348.1"> from the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.349.1">Edit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1"> menu:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer148">
<span class="koboSpan" id="kobo.351.1"><img alt="Figure 8.8 – The Transactions list in the Undo History window" src="image/Figure_08.08_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.352.1">Figure 8.8 – The Transactions list in the Undo History window</span></p>
<p><span class="koboSpan" id="kobo.353.1">With </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.354.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">Blutility Action</span></strong><span class="koboSpan" id="kobo.356.1"> appearing </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.357.1">in the undo history and working correctly, the tool is </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">now complete.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">When creating tools using Blueprint Utilities, it is considered best practice to always include the ability for the user to undo the effect of the tool, so implementing the Command pattern is key to creating </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">user-friendly solutions.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.361.1">Command pattern for gameplay in C++</span></h2>
<p><span class="koboSpan" id="kobo.362.1">Making our own version of the Command pattern for general </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.363.1">use, let’s establish a class for our base command. </span><span class="koboSpan" id="kobo.363.2">Start by making a child of </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">UObject</span></strong><span class="koboSpan" id="kobo.365.1"> inside your IDE. </span><span class="koboSpan" id="kobo.365.2">We are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">UObject</span></strong><span class="koboSpan" id="kobo.367.1"> so that our class is visible to the engine, but it doesn’t need all the extra trappings of </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">AActor</span></strong><span class="koboSpan" id="kobo.369.1">, such as a transform. </span><span class="koboSpan" id="kobo.369.2">We mark it as </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">Abstract</span></strong><span class="koboSpan" id="kobo.371.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">UCLASS()</span></strong><span class="koboSpan" id="kobo.373.1"> macro to make sure no instance will ever be made of this object. </span><span class="koboSpan" id="kobo.373.2">This class only needs a virtual execute function as we won’t be supporting undo queueing, and initialization will be dealt with differently from standard C++ implementations due to the way Unreal deals with object spawning, let's set </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">that up.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.375.1">Command.h</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.376.1">
#pragma once
#include "CoreMinimal.h"
#include "Command.generated.h"
UCLASS(Abstract)
class RTS_AI_API UCommand : public UObject
{
    GENERATED_BODY()
public:
    virtual void Execute();
};</span></pre> <p><span class="koboSpan" id="kobo.377.1">We only need to generate empty function definitions in the body file; there is no need to add any code to the functions as whatever is written there will never run. </span><span class="koboSpan" id="kobo.377.2">After creating the base command class, compile everything into the editor layer to make sure there are no errors. </span><span class="koboSpan" id="kobo.377.3">With it all compiled, right-click on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">Command</span></strong><span class="koboSpan" id="kobo.379.1"> object in the project drawer and create a child C++ class called something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">Command_UnitMove</span></strong><span class="koboSpan" id="kobo.381.1">. </span><span class="koboSpan" id="kobo.381.2">This will be the first command linked with our framework. </span><span class="koboSpan" id="kobo.381.3">The definition and body are shown next and are simple. </span><span class="koboSpan" id="kobo.381.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">Init</span></strong><span class="koboSpan" id="kobo.383.1"> function is made so that we can set up local variables for the command to execute with, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Execute</span></strong><span class="koboSpan" id="kobo.385.1"> function is overridden to </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.386.1">actually use those values by calling the interfaced function on the reference object. </span><span class="koboSpan" id="kobo.386.2">Setup the header file as </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">shown below:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.388.1">Command_UnitMove.h</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.389.1">
UCLASS()
class RTS_AI_API UCommand_UnitMove : public UCommand
{
    GENERATED_BODY()
public:
    void Init(AActor* unit, FVector moveLocation);
    virtual void Execute() override;
private:
    TObjectPtr&lt;AActor&gt; _unit;
    FVector _moveLocation;
};</span></pre> <p><span class="koboSpan" id="kobo.390.1">As you can see next, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">Init</span></strong><span class="koboSpan" id="kobo.392.1"> function actually has no innards. </span><span class="koboSpan" id="kobo.392.2">Instead, we use C++ standard constructor overloading syntax to pass the arguments up to the constructors of the internal objects. </span><span class="koboSpan" id="kobo.392.3">This is not necessary as code in the body will still work, but it is considered better practice as it uses slightly less memory, but only fractionally. </span><span class="koboSpan" id="kobo.392.4">So, let's add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">Init</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.394.1"> function:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.395.1">Command_UnitMove.cpp</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
void UCommand_UnitMove::Init(AActor* unit,
    FVector moveLocation) : _unit(unit)_moveLocation
        (moveLocation) 
{}
void UCommand_UnitMove::Execute()
{
    Super::Execute();
    IControllableUnit::Execute_SetMoveLocation(_unit,_moveLocation);
}</span></pre> <p><span class="koboSpan" id="kobo.397.1">The next steps would be to augment the system for </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.398.1">consuming input to distinguish when we want to add a command to the queue versus just overwriting what is there. </span><span class="koboSpan" id="kobo.398.2">This would be a couple of lines in many different classes, but we have provided the base for you. </span><span class="koboSpan" id="kobo.398.3">To inspect what has been made, you can head to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">PC_RTS</span></strong><span class="koboSpan" id="kobo.400.1"> header and body and look at how the input is routed into the pawn via interface calls. </span><span class="koboSpan" id="kobo.400.2">The part we are working on next is the character being controlled. </span><span class="koboSpan" id="kobo.400.3">There is a function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">AEliteUnit</span></strong><span class="koboSpan" id="kobo.402.1"> class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">QueueMoveLocation_Implementation</span></strong><span class="koboSpan" id="kobo.404.1">, which is currently empty. </span><span class="koboSpan" id="kobo.404.2">As it stands, our player can right-click anywhere while holding left </span><em class="italic"><span class="koboSpan" id="kobo.405.1">shift</span></em><span class="koboSpan" id="kobo.406.1"> for this function to fire. </span><span class="koboSpan" id="kobo.406.2">What we would like is for this function to create a new move </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">Command</span></strong><span class="koboSpan" id="kobo.408.1"> object, initialize it, and store it in a queue. </span><span class="koboSpan" id="kobo.408.2">For that, we need a queue, so in the header, add a protected or private </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">TQueue&lt;TObjectPtr&lt;UCommand&gt;&gt;</span></strong><span class="koboSpan" id="kobo.410.1"> variable, autocompleting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">#include</span></strong><span class="koboSpan" id="kobo.412.1"> instances where necessary, and name it something sensible; we have gone with </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">_commandQueue</span></strong><span class="koboSpan" id="kobo.414.1">. </span><span class="koboSpan" id="kobo.414.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">QueueMoveLocation_Implementation</span></strong><span class="koboSpan" id="kobo.416.1"> function can now check if the character is in the process of moving, and if it is, do exactly what was detailed previously. </span><span class="koboSpan" id="kobo.416.2">Create a new command to reify the request, initialize it with values, and add it to </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">the queue:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.418.1">QueueMoveLocation_Implementation function</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
void AEliteUnit::QueueMoveLocation_Implementation(FVector targetLocation)
{
    if(!_isMoving)
    {
        _AIController-&gt;GetBlackboardComponent()-&gt;
            SetValueAsVector("MoveToLocation", targetLocation);
        _isMoving = true;
        return;
    }
    TobjectPtr&lt;Ucommand_UnitMove&gt; moveCommand =
        NewObject&lt;Ucommand_UnitMove&gt;(this);
    moveCommand-&gt;Init(this, targetLocation);
    _CommandQueue.Enqueue(moveCommand);
}</span></pre> <p><span class="koboSpan" id="kobo.420.1">It is all well and good storing requests to move, but </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.421.1">there needs to be a system for clearing the queue as commands are completed, making use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">Dequeue</span></strong><span class="koboSpan" id="kobo.423.1"> function. </span><span class="koboSpan" id="kobo.423.2">This is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">MoveLocationReached_Implementation</span></strong><span class="koboSpan" id="kobo.425.1"> callback function comes in. </span><span class="koboSpan" id="kobo.425.2">This needs to see if there are any commands, and if there are, remove them from the queue and call their </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Execute</span></strong><span class="koboSpan" id="kobo.427.1"> function. </span><span class="koboSpan" id="kobo.427.2">This is the reason we made sure the command has all its resources injected on creation: so that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">Execute</span></strong><span class="koboSpan" id="kobo.429.1"> function can remain parameter-less and therefore useful, as set out in the </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">code below.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.431.1">MoveLocationReached_Implementation function</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.432.1">
void AEliteUnit::MoveLocationReached_Implementation()
{
    _isMoving = false;
    if(!_CommandQueue.IsEmpty())
    {
        TObjectPtr&lt;UCommand&gt; command;
        _CommandQueue.Dequeue(command);
        command-&gt;Execute();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.433.1">With that, the system is functionally complete. </span><span class="koboSpan" id="kobo.433.2">There is, of course, no</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.434.1"> feedback to the user about what currently exists in the queue; that would require a lot more in the way of functions to peek values of commands, but if you wanted to expand this to include different types of move commands or actions, then all you’d need to do is make them from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">UCommand</span></strong><span class="koboSpan" id="kobo.436.1"> base, create them somewhere, and add them to </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">Our system uses a queue of commands for stacking player commands, but if you wanted an AI to be in control, you could preload it with a set of actions it can perform and let it loose with some form of </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">Goal-Oriented Action Planning</span></strong><span class="koboSpan" id="kobo.440.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.441.1">GOAP</span></strong><span class="koboSpan" id="kobo.442.1">). </span><span class="koboSpan" id="kobo.442.2">GOAP is an AI design method that abstracts individual</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.443.1"> interactions with the world from the purpose they fulfill. </span><span class="koboSpan" id="kobo.443.2">Stringing these actions together in a chain can create a strategy to achieve a goal. </span><span class="koboSpan" id="kobo.443.3">The Command pattern is a great way of implementing this as you can pre-generate a series of commands that make up all the actions an AI can take. </span><span class="koboSpan" id="kobo.443.4">Then, the AI strings them together into a queue, as we did previously for the action queue on the controllable unit, to plan its strategy. </span><span class="koboSpan" id="kobo.443.5">Executing the commands one by one then hopefully allows the AI to achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">its goal.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">By the very nature of making games, there is always some use for the Command pattern, which makes it a good pattern to practice setting as a templated plugin, much as with our next pattern, the state machine, where the Command pattern is used to delay and record logic and the state machine segregates it </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">by use.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.447.1">Creating the many levels of a state machine</span></h1>
<p><span class="koboSpan" id="kobo.448.1">A</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.449.1"> state machine allows us to separate behavior based on the idea of a </span><em class="italic"><span class="koboSpan" id="kobo.450.1">state</span></em><span class="koboSpan" id="kobo.451.1"> – a simple concept, but it has wide-reaching applications from animation state machines to AI logic and contextual </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">player actions.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">The simplest of state machines feature two elements: states</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.454.1"> and transitions. </span><span class="koboSpan" id="kobo.454.2">A state machine, at</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.455.1"> any moment, will either be in a single state or transitioning between two different states, which is why they are a significant part of animation systems, where blending improves the visual quality and feel of characters when receiving input from the player. </span><span class="koboSpan" id="kobo.455.2">Let’s look at this in </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">more detail:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.457.1">A state</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.458.1"> defines a specific output and/or value of variables. </span><span class="koboSpan" id="kobo.458.2">In an animation state machine, the state defines which animation asset should </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">be playing.</span></span></li>
<li><span class="koboSpan" id="kobo.460.1">A transition</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.461.1"> contains the logic that defines when a state machine can transition between two states. </span><span class="koboSpan" id="kobo.461.2">Transitions can be adjusted to control the duration as well as utilize curves to further refine the blend weighting between the two states throughout the duration of </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">the transition.</span></span></li>
</ul>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.463.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.464.1">.9</span></em><span class="koboSpan" id="kobo.465.1"> shows a simple state machine with three states and four transitions. </span><span class="koboSpan" id="kobo.465.2">Each transition has a start state and an end state. </span><span class="koboSpan" id="kobo.465.3">Transitions can exist in either direction, as shown in the example, with there being two transitions between </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">State 1</span></strong><span class="koboSpan" id="kobo.467.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">State 3</span></strong><span class="koboSpan" id="kobo.469.1">, one from </span><strong class="bold"><span class="koboSpan" id="kobo.470.1">State 3</span></strong><span class="koboSpan" id="kobo.471.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">State 1</span></strong><span class="koboSpan" id="kobo.473.1">, and another from </span><strong class="bold"><span class="koboSpan" id="kobo.474.1">State 1</span></strong><span class="koboSpan" id="kobo.475.1"> to </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.476.1">State 3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer149">
<span class="koboSpan" id="kobo.478.1"><img alt="Figure 8.9 – A state machine with three states and four transitions" src="image/Figure_08.09_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.479.1">Figure 8.9 – A state machine with three states and four transitions</span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.480.1">Exploring animation state machines</span></h2>
<p><span class="koboSpan" id="kobo.481.1">A simple character </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.482.1">animation state machine might look like the example provided in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.483.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.484.1">.10</span></em><span class="koboSpan" id="kobo.485.1">. </span><span class="koboSpan" id="kobo.485.2">This shows a character animation state machine that can </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.486.1">stand still (idle), move (denoted by the run state), and jump (which uses </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">three states).</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">A good example to understand the use of transitions is the setup of a three-part jump </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">animation system:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.490.1">The transition from </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">Idle</span></strong><span class="koboSpan" id="kobo.492.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.493.1">Run</span></strong><span class="koboSpan" id="kobo.494.1"> into </span><strong class="bold"><span class="koboSpan" id="kobo.495.1">JumpStart</span></strong><span class="koboSpan" id="kobo.496.1"> is controlled by the player input (when the </span><strong class="bold"><span class="koboSpan" id="kobo.497.1">Jump</span></strong><span class="koboSpan" id="kobo.498.1"> button is pressed) or, more commonly, with physics (when the character is in </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the air)</span></span></li>
<li><span class="koboSpan" id="kobo.500.1">The second transition into </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">JumpLoop</span></strong><span class="koboSpan" id="kobo.502.1"> occurs when the </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">JumpStart</span></strong><span class="koboSpan" id="kobo.504.1"> animation is near completion, either controlled via logic within the transition or using the automatic option, which starts the transition purely based on the duration of </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">the transition</span></span></li>
<li><span class="koboSpan" id="kobo.506.1">The third transition to </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">JumpEnd</span></strong><span class="koboSpan" id="kobo.508.1"> (typically a landing animation) occurs when the character actor returns to contact with the floor – that is, when the character is </span><em class="italic"><span class="koboSpan" id="kobo.509.1">NOT</span></em><span class="koboSpan" id="kobo.510.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">the air</span></span></li>
<li><span class="koboSpan" id="kobo.512.1">The final transitions, back to </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">Idle</span></strong><span class="koboSpan" id="kobo.514.1"> or back to </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">Run</span></strong><span class="koboSpan" id="kobo.516.1">, are, then, similar to the second transition, based on the remaining time of the landing animation in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.517.1">JumpEnd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.518.1"> state:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer150">
<span class="koboSpan" id="kobo.519.1"><img alt="Figure 8.10 – An animation state machine for a character" src="image/Figure_08.10_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.520.1">Figure 8.10 – An animation state machine for a character</span></p>
<p><span class="koboSpan" id="kobo.521.1">A single state can </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.522.1">be connected to any number of other states via the</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.523.1"> use of lots of transitions in a one-to-many relationship; however, a state machine can be refined with the use of a conduit node that allows for a one-to-many, many-to-one, or many-to-many relationship within a single node. </span><span class="koboSpan" id="kobo.523.2">Conduits contain no state information (such as an animation); they simply act, as their name suggests, as a conduit between states, simplifying the need for an excessive number of transition lines between states to achieve the same many-to-many relationship, as </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">illustrated here:</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<span class="koboSpan" id="kobo.525.1"><img alt="Figure 8.11 – A more complex state machine including a conduit node" src="image/Figure_08.11_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.526.1">Figure 8.11 – A more complex state machine including a conduit node</span></p>
<p><span class="koboSpan" id="kobo.527.1">The</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.528.1"> system shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.529.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.530.1">.11</span></em><span class="koboSpan" id="kobo.531.1"> includes a system to select different </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.532.1">jumping and landing animations for when the character is standing still (idle) or when it is moving. </span><span class="koboSpan" id="kobo.532.2">A conduit is used to decide which of the two landing animations should </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">be selected:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.534.1">The transition out of </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">JumpLoop</span></strong><span class="koboSpan" id="kobo.536.1"> into the landing conduit remains the same as the previous system, based on when the character is no longer in </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">the air</span></span></li>
<li><span class="koboSpan" id="kobo.538.1">The transitions out of the conduit into </span><strong class="bold"><span class="koboSpan" id="kobo.539.1">StaticLanding</span></strong><span class="koboSpan" id="kobo.540.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.541.1">RunningLanding</span></strong><span class="koboSpan" id="kobo.542.1"> are based on the velocity of the character where if the velocity is </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">0</span></strong><span class="koboSpan" id="kobo.544.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.545.1">StaticLanding</span></strong><span class="koboSpan" id="kobo.546.1"> state will be selected, and if the velocity is greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">0</span></strong><span class="koboSpan" id="kobo.548.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">RunningLanding</span></strong><span class="koboSpan" id="kobo.550.1"> state will </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">be selected</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.552.1">While this, at this point, doesn’t offer much more efficiency for the number of transitions, it does allow the separation of checks and simplifies the logic used to identify which transition to use. </span><span class="koboSpan" id="kobo.552.2">This makes the system much easier to expand, for example, by adding a different landing if the character has fallen a larger distance or if the character is </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">traveling backward.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">Animation state machines</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.555.1"> can become very complex and even include state machines within state machines, where a state utilizes its own state machine to determine its own output. </span><span class="koboSpan" id="kobo.555.2">The complexity of the system depends upon the required solution and how many different animations need to </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">be considered.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">We can create many styles of</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.558.1"> state machines that make them useful for different</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.559.1"> purposes. </span><span class="koboSpan" id="kobo.559.2">We’ll be starting the journey by looking at the simplest form: an enum/switch implementation where the state is determined by a </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">simple variable.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.561.1">Enum/switch implementation</span></h2>
<p><span class="koboSpan" id="kobo.562.1">If all you need to do is separate</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.563.1"> mutually exclusive logic, then an enum-style state machine is all you require. </span><span class="koboSpan" id="kobo.563.2">Creating an enum with a value for each state is the start. </span><span class="koboSpan" id="kobo.563.3">Unreal requires enum definitions to have specific tags to be usable in Blueprint, where you may want to visualize things to make debugging easier. </span><span class="koboSpan" id="kobo.563.4">The important thing is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">UENUM()</span></strong><span class="koboSpan" id="kobo.565.1"> block. </span><span class="koboSpan" id="kobo.565.2">In the following code snippet, we can see that it includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">BlueprintableType</span></strong><span class="koboSpan" id="kobo.567.1"> property. </span><span class="koboSpan" id="kobo.567.2">This allows the editor layer to both serialize C++ variables of this type into details panels and also create Blueprint-level variables of this type. </span><span class="koboSpan" id="kobo.567.3">The enum is also defined as a class inheriting from an unsigned integer. </span><span class="koboSpan" id="kobo.567.4">This is different from standard C++ where an enum is its own type. </span><span class="koboSpan" id="kobo.567.5">Unreal naming convention would have you prefix your enum type name with </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">E</span></strong><span class="koboSpan" id="kobo.569.1">, but this is not a requirement for it to function. </span><span class="koboSpan" id="kobo.569.2">You will have to decide what size unsigned integer to inherit from. </span><span class="koboSpan" id="kobo.569.3">Here, we have shown a </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">uint8</span></strong><span class="koboSpan" id="kobo.571.1"> type, which would give you 8 bits of size, meaning that you can either have 256 values as standard or 8 values if using the enum to pack Boolean values as flags. </span><span class="koboSpan" id="kobo.571.2">In most cases, </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">uint8</span></strong><span class="koboSpan" id="kobo.573.1"> will provide the necessary space. </span><span class="koboSpan" id="kobo.573.2">Each value also has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">UMETA()</span></strong><span class="koboSpan" id="kobo.575.1"> block that gives the flexibility of a different display name in </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">the editor:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.577.1">UENUM example definition</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
UENUM(BlueprintType)
enum class EState : uint8
{
    State1    UMETA(DisplayName = "First State"),
    State2    UMETA(DisplayName = "Second State"),
    State3    UMETA(DisplayName = "Third State"),
};</span></pre> <p><span class="koboSpan" id="kobo.579.1">Making an enum variable to track our current state allows us to segregate our logic into different case blocks of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">switch</span></strong><span class="koboSpan" id="kobo.581.1"> statement. </span><span class="koboSpan" id="kobo.581.2">While an integer variable could be used for this same job, the enum only has a small additional cost and makes our code more human-readable. </span><span class="koboSpan" id="kobo.581.3">Anywhere we need to execute different logic based on the state, we can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">switch</span></strong><span class="koboSpan" id="kobo.583.1"> case, as in the following example. </span><span class="koboSpan" id="kobo.583.2">This is in place of many Boolean variables combined in </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.584.1">complex amounts of </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">if</span></strong><span class="koboSpan" id="kobo.586.1"> statements, instead setting it out </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.588.1">Example state machine switch statement</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
Estate _State;
void SomeFunction()
// some code…
switch(_State)
{
case Estate::State1:
    //State1 code
    break;
case Estate::State2:
    //State2 code
    break;
case Estate::State3:
    //State3 code
    break;
default:
    //unhandled state code
    break;
}</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.590.1">Helpful tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.591.1">Save yourself time by leveraging your IDE’s code autocomplete functionality to create the template </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">switch</span></strong><span class="koboSpan" id="kobo.593.1"> statement followed by all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">case</span></strong><span class="koboSpan" id="kobo.595.1"> statements with a few keyboard presses. </span><span class="koboSpan" id="kobo.595.2">In Visual Studio, this requires autocompleting the statement. </span><span class="koboSpan" id="kobo.595.3">Without clicking away, press </span><em class="italic"><span class="koboSpan" id="kobo.596.1">Enter</span></em><span class="koboSpan" id="kobo.597.1"> twice after adding the variable to the expression brackets; this should engage the autocomplete and paste in the template structure. </span><span class="koboSpan" id="kobo.597.2">Rider uses the </span><em class="italic"><span class="koboSpan" id="kobo.598.1">Alt</span></em><span class="koboSpan" id="kobo.599.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.600.1">Enter</span></em><span class="koboSpan" id="kobo.601.1"> autocomplete tool to </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">do this.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">enum</span></strong><span class="koboSpan" id="kobo.605.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">switch</span></strong><span class="koboSpan" id="kobo.607.1"> method </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.608.1">works when all you need to segregate is logic. </span><span class="koboSpan" id="kobo.608.2">As soon as variables that only have use in some states get involved, we can enforce the </span><strong class="bold"><span class="koboSpan" id="kobo.609.1">single responsibility principle</span></strong><span class="koboSpan" id="kobo.610.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.611.1">SRP</span></strong><span class="koboSpan" id="kobo.612.1">) from </span><a href="B18297_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.613.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.614.1"> and bundle the full state, variables, and logic into a class. </span><span class="koboSpan" id="kobo.614.2">This helps with readability and expansion once our </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.615.1">state machine starts to grow. </span><span class="koboSpan" id="kobo.615.2">These new states are called </span><em class="italic"><span class="koboSpan" id="kobo.616.1">stateful</span></em><span class="koboSpan" id="kobo.617.1"> states because they have some essence of memory attached to them, as opposed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">enum/switch</span></strong><span class="koboSpan" id="kobo.619.1"> method, where states are pure logic and </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">therefore stateless.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.621.1">Static versus instanced states</span></h2>
<p><span class="koboSpan" id="kobo.622.1">When</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.623.1"> using stateful states, there is a decision to make. </span><span class="koboSpan" id="kobo.623.2">We can</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.624.1"> define our states as either static or instanced. </span><span class="koboSpan" id="kobo.624.2">Static states only exist once in stack memory, helping with overall memory size if multiple machines have reference to the logic. </span><span class="koboSpan" id="kobo.624.3">This can be especially helpful for AI state machines being used by large numbers of actors. </span><span class="koboSpan" id="kobo.624.4">Instanced states must be created and likely exist in heap memory. </span><span class="koboSpan" id="kobo.624.5">Instanced states are necessary when the state of a state – that is to say, the current value of the variables it holds – matters to the actor running the state machine. </span><span class="koboSpan" id="kobo.624.6">Something such as a heavy attack charge level cares about which state machine it is running on and therefore must be in an instanced state; otherwise, all state machines running that state will share a </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">charge level.</span></span></p>
<p><span class="koboSpan" id="kobo.626.1">To implement </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.627.1">states as separate classes, there must be a parent </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.628.1">state class that has the basic functionality of a state. </span><span class="koboSpan" id="kobo.628.2">The following code shows instanced states, but a static state would be largely the same with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">static</span></strong><span class="koboSpan" id="kobo.630.1"> keyword. </span><span class="koboSpan" id="kobo.630.2">In this example, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">Update()</span></strong><span class="koboSpan" id="kobo.632.1"> function to return an </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">EState</span></strong><span class="koboSpan" id="kobo.634.1"> value that will inform the machine running this state when to change state and which one to change to. </span><span class="koboSpan" id="kobo.634.2">It also has other benefits of using separate classes for states, enter, and exit logic. </span><span class="koboSpan" id="kobo.634.3">Usage of this can vary wildly, but it gives gameplay programmers a hook for the moment a state starts and finishes to run extra logic. </span><span class="koboSpan" id="kobo.634.4">Lastly, marking all the functions as purely virtual will make the class abstract in nature and ensure all child states have these functions implemented in </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">some capacity:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.636.1">Example state base class header</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.637.1">
class State
{
public:
    virtual EState Update() = 0;
    virtual void Enter() = 0;
    virtual void Exit() = 0;
}</span></pre> <p><span class="koboSpan" id="kobo.638.1">The actual machine is very simple; it consists of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">State</span></strong><span class="koboSpan" id="kobo.640.1"> variable to hold the current state being run and some kind of collection for the rest of the states to be created into and held in. </span><span class="koboSpan" id="kobo.640.2">This is where a static implementation may differ; states are still held as references, but they don’t need to be instantiated. </span><span class="koboSpan" id="kobo.640.3">Setup the header for the instanced state machine as </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">shown below:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.642.1">Instanced state machine implementation header</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.643.1">
class SomeClass
{
public:
    SomeClass();
    void Update();
private:
    State* _State;
    EState _CurrentState;
    Map&lt;Estate, State*&gt; _StateLibrary;
    void ChangeState(EState nextState);
};</span></pre> <p><span class="koboSpan" id="kobo.644.1">This </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.645.1">code makes use of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">Map&lt;&gt;</span></strong><span class="koboSpan" id="kobo.647.1"> collection. </span><span class="koboSpan" id="kobo.647.2">This </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.648.1">doesn’t strictly exist in base C++ but it is analogous to Unreal’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">TMap&lt;&gt; </span></strong><span class="koboSpan" id="kobo.650.1">collection, which stores key-value pairs and indexes by key. </span><span class="koboSpan" id="kobo.650.2">The body therefore can be setup </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.652.1">Instanced state machine implementation body</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.653.1">
SomeClass::SomeClass()
{
    State* tempState = new ExampleState();
    _StateLibrary.Add(EState::example, tempState);
    tempState = new OtherState();
    _StateLibrary.Add(EState::other, tempState);
    // Do this for each state the state machine requires
    _CurrentState = EState::example;
    _State = _StateLibrary[_CurrentState];
    _State-&gt;Enter();
}
void SomeClass::Update()
{
    EState next = _State.Update();
    if (next != _CurrentState)
    {
        ChangeState(next);
    }
}
void SomeClass::ChangeState(EState nextState)
{
    _State-&gt;Exit();
    _CurrentState = nextState;
    _State = _StateLibrary[_CurrentState];
    _State-&gt;Enter();
}</span></pre> <p><span class="koboSpan" id="kobo.654.1">In Unreal, making </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.655.1">objects of base C++ classes can make your code faster</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.656.1"> as you are ignoring all the overhead of Unreal’s Editor layer, but if you want to make an instanced state machine that can be balanced by designers, it is a good idea to create your states as Actor components. </span><span class="koboSpan" id="kobo.656.2">That way, you could build the entire system to work through the editor using custom </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">slate tools.</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">The next bottleneck in the system comes into play when multiple unconnected factors influence different parts of the behavior. </span><span class="koboSpan" id="kobo.658.2">This could mean the state machine is governing locomotion and world interaction. </span><span class="koboSpan" id="kobo.658.3">With the current system, a new state would be needed for each combination of possibilities, such as a running heavy attack and a crouched heavy attack. </span><span class="koboSpan" id="kobo.658.4">The heavy attack logic is likely to be duplicated between these states, which should be setting off alarm bells. </span><span class="koboSpan" id="kobo.658.5">There is a solution in concurrent </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">state machines.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.660.1">Concurrent state machines</span></h2>
<p><span class="koboSpan" id="kobo.661.1">The term </span><em class="italic"><span class="koboSpan" id="kobo.662.1">concurrent</span></em><span class="koboSpan" id="kobo.663.1"> simply means to be</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.664.1"> running at the same time as</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.665.1"> something else. </span><span class="koboSpan" id="kobo.665.2">It is a term thrown about a lot in the networking sphere, but here, it means something far simpler. </span><span class="koboSpan" id="kobo.665.3">When there are two or more areas of control that never cross, we can create a state machine for each area and run them at the same time. </span><span class="koboSpan" id="kobo.665.4">Expanding our implementation from the preceding section, the following code shows that each state machine exists and updates side by side. </span><span class="koboSpan" id="kobo.665.5">The rest of the setup will also need to be doubled. </span><span class="koboSpan" id="kobo.665.6">Only minor changes are needed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">ChangeState()</span></strong><span class="koboSpan" id="kobo.667.1"> function to accommodate the upgrade, making it machine-agnostic. </span><span class="koboSpan" id="kobo.667.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">State*&amp;</span></strong><span class="koboSpan" id="kobo.669.1"> argument here is used to pass the pointer by reference instead of the value being pointed to, as it is</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.670.1"> the pointer we need to retarget. </span><span class="koboSpan" id="kobo.670.2">This can be </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">seen below.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.672.1">Concurrent state machine implementation</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.673.1">
void SomeClass::Update()
{
    EMoveState nextMove = _StateMove.Update();
    EAttackState nextAttack = _StateAttack.Update();
    if (nextMove != _MoveStateTracker)
    {
        ChangeState(nextMove, _MoveStateTracker, _MoveState);
    }
    if (nextAttack != _AttackStateTracker)
    {
        ChangeState(nextAttack, _AttackStateTracker, _AttackState);
    }
}
void SomeClass::ChangeState(EState nextState,     EState&amp; stateTracker, State*&amp; stateMachine)
{
    stateMachine-&gt;Exit();
    stateTracker = nextState;
    stateMachine = _StateLibrary[stateTracker];
    stateMachine-&gt;Enter();
}</span></pre> <p><span class="koboSpan" id="kobo.674.1">The next</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.675.1"> area for improvement will be noticed most in state machines</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.676.1"> that govern variant behavior where multiple states might share some base functionality but differ slightly. </span><span class="koboSpan" id="kobo.676.2">An example of this could be that a crouching state has different state transitions from a running state but the logic for executing movement is the same. </span><span class="koboSpan" id="kobo.676.3">In this case, we can take advantage of the fact that all states inherit from a parent and add some more layers with a hierarchical </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">state machine.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.678.1">Hierarchical state machines</span></h2>
<p><span class="koboSpan" id="kobo.679.1">As the name suggests, the state </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.680.1">inheritance tree being pulled into a larger</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.681.1"> inheritance hierarchy with base behavior for groups of states creates a hierarchical state machine. </span><span class="koboSpan" id="kobo.681.2">Everything within this actually functions exactly the same as the base state machine; you just need to make sure that the implementations of each function call the base version. </span><span class="koboSpan" id="kobo.681.3">This is more of a code architecture principle to reduce memory footprint and speed up development. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.682.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.683.1">.12</span></em><span class="koboSpan" id="kobo.684.1"> shows an example state inheritance tree for character locomotion and how we can use the grounded mid-level state to create several other states that implement grounded movement logic without needing to write it out a bunch of times. </span><span class="koboSpan" id="kobo.684.2">This improves maintainability as well since we are </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">centralizing behavior:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer152">
<span class="koboSpan" id="kobo.686.1"><img alt="Figure 8.12 – UML diagram showing an example inheritance structure for a set of hierarchical states" src="image/Figure_08.12_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.687.1">Figure 8.12 – UML diagram showing an example inheritance structure for a set of hierarchical states</span></p>
<p><span class="koboSpan" id="kobo.688.1">The final</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.689.1"> step is not to do with the execution logic but the transitions. </span><span class="koboSpan" id="kobo.689.2">As</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.690.1"> it currently stands, each state transition must know which state it’s heading to. </span><span class="koboSpan" id="kobo.690.2">This can work for simple state machines, but as soon as you have an interrupt action that can be accessed from anywhere and must return execution to where it came from when finished, we have a problem. </span><span class="koboSpan" id="kobo.690.3">Storing the information on where the state was entered from doesn’t really solve the problem, because what if the state we were in had a state that must be preserved? </span><span class="koboSpan" id="kobo.690.4">The answer is the very fancy pushdown automata level of a </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">state machine.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.692.1">Pushdown automata</span></h2>
<p><span class="koboSpan" id="kobo.693.1">As just mentioned, pushdown automata </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.694.1">aim to provide a way to enter states with</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.695.1"> a breadcrumb trail to follow back out if the need arises. </span><span class="koboSpan" id="kobo.695.2">We achieve this by storing the current path of states in a stack. </span><span class="koboSpan" id="kobo.695.3">The only code change here is that the tracker and state pointer variables get merged into a struct and stored in a single state stack instead. </span><span class="koboSpan" id="kobo.695.4">Execution is simply run the same way on whichever state happens to be on </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">the top.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">This allows us to </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.698.1">push interrupt states from anywhere in the machine, then pop that state off and continue from where we were – another simple idea that provides a lot of utility. </span><span class="koboSpan" id="kobo.698.2">Prime example usage would be a state machine that governs animations on a character that can move and attack. </span><span class="koboSpan" id="kobo.698.3">Attacks take over the animation solver until they are finished. </span><span class="koboSpan" id="kobo.698.4">The character should then return to whichever state they were in, be that </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.699.1">crouched or standing idle. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.700.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.701.1">.13</span></em><span class="koboSpan" id="kobo.702.1"> shows how the stack changes as the </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">interaction progresses:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer153">
<span class="koboSpan" id="kobo.704.1"><img alt="Figure 8.13 – Storyboard of a pushdown automata state stack over the course of an attack input" src="image/Figure_08.13_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.705.1">Figure 8.13 – Storyboard of a pushdown automata state stack over the course of an attack input</span></p>
<p><span class="koboSpan" id="kobo.706.1">The state machine, as we have covered, has many forms. </span><span class="koboSpan" id="kobo.706.2">The real silver bullet with this pattern is realizing that none of these forms is mutually exclusive. </span><span class="koboSpan" id="kobo.706.3">You can make a hierarchical pushdown automata state machine that runs concurrently with another. </span><span class="koboSpan" id="kobo.706.4">The flip side of that is noticing that if you are using a fully featured hierarchical pushdown automata state machine in earnest, there is probably a simpler pattern that solves the same problem in a much more </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">elegant way.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.708.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.709.1">Altogether, we have covered three patterns that you can build into any future project: the Singleton pattern, which makes sure there is – and only ever will be – one instance of an object that exists, the Command pattern, which provides the utility of separation between the request for an action and that action happening, and finally, the State pattern, which separates our mutually </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">exclusive logic.</span></span></p>
<p><span class="koboSpan" id="kobo.711.1">At this point, you should understand that Singleton does work in some cases, but it has its drawbacks. </span><span class="koboSpan" id="kobo.711.2">The Command pattern can be used for so many different things that you should probably make a version of it as a template library for use in all future projects, and the State pattern has so many layers that it can ruin its own usefulness </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">with depth.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">The next chapter will explore some behavioral patterns that solidify the behavior of a class in different ways to improve the expandability of our systems – namely, the type object pattern, which we would posit as the most useful pattern in game development for </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">content creation.</span></span></p>
</div>
</body></html>