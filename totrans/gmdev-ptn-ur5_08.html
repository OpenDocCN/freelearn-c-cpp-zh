<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-102"><a id="_idTextAnchor113"/>8</h1>
<h1 id="_idParaDest-103"><a id="_idTextAnchor114"/>Building Design Patterns – Singleton, Command, and State</h1>
<p>Whereas the previous chapter looked at a methodology of code architecture design, this chapter will look at three design patterns you can build yourself that have applications across many game genres.</p>
<p>The patterns being covered are as follows:</p>
<ul>
<li>Singleton pattern – understanding why it’s a Pandora’s box that often gets overused</li>
<li>Command pattern – how it has many uses beyond the obvious</li>
<li>The many levels of state machine traveling down the rabbit hole and seeing how far we can push its concept</li>
</ul>
<p>The aim of this will be to make some base classes that can be imported into any future project to speed up development. By the end of the chapter, you should understand why so many online resources overuse the Singleton pattern, what a hidden gem the Command pattern is, and how deep customization can go with the humble state machine.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor115"/>Technical requirements</h1>
<p>This chapter will be building on the <code>chapter8</code> branch on GitHub, which can be downloaded from <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter08">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter08</a></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor116"/>Implementing a Singleton pattern – understanding why it’s a Pandora’s box</h1>
<p>The official point of the <a id="_idIndexMarker304"/>Singleton pattern is to ensure there is only one instance of a class in existence at any one time, hence the name “single”-ton. Unfortunately, this often gets packaged and confused with a public static variable to this one existing object. The actual idea of only having one object instance of a class makes sense. You might have a manager that needs to exist in every level, but if you don’t know the path the player took to get to this level, then you have no idea if one has been spawned yet. The solution is to make the manager a Singleton class and have a copy at every level. We can do this with the following code, using a static variable pointing to the one that exists:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Example Singleton.h excerpt</p>
<pre class="source-code">
UCLASS()
public Singleton : public AActor
{
    static TObjectPtr&lt;Singleton&gt; _instance;
public:
    void Init();
}</pre> <p>We then have a choice on whether we delete the new one if it is a second or if it should assume the position of the instance, deleting what was previously there . The body file therefore would be:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Example Singleton.cpp excerpt</p>
<pre class="source-code">
void Singleton::Init()
{
    if (_instance == nullptr)
    {
        _instance = this;
    }
    else
    {
        this-&gt;Destroy();
    }
}</pre> <p>There is an<a id="_idIndexMarker305"/> innate question arising from this. Internally, our monologue could sound like: “If only one instance of this class will ever exist, then why does it need to be instanced in the first place? Surely, making the entire class static has the same effect and will take up less memory with the functions and variables only existing on the stack, negating the need for a Singleton pattern.” You could answer that with a situation. Perhaps there is a need to replace the object in the instance slot with every new level. That is one argument for a Singleton pattern, but the usage is limited and can usually be designed around using the pattern we discussed at great length in <a href="B18297_07.xhtml#_idTextAnchor090"><em class="italic">Chapter 7</em></a>.</p>
<p>The other issue is that most implementations of the Singleton pattern use a public static variable for tracking the instance. This has led many people to think the purpose of this pattern is for an easy communication link between a top-level system and any object that needs it. Doing this potentially couples every class with the Singleton pattern, which we have established in previous chapters is a thing to be avoided. The effect can be seen clearly in <em class="italic">Figure 8</em><em class="italic">.1</em>, where every class aggregates the <strong class="bold">Singleton</strong> class into its memory footprint because it has one or more references within:</p>
<div><div><img alt="Figure 8.1 – UML﻿ diagram of a Singleton pattern being aggregated into lots of classes" src="img/Figure_08.01_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – UML diagram of a Singleton pattern being aggregated into lots of classes</p>
<p>The correct<a id="_idIndexMarker306"/> usage is a private static variable used to track the instance, as shown at the start of this section. Then, with the instance created by a manager, it fits into the hierarchical class tree shown in <a href="B18297_07.xhtml#_idTextAnchor090"><em class="italic">Chapter 7</em></a>. This manager can then distribute the direct reference to any classes under it via the initialization chain. This is what we know <a id="_idIndexMarker307"/>as <strong class="bold">dependency injection</strong>. This does still create coupling, but the spread is much more controlled. An example custom initializer function for a unit in a grid-based game could have the dependency of the grid injected into it instead of making the grid a Singleton pattern that anything can access. Next, you can see an example of how this could be constructed and how little this method impacts the flow of the code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Dependency injection example</p>
<pre class="source-code">
void AUnit::Init(AGrid* grid)
{
    _GridRef = grid;
}
void AUnit::Move(FVector2 targetCoords)
{
    Path p = GridRef-&gt;GetPath(_CurrentCoords,
        targetCoords))
    if(p != nullptr)
{
        //Move the Unit
    }
}</pre> <p>Overall, the actual concept and code for the Singleton pattern <a id="_idTextAnchor117"/>is relatively simple; the problem lies in how it is used. Even with the cleaner implementation, most – if not all – cases where a Singleton pattern has been used can be replaced with a different pattern to make the code easier to expand. Aggregation may mean that this functionality can become a component, or there may need to be a shift in the structure to something more like a subclass sandbox pattern (to be discussed later, in <a href="B18297_09.xhtml#_idTextAnchor130"><em class="italic">Chapter 9</em></a>) where the functionality is statically defined in a parent. Dependency injection takes most of the replacement duty, as the common use for a<a id="_idIndexMarker308"/> Singleton pattern will be a global utility class such as a <strong class="bold">Fog of War</strong> manager on a tiled grid. This is better sent through the initialization chain as a dependency injection so that other clas<a id="_idTextAnchor118"/>ses don’t also have access allowing other developers to incorrectly use the <a id="_idIndexMarker309"/>functionality.</p>
<p>Now that the temptation of the Singleton pattern has been expunged from our minds, we can move on to patterns that are useful in multiple scenarios, such as the Command pattern.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor119"/>Implementing the Command pattern for different use cases</h1>
<p>The <a id="_idIndexMarker310"/>Command pattern adds a layer of separation between the request for an action and that action being carried out. The implementation looks like what is shown in <em class="italic">Figure 8</em><em class="italic">.2</em>, where the <code>Command</code> class parent is abstract and only has a constructor, <code>execute()</code>, and <code>undo()</code> functions that all take no arguments. The idea is that the child classes are more specific and contain all the object references needed to execute properly:</p>
<div><div><img alt="Figure 8.2 – UML diagram showing the structure of a Command pattern base class" src="img/Figure_08.02_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – UML diagram showing the structure of a Command pattern base class</p>
<p>The purpose of a command is to reify the abstract idea of an action so that we can store it in a list. This list can have many uses, but the most identified is the undo queue that Microsoft made synonymous with its keyboard shortcut, <em class="italic">Ctrl</em> + <em class="italic">Z</em>. When an action is performed, a Command object of the relevant type is created and added to the list. The command is executed and left in this list until it falls off the back; this keeps the list in chronological order. If the user presses the undo key, then the last command in the list has its undo function called, and a pointer for the most recent command moves back one. This is shown in <em class="italic">Figure 8</em><em class="italic">.3,</em> where you can see that creating a new command after some have been undone chops the undone commands off and inserts the new command as the head of the list:</p>
<div><div><img alt="Figure 8.3 – Diagram showing the process of adding, undoing, and branching commands" src="img/Figure_08.03_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Diagram showing the process of adding, undoing, and branching commands</p>
<p>In games, we<a id="_idIndexMarker311"/> can use this functionality for a plethora of different scenarios. The most common are strategy games, where the player can queue up actions for their units to be executed in a certain order, each only executing after the last has finished. Surprisingly few strategy games make use of the Command pattern’s undo capabilities, but that may be because it would reduce the cost of actions. Undo is making more of an appearance in modern games in the form of a rewind mechanic; exploited in classics such as <em class="italic">Braid</em> and incorporated as a feature into AAA games such as the <em class="italic">Forza Horizon</em> series. This real-time application has varying methods of execution; it is likely that <em class="italic">Braid</em> simply records all moving objects’ positions on a timer as there is so little going on in the scene. This approach clearly wouldn’t work for a racing game with complex physics; instead, you could record each time the player’s input changes as a different command. The undo queue then has to run the game backward and understand when commands were added to the list to preserve momentum.</p>
<p>Saving each of the players’ input actions into a list can also work as a sort of replay-saving mechanic. This works for games such as the <em class="italic">Trials</em> series and fighting games such as <em class="italic">Super Smash Bros.</em> because there are no elements of randomness in the mechanics. If you input the same action at the same time, you will have the same result every time. This<a id="_idIndexMarker312"/> could lead to large replay files, with each input axis saving potentially a value every frame. There are potential ways around this, such as only saving the result of these inputs when an action is performed that relies on the state of the driven element. This could mean instead of saving every mouse movement in <em class="italic">World of Tanks</em>, the barrel rotation and time are saved every time a shell is fired and the barrel is hit. This way, all the little motions that add to zero are ignored from the replay file.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor120"/>Command pattern for undo functionality in Blueprint Utilities</h2>
<p>In <a id="_idIndexMarker313"/>Unreal, we can make tools to use in the editor <a id="_idIndexMarker314"/>called <strong class="bold">Blueprint Utilities</strong> (formerly known as Blutilities during early development). Blueprint Utilities can be created as either<a id="_idIndexMarker315"/> right-click menu actions or as Utility Widgets that operate in a floating window or can be docked into the UI and can manipulate assets (the files in the content browser) or actors (elements within the world) to complete repeated actions, to reduce the impact of workflow steps or simply to remove the requirement for user input to reduce opportunities for mistakes.</p>
<p>Editor Utilities can hold any number of tools within them, with each tool being created as its own function, having its own graph or a custom event within the standard Blueprint Event Graph. Actor and Asset Utility Widgets require us to define which class of actor or asset the tools will interact with, known as the <em class="italic">Supported Class</em>, enabling them to be added contextually to the right-click menus.</p>
<p>We are going to explore implementing the Command pattern using transaction nodes in Blueprint to add the ability to undo the process a tool does. To do this, we are going to create a simple tool that rotates the selected objects in the level by 45 degrees.</p>
<p>To begin with, let’s create a Utility Blueprint and define its <em class="italic">Supported Class</em> as <code>Actor</code> (so that we can use the tool on any actor in the world). To do this, follow these steps:</p>
<ol>
<li>Right-click in the content browser and navigate to <strong class="bold">Editor Utilities</strong> | <strong class="bold">Editor</strong> <strong class="bold">Utility Blueprint</strong>.</li>
<li>From the popup, expand the <strong class="bold">All Classes</strong> rollout, select <strong class="bold">ActorActionUtility</strong>, and click the <strong class="bold">Select</strong> button once it becomes available.</li>
<li>Give the new Blueprint an appropriate name such as <code>EU_ActorTransformTools</code>.</li>
<li>Open the Blueprint, then on the left side, hover over the <strong class="bold">Functions</strong> section of the <strong class="bold">My Blueprint</strong> tab. This should reveal the <strong class="bold">Override</strong> dropdown; from this, select <strong class="bold">Get </strong><strong class="bold">Supported Class</strong>.</li>
<li>This should have automatically opened the <strong class="bold">Get Supported Class</strong> function graph. From here, delete the <strong class="bold">Parent: Get Supported Class</strong> node and, using the dropdown on the <strong class="bold">Return Node</strong> node, select <strong class="bold">Actor</strong> as the supported class for any tools built in this Blueprint:</li>
</ol>
<div><div><img alt="Figure 8.4 – The Get Supported Class function, overridden to set Actor as the supported class" src="img/Figure_08.04_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The Get Supported Class function, overridden to set Actor as the supported class</p>
<p>With the <a id="_idIndexMarker316"/>Blueprint set up, we can<a id="_idIndexMarker317"/> now add our tools to it. We can add tools either as functions or custom events, as mentioned earlier in this section. For this example, we will create our tool as a new function to keep the structure of the tools within the Utility Blueprint tidy:</p>
<ol>
<li>With the Utility Blueprint open, click the <code>RotateSelected45</code>.</li>
<li>With the <strong class="bold">RotateSelected45</strong> graph open (which should happen automatically) in the <strong class="bold">Details</strong> panel, set the <strong class="bold">Call in Editor</strong> checkbox to <strong class="bold">On</strong>.</li>
</ol>
<p>With the function set up, let’s test that we’ve enabled the correct things and the function is appearing in the menus when we right-click on something in the viewport, like so:</p>
<ol>
<li>Add some cubes to the level using the <strong class="bold">Quickly Add to the Project</strong> button, navigating to <strong class="bold">Shapes</strong> | <strong class="bold">Cube</strong>, and dragging one into the viewport.</li>
<li>Duplicate the cube a few times by holding <em class="italic">Alt</em> and dragging the cube using the <strong class="bold">Move</strong> tool.</li>
<li>Select all of the cubes and right-click on one of them. You should now be able to navigate to <strong class="bold">Scripted Actor Actions</strong> | <strong class="bold">Rotate </strong><strong class="bold">Selected 45</strong>.</li>
</ol>
<p>At this point, nothing will happen because we have not yet created any logic in the Blueprint function.</p>
<p>Next, we will <a id="_idIndexMarker318"/>set up the functionality<a id="_idIndexMarker319"/> to rotate the actor (not worrying yet about implementing the Command pattern). The process here is to first identify which actors the user has selected, then use a <strong class="bold">For Each Loop</strong> node to rotate the actor in the world. To do this in Blueprint, follow these steps:</p>
<ol>
<li>Drag from the pin on the <code>Get Selected </code><code>Actors</code> node.</li>
<li>Drag from the <code>For Each </code><code>Loop</code> node.</li>
<li>Connect the output pin from the <strong class="bold">Get Selected Actors</strong> node to the <strong class="bold">Exec</strong> pin on the <strong class="bold">For Each </strong><strong class="bold">Loop</strong> node.</li>
<li>Drag from the <code>Add Actor World </code><code>Rotation</code> node.</li>
<li>Set the <code>0</code>, <code>0</code>, and <code>45</code>.</li>
</ol>
<p>Your function should now look this:</p>
<div><div><img alt="Figure 8.5 – The Rotate Selected 45 function without undo functionality" src="img/Figure_08.05_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – The Rotate Selected 45 function without undo functionality</p>
<p>With the functionality set up, test the function again with the same process as before when we tested that the function was appearing. You should now see that the box rotates.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you have <strong class="bold">Realtime</strong> turned off in the viewport, you will not see the box rotate until you move the viewport for it to update.</p>
<p>With the<a id="_idIndexMarker320"/> functionality <a id="_idIndexMarker321"/>now working, we want to add the ability to undo the action by implementing the Command pattern using the<strong class="bold"> Transaction</strong> system. To do this, we need to add three nodes: a <strong class="bold">Begin Transaction</strong> node, to start the process of recording the actions, a <strong class="bold">Transact Object</strong> node, which is used to identify objects that are about to have a property changed, and an <strong class="bold">End Transaction</strong> node, which stops the process of recording actions. Follow these steps:</p>
<ol>
<li>Add a <code>Begin Transaction</code> node at the start of the function, between the <strong class="bold">Rotate Selected 45</strong> node and the <strong class="bold">Get Selected </strong><strong class="bold">Actors</strong> node.</li>
<li>Add a <code>Transact Object</code> node as the first part of the for each loop, between the <strong class="bold">For Each Loop</strong> node and the <strong class="bold">Add Actor World Rotation</strong> node in the <strong class="bold">Loop </strong><strong class="bold">Body</strong> chain.</li>
<li>Drag out from the <code>End Transaction</code> node, completing the function.</li>
</ol>
<p>Your function should now look like this; we’ve added some reroute nodes to the link between the <strong class="bold">For Each Loop</strong> node’s <strong class="bold">Array Element</strong> pin and the <strong class="bold">Target</strong> pin on the <strong class="bold">Add Actor World </strong><strong class="bold">Rotation</strong> node:</p>
<div><div><img alt="Figure 8.6 – The completed Rotate Selected 45 function with Transaction nodes" src="img/Figure_08.06_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – The completed Rotate Selected 45 function with Transaction nodes</p>
<p>With the function now complete, it is time to test it again. Repeat the steps from before, and the box should still rotate.</p>
<p>The <a id="_idIndexMarker322"/>difference now is you <a id="_idIndexMarker323"/>should be able to click <strong class="bold">Edit</strong> in the top toolbar and see that an option for <strong class="bold">Undo Blutility Action</strong> has become available in the <strong class="bold">HISTORY</strong> section. If you select it, you should be able to see that any actors that were rotated by the tool return to their previous state:</p>
<div><div><img alt="Figure 8.7 – Undo Blutility Action in the HISTORY section of the Edit menu" src="img/Figure_08.07_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Undo Blutility Action in the HISTORY section of the Edit menu</p>
<p>You can also see <strong class="bold">Blutility Action</strong> in the <strong class="bold">Transactions</strong> list when you select <strong class="bold">Undo History</strong> from the <strong class="bold">Edit</strong> menu:</p>
<div><div><img alt="Figure 8.8 – The Transactions list in the Undo History window" src="img/Figure_08.08_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – The Transactions list in the Undo History window</p>
<p>With <a id="_idIndexMarker324"/>the <strong class="bold">Blutility Action</strong> appearing <a id="_idIndexMarker325"/>in the undo history and working correctly, the tool is now complete.</p>
<p>When creating tools using Blueprint Utilities, it is considered best practice to always include the ability for the user to undo the effect of the tool, so implementing the Command pattern is key to creating user-friendly solutions.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor121"/>Command pattern for gameplay in C++</h2>
<p>Making our own version of the Command pattern for general <a id="_idIndexMarker326"/>use, let’s establish a class for our base command. Start by making a child of <code>UObject</code> inside your IDE. We are using <code>UObject</code> so that our class is visible to the engine, but it doesn’t need all the extra trappings of <code>AActor</code>, such as a transform. We mark it as <code>Abstract</code> in the <code>UCLASS()</code> macro to make sure no instance will ever be made of this object. This class only needs a virtual execute function as we won’t be supporting undo queueing, and initialization will be dealt with differently from standard C++ implementations due to the way Unreal deals with object spawning, let's set that up.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Command.h</p>
<pre class="source-code">
#pragma once
#include "CoreMinimal.h"
#include "Command.generated.h"
UCLASS(Abstract)
class RTS_AI_API UCommand : public UObject
{
    GENERATED_BODY()
public:
    virtual void Execute();
};</pre> <p>We only need to generate empty function definitions in the body file; there is no need to add any code to the functions as whatever is written there will never run. After creating the base command class, compile everything into the editor layer to make sure there are no errors. With it all compiled, right-click on the <code>Command</code> object in the project drawer and create a child C++ class called something like <code>Command_UnitMove</code>. This will be the first command linked with our framework. The definition and body are shown next and are simple. The <code>Init</code> function is made so that we can set up local variables for the command to execute with, and the <code>Execute</code> function is overridden to <a id="_idIndexMarker327"/>actually use those values by calling the interfaced function on the reference object. Setup the header file as shown below:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Command_UnitMove.h</p>
<pre class="source-code">
UCLASS()
class RTS_AI_API UCommand_UnitMove : public UCommand
{
    GENERATED_BODY()
public:
    void Init(AActor* unit, FVector moveLocation);
    virtual void Execute() override;
private:
    TObjectPtr&lt;AActor&gt; _unit;
    FVector _moveLocation;
};</pre> <p>As you can see next, the <code>Init</code> function actually has no innards. Instead, we use C++ standard constructor overloading syntax to pass the arguments up to the constructors of the internal objects. This is not necessary as code in the body will still work, but it is considered better practice as it uses slightly less memory, but only fractionally. So, let's add the <code>Init</code> function:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Command_UnitMove.cpp</p>
<pre class="source-code">
void UCommand_UnitMove::Init(AActor* unit,
    FVector moveLocation) : _unit(unit)_moveLocation
        (moveLocation) 
{}
void UCommand_UnitMove::Execute()
{
    Super::Execute();
    IControllableUnit::Execute_SetMoveLocation(_unit,_moveLocation);
}</pre> <p>The next steps would be to augment the system for <a id="_idIndexMarker328"/>consuming input to distinguish when we want to add a command to the queue versus just overwriting what is there. This would be a couple of lines in many different classes, but we have provided the base for you. To inspect what has been made, you can head to the <code>PC_RTS</code> header and body and look at how the input is routed into the pawn via interface calls. The part we are working on next is the character being controlled. There is a function in the <code>AEliteUnit</code> class called <code>QueueMoveLocation_Implementation</code>, which is currently empty. As it stands, our player can right-click anywhere while holding left <em class="italic">shift</em> for this function to fire. What we would like is for this function to create a new move <code>Command</code> object, initialize it, and store it in a queue. For that, we need a queue, so in the header, add a protected or private <code>TQueue&lt;TObjectPtr&lt;UCommand&gt;&gt;</code> variable, autocompleting the <code>#include</code> instances where necessary, and name it something sensible; we have gone with <code>_commandQueue</code>. The <code>QueueMoveLocation_Implementation</code> function can now check if the character is in the process of moving, and if it is, do exactly what was detailed previously. Create a new command to reify the request, initialize it with values, and add it to the queue:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">QueueMoveLocation_Implementation function</p>
<pre class="source-code">
void AEliteUnit::QueueMoveLocation_Implementation(FVector targetLocation)
{
    if(!_isMoving)
    {
        _AIController-&gt;GetBlackboardComponent()-&gt;
            SetValueAsVector("MoveToLocation", targetLocation);
        _isMoving = true;
        return;
    }
    TobjectPtr&lt;Ucommand_UnitMove&gt; moveCommand =
        NewObject&lt;Ucommand_UnitMove&gt;(this);
    moveCommand-&gt;Init(this, targetLocation);
    _CommandQueue.Enqueue(moveCommand);
}</pre> <p>It is all well and good storing requests to move, but <a id="_idIndexMarker329"/>there needs to be a system for clearing the queue as commands are completed, making use of the <code>Dequeue</code> function. This is where the <code>MoveLocationReached_Implementation</code> callback function comes in. This needs to see if there are any commands, and if there are, remove them from the queue and call their <code>Execute</code> function. This is the reason we made sure the command has all its resources injected on creation: so that the <code>Execute</code> function can remain parameter-less and therefore useful, as set out in the code below.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">MoveLocationReached_Implementation function</p>
<pre class="source-code">
void AEliteUnit::MoveLocationReached_Implementation()
{
    _isMoving = false;
    if(!_CommandQueue.IsEmpty())
    {
        TObjectPtr&lt;UCommand&gt; command;
        _CommandQueue.Dequeue(command);
        command-&gt;Execute();
    }
}</pre> <p>With that, the system is functionally complete. There is, of course, no<a id="_idIndexMarker330"/> feedback to the user about what currently exists in the queue; that would require a lot more in the way of functions to peek values of commands, but if you wanted to expand this to include different types of move commands or actions, then all you’d need to do is make them from the <code>UCommand</code> base, create them somewhere, and add them to the queue.</p>
<p>Our system uses a queue of commands for stacking player commands, but if you wanted an AI to be in control, you could preload it with a set of actions it can perform and let it loose with some form of <strong class="bold">Goal-Oriented Action Planning</strong> (<strong class="bold">GOAP</strong>). GOAP is an AI design method that abstracts individual<a id="_idIndexMarker331"/> interactions with the world from the purpose they fulfill. Stringing these actions together in a chain can create a strategy to achieve a goal. The Command pattern is a great way of implementing this as you can pre-generate a series of commands that make up all the actions an AI can take. Then, the AI strings them together into a queue, as we did previously for the action queue on the controllable unit, to plan its strategy. Executing the commands one by one then hopefully allows the AI to achieve its goal.</p>
<p>By the very nature of making games, there is always some use for the Command pattern, which makes it a good pattern to practice setting as a templated plugin, much as with our next pattern, the state machine, where the Command pattern is used to delay and record logic and the state machine segregates it by use.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor122"/>Creating the many levels of a state machine</h1>
<p>A<a id="_idIndexMarker332"/> state machine allows us to separate behavior based on the idea of a <em class="italic">state</em> – a simple concept, but it has wide-reaching applications from animation state machines to AI logic and contextual player actions.</p>
<p>The simplest of state machines feature two elements: states<a id="_idIndexMarker333"/> and transitions. A state machine, at<a id="_idIndexMarker334"/> any moment, will either be in a single state or transitioning between two different states, which is why they are a significant part of animation systems, where blending improves the visual quality and feel of characters when receiving input from the player. Let’s look at this in more detail:</p>
<ul>
<li>A state<a id="_idIndexMarker335"/> defines a specific output and/or value of variables. In an animation state machine, the state defines which animation asset should be playing.</li>
<li>A transition<a id="_idIndexMarker336"/> contains the logic that defines when a state machine can transition between two states. Transitions can be adjusted to control the duration as well as utilize curves to further refine the blend weighting between the two states throughout the duration of the transition.</li>
</ul>
<p><em class="italic">Figure 8</em><em class="italic">.9</em> shows a simple state machine with three states and four transitions. Each transition has a start state and an end state. Transitions can exist in either direction, as shown in the example, with there being two transitions between <strong class="bold">State 1</strong> and <strong class="bold">State 3</strong>, one from <strong class="bold">State 3</strong> to <strong class="bold">State 1</strong>, and another from <strong class="bold">State 1</strong> to <strong class="bold">State 3</strong>:</p>
<div><div><img alt="Figure 8.9 – A state machine with three states and four transitions" src="img/Figure_08.09_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – A state machine with three states and four transitions</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor123"/>Exploring animation state machines</h2>
<p>A simple character <a id="_idIndexMarker337"/>animation state machine might look like the example provided in <em class="italic">Figure 8</em><em class="italic">.10</em>. This shows a character animation state machine that can <a id="_idIndexMarker338"/>stand still (idle), move (denoted by the run state), and jump (which uses three states).</p>
<p>A good example to understand the use of transitions is the setup of a three-part jump animation system:</p>
<ul>
<li>The transition from <strong class="bold">Idle</strong> or <strong class="bold">Run</strong> into <strong class="bold">JumpStart</strong> is controlled by the player input (when the <strong class="bold">Jump</strong> button is pressed) or, more commonly, with physics (when the character is in the air)</li>
<li>The second transition into <strong class="bold">JumpLoop</strong> occurs when the <strong class="bold">JumpStart</strong> animation is near completion, either controlled via logic within the transition or using the automatic option, which starts the transition purely based on the duration of the transition</li>
<li>The third transition to <strong class="bold">JumpEnd</strong> (typically a landing animation) occurs when the character actor returns to contact with the floor – that is, when the character is <em class="italic">NOT</em> in the air</li>
<li>The final transitions, back to <strong class="bold">Idle</strong> or back to <strong class="bold">Run</strong>, are, then, similar to the second transition, based on the remaining time of the landing animation in the <strong class="bold">JumpEnd</strong> state:</li>
</ul>
<div><div><img alt="Figure 8.10 – An animation state machine for a character" src="img/Figure_08.10_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – An animation state machine for a character</p>
<p>A single state can <a id="_idIndexMarker339"/>be connected to any number of other states via the<a id="_idIndexMarker340"/> use of lots of transitions in a one-to-many relationship; however, a state machine can be refined with the use of a conduit node that allows for a one-to-many, many-to-one, or many-to-many relationship within a single node. Conduits contain no state information (such as an animation); they simply act, as their name suggests, as a conduit between states, simplifying the need for an excessive number of transition lines between states to achieve the same many-to-many relationship, as illustrated here:</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 8.11 – A more complex state machine including a conduit node" src="img/Figure_08.11_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – A more complex state machine including a conduit node</p>
<p>The<a id="_idIndexMarker341"/> system shown in <em class="italic">Figure 8</em><em class="italic">.11</em> includes a system to select different <a id="_idIndexMarker342"/>jumping and landing animations for when the character is standing still (idle) or when it is moving. A conduit is used to decide which of the two landing animations should be selected:</p>
<ul>
<li>The transition out of <strong class="bold">JumpLoop</strong> into the landing conduit remains the same as the previous system, based on when the character is no longer in the air</li>
<li>The transitions out of the conduit into <code>0</code>, the <code>0</code>, the <strong class="bold">RunningLanding</strong> state will be selected</li>
</ul>
<p>While this, at this point, doesn’t offer much more efficiency for the number of transitions, it does allow the separation of checks and simplifies the logic used to identify which transition to use. This makes the system much easier to expand, for example, by adding a different landing if the character has fallen a larger distance or if the character is traveling backward.</p>
<p>Animation state machines<a id="_idIndexMarker343"/> can become very complex and even include state machines within state machines, where a state utilizes its own state machine to determine its own output. The complexity of the system depends upon the required solution and how many different animations need to be considered.</p>
<p>We can create many styles of<a id="_idIndexMarker344"/> state machines that make them useful for different<a id="_idIndexMarker345"/> purposes. We’ll be starting the journey by looking at the simplest form: an enum/switch implementation where the state is determined by a simple variable.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor124"/>Enum/switch implementation</h2>
<p>If all you need to do is separate<a id="_idIndexMarker346"/> mutually exclusive logic, then an enum-style state machine is all you require. Creating an enum with a value for each state is the start. Unreal requires enum definitions to have specific tags to be usable in Blueprint, where you may want to visualize things to make debugging easier. The important thing is the <code>UENUM()</code> block. In the following code snippet, we can see that it includes the <code>BlueprintableType</code> property. This allows the editor layer to both serialize C++ variables of this type into details panels and also create Blueprint-level variables of this type. The enum is also defined as a class inheriting from an unsigned integer. This is different from standard C++ where an enum is its own type. Unreal naming convention would have you prefix your enum type name with <code>E</code>, but this is not a requirement for it to function. You will have to decide what size unsigned integer to inherit from. Here, we have shown a <code>uint8</code> type, which would give you 8 bits of size, meaning that you can either have 256 values as standard or 8 values if using the enum to pack Boolean values as flags. In most cases, <code>uint8</code> will provide the necessary space. Each value also has a <code>UMETA()</code> block that gives the flexibility of a different display name in the editor:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">UENUM example definition</p>
<pre class="source-code">
UENUM(BlueprintType)
enum class EState : uint8
{
    State1    UMETA(DisplayName = "First State"),
    State2    UMETA(DisplayName = "Second State"),
    State3    UMETA(DisplayName = "Third State"),
};</pre> <p>Making an enum variable to track our current state allows us to segregate our logic into different case blocks of a <code>switch</code> statement. While an integer variable could be used for this same job, the enum only has a small additional cost and makes our code more human-readable. Anywhere we need to execute different logic based on the state, we can use a <code>switch</code> case, as in the following example. This is in place of many Boolean variables combined in <a id="_idIndexMarker347"/>complex amounts of <code>if</code> statements, instead setting it out like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Example state machine switch statement</p>
<pre class="source-code">
Estate _State;
void SomeFunction()
// some code…
switch(_State)
{
case Estate::State1:
    //State1 code
    break;
case Estate::State2:
    //State2 code
    break;
case Estate::State3:
    //State3 code
    break;
default:
    //unhandled state code
    break;
}</pre> <p class="callout-heading">Helpful tip</p>
<p class="callout">Save yourself time by leveraging your IDE’s code autocomplete functionality to create the template <code>switch</code> statement followed by all the <code>case</code> statements with a few keyboard presses. In Visual Studio, this requires autocompleting the statement. Without clicking away, press <em class="italic">Enter</em> twice after adding the variable to the expression brackets; this should engage the autocomplete and paste in the template structure. Rider uses the <em class="italic">Alt</em> + <em class="italic">Enter</em> autocomplete tool to do this.</p>
<p>The <code>enum</code>/<code>switch</code> method <a id="_idIndexMarker348"/>works when all you need to segregate is logic. As soon as variables that only have use in some states get involved, we can enforce the <code>enum/switch</code> method, where states are pure logic and therefore stateless.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor125"/>Static versus instanced states</h2>
<p>When<a id="_idIndexMarker350"/> using stateful states, there is a decision to make. We can<a id="_idIndexMarker351"/> define our states as either static or instanced. Static states only exist once in stack memory, helping with overall memory size if multiple machines have reference to the logic. This can be especially helpful for AI state machines being used by large numbers of actors. Instanced states must be created and likely exist in heap memory. Instanced states are necessary when the state of a state – that is to say, the current value of the variables it holds – matters to the actor running the state machine. Something such as a heavy attack charge level cares about which state machine it is running on and therefore must be in an instanced state; otherwise, all state machines running that state will share a charge level.</p>
<p>To implement <a id="_idIndexMarker352"/>states as separate classes, there must be a parent <a id="_idIndexMarker353"/>state class that has the basic functionality of a state. The following code shows instanced states, but a static state would be largely the same with the <code>static</code> keyword. In this example, we are using the <code>Update()</code> function to return an <code>EState</code> value that will inform the machine running this state when to change state and which one to change to. It also has other benefits of using separate classes for states, enter, and exit logic. Usage of this can vary wildly, but it gives gameplay programmers a hook for the moment a state starts and finishes to run extra logic. Lastly, marking all the functions as purely virtual will make the class abstract in nature and ensure all child states have these functions implemented in some capacity:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Example state base class header</p>
<pre class="source-code">
class State
{
public:
    virtual EState Update() = 0;
    virtual void Enter() = 0;
    virtual void Exit() = 0;
}</pre> <p>The actual machine is very simple; it consists of a <code>State</code> variable to hold the current state being run and some kind of collection for the rest of the states to be created into and held in. This is where a static implementation may differ; states are still held as references, but they don’t need to be instantiated. Setup the header for the instanced state machine as shown below:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Instanced state machine implementation header</p>
<pre class="source-code">
class SomeClass
{
public:
    SomeClass();
    void Update();
private:
    State* _State;
    EState _CurrentState;
    Map&lt;Estate, State*&gt; _StateLibrary;
    void ChangeState(EState nextState);
};</pre> <p>This <a id="_idIndexMarker354"/>code makes use of a <code>Map&lt;&gt;</code> collection. This <a id="_idIndexMarker355"/>doesn’t strictly exist in base C++ but it is analogous to Unreal’s <code>TMap&lt;&gt; </code>collection, which stores key-value pairs and indexes by key. The body therefore can be setup like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Instanced state machine implementation body</p>
<pre class="source-code">
SomeClass::SomeClass()
{
    State* tempState = new ExampleState();
    _StateLibrary.Add(EState::example, tempState);
    tempState = new OtherState();
    _StateLibrary.Add(EState::other, tempState);
    // Do this for each state the state machine requires
    _CurrentState = EState::example;
    _State = _StateLibrary[_CurrentState];
    _State-&gt;Enter();
}
void SomeClass::Update()
{
    EState next = _State.Update();
    if (next != _CurrentState)
    {
        ChangeState(next);
    }
}
void SomeClass::ChangeState(EState nextState)
{
    _State-&gt;Exit();
    _CurrentState = nextState;
    _State = _StateLibrary[_CurrentState];
    _State-&gt;Enter();
}</pre> <p>In Unreal, making <a id="_idIndexMarker356"/>objects of base C++ classes can make your code faster<a id="_idIndexMarker357"/> as you are ignoring all the overhead of Unreal’s Editor layer, but if you want to make an instanced state machine that can be balanced by designers, it is a good idea to create your states as Actor components. That way, you could build the entire system to work through the editor using custom slate tools.</p>
<p>The next bottleneck in the system comes into play when multiple unconnected factors influence different parts of the behavior. This could mean the state machine is governing locomotion and world interaction. With the current system, a new state would be needed for each combination of possibilities, such as a running heavy attack and a crouched heavy attack. The heavy attack logic is likely to be duplicated between these states, which should be setting off alarm bells. There is a solution in concurrent state machines.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor126"/>Concurrent state machines</h2>
<p>The term <em class="italic">concurrent</em> simply means to be<a id="_idIndexMarker358"/> running at the same time as<a id="_idIndexMarker359"/> something else. It is a term thrown about a lot in the networking sphere, but here, it means something far simpler. When there are two or more areas of control that never cross, we can create a state machine for each area and run them at the same time. Expanding our implementation from the preceding section, the following code shows that each state machine exists and updates side by side. The rest of the setup will also need to be doubled. Only minor changes are needed to the <code>ChangeState()</code> function to accommodate the upgrade, making it machine-agnostic. The <code>State*&amp;</code> argument here is used to pass the pointer by reference instead of the value being pointed to, as it is<a id="_idIndexMarker360"/> the pointer we need to retarget. This can be seen below.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Concurrent state machine implementation</p>
<pre class="source-code">
void SomeClass::Update()
{
    EMoveState nextMove = _StateMove.Update();
    EAttackState nextAttack = _StateAttack.Update();
    if (nextMove != _MoveStateTracker)
    {
        ChangeState(nextMove, _MoveStateTracker, _MoveState);
    }
    if (nextAttack != _AttackStateTracker)
    {
        ChangeState(nextAttack, _AttackStateTracker, _AttackState);
    }
}
void SomeClass::ChangeState(EState nextState,     EState&amp; stateTracker, State*&amp; stateMachine)
{
    stateMachine-&gt;Exit();
    stateTracker = nextState;
    stateMachine = _StateLibrary[stateTracker];
    stateMachine-&gt;Enter();
}</pre> <p>The next<a id="_idIndexMarker361"/> area for improvement will be noticed most in state machines<a id="_idIndexMarker362"/> that govern variant behavior where multiple states might share some base functionality but differ slightly. An example of this could be that a crouching state has different state transitions from a running state but the logic for executing movement is the same. In this case, we can take advantage of the fact that all states inherit from a parent and add some more layers with a hierarchical state machine.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor127"/>Hierarchical state machines</h2>
<p>As the name suggests, the state <a id="_idIndexMarker363"/>inheritance tree being pulled into a larger<a id="_idIndexMarker364"/> inheritance hierarchy with base behavior for groups of states creates a hierarchical state machine. Everything within this actually functions exactly the same as the base state machine; you just need to make sure that the implementations of each function call the base version. This is more of a code architecture principle to reduce memory footprint and speed up development. <em class="italic">Figure 8</em><em class="italic">.12</em> shows an example state inheritance tree for character locomotion and how we can use the grounded mid-level state to create several other states that implement grounded movement logic without needing to write it out a bunch of times. This improves maintainability as well since we are centralizing behavior:</p>
<div><div><img alt="Figure 8.12 – UML diagram showing an example inheritance structure for a set of hierarchical states" src="img/Figure_08.12_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – UML diagram showing an example inheritance structure for a set of hierarchical states</p>
<p>The final<a id="_idIndexMarker365"/> step is not to do with the execution logic but the transitions. As<a id="_idIndexMarker366"/> it currently stands, each state transition must know which state it’s heading to. This can work for simple state machines, but as soon as you have an interrupt action that can be accessed from anywhere and must return execution to where it came from when finished, we have a problem. Storing the information on where the state was entered from doesn’t really solve the problem, because what if the state we were in had a state that must be preserved? The answer is the very fancy pushdown automata level of a state machine.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor128"/>Pushdown automata</h2>
<p>As just mentioned, pushdown automata <a id="_idIndexMarker367"/>aim to provide a way to enter states with<a id="_idIndexMarker368"/> a breadcrumb trail to follow back out if the need arises. We achieve this by storing the current path of states in a stack. The only code change here is that the tracker and state pointer variables get merged into a struct and stored in a single state stack instead. Execution is simply run the same way on whichever state happens to be on the top.</p>
<p>This allows us to <a id="_idIndexMarker369"/>push interrupt states from anywhere in the machine, then pop that state off and continue from where we were – another simple idea that provides a lot of utility. Prime example usage would be a state machine that governs animations on a character that can move and attack. Attacks take over the animation solver until they are finished. The character should then return to whichever state they were in, be that <a id="_idIndexMarker370"/>crouched or standing idle. <em class="italic">Figure 8</em><em class="italic">.13</em> shows how the stack changes as the interaction progresses:</p>
<div><div><img alt="Figure 8.13 – Storyboard of a pushdown automata state stack over the course of an attack input" src="img/Figure_08.13_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Storyboard of a pushdown automata state stack over the course of an attack input</p>
<p>The state machine, as we have covered, has many forms. The real silver bullet with this pattern is realizing that none of these forms is mutually exclusive. You can make a hierarchical pushdown automata state machine that runs concurrently with another. The flip side of that is noticing that if you are using a fully featured hierarchical pushdown automata state machine in earnest, there is probably a simpler pattern that solves the same problem in a much more elegant way.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor129"/>Summary</h1>
<p>Altogether, we have covered three patterns that you can build into any future project: the Singleton pattern, which makes sure there is – and only ever will be – one instance of an object that exists, the Command pattern, which provides the utility of separation between the request for an action and that action happening, and finally, the State pattern, which separates our mutually exclusive logic.</p>
<p>At this point, you should understand that Singleton does work in some cases, but it has its drawbacks. The Command pattern can be used for so many different things that you should probably make a version of it as a template library for use in all future projects, and the State pattern has so many layers that it can ruin its own usefulness with depth.</p>
<p>The next chapter will explore some behavioral patterns that solidify the behavior of a class in different ways to improve the expandability of our systems – namely, the type object pattern, which we would posit as the most useful pattern in game development for content creation.</p>
</div>
</body></html>