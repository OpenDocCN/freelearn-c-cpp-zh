- en: Working with Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are an important construct of any programming language. To keep data
    of a similar type together, we need arrays. Arrays are heavily used in applications
    where elements have to be accessed at random. Arrays are also a prime choice when
    you need to sort elements, look for desired data in a collection, and find common
    or unique data between two sets. Arrays are assigned contiguous memory locations
    and are a very popular structure for sorting and searching data collections because
    any element of an array can be accessed by simply specifying its subscript or
    index location. This chapter will cover recipes that include operations commonly
    applied to arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to make the following recipes using arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting an element into a one-dimensional array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplying two matrices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the common elements in two arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the difference between two sets or arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the unique elements in an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding whether a matrix is sparse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging two sorted arrays into one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with the first recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Inserting an element in an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to insert an element in-between an array.
    You can define the length of the array and also specify the location where you
    want the new value to be inserted. The program will display the array after the
    value has been inserted.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '1\. Let''s assume that there is an array, **p**, with five elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88dedebb-9397-4a99-a0e1-7f24d92508e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose you want to enter a value, say **99**, at the third position.
    We will write a C program that will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/affaa657-3cbc-497d-bba9-04d30a5dca2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to insert an element in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a macro called `max` and initialize it to a value of `100`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an array `p` of size max elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the length of the array when prompted. The length you enter will be assigned
    to a variable `n`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A `for` loop will be executed prompting you to enter the elements of the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the position in the array where the new value has to be inserted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the arrays in C are zero-based, the position you enter is decremented
    by 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To create space for the new element at the specified index location, all the
    elements are shifted one position down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the new value which will be inserted at the vacated index location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `insertintoarray.c` program for inserting an element in between
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we want to specify the length of the array, we will first define a macro
    called `max` and initialize it to a value of 100\. I have defined the value of
    max as 100 because I assume that I will not need to enter more than 100 values
    in an array, but it can be any value as desired. An array, `p`, is defined of
    size `max` elements. You will be prompted to specify the length of the array.
    Let's specify the length of the array as 5\. We will assign the value `5` to the
    variable `n`. Using a `for` loop, you will be asked to enter the elements of the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you enter the values in the array, as shown in *Figure 1.1* given
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4c3a8cb-d277-47bd-8d5b-31df5d1d9a21.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the numbers, 0, 1, 2, and so on are known as index
    or subscript and are used for assigning and retrieving values from an array. Next,
    you will be asked to specify the position in the array where the new value has
    to be inserted. Suppose, you enter `3`, which is assigned to the variable `k`.
    This means that you want to insert a new value at location 3 in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Because the arrays in C are zero-based, position 3 means that you want to insert
    a new value at index location 2, which is **p[2]**. Hence, the position entered
    in `k` is decremented by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create space for the new element at index location **p[2]**, all the elements
    are shifted one position down. This means that the element at **p[4]** is moved
    to index location **p[5]**, the one at **p[3]** is moved to **p[4]**, and the
    element at **p[2]** is moved to **p[3]**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bf16859-1375-4e03-9d61-fcbc348737d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the element from the target index location is safely copied to the next
    location, you will be asked to enter the new value. Suppose you enter the new
    value as `99`; that value will be inserted at index location **p[2]**, as shown
    in *Figure 1.2,* given earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8dad9c99-e3a6-4418-b19d-9635c74eb8cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s use GCC to compile the `insertintoarray.c` program, as shown in this
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run the generated executable file, `insertintoarray.exe`, to see
    the program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully inserted an element in an array.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we want to delete an element from an array? The procedure is simply
    the reverse; in other words, all the elements from the bottom of the array will
    be copied one place up to replace the element that was deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume array **p** has the following five elements (*Figure 1.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/236c2707-a44b-4300-8bbf-6c2a0684d61e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Suppose, we want to delete the third element, in other words, the one at **p[2]**,
    from this array. To do so, the element at **p[3]** will be copied to **p[2]**,
    the element at **p[4]** will be copied to **p[3]**, and the last element, which
    here is at **p[4]**, will stay as it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8a39086-7cf2-4b0e-a792-98d6cfc97f2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4
  prefs: []
  type: TYPE_NORMAL
- en: 'The `deletefromarray.c` program for deleting the array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying two matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A prerequisite for multiplying two matrices is that the number of columns in
    the first matrix must be equal to the number of rows in the second matrix.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create two matrices of orders **2 x 3** and **3 x 4** each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we make the matrix multiplication program, we need to understand how
    matrix multiplication is performed manually. To do so, let''s assume that the
    two matrices to be multiplied have the following elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/655cf601-5e0c-424f-ba47-932259913ba3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5
  prefs: []
  type: TYPE_NORMAL
- en: 'The resultant matrix will be of the order **2 x 4**, that is, the resultant
    matrix will have the same number of rows as the first matrix and the same number
    of columns as the second matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d962de0-0dfb-4bbb-9f54-7958be3cdcb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, the resultant matrix of the order **2 x 4** will have the following
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73d7a071-0545-4459-ab26-51687adcfe7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7
  prefs: []
  type: TYPE_NORMAL
- en: 'The element **first row, first column** in the resultant matrix is computed
    using the following formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <q>SUM(first element of the first row of the first matrix × first element of
    the first column of the second matrix), (second element of the first row... ×
    second element of the first column...), (and so on...)</q>
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s assume the elements of the two matrices are as shown in
    *Figure 1.5*.  The elements in the first row and the first column of the resultant
    matrix will be computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b55ec5fe-7b01-4f23-87f4-b0e3a6a3fa91.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the element in **first row, first column** in the resultant matrix will
    be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**(3×6)+(9×3)+(7×5)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**=18 + 27 + 35**'
  prefs: []
  type: TYPE_NORMAL
- en: '**=80**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1.9* explains how the rest of the elements are computed in the resultant
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/767866de-9455-4475-aaac-bb18f895746f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9
  prefs: []
  type: TYPE_NORMAL
- en: 'The `matrixmulti.c` program for multiplying the two matrices is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The two matrices are defined `matA` and `matB` of the orders 2 x 3 and 3 x
    4, respectively, using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You will be asked to enter the elements of the two matrices using the nested
    `for` loops. The elements in the matrix are entered in row-major order, in other
    words, all the elements of the first row are entered first, followed by all the
    elements of the second row, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the nested loops, `for i` and `for j`, the outer loop, `for i`, represents
    the row and the inner loop, and `for j` represents the column.
  prefs: []
  type: TYPE_NORMAL
- en: 'While entering the elements of matrices `matA` and `matB`, the values entered
    in the two matrices will be assigned to the respective index locations of the
    two-dimensional arrays as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/693b9c12-b0ed-4f26-9b41-6bc889829fd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10
  prefs: []
  type: TYPE_NORMAL
- en: 'The nested loops that actually compute the matrix multiplication are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The variable `i` represents the row of the resultant matrix, `j` represents
    the column of the resultant matrix, and `k` represents the common factor. The
    <q>common factor</q> here means the column of the first matrix and the row of
    the second matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the prerequisite for matrix multiplication is that the column of
    the first matrix should have the same number of rows as the second matrix. Because
    the respective elements have to be added after multiplication, the element has
    to be initialized to `0` before addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following statement initializes the elements of the resultant matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for k` loop inside the nested loops helps in selecting the elements in
    the rows of the first matrix and multiplying them by elements of the column of
    the second matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use GCC to compile the `matrixmulti.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the generated executable file, `matrixmulti.exe`, to see the output
    of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully multiplied two matrices.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that you might notice while entering the elements of the matrix is
    that there are two ways of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is that you press *Enter* after inputting each element as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The values will be automatically assigned to the matrix in row-major order,
    in other words, `3` will be assigned to `matA[0][0]`, `9` will be assigned to
    `matA[0][1]`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method of entering elements in the matrix is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, `6` will be assigned to `matB[0][0]`, `2` will be assigned to `matB[0][1]`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Finding the common elements in two arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding the common elements in two arrays is akin to finding the intersection
    of two sets. Let's learn how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define two arrays of a certain size and assign elements of your choice to both
    the arrays. Let''s assume that we created two arrays called **p** and **q**, both
    of size four elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f5a4b04-9ca7-4c11-9c3e-ebac923a6cc4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11
  prefs: []
  type: TYPE_NORMAL
- en: Define one more array. Let's call it array **r**, to be used for storing the
    elements that are common between the two arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an element in array **p** exists in the array **q**, it is added to array
    **r**. For instance, if the element at the first location in array **p**, which
    is at **p[0]**, does not appear in array **q**, it is discarded, and the next
    element, at **p[1]**, is picked up for comparison.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And if the element at **p[0]** is found anywhere in array **q**, it is added
    to array **r**, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9ee95874-f55b-418e-a0f0-1bb0b3840df9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12
  prefs: []
  type: TYPE_NORMAL
- en: This procedure is repeated with other elements of array **q**. That is, **p[1]**
    is compared with **q[0]**, **q[1]**, **q[2]**, and **q[3]**. If **p[1]** is not
    found in array **q**, then before inserting it straightaway into array **r**,
    it is compared with the existing elements of array **r** to avoid repetitive elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because the element at **p[1]** appears in array **q** and is not already present
    in array **r**, it is added to array **r** as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b3ed38d0-9d64-4a2f-9a0e-5ad75ab84c51.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13
  prefs: []
  type: TYPE_NORMAL
- en: 'The `commoninarray.c` program for establishing common elements among the two
    arrays is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A macro, `max`, is defined of size `100`. A function, `ifexists()`, is defined
    that simply returns `true (1)` or `false (0)`. The function returns `true` if
    the supplied value exists in the specified array, and `false` if it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: Two arrays are defined, called `p` and `q`, of size `max` (in other words, 100
    elements). You will be prompted to specify the length of the array, `p`, and then
    asked to enter the elements in that array. After that, you will be asked to specify
    the length of array `q`, followed by entering the elements in array `q`.
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, `p[0]`, the first element in array `p` , is picked up, and by using
    the `for` loop, `p[0]` is compared with all the elements of array `q`. If `p[0]`
    is found in array `q`, then `p[0]` is added to the resulting array, `r`.
  prefs: []
  type: TYPE_NORMAL
- en: After a comparison of `p[0]`, the second element in array p, `p[1]`, is picked
    up and compared with all the elements of array `q`. The procedure is repeated
    until all the elements of array `p` are compared with all the elements of array
    `q`.
  prefs: []
  type: TYPE_NORMAL
- en: If any elements of array `p` are found in array `q`, then before adding that
    element to the resulting array, `r`, it is run through the `ifexists()` function
    to ensure that the element does not already exist in array `r`. This is because
    we don't want repetitive elements in array `r`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all the elements in array `r`, which are the common elements of the
    two arrays, are displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `commoninarray.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the generated executable file, `commoninarray.exe`, to see
    the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Because there were no common elements between the two arrays entered previously,
    we can't quite say that we've truly tested the program. Let's run the program
    again, and this time, we will enter the array elements such that they have something
    in common.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully identified the common elements between two arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the difference between two sets or arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about the difference between two sets or arrays, we are referring
    to all the elements of the first array that don't appear in the second array.
    In essence, all the elements in the first array that are not common to the second
    array are referred to as the difference between the two sets. The difference in
    sets `p` and `q`, for example, will be denoted by `p – q`.
  prefs: []
  type: TYPE_NORMAL
- en: If array `p`, for example, has the elements `{1, 2, 3, 4}`, and array `q` has
    the elements `{2, 4, 5, 6}`, then the difference between the two arrays, `p -
    q`, will be  `{1,3}`.  Let's find out how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define two arrays, say `p` and `q`, of a certain size and assign elements of
    your choice to both the arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define one more array, say `r`, to be used for storing the elements that represent
    the difference between the two arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick one element from array `p` and compare it with all the elements of the
    array `q`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the element of array `p` exists in array `q`, discard that element and pick
    up the next element of array `p` and repeat from step 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the element of array `p` does not exist in array `q`, add that element in
    array `r`. Before adding that element to array `r`, ensure that it does not already
    exist in array `r`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 3 to 5 until all the elements of array `p` are compared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display all the elements in array `r`, as these are the elements that represent
    the difference between arrays `p` and `q`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `differencearray.c` program to establish the difference between two arrays
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We defined two arrays called **p** and **q**. We don't want to fix the length
    of these arrays, so we should define a macro called `max` of value `100` and set
    the two arrays, **p** and **q**, to the size of `max`.
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, you will be prompted to specify the size of the first array and
    enter the elements in the first array, **p**. Similarly, you will be asked to
    specify the length of the second array, **q**, followed by entering the elements
    in the second array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume you have specified the length of both arrays as 4 and have entered
    the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fc0af7c-1dc3-43a0-a703-259a403fa501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14
  prefs: []
  type: TYPE_NORMAL
- en: We need to pick up one element at a time from the first array and compare it
    with all the elements of the second array. If an element in array **p** does not
    appear in array **q**, it will be assigned to the third array we created, array **r**.
  prefs: []
  type: TYPE_NORMAL
- en: Array **r** will be used for storing the elements that define the difference
    between two arrays. As shown in *Figure 1.15*, the first element of array **p**,
    in other words, at **p[0]**, is compared with all the elements of array **q**,
    in other words, with **q[0]**, **q[1]**, **q[2]**, and **q[3]**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the element at **p[0]**, which is **1**, does not appear in array **q**,
    it will be added to the array **r**, indicating the first element representing
    the difference between the two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e07c23be-748e-436a-8ef0-17269e96b071.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.15
  prefs: []
  type: TYPE_NORMAL
- en: Because the element at **p[1]**, which is **2**, appears in array **q**, it
    is discarded, and the next element in array **p**, in other words, **p[2]**, is
    picked up and compared with all the elements in array **q**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the element at **p[2]** does not appear in array **q**, it is added to array **r**
    at the next available location, which is **r[1]** (see *Figure 1.16* as follows):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca765e18-f000-44dc-9136-885c95b3315c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.16
  prefs: []
  type: TYPE_NORMAL
- en: Continue the procedure until all the elements of array **p** are compared with
    all the elements of array **q**. Finally, we will have array **r**, with the elements
    showing the difference between our two arrays, **p** and **q**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile our program, `differencearray.c`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the generated executable file, `differencearray`, to see the
    output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully found the difference between two arrays. Now, let's
    move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Finding the unique elements in an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to find the unique elements in an array, such
    that the repetitive elements in the array will be displayed only once.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define two arrays, **p** and **q**, of a certain size and assign elements only
    to array **p**. We will leave array **q** blank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These will be our source and target arrays, respectively. The target array will
    contain the resulting unique elements of the source array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, each of the elements in the source array will be compared with the
    existing elements in the target array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the element in the source array exists in the target array, then that element
    is discarded and the next element in the source array is picked up for comparison.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the source array element does not exist in the target array, it is copied
    into the target array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s assume that array **p** contains the following repetitive elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb3482eb-e590-44c7-9ef5-0c21eab0731b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.17
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by copying the first element of the source array, **p**, into
    the target array, **q**, in other words, **p[0]** into array **q[0]**, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9e6c62a6-5225-4c80-bcdd-02877479214c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.18
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the second array element of **p**, in other words, **p[1]**, is compared
    with all the existing elements of array **q**. That is, **p[1]** is compared with
    array **q** to check whether it already exists in array **q**, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3d0013c-a44a-4ad0-80b8-071cd266163a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.19
  prefs: []
  type: TYPE_NORMAL
- en: 'Because **p[1]** does not exist in array **q**, it is copied at **q[1]**, as
    shown in *Figure 1.20*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f45d9b2-5b7f-4065-8fbf-ee262e075cc9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.20
  prefs: []
  type: TYPE_NORMAL
- en: This procedure is repeated until all the elements of array **p** are compared
    with array q. In the end, we will have array **q**, which will contain the unique
    elements of array **p**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the `uniqueelements.c` program for finding the unique elements in the
    first array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will define a macro called `max` of size `100`. Two arrays, `p` and `q`,
    are defined of size `max`. Array `p` will contain the original elements, and array
    `q` will contain the unique elements of array `p`. You will be prompted to enter
    the length of the array and, thereafter, using the `for` loop, the elements of
    the array will be accepted and assigned to array `p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following statement will assign the first element of array `p` to the first
    index location of our blank array, which we will name array `q`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A `for` loop is again used to access the rest of the elements of array `p`,
    one by one. First, the foremost element of array `p`, which is at `p[0]`, is copied
    to array `q` at `q[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the second array `p` element, `p[1]`, is compared with all the existing
    elements of array `q`. That is, `p[1]` is checked against array `q` to confirm
    whether it is already present there.
  prefs: []
  type: TYPE_NORMAL
- en: Because there is only a single element in array `q`,  `p[1]` is compared with `q[0]`.
    Because `p[1]` does not exist in array `q`, it is copied at `q[1]`.
  prefs: []
  type: TYPE_NORMAL
- en: This procedure is repeated for all elements in array `p`. Each of the accessed
    elements of array `p` is run through the `ifexists()` function to check whether
    any of them already exist in array `q`.
  prefs: []
  type: TYPE_NORMAL
- en: The function returns `1` if an element in array `p` already exists in array
    `q`. In that case, the element in array `p` is discarded and the next array element
    is picked up for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: In case the `ifexists()` function returns `0`, confirming that the element in
    array `p` does not exist in array `q`, the array `p` element is added to array
    `q` at the next available index/subscript location.
  prefs: []
  type: TYPE_NORMAL
- en: When all the elements of array `p` are checked and compared, array `q` will
    have only the unique elements of array `p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `uniqueelements.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the generated executable file, `uniqueelements.exe`, to see
    the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully identified the unique elements in an array. Now, let's
    move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Finding whether a matrix is sparse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A matrix is considered sparse when it has more zero values than non-zero values
    (and dense when it has more non-zero values). In this recipe, we will learn how
    to find out whether the specified matrix is sparse.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, specify the order of the matrix. Then, you will be prompted to enter
    the elements in the matrix. Let''s assume that you specified the order of the
    matrix as 4 x 4\. After entering the elements in the matrix, it might appear like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2f8763f6-46f1-4ecb-9a6d-b11350ac663c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.21
  prefs: []
  type: TYPE_NORMAL
- en: Once the elements of the matrix are entered, count the number of zeros in it.
    A counter for this purpose is initialized to **0**. Using nested loops, each of
    the matrix elements is scanned and, upon finding any zero elements, the value
    of the counter is incremented by 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thereafter, the following formula is used for establishing whether the matrix
    is sparse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*If counter > [(the number of rows x the number of columns)/2] =  Sparse Matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the result of the preceding formula, one of the following messages
    will be displayed on the screen as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sparsematrix.c` program for establishing whether the matrix is sparse
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we don't want to fix the size of the matrix, we will define a macro
    called `max` of value 100\. A matrix, or a two-dimensional array called **arr**,
    is defined of the order max x max. You will be prompted to enter the order of
    the matrix, for which you can again enter any value up to 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that you’ve specified the order of the matrix as 4 x 4\. You
    will be prompted to enter elements in the matrix. The values entered in the matrix
    will be in row-major order. After entering the elements, the matrix **arr** should
    look like *F**igure 1.22,* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aedcbc84-4f1e-4271-964d-3adf93ec0e3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.22
  prefs: []
  type: TYPE_NORMAL
- en: 'A counter called `ctr` is created and is initialized to `0`. Using nested loops,
    each element of matrix `arr` is checked and the value of `ctr` is incremented
    if any element is found to be 0\. Thereafter, using the `if else` statement, we
    will check whether the count of zero values is more than non-zero values. If the
    count of zero values is more than non-zero values, then the message will be displayed
    on the screen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, failing that, the message will be displayed on the screen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use GCC to compile the `sparsematrix.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the generated executable file, `sparsematrix.exe`, to see the output
    of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay. Let''s run the program again to see the output when the count of non-zero
    values is higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully identified a sparse and a non-sparse matrix.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How about finding an identity matrix, in other words, finding out whether the
    matrix entered by the user is an identity matrix or not. Let me tell you—a matrix
    is said to be an identity matrix if it is a square matrix and all the elements
    of the principal diagonal are ones and all other elements are zeros. An identity
    matrix of the order **3 x 3** may appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cec9498c-eb58-4644-a7b8-a829389e2475.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.23
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, you can see that the principal diagonal elements
    of the matrix are 1''s and the rest of them are 0''s. The index or subscript location
    of the principal diagonal elements will be `arr[0][0]`, `arr[1][1]`, and `arr[2][2]`,
    so the following procedure is followed to find out whether the matrix is an identity
    matrix or not:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks that if the index location of the row and column is the same, in other
    words, if the row number is 0 and the column number, too, is 0, then at that index
    location, [0][0], the matrix element must be `1`. Similarly, if the row number
    is 1 and the column number, too, is 1, that is, at the [1][1] index location,
    the matrix element must be `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the matrix element is `0` at all the other index locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both the preceding conditions are met, then the matrix is an identity matrix,
    or else it is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `identitymatrix.c` program to establish whether the entered matrix is an
    identity matrix or not is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use GCC to compile the `identitymatrix.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'No error is generated. This means the program is compiled perfectly and an
    executable file is generated. Let''s run the generated executable file. First,
    we will enter a non-square matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's run the program again; this time, we will enter a square matrix
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Because a non-diagonal element in the preceding matrix is `1`, it is not an
    identity matrix. Let''s run the program again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Merging two sorted arrays into a single array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to merge two sorted arrays into a single array
    so that the resulting merged array is also in sorted form.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume there are two arrays, **p** and **q**, of a certain length. The
    length of the two arrays can differ. Both have some sorted elements in them, as
    shown in *Figure 1.24*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a51fc2f-4333-42ee-9a74-3103b8273fcb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.24
  prefs: []
  type: TYPE_NORMAL
- en: The merged array that will be created from the sorted elements of the preceding
    two arrays will be called array **r**. Three subscripts or index locations will
    be used to point to the respective elements of the three arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subscript `i` will be used to point to the index location of array `p`. Subscript
    `j` will be used to point to the index location of array `q` and subscript `k`
    will be used to point to the index location of array `r`. In the beginning, all
    three subscripts will be initialized to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following three formulas will be applied to get the merged sorted array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The element at `p[i]` is compared with the element at `q[j]`. If `p[i]` is
    less than `q[j]`, then `p[i]` is assigned to array `r`, and the indices of arrays `p`
    and `r` are incremented so that the following element of array `p` is picked up
    for the next comparison as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If `q[j]` is less than `p[i]`, then `q[j]` is assigned to array `r`, and the
    indices of arrays `q` and `r`  are incremented so that the following element of
    array `q` is picked up for the next comparison as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If `p[i]` is equal to `q[j]`, then both the elements are assigned to array `r`.  `p[i]`
    is added to `r[k]`. The values of the `i` and `k` indices are incremented.  `q[j]` is
    also added to `r[k]`, and the indices of the `q` and `r` arrays are incremented.
    Refer to the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The procedure will be repeated until either of the arrays gets over. If any
    of the arrays is over, the remainder of the elements of the other array will be
    simply appended to the array `r`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `mergetwosortedarrays.c` program for merging two sorted arrays is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A macro called `max` is defined of size `100`. Three arrays, `p`, `q`, and `r`,
    are defined of size `max`. You will first be asked to enter the size of the first
    array, `p`, followed by the sorted elements for array `p`. The process is repeated
    for the second array `q`.
  prefs: []
  type: TYPE_NORMAL
- en: Three indices, `i`, `j` and `k`, are defined and initialized to `0`. The three
    indices will point to the elements of the three arrays, `p`, `q`, and `r`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The first elements of arrays **p** and **q**, in other words, **p[0]**  and **q[0]**,
    are compared and the smaller one is assigned to array **r**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because **q[0]** is smaller than **p[0]**, **q[0]** is added to array **r**, and
    the indices of arrays **q** and **r** are incremented for the next comparison
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f589a7b-f9dc-4b75-9996-03be25128569.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.25
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, **p[0]** will be compared with **q[1]**. Because **p[0]** is smaller
    than **q[1]**, the value at **p[0]** will be assigned to array **r** at **r[1]**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fd85177-4980-4662-b195-8e4e7c6fd69a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.26
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, **p[1]** will be compared with **q[1]**. Because **q[1]** is smaller
    than **p[1]**, **q[1]** will be assigned to array **r**, and the indices of the **q** and **r** arrays
    will be incremented for the next comparisons (refer to the following diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c9a9e7d-fa51-4ee7-9988-77b0539eba1e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.27
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `mergetwosortedarrays.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the generated executable file, `mergetwosortedarrays.exe`,
    in order to see the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully merged two sorted arrays into one.
  prefs: []
  type: TYPE_NORMAL
