["```cpp\nif(sf::Keyboard::isKeyPressed(sf::Keyboard::W)){\n    // Do something if the W key is pressed.\n}\n```", "```cpp\nif(sf::Mouse::isButtonPressed(sf::Mouse::Left)){\n    // Do something if the left mouse button is pressed.\n}\n```", "```cpp\n// Getting the mouse position.\nsf::Vector2i mousePos = sf::Mouse::getPosition(); // 1\nsf::Vector2i mousePos = sf::Mouse::getPosition(m_window); // 2\n\n// Setting the mouse position.\nsf::Mouse::setPosition(sf::Vector2i(0,0)); // 3\nsf::Mouse::setPosition(sf::Vector2i(0,0),m_window); // 4\n```", "```cpp\nif (sf::Joystick::isConnected(0))\n{\n    // We have a controller with an id 0.\n}\n```", "```cpp\nunsigned int n_buttons = sf::Joystick::getButtonCount(0);\n```", "```cpp\nif(sf::Joystick::isButtonPressed(0,1)){\n    // Button 1 on controller 0 is pressed.\n}\n```", "```cpp\nif(sf::Joystick::hasAxis(0,sf::Joystick::X)){\n    // Controller 0 supports movement on X axis.\n}\n```", "```cpp\nfloat p_x = sf::Joystick::getAxisPosition(0, sf::Joystick::X);\nfloat p_y = sf::Joystick::getAxisPosition(0, sf::Joystick::Y);\n// Do something with p_x and p_y.\n```", "```cpp\nsf::Event event;\n\nwhile(m_window.pollEvent(event)){\n    switch(event.type){\n    case sf::Event::Closed:\n        m_window.close();\n        break;\n\n    case sf::Event::KeyPressed:\n        if(event.key.code == sf::Keyboard::W){\n            // Do something when W key gets pressed once.\n        }\n        break;\n    }\n}\n```", "```cpp\nenum class EventType{\n    KeyDown = sf::Event::KeyPressed,\n    KeyUp = sf::Event::KeyReleased,\n    MButtonDown = sf::Event::MouseButtonPressed,\n    MButtonUp = sf::Event::MouseButtonReleased,\n    MouseWheel = sf::Event::MouseWheelMoved,\n    WindowResized = sf::Event::Resized,\n    GainedFocus = sf::Event::GainedFocus,\n    LostFocus = sf::Event::LostFocus,\n    MouseEntered = sf::Event::MouseEntered,\n    MouseLeft = sf::Event::MouseLeft,\n    Closed = sf::Event::Closed,\n    TextEntered = sf::Event::TextEntered,\n    Keyboard = sf::Event::Count + 1, Mouse, Joystick\n};\n```", "```cpp\nstruct EventInfo{\n    EventInfo(){ m_code = 0; }\n    EventInfo(int l_event){ m_code = l_event; }\n    union{\n        int m_code;\n    };\n};\n```", "```cpp\nusing Events = std::vector<std::pair<EventType, EventInfo>>;\n```", "```cpp\nstruct EventDetails{\n    EventDetails(const std::string& l_bindName)\n        : m_name(l_bindName)\n    {\n        Clear();\n    }\n    std::string m_name;\n\n    sf::Vector2i m_size;\n    sf::Uint32 m_textEntered;\n    sf::Vector2i m_mouse;\n    int m_mouseWheelDelta;\n    int m_keyCode; // Single key code.\n\n    void Clear(){\n        m_size = sf::Vector2i(0, 0);\n        m_textEntered = 0;\n        m_mouse = sf::Vector2i(0, 0);\n        m_mouseWheelDelta = 0;\n        m_keyCode = -1;\n    }\n};\n```", "```cpp\nstruct Binding{\n   Binding(const std::string& l_name)\n      : m_name(l_name), m_details(l_name), c(0){}\n   void BindEvent(EventType l_type,\n      EventInfo l_info = EventInfo())\n   {\n      m_events.emplace_back(l_type, l_info);\n   }\n\n   Events m_events;\n   std::string m_name;\n   int c; // Count of events that are \"happening\".\n\n   EventDetails m_details;\n};\n```", "```cpp\nusing Bindings = std::unordered_map<std::string, Binding*>;\n```", "```cpp\nvoid(SomeClass::*_callback)();\n```", "```cpp\nstruct Callback{\n    std::string m_name;\n    SomeClass* CallbackInstance; // Pointer to instance.\n    void(SomeClass::*_callback)();\n\n    void Call(){\n    CallbackInstance->*_callback();\n    }\n};\n```", "```cpp\ntemplate<class T>\nstruct Callback{\n    ...\n    T* CallbackInstance; // Pointer to instance.\n    void(T::*_callback)();\n    ...\n};\n```", "```cpp\ntemplate <class T>\nusing Function = void (T::*)();\n```", "```cpp\n#include <functional> // Defines std::function & std::bind.\n...\nstd::function<void(void)> foo = std::bind(&Bar::method1, this);\n```", "```cpp\nfoo(); // Equivalent to barInstance->method1();\n```", "```cpp\nusing Callbacks = std::unordered_map<std::string, std::function<void(EventDetails*)>>;\n```", "```cpp\nclass EventManager{\npublic:\n    EventManager();\n    ~EventManager();\n\n    bool AddBinding(Binding *l_binding);\n    bool RemoveBinding(std::string l_name);\n\n    void SetFocus(const bool& l_focus);\n\n    // Needs to be defined in the header!\n    template<class T>\n    bool AddCallback(const std::string& l_name, void(T::*l_func)(EventDetails*), T* l_instance)\n    {\n        auto temp = std::bind(l_func,l_instance, std::placeholders::_1);\n        return m_callbacks.emplace(l_name, temp).second;\n    }\n\n    void RemoveCallback(const std::string& l_name){\n        m_callbacks.erase(l_name);\n    }\n\n    void HandleEvent(sf::Event& l_event);\n    void Update();\n\n    sf::Vector2i GetMousePos(sf::RenderWindow* l_wind = nullptr){\n        return (l_wind ? sf::Mouse::getPosition(*l_wind)\n            : sf::Mouse::getPosition());\n    }\nprivate:\n    void LoadBindings();\n\n    Bindings m_bindings;\n    Callbacks m_callbacks;\n    bool m_hasFocus;\n};\n```", "```cpp\nEventManager::EventManager(): m_hasFocus(true){ LoadBindings(); }\nEventManager::~EventManager(){\n   for (auto &itr : m_bindings){\n      delete itr.second;\n      itr.second = nullptr;\n   }\n}\n```", "```cpp\nbool EventManager::AddBinding(Binding *l_binding){\n   if (m_bindings.find(l_binding->m_name) != m_bindings.end())\n      return false;\n\n   return m_bindings.emplace(l_binding->m_name,\n      l_binding).second;\n}\n```", "```cpp\nbool EventManager::RemoveBinding(std::string l_name){\n    auto itr = m_bindings.find(l_name);\n    if (itr == m_bindings.end()){ return false; }\n    delete itr->second;\n    m_bindings.erase(itr);\n    return true;\n}\n```", "```cpp\nvoid EventManager::HandleEvent(sf::Event& l_event){\n  // Handling SFML events.\n  for (auto &b_itr : m_bindings){\n    Binding* bind = b_itr.second;\n    for (auto &e_itr : bind->m_events){\n      EventType sfmlEvent = (EventType)l_event.type;\n      if (e_itr.first != sfmlEvent){ continue; }\n      if (sfmlEvent == EventType::KeyDown ||\n        sfmlEvent == EventType::KeyUp)\n      {\n        if (e_itr.second.m_code == l_event.key.code){\n          // Matching event/keystroke.\n          // Increase count.\n          if (bind->m_details.m_keyCode != -1){\n            bind->m_details.m_keyCode = e_itr.second.m_code;\n          }\n          ++(bind->c);\n          break;\n        }\n      } else if (sfmlEvent == EventType::MButtonDown ||\n        sfmlEvent == EventType::MButtonUp)\n      {\n        if (e_itr.second.m_code == l_event.mouseButton.button){\n          // Matching event/keystroke.\n          // Increase count.\n          bind->m_details.m_mouse.x = l_event.mouseButton.x;\n          bind->m_details.m_mouse.y = l_event.mouseButton.y;\n          if (bind->m_details.m_keyCode != -1){\n            bind->m_details.m_keyCode = e_itr.second.m_code;\n          }\n          ++(bind->c);\n          break;\n        }\n      } else {\n        // No need for additional checking.\n        if (sfmlEvent == EventType::MouseWheel){\n          bind->m_details.m_mouseWheelDelta = l_event.mouseWheel.delta;\n        } else if (sfmlEvent == EventType::WindowResized){\n          bind->m_details.m_size.x = l_event.size.width;\n          bind->m_details.m_size.y = l_event.size.height;\n        } else if (sfmlEvent == EventType::TextEntered){\n          bind->m_details.m_textEntered = l_event.text.unicode;\n        }\n        ++(bind->c);\n      }\n    }\n  }\n}\n```", "```cpp\nvoid EventManager::Update(){\n  if (!m_hasFocus){ return; }\n  for (auto &b_itr : m_bindings){\n    Binding* bind = b_itr.second;\n    for (auto &e_itr : bind->m_events){\n      switch (e_itr.first){\n      case(EventType::Keyboard) :\n        if (sf::Keyboard::isKeyPressed(\n          sf::Keyboard::Key(e_itr.second.m_code)))\n        {\n          if (bind->m_details.m_keyCode != -1){\n            bind->m_details.m_keyCode = e_itr.second.m_code;\n          }\n          ++(bind->c);\n        }\n      break;\n      case(EventType::Mouse) :\n        if (sf::Mouse::isButtonPressed(\n          sf::Mouse::Button(e_itr.second.m_code)))\n        {\n          if (bind->m_details.m_keyCode != -1){\n            bind->m_details.m_keyCode = e_itr.second.m_code;\n          }\n          ++(bind->c);\n        }\n      break;\n      case(EventType::Joystick) :\n        // Up for expansion.\n        break;\n      }\n    }\n\n    if (bind->m_events.size() == bind->c){\n      auto callItr = m_callbacks.find(bind->m_name);\n      if(callItr != m_callbacks.end()){\n        callItr->second(&bind->m_details);\n      }\n    }\n    bind->c = 0;\n    bind->m_details.Clear();\n  }\n}\n```", "```cpp\nWindow_close 0:0\nFullscreen_toggle 5:89\nMove 9:0 24:38\n```", "```cpp\nvoid EventManager::LoadBindings(){\n  std::string delimiter = \":\";\n\n  std::ifstream bindings;\n  bindings.open(\"keys.cfg\");\n  if (!bindings.is_open()){\n    std::cout << \"! Failed loading keys.cfg.\" << std::endl;\n    return;\n  }\n  std::string line;\n  while (std::getline(bindings, line)){\n    std::stringstream keystream(line);\n    std::string callbackName;\n    keystream >> callbackName;\n    Binding* bind = new Binding(callbackName);\n    while (!keystream.eof()){\n      std::string keyval;\n      keystream >> keyval;\n      int start = 0;\n      int end = keyval.find(delimiter);\n      if (end == std::string::npos){\n        delete bind;\n        bind = nullptr;\n        break;\n      }\n      EventType type = EventType(\n        stoi(keyval.substr(start, end - start)));\n      int code = stoi(keyval.substr(end + delimiter.length(),\n        keyval.find(delimiter, end + delimiter.length())));\n        EventInfo eventInfo;\n      eventInfo.m_code = code;\n\n      bind->BindEvent(type, eventInfo);\n    }\n\n    if (!AddBinding(bind)){ delete bind; }\n    bind = nullptr;\n  }\n  bindings.close();\n}\n```", "```cpp\nclass Window{\npublic:\n    ...\n    bool IsFocused();\n    EventManager* GetEventManager();\n    void ToggleFullscreen(EventDetails* l_details);\n    void Close(EventDetails* l_details = nullptr);\n    ...\nprivate:\n    ...\n    EventManager m_eventManager;\n    bool m_isFocused;\n};\n```", "```cpp\nvoid Window::Close(){ m_isDone = true; }\n```", "```cpp\nvoid Window::Update(){\n   sf::Event event;\n   while(m_window.pollEvent(event)){\n      if (event.type == sf::Event::LostFocus){\n         m_isFocused = false;\n         m_eventManager.SetFocus(false);\n      }\n      else if (event.type == sf::Event::GainedFocus){\n         m_isFocused = true;\n         m_eventManager.SetFocus(true);\n      }\n      m_eventManager.HandleEvent(event);\n   }\n   m_eventManager.Update();\n}\n```", "```cpp\nvoid Window::Setup(...){\n    ...\n    m_isFocused = true; // Default value for focused flag.\n    m_eventManager->AddCallback(\"Fullscreen_toggle\", &Window::ToggleFullscreen,this);\n    m_eventManager->AddCallback(\"Window_close\", &Window::Close,this);\n    ...\n}\n```", "```cpp\nvoid Game::MoveSprite(EventDetails* l_details){\n    sf::Vector2i mousepos = m_window->GetEventManager()->GetMousePos(m_window->GetRenderWindow());\n    m_sprite.setPosition(mousepos.x, mousepos.y);\n    std::cout << \"Moving sprite to: \" << mousepos.x << \":\" << mousepos.y << std::endl;\n}\n```", "```cpp\nGame::Game(){\n    ...\n    // Texture and sprite setup.\n    ...\n    m_window->GetEventManager()->AddCallback(\"Move\", &Game::MoveSprite,this);\n}\n```", "```cpp\nMove 9:0 24:38\n```"]