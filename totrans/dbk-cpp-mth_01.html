<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-14">
    <a id="_idTextAnchor013">
    </a>
    
     1
    
   </h1>
   <h1 id="_idParaDest-15">
    <a id="_idTextAnchor014">
    </a>
    
     C++ Is Very Difficult to Learn
    
   </h1>
   <p class="Italic-Subheading">
    <em class="italic">
     
      If you want to channel all
     
    </em>
    
     <em class="italic">
      
       its power
      
     </em>
    
   </p>
   <p>
    
     A prevalent belief between both C++ programmers and those who only hear about the language is that it’s very difficult to learn it.
    
    
     But what is this based upon?
    
    
     We will see that part of this belief is historical; not only has C++ been around for almost 30 years, but the initial standard was both unforgiving to programmers and required a lot of knowledge of memory management.
    
    
     Modern C++, after consequent improvements brought by the new standards C++11, C++ 14, C++ 17, C++ 20, and C++ 23, allows programmers to write code that is very similar to Java or C#.
    
    
     However, C++ has its specific niche in systems programming, which makes it necessary for programmers to learn more topics than necessary for other
    
    
     
      modern languages.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Why is C++ perceived as difficult
     
     
      
       to learn?
      
     
    </li>
    <li>
     
      The hard parts of C++ and how to
     
     
      
       grasp them
      
     
    </li>
    <li>
     
      The Stroustrup method for
     
     
      
       learning C++
      
     
    </li>
    <li>
     
      The test-driven method for
     
     
      
       learning C++
      
     
    </li>
    <li>
     
      With
     
     
      
       great power…
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-16">
    <a id="_idTextAnchor015">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     The code examples in this chapter can be found in the GitHub repository
    
    <a href="https://github.com/PacktPublishing/Debunking-CPP-Myths">
     
      https://github.com/PacktPublishing/Debunking-CPP-Myths
     
    </a>
    
     in the
    
    <strong class="source-inline">
     
      ch1
     
    </strong>
    
     folder.
    
    
     The code uses
    
    <strong class="source-inline">
     
      doctest
     
    </strong>
    
     (
    
    <a href="https://github.com/doctest/doctest">
     
      https://github.com/doctest/doctest
     
    </a>
    
     ) as a testing library,
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      make
     
    </strong>
    
     for compilation, and targets C++ 20.
    
    
     You will also need
    
    <strong class="source-inline">
     
      valgrind
     
    </strong>
    
     (
    
    <a href="https://valgrind.org/">
     
      https://valgrind.org/
     
    </a>
    
     ) to check for
    
    
     
      memory leaks.
     
    
   </p>
   <h1 id="_idParaDest-17">
    <a id="_idTextAnchor016">
    </a>
    
     Why is C++ perceived as difficult to learn?
    
   </h1>
   <p>
    
     The beginnings of C++ saw it
    
    <a id="_idIndexMarker000">
    </a>
    
     as an extension to C, only using the new paradigm,
    
    <strong class="bold">
     
      object-oriented programming
     
    </strong>
    
     (
    
    <strong class="bold">
     
      OOP
     
    </strong>
    
     ), thus
    
    <a id="_idIndexMarker001">
    </a>
    
     promising to solve the many problems of growing code bases.
    
    
     This initial version of C++ is unforgiving; you, the programmer, had to deeply understand how memory allocation and release works and how pointer arithmetic works, as well as guard against a myriad of subtleties that you’d be likely to miss and that usually ended up in an unhelpful error message.
    
    
     It didn’t help that the prevalent cultural zeitgeist of programmers back then was that a real programmer had to know all the intricacies of CPUs, RAM, various assembly languages, OS workings, and compilers.
    
    
     It also didn’t help that the standardization committee did almost nothing to reduce the possibility of such errors for decades.
    
    
     No wonder the fame of the language is following it almost 40 years later.
    
    
     My experience learning it only helps to understand the struggles to learn the language
    
    
     
      back then.
     
    
   </p>
   <p>
    
     I had my first touches with C++ during my polytechnics studies, in the 90s.
    
    
     They had left me both intrigued and puzzled.
    
    
     I understood the power of the language, while it was actively fighting against me – or that’s how I perceived it.
    
    
     I had to struggle to write code that worked.
    
    
     I was not yet familiar with STL, which was yet to gain notoriety as part of the standard, so most of my first C++ programs dealt with pointer usage.
    
    
     A common question at C++ exams was about differentiating between an array of pointers and a pointer to an array.
    
    
     I can only imagine how helpful the complexities of the language were for building
    
    
     
      exam questions!
     
    
   </p>
   <p>
    
     For the record, see here the difference between pointer to array and array of pointers, a common exam question
    
    
     
      for C++:
     
    
   </p>
   <p>
    
     <strong class="source-inline">
      
       int(*pointerToArrayOf10Numbers)[10];
      
     </strong>
    
   </p>
   <p>
    
     <strong class="source-inline">
      
       int *arrayOfTenPointers[10]
      
     </strong>
    
   </p>
   <p>
    
     I continued learning C++ through practice and from books I could find before the internet would make the knowledge available to everyone.
    
    
     But the biggest jump in my understanding of the language was a project I worked on around the 2000s.
    
    
     The project lead, a very technical Belgian man, set for us very clear guidelines and a process we had to follow to get the best C++ code possible.
    
    
     This need for excellence did not come simply from his desires but from the project needs: we were building a NoSQL database engine many years before they would be given
    
    
     
      this label.
     
    
   </p>
   <p>
    
     For this project, I had to study and know all the rules from the two seminal books on C++:
    
    <em class="italic">
     
      Effective C++
     
    </em>
    
     and
    
    <em class="italic">
     
      More Effective C++
     
    </em>
    
     by Scott Meyers.
    
    
     The two books document in total 90 guidelines for C++ programmers, ranging from issues of resource initialization and release to minute ways to improve performance, inheritance, exception handling, and so on.
    
    
     This is also when I started using STL extensively, although the standard library was much more limited in scope than it
    
    
     
      is today.
     
    
   </p>
   <p>
    
     This newly
    
    <a id="_idIndexMarker002">
    </a>
    
     acquired knowledge made my C++ programs more reliable and made me more productive.
    
    
     An important contributing factor was the process we used in synergy with the wisdom of the two books.
    
    
     We wrote unit tests, we performed design and code reviews, and we carefully crafted our code knowing that it would be dissected by a colleague before getting accepted in the code base.
    
    
     This made our code quasi-bug-free and helped us implement complex features with high performance in a
    
    
     
      reasonable time.
     
    
   </p>
   <p>
    
     However, the language was still fighting against us.
    
    
     We knew how to write good C++ code, only it required a level of attention and care that inevitably slowed us down.
    
    
     Mastering C++ was not enough; the language had to give
    
    
     
      something back.
     
    
   </p>
   <p>
    
     After this project, I left the C++ world and learned C# and managed C++, Java, PHP, Python, Haskell, JavaScript, and Groovy, to limit myself to those languages I’d used for professional programming.
    
    
     While every programming language offered higher abstractions and fewer headaches compared to C++, I still had nostalgia for my formative years in programming.
    
    
     The fact that I knew C++ and all the intricacies of memory management gave me a deep understanding of the inner workings of these other languages, allowing me to use them to their fullest.
    
    
     Haskell proved to be very familiar to me since it was closely mapping the meta-programming techniques I’d learned from the seminal book by Andrei Alexandrescu,
    
    <em class="italic">
     
      Modern C++ Design
     
    </em>
    
     .
    
    
     C++ was living on in my mind, not only as the first programming language I used professionally but also as a foundation for every other language I’ve
    
    
     
      used since.
     
    
   </p>
   <p>
    
     To my delight, around 2010, the news came that the C++ standardization committee was finally making bold and frequent changes to the language.
    
    
     The last C++ standard had been for many years C++ 98; suddenly we were seeing a new version every three years.
    
    
     This rolling release of new versions of the standard allowed the introduction of the functional programming paradigm, of ranges, of new primitives for parallel and asynchronous programming, of move semantics.
    
    
     But the biggest change for anyone who wants to learn C++ today is the simplification of memory management and the introduction of
    
    <strong class="source-inline">
     
      auto
     
    </strong>
    
     types.
    
    
     The big breakthrough offered by these changes is that a Java or C# programmer can understand modern C++ programs, something we weren’t sure about back when Java and
    
    
     
      C# started.
     
    
   </p>
   <p>
    
     This means the
    
    <a id="_idIndexMarker003">
    </a>
    
     language is much easier to learn today than in the 90s.
    
    
     A good example of this change is the complete irrelevance of the old exam question on the difference between an array to pointers or a pointer to arrays; naked arrays can easily be replaced with a
    
    <strong class="source-inline">
     
      vector&lt;&gt;
     
    </strong>
    
     or a
    
    <strong class="source-inline">
     
      list&lt;&gt;
     
    </strong>
    
     , while pointers are replaced with the more precise
    
    <strong class="source-inline">
     
      shared_pointer&lt;&gt;
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      unique_pointer&lt;&gt;
     
    </strong>
    
     .
    
    
     This in turn reduces concerns related to allocation and release of memory for the pointers, thus both cleaning up the code and reducing the potential for the inscrutable error messages so prevalent in
    
    
     
      C++ 98.
     
    
   </p>
   <p>
    
     We can’t say, however, that the C++ language is as easy to learn as the other mainstream ones today.
    
    
     Let’s
    
    
     
      see why.
     
    
   </p>
   <h1 id="_idParaDest-18">
    <a id="_idTextAnchor017">
    </a>
    
     The hard parts of C++ and how to grasp them
    
   </h1>
   <p>
    
     Is C++ as easy to
    
    <a id="_idIndexMarker004">
    </a>
    
     learn as Java, C#, PHP, JavaScript, or Python?
    
    
     Despite all the language improvements, the answer is: most likely not.
    
    
     The important question is: Should C++ be as easy to learn as all these
    
    
     
      other languages?
     
    
   </p>
   <p>
    
     The demise of C++ has been predicted for a very long time.
    
    
     Java, then C#, and nowadays Rust were in turn touted as complete replacements for our venerable subject of debate.
    
    
     Instead, each of them seems to carve their own niche while C++ is still leading in programs that require careful optimization or work in constrained environments.
    
    
     It helps that millions of lines of C++ exist today, some of them decades old.
    
    
     While some of them can be turned into cloud-native, serverless, or microservices architectures, there will always be problems better fit for the engineering style serviced
    
    
     
      by C++.
     
    
   </p>
   <p>
    
     We conclude, therefore, that C++ has its own purpose in the world of development, and any new programming language faces a steep uphill battle to displace it.
    
    
     This observation comes with its consequence: specific parts of C++ will necessarily be more difficult to grasp than other languages.
    
    
     While Java or C# will spare you from thinking of memory allocation and what happens with the memory when you pass arguments to another method, C++ needs to take these issues head-on and give you the option to optimize your code as your
    
    
     
      context dictates.
     
    
   </p>
   <p>
    
     Therefore, if you want
    
    <a id="_idIndexMarker005">
    </a>
    
     to understand C++, you can’t escape memory management.
    
    
     Fortunately, it’s much less of an issue than it used
    
    
     
      to be.
     
    
   </p>
   <p>
    
     Let’s analyze the differences by looking at how different languages manage memory allocation and release.
    
    
     Java uses a
    
    <a id="_idIndexMarker006">
    </a>
    
     full
    
    <strong class="bold">
     
      object-oriented
     
    </strong>
    
     (
    
    <strong class="bold">
     
      OO
     
    </strong>
    
     ) approach, in which every value is an object.
    
    
     C# designers decided to use both value types that include the typical numeric values, chars, structs, and enums, and reference types that correspond to the objects.
    
    
     In Python, every value is an object, and the type can be established later in the program.
    
    
     All these three languages feature a garbage collector that deals with memory release.
    
    
     The Python language uses a reference counting mechanism in addition to the garbage collector, thus allowing it to be
    
    
     
      optionally disabled.
     
    
   </p>
   <p>
    
     The C++ 98 standard didn’t provide any built-in mechanism for pointer release, instead providing the full power and responsibility for memory management to the programmer.
    
    
     Unfortunately, this led to problems.
    
    
     Suppose that you initialize a pointer and allocate a large area of memory for a value.
    
    
     You then pass this pointer to other methods.
    
    
     Who is responsible for releasing
    
    
     
      the memory?
     
    
   </p>
   <p>
    
     See, for example, the following simple
    
    
     
      code sample:
     
    
   </p>
   <pre class="source-code">
BigDataStructure* pData = new pData();
call1(pData);
call2(pData);
call3(pData);</pre>
   <p>
    
     Should the caller release the memory allocated in
    
    <strong class="source-inline">
     
      pData
     
    </strong>
    
     ?
    
    
     Should
    
    <strong class="source-inline">
     
      call3
     
    </strong>
    
     do it?
    
    
     What if
    
    <strong class="source-inline">
     
      call3
     
    </strong>
    
     calls another function with the same
    
    <strong class="source-inline">
     
      pData
     
    </strong>
    
     instance?
    
    
     Who is responsible for releasing it?
    
    
     What happens if
    
    
     <strong class="source-inline">
      
       call2
      
     </strong>
    
    
     
      fails?
     
    
   </p>
   <p>
    
     The responsibility for memory release is ambiguous and, therefore, needs to be specified for every function or for every scope, to be more precise.
    
    
     The complexity of this problem increases with the complexity of programs and data flows.
    
    
     This would make most programmers using the other mainstream languages scratch their heads or completely ignore the responsibility and end up either with memory leaks or with calls to memory areas that have been
    
    
     
      already released.
     
    
   </p>
   <p>
    
     Java, C#, and Python solve all these issues without asking the programmer to be careful.
    
    
     Two techniques are helpful: reference counting and garbage collection.
    
    
     Reference counting works as follows: upon every call to copy the value, the reference count is increased.
    
    
     When getting out of scope, the reference count is decreased.
    
    
     When the reference count gets to 0, release the memory.
    
    
     Garbage collectors work similarly, only they run periodically and check also for circular references, ensuring that even convoluted memory structures get released correctly, albeit with
    
    
     
      a delay.
     
    
   </p>
   <p>
    
     Even back in
    
    <a id="_idIndexMarker007">
    </a>
    
     the 2000s, nothing was stopping us from implementing reference counting in C++.
    
    
     The design pattern is known as smart pointers and allows us to think less about
    
    
     
      these issues.
     
    
   </p>
   <p>
    
     In fact, C++ had from the very beginning yet another, more elegant way, to deal with this problem: pass-by-reference.
    
    
     There’s a good reason why pass-by-reference is the default way to pass objects around in Java, C#, and Python: it’s very natural and convenient.
    
    
     It allows you to create an object, allocate its memory, pass by reference, and the best part: its memory will automatically get released upon exiting the scope.
    
    
     Let’s look at a similar example to the one
    
    
     
      using pointers:
     
    
   </p>
   <pre class="source-code">
BigDataStructure data{};
call1(data);
call2(data);
call3(data);
...
void call1(BigDataStructure&amp; data){
    ...
}</pre>
   <p>
    
     This time, it doesn’t really matter what happens in
    
    <strong class="source-inline">
     
      call1
     
    </strong>
    
     ; the memory will be released correctly after exiting the scope in which data is initialized.
    
    
     The only limitation of reference types is that the memory allocated for the variable cannot be reallocated.
    
    
     Personally, I see
    
    <a id="_idIndexMarker008">
    </a>
    
     this as a big advantage, given that modifying data can get messy very quickly; in fact, I prefer to pass every value with
    
    <strong class="source-inline">
     
      const&amp;
     
    </strong>
    
     if possible.
    
    
     There are, however, limited applications for highly optimized polymorphic data structures that are enabled through
    
    
     
      memory reallocation.
     
    
   </p>
   <p>
    
     Looking at the preceding program, if we ignore the
    
    <strong class="source-inline">
     
      &amp;
     
    </strong>
    
     sign from
    
    <strong class="source-inline">
     
      call1
     
    </strong>
    
     and rename the functions to fit their corresponding conventions, we could also read Java or C#.
    
    
     So, C++ could have been close to these languages from the beginning.
    
    
     Why isn’t it still
    
    
     
      similar enough?
     
    
   </p>
   <p>
    
     Well, you can’t escape memory management in C++.
    
    
     The preceding code would not make a Java or C# programmer think of anything more; we established that C++ is different, though.
    
    
     The standardization committee realized that there are situations when we need to allocate memory in one function and release it in another and that it would be ideal to avoid using pointers to do that.
    
    
     Enter
    
    
     
      move semantics.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Move semantics is a key feature introduced in C++11 to enhance performance by eliminating unnecessary copying of objects.
    
    
     It allows resources to be transferred from one object to another without creating a copy, which is especially beneficial for objects that manage dynamic memory, file handles, or other resources.
    
    
     To utilize move semantics, you need to implement a move constructor, which initializes a new object by transferring resources from a
    
    <strong class="source-inline">
     
      rvalue
     
    </strong>
    
     (temporary object) to the new object, and a move assignment operator, which transfers resources from a rvalue to an existing object for your class.
    
    
     The
    
    <strong class="source-inline">
     
      std::move
     
    </strong>
    
     function is a utility that casts an object to a rvalue reference, enabling move semantics.
    
    
     To help, the compiler creates the move constructor in
    
    
     
      certain conditions.
     
    
   </p>
   <p>
    
     See in the following example how we might use move semantics to move the scope of a variable to the
    
    
     
      function process:
     
    
   </p>
   <pre class="source-code">
BigDataStructure data{};
process(data);
...
void process(BigDataStructure&amp;&amp; data){
}</pre>
   <p>
    
     Not much
    
    <a id="_idIndexMarker009">
    </a>
    
     seems different, other than using two ampersand signs.
    
    
     The behavior is, however, very different.
    
    
     The scope of the
    
    <strong class="source-inline">
     
      data
     
    </strong>
    
     variable moves into the called function, and
    
    <strong class="source-inline">
     
      process
     
    </strong>
    
     , and the memory gets released upon
    
    
     
      exiting it.
     
    
   </p>
   <p>
    
     Move semantics allows us to avoid copying big data values and to transfer the responsibility for releasing the memory into called functions.
    
    
     This is a unique mechanic between the languages we’ve discussed until now.
    
    
     To my best knowledge, the only other programming languages to implement these mechanics are the other contenders for systems programming: Rust
    
    
     
      and Swift.
     
    
   </p>
   <p>
    
     This proves to us that, as much as C++ resembles Java or C# nowadays, it does require programmers to understand in more detail the way memory allocation and release work.
    
    
     We may have gotten over the exam questions that focused on minor syntax differences with big effects, but we haven’t gotten over the need to learn more than for the
    
    
     
      other languages.
     
    
   </p>
   <p>
    
     Memory management, while a big part of the conversation, is not the only thing that makes things more difficult when learning C++.
    
    
     A few things are different and can be a bit annoying
    
    
     
      for newcomers:
     
    
   </p>
   <ul>
    <li>
     
      The need for
     
     <strong class="source-inline">
      
       #ifndef
      
     </strong>
     
      preprocessor directives or the non-standard but often supported
     
     <strong class="source-inline">
      
       #pragma once
      
     </strong>
     
      to ensure that files are only
     
     
      
       included once
      
     
    </li>
    <li>
     
      Separate
     
     <strong class="source-inline">
      
       .h
      
     </strong>
     
      files along with arbitrary rules of what goes in
     
     <strong class="source-inline">
      
       .h
      
     </strong>
     
      and what goes
     
     
      
       in
      
     
     
      <strong class="source-inline">
       
        .cpp
       
      </strong>
     
    </li>
    <li>
     
      The very weird way to define interfaces with
     
     
      <strong class="source-inline">
       
        virtual methodName()=0
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     While we can ensure we use all these contraptions with rules and guidelines automatically applied by modern IDEs, their presence begs the question: Why are they
    
    
     
      still needed?
     
    
   </p>
   <p>
    
     Barring the aforementioned, it is much more difficult to get over the fact that there’s no easy way to build a program and add external references.
    
    
     Java, with all its faults, has a single compiler, and Maven/Gradle as standard tools for dependency management that allow the download and integration of a new library with a simple command.
    
    
     C#, although fraught with the same issue for a long time, has pretty much standardized the community-created NuGet command for getting external libraries.
    
    
     Python features the standard
    
    <strong class="source-inline">
     
      pip
     
    </strong>
    
     command for
    
    
     
      managing packages.
     
    
   </p>
   <p>
    
     With C++, you
    
    <a id="_idIndexMarker010">
    </a>
    
     need to work more.
    
    
     Unlike Java and C#, which count on a virtual machine, your C++ programs need to be compiled for every supported target, and each target matched with the right libraries.
    
    
     Of course, there are tools for that.
    
    
     The two package managers I’ve heard mentioned the most are Conan and
    
    <strong class="source-inline">
     
      vcpkg
     
    </strong>
    
     .
    
    
     For build systems, CMake seems quite popular.
    
    
     The trouble is that none of these tools are standard.
    
    
     While it’s true that neither Java’s Maven/Gradle nor C#’s NuGet have started as a standard, their integration in tools and fast adoption means that they are the de facto standard today.
    
    
     C++ has a little bit more to go until this part of the language matures.
    
    
     We’ll talk more about these issues in a separate chapter, but it’s obvious that part of the C++ confusion is also generated by this complexity in trying out
    
    
     
      simple programs.
     
    
   </p>
   <p>
    
     We looked at various complications in C++ compared to other languages, and we saw that while the language has gotten easier, it’s still not as easy as Java or C#.
    
    
     But the core question is: Is C++ very difficult to learn?
    
    
     To examine this, let’s look at three methods beginners can use to
    
    
     
      learn C++.
     
    
   </p>
   <h1 id="_idParaDest-19">
    <a id="_idTextAnchor018">
    </a>
    
     The Stroustrup method for learning C++
    
   </h1>
   <p>
    
     While the C++ standard
    
    <a id="_idIndexMarker011">
    </a>
    
     has evolved toward simplicity, many of the learning materials have stayed the same.
    
    
     I can imagine it’s difficult to keep up with the C++ standard, given its newfound speed of change after 2010, and a question always remains: How much code is using the latest standard?
    
    
     Won’t students need to learn anyway the old ways of C++ so that they can deal with decades-old
    
    
     
      code bases?
     
    
   </p>
   <p>
    
     Despite this possibility, we must progress at some point, and Bjarne Stroustrup thought the same.
    
    
     The third edition of his book,
    
    <em class="italic">
     
      Programming: Principles and Practice using C++
     
    </em>
    
     (
    
    <a href="https://www.amazon.com/Programming-Principles-Practice-Using-C-ebook/dp/B0CW1HXMH3/">
     
      https://www.amazon.com/Programming-Principles-Practice-Using-C-ebook/dp/B0CW1HXMH3/
     
    </a>
    
     ), published in 2024, is addressed to beginners in programming and takes them through the C++ language.
    
    
     The book is a very good introduction to C++, and it’s accompanied by examples and a slide deck useful for anyone who wants to teach or learn
    
    
     
      the language.
     
    
   </p>
   <p>
    
     It’s interesting to note that Stroustrup does not shy away from the topic of pointers and memory management, instead discussing the minimum necessary and immediately showing the ways modern C++
    
    
     
      avoids them.
     
    
   </p>
   <p>
    
     Let’s take as
    
    <a id="_idIndexMarker012">
    </a>
    
     an example the slides associated with
    
    
     <em class="italic">
      
       Chapter 16
      
     </em>
    
    
     that focus on arrays.
    
    
     They start with an explanation of naked arrays, their connection with pointers, and how you can get in trouble when using pointers.
    
    
     Then, alternatives are introduced:
    
    <strong class="source-inline">
     
      vector
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      set
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      map
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      unordered_map
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      array
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      unique_ptr
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      shared_ptr
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      span
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      not_null
     
    </strong>
    
     .
    
    
     The deck ends with an example of a palindrome implementation in multiple ways, comparing the differences in safety and brevity of the code.
    
    
     Therefore, the whole purpose of this chapter is to show the various issues with arrays and pointers and how STL structures help avoid
    
    
     
      these issues.
     
    
   </p>
   <p>
    
     The resulting code closely resembles the Java or C# variants.
    
    
     However, Stroustrup points out that pointer arithmetic is still useful to implement data structures.
    
    
     In other words, use it sparingly and only when you really need
    
    
     
      heavy optimizations.
     
    
   </p>
   <p>
    
     We conclude, therefore, that the language creator doesn’t shy away from pointers and memory management but is focused on removing a lot of the potential issues that come with it.
    
    
     This enables C++ programmers to care less about memory management than in the C++ 98 era, but still a little bit more than in Java
    
    
     
      or C#.
     
    
   </p>
   <p>
    
     The question still stands: Could beginners learn C++ without thinking much about pointers?
    
    
     Another teaching method seems to prove this is possible – if we want to train library users instead of
    
    
     
      library creators.
     
    
   </p>
   <h1 id="_idParaDest-20">
    <a id="_idTextAnchor019">
    </a>
    
     The Kate Gregory method – don’t teach C
    
   </h1>
   <p>
    
     In a talk at
    
    <em class="italic">
     
      CppCon 2015
     
    </em>
    
     (
    
    <a href="https://www.youtube.com/watch?v=YnWhqhNdYyk">
     
      https://www.youtube.com/watch?v=YnWhqhNdYyk
     
    </a>
    
     ), Kate Gregory
    
    <a id="_idIndexMarker013">
    </a>
    
     makes the point that C is not a prerequisite for learning C++ and that it’s actively harming the learning process to start by teaching
    
    <strong class="source-inline">
     
      printf
     
    </strong>
    
     , naked arrays, and char pointers on the first day of a beginner
    
    
     
      C++ course.
     
    
   </p>
   <p>
    
     Instead, her proposal is to start with the objects available in STL.
    
    
     The string and vector classes are quite clear to beginners, and operator overloading is also a very natural way to use these objects.
    
    
     Beginners expect that
    
    <strong class="source-inline">
     
      "abcd" + "efg"
     
    </strong>
    
     will result in
    
    <strong class="source-inline">
     
      "abcdefg"
     
    </strong>
    
     ; there’s no need to explain the intricacies of operator overloading so that they can write simple programs.
    
    
     Moreover, this approach completely avoids discussing destructors and
    
    
     
      memory cleanup.
     
    
   </p>
   <p>
    
     She continues by
    
    <a id="_idIndexMarker014">
    </a>
    
     arguing that teaching lambdas to beginners is also quite easy if you start with an example.
    
    
     Consider trying to find a value in a vector.
    
    
     A first approach would be using a
    
    <strong class="source-inline">
     
      for
     
    </strong>
    
     loop that you can skim over.
    
    
     The second method is using
    
    <strong class="source-inline">
     
      std::find
     
    </strong>
    
     .
    
    
     But what if we want to find an even value in a
    
    <strong class="source-inline">
     
      vector&lt;int&gt;
     
    </strong>
    
     instance?
    
    
     This introduces lambdas very naturally in the conversation, without a whole discussion on all the possible ways to
    
    
     
      write them.
     
    
   </p>
   <p>
    
     With this method, she argues that beginners will be able to use existing libraries.
    
    
     They will have some gaps in their knowledge, and in the case of a course for programmers working on a specific code base, you might need to have a section that introduces them to reading specific idioms useful for their work.
    
    
     And if you want these programmers to become library creators, then you need a more advanced course that dives into the depths of memory management and optimizations possible
    
    
     
      with pointers.
     
    
   </p>
   <p>
    
     My 15 years of experience training people in complex skills tell me that this teaching method is very good.
    
    
     A key thing in training is to understand your target audience and do your best to avoid the curse of knowledge – the fact that you don’t remember how it was not to know something you know very well today.
    
    
     This method caters to the beginner mind by providing fast wins and good progression and giving the learners the courage to write code.
    
    
     So, it’s definitely an improvement in the methods of
    
    
     
      learning C++.
     
    
   </p>
   <p>
    
     However, this is not the only way to learn a language.
    
    
     It’s a structured way, yes, but exploration is an important part of learning.
    
    
     There’s a way to learn C++ through exploration that uses a method typically
    
    <a id="_idIndexMarker015">
    </a>
    
     associated with Twitter clashes:
    
    <strong class="bold">
     
      Test Driven
     
    </strong>
    
     <strong class="bold">
      
       Development
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       TDD
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <h1 id="_idParaDest-21">
    <a id="_idTextAnchor020">
    </a>
    
     The test-driven method for learning C++
    
   </h1>
   <p>
    
     Learning
    
    <a id="_idIndexMarker016">
    </a>
    
     from books or structured courses is only one method; the other one is through personal exploration.
    
    
     Imagine learning C++, but instead of having to look through a bunch of code examples first, write the code as you think it should work and learn incrementally the differences between your intuition and the actual language.
    
    
     In fact, people naturally combine these two methods even when going through a structured
    
    
     
      learning course.
     
    
   </p>
   <p>
    
     One downside of learning through exploration is that it’s hard to understand your progress, and you might often end up in difficult spots.
    
    
     A method comes to the
    
    
     
      rescue: TDD.
     
    
   </p>
   <p>
    
     TDD is a
    
    <a id="_idIndexMarker017">
    </a>
    
     counter-intuitive, effective method for incremental design.
    
    
     Its simplest description is
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Step 1, also known as red
      
     </strong>
     
      : Write one test that fails and shows the next case that needs to
     
     
      
       be implemented
      
     
    </li>
    <li>
     <strong class="bold">
      
       Step 2, also known as green
      
     </strong>
     
      : Write the simplest code to make the test pass (and keep all the other
     
     
      
       tests passing)
      
     
    </li>
    <li>
     <strong class="bold">
      
       Step 3, also known as refactor
      
     </strong>
     
      : Refactor the production code and the test code
     
     
      
       to simplify.
      
     
    </li>
   </ul>
   <p>
    
     This red-green-refactor cycle repeats in very small cycles (often 5-10 minutes) until all the behaviors associated with the current feature or user story have
    
    
     
      been implemented.
     
    
   </p>
   <p class="callout-heading">
    
     Addressing TDD misconceptions
    
   </p>
   <p class="callout">
    
     Personally, I am
    
    <a id="_idIndexMarker018">
    </a>
    
     a fan of TDD, and I’ve used it for more than 10 years with a lot of success.
    
    
     In fact, I used TDD to write the sample code for this book.
    
    
     However, I know that TDD has been received with mixed feelings by the industry.
    
    
     Part of it is a failure in imagination, a common question being: How can I write a test for a method that doesn’t exist?
    
    
     Well, pretty much the same way in which you write code that hasn’t existed before: you imagine it’s there and focus on the desired inputs and outputs.
    
    
     Other criticism comes from failing to understand what TDD really is and how it works.
    
    
     Examples of faux TDD failures often involve starting with edge cases and showing that things get complicated very quickly when you should start with happy-path cases.
    
    
     Claims of TDD slowing down development are credible, but the truth is that this method helps us be more thorough and calculated, thus avoiding issues that are usually caught much later in the process and fixed with much sweat and stress.
    
    
     Finally, TDD is not a method for designing high-performing algorithms, but it can help you find a first solution that you later optimize with the help of a
    
    
     
      test suite.
     
    
   </p>
   <p>
    
     To understand how to learn a programming language with a modified TDD cycle, we need to clarify two things about TDD.
    
    
     First, TDD is counter-intuitive because it requires a prolonged focus on the problem domain, while most programming courses teach us how to deal with the solution domain.
    
    
     Second, TDD is a method for incremental design; that is, finding a code structure that solves a specific problem in a step-by-step manner instead of all at once.
    
    
     These two characteristics make TDD the best fit for learning a new programming language, with
    
    
     
      some support.
     
    
   </p>
   <p>
    
     Imagine
    
    <a id="_idIndexMarker019">
    </a>
    
     that instead of learning the whole thing about C++ before being able to run a program, you just learn how to write a test.
    
    
     That is easy enough because tests tend to use a small subset of the language.
    
    
     Moreover, running the tests gives you instant feedback: failure or red when something is not right and success or green when everything is working fine.
    
    
     Finally, this allows you to explore a problem once you have one or more tests and figure out how to write the code such that the compiler understands it – which is what you want when you learn a language.
    
    
     It might be a bit problematic to figure out the error messages, particularly in C++, but if you have a person (or maybe an AI in the future) to ask for help, you’ll learn a lot on your way and see the green bar whenever you’ve learned
    
    
     
      something new.
     
    
   </p>
   <p>
    
     This method has been tested on a small scale, and it worked remarkably well.
    
    
     Here’s how a learning session might work
    
    
     
      for C++.
     
    
   </p>
   <h2 id="_idParaDest-22">
    <a id="_idTextAnchor021">
    </a>
    
     Setup
    
   </h2>
   <p>
    
     At least two actors
    
    <a id="_idIndexMarker020">
    </a>
    
     are involved in the learning process; we’ll call them the coach and the student.
    
    
     I prefer using a coach instead of the instructor because the goal is to guide the students on their own learning path rather than teach them
    
    
     
      things directly.
     
    
   </p>
   <p>
    
     I will discuss the rest of the session as if only a student is involved.
    
    
     A similar setup can work with multiple students
    
    
     
      as well.
     
    
   </p>
   <p>
    
     The first thing the actors need to do is to set a goal.
    
    
     Typically, the goal is to learn a minimum of C++, but it can also be learning more about a specific topic – for example,
    
    <strong class="source-inline">
     
      std::vector
     
    </strong>
    
     or
    
    
     
      STL algorithms.
     
    
   </p>
   <p>
    
     In terms of the technical setup, this process works best with the two people watching the code on the same monitor and working side by side.
    
    
     While this is best done in person, remote is possible as well through
    
    
     
      various tools.
     
    
   </p>
   <p>
    
     To start, the coach needs to set up a simple project composed of a test library, a production code file, and a test file.
    
    
     A simple way to run the tests needs to be provided, either as a button click, a keyboard shortcut, or a simple command.
    
    
     The setup I recommend for C++ is to use
    
    <strong class="source-inline">
     
      doctest
     
    </strong>
    
     (
    
    <a href="https://github.com/doctest/doctest">
     
      https://github.com/doctest/doctest
     
    </a>
    
     ), a header file-only test library
    
    <a id="_idIndexMarker021">
    </a>
    
     that is very fast and supports a lot of the features needed
    
    
     
      for production.
     
    
   </p>
   <p>
    
     Here’s the simplest structure for
    
    
     
      this project:
     
    
   </p>
   <ul>
    <li>
     
      A test
     
     
      
       file,
      
     
     
      <strong class="source-inline">
       
        test.cpp
       
      </strong>
     
    </li>
    <li>
     
      A production header
     
     
      
       file,
      
     
     
      <strong class="source-inline">
       
        prod.h
       
      </strong>
     
    </li>
    <li>
     
      A
     
     
      <strong class="source-inline">
       
        doctest.h
       
      </strong>
     
     
      
       file
      
     
    </li>
    <li>
     
      A Makefile allowing us to run
     
     
      
       the tests
      
     
    </li>
   </ul>
   <p>
    
     A
    
    <strong class="source-inline">
     
      production cpp
     
    </strong>
    
     file may also be needed depending on the
    
    
     
      learning objectives.
     
    
   </p>
   <p>
    
     The coach also needs to
    
    <a id="_idIndexMarker022">
    </a>
    
     provide an example of a first test that fails and show how to run the tests.
    
    
     The student takes over the keyboard and runs the test as well.
    
    
     This test can be very simple, as in the
    
    
     
      following example:
     
    
   </p>
   <pre class="source-code">
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest.h" 
#include "prod.h"
TEST_CASE("Test Example"){
    auto anAnswer = answer();
    CHECK(anAnswer);
}</pre>
   <p>
    
     The production header shows
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
bool answer(){
    return true;
}</pre>
   <p>
    
     The first order of business is then to make the test pass.
    
    
     The question the coach will keep asking the student is: “How do you think this will work?
    
    
     Write whatever you find intuitive.”
    
    
     If the student finds the correct answer, great!
    
    
     If not, show the correct answer and explain
    
    
     
      the reasons.
     
    
   </p>
   <p>
    
     This example
    
    <a id="_idIndexMarker023">
    </a>
    
     is very useful because it introduces a few elements of the language and shows them working: a function declaration, a variable, a test, and a return value.
    
    
     At the same time, the process is very nice because it gives the student a measure of progress: tests passing is good, and tests not passing means there’s something
    
    
     
      to learn.
     
    
   </p>
   <p>
    
     With all these done, it’s time to enter the
    
    
     
      exploration phase.
     
    
   </p>
   <h2 id="_idParaDest-23">
    <a id="_idTextAnchor022">
    </a>
    
     Exploring the language
    
   </h2>
   <p>
    
     There are
    
    <a id="_idIndexMarker024">
    </a>
    
     two ways to explore a programming language in this manner: through simple problems that introduce concepts one by one, also known as koans, or through solving a more
    
    
     
      complex problem.
     
    
   </p>
   <p>
    
     Either way, the method stays the same: first, the coach writes a simple test or helps the student write a simple test that fails.
    
    
     Then, the student is asked to write the solution that seems most intuitive to them.
    
    
     Tests are run, and if they don’t pass, the coach needs to explain what is not working.
    
    
     Either the coach or the student makes the change, and when the tests pass, the step ends with
    
    
     
      clear progress.
     
    
   </p>
   <p>
    
     During this process, it’s important to focus on the next natural step for the student.
    
    
     If the student has specific questions or curiosities, the next test can treat these instead of going through a scripted process.
    
    
     This adaptive way of learning helps students feel in charge, and the process gives them an illusion of autonomy that eventually turns
    
    
     
      into reality.
     
    
   </p>
   <h2 id="_idParaDest-24">
    <a id="_idTextAnchor023">
    </a>
    
     What about memory issues?
    
   </h2>
   <p>
    
     We spent
    
    <a id="_idIndexMarker025">
    </a>
    
     some time in this chapter discussing the fact that C++ programmers need to learn more about memory management than their colleagues using other mainstream programming languages.
    
    
     How can they learn memory management with this method?
    
    
     Tests will not catch memory issues,
    
    
     
      will they?
     
    
   </p>
   <p>
    
     Indeed, we want students to learn that they need to care about memory from the very beginning.
    
    
     Therefore, memory checks need to be integrated into our test suite.
    
    
     We have two options to do this: either use a specialized tool or select a test library that can detect
    
    
     
      memory issues.
     
    
   </p>
   <p>
    
     A specialized tool such as
    
    <strong class="source-inline">
     
      valgrind
     
    </strong>
    
     is easy to integrate into our process.
    
    
     See the following example of
    
    
     
      a Makefile:
     
    
   </p>
   <pre class="source-code">
check-leaks: test 
    valgrind -q --leak-check=full ./out/tests
test: test.cpp
    ./out/tests
test.cpp: .FORCE
    mkdir -p out/
    g++ -std=c++20 -I"src/" "test.cpp"  -o out/tests
.FORCE:</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      test.cpp
     
    </strong>
    
     target
    
    <a id="_idIndexMarker026">
    </a>
    
     is compiling the tests.
    
    
     The test target depends on
    
    <strong class="source-inline">
     
      test.cpp
     
    </strong>
    
     and runs the tests.
    
    
     And the first target,
    
    <strong class="source-inline">
     
      check-leaks
     
    </strong>
    
     , runs
    
    <strong class="source-inline">
     
      valgrind
     
    </strong>
    
     automatically with options to show errors only when they come up so that students don’t get overwhelmed.
    
    
     When running
    
    <strong class="source-inline">
     
      make
     
    </strong>
    
     without any parameters, the first target is picked, so the memory analysis is done
    
    
     
      by default.
     
    
   </p>
   <p>
    
     Assume we are running the tests with a memory leak, as in the
    
    
     
      following example:
     
    
   </p>
   <pre class="source-code">
bool answer(){
int* a = new int(4);
return true;
}</pre>
   <p>
    
     We are immediately greeted by
    
    
     
      this output:
     
    
   </p>
   <pre class="source-code">
==========================================================[doctest] test cases: 1 | 1 passed | 0 failed | 0 skipped
[doctest] assertions: 1 | 1 passed | 0 failed |
[doctest] Status: SUCCESS!
valgrind -q --leak-check=full ./out/tests
[doctest] doctest version is "2.4.11"
[doctest] run with "--help" for options
==========================================================[doctest] test cases: 1 | 1 passed | 0 failed | 0 skipped
[doctest] assertions: 1 | 1 passed | 0 failed |
[doctest] Status: SUCCESS!
==48400== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==48400==    at 0x4849013: operator new(unsigned long) ==48400==    by 0x124DC9: answer()</pre>
   <p>
    
     This output provides enough information for a conversation with
    
    
     
      the student.
     
    
   </p>
   <p>
    
     The second
    
    <a id="_idIndexMarker027">
    </a>
    
     option is to use a test library that already has memory leak detection implemented.
    
    
     CppUTest (
    
    <a href="http://cpputest.github.io/">
     
      http://cpputest.github.io/
     
    </a>
    
     ) is
    
    <a id="_idIndexMarker028">
    </a>
    
     such a library, and it also has the advantage of supporting C and working for
    
    
     
      embedded code.
     
    
   </p>
   <p>
    
     With these tools at our disposal, it’s now clear that this method works for teaching C++ to anyone who wants to try it or to dive deeper into specific parts, using exploration as
    
    
     
      a method.
     
    
   </p>
   <p>
    
     Now that we learned two methods for learning C++ today, let’s go back to understanding what C++’s niche is and why it necessarily needs to be more complex than
    
    
     
      other languages.
     
    
   </p>
   <h1 id="_idParaDest-25">
    <a id="_idTextAnchor024">
    </a>
    
     With great power…
    
   </h1>
   <p>
    
     If there’s one thing I’d like you to take away from this chapter, it’s that C++ is a very powerful language, and
    
    <a id="_idIndexMarker029">
    </a>
    
     with this power comes the programmer’s responsibility to use the appropriate level
    
    
     
      of abstraction.
     
    
   </p>
   <p>
    
     I’m certain that a team of C++ programmers starting a new project today that solves specific business problems, using only the latest standard and specific libraries, can write code safely and with good performance without worrying about memory issues more than their Java or C# colleagues.
    
    
     In fact, it’s likely their code will resemble quite closely that written in other languages, with the expectation of
    
    
     
      better performance.
     
    
   </p>
   <p>
    
     However, even such a team will occasionally face a choice: Do we implement a slightly less performant solution using the existing tools offered to us by STL, or do we optimize it to the stars by recursing to pointer arithmetic, move semantics, or custom memory management?
    
    
     This is when the power of C++ requires an equally high level of responsibility, care, and
    
    
     
      deep understanding.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     As I’m writing these words, the world is still in turmoil after the CrowdStrike incident of July 2024.
    
    
     The causes for the incident are still not 100% clear, despite the official disclosure (
    
    <a href="https://www.scmagazine.com/news/crowdstrike-discloses-new-technical-details-behind-outage">
     
      https://www.scmagazine.com/news/crowdstrike-discloses-new-technical-details-behind-outage
     
    </a>
    
     ).
    
    
     Either way, it looks as if a memory access error in a C++ program has led to a kernel panic in Windows systems around the world, grounding planes, stopping money transfers, and – most dreadfully – shutting down emergency services.
    
    
     Of course, this change should have never reached production, but it’s nonetheless a reminder of how much the world depends on software and of the consequences of the misuse of the power
    
    
     
      of C++.
     
    
   </p>
   <h1 id="_idParaDest-26">
    <a id="_idTextAnchor025">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we examined a statement:
    
    <em class="italic">
     
      C++ is very difficult to learn
     
    </em>
    
     .
    
    
     So,
    
    
     
      is it?
     
    
   </p>
   <p>
    
     We looked at the history of C++ and how initially it was indeed a challenge to write even the simplest of programs.
    
    
     We saw how Java, C#, and Python deal with some of the problems programmers face with C++ and how the C++ standard has evolved unexpectedly fast in the past 15 years to remove
    
    
     
      its impediments.
     
    
   </p>
   <p>
    
     While you can write C++ code that resembles Java or C# today, you will likely still need to understand memory management, a fact we exemplified using move semantics.
    
    
     We also saw that the methods for learning C++ have evolved with the language and with the times, with Stroustrup introducing pointers only in passing and quickly switching to higher-level structures available in STL.
    
    
     We saw that a modified TDD cycle can help people learn C++ in an exploratory manner and without getting overwhelmed by the complexity of error messages and
    
    
     
      the language.
     
    
   </p>
   <p>
    
     We also pointed out that C++ has a disadvantage when it comes to tooling and portability.
    
    
     Installing a new dependency is a whole thing in C++, unlike Java, Python, or C#, which provide one de facto standard command to manage packages.
    
    
     This can turn off wannabe C++ programmers who make a
    
    
     
      deeper analysis.
     
    
   </p>
   <p>
    
     Finally, despite the progress in the standard, we cannot forget the sheer size of C++ code that is in the world and not up to the latest standard.
    
    
     Chances are, even if you learn modern C++, your work will involve dealing with older code sooner
    
    
     
      or later.
     
    
   </p>
   <p>
    
     We conclude, therefore, that C++ is still more difficult to learn than Java, C#, or Python, but that it’s closer than it’s ever been and that the power of the language continues to be attractive for a subset
    
    
     
      of programmers.
     
    
   </p>
   <p>
    
     In the next chapter, Ferenc will examine the question: Is every C++ program standard?
    
    
     Or, maybe programmers are driven by solving problems and picking the solutions that work best in their environment, ignoring the standard or even creating idioms that end up in the standard after
    
    
     
      a while.
     
    
   </p>
  </div>
 </body></html>