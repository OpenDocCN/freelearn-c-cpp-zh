<html><head></head><body>
  <div id="_idContainer006">
   <h1 class="chapter-number" id="_idParaDest-14">
    <a id="_idTextAnchor013">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     1
    </span>
   </h1>
   <h1 id="_idParaDest-15">
    <a id="_idTextAnchor014">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     C++ Is Very Difficult to Learn
    </span>
   </h1>
   <p class="Italic-Subheading">
    <em class="italic">
     <span class="koboSpan" id="kobo.3.1">
      If you want to channel all
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.4.1">
       its power
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     A prevalent belief between both C++ programmers and those who only hear about the language is that it’s very difficult to learn it.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     But what is this based upon?
    </span>
    <span class="koboSpan" id="kobo.5.3">
     We will see that part of this belief is historical; not only has C++ been around for almost 30 years, but the initial standard was both unforgiving to programmers and required a lot of knowledge of memory management.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     Modern C++, after consequent improvements brought by the new standards C++11, C++ 14, C++ 17, C++ 20, and C++ 23, allows programmers to write code that is very similar to Java or C#.
    </span>
    <span class="koboSpan" id="kobo.5.5">
     However, C++ has its specific niche in systems programming, which makes it necessary for programmers to learn more topics than necessary for other
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      modern languages.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.9.1">
      Why is C++ perceived as difficult
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.10.1">
       to learn?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      The hard parts of C++ and how to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       grasp them
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      The Stroustrup method for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       learning C++
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      The test-driven method for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       learning C++
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      With
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       great power…
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-16">
    <a id="_idTextAnchor015">
    </a>
    <span class="koboSpan" id="kobo.19.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.20.1">
     The code examples in this chapter can be found in the GitHub repository
    </span>
    <a href="https://github.com/PacktPublishing/Debunking-CPP-Myths">
     <span class="koboSpan" id="kobo.21.1">
      https://github.com/PacktPublishing/Debunking-CPP-Myths
     </span>
    </a>
    <span class="koboSpan" id="kobo.22.1">
     in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.23.1">
      ch1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.24.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.24.2">
     The code uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.25.1">
      doctest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.26.1">
     (
    </span>
    <a href="https://github.com/doctest/doctest">
     <span class="koboSpan" id="kobo.27.1">
      https://github.com/doctest/doctest
     </span>
    </a>
    <span class="koboSpan" id="kobo.28.1">
     ) as a testing library,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.29.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.30.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.31.1">
      make
     </span>
    </strong>
    <span class="koboSpan" id="kobo.32.1">
     for compilation, and targets C++ 20.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     You will also need
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.33.1">
      valgrind
     </span>
    </strong>
    <span class="koboSpan" id="kobo.34.1">
     (
    </span>
    <a href="https://valgrind.org/">
     <span class="koboSpan" id="kobo.35.1">
      https://valgrind.org/
     </span>
    </a>
    <span class="koboSpan" id="kobo.36.1">
     ) to check for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      memory leaks.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-17">
    <a id="_idTextAnchor016">
    </a>
    <span class="koboSpan" id="kobo.38.1">
     Why is C++ perceived as difficult to learn?
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.39.1">
     The beginnings of C++ saw it
    </span>
    <a id="_idIndexMarker000">
    </a>
    <span class="koboSpan" id="kobo.40.1">
     as an extension to C, only using the new paradigm,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.41.1">
      object-oriented programming
     </span>
    </strong>
    <span class="koboSpan" id="kobo.42.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.43.1">
      OOP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.44.1">
     ), thus
    </span>
    <a id="_idIndexMarker001">
    </a>
    <span class="koboSpan" id="kobo.45.1">
     promising to solve the many problems of growing code bases.
    </span>
    <span class="koboSpan" id="kobo.45.2">
     This initial version of C++ is unforgiving; you, the programmer, had to deeply understand how memory allocation and release works and how pointer arithmetic works, as well as guard against a myriad of subtleties that you’d be likely to miss and that usually ended up in an unhelpful error message.
    </span>
    <span class="koboSpan" id="kobo.45.3">
     It didn’t help that the prevalent cultural zeitgeist of programmers back then was that a real programmer had to know all the intricacies of CPUs, RAM, various assembly languages, OS workings, and compilers.
    </span>
    <span class="koboSpan" id="kobo.45.4">
     It also didn’t help that the standardization committee did almost nothing to reduce the possibility of such errors for decades.
    </span>
    <span class="koboSpan" id="kobo.45.5">
     No wonder the fame of the language is following it almost 40 years later.
    </span>
    <span class="koboSpan" id="kobo.45.6">
     My experience learning it only helps to understand the struggles to learn the language
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      back then.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     I had my first touches with C++ during my polytechnics studies, in the 90s.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     They had left me both intrigued and puzzled.
    </span>
    <span class="koboSpan" id="kobo.47.3">
     I understood the power of the language, while it was actively fighting against me – or that’s how I perceived it.
    </span>
    <span class="koboSpan" id="kobo.47.4">
     I had to struggle to write code that worked.
    </span>
    <span class="koboSpan" id="kobo.47.5">
     I was not yet familiar with STL, which was yet to gain notoriety as part of the standard, so most of my first C++ programs dealt with pointer usage.
    </span>
    <span class="koboSpan" id="kobo.47.6">
     A common question at C++ exams was about differentiating between an array of pointers and a pointer to an array.
    </span>
    <span class="koboSpan" id="kobo.47.7">
     I can only imagine how helpful the complexities of the language were for building
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.48.1">
      exam questions!
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.49.1">
     For the record, see here the difference between pointer to array and array of pointers, a common exam question
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      for C++:
     </span>
    </span>
   </p>
   <p>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.51.1">
       int(*pointerToArrayOf10Numbers)[10];
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.52.1">
       int *arrayOfTenPointers[10]
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.53.1">
     I continued learning C++ through practice and from books I could find before the internet would make the knowledge available to everyone.
    </span>
    <span class="koboSpan" id="kobo.53.2">
     But the biggest jump in my understanding of the language was a project I worked on around the 2000s.
    </span>
    <span class="koboSpan" id="kobo.53.3">
     The project lead, a very technical Belgian man, set for us very clear guidelines and a process we had to follow to get the best C++ code possible.
    </span>
    <span class="koboSpan" id="kobo.53.4">
     This need for excellence did not come simply from his desires but from the project needs: we were building a NoSQL database engine many years before they would be given
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.54.1">
      this label.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.55.1">
     For this project, I had to study and know all the rules from the two seminal books on C++:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.56.1">
      Effective C++
     </span>
    </em>
    <span class="koboSpan" id="kobo.57.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.58.1">
      More Effective C++
     </span>
    </em>
    <span class="koboSpan" id="kobo.59.1">
     by Scott Meyers.
    </span>
    <span class="koboSpan" id="kobo.59.2">
     The two books document in total 90 guidelines for C++ programmers, ranging from issues of resource initialization and release to minute ways to improve performance, inheritance, exception handling, and so on.
    </span>
    <span class="koboSpan" id="kobo.59.3">
     This is also when I started using STL extensively, although the standard library was much more limited in scope than it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.60.1">
      is today.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.61.1">
     This newly
    </span>
    <a id="_idIndexMarker002">
    </a>
    <span class="koboSpan" id="kobo.62.1">
     acquired knowledge made my C++ programs more reliable and made me more productive.
    </span>
    <span class="koboSpan" id="kobo.62.2">
     An important contributing factor was the process we used in synergy with the wisdom of the two books.
    </span>
    <span class="koboSpan" id="kobo.62.3">
     We wrote unit tests, we performed design and code reviews, and we carefully crafted our code knowing that it would be dissected by a colleague before getting accepted in the code base.
    </span>
    <span class="koboSpan" id="kobo.62.4">
     This made our code quasi-bug-free and helped us implement complex features with high performance in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      reasonable time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.64.1">
     However, the language was still fighting against us.
    </span>
    <span class="koboSpan" id="kobo.64.2">
     We knew how to write good C++ code, only it required a level of attention and care that inevitably slowed us down.
    </span>
    <span class="koboSpan" id="kobo.64.3">
     Mastering C++ was not enough; the language had to give
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      something back.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.66.1">
     After this project, I left the C++ world and learned C# and managed C++, Java, PHP, Python, Haskell, JavaScript, and Groovy, to limit myself to those languages I’d used for professional programming.
    </span>
    <span class="koboSpan" id="kobo.66.2">
     While every programming language offered higher abstractions and fewer headaches compared to C++, I still had nostalgia for my formative years in programming.
    </span>
    <span class="koboSpan" id="kobo.66.3">
     The fact that I knew C++ and all the intricacies of memory management gave me a deep understanding of the inner workings of these other languages, allowing me to use them to their fullest.
    </span>
    <span class="koboSpan" id="kobo.66.4">
     Haskell proved to be very familiar to me since it was closely mapping the meta-programming techniques I’d learned from the seminal book by Andrei Alexandrescu,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.67.1">
      Modern C++ Design
     </span>
    </em>
    <span class="koboSpan" id="kobo.68.1">
     .
    </span>
    <span class="koboSpan" id="kobo.68.2">
     C++ was living on in my mind, not only as the first programming language I used professionally but also as a foundation for every other language I’ve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.69.1">
      used since.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.70.1">
     To my delight, around 2010, the news came that the C++ standardization committee was finally making bold and frequent changes to the language.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     The last C++ standard had been for many years C++ 98; suddenly we were seeing a new version every three years.
    </span>
    <span class="koboSpan" id="kobo.70.3">
     This rolling release of new versions of the standard allowed the introduction of the functional programming paradigm, of ranges, of new primitives for parallel and asynchronous programming, of move semantics.
    </span>
    <span class="koboSpan" id="kobo.70.4">
     But the biggest change for anyone who wants to learn C++ today is the simplification of memory management and the introduction of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.71.1">
      auto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.72.1">
     types.
    </span>
    <span class="koboSpan" id="kobo.72.2">
     The big breakthrough offered by these changes is that a Java or C# programmer can understand modern C++ programs, something we weren’t sure about back when Java and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      C# started.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     This means the
    </span>
    <a id="_idIndexMarker003">
    </a>
    <span class="koboSpan" id="kobo.75.1">
     language is much easier to learn today than in the 90s.
    </span>
    <span class="koboSpan" id="kobo.75.2">
     A good example of this change is the complete irrelevance of the old exam question on the difference between an array to pointers or a pointer to arrays; naked arrays can easily be replaced with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.76.1">
      vector&lt;&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     or a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.78.1">
      list&lt;&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.79.1">
     , while pointers are replaced with the more precise
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.80.1">
      shared_pointer&lt;&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.81.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.82.1">
      unique_pointer&lt;&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.83.1">
     .
    </span>
    <span class="koboSpan" id="kobo.83.2">
     This in turn reduces concerns related to allocation and release of memory for the pointers, thus both cleaning up the code and reducing the potential for the inscrutable error messages so prevalent in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.84.1">
      C++ 98.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.85.1">
     We can’t say, however, that the C++ language is as easy to learn as the other mainstream ones today.
    </span>
    <span class="koboSpan" id="kobo.85.2">
     Let’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.86.1">
      see why.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-18">
    <a id="_idTextAnchor017">
    </a>
    <span class="koboSpan" id="kobo.87.1">
     The hard parts of C++ and how to grasp them
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.88.1">
     Is C++ as easy to
    </span>
    <a id="_idIndexMarker004">
    </a>
    <span class="koboSpan" id="kobo.89.1">
     learn as Java, C#, PHP, JavaScript, or Python?
    </span>
    <span class="koboSpan" id="kobo.89.2">
     Despite all the language improvements, the answer is: most likely not.
    </span>
    <span class="koboSpan" id="kobo.89.3">
     The important question is: Should C++ be as easy to learn as all these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.90.1">
      other languages?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     The demise of C++ has been predicted for a very long time.
    </span>
    <span class="koboSpan" id="kobo.91.2">
     Java, then C#, and nowadays Rust were in turn touted as complete replacements for our venerable subject of debate.
    </span>
    <span class="koboSpan" id="kobo.91.3">
     Instead, each of them seems to carve their own niche while C++ is still leading in programs that require careful optimization or work in constrained environments.
    </span>
    <span class="koboSpan" id="kobo.91.4">
     It helps that millions of lines of C++ exist today, some of them decades old.
    </span>
    <span class="koboSpan" id="kobo.91.5">
     While some of them can be turned into cloud-native, serverless, or microservices architectures, there will always be problems better fit for the engineering style serviced
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.92.1">
      by C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.93.1">
     We conclude, therefore, that C++ has its own purpose in the world of development, and any new programming language faces a steep uphill battle to displace it.
    </span>
    <span class="koboSpan" id="kobo.93.2">
     This observation comes with its consequence: specific parts of C++ will necessarily be more difficult to grasp than other languages.
    </span>
    <span class="koboSpan" id="kobo.93.3">
     While Java or C# will spare you from thinking of memory allocation and what happens with the memory when you pass arguments to another method, C++ needs to take these issues head-on and give you the option to optimize your code as your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.94.1">
      context dictates.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.95.1">
     Therefore, if you want
    </span>
    <a id="_idIndexMarker005">
    </a>
    <span class="koboSpan" id="kobo.96.1">
     to understand C++, you can’t escape memory management.
    </span>
    <span class="koboSpan" id="kobo.96.2">
     Fortunately, it’s much less of an issue than it used
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.97.1">
      to be.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.98.1">
     Let’s analyze the differences by looking at how different languages manage memory allocation and release.
    </span>
    <span class="koboSpan" id="kobo.98.2">
     Java uses a
    </span>
    <a id="_idIndexMarker006">
    </a>
    <span class="koboSpan" id="kobo.99.1">
     full
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.100.1">
      object-oriented
     </span>
    </strong>
    <span class="koboSpan" id="kobo.101.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.102.1">
      OO
     </span>
    </strong>
    <span class="koboSpan" id="kobo.103.1">
     ) approach, in which every value is an object.
    </span>
    <span class="koboSpan" id="kobo.103.2">
     C# designers decided to use both value types that include the typical numeric values, chars, structs, and enums, and reference types that correspond to the objects.
    </span>
    <span class="koboSpan" id="kobo.103.3">
     In Python, every value is an object, and the type can be established later in the program.
    </span>
    <span class="koboSpan" id="kobo.103.4">
     All these three languages feature a garbage collector that deals with memory release.
    </span>
    <span class="koboSpan" id="kobo.103.5">
     The Python language uses a reference counting mechanism in addition to the garbage collector, thus allowing it to be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.104.1">
      optionally disabled.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.105.1">
     The C++ 98 standard didn’t provide any built-in mechanism for pointer release, instead providing the full power and responsibility for memory management to the programmer.
    </span>
    <span class="koboSpan" id="kobo.105.2">
     Unfortunately, this led to problems.
    </span>
    <span class="koboSpan" id="kobo.105.3">
     Suppose that you initialize a pointer and allocate a large area of memory for a value.
    </span>
    <span class="koboSpan" id="kobo.105.4">
     You then pass this pointer to other methods.
    </span>
    <span class="koboSpan" id="kobo.105.5">
     Who is responsible for releasing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.106.1">
      the memory?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.107.1">
     See, for example, the following simple
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.108.1">
      code sample:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.109.1">
BigDataStructure* pData = new pData();
call1(pData);
call2(pData);
call3(pData);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.110.1">
     Should the caller release the memory allocated in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.111.1">
      pData
     </span>
    </strong>
    <span class="koboSpan" id="kobo.112.1">
     ?
    </span>
    <span class="koboSpan" id="kobo.112.2">
     Should
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.113.1">
      call3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.114.1">
     do it?
    </span>
    <span class="koboSpan" id="kobo.114.2">
     What if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.115.1">
      call3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.116.1">
     calls another function with the same
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.117.1">
      pData
     </span>
    </strong>
    <span class="koboSpan" id="kobo.118.1">
     instance?
    </span>
    <span class="koboSpan" id="kobo.118.2">
     Who is responsible for releasing it?
    </span>
    <span class="koboSpan" id="kobo.118.3">
     What happens if
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.119.1">
       call2
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.120.1">
      fails?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.121.1">
     The responsibility for memory release is ambiguous and, therefore, needs to be specified for every function or for every scope, to be more precise.
    </span>
    <span class="koboSpan" id="kobo.121.2">
     The complexity of this problem increases with the complexity of programs and data flows.
    </span>
    <span class="koboSpan" id="kobo.121.3">
     This would make most programmers using the other mainstream languages scratch their heads or completely ignore the responsibility and end up either with memory leaks or with calls to memory areas that have been
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.122.1">
      already released.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.123.1">
     Java, C#, and Python solve all these issues without asking the programmer to be careful.
    </span>
    <span class="koboSpan" id="kobo.123.2">
     Two techniques are helpful: reference counting and garbage collection.
    </span>
    <span class="koboSpan" id="kobo.123.3">
     Reference counting works as follows: upon every call to copy the value, the reference count is increased.
    </span>
    <span class="koboSpan" id="kobo.123.4">
     When getting out of scope, the reference count is decreased.
    </span>
    <span class="koboSpan" id="kobo.123.5">
     When the reference count gets to 0, release the memory.
    </span>
    <span class="koboSpan" id="kobo.123.6">
     Garbage collectors work similarly, only they run periodically and check also for circular references, ensuring that even convoluted memory structures get released correctly, albeit with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.124.1">
      a delay.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.125.1">
     Even back in
    </span>
    <a id="_idIndexMarker007">
    </a>
    <span class="koboSpan" id="kobo.126.1">
     the 2000s, nothing was stopping us from implementing reference counting in C++.
    </span>
    <span class="koboSpan" id="kobo.126.2">
     The design pattern is known as smart pointers and allows us to think less about
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.127.1">
      these issues.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.128.1">
     In fact, C++ had from the very beginning yet another, more elegant way, to deal with this problem: pass-by-reference.
    </span>
    <span class="koboSpan" id="kobo.128.2">
     There’s a good reason why pass-by-reference is the default way to pass objects around in Java, C#, and Python: it’s very natural and convenient.
    </span>
    <span class="koboSpan" id="kobo.128.3">
     It allows you to create an object, allocate its memory, pass by reference, and the best part: its memory will automatically get released upon exiting the scope.
    </span>
    <span class="koboSpan" id="kobo.128.4">
     Let’s look at a similar example to the one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      using pointers:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.130.1">
BigDataStructure data{};
call1(data);
call2(data);
call3(data);
...
</span><span class="koboSpan" id="kobo.130.2">void call1(BigDataStructure&amp; data){
    ...
</span><span class="koboSpan" id="kobo.130.3">}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.131.1">
     This time, it doesn’t really matter what happens in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.132.1">
      call1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.133.1">
     ; the memory will be released correctly after exiting the scope in which data is initialized.
    </span>
    <span class="koboSpan" id="kobo.133.2">
     The only limitation of reference types is that the memory allocated for the variable cannot be reallocated.
    </span>
    <span class="koboSpan" id="kobo.133.3">
     Personally, I see
    </span>
    <a id="_idIndexMarker008">
    </a>
    <span class="koboSpan" id="kobo.134.1">
     this as a big advantage, given that modifying data can get messy very quickly; in fact, I prefer to pass every value with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.135.1">
      const&amp;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.136.1">
     if possible.
    </span>
    <span class="koboSpan" id="kobo.136.2">
     There are, however, limited applications for highly optimized polymorphic data structures that are enabled through
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.137.1">
      memory reallocation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.138.1">
     Looking at the preceding program, if we ignore the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.139.1">
      &amp;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.140.1">
     sign from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.141.1">
      call1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.142.1">
     and rename the functions to fit their corresponding conventions, we could also read Java or C#.
    </span>
    <span class="koboSpan" id="kobo.142.2">
     So, C++ could have been close to these languages from the beginning.
    </span>
    <span class="koboSpan" id="kobo.142.3">
     Why isn’t it still
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.143.1">
      similar enough?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.144.1">
     Well, you can’t escape memory management in C++.
    </span>
    <span class="koboSpan" id="kobo.144.2">
     The preceding code would not make a Java or C# programmer think of anything more; we established that C++ is different, though.
    </span>
    <span class="koboSpan" id="kobo.144.3">
     The standardization committee realized that there are situations when we need to allocate memory in one function and release it in another and that it would be ideal to avoid using pointers to do that.
    </span>
    <span class="koboSpan" id="kobo.144.4">
     Enter
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      move semantics.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.146.1">
     Note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.147.1">
     Move semantics is a key feature introduced in C++11 to enhance performance by eliminating unnecessary copying of objects.
    </span>
    <span class="koboSpan" id="kobo.147.2">
     It allows resources to be transferred from one object to another without creating a copy, which is especially beneficial for objects that manage dynamic memory, file handles, or other resources.
    </span>
    <span class="koboSpan" id="kobo.147.3">
     To utilize move semantics, you need to implement a move constructor, which initializes a new object by transferring resources from a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      rvalue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     (temporary object) to the new object, and a move assignment operator, which transfers resources from a rvalue to an existing object for your class.
    </span>
    <span class="koboSpan" id="kobo.149.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      std::move
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     function is a utility that casts an object to a rvalue reference, enabling move semantics.
    </span>
    <span class="koboSpan" id="kobo.151.2">
     To help, the compiler creates the move constructor in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.152.1">
      certain conditions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.153.1">
     See in the following example how we might use move semantics to move the scope of a variable to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.154.1">
      function process:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.155.1">
BigDataStructure data{};
process(data);
...
</span><span class="koboSpan" id="kobo.155.2">void process(BigDataStructure&amp;&amp; data){
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.156.1">
     Not much
    </span>
    <a id="_idIndexMarker009">
    </a>
    <span class="koboSpan" id="kobo.157.1">
     seems different, other than using two ampersand signs.
    </span>
    <span class="koboSpan" id="kobo.157.2">
     The behavior is, however, very different.
    </span>
    <span class="koboSpan" id="kobo.157.3">
     The scope of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     variable moves into the called function, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.160.1">
      process
     </span>
    </strong>
    <span class="koboSpan" id="kobo.161.1">
     , and the memory gets released upon
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.162.1">
      exiting it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.163.1">
     Move semantics allows us to avoid copying big data values and to transfer the responsibility for releasing the memory into called functions.
    </span>
    <span class="koboSpan" id="kobo.163.2">
     This is a unique mechanic between the languages we’ve discussed until now.
    </span>
    <span class="koboSpan" id="kobo.163.3">
     To my best knowledge, the only other programming languages to implement these mechanics are the other contenders for systems programming: Rust
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.164.1">
      and Swift.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.165.1">
     This proves to us that, as much as C++ resembles Java or C# nowadays, it does require programmers to understand in more detail the way memory allocation and release work.
    </span>
    <span class="koboSpan" id="kobo.165.2">
     We may have gotten over the exam questions that focused on minor syntax differences with big effects, but we haven’t gotten over the need to learn more than for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.166.1">
      other languages.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     Memory management, while a big part of the conversation, is not the only thing that makes things more difficult when learning C++.
    </span>
    <span class="koboSpan" id="kobo.167.2">
     A few things are different and can be a bit annoying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.168.1">
      for newcomers:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.169.1">
      The need for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.170.1">
       #ifndef
      </span>
     </strong>
     <span class="koboSpan" id="kobo.171.1">
      preprocessor directives or the non-standard but often supported
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.172.1">
       #pragma once
      </span>
     </strong>
     <span class="koboSpan" id="kobo.173.1">
      to ensure that files are only
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.174.1">
       included once
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.175.1">
      Separate
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.176.1">
       .h
      </span>
     </strong>
     <span class="koboSpan" id="kobo.177.1">
      files along with arbitrary rules of what goes in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.178.1">
       .h
      </span>
     </strong>
     <span class="koboSpan" id="kobo.179.1">
      and what goes
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.180.1">
       in
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.181.1">
        .cpp
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.182.1">
      The very weird way to define interfaces with
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.183.1">
        virtual methodName()=0
       </span>
      </strong>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.184.1">
     While we can ensure we use all these contraptions with rules and guidelines automatically applied by modern IDEs, their presence begs the question: Why are they
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.185.1">
      still needed?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     Barring the aforementioned, it is much more difficult to get over the fact that there’s no easy way to build a program and add external references.
    </span>
    <span class="koboSpan" id="kobo.186.2">
     Java, with all its faults, has a single compiler, and Maven/Gradle as standard tools for dependency management that allow the download and integration of a new library with a simple command.
    </span>
    <span class="koboSpan" id="kobo.186.3">
     C#, although fraught with the same issue for a long time, has pretty much standardized the community-created NuGet command for getting external libraries.
    </span>
    <span class="koboSpan" id="kobo.186.4">
     Python features the standard
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.187.1">
      pip
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     command for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.189.1">
      managing packages.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.190.1">
     With C++, you
    </span>
    <a id="_idIndexMarker010">
    </a>
    <span class="koboSpan" id="kobo.191.1">
     need to work more.
    </span>
    <span class="koboSpan" id="kobo.191.2">
     Unlike Java and C#, which count on a virtual machine, your C++ programs need to be compiled for every supported target, and each target matched with the right libraries.
    </span>
    <span class="koboSpan" id="kobo.191.3">
     Of course, there are tools for that.
    </span>
    <span class="koboSpan" id="kobo.191.4">
     The two package managers I’ve heard mentioned the most are Conan and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      vcpkg
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     .
    </span>
    <span class="koboSpan" id="kobo.193.2">
     For build systems, CMake seems quite popular.
    </span>
    <span class="koboSpan" id="kobo.193.3">
     The trouble is that none of these tools are standard.
    </span>
    <span class="koboSpan" id="kobo.193.4">
     While it’s true that neither Java’s Maven/Gradle nor C#’s NuGet have started as a standard, their integration in tools and fast adoption means that they are the de facto standard today.
    </span>
    <span class="koboSpan" id="kobo.193.5">
     C++ has a little bit more to go until this part of the language matures.
    </span>
    <span class="koboSpan" id="kobo.193.6">
     We’ll talk more about these issues in a separate chapter, but it’s obvious that part of the C++ confusion is also generated by this complexity in trying out
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.194.1">
      simple programs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.195.1">
     We looked at various complications in C++ compared to other languages, and we saw that while the language has gotten easier, it’s still not as easy as Java or C#.
    </span>
    <span class="koboSpan" id="kobo.195.2">
     But the core question is: Is C++ very difficult to learn?
    </span>
    <span class="koboSpan" id="kobo.195.3">
     To examine this, let’s look at three methods beginners can use to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      learn C++.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-19">
    <a id="_idTextAnchor018">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     The Stroustrup method for learning C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     While the C++ standard
    </span>
    <a id="_idIndexMarker011">
    </a>
    <span class="koboSpan" id="kobo.199.1">
     has evolved toward simplicity, many of the learning materials have stayed the same.
    </span>
    <span class="koboSpan" id="kobo.199.2">
     I can imagine it’s difficult to keep up with the C++ standard, given its newfound speed of change after 2010, and a question always remains: How much code is using the latest standard?
    </span>
    <span class="koboSpan" id="kobo.199.3">
     Won’t students need to learn anyway the old ways of C++ so that they can deal with decades-old
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.200.1">
      code bases?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.201.1">
     Despite this possibility, we must progress at some point, and Bjarne Stroustrup thought the same.
    </span>
    <span class="koboSpan" id="kobo.201.2">
     The third edition of his book,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.202.1">
      Programming: Principles and Practice using C++
     </span>
    </em>
    <span class="koboSpan" id="kobo.203.1">
     (
    </span>
    <a href="https://www.amazon.com/Programming-Principles-Practice-Using-C-ebook/dp/B0CW1HXMH3/">
     <span class="koboSpan" id="kobo.204.1">
      https://www.amazon.com/Programming-Principles-Practice-Using-C-ebook/dp/B0CW1HXMH3/
     </span>
    </a>
    <span class="koboSpan" id="kobo.205.1">
     ), published in 2024, is addressed to beginners in programming and takes them through the C++ language.
    </span>
    <span class="koboSpan" id="kobo.205.2">
     The book is a very good introduction to C++, and it’s accompanied by examples and a slide deck useful for anyone who wants to teach or learn
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.206.1">
      the language.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.207.1">
     It’s interesting to note that Stroustrup does not shy away from the topic of pointers and memory management, instead discussing the minimum necessary and immediately showing the ways modern C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.208.1">
      avoids them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.209.1">
     Let’s take as
    </span>
    <a id="_idIndexMarker012">
    </a>
    <span class="koboSpan" id="kobo.210.1">
     an example the slides associated with
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.211.1">
       Chapter 16
      </span>
     </em>
    </span>
    <span class="koboSpan" id="kobo.212.1">
     that focus on arrays.
    </span>
    <span class="koboSpan" id="kobo.212.2">
     They start with an explanation of naked arrays, their connection with pointers, and how you can get in trouble when using pointers.
    </span>
    <span class="koboSpan" id="kobo.212.3">
     Then, alternatives are introduced:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.213.1">
      vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.214.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.215.1">
      set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.216.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.217.1">
      map
     </span>
    </strong>
    <span class="koboSpan" id="kobo.218.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.219.1">
      unordered_map
     </span>
    </strong>
    <span class="koboSpan" id="kobo.220.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.221.1">
      array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.222.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.223.1">
      string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.224.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.225.1">
      unique_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.227.1">
      shared_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.228.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.229.1">
      span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.230.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.231.1">
      not_null
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     .
    </span>
    <span class="koboSpan" id="kobo.232.2">
     The deck ends with an example of a palindrome implementation in multiple ways, comparing the differences in safety and brevity of the code.
    </span>
    <span class="koboSpan" id="kobo.232.3">
     Therefore, the whole purpose of this chapter is to show the various issues with arrays and pointers and how STL structures help avoid
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.233.1">
      these issues.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.234.1">
     The resulting code closely resembles the Java or C# variants.
    </span>
    <span class="koboSpan" id="kobo.234.2">
     However, Stroustrup points out that pointer arithmetic is still useful to implement data structures.
    </span>
    <span class="koboSpan" id="kobo.234.3">
     In other words, use it sparingly and only when you really need
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.235.1">
      heavy optimizations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.236.1">
     We conclude, therefore, that the language creator doesn’t shy away from pointers and memory management but is focused on removing a lot of the potential issues that come with it.
    </span>
    <span class="koboSpan" id="kobo.236.2">
     This enables C++ programmers to care less about memory management than in the C++ 98 era, but still a little bit more than in Java
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      or C#.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.238.1">
     The question still stands: Could beginners learn C++ without thinking much about pointers?
    </span>
    <span class="koboSpan" id="kobo.238.2">
     Another teaching method seems to prove this is possible – if we want to train library users instead of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      library creators.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-20">
    <a id="_idTextAnchor019">
    </a>
    <span class="koboSpan" id="kobo.240.1">
     The Kate Gregory method – don’t teach C
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     In a talk at
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.242.1">
      CppCon 2015
     </span>
    </em>
    <span class="koboSpan" id="kobo.243.1">
     (
    </span>
    <a href="https://www.youtube.com/watch?v=YnWhqhNdYyk">
     <span class="koboSpan" id="kobo.244.1">
      https://www.youtube.com/watch?v=YnWhqhNdYyk
     </span>
    </a>
    <span class="koboSpan" id="kobo.245.1">
     ), Kate Gregory
    </span>
    <a id="_idIndexMarker013">
    </a>
    <span class="koboSpan" id="kobo.246.1">
     makes the point that C is not a prerequisite for learning C++ and that it’s actively harming the learning process to start by teaching
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.247.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.248.1">
     , naked arrays, and char pointers on the first day of a beginner
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.249.1">
      C++ course.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.250.1">
     Instead, her proposal is to start with the objects available in STL.
    </span>
    <span class="koboSpan" id="kobo.250.2">
     The string and vector classes are quite clear to beginners, and operator overloading is also a very natural way to use these objects.
    </span>
    <span class="koboSpan" id="kobo.250.3">
     Beginners expect that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.251.1">
      "abcd" + "efg"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.252.1">
     will result in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.253.1">
      "abcdefg"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.254.1">
     ; there’s no need to explain the intricacies of operator overloading so that they can write simple programs.
    </span>
    <span class="koboSpan" id="kobo.254.2">
     Moreover, this approach completely avoids discussing destructors and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      memory cleanup.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.256.1">
     She continues by
    </span>
    <a id="_idIndexMarker014">
    </a>
    <span class="koboSpan" id="kobo.257.1">
     arguing that teaching lambdas to beginners is also quite easy if you start with an example.
    </span>
    <span class="koboSpan" id="kobo.257.2">
     Consider trying to find a value in a vector.
    </span>
    <span class="koboSpan" id="kobo.257.3">
     A first approach would be using a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.258.1">
      for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.259.1">
     loop that you can skim over.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     The second method is using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.260.1">
      std::find
     </span>
    </strong>
    <span class="koboSpan" id="kobo.261.1">
     .
    </span>
    <span class="koboSpan" id="kobo.261.2">
     But what if we want to find an even value in a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.262.1">
      vector&lt;int&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     instance?
    </span>
    <span class="koboSpan" id="kobo.263.2">
     This introduces lambdas very naturally in the conversation, without a whole discussion on all the possible ways to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.264.1">
      write them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.265.1">
     With this method, she argues that beginners will be able to use existing libraries.
    </span>
    <span class="koboSpan" id="kobo.265.2">
     They will have some gaps in their knowledge, and in the case of a course for programmers working on a specific code base, you might need to have a section that introduces them to reading specific idioms useful for their work.
    </span>
    <span class="koboSpan" id="kobo.265.3">
     And if you want these programmers to become library creators, then you need a more advanced course that dives into the depths of memory management and optimizations possible
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.266.1">
      with pointers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.267.1">
     My 15 years of experience training people in complex skills tell me that this teaching method is very good.
    </span>
    <span class="koboSpan" id="kobo.267.2">
     A key thing in training is to understand your target audience and do your best to avoid the curse of knowledge – the fact that you don’t remember how it was not to know something you know very well today.
    </span>
    <span class="koboSpan" id="kobo.267.3">
     This method caters to the beginner mind by providing fast wins and good progression and giving the learners the courage to write code.
    </span>
    <span class="koboSpan" id="kobo.267.4">
     So, it’s definitely an improvement in the methods of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.268.1">
      learning C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.269.1">
     However, this is not the only way to learn a language.
    </span>
    <span class="koboSpan" id="kobo.269.2">
     It’s a structured way, yes, but exploration is an important part of learning.
    </span>
    <span class="koboSpan" id="kobo.269.3">
     There’s a way to learn C++ through exploration that uses a method typically
    </span>
    <a id="_idIndexMarker015">
    </a>
    <span class="koboSpan" id="kobo.270.1">
     associated with Twitter clashes:
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.271.1">
      Test Driven
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.272.1">
       Development
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.273.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.274.1">
       TDD
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.275.1">
      ).
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-21">
    <a id="_idTextAnchor020">
    </a>
    <span class="koboSpan" id="kobo.276.1">
     The test-driven method for learning C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.277.1">
     Learning
    </span>
    <a id="_idIndexMarker016">
    </a>
    <span class="koboSpan" id="kobo.278.1">
     from books or structured courses is only one method; the other one is through personal exploration.
    </span>
    <span class="koboSpan" id="kobo.278.2">
     Imagine learning C++, but instead of having to look through a bunch of code examples first, write the code as you think it should work and learn incrementally the differences between your intuition and the actual language.
    </span>
    <span class="koboSpan" id="kobo.278.3">
     In fact, people naturally combine these two methods even when going through a structured
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.279.1">
      learning course.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.280.1">
     One downside of learning through exploration is that it’s hard to understand your progress, and you might often end up in difficult spots.
    </span>
    <span class="koboSpan" id="kobo.280.2">
     A method comes to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.281.1">
      rescue: TDD.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.282.1">
     TDD is a
    </span>
    <a id="_idIndexMarker017">
    </a>
    <span class="koboSpan" id="kobo.283.1">
     counter-intuitive, effective method for incremental design.
    </span>
    <span class="koboSpan" id="kobo.283.2">
     Its simplest description is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.284.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.285.1">
       Step 1, also known as red
      </span>
     </strong>
     <span class="koboSpan" id="kobo.286.1">
      : Write one test that fails and shows the next case that needs to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.287.1">
       be implemented
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.288.1">
       Step 2, also known as green
      </span>
     </strong>
     <span class="koboSpan" id="kobo.289.1">
      : Write the simplest code to make the test pass (and keep all the other
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.290.1">
       tests passing)
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.291.1">
       Step 3, also known as refactor
      </span>
     </strong>
     <span class="koboSpan" id="kobo.292.1">
      : Refactor the production code and the test code
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.293.1">
       to simplify.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.294.1">
     This red-green-refactor cycle repeats in very small cycles (often 5-10 minutes) until all the behaviors associated with the current feature or user story have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.295.1">
      been implemented.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.296.1">
     Addressing TDD misconceptions
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.297.1">
     Personally, I am
    </span>
    <a id="_idIndexMarker018">
    </a>
    <span class="koboSpan" id="kobo.298.1">
     a fan of TDD, and I’ve used it for more than 10 years with a lot of success.
    </span>
    <span class="koboSpan" id="kobo.298.2">
     In fact, I used TDD to write the sample code for this book.
    </span>
    <span class="koboSpan" id="kobo.298.3">
     However, I know that TDD has been received with mixed feelings by the industry.
    </span>
    <span class="koboSpan" id="kobo.298.4">
     Part of it is a failure in imagination, a common question being: How can I write a test for a method that doesn’t exist?
    </span>
    <span class="koboSpan" id="kobo.298.5">
     Well, pretty much the same way in which you write code that hasn’t existed before: you imagine it’s there and focus on the desired inputs and outputs.
    </span>
    <span class="koboSpan" id="kobo.298.6">
     Other criticism comes from failing to understand what TDD really is and how it works.
    </span>
    <span class="koboSpan" id="kobo.298.7">
     Examples of faux TDD failures often involve starting with edge cases and showing that things get complicated very quickly when you should start with happy-path cases.
    </span>
    <span class="koboSpan" id="kobo.298.8">
     Claims of TDD slowing down development are credible, but the truth is that this method helps us be more thorough and calculated, thus avoiding issues that are usually caught much later in the process and fixed with much sweat and stress.
    </span>
    <span class="koboSpan" id="kobo.298.9">
     Finally, TDD is not a method for designing high-performing algorithms, but it can help you find a first solution that you later optimize with the help of a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.299.1">
      test suite.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.300.1">
     To understand how to learn a programming language with a modified TDD cycle, we need to clarify two things about TDD.
    </span>
    <span class="koboSpan" id="kobo.300.2">
     First, TDD is counter-intuitive because it requires a prolonged focus on the problem domain, while most programming courses teach us how to deal with the solution domain.
    </span>
    <span class="koboSpan" id="kobo.300.3">
     Second, TDD is a method for incremental design; that is, finding a code structure that solves a specific problem in a step-by-step manner instead of all at once.
    </span>
    <span class="koboSpan" id="kobo.300.4">
     These two characteristics make TDD the best fit for learning a new programming language, with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.301.1">
      some support.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.302.1">
     Imagine
    </span>
    <a id="_idIndexMarker019">
    </a>
    <span class="koboSpan" id="kobo.303.1">
     that instead of learning the whole thing about C++ before being able to run a program, you just learn how to write a test.
    </span>
    <span class="koboSpan" id="kobo.303.2">
     That is easy enough because tests tend to use a small subset of the language.
    </span>
    <span class="koboSpan" id="kobo.303.3">
     Moreover, running the tests gives you instant feedback: failure or red when something is not right and success or green when everything is working fine.
    </span>
    <span class="koboSpan" id="kobo.303.4">
     Finally, this allows you to explore a problem once you have one or more tests and figure out how to write the code such that the compiler understands it – which is what you want when you learn a language.
    </span>
    <span class="koboSpan" id="kobo.303.5">
     It might be a bit problematic to figure out the error messages, particularly in C++, but if you have a person (or maybe an AI in the future) to ask for help, you’ll learn a lot on your way and see the green bar whenever you’ve learned
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.304.1">
      something new.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.305.1">
     This method has been tested on a small scale, and it worked remarkably well.
    </span>
    <span class="koboSpan" id="kobo.305.2">
     Here’s how a learning session might work
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.306.1">
      for C++.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-22">
    <a id="_idTextAnchor021">
    </a>
    <span class="koboSpan" id="kobo.307.1">
     Setup
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.308.1">
     At least two actors
    </span>
    <a id="_idIndexMarker020">
    </a>
    <span class="koboSpan" id="kobo.309.1">
     are involved in the learning process; we’ll call them the coach and the student.
    </span>
    <span class="koboSpan" id="kobo.309.2">
     I prefer using a coach instead of the instructor because the goal is to guide the students on their own learning path rather than teach them
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.310.1">
      things directly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.311.1">
     I will discuss the rest of the session as if only a student is involved.
    </span>
    <span class="koboSpan" id="kobo.311.2">
     A similar setup can work with multiple students
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.312.1">
      as well.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.313.1">
     The first thing the actors need to do is to set a goal.
    </span>
    <span class="koboSpan" id="kobo.313.2">
     Typically, the goal is to learn a minimum of C++, but it can also be learning more about a specific topic – for example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.314.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.315.1">
     or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.316.1">
      STL algorithms.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     In terms of the technical setup, this process works best with the two people watching the code on the same monitor and working side by side.
    </span>
    <span class="koboSpan" id="kobo.317.2">
     While this is best done in person, remote is possible as well through
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.318.1">
      various tools.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.319.1">
     To start, the coach needs to set up a simple project composed of a test library, a production code file, and a test file.
    </span>
    <span class="koboSpan" id="kobo.319.2">
     A simple way to run the tests needs to be provided, either as a button click, a keyboard shortcut, or a simple command.
    </span>
    <span class="koboSpan" id="kobo.319.3">
     The setup I recommend for C++ is to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.320.1">
      doctest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     (
    </span>
    <a href="https://github.com/doctest/doctest">
     <span class="koboSpan" id="kobo.322.1">
      https://github.com/doctest/doctest
     </span>
    </a>
    <span class="koboSpan" id="kobo.323.1">
     ), a header file-only test library
    </span>
    <a id="_idIndexMarker021">
    </a>
    <span class="koboSpan" id="kobo.324.1">
     that is very fast and supports a lot of the features needed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.325.1">
      for production.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.326.1">
     Here’s the simplest structure for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.327.1">
      this project:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.328.1">
      A test
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.329.1">
       file,
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.330.1">
        test.cpp
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.331.1">
      A production header
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.332.1">
       file,
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.333.1">
        prod.h
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.334.1">
      A
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.335.1">
        doctest.h
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.336.1">
       file
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.337.1">
      A Makefile allowing us to run
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.338.1">
       the tests
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.339.1">
     A
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.340.1">
      production cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.341.1">
     file may also be needed depending on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      learning objectives.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.343.1">
     The coach also needs to
    </span>
    <a id="_idIndexMarker022">
    </a>
    <span class="koboSpan" id="kobo.344.1">
     provide an example of a first test that fails and show how to run the tests.
    </span>
    <span class="koboSpan" id="kobo.344.2">
     The student takes over the keyboard and runs the test as well.
    </span>
    <span class="koboSpan" id="kobo.344.3">
     This test can be very simple, as in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.345.1">
      following example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.346.1">
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest.h" 
#include "prod.h"
TEST_CASE("Test Example"){
    auto anAnswer = answer();
    CHECK(anAnswer);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.347.1">
     The production header shows
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.348.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.349.1">
bool answer(){
    return true;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.350.1">
     The first order of business is then to make the test pass.
    </span>
    <span class="koboSpan" id="kobo.350.2">
     The question the coach will keep asking the student is: “How do you think this will work?
    </span>
    <span class="koboSpan" id="kobo.350.3">
     Write whatever you find intuitive.”
    </span>
    <span class="koboSpan" id="kobo.350.4">
     If the student finds the correct answer, great!
    </span>
    <span class="koboSpan" id="kobo.350.5">
     If not, show the correct answer and explain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.351.1">
      the reasons.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.352.1">
     This example
    </span>
    <a id="_idIndexMarker023">
    </a>
    <span class="koboSpan" id="kobo.353.1">
     is very useful because it introduces a few elements of the language and shows them working: a function declaration, a variable, a test, and a return value.
    </span>
    <span class="koboSpan" id="kobo.353.2">
     At the same time, the process is very nice because it gives the student a measure of progress: tests passing is good, and tests not passing means there’s something
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.354.1">
      to learn.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.355.1">
     With all these done, it’s time to enter the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.356.1">
      exploration phase.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-23">
    <a id="_idTextAnchor022">
    </a>
    <span class="koboSpan" id="kobo.357.1">
     Exploring the language
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.358.1">
     There are
    </span>
    <a id="_idIndexMarker024">
    </a>
    <span class="koboSpan" id="kobo.359.1">
     two ways to explore a programming language in this manner: through simple problems that introduce concepts one by one, also known as koans, or through solving a more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.360.1">
      complex problem.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.361.1">
     Either way, the method stays the same: first, the coach writes a simple test or helps the student write a simple test that fails.
    </span>
    <span class="koboSpan" id="kobo.361.2">
     Then, the student is asked to write the solution that seems most intuitive to them.
    </span>
    <span class="koboSpan" id="kobo.361.3">
     Tests are run, and if they don’t pass, the coach needs to explain what is not working.
    </span>
    <span class="koboSpan" id="kobo.361.4">
     Either the coach or the student makes the change, and when the tests pass, the step ends with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.362.1">
      clear progress.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.363.1">
     During this process, it’s important to focus on the next natural step for the student.
    </span>
    <span class="koboSpan" id="kobo.363.2">
     If the student has specific questions or curiosities, the next test can treat these instead of going through a scripted process.
    </span>
    <span class="koboSpan" id="kobo.363.3">
     This adaptive way of learning helps students feel in charge, and the process gives them an illusion of autonomy that eventually turns
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.364.1">
      into reality.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-24">
    <a id="_idTextAnchor023">
    </a>
    <span class="koboSpan" id="kobo.365.1">
     What about memory issues?
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.366.1">
     We spent
    </span>
    <a id="_idIndexMarker025">
    </a>
    <span class="koboSpan" id="kobo.367.1">
     some time in this chapter discussing the fact that C++ programmers need to learn more about memory management than their colleagues using other mainstream programming languages.
    </span>
    <span class="koboSpan" id="kobo.367.2">
     How can they learn memory management with this method?
    </span>
    <span class="koboSpan" id="kobo.367.3">
     Tests will not catch memory issues,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.368.1">
      will they?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.369.1">
     Indeed, we want students to learn that they need to care about memory from the very beginning.
    </span>
    <span class="koboSpan" id="kobo.369.2">
     Therefore, memory checks need to be integrated into our test suite.
    </span>
    <span class="koboSpan" id="kobo.369.3">
     We have two options to do this: either use a specialized tool or select a test library that can detect
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.370.1">
      memory issues.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.371.1">
     A specialized tool such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.372.1">
      valgrind
     </span>
    </strong>
    <span class="koboSpan" id="kobo.373.1">
     is easy to integrate into our process.
    </span>
    <span class="koboSpan" id="kobo.373.2">
     See the following example of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.374.1">
      a Makefile:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.375.1">
check-leaks: test 
    valgrind -q --leak-check=full ./out/tests
test: test.cpp
    ./out/tests
test.cpp: .FORCE
    mkdir -p out/
    g++ -std=c++20 -I"src/" "test.cpp"  -o out/tests
.FORCE:</span></pre>
   <p>
    <span class="koboSpan" id="kobo.376.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.377.1">
      test.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.378.1">
     target
    </span>
    <a id="_idIndexMarker026">
    </a>
    <span class="koboSpan" id="kobo.379.1">
     is compiling the tests.
    </span>
    <span class="koboSpan" id="kobo.379.2">
     The test target depends on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.380.1">
      test.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.381.1">
     and runs the tests.
    </span>
    <span class="koboSpan" id="kobo.381.2">
     And the first target,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.382.1">
      check-leaks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.383.1">
     , runs
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.384.1">
      valgrind
     </span>
    </strong>
    <span class="koboSpan" id="kobo.385.1">
     automatically with options to show errors only when they come up so that students don’t get overwhelmed.
    </span>
    <span class="koboSpan" id="kobo.385.2">
     When running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.386.1">
      make
     </span>
    </strong>
    <span class="koboSpan" id="kobo.387.1">
     without any parameters, the first target is picked, so the memory analysis is done
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.388.1">
      by default.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.389.1">
     Assume we are running the tests with a memory leak, as in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.390.1">
      following example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.391.1">
bool answer(){
int* a = new int(4);
return true;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.392.1">
     We are immediately greeted by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.393.1">
      this output:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.394.1">
==========================================================[doctest] test cases: 1 | 1 passed | 0 failed | 0 skipped
[doctest] assertions: 1 | 1 passed | 0 failed |
[doctest] Status: SUCCESS!
</span><span class="koboSpan" id="kobo.394.2">valgrind -q --leak-check=full ./out/tests
[doctest] doctest version is "2.4.11"
[doctest] run with "--help" for options
==========================================================[doctest] test cases: 1 | 1 passed | 0 failed | 0 skipped
[doctest] assertions: 1 | 1 passed | 0 failed |
[doctest] Status: SUCCESS!
</span><span class="koboSpan" id="kobo.394.3">==48400== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==48400==    at 0x4849013: operator new(unsigned long) ==48400==    by 0x124DC9: answer()</span></pre>
   <p>
    <span class="koboSpan" id="kobo.395.1">
     This output provides enough information for a conversation with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.396.1">
      the student.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.397.1">
     The second
    </span>
    <a id="_idIndexMarker027">
    </a>
    <span class="koboSpan" id="kobo.398.1">
     option is to use a test library that already has memory leak detection implemented.
    </span>
    <span class="koboSpan" id="kobo.398.2">
     CppUTest (
    </span>
    <a href="http://cpputest.github.io/">
     <span class="koboSpan" id="kobo.399.1">
      http://cpputest.github.io/
     </span>
    </a>
    <span class="koboSpan" id="kobo.400.1">
     ) is
    </span>
    <a id="_idIndexMarker028">
    </a>
    <span class="koboSpan" id="kobo.401.1">
     such a library, and it also has the advantage of supporting C and working for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.402.1">
      embedded code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.403.1">
     With these tools at our disposal, it’s now clear that this method works for teaching C++ to anyone who wants to try it or to dive deeper into specific parts, using exploration as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.404.1">
      a method.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.405.1">
     Now that we learned two methods for learning C++ today, let’s go back to understanding what C++’s niche is and why it necessarily needs to be more complex than
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.406.1">
      other languages.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-25">
    <a id="_idTextAnchor024">
    </a>
    <span class="koboSpan" id="kobo.407.1">
     With great power…
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.408.1">
     If there’s one thing I’d like you to take away from this chapter, it’s that C++ is a very powerful language, and
    </span>
    <a id="_idIndexMarker029">
    </a>
    <span class="koboSpan" id="kobo.409.1">
     with this power comes the programmer’s responsibility to use the appropriate level
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.410.1">
      of abstraction.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.411.1">
     I’m certain that a team of C++ programmers starting a new project today that solves specific business problems, using only the latest standard and specific libraries, can write code safely and with good performance without worrying about memory issues more than their Java or C# colleagues.
    </span>
    <span class="koboSpan" id="kobo.411.2">
     In fact, it’s likely their code will resemble quite closely that written in other languages, with the expectation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.412.1">
      better performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.413.1">
     However, even such a team will occasionally face a choice: Do we implement a slightly less performant solution using the existing tools offered to us by STL, or do we optimize it to the stars by recursing to pointer arithmetic, move semantics, or custom memory management?
    </span>
    <span class="koboSpan" id="kobo.413.2">
     This is when the power of C++ requires an equally high level of responsibility, care, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.414.1">
      deep understanding.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.415.1">
     Note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.416.1">
     As I’m writing these words, the world is still in turmoil after the CrowdStrike incident of July 2024.
    </span>
    <span class="koboSpan" id="kobo.416.2">
     The causes for the incident are still not 100% clear, despite the official disclosure (
    </span>
    <a href="https://www.scmagazine.com/news/crowdstrike-discloses-new-technical-details-behind-outage">
     <span class="koboSpan" id="kobo.417.1">
      https://www.scmagazine.com/news/crowdstrike-discloses-new-technical-details-behind-outage
     </span>
    </a>
    <span class="koboSpan" id="kobo.418.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.418.2">
     Either way, it looks as if a memory access error in a C++ program has led to a kernel panic in Windows systems around the world, grounding planes, stopping money transfers, and – most dreadfully – shutting down emergency services.
    </span>
    <span class="koboSpan" id="kobo.418.3">
     Of course, this change should have never reached production, but it’s nonetheless a reminder of how much the world depends on software and of the consequences of the misuse of the power
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.419.1">
      of C++.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-26">
    <a id="_idTextAnchor025">
    </a>
    <span class="koboSpan" id="kobo.420.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.421.1">
     In this chapter, we examined a statement:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.422.1">
      C++ is very difficult to learn
     </span>
    </em>
    <span class="koboSpan" id="kobo.423.1">
     .
    </span>
    <span class="koboSpan" id="kobo.423.2">
     So,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.424.1">
      is it?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.425.1">
     We looked at the history of C++ and how initially it was indeed a challenge to write even the simplest of programs.
    </span>
    <span class="koboSpan" id="kobo.425.2">
     We saw how Java, C#, and Python deal with some of the problems programmers face with C++ and how the C++ standard has evolved unexpectedly fast in the past 15 years to remove
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.426.1">
      its impediments.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.427.1">
     While you can write C++ code that resembles Java or C# today, you will likely still need to understand memory management, a fact we exemplified using move semantics.
    </span>
    <span class="koboSpan" id="kobo.427.2">
     We also saw that the methods for learning C++ have evolved with the language and with the times, with Stroustrup introducing pointers only in passing and quickly switching to higher-level structures available in STL.
    </span>
    <span class="koboSpan" id="kobo.427.3">
     We saw that a modified TDD cycle can help people learn C++ in an exploratory manner and without getting overwhelmed by the complexity of error messages and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      the language.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.429.1">
     We also pointed out that C++ has a disadvantage when it comes to tooling and portability.
    </span>
    <span class="koboSpan" id="kobo.429.2">
     Installing a new dependency is a whole thing in C++, unlike Java, Python, or C#, which provide one de facto standard command to manage packages.
    </span>
    <span class="koboSpan" id="kobo.429.3">
     This can turn off wannabe C++ programmers who make a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.430.1">
      deeper analysis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.431.1">
     Finally, despite the progress in the standard, we cannot forget the sheer size of C++ code that is in the world and not up to the latest standard.
    </span>
    <span class="koboSpan" id="kobo.431.2">
     Chances are, even if you learn modern C++, your work will involve dealing with older code sooner
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.432.1">
      or later.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.433.1">
     We conclude, therefore, that C++ is still more difficult to learn than Java, C#, or Python, but that it’s closer than it’s ever been and that the power of the language continues to be attractive for a subset
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.434.1">
      of programmers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.435.1">
     In the next chapter, Ferenc will examine the question: Is every C++ program standard?
    </span>
    <span class="koboSpan" id="kobo.435.2">
     Or, maybe programmers are driven by solving problems and picking the solutions that work best in their environment, ignoring the standard or even creating idioms that end up in the standard after
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.436.1">
      a while.
     </span>
    </span>
   </p>
  </div>
 </body></html>