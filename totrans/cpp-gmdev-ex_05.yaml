- en: Setting Up Your Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start with the basics of how a game is made and what
    basic graphical components the game requires. Since this book is going to be covering
    graphics with C++, we will mostly look at what is graphically required from the
    graphics engine in a game. We will also cover the sound system so that we can
    make the game more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: To create a basic graphics engine, we will be using the **Simple and Fast Multimedia
    Library** (**SFML**) since this includes most of the functionality that is needed
    to get a game up and running. The reason for choosing SFML is that it is very
    basic and easy to understand, unlike other engines and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create a window for our game and add animations to
    it. We will also learn how to create and control our player's movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of SFML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading SFML and configuring Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handing player movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of SFML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games and video games (unlike other entertainment media) actually involve loading
    various resources, such as images, videos, sound, font types, and more. SFML provides
    functions for loading all of these features into games.
  prefs: []
  type: TYPE_NORMAL
- en: SFML is cross-platform compatible, which implies that it permits you to develop
    and run games on diverse platforms. It also supports various languages other than
    C++. Additionally, it is open source, so you can take a look at the source code
    and add a feature to it (if it is not included).
  prefs: []
  type: TYPE_NORMAL
- en: 'SFML is broken down into five modules, which can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System**: This module directly interacts with a system such as Windows, which
    is essentially the **o****perating system** (**OS**) that it will use. Since SFML
    is cross-platform compatible and each OS is different in terms of how it handles
    data, this module takes care of interacting with the OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Window**: When rendering anything to the screen, the first thing we need
    is a viewport or a window. Once we have access to this, we can start sending our
    rendered scene to it. The window module takes care of how a window is created,
    how the input is handled, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphics**: After we have access to a window, we can use the graphics module
    to begin rendering our scene to the window. In SFML, the graphics module is primarily
    rendered using OpenGL and deals with 2D scene rendering only. Therefore, it can''t
    be used to make 3D games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audio**: The audio module is responsible for playing audio and audio streams,
    as well as recording audio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**: SFML also includes a networking library for sending and receiving
    data, which can be used for developing multiplayer games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading SFML and configuring Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are familiar with the basics, let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the SFML download page ([https://www.sfml-dev.org/download.php](https://www.sfml-dev.org/download.php.)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/65814d16-760b-4b41-b355-8e269710b1f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Select **SFML 2.5.1**. Alternatively, you can clone the repository and build
    the latest version using CMake.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download either the 32-bit or 64-bit version (depending on your OS) for Visual
    Studio 2017.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although we are going to be developing the game for Windows, you can download
    SFML for Linux or macOS from the same web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the downloaded ZIP file, you will see the following directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc138488-540c-41c0-b3a3-081fdc183027.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These directories can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bin`: This contains all the **dynamic link libraries** (**DLLs**) that are
    required for running all the SFML modules. This has a `.dll` file, which contains
    the debug and release versions. The debug version has a `-d` suffix at the end
    of the file. Files that don''t have this suffix are the release version `.dll`
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doc`: This contains the documentation for SFML provided in HTML format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`examples`: This contains examples we can use to implement the modules and
    features of SFML. It tells us how to open a window, include OpenGL, carry out
    networking, and how to create a basic pong-like game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: This contains all the header files for the modules. The graphics
    module has classes for creating sprites, loading textures, creating shapes, and
    more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib`: This contains all the library files that we will need in order to run
    SFML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also two files: `readme.md` and `license.md`. The license file indicates
    that SFML can be used for commercial purposes. Therefore, it can be altered and
    redistributed, provided that you don't claim that you created it.
  prefs: []
  type: TYPE_NORMAL
- en: To set up a Visual Studio project, create a new project called `SFMLProject`.
    In this Visual Studio project root directory, where `SFMLProject.vcxproj` is located,
    extract the `SFML-2.5.1` folder and place it here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, in the root directory, move all the `.dll` files from the `.bin` folder
    into the root directory. Your project root directory should look similar to the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9e2adfcc-5ba7-4ff8-9644-2bc7d108f23e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Visual Studio project, create a new `source.cpp` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open Project Properties by right-clicking on the project in the Solution
    Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the Win32 configuration is selected. Under Configuration Properties,
    select VC++ Directories. Add $(ProjectDir)\SFML-2.5.1\include to the Include Directories.
    Then, add $(ProjectDIr)\SFML-2.5.1\lib in Library Directories, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/80696d8b-ade1-4424-b7af-97c629910851.png)'
  prefs: []
  type: TYPE_IMG
- en: The `$(ProjectDir)` keyword always makes sure that files are searched with reference
    to the project directory, which is where the `.vcxproj` file is located. This
    makes the project portable and able to run on any Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to set what libraries we want to use; select Input from the Linker dropdown
    menu and type in the following `.lib` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec65240f-e234-4388-8ff4-8683652e3140.png)'
  prefs: []
  type: TYPE_IMG
- en: Although we won't be using `sfml-network-d.lib` in this book, it is better to
    include it so that, if you do want to make a multiplayer game later, then you
    will already be set up for it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've completed the setup, we can finally start typing some code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we draw anything, the first thing we need is a window so that we can
    display something on the screen. Let''s create a window:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `source.cpp` file, include the `Graphics.hpp` file to gain
    access to the SFML graphics library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the main function, which will be the application''s main entry point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To create the window, we have to specify the size of the window that we want
    to create. SFML has a `Vector2f` data type, which takes an `x` and a `y` value
    and uses them to define the size of the window that we will be using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Between `include` and `main`, add the following line of code. Create a variable
    called `viewSize` and set the `x` and `y` values to `1024` and `768`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The assets for the game are created for the resolution, so I am using this view
    size; we also need to specify a `viewMode` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`viewMode` is an SFML class that sets the width and height of the window. It
    also gets the bits that are required to represent a color value in a pixel. `viewMode`
    also obtains the different resolutions that your monitor supports so that you
    can let the user set the resolution of the game to glorious 4K resolution if they
    desire.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the view mode, add the following code after setting the `viewSize` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can finally create a window. The window is created using the `RenderWindow`
    class. The `RenderWindow` constructor takes three parameters: a `viewMode` parameter,
    a window name parameter, and a `Style` parameter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have already created a `viewMode` parameter and we can pass in a window
    name here using a string. The third parameter, `Style`. `Style`, is an `enum` value;
    we can add a number of values, called a bitmask, to create the window style that
    we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sf::style::Titlebar`: This adds a title bar to the top of the window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sf::style::Fullscreen`: This creates a full-screen mode window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sf::style::Default`: This is the default style that combines the ability to
    resize a window, close it, and add a title bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a default-style window. First, create the window using the following
    command and add it after the creation of the `viewMode` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` class, we will create a `while` loop, which handles the main
    game loop for our game. This will check whether or not the window is open so that
    we can add some keyboard events by updating and rendering the objects in the scene.
    The `while` loop will run as long as the window is open. In the `main` function,
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the application. Here, you have your not-so-interesting game with a
    window that has a white background. Hey, at least you have a window now! To display
    something here, we have to clear the window and display whatever we draw in every
    frame.  This is done using the `clear` and `display` functions.
  prefs: []
  type: TYPE_NORMAL
- en: We have to call `window.clear()` before we can render the scene and then call
    `window.display()` afterward to display the scene objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `while` loop, add the `clear` and `display` functions. Game objects
    will be drawn between the `clear` function and the `display` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clear` function takes in a clear color. Here, we are passing in the color
    red as a value into the function. This function fills in the whole window with
    this solid color value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4202f8f9-7655-403d-beab-f571306cec60.png)'
  prefs: []
  type: TYPE_IMG
- en: Drawing shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SFML provides us with the functionality to draw basic shapes such as a rectangle,
    circle, and triangle. The shape can be set to a certain size and has functions,
    such as `fillColor`, `Position`, and `Origin`, so that we can set the color, the
    position of the shape in the viewport, and the origin around which the shape can
    rotate respectively. Let''s take a look at an example of a rectangular shape:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `while` loop, add the following code to set up the rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a `Rectangle` parameter of the `RectangleShape` type and named
    it `rect`. The constructor of `RectangleShape` takes in the size of the rectangle.
    Its size is `500` by `300`. Then, we set the color of the rectangle to yellow.
    After this, we set the position of the rectangle to the center of the viewport
    and set the origin to the center of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw the rectangle, we have to call the `window.draw()` function and pass
    the rectangle into it. Make sure that you call this function between the `clear`
    and `display` functions in the `while` loop. Now, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the project; you will see a yellow rectangle in a red viewport, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9efb88d6-b2f6-4ae1-a98f-9ab5d9f53a25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we set the position to `(0, 0)`, you will see where the origin is for the
    2D rectangle in SFML—it is in the top left corner of the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ffda409-1467-4cde-87fe-8d5ce8fa778e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Move it back to the center of the viewport by undoing the previous action.
    Then, set the rectangle to the center of the viewport again, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add a few more shapes, such as a circle and a triangle. We can
    create a circle using the `CircleShape` class, whereas we can create a triangle
    using the `ConvexShape` class. Before the main loop, we will create a circle by
    using `CircleShape` and `Triangle` with `ConvexShape`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `CircleShape` class takes only one parameter (which is the radius of the
    circle), in comparison to the rectangle, which takes two parameters. We set the
    color of the circle to green using the `setFIllColor` function, and then set its
    position and origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the triangle, we use the `ConvexShape` class. To create a shape,
    we specify the `setPointCount`, which takes one parameter. We will use it to specify
    how many points will make up the shape. Next, using the `setPoint` function, we
    set the location of the points. This takes two parameters: the first is the index
    of the point and the second is the location of the point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the triangle, we use three points: the first, with an index of `0` and
    a location of `(-100, 0)`; the second, with an index of `1` and a location of
    `(0, -100)`; and the third, with an index of `2` and a location of `(100, 0)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to set the color of the triangle. We do this by setting the values
    of the red, green, blue, and alpha values. Colors in SFML are 8-bit integer values.
    This means that each color range is between 0 and 255, where 0 is black and 255
    is the maximum color range. So, when we set the color of the triangle to `triangle.setFillColor(sf::Color(128,
    0, 128, 255));`, red is half of its maximum range, there is no green, blue is
    also half of its maximum range, and alpha is `255`, making the triangle fully
    opaque. Then, we set the position of the triangle so that it's at the center of
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we draw the circle and triangle. Call the `draw` function for the circle
    and triangle after drawing the rectangle, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bc59e484-d415-4dac-9c27-8baf8f7f5a2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that, when creating the triangle, the second point was created with a
    negative *y* value of `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the triangle is pointing upward. This means that the *+y* axis is
    pointing downward. You will find that this is mostly the case in 2D frameworks.
    Furthermore, the origin for the scene is in the top-left corner, so the coordinate
    system is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfe38702-fcdf-4381-b183-15686c0cd830.png)'
  prefs: []
  type: TYPE_IMG
- en: It is also important to note that the drawing order matters. Drawing happens
    from back to front. So, the first shape that's drawn will be behind the shapes
    that are drawn later in the same location. Objects that are drawn later simply
    draw over the earlier objects, in the same way that an artist would draw in real
    life when painting on a canvas. So, make sure that you draw the bigger objects
    first and then draw the smaller ones later. If you draw the smaller objects before
    the bigger ones, then the smaller objects will be behind the bigger objects and
    you won't be able to see them. Make sure this doesn't happen as you won't get
    any errors and everything in the code will be correct, so you won't know if something's
    gone wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A sprite is a rectangle with a picture applied to it. You may be wondering,
    *why not just use a picture?* Of course, we do load a picture up, then we won''t
    be able to move or rotate it. Therefore, we apply a picture or texture to a rectangle
    that is able to move and rotate, making it look as if the picture is doing so.
    Let''s learn how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we will be loading images into our game project, which is in the root
    directory of the project, let's create a folder called `Assets`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this folder, create another folder called `graphics`, and then copy and
    paste the `sky.png` file into the `graphics` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73547c73-e482-4051-8ea6-4255b56d8cba.png)'
  prefs: []
  type: TYPE_IMG
- en: To create sprites, we use the `Sprite` class from SFML. The `Sprite` class takes
    in a texture. Then, the picture is loaded using the `Texture` class. While drawing,
    you need to call `window.draw.(sprite)` to draw the sprite. Let's take a look
    at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a `Texture` class called `skyTexture` and a `Sprite` class called `skySprite`
    globally. This should be done after the creation of the `RenderWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function called `init` in the `source.cpp` file that appears right
    before the `main` function. Since we don''t want the `main` function to be cluttered,
    we will add the code to initialize `skyTexture` and `skySprite` to it. In the
    `init` function, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we load the `skyTexture` function by calling the `loadFromFile` function.
    We pass in the path and filename of the file that we want to load. Here, we want
    to load the `sky.png` file from the `Assets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `setTexture` function of the sprite and pass the `skyTexture` function
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, create a new function called `draw()` above the `main` and `init` functions.
    We call draw (`skySprite`) in it in order to draw the sprite, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to call `init()` at the beginning of the `main` function and `draw()`
    in the `while` loop that we added to the `main` function. You can remove all the
    code that was used for creating and drawing the shapes from the `main` function.
    Your `main` function should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afd3616f-cc49-4c28-a5e2-d82b246818d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Praise the sun! Lo and behold, we have the sky texture loaded and have drawn
    it as a sprite in the window.
  prefs: []
  type: TYPE_NORMAL
- en: I have included a background texture picture as well, called `bg.png`, which
    is available in the `Assets` folder of this chapter's project. Try and load the
    texture and draw the texture in the same way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I named the variables of the background texture and sprite `bgTexture` and `bgSprite`,
    respectively, and drew the `bgSprite` variable into the scene. Don't forget to
    add the `bg.png` file to the `Assets/graphics` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your scene should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db72e296-c03e-40bd-a81b-14fe9ddf80fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, add another sprite called `heroSprite` and load in the picture with `heroTexture`.
    Set the origin of the sprite to its center and place it in the middle of the scene.
    The `hero.png` file image is provided here, so make sure you place it in the `Assets/graphics`
    folder. Now, declare `heroSprite` and `heroTexture`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To set the origin of the sprite, we take the textures and the height and divide
    them by `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the `draw` function, draw the `heroSprite` sprite, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our hero will now appear in the scene, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2dfe1e8c-a587-4105-b894-c837d2da6aae.png)'
  prefs: []
  type: TYPE_IMG
- en: Keyboard input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is great that we are able to add shapes, sprites, and textures; however,
    computer games, by nature, are interactive. We will need to allow players to use
    keyboard inputs so that they can access the game's content. But how do we know
    which button the player is pressing? Well, that is handled through the polling
    of events. Polling just checks the status of the keys regularly; events are used
    to check whether an event was triggered, such as the closing of the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: SFML provides the `sf::Event` class so that we can poll events. We can use the
    `pollEvent` function of the window to check for events that may be occurring,
    such as a player pressing a button.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new function called `updateInput()`. Here, we will create a new object
    of the `sf::Event` class called `event`. We will create a `while` loop called `window.pollEvent` and
    then pass in the `event` variable to check for events.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have been using *Shift* + *F5* or the stop button in Visual Studio to
    stop the application. One of the basic things we can do is check whether the *Esc*
    key has been pressed. If it has been pressed, we want to close the window. To
    do this, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the `while` loop, we need to check whether the event key code is that of
    the *Esc* key code, or whether the event is `Event::closed`. Then, we call the
    `window.close()` function to close the window. When we close the window, it shuts
    down the application.
  prefs: []
  type: TYPE_NORMAL
- en: Call the `updateInput()` function in the main `while` loop before the `window.clear()`
    function. Now, when you press *Esc* while the application is running, it will
    close. SFML doesn't limit inputs just to keyboards; it also provides functionality
    for mouse, joystick, and touch input.
  prefs: []
  type: TYPE_NORMAL
- en: Handing player movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have access to the player''s keyboard, we can learn how to move
    game objects. Let''s move the player character to the right when the right arrow
    key is pressed on the keyboard. We will stop moving the hero when the right arrow
    key is released:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a global `Vector2f` called `playerPosition`, right after `heroSprite`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Boolean data type called `playerMoving` and set it to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `updateInput` function, we will check whether the right key has been
    pressed or released. If the button is pressed, we set `playerMoving` to `true`.
    If the button is released, then we set `playerMoving` to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `updateInput` function should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To update the objects in the scene, we will create a function called `update`,
    which will take a float called `dt`. This stands for delta time and refers to
    the time that has passed between the previous update and the current update call.
    In the `update` function, we will check whether the player is moving. If the player
    is moving, then we will move the position of the player in the *+x* direction
    and multiply this by `dt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason we multiply by delta time is because if we don't, then the update
    will not be time-dependent, but processor-dependent instead. If you don't multiply
    the position by `dt`, then the update will happen faster on a faster PC and will
    be slower on a slower PC. So, make sure that any movement is always multiplied
    by `dt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` function should look as follows. Make sure that this function
    appears before the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the `main` function, create an object of the `sf::Clock` type
    called `Clock`. The `Clock` class takes care of getting the system clock and allows
    us to get the delta time in seconds, milliseconds, or microseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `while` loop, after calling `updateInput()`, create a variable called
    `dt` of the `sf::Time` type and set the `dt` variable by calling `clock.restart().`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, call the `update` function and pass in `dt.asSeconds()`, which will give
    the delta time as 60 frames per second, which is approximately .0167 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `main` function should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run the project and press the right arrow key on the keyboard,
    the player will start moving right, and will stop when you release the right arrow
    key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44a97710-1da7-4ba3-8fb2-3ee7edef437b.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to set up SFML so that we can start creating
    a game. We covered the five basic modules that make up SFML, and also looked at
    creating shapes using SFML and adding the background and player sprite to the
    scene. We also added keyboard input and used this to make the player character
    move within the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create the basic skeleton of the game. We will
    also move the player character to a separate class and add some basic physics
    to the character to allow them to jump in the game.
  prefs: []
  type: TYPE_NORMAL
