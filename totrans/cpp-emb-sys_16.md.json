["```cpp\ntypedef struct\n{\n  __IO uint32_t CR;         /* Address offset: 0x00 */\n  __IO uint32_t CFGR;      /* Address offset: 0x04 */\n  __IO uint32_t CIR;       /* Address offset: 0x08 */\n  __IO uint32_t APB2RSTR;  /* Address offset: 0x0C */\n  __IO uint32_t APB1RSTR;  /* Address offset: 0x10 */\n  __IO uint32_t AHBENR;    /* Address offset: 0x14 */ \n  __IO uint32_t APB2ENR;   /* Address offset: 0x18 */ \n  __IO uint32_t APB1ENR;   /* Address offset: 0x1C */  \n  __IO uint32_t BDCR;      /* Address offset: 0x20 */  \n  __IO uint32_t CSR;       /* Address offset: 0x24 */   \n  __IO uint32_t AHBRSTR;   /* Address offset: 0x28 */  \n  __IO uint32_t CFGR2;     /* Address offset: 0x2C */\n  __IO uint32_t CFGR3;     /* Address offset: 0x30 */\n  __IO uint32_t CR2;       /* Address offset: 0x34 */\n} RCC_TypeDef; \n```", "```cpp\n#define PERIPH_BASE           0x40000000UL\n/*!< Peripheral memory map */\n#define APBPERIPH_BASE        PERIPH_BASE\n#define AHBPERIPH_BASE       (PERIPH_BASE + 0x00020000UL)\n/*!< AHB peripherals */\n#define RCC_BASE            (AHBPERIPH_BASE + 0x00001000UL)\n/*!< Peripheral_declaration */\n#define RCC                 ((RCC_TypeDef *) RCC_BASE) \nSystemInit function:\n```", "```cpp\n/* Set HSION bit */\nRCC->CR |= (uint32_t)0x00000001U; \n```", "```cpp\n/* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */\nRCC->CFGR &= (uint32_t)0x08FFB80CU; \n```", "```cpp\nstruct read_access{};\nstruct write_access{};\nstruct read_write_access : read_access, write_access {};\ntemplate<std::uintptr_t Address, typename Access = read_write_access, typename T = std::uint32_t>\nstruct reg {\ntemplate <typename Access_ = Access>\nstatic std::enable_if_t<std::is_base_of_v<read_access, Access_>, T> \nread()\n{\n    return *reinterpret_cast<volatile T*>(Address);\n}\ntemplate <typename Access_ = Access>\nstatic std::enable_if_t<std::is_base_of_v<write_access, Access_>, void>\nwrite(T val)\n{\n    *reinterpret_cast<volatile T*>(Address) = val;\n}\n}; \n```", "```cpp\nusing rcc = reg<0x40021000>;\nauto val = rcc::read(); // ok\nrcc::write(0xDEADBEEF); // ok\nusing rcc_read = reg<0x40021000, read_access>;\nauto val = rcc_read::read(); // ok\nrcc_read::write(0xDEADBEEF); // compiler-error, no write access\nusing rcc_write = reg<0x40021000, write_access>;\nauto val = rcc_write::read(); // compiler-error, no read access\nrcc_write::write(0xDEADBEEF); // ok \n```", "```cpp\n$ cmake -B build -DCMAKE_BUILD_TYPE=Release -DMAIN_CPP_FILE_NAME=main_basic_reg.cpp\n$ cmake --build build --target run_in_renode \n```", "```cpp\ntemplate<typename BitField, typename Reg, typename T>\nconcept BitFieldConcept =\n    std::is_same_v<Reg, typename BitField::reg> &&\n    std::is_enum_v<typename BitField::value> &&\n    std::is_same_v<std::underlying_type_t<typename\nBitField::value>, T>;\ntemplate<std::uintptr_t Address, typename Access = read_write_access, typename T = std::uint32_t>\nstruct reg {\nusing RegType = T;\n     // Type alias for the current instantiation\nusing ThisReg = reg<Address, Access, T>;\ntemplate<typename BitField>\nrequires `BitFieldConcept`<BitField, ThisReg, T>\nstatic void set(BitField::value bits_val)\n{\n    auto reg_value = read();\n    reg_value &= ~BitField::c_mask;\n    reg_value |= (static_cast<T>(bits_val) <<\n          BitField::c_position) & BitField::c_mask;\n    write(reg_value);\n}\ntemplate <typename Access_ = Access>\nstatic std::enable_if_t<std::is_base_of_v<read_access, Access_>, T> \nread()\n{\n    return *reinterpret_cast<volatile T*>(Address);\n}\nprivate:\n\ntemplate <typename Access_ = Access>\nstatic std::enable_if_t<std::is_base_of_v<write_access, Access_>, void> \nwrite(T val)\n{\n    *reinterpret_cast<volatile T*>(Address) = val;\n}\n}; \n```", "```cpp\nusing rcc = reg<0x40021000>;\nstruct hsion {\n    using reg = rcc;\n    using T = reg::RegType;\n    static constexpr T c_position = 0U;\n    static constexpr T c_mask = (1U << c_position);\n    enum class value : T {\n        disable = 0U,\n        enable  = 1U,\n    };\n}; \n```", "```cpp\nrcc::set<hsion>(hsion::value::enable);\nrcc::set<hsion>(hsion::value::disable); \n```", "```cpp\ntemplate<auto Bits>\nstruct `hsi_trim` {\n    using reg = rcc;\n    using T = reg::RegType;\n    `static_assert`(std::is_same_v<T, decltype(Bits)>);\n    static constexpr T c_position = 3;\n    static constexpr T c_mask = (0x1F << c_position);\n    `static_assert`(Bits <= 0x1F);\n    enum class value : T {\n        val = Bits\n    };\n}; \n```", "```cpp\nrcc::set<hsi_trim<0xFLU>>(hsi_trim<0xFLU>::value::val); \n```", "```cpp\n$ cmake -B build -DCMAKE_BUILD_TYPE=Release -DMAIN_CPP_FILE_NAME=main_type_safe_reg.cpp\n$ cmake --build build --target run_in_renode \n```", "```cpp\ntemplate<typename Reg, uint32_t Pos>\nstruct `reg_bits`_enable_disable {\n    using reg = Reg;\n    using T = reg::RegType;\n    static constexpr T c_position = Pos;\n    static constexpr T c_mask = (0x1UL << c_position);\n    enum class value : T {\n        disable = 0,\n        enable = 1\n    };\n}; \n```", "```cpp\nusing hsion = reg_bits_enable_disable<rcc, 0U>; \n```", "```cpp\ntemplate<auto Bits, typename Reg, uint32_t Mask, uint32_t Pos = 0>\nstruct reg_bits {\n    using reg = Reg; using T = reg::RegType;\n    static_assert(std::is_same_v<T, decltype(Bits)>);\n    static constexpr T c_position = Pos;\n    static constexpr T c_mask = (Mask << c_position);\n    static_assert(Bits <= Mask);\n    enum class value : T {\n        val = Bits\n    };\n}; \n```", "```cpp\ntemplate<auto Bits>\nusing hsi_trim = reg_bits<Bits, rcc, 0x1F, 3U>; \n```", "```cpp\nstruct timer2_traits {\n    constexpr static std::uintptr_t base_address = 0x40000000;\n    constexpr static IRQn_Type irqn = TIM2_IRQn;\n    constexpr static std::uint32_t arr_bit_mask = 0xFFFFFFFF;\n};\nstruct timer3_traits {\n    constexpr static std::uintptr_t base_address = 0x40000400;\n    constexpr static IRQn_Type irqn = TIM3_IRQn;\n    constexpr static std::uint32_t arr_bit_mask = 0xFFFF;\n}; \n```", "```cpp\ntemplate <typename TimerTraits>\nstruct timer {\n    constexpr static std::uintptr_t base_address =\n                                    TimerTraits::base_address;\n    using cr1 = reg<base_address + 0x00>;\n    using dier = reg<base_address + 0x0C>;\n    using sr = reg<base_address + 0x10>;\n    using psc = reg<base_address + 0x28>;\n    using arr = reg<base_address + 0x2C>;\n\n    template<auto Bits>\n    using psc_bits = reg_bits<Bits, psc, static_cast<uint32_t>(0xFFFF)>;\n    template<auto Bits>\n    using arr_bits = reg_bits<Bits, arr, TimerTraits::arr_bit_mask>;\n    using uie = reg_bits_enable_disable<dier, 0UL>;\n    using cen = reg_bits_enable_disable<cr1, 0UL>;\n    using uif = reg_bits_enable_disable<sr, 0UL>;\n    template<std::uint32_t Period>\n static void start() {\n        // a magic number prescaler value\n// for 1ms timer resolution\nconstexpr std::uint32_t prescaler = 9999;\n        constexpr std::uint32_t auto_reload = Period - 1;\n        psc::template set<psc_bits<prescaler>>\n                    (psc_bits<prescaler>::value::val);\n        arr::template set<arr_bits<auto_reload>>\n                    (arr_bits<auto_reload>::value::val);\n        dier::template set<uie>(uie::value::enable);\n        NVIC_SetPriority(TimerTraits::irqn, 1);\n        NVIC_EnableIRQ(TimerTraits::irqn);\n        cr1::template set<cen>(cen::value::enable);\n    }\n}; \n```", "```cpp\nconstexpr static std::uintptr_t base_address = TimerTraits::base_address;\nusing cr1 = reg<base_address + 0x00>;\nusing dier = reg<base_address + 0x0C>;\nusing sr = reg<base_address + 0x10>;\nusing psc = reg<base_address + 0x28>;\nusing arr = reg<base_address + 0x2C>; \n```", "```cpp\ntemplate<auto Bits>\nusing psc_bits = reg_bits<Bits, psc, static_cast<uint32_t> (0xFFFF)>;\ntemplate<auto Bits>\nusing arr_bits = reg_bits<Bits, arr, TimerTraits::arr_bit_mask>;\nusing uie = reg_bits_enable_disable<dier, 0UL>;\nusing cen = reg_bits_enable_disable<cr1, 0UL>;\nusing uif = reg_bits_enable_disable<sr, 0UL>; \n```", "```cpp\nusing timer2 = timer<timer2_traits>;\nusing timer3 = timer<timer3_traits>;\nextern \"C\" void TIM2_IRQHandler(void)\n{\n    if (timer2::sr::read() & TIM_SR_UIF)\n    {\n        timer2::sr::set<timer2::uif> (timer2::uif::value::disable);\n        printf(\"TIM2 IRQ..\\r\\n\");\n    }\n}\nextern \"C\" void TIM3_IRQHandler(void)\n{\n    if (timer3::sr::read() & TIM_SR_UIF)\n    {\n        timer3::sr::set<timer3::uif> (timer3::uif::value::disable);\n        printf(\"TIM3 IRQ..\\r\\n\");\n    }\n}\nint main()\n{\n    timer2::start<1000>();\n    timer3::start<500>();\n    while(true)\n    {\n    }\n} \n```", "```cpp\n$ cmake -B build -DCMAKE_BUILD_TYPE=Release -DMAIN_CPP_FILE_NAME=main_timer_peripheral.cpp\n$ cmake --build build --target run_in_renode \n```"]