- en: Preface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前言
- en: About this book
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于本书
- en: The *C++20 STL Cookbook* provides recipes to help you get the most out of the
    C++ STL (Standard Template Library), including new features introduced with C++20\.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 《*C++20 STL 烹饪书*》提供了食谱，帮助你充分利用 C++ STL（标准模板库），包括 C++20 中引入的新特性。
- en: C++ is a rich and powerful language. Built upon C, with syntactic extensions
    for type safety, generic programming, and object-oriented programming, C++ is
    essentially a low-level language. The STL provides a broad set of higher-level
    classes, functions, and algorithms to make your programming job easier, more effective,
    and less prone to error.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 是一种丰富而强大的语言。建立在 C 的基础上，通过类型安全、泛型编程和面向对象编程的语法扩展，C++ 实质上是一种低级语言。STL 提供了一组高级类、函数和算法，使你的编程工作更轻松、更有效，且更不容易出错。
- en: I've often said that C++ is five languages cobbled into one. The formal specification
    includes 1) the entire *C language*, 2) C's cryptic-yet-powerful *macro preprocessor*,
    3) a feature-rich *class/object* model, 4) a *generic programming* model called
    *templates*, and finally, built upon C++ classes and templates, 5) the *STL*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常说 C++ 是五种语言拼凑在一起的一种。正式规范包括 1) 整个 *C 语言*，2) C 的神秘而强大的 *宏预处理器*，3) 功能丰富的 *类/对象*
    模型，4) 一种称为 *模板* 的 *泛型编程* 模型，最后，建立在 C++ 类和模板之上，5) *STL*。
- en: Prerequisite knowledge
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前置知识
- en: This book presumes that you have a basic understanding of C++, including syntax,
    structure, data types, classes and objects, templates, and the STL.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你已具备 C++ 的基本理解，包括语法、结构、数据类型、类和对象、模板以及 STL。
- en: The recipes and examples in this book presume that you understand the need to
    `#include` certain headers to use library functions. The recipes don't usually
    list all the necessary headers, preferring to focus on the techniques at hand.
    You're encouraged to download the example code, which has all the necessary `#include`
    directives and other front matter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的食谱和示例假设你理解了需要 `#include` 某些头文件以使用库函数的需要。食谱通常不会列出所有必要的头文件，而是更专注于手头的技巧。鼓励你下载示例代码，其中包含所有必要的
    `#include` 指令和其他前置内容。
- en: 'You may download the example code from GitHub: [https://github.com/PacktPublishing/CPP-20-STL-Cookbook](https://github.com/PacktPublishing/CPP-20-STL-Cookbook).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 GitHub 下载示例代码：[https://github.com/PacktPublishing/CPP-20-STL-Cookbook](https://github.com/PacktPublishing/CPP-20-STL-Cookbook)。
- en: 'These assumptions mean that when you see a piece of code like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些假设意味着当你看到这样的代码片段时：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should already know that you''ll need to put this code in a `main()` function,
    you''ll need to `#include` the `<iostream>` header, and `cout` is an object in
    the `std::` namespace:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经知道，你需要将此代码放入 `main()` 函数中，你需要 `#include` `<iostream>` 头文件，而 `cout` 是 `std::`
    命名空间中的一个对象：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The STL's power is derived from templates *(a brief primer)*
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL 的力量来源于模板（简要入门）
- en: '*Templates* are how C++ does *generic programming*, code that''s independent
    of type while retaining type safety. C++ templates allow you to use tokens as
    placeholders for types and classes, like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板* 是 C++ 进行 *泛型编程* 的方式，代码独立于类型同时保持类型安全。C++ 模板允许你使用标记作为类型和类的占位符，如下所示：'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A template may be used for classes and/or functions. In this template function,
    the `T` represents a *generic type*, which allows this code to be used in the
    context of any compatible class or type:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可用于类和/或函数。在这个模板函数中，`T` 代表一个 *泛型类型*，这使得此代码可以在任何兼容的类或类型的上下文中使用：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This invokes the template function with an `int` type. This same code can be
    used with any type or class that supports the `+` operator.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 `int` 类型调用模板函数。相同的代码可以用于任何支持 `+` 操作符的类型或类。
- en: 'When the compiler sees a *template invocation*, like `add_em_up<int>(a, b)`,
    it creates a *specialization*. This is what makes the code type safe. When you
    invoke `add_em_up()` with an `int` type, the specialization will look something
    like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器看到 *模板调用*，例如 `add_em_up<int>(a, b)`，它会创建一个 *特化*。这就是使代码类型安全的原因。当你用 `int`
    类型调用 `add_em_up()` 时，特化将类似于以下这样：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The specialization takes the template and replaces all instances of the `T`
    placeholder with the type from the invocation, in this case, `int`. The compiler
    creates a separate specialization of the template each time it's invoked with
    a different type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 特化将模板替换为 `T` 占位符的所有实例，在这个例子中，是 `int`。每次用不同类型调用模板时，编译器都会为模板创建一个单独的特化。
- en: STL *containers*, like `vector`, `stack`, or `map`, along with their *iterators*
    and other supporting functions and algorithms, are built with templates so they
    can be used generically while maintaining type safety. This is what makes the
    STL so flexible. Templates are the *T* in the STL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: This book uses the C++20 standard
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++ language is standardized by the International Organization for Standardization
    (ISO) on a roughly three-year cycle. The current standard is called C++20 (which
    was preceded by C++17, C++14, and C++11 before that). C++20 was approved in September
    2020\.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: C++20 adds many important features to the language and the STL. New features
    like *format*, *modules*, *ranges*, and more will have significant impact on the
    way we use the STL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also convenience changes. For example, if you want to remove every
    matching element of a `vector`, you may have been using the *erase-remove idiom*
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Starting with C++20 you can use the new `std::erase` function and do all of
    that in one simple, optimized function call:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: C++20 has many improvements, both subtle and substantial. In this book, we will
    cover much of it, especially what's relevant to the STL.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Braced initialization
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may notice that the recipes in this book often use *braced initialization*
    in place of the more familiar *copy initialization*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `=` operator pulls double-duty as both an assignment and a copy operator.
    It's common, familiar, and it works, so we've all been using it forever.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The downside of the `=` operator is that it's also a copy constructor, which
    often means *implicit narrowing conversion*. This is both inefficient and can
    lead to unintended type conversions, which can be difficult to debug.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Braced initialization uses the list initialization operator `{}` (introduced
    in C++11) to avoid those side effects. It's a good habit to get into and you'll
    see it a lot in this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth noting that the special case of `T{}` is guaranteed to be zero-initialized.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The empty brace zero initialization offers a useful shortcut for initializing
    new variables.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Hiding the std:: namespace'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most instances, the exercises in this book will hide the `std::` namespace.
    This is mostly for page space and readability considerations. We all know that
    most STL identifiers are in the `std::` namespace. I will normally use some form
    of the `using` declaration to avoid cluttering the examples with repetitive prefixes.
    For example, when using `cout` you can presume I''ve included a `using` declaration
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I usually *will not show* the `using` declaration in the recipe listings. This
    allows us to focus on the purpose of the example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'It is poor practice to import the entire `std::` namespace in your code. You
    should *avoid* a `using namespace` declaration like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `std::` namespace includes thousands of identifiers and there's no good
    reason to clutter your namespace with them. The potential for collisions is not
    trivial, and can be hard to track down. When you want to use a name without the
    `std::` prefix, the preferred method is to import a single name at a time, as
    above.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::`命名空间包含成千上万的标识符，没有很好的理由在你的命名空间中用它们来造成混乱。冲突的可能性不是微不足道的，而且可能很难追踪。当你想要使用不带`std::`前缀的名称时，首选的方法是像上面那样一次导入一个名称。'
- en: To further avoid namespace collisions, I often use a separate namespace for
    classes that will be re-used. I tend to use `namespace bw` for my personal namespace.
    You may use something else that works for you.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步避免命名空间冲突，我经常为将要重用的类使用一个单独的命名空间。我倾向于使用`namespace bw`作为我的个人命名空间。你也可以使用对你来说有效的方法。
- en: Type aliases with using
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`using`声明类型别名
- en: This book uses the `using` directive for type aliases instead of `typedef`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用`using`指令而不是`typedef`来声明类型别名。
- en: 'STL classes and types can be verbose at times. A templated iterator class,
    for example, may look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: STL类和类型有时可能会很冗长。例如，一个模板迭代器类可能看起来像这样：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Long type names are not just hard to type, they are prone to error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 长类型名不仅难以输入，而且容易出错。
- en: 'One common technique is to abbreviate long type names with `typedef`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的技巧是使用`typedef`来缩短长类型名：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This declares an alias for our unwieldy iterator type. `typedef` is inherited
    from C and its syntax reflects that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们的笨拙迭代器类型声明了一个别名。`typedef`是从C继承的，其语法反映了这一点。
- en: 'Beginning with C+11, the `using` keyword may be used to create a type alias:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从C+11开始，可以使用`using`关键字来创建类型别名：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In most circumstances, a `using` alias is equivalent to `typedef`. The most
    significant difference is that a `using` alias may be templated:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`using`别名等同于`typedef`。最显著的区别是`using`别名可能是模板化的：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For these reasons, and for the sake of clarity, this book prefers the `using`
    directive for type aliases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，为了清晰起见，本书更倾向于使用`using`指令来声明类型别名。
- en: Abbreviated function templates
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化的函数模板
- en: 'Beginning with C++20, an *abbreviated function template* may be specified without
    the template header. For example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++20开始，可以指定没有模板头的*简化的函数模板*。例如：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `auto` type in a parameter list works like an anonymous template `typename`.
    It is equivalent to:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表中的`auto`类型就像一个匿名模板`typename`，它等同于：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Though new in C++20, abbreviated function templates have been supported by the
    major compilers for some time already. This book will use abbreviated function
    templates in many of the examples.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C++20中才引入，但简化的函数模板已经被主要的编译器支持了一段时间。本书将在许多示例中使用简化的函数模板。
- en: The C++20 format() function
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++20的`format()`函数
- en: Until C++20 we've had a choice of using legacy `printf()` or the STL `cout`
    for formatting text. Both have serious flaws but we've used them because they
    work. Beginning with C++20, the `format()` function provides text formatting inspired
    by Python 3's formatter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 直到C++20，我们可以在使用传统的`printf()`或STL的`cout`进行文本格式化之间进行选择。两者都有严重的缺陷，但我们使用它们是因为它们有效。从C++20开始，`format()`函数提供了受Python
    3格式化程序启发的文本格式化。
- en: This course uses the new STL `format()` function liberally. Please see [*Chaper
    1*](B18267_01_ePub.xhtml#_idTextAnchor027), *New C++20 Features*, for a more comprehensive
    description.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本课程大量使用了新的STL `format()`函数。请参阅[*第1章*](B18267_01_ePub.xhtml#_idTextAnchor027)，*新C++20特性*，以获取更全面的描述。
- en: Use the STL to solve real-world problems
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL解决实际问题
- en: The recipes in this book use the STL to provide real-world solutions to real-world
    problems. They have been designed to rely exclusively on the STL and C++ standard
    libraries, with no external libraries. This should make it easy for you to experiment
    and learn without the distractions of installing and configuring third-party code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的食谱使用STL为实际问题提供实际解决方案。它们被设计为仅依赖于STL和C++标准库，不使用任何外部库。这应该使你能够轻松地进行实验和学习，而不会受到安装和配置第三方代码的干扰。
- en: Now, let's go have some fun with the STL. *Happy learning!*
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用STL（标准模板库）来享受一些乐趣吧。*快乐学习！*
- en: Who this book is for
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书面向的对象
- en: This book is for *intermediate to advanced* C++ programmers who want to get
    more out of the C++20 Standard Template Library. Basic knowledge of coding and
    C++ concepts are necessary to get the most out of this book.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是为希望从C++20标准模板库中获得更多内容的*中级到高级*C++程序员而编写的。为了充分利用本书，需要具备基本的编码知识和C++概念。
- en: What this book covers
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书涵盖的内容
- en: '[*Chaper 1*](B18267_01_ePub.xhtml#_idTextAnchor027), *New C++20 Features*,
    introduces the new STL features in C++20\. It aims to familiarize you with the
    new language features so you may use them with the STL.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第1章*](B18267_01_ePub.xhtml#_idTextAnchor027), *新C++20特性*, 介绍了C++20中的新STL特性。目的是让您熟悉这些新语言特性，以便您可以在STL中使用它们。'
- en: '[*Chapter 2*](B18267_02_ePub.xhtml#_idTextAnchor057), *General STL Features*,
    discusses modern STL features added in recent C++ versions.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第2章*](B18267_02_ePub.xhtml#_idTextAnchor057), *通用STL特性*, 讨论了最近C++版本中添加的现代STL特性。'
- en: '[*Chapter 3*](B18267_03_ePub.xhtml#_idTextAnchor076), *STL Containers*, covers
    the STL''s comprehensive library of containers.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第3章*](B18267_03_ePub.xhtml#_idTextAnchor076), *STL容器*, 讨论了STL的全面容器库。'
- en: '[*Chapter 4*](B18267_04_ePub.xhtml#_idTextAnchor122), *Compatible Iterators*,
    shows how to use and create STL-compatible iterators.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第4章*](B18267_04_ePub.xhtml#_idTextAnchor122), *兼容迭代器*, 展示了如何使用和创建与STL兼容的迭代器。'
- en: '[*Chapter 5*](B18267_05_ePub.xhtml#_idTextAnchor155), *Lambda Expressions*,
    covers the use of lambdas with STL functions and algorithms.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第5章*](B18267_05_ePub.xhtml#_idTextAnchor155), *Lambda表达式*, 讨论了与STL函数和算法一起使用Lambda的方法。'
- en: '[*Chapter 6*](B18267_06_ePub.xhtml#_idTextAnchor181), *STL Algorithms*, provides
    recipes for using and creating STL-compatible algorithms.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第6章*](B18267_06_ePub.xhtml#_idTextAnchor181), *STL算法*, 提供了使用和创建与STL兼容的算法的食谱。'
- en: '[*Chapter 7*](B18267_07_ePub.xhtml#_idTextAnchor212), *Strings, Stream, and
    Formatting*, describes the STL string and formatter classes.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第7章*](B18267_07_ePub.xhtml#_idTextAnchor212), *字符串、流和格式化*, 描述了STL的字符串和格式化类。'
- en: '[*Chapter 8*](B18267_08_ePub.xhtml#_idTextAnchor250), *Utility Classes*, covers
    STL utilities for date-and-time, smart pointers, optionals, and more.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第8章*](B18267_08_ePub.xhtml#_idTextAnchor250), *实用类*, 讨论了STL的日期和时间、智能指针、optionals等实用类。'
- en: '[*Chapter 9*](B18267_09_ePub.xhtml#_idTextAnchor291), *Concurrency and Parallelism*,
    describes support for concurrency, including threads, async, atomic types, and
    more.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第9章*](B18267_09_ePub.xhtml#_idTextAnchor291), *并发与并行性*, 描述了对并发性的支持，包括线程、async、原子类型等。'
- en: '[*Chapter 10*](B18267_10_ePub.xhtml#_idTextAnchor324), *Using the File System*,
    covers the `std::filesystem` classes and how to put them to use with the latest
    advancements that came out with C++20.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第10章*](B18267_10_ePub.xhtml#_idTextAnchor324), *使用文件系统*, 讨论了`std::filesystem`类以及如何利用C++20带来的最新进展来使用它们。'
- en: '[*Chapter 11*](B18267_11_ePub.xhtml#_idTextAnchor347), *A Few More Ideas*,
    provides a few more solutions, including a trie class, string split, and more.
    This provides advanced examples on how to put the STL to use for real-world problems.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第11章*](B18267_11_ePub.xhtml#_idTextAnchor347), *更多想法*, 提供了一些额外的解决方案，包括trie类、字符串分割等。这提供了如何将STL应用于实际问题的先进示例。'
- en: The recipes in this book use the GCC compiler
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本书中的食谱使用GCC编译器
- en: Unless otherwise noted, most of the recipes in this book have been developed
    and tested using the GCC compiler, version 11.2, the latest stable version as
    of this writing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，本书中的大多数食谱都是使用GCC编译器，版本11.2，截至本书撰写时的最新稳定版本开发的。
- en: As I write this, C++20 is still new and is not fully implemented on any available
    compiler. Of the three major compilers, *GCC* (GNU), *MSVC* (Microsoft), and *Clang*
    (Apple), the MSVC compiler is furthest along in implementing the new standard.
    Occasionally, we may run into a feature that is implemented on MSVC or another
    compiler, but not on GCC, in which case I will note which compiler I used. If
    a feature is not yet implemented on any available compiler, I will explain that
    I was unable to test it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写这篇文章时，C++20仍然很新，并且任何可用的编译器都没有完全实现。在三个主要编译器中，*GCC*（GNU）、*MSVC*（Microsoft）和*Clang*（Apple）中，MSVC编译器在实现新标准方面进展最快。偶尔，我们可能会遇到在MSVC或其他编译器上实现但在GCC上未实现的功能，在这种情况下，我会注明我使用了哪个编译器。如果一个功能在任何可用的编译器上尚未实现，我会解释我无法对其进行测试。
- en: '![](img/B18267_Preface_01.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18267_Preface_01.png)'
- en: I strongly recommend that you install GCC to follow along with the recipes in
    this book. GCC is freely available under the GNU General Public License (GPL).
    The easiest way to get the latest version of GCC is to install *Debian Linux*
    (also GPL) and use `apt` with the `testing` repository.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您安装GCC以跟随本书中的食谱。GCC在GNU通用公共许可证（GPL）下免费提供。获取GCC最新版本的最简单方法是安装*Debian Linux*（也是GPL），并使用`apt`和`testing`仓库。
- en: '**If you are using the digital version of this book, we suggest you type the
    code yourself or download the code from the GitHub repository (link in the next
    section). This will avoid errors due to copying and pasting formatted code from
    the e-book.**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您正在使用本书的数字版，我们建议您自己输入代码或从GitHub仓库（下一节中的链接）下载代码。这将避免从电子书复制粘贴格式化代码时产生的错误。**'
- en: Download the example code files
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载示例代码文件
- en: You can download the example code files for this book from GitHub at https://github.com/PacktPublishing/CPP-20-STL-Cookbook.
    In the event of updates and errata, code will be updated on the GitHub repository.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub（https://github.com/PacktPublishing/CPP-20-STL-Cookbook）下载本书的示例代码文件。在更新和勘误的情况下，代码将在GitHub仓库中更新。
- en: We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有其他来自我们丰富的图书和视频目录的代码包可供选择，请访问[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)。查看它们！
- en: Conventions used
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用的约定
- en: There are a number of text conventions used throughout this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用了多种文本约定。
- en: '`Code in text`: Indicates code words in text, database table names, folder
    names, file names, file extensions, path names, dummy URLs, user input, and Twitter
    handles. Here is an example: "The `insert()` method takes an `initializer_list`
    and calls the private function `_insert()`:"'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`文本中的代码`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟URL、用户输入和Twitter昵称。以下是一个示例：“`insert()`方法接受一个`initializer_list`并调用私有函数`_insert()`：”'
- en: 'A block of code is set as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块设置如下：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we wish to draw your attention to a particular part of a code block, the
    relevant lines or items are set in bold:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望您注意代码块中的特定部分时，相关的行或项目将以粗体显示：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Any command-line input or output is written as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 任何命令行输入或输出都按以下方式编写：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Bold**: Indicates a new term, an important word, or words that you see onscreen.
    For example, words in menus or dialog boxes appear in the text like this. Here
    is an example: "Select **System info** from the **Administration** panel."'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**粗体**：表示新术语、重要单词或您在屏幕上看到的单词。例如，菜单或对话框中的单词在文本中显示如下。以下是一个示例：“从**管理**面板中选择**系统信息**。”'
- en: Tips or important notes
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士或重要注意事项
- en: Appear like this.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 显示如下。
- en: Sections
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分
- en: In this book, you will find several headings that appear frequently (*How to
    do it...*, *How it works...*, *There's more...*, and *See also…*).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将找到一些经常出现的标题（*如何做…*、*它是如何工作的…*、*更多内容…*和*另请参阅…*）。
- en: 'To give clear instructions on how to complete a recipe, use these sections
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地说明如何完成食谱，请按照以下方式使用这些部分：
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: This section contains the steps required to follow the recipe.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含遵循食谱所需的步骤。
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This section usually consists of a detailed explanation of what happened in
    the previous section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通常包含对前节发生事件的详细解释。
- en: There's more…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: This section consists of additional information about the recipe in order to
    make you more knowledgeable about the recipe.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含有关食谱的附加信息，以便您对食谱有更深入的了解。
- en: See also…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅…
- en: This section provides helpful links to other useful information for the recipe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了对其他有用信息的链接，以帮助您了解食谱。
- en: Get in touch
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系我们
- en: Feedback from our readers is always welcome.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎读者反馈。
- en: '**General feedback**: If you have questions about any aspect of this book,
    mention the book title in the subject of your message and email us at [customercare@packtpub.com](http://customercare@packtpub.com).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**一般反馈**：如果您对本书的任何方面有疑问，请在邮件主题中提及书名，并通过[customercare@packtpub.com](http://customercare@packtpub.com)给我们发邮件。'
- en: '**Errata**: Although we have taken every care to ensure the accuracy of our
    content, mistakes do happen. If you have found a mistake in this book, we would
    be grateful if you would report this to us. Please visit [www.packtpub.com/support/errata](http://www.packtpub.com/support/errata),
    selecting your book, clicking on the Errata Submission Form link, and entering
    the details.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**勘误**：尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在这本书中发现了错误，如果您能向我们报告，我们将不胜感激。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)，选择您的书籍，点击勘误提交表单链接，并输入详细信息。'
- en: '**Piracy**: If you come across any illegal copies of our works in any form
    on the Internet, we would be grateful if you would provide us with the location
    address or website name. Please contact us at [copyright@packt.com](http://copyright@packt.com)
    with a link to the material.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**盗版**：如果您在互联网上遇到任何形式的我们作品的非法副本，如果您能提供位置地址或网站名称，我们将不胜感激。请通过[copyright@packt.com](http://copyright@packt.com)与我们联系，并提供材料的链接。'
- en: '**If you are interested in becoming an author**: If there is a topic that you
    have expertise in and you are interested in either writing or contributing to
    a book, please visit [authors.packtpub.com](http://authors.packtpub.com).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您有兴趣成为作者**：如果您在某个领域有专业知识，并且对撰写或参与书籍感兴趣，请访问[authors.packtpub.com](http://authors.packtpub.com)。'
- en: Share Your Thoughts
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享您的想法
- en: Once you've read *C++20 STL Cookbook*, we'd love to hear your thoughts! [Please
    click here to go straight to the Amazon review page](https://packt.link/r/1803248718)
    for this book and share your feedback.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您阅读了《C++20 STL 烹饪秘籍》，我们非常乐意听取您的想法！[请点击此处直接进入此书的亚马逊评论页面](https://packt.link/r/1803248718)并分享您的反馈。
- en: Your review is important to us and the tech community and will help us make
    sure we're delivering excellent quality content.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您的评论对我们和科技社区都非常重要，并将帮助我们确保我们提供高质量的内容。
- en: Preface
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前言
