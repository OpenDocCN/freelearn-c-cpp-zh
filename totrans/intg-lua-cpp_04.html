<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer032">
<h1 class="chapter-number" id="_idParaDest-88"><a id="_idTextAnchor088"/>4</h1>
<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Mapping Lua Types to C++</h1>
<p>In the previous chapter, we learned how to call a Lua function with a single string argument that returns one string value. In this chapter, we will learn how to call a Lua function with any type and any number of arguments and support multiple return values. To do this, we need to find a convenient way to map Lua types to C++ types. Then, we will build upon this type system to improve our Lua executor step by step. During this process, you will continue to deepen your understanding of the Lua stack and learn how to use some of the modern C++ features to <span class="No-Break">integrate Lua.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Mapping <span class="No-Break">Lua types</span></li>
<li>Supporting different <span class="No-Break">argument types</span></li>
<li>Supporting a variable number <span class="No-Break">of arguments</span></li>
<li>Supporting multiple <span class="No-Break">return values</span></li>
</ul>
<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Technical requirements</h1>
<p>This chapter is more C++ coding intensive. To better follow this chapter, please make sure you understand <span class="No-Break">the following:</span></p>
<ul>
<li>You are familiar with the modern C++ standards. We will start to use features from <strong class="bold">C++11</strong> and <strong class="bold">C++17</strong>. If you have only used <strong class="bold">C++03</strong>, please take a while to study the new C++ features on your own when you encounter them in this chapter. As a heads-up, we will use <strong class="bold">enum class</strong>, <strong class="bold">std::variant</strong>, <strong class="bold">std::visit</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">std::initializer_list</strong></span><span class="No-Break">.</span></li>
<li>You can access the source code for this chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter04</span></a><span class="No-Break">.</span></li>
<li>You can understand and execute the code in the <strong class="source-inline">begin</strong> folder from the preceding GitHub link. The <strong class="source-inline">begin</strong> folder has some necessary solutions from the last chapter’s questions integrated and acts as the starting point for this chapter. We will add new features implemented in this chapter <span class="No-Break">to it.</span></li>
</ul>
<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>Mapping Lua types</h1>
<p>In <span class="No-Break"><em class="italic">Chapter 2</em></span>, <em class="italic">Lua Fundamentals</em>, we<a id="_idIndexMarker162"/> learned about the Lua types. They are different from C++ types. To use them in C++, we need to do some mapping. In <span class="No-Break"><em class="italic">Chapter 3</em></span>, <em class="italic">How to Call Lua from C++</em>, we mapped the Lua string to the C++ <strong class="source-inline">std::string</strong>. It is mapped by hardcoding it in our <span class="No-Break">Lua executor.</span></p>
<p>What if we want to support all possible Lua types, both in the function arguments and in function return values? What if we want to call Lua functions with different numbers of arguments? It is not feasible to create a C++ function for each argument type and argument count combination. That way, our Lua executor would be plagued with hundreds of functions just to call <span class="No-Break">Lua functions!</span></p>
<p>Fortunately, C++ is powerful <a id="_idIndexMarker163"/>with its <strong class="bold">object-oriented programming</strong> and<a id="_idIndexMarker164"/> its <strong class="bold">generic programming</strong>. These two paradigms lead to two different ways in which you can solve problems <span class="No-Break">in C++.</span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Exploring different mapping options</h2>
<p>As said, C++ supports <a id="_idIndexMarker165"/>object-oriented programming and generic programming. We can design a type system with either <span class="No-Break">of them.</span></p>
<h3>Using object-oriented types</h3>
<p>This approach is <a id="_idIndexMarker166"/>probably easier to<a id="_idIndexMarker167"/> understand. It has been supported since the birth of C++. We can define an abstract base class that represents all possible types, then inherit it and implement a concrete class for <span class="No-Break">each type.</span></p>
<p>Besides C++, most programming languages support this method. If you or your team work with multiple programming languages, this method might cause less concept switching <span class="No-Break">in work.</span></p>
<p>But this approach is also more verbose. You will have other considerations as well. For example, after the mappings are defined, you would want to prevent creating new types that do not exist in <a id="_idIndexMarker168"/>Lua. You would have to<a id="_idIndexMarker169"/> make base class constructors private and declare a <span class="No-Break">few friends.</span></p>
<h3>Using generic types</h3>
<p>This approach<a id="_idIndexMarker170"/> depends on<a id="_idIndexMarker171"/> a new C++17 feature: <em class="italic">std::variant</em>. You can define and map a simple C++ class for each Lua type without inheritance. Then you create a union type with <strong class="source-inline">std::variant</strong>, saying that this union type may be and can only be from the pre-defined <span class="No-Break">Lua mappings.</span></p>
<p>This will result in less code. The less code, the less chance that something will go wrong. Modern programming tends to adopt new paradigms, besides the vanilla <span class="No-Break">object-oriented methodology.</span></p>
<p>The drawback of this approach is that not all organizations adopt the new C++ standards that fast, which in turn makes them less <span class="No-Break">widely understood.</span></p>
<p>In this chapter, we will implement that approach. After going through this chapter, if you prefer, you can implement object-oriented types on your own. But before we move on, let us look at the <strong class="source-inline">Makefile</strong> used for <span class="No-Break">this chapter.</span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Introducing some new Makefile tricks</h2>
<p>Before diving <a id="_idIndexMarker172"/>into the<a id="_idIndexMarker173"/> details, let us go through the <strong class="source-inline">Makefile</strong>. You can find a copy in the <strong class="source-inline">begin</strong> folder in the GitHub repository, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
LUA_PATH = ../../lua
CXX = g++
CXXFLAGS = -std=c++17 -Wall -Werror
CPPFLAGS = -I${LUA_PATH}/src
LDFLAGS = -L${LUA_PATH}/src
EXECUTABLE = executable
ALL_O = main.o LuaExecutor.o LoggingLuaExecutorListener.o
all: clean lua project
lua:
    @cd ${LUA_PATH} &amp;&amp; make
project: ${ALL_O}
    $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) -o $(EXECUTABLE) 
     ${ALL_O} -llua
clean:
    rm -f ${ALL_O} $(EXECUTABLE)</pre>
<p>There are only<a id="_idIndexMarker174"/> four<a id="_idIndexMarker175"/> differences compared to the <strong class="source-inline">Makefile</strong> used in <span class="No-Break"><em class="italic">Chapter 3</em></span><span class="No-Break">:</span></p>
<ul>
<li>In <strong class="source-inline">CXXFLAGS</strong>, we require the compiler to compile our code as C++17 by adding <strong class="source-inline">-std=c++17</strong>. Without this, it will use the default standard, which may be an older <span class="No-Break">C++ version.</span></li>
<li>A new variable, <strong class="source-inline">ALL_O</strong>, defines all the object files that will be produced. Each C++ source file will be compiled into an object file. Remember to add a new object file here when you add a new source file. Otherwise, without the object file produced, the linker cannot find the symbols that should have been in the missing object file, and you will get <span class="No-Break">linker errors.</span></li>
<li>The <strong class="source-inline">project</strong> target now depends on all object files. <strong class="source-inline">Make</strong> is smart enough to compile the object files from the source files for you automatically by using the corresponding source file as a dependency for the <span class="No-Break">object file.</span></li>
<li>The <strong class="source-inline">all</strong> target has an extra dependency: the <strong class="source-inline">clean</strong> target. This always cleans the project and rebuilds it. When you write an object file target manually, you can make it depend on multiple header files. When <strong class="source-inline">Make</strong> does this for you, it cannot tell which header files need to be depended on. So, this is a trick for small projects for study purposes. For more formal projects, you should consider supporting compiling everything correctly without cleaning <span class="No-Break">it first.</span></li>
</ul>
<p>If you struggle to understand this <strong class="source-inline">Makefile</strong>, please check the explanation in <span class="No-Break"><em class="italic">Chapter 1</em></span> and <span class="No-Break"><em class="italic">Chapter 3</em></span>. Better yet, you can research more online. If you have no urgent need to learn about the <strong class="source-inline">Makefile</strong>, it is also perfectly fine just to use it as it is, and be comfortable <span class="No-Break">with it.</span></p>
<p class="callout-heading">Remember</p>
<p class="callout">The <strong class="source-inline">Makefile</strong> examples used in this book favor simplicity, rather than <span class="No-Break">production flexibility.</span></p>
<p>We have distracted ourselves a bit from C++ by explaining some new <strong class="source-inline">Makefile</strong> mechanisms. This will be the last time we go through a <strong class="source-inline">Makefile</strong> in this book. In the following chapters, please refer to the GitHub <span class="No-Break">source code.</span></p>
<p>The explanation was necessary, in case you get cryptic errors from the C++ compiler and linker. Now we can go back to our focus. We will define some simple C++ structures that map to Lua types. After this, we can use <strong class="source-inline">std::variant</strong> to declare a union type. Having a<a id="_idIndexMarker176"/> union<a id="_idIndexMarker177"/> type will enable us to pass a value of any type to our C++ functions. Now, let us define the Lua types <span class="No-Break">in C++.</span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Defining Lua types in C++</h2>
<p>The first order <a id="_idIndexMarker178"/>of business <a id="_idIndexMarker179"/>is how we can define a Lua type in C++. We want a clear definition of Lua types, so things such as <strong class="source-inline">std::string</strong> are no longer <span class="No-Break">unique enough.</span></p>
<p>Since C++11, we have <em class="italic">enum class</em> support. We can limit our Lua types with an enum class in C++ <span class="No-Break">as follows:</span></p>
<pre class="source-code">
enum class LuaType
{
    nil,
    boolean,
    number,
    string,
};</pre>
<p>For now, we only support the Lua basic types that can map to simple C++ types. You can put this declaration in a file named <strong class="source-inline">LuaType.hpp</strong> and include it in <strong class="source-inline">LuaExecutor.h</strong> as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
#include "LuaType.hpp"</pre>
<p>We call it <strong class="source-inline">*.hpp</strong> because we will put the type implementations in the header file directly and inline all the functions. This is partly because the implementation classes will be simple, and partly because this is a book, and limiting the number of lines of code is important. You can separate the code into a header file and a source file or name this header file with<a id="_idIndexMarker180"/> implementations <strong class="source-inline">LuaType.h</strong>. This depends on convention, as per <a id="_idIndexMarker181"/>each company or organization, and there are many ways to do something <span class="No-Break">in C++.</span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Implementing Lua types in C++</h2>
<p>As explained, we will <a id="_idIndexMarker182"/>use simple classes without inheritance. Each<a id="_idIndexMarker183"/> class will have two fields: a <strong class="source-inline">type</strong> field of <strong class="source-inline">LuaType</strong> we just defined, and a <strong class="source-inline">value</strong> field for the actual data storage <span class="No-Break">in C++.</span></p>
<p>In <strong class="source-inline">LuaType.hpp</strong>, implement four structures. In C++, a structure is the same as a class, but with public access to its members by default. We use structures conventionally when we want to define data. First, <span class="No-Break">implement </span><span class="No-Break"><strong class="source-inline">LuaType::nil</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
#include &lt;cstddef&gt;
struct LuaNil final
{
    const LuaType type = LuaType::nil;
    const std::nullptr_t value = nullptr;
    static LuaNil make() { return LuaNil(); }
private:
    LuaNil() = default;
};</pre>
<p>We choose to use <strong class="source-inline">nullptr</strong> to represent a Lua nil value. Its type is <strong class="source-inline">std::nullptr_t</strong>. We also make the constructor private and provide a static function to <a id="_idIndexMarker184"/>create <a id="_idIndexMarker185"/><span class="No-Break">new objects.</span></p>
<p class="callout-heading">Design patterns</p>
<p class="callout">Here, we used a design pattern – the static factory method with a private constructor. In our implementation, this will prevent creating objects on the heap with <strong class="source-inline">new</strong>. The C++ structures for Lua types do not provide copy constructors either. This is a design choice – you either fully support passing it around and assigning to it or limit its usage. In this book, we limit its usage purely when interacting with the Lua executor on the C++ stack. If you have another layer above the Lua executor, you need to convert the structures to C++ basic types or your own type. This helps <span class="No-Break">with abstraction.</span></p>
<p>Similarly, <span class="No-Break">implement </span><span class="No-Break"><strong class="source-inline">LuaType::boolean</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
struct LuaBoolean final
{
    const LuaType type = LuaType::boolean;
    const bool value;
    static LuaBoolean make(const bool value)
    {
        return LuaBoolean(value);
    }
private:
    LuaBoolean(const bool value) : value(value) {}
};</pre>
<p>The static <strong class="source-inline">make</strong> function accepts a <strong class="source-inline">boolean</strong> value to create an instance. In the private constructor, we use a member initializer list to initialize the <strong class="source-inline">value</strong> <span class="No-Break">member variable.</span></p>
<p>For <strong class="source-inline">LuaType::number</strong>, we choose to use the C++ double type to store <span class="No-Break">the value:</span></p>
<pre class="source-code">
struct LuaNumber final
{
    const LuaType type = LuaType::number;
    const double value;
    static LuaNumber make(const double value)
    {
        return LuaNumber(value);
    }
private:
    LuaNumber(const double value) : value(value) {}
};</pre>
<p>Lua itself does<a id="_idIndexMarker186"/> not <a id="_idIndexMarker187"/>distinguish between an integer and a float in the basic <em class="italic">number</em> type, but if you need to, you can create two C++ types for integers and floats separately. To do this, you can use the Lua <strong class="source-inline">lua_isinteger</strong> library function to check whether the number is an integer. If it is not, it is a double. In this book, we only implement mappings for the basic Lua types. In a gaming system, you might want to enforce using the float type. In an embedded system, you might want to enforce using the integer type. Or, you can support using both in a project. This is easy to achieve by referencing the implementation <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">LuaNumber</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Linking knowledge</p>
<p class="callout">In Lua code, you can use the <strong class="source-inline">math.type</strong> library function to check whether a number is an integer or <span class="No-Break">a float.</span></p>
<p>And finally, for <strong class="source-inline">LuaType::string</strong>, we use <strong class="source-inline">std::string</strong> to store <span class="No-Break">the value:</span></p>
<pre class="source-code">
#include &lt;string&gt;
struct LuaString final
{
    const LuaType type = LuaType::string;
    const std::string value;
    static LuaString make(const std::string &amp;value)
    {
        return LuaString(value);
    }
private:
    LuaString(const std::string &amp;value) : value(value) {}
};</pre>
<p>This<a id="_idIndexMarker188"/> concludes <a id="_idIndexMarker189"/>our type implementations. Next is where all the <span class="No-Break">magic happens.</span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Implementing a union type</h2>
<p>We have<a id="_idIndexMarker190"/> defined a <strong class="source-inline">LuaType</strong> enum class to identify Lua types, and <a id="_idIndexMarker191"/>structures to represent Lua values of different types. When we want to pass a Lua value around, we need a type to represent them all. Without using a common base class, we can use <strong class="source-inline">std::variant</strong>. It is a template class taking a list of types as its parameters. Then it can safely represent any of these types in code. To see it in action, add the following <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">LuaType.hpp</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
#include &lt;variant&gt;
using LuaValue = std::variant&lt;
    LuaNil, LuaBoolean, LuaNumber, LuaString&gt;;</pre>
<p>The <strong class="source-inline">using</strong> keyword <a id="_idIndexMarker192"/>creates a type alias, <strong class="source-inline">LuaValue</strong>. It can represent any of the four specified types in the <span class="No-Break">template parameters.</span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Working with the union type</h2>
<p>If you have not <a id="_idIndexMarker193"/>used <strong class="source-inline">std::variant</strong> before, you may <a id="_idIndexMarker194"/>have wondered how can we tell which actual type it is holding. If you pass a value of <strong class="source-inline">LuaValue</strong> around, you cannot access the <strong class="source-inline">type</strong> or the <strong class="source-inline">value</strong> field directly. This is because there is no common base class. At compile time, the compiler does not know what fields are supported by simply looking at the <strong class="source-inline">std::variant</strong> variable. To do this, we need a small twist. C++17 also provides <strong class="source-inline">std::visit</strong> to help with this. Let us implement a helper function to get the <strong class="source-inline">LuaType</strong> from a <strong class="source-inline">LuaValue</strong>. In <strong class="source-inline">LuaType.hpp</strong>, add the code <span class="No-Break">as follows:</span></p>
<pre class="source-code">
inline LuaType getLuaType(const LuaValue &amp;value)
{
    return std::visit(
        [](const auto &amp;v) { return v.type; },
        value);
}</pre>
<p>This function is an <strong class="bold">inline</strong> function to make <a id="_idIndexMarker195"/>the call site more efficient. Moreover, it needs to be an inline function because we are implementing it in the header file directly. Without the <strong class="source-inline">inline</strong> keyword, the function may get included in different source files with the same symbol, which leads to <span class="No-Break">link errors.</span></p>
<p><strong class="source-inline">std::visit</strong> takes two arguments. The first is<a id="_idIndexMarker196"/> a C++ <strong class="bold">callable</strong> and the second is the value to work on. It passes the value to the callable. In the callable, you can access the field directly, because <strong class="source-inline">std::visit</strong> makes the type information available. If you have never come across this concept or usage before, it may take some time to digest. You can consider this<a id="_idIndexMarker197"/> callable a <strong class="bold">lambda</strong>. If you have used lambda from other programming languages, such as Java, Kotlin, Swift, or Python, the C++ one is very similar. In other programming languages, more often than not, the lambda is the last parameter, which is <a id="_idIndexMarker198"/>called a <strong class="bold">trailing lambda</strong> and in some cases is easier to read. The best way to learn about C++ lambda is to use it and try to feel comfortable with it until you have fully <span class="No-Break">mastered it.</span></p>
<p>With this, let us implement another helper function to get the string representation of each<a id="_idIndexMarker199"/> type. In <strong class="source-inline">LuaTypp.hpp</strong>, add <a id="_idIndexMarker200"/>the <span class="No-Break">following function:</span></p>
<pre class="source-code">
inline std::string
getLuaValueString(const LuaValue &amp;value)
{
    switch (getLuaType(value))
    {
    case LuaType::nil:
        return "nil";
    case LuaType::boolean:
        return std::get&lt;LuaBoolean&gt;(value).value
            ? "true" : "false";
    case LuaType::number:
        return std::to_string(
            std::get&lt;LuaNumber&gt;(value).value);
    case LuaType::string:
        return  std::get&lt;LuaString&gt;(value).value;
    }
}</pre>
<p>This will help us to test our implementations in the rest of this chapter by getting what is stored in a <strong class="source-inline">LuaValue</strong>. You can use <strong class="source-inline">std::get</strong> to get a specific type from a <span class="No-Break"><strong class="source-inline">std::variant</strong></span><span class="No-Break"> union.</span></p>
<p>We have talked about <strong class="source-inline">std::variant</strong>, <strong class="source-inline">std::visit</strong>, and <strong class="source-inline">std::get</strong>, but not enough to be a C++ expert in this area. Before moving on, feel free to research more <span class="No-Break">on them.</span></p>
<p>Next, let us use the <a id="_idIndexMarker201"/>Lua mapping we have implemented to make <a id="_idIndexMarker202"/>calling Lua functions more flexible. First, we will get rid of the hardcoded <strong class="source-inline">std::string</strong> used for the <strong class="source-inline">call</strong> function in our <span class="No-Break">Lua executor.</span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Supporting different argument types</h1>
<p>In the last chapter, w<a id="_idIndexMarker203"/>e implemented our C++ function to call a Lua function <span class="No-Break">as follows:</span></p>
<pre class="source-code">
std::string call(const std::string &amp;function,
                 const std::string &amp;param);</pre>
<p>Our goal in this step is to make it more general and we want the <span class="No-Break">following instead:</span></p>
<pre class="source-code">
LuaValue call(const std::string &amp;function,
              const LuaValue &amp;param);</pre>
<p>In fact, go ahead and change this in <strong class="source-inline">LuaExecutor.h</strong>. To make it work, we will implement helper functions to push onto and pop from the Lua stack, with our <strong class="source-inline">LuaValue</strong> C++ type instead of <strong class="source-inline">std::string</strong>. Let us work on pushing onto the <span class="No-Break">stack first.</span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Pushing onto the stack</h2>
<p>In the previous <a id="_idIndexMarker204"/>call function, we pushed the <strong class="source-inline">param</strong> argument of the <strong class="source-inline">std::string</strong> type onto the Lua stack with <span class="No-Break">the following:</span></p>
<pre class="source-code">
lua_pushstring(L, param.c_str());</pre>
<p>To support more Lua types, we can implement a <strong class="source-inline">pushValue</strong> method that takes <strong class="source-inline">LuaValue</strong> as an argument and calls different <strong class="source-inline">lua_pushX</strong> Lua library functions based on the <strong class="source-inline">type</strong> field <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">LuaValue</strong></span><span class="No-Break">.</span></p>
<p>In <strong class="source-inline">LuaExecutor.h</strong>, add the declaration <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class LuaExecutor
{
private:
    void pushValue(const LuaValue &amp;value);
};</pre>
<p>And in <strong class="source-inline">LuaExecutor.cc</strong>, implement the <span class="No-Break"><strong class="source-inline">pushValue</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
void LuaExecutor::pushValue(const LuaValue &amp;value)
{
    switch (getLuaType(value))
    {
    case LuaType::nil:
        lua_pushnil(L);
        break;
    case LuaType::boolean:
        lua_pushboolean(L,
            std::get&lt;LuaBoolean&gt;(value).value ? 1 : 0);
        break;
    case LuaType::number:
        lua_pushnumber(L,
            std::get&lt;LuaNumber&gt;(value).value);
        break;
    case LuaType::string:
        lua_pushstring(L,
            std::get&lt;LuaString&gt;(value).value.c_str());
        break;
    }
}</pre>
<p>Our implementation only uses one <strong class="source-inline">switch</strong> statement on <strong class="source-inline">LuaType</strong>. We implemented <strong class="source-inline">getLuaType</strong> in <strong class="source-inline">LuaType.hpp</strong> earlier in this chapter. In each <strong class="source-inline">case</strong>, we use <strong class="source-inline">std::get</strong> to get the typed <a id="_idIndexMarker205"/>value from the <strong class="source-inline">LuaValue</strong> type union. Next, we will look at the <span class="No-Break">popping part.</span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Popping from the stack</h2>
<p>Popping from the<a id="_idIndexMarker206"/> Lua stack is a reverse operation of the pushing part. We will get the value from the Lua stack and use the Lua <strong class="source-inline">lua_type</strong> library function to check its Lua type, and then create a C++ <strong class="source-inline">LuaValue</strong> object with a <span class="No-Break">matching </span><span class="No-Break"><strong class="source-inline">LuaType</strong></span><span class="No-Break">.</span></p>
<p>To make things more modular, we will create <span class="No-Break">two functions:</span></p>
<ul>
<li><strong class="source-inline">getValue</strong> to convert a Lua stack position to <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">LuaValue</strong></span></li>
<li><strong class="source-inline">popValue</strong> to pop and return the top of <span class="No-Break">the stack</span></li>
</ul>
<p>Add the following declarations <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">LuaExecutor.h</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
class LuaExecutor
{
private:
    LuaValue getValue(int index);
    LuaValue popValue();
};</pre>
<p>In <strong class="source-inline">LuaExecutor.cc</strong>, let us first <span class="No-Break">implement </span><span class="No-Break"><strong class="source-inline">getValue</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
LuaValue LuaExecutor::getValue(int index)
{
    switch (lua_type(L, index))
    {
    case LUA_TNIL:
        return LuaNil::make();
    case LUA_TBOOLEAN:
        return LuaBoolean::make(
            lua_toboolean(L, index) == 1);
    case LUA_TNUMBER:
        return LuaNumber::make(
            (double)lua_tonumber(L, index));
    case LUA_TSTRING:
        return LuaString::make(lua_tostring(L, index));
    default:
        return LuaNil::make();
    }
}</pre>
<p>The code is quite <a id="_idIndexMarker207"/>straightforward. First, we check the Lua type of a requested stack location, and then we return a <strong class="source-inline">LuaValue</strong> accordingly. For the unsupported Lua types, for example, table and function, we just return <strong class="source-inline">LuaNil</strong> for now. With this, we can implement <strong class="source-inline">popValue</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
LuaValue LuaExecutor::popValue()
{
    auto value = getValue(-1);
    lua_pop(L, 1);
    return value;
}</pre>
<p>We first call <strong class="source-inline">getValue</strong> with <strong class="source-inline">-1</strong> as the stack location to get the top of the stack. Then we pop the top of <span class="No-Break">the stack.</span></p>
<p>With the stack operations<a id="_idIndexMarker208"/> implemented, we can now implement the new <strong class="source-inline">call</strong> function by putting the stack <span class="No-Break">operations together.</span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor101"/>Putting it together</h2>
<p>Take a moment to <a id="_idIndexMarker209"/>read the old <strong class="source-inline">call</strong> function implementation again. It is shown <span class="No-Break">as follows:</span></p>
<pre class="source-code">
std::string LuaExecutor::call(
    const std::string &amp;function,
    const std::string &amp;param)
{
    int type = lua_getglobal(L, function.c_str());
    assert(LUA_TFUNCTION == type);
    lua_pushstring(L, param.c_str());
    pcall(1, 1);
    return popString();
}</pre>
<p>To implement our new <strong class="source-inline">call</strong> function, not much needs to be changed. We only need to replace the two lines of code doing stack operations with the new helper functions we have just implemented. Write the new call function in <strong class="source-inline">LuaExecutor.cc</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
LuaValue LuaExecutor::call(
    const std::string &amp;function, const LuaValue &amp;param)
{
    int type = lua_getglobal(L, function.c_str());
    assert(LUA_TFUNCTION == type);
    pushValue(param);
    pcall(1, 1);
    return popValue();
}</pre>
<p>We have replaced the lines working with <strong class="source-inline">std::string</strong> with new lines working <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">LuaValue</strong></span><span class="No-Break">.</span></p>
<p>Since we have a dedicated <strong class="source-inline">getValue</strong> function and <strong class="source-inline">popValue</strong> to covert a raw Lua value to a <strong class="source-inline">LuaValue</strong>, we can take the chance to make <strong class="source-inline">popString</strong> use them as well. Rewrite it <span class="No-Break">as follows:</span></p>
<pre class="source-code">
std::string LuaExecutor::popString()
{
    auto result = std::get&lt;LuaString&gt;(popValue());
    return result.value;
}</pre>
<p>Here, we have gotten rid of the use of Lua library functions in <strong class="source-inline">popString</strong>. It is a good practice to limit the dependency on a third-party library to only a few functions. Another way to think about <a id="_idIndexMarker210"/>this is, in a class, internally, there can be low-level functions and <span class="No-Break">high-level functions.</span></p>
<p>Next, let us test our improved <span class="No-Break">Lua executor.</span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor102"/>Testing it out</h2>
<p>Because we have <a id="_idIndexMarker211"/>used C++17 features to implement <strong class="source-inline">LuaValue</strong>, we will write the test code in modern C++ as well. Write <strong class="source-inline">main.cpp</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    lua-&gt;executeFile("script.lua");
    auto value1 = lua-&gt;call(
        "greetings", LuaString::make("C++"));
    std::cout &lt;&lt; getLuaValueString(value1) &lt;&lt; std::endl;
    auto value2 = lua-&gt;call(
        "greetings", LuaNumber::make(3.14));
    std::cout &lt;&lt; getLuaValueString(value2) &lt;&lt; std::endl;
    return 0;
}</pre>
<p>In this test code, we first use <strong class="source-inline">std::unique_ptr</strong> to hold our Lua executor and its listener, and then load the Lua script with the <strong class="source-inline">greetings</strong> Lua function. This Lua function is from the last chapter. The real actions are calling the Lua function twice: first with <strong class="source-inline">LuaString</strong>, then <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">LuaNumber</strong></span><span class="No-Break">.</span></p>
<p>Compile and run the test code. If you have done everything correctly, you should see the <span class="No-Break">following output:</span></p>
<pre class="source-code">
Hello C++
Hello 3.14</pre>
<p>If you see compiler<a id="_idIndexMarker212"/> or linker errors, do not feel discouraged. It is common to see a few cryptic error messages when building new C++ code, especially when applying new knowledge. Trace the errors and try to correct them. You can also compare with the code in GitHub if you <span class="No-Break">need to.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">We have learned a lot so far. Our improved Lua executor can call Lua functions with a more flexible argument, although it is still only accepting one argument. By now, you should be comfortable and confident in using a common C++ type to represent different Lua types. Take a break and reflect, before moving on to further improve our Lua executor to call Lua functions with a variable number <span class="No-Break">of arguments.</span></p>
<p>Now, let us <a id="_idIndexMarker213"/>continue to improve our <span class="No-Break">Lua executor.</span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Supporting a variable number of arguments</h1>
<p>The Lua <strong class="source-inline">function</strong> supports a variable <a id="_idIndexMarker214"/>number of arguments. Let us implement one <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">script.lua</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
function greetings(...)
    local result = "Hello"
    for i, v in ipairs{...} do
        result = result .. " " .. v .. ","
    end
    return result
end</pre>
<p>This will return a greeting message and include all arguments in the message. The three dots (<strong class="source-inline">...</strong>) indicate that the function takes a variable number of arguments. We can iterate through the arguments <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">ipairs</strong></span><span class="No-Break">.</span></p>
<p>How can we support this in C++? For the stack operations, we only need to push more values. The main decision is how we should declare the Lua executor <strong class="source-inline">call</strong> function to accept a variable number <span class="No-Break">of arguments.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>Implementing the C++ function</h2>
<p>Since C++11, we <a id="_idIndexMarker215"/>can<a id="_idIndexMarker216"/> use<a id="_idIndexMarker217"/> a <strong class="bold">variadic function template</strong> to <a id="_idIndexMarker218"/>pass a <strong class="bold">parameter pack</strong>. A parameter pack is a list of arguments of <span class="No-Break">any size.</span></p>
<p>In <strong class="source-inline">LuaExecutor.h</strong>, change the <strong class="source-inline">call</strong> function declaration to <span class="No-Break">the following:</span></p>
<pre class="source-code">
template &lt;typename... Ts&gt;
LuaValue call(const std::string &amp;function,
              const Ts &amp;...params);</pre>
<p><strong class="source-inline">typename... Ts</strong> defines a template parameter pack, and the function takes it as the <span class="No-Break"><strong class="source-inline">params</strong></span><span class="No-Break"> argument.</span></p>
<p>Now, let us implement it. Delete the <strong class="source-inline">call</strong> implementation in <strong class="source-inline">LuaExecutor.cc</strong>. Since we are now<a id="_idIndexMarker219"/> using templates, we<a id="_idIndexMarker220"/> need to put the implementation in the header file. In <strong class="source-inline">LuaExecutor.h</strong>, add the code <span class="No-Break">as follows:</span></p>
<pre class="source-code">
template &lt;typename... Ts&gt;
LuaValue LuaExecutor::call(const std::string &amp;function,
                           const Ts &amp;...params)
{
    int type = lua_getglobal(L, function.c_str());
    assert(LUA_TFUNCTION == type);
    for (auto param :
        std::initializer_list&lt;LuaValue&gt;{params...})
    {
        pushValue(param);
    }
    pcall(sizeof...(params), 1);
    return popValue();
}</pre>
<p>This implementation can be broken down into four steps, separated by empty lines <span class="No-Break">in code:</span></p>
<ul>
<li>It gets the Lua function to call. This has <span class="No-Break">not changed.</span></li>
<li>It pushes the C++ function arguments. Here, we choose to make a <strong class="source-inline">std::initializer_list</strong> from the parameter pack and loop <span class="No-Break">through it.</span></li>
<li>It calls the Lua function. We use <strong class="source-inline">sizeof...(params)</strong> to get the size of the parameter pack and tell Lua we are sending that <span class="No-Break">many arguments.</span></li>
<li>It gets the return value from the Lua function and <span class="No-Break">returns it.</span></li>
</ul>
<p>There is more than one way to accomplish <em class="italic">step 2</em>. You can use a lambda to unpack the parameter pack, and there are even different options to write this lambda. When, in due course, <strong class="bold">C++20</strong> gets <a id="_idIndexMarker221"/>adopted, you will have even more options. Those are, however, outside the scope of this book. Here, we choose to use a more conventional way to implement, so<a id="_idIndexMarker222"/> that it is <a id="_idIndexMarker223"/>easier to understand by <span class="No-Break">more people.</span></p>
<p>Next, let us test whether our <span class="No-Break">implementation works.</span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>Testing it out</h2>
<p>In <strong class="source-inline">main.cpp</strong>, replace <a id="_idIndexMarker224"/>the lines that call <strong class="source-inline">lua-&gt;call</strong> and print the result <span class="No-Break">as follows:</span></p>
<pre class="source-code">
auto result = lua-&gt;call("greetings",
    LuaString::make("C++"), LuaString::make("Lua"));
std::cout &lt;&lt; getLuaValueString(result) &lt;&lt; std::endl;</pre>
<p>In the test code, we have passed two strings to the Lua <strong class="source-inline">greetings</strong> function. Since we support a variable number of arguments, you can pass as many arguments as you want, zero included. You should see an output similar to <strong class="source-inline">Hello </strong><span class="No-Break"><strong class="source-inline">C++, Lua,</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Some more words on our mechanism</h2>
<p>By now, we have<a id="_idIndexMarker225"/> implemented in our Lua executor a general function to call any Lua functions, and with any number of arguments. Please take a moment to ponder on the following points, which will deepen <span class="No-Break">your understanding:</span></p>
<ul>
<li><em class="italic">The Lua function being called does not need to be declared as accepting a variable number of arguments, while our C++ function is.</em> When calling a Lua function from C++, you always need to tell the Lua library how many arguments have been pushed onto <span class="No-Break">the stack.</span></li>
<li><em class="italic">The Lua function does not need to return a value.</em> You can try to comment out the return statement in the <strong class="source-inline">greetings</strong> function. The C++ side will get a <strong class="source-inline">LuaNil</strong>, because the Lua library guarantees to push the requested number of return values onto the stack, using nil when the Lua function does not return <span class="No-Break">enough values.</span></li>
<li><em class="italic">The Lua function can return more than one value.</em> We will only get the first value, and the Lua library will discard the rest, because when calling the Lua function, we requested only one <span class="No-Break">return value.</span></li>
</ul>
<p>Our current implementation already supports most of the use cases for calling plain Lua functions, except for<a id="_idIndexMarker226"/> the last point mentioned above. Next, we will support multiple return values to complete the Lua function <span class="No-Break">call mechanism.</span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/>Supporting multiple return values</h1>
<p>To work on retrieving<a id="_idIndexMarker227"/> multiple return values, let us first make a Lua function that actually does that. In <strong class="source-inline">script.lua</strong>, add the <span class="No-Break">following function:</span></p>
<pre class="source-code">
function dump_params(...)
    local results = {}
    for i, v in ipairs{...} do
        results[i] = i .. ": " .. tostring(v) ..
            " [" .. type(v) .. "]"
    end
    return table.unpack(results)
end</pre>
<p>This will get every argument and print out its type. We first put them in a table, then we unpack the table so that each table entry is returned as a <span class="No-Break">separate value.</span></p>
<p>Now, we have some decisions to make. We are happy with the current <strong class="source-inline">call</strong> function except for its return value. However, we cannot overload a function in C++ for a different return type. We need to create another function that returns a list <span class="No-Break">of values.</span></p>
<p>How can we get multiple return values from Lua? Compared with <strong class="source-inline">call</strong>, there are two differences that we need <span class="No-Break">to tackle:</span></p>
<ul>
<li>How can we tell the Lua library that we are expecting a variable number of return values, instead of a <span class="No-Break">fixed number?</span></li>
<li>How can we get this variable number of return values <span class="No-Break">in C++?</span></li>
</ul>
<p>To tackle the first problem, while calling the Lua library <strong class="source-inline">lua_pcall</strong> function, we can specify a magic number for the number of expected return values: <strong class="source-inline">LUA_MULTRET</strong>. This means that we will take whatever the Lua function returns, without the library discarding extra return values or padding with nil. This magic number is the only special case to specify the number of return values. It is internally defined as <strong class="source-inline">-1</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">lua.h</strong></span><span class="No-Break">.</span></p>
<p>To tackle the second problem, we only need to count how many elements there are in the Lua stack before calling the Lua function, and how many elements there are after calling the Lua function. This is because the Lua library pushes all return values onto the stack, so the new <a id="_idIndexMarker228"/>elements in the stack are the return values. We have implemented <strong class="source-inline">popValue</strong> to pop the top of the stack. We need another function to pop more than one value from <span class="No-Break">the stack.</span></p>
<p>With the two problems solved, let us start <span class="No-Break">to implement.</span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>Implementing the C++ function</h2>
<p>In <strong class="source-inline">LuaExecutor.h</strong>, add <a id="_idIndexMarker229"/>the <span class="No-Break">following declarations:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    template &lt;typename... Ts&gt;
    std::vector&lt;LuaValue&gt; vcall(
        const std::string &amp;function,
        const Ts &amp;...params);
private:
    std::vector&lt;LuaValue&gt; popValues(int n);
};</pre>
<p>We added another function to call Lua functions. We call it <strong class="source-inline">vcall</strong> because it returns a <strong class="source-inline">std::vector</strong>. We also added a <strong class="source-inline">popValues</strong> helper function to pop the top <strong class="source-inline">n</strong> elements from the <span class="No-Break">Lua stack.</span></p>
<p>First, let us<a id="_idIndexMarker230"/> implement <strong class="source-inline">vcall</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">LuaExecutor.h</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
template &lt;typename... Ts&gt;
std::vector&lt;LuaValue&gt; LuaExecutor::vcall(
    const std::string &amp;function, const Ts &amp;...params)
{
    int stackSz = lua_gettop(L);
    int type = lua_getglobal(L, function.c_str());
    assert(LUA_TFUNCTION == type);
    for (auto param :
        std::initializer_list&lt;LuaValue&gt;{params...})
    {
        pushValue(param);
    }
    if (pcall(sizeof...(params), LUA_MULTRET))
    {
        int nresults = lua_gettop(L) - stackSz;
        return popValues(nresults);
    }
    return std::vector&lt;LuaValue&gt;();
}</pre>
<p>We now have five steps, which are explained <span class="No-Break">as follows:</span></p>
<ol>
<li>Record the stack size before doing anything else <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">lua_gettop</strong></span><span class="No-Break">.</span></li>
<li>Get the Lua function onto the stack <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">lua_getglobal</strong></span><span class="No-Break">.</span></li>
<li>Push all the arguments onto the stack <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">pushValue</strong></span><span class="No-Break">.</span></li>
<li>Call the Lua function with <strong class="source-inline">pcall</strong> and pass <strong class="source-inline">LUA_MULTRET</strong> to indicate that we will take all the return values from the Lua function. The Lua library will guarantee to pop all elements you pushed in <em class="italic">step 2</em> and <span class="No-Break"><em class="italic">step 3</em></span><span class="No-Break">.</span></li>
<li>Pop all the return values from the stack and return them with <strong class="source-inline">popValues</strong>. We check the stack size again. The new stack size minus the original stack size stored in <strong class="source-inline">stackSz</strong> is the number of <span class="No-Break">values returned.</span></li>
</ol>
<p>Next, we <a id="_idIndexMarker231"/>will implement the final piece, the helper function, to pop all return values from the Lua stack. In <strong class="source-inline">LuaExecutor.cc</strong>, add the <span class="No-Break">following code:</span></p>
<pre class="source-code">
std::vector&lt;LuaValue&gt; LuaExecutor::popValues(int n)
{
    std::vector&lt;LuaValue&gt; results;
    for (int i = n; i &gt; 0; --i)
    {
        results.push_back(getValue(-i));
    }
    lua_pop(L, n);
    return results;
}</pre>
<p>Lua pushes the first return value onto the stack, then the second, and so on. So, the top of the stack needs to be stored at the end of the vector. Here, we read the return values in sequence, starting from the middle of the stack and moving toward the top of the stack. <strong class="source-inline">-i</strong> is the <strong class="source-inline">ith</strong> position <a id="_idIndexMarker232"/>counting from the top of <span class="No-Break">the stack.</span></p>
<p>Next, let’s test <span class="No-Break">this out.</span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>Testing it out</h2>
<p>In <strong class="source-inline">main.cpp</strong>, change the<a id="_idIndexMarker233"/> test code <span class="No-Break">as follows:</span></p>
<pre class="source-code">
auto results = lua-&gt;vcall(
    "dump_params",
    LuaString::make("C++"),
    LuaString::make("Lua"),
    LuaNumber::make(3.14),
    LuaBoolean::make(true),
    LuaNil::make());
for (auto result : results)
{
    std::cout &lt;&lt; getLuaValueString(result) &lt;&lt; std::endl;
}</pre>
<p>We are passing a list of different types of <strong class="source-inline">LuaValue</strong> (<strong class="source-inline">LuaString</strong>, <strong class="source-inline">LuaNumber</strong>, <strong class="source-inline">LuaBoolean</strong> and <strong class="source-inline">LuaNil</strong>) to our new function. This will output <span class="No-Break">the following:</span></p>
<pre class="source-code">
1: C++ [string]
2: Lua [string]
3: 3.14 [number]
4: true [boolean]</pre>
<p>Have you observed anything unusual? We have passed five arguments but only got four return values! <strong class="source-inline">LuaNil</strong> is not printed out. Why? This is because, in <strong class="source-inline">dump_params</strong>, we used <strong class="source-inline">table.unpack</strong> to return multiple values. Lua’s <strong class="source-inline">table.unpack</strong> will stop when it sees a nil value. If you move <strong class="source-inline">LuaNil::make()</strong> to the middle of the list, you will miss more return<a id="_idIndexMarker234"/> values. This is expected. This is a Lua thing. Similar to a C++ <strong class="source-inline">char*</strong> string, it will end when it first sees a <span class="No-Break"><strong class="source-inline">NULL</strong></span><span class="No-Break"> character.</span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Summary</h1>
<p>In this chapter, we first explored how to map Lua types to C++ types, with the goal of ease of use in C++ function calls. Then, we learned about a general way to call any <span class="No-Break">Lua functions.</span></p>
<p>This chapter progressed step by step. You continued to improve the Lua executor. Each step produced a milestone. This, in turn, was based on the work from the last chapter. Going through the following exercises will also give you a chance to recap what you have learned with hands-on coding. We will continue the book with <span class="No-Break">this methodology.</span></p>
<p>In the next chapter, we will learn how to integrate <span class="No-Break">Lua tables.</span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Exercises</h1>
<ol>
<li>Implement <strong class="source-inline">LuaType::function</strong> and <strong class="source-inline">LuaFunction</strong> to cover the Lua function type. Do not worry about the value field in <strong class="source-inline">LuaFunction</strong>. You can use <strong class="source-inline">nullptr</strong>. To test it, you need to call a Lua function that returns another function, and in C++, print out that the return value is <span class="No-Break">a function.</span></li>
<li>Implement <strong class="source-inline">LuaType::table</strong> and <strong class="source-inline">LuaTable</strong> to cover the Lua table type. Follow the same instructions as for the <span class="No-Break">previous question.</span></li>
<li>In the last chapter, we implemented <strong class="source-inline">getGlobalString</strong> and <strong class="source-inline">setGlobal</strong> to work with Lua global values. Rewrite those two methods to support more types. You can use the new names <strong class="source-inline">getGlobal</strong> and <strong class="source-inline">setGlobal</strong>, and <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">LuaValue</strong></span><span class="No-Break">.</span></li>
<li>Implement a private <strong class="source-inline">dumpStack</strong> debug function. This function will dump the current Lua stack. You only need to support the currently supported types in <strong class="source-inline">LuaValue</strong>. Insert a call to this function in different places in <strong class="source-inline">LuaExecutor</strong>. This will deepen your understanding of the <span class="No-Break">Lua stack.</span></li>
</ol>
</div>
</div></body></html>