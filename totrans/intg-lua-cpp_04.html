<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-88"><a id="_idTextAnchor088"/>4</h1>
<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Mapping Lua Types to C++</h1>
<p>In the previous chapter, we learned how to call a Lua function with a single string argument that returns one string value. In this chapter, we will learn how to call a Lua function with any type and any number of arguments and support multiple return values. To do this, we need to find a convenient way to map Lua types to C++ types. Then, we will build upon this type system to improve our Lua executor step by step. During this process, you will continue to deepen your understanding of the Lua stack and learn how to use some of the modern C++ features to integrate Lua.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Mapping Lua types</li>
<li>Supporting different argument types</li>
<li>Supporting a variable number of arguments</li>
<li>Supporting multiple return values</li>
</ul>
<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Technical requirements</h1>
<p>This chapter is more C++ coding intensive. To better follow this chapter, please make sure you understand the following:</p>
<ul>
<li>You are familiar with the modern C++ standards. We will start to use features from <strong class="bold">C++11</strong> and <strong class="bold">C++17</strong>. If you have only used <strong class="bold">C++03</strong>, please take a while to study the new C++ features on your own when you encounter them in this chapter. As a heads-up, we will use <strong class="bold">enum class</strong>, <strong class="bold">std::variant</strong>, <strong class="bold">std::visit</strong>, and <strong class="bold">std::initializer_list</strong>.</li>
<li>You can access the source code for this chapter here: <a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter04">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter04</a>.</li>
<li>You can understand and execute the code in the <code>begin</code> folder from the preceding GitHub link. The <code>begin</code> folder has some necessary solutions from the last chapter’s questions integrated and acts as the starting point for this chapter. We will add new features implemented in this chapter to it.</li>
</ul>
<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>Mapping Lua types</h1>
<p>In <em class="italic">Chapter 2</em>, <em class="italic">Lua Fundamentals</em>, we<a id="_idIndexMarker162"/> learned about the Lua types. They are different from C++ types. To use them in C++, we need to do some mapping. In <em class="italic">Chapter 3</em>, <em class="italic">How to Call Lua from C++</em>, we mapped the Lua string to the C++ <code>std::string</code>. It is mapped by hardcoding it in our Lua executor.</p>
<p>What if we want to support all possible Lua types, both in the function arguments and in function return values? What if we want to call Lua functions with different numbers of arguments? It is not feasible to create a C++ function for each argument type and argument count combination. That way, our Lua executor would be plagued with hundreds of functions just to call Lua functions!</p>
<p>Fortunately, C++ is powerful <a id="_idIndexMarker163"/>with its <strong class="bold">object-oriented programming</strong> and<a id="_idIndexMarker164"/> its <strong class="bold">generic programming</strong>. These two paradigms lead to two different ways in which you can solve problems in C++.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Exploring different mapping options</h2>
<p>As said, C++ supports <a id="_idIndexMarker165"/>object-oriented programming and generic programming. We can design a type system with either of them.</p>
<h3>Using object-oriented types</h3>
<p>This approach is <a id="_idIndexMarker166"/>probably easier to<a id="_idIndexMarker167"/> understand. It has been supported since the birth of C++. We can define an abstract base class that represents all possible types, then inherit it and implement a concrete class for each type.</p>
<p>Besides C++, most programming languages support this method. If you or your team work with multiple programming languages, this method might cause less concept switching in work.</p>
<p>But this approach is also more verbose. You will have other considerations as well. For example, after the mappings are defined, you would want to prevent creating new types that do not exist in <a id="_idIndexMarker168"/>Lua. You would have to<a id="_idIndexMarker169"/> make base class constructors private and declare a few friends.</p>
<h3>Using generic types</h3>
<p>This approach<a id="_idIndexMarker170"/> depends on<a id="_idIndexMarker171"/> a new C++17 feature: <em class="italic">std::variant</em>. You can define and map a simple C++ class for each Lua type without inheritance. Then you create a union type with <code>std::variant</code>, saying that this union type may be and can only be from the pre-defined Lua mappings.</p>
<p>This will result in less code. The less code, the less chance that something will go wrong. Modern programming tends to adopt new paradigms, besides the vanilla object-oriented methodology.</p>
<p>The drawback of this approach is that not all organizations adopt the new C++ standards that fast, which in turn makes them less widely understood.</p>
<p>In this chapter, we will implement that approach. After going through this chapter, if you prefer, you can implement object-oriented types on your own. But before we move on, let us look at the <code>Makefile</code> used for this chapter.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Introducing some new Makefile tricks</h2>
<p>Before diving <a id="_idIndexMarker172"/>into the<a id="_idIndexMarker173"/> details, let us go through the <code>Makefile</code>. You can find a copy in the <code>begin</code> folder in the GitHub repository, as follows:</p>
<pre class="source-code">
LUA_PATH = ../../lua
CXX = g++
CXXFLAGS = -std=c++17 -Wall -Werror
CPPFLAGS = -I${LUA_PATH}/src
LDFLAGS = -L${LUA_PATH}/src
EXECUTABLE = executable
ALL_O = main.o LuaExecutor.o LoggingLuaExecutorListener.o
all: clean lua project
lua:
    @cd ${LUA_PATH} &amp;&amp; make
project: ${ALL_O}
    $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) -o $(EXECUTABLE) 
     ${ALL_O} -llua
clean:
    rm -f ${ALL_O} $(EXECUTABLE)</pre>
<p>There are only<a id="_idIndexMarker174"/> four<a id="_idIndexMarker175"/> differences compared to the <code>Makefile</code> used in <em class="italic">Chapter 3</em>:</p>
<ul>
<li>In <code>CXXFLAGS</code>, we require the compiler to compile our code as C++17 by adding <code>-std=c++17</code>. Without this, it will use the default standard, which may be an older C++ version.</li>
<li>A new variable, <code>ALL_O</code>, defines all the object files that will be produced. Each C++ source file will be compiled into an object file. Remember to add a new object file here when you add a new source file. Otherwise, without the object file produced, the linker cannot find the symbols that should have been in the missing object file, and you will get linker errors.</li>
<li>The <code>project</code> target now depends on all object files. <code>Make</code> is smart enough to compile the object files from the source files for you automatically by using the corresponding source file as a dependency for the object file.</li>
<li>The <code>all</code> target has an extra dependency: the <code>clean</code> target. This always cleans the project and rebuilds it. When you write an object file target manually, you can make it depend on multiple header files. When <code>Make</code> does this for you, it cannot tell which header files need to be depended on. So, this is a trick for small projects for study purposes. For more formal projects, you should consider supporting compiling everything correctly without cleaning it first.</li>
</ul>
<p>If you struggle to understand this <code>Makefile</code>, please check the explanation in <em class="italic">Chapter 1</em> and <em class="italic">Chapter 3</em>. Better yet, you can research more online. If you have no urgent need to learn about the <code>Makefile</code>, it is also perfectly fine just to use it as it is, and be comfortable with it.</p>
<p class="callout-heading">Remember</p>
<p class="callout">The <code>Makefile</code> examples used in this book favor simplicity, rather than production flexibility.</p>
<p>We have distracted ourselves a bit from C++ by explaining some new <code>Makefile</code> mechanisms. This will be the last time we go through a <code>Makefile</code> in this book. In the following chapters, please refer to the GitHub source code.</p>
<p>The explanation was necessary, in case you get cryptic errors from the C++ compiler and linker. Now we can go back to our focus. We will define some simple C++ structures that map to Lua types. After this, we can use <code>std::variant</code> to declare a union type. Having a<a id="_idIndexMarker176"/> union<a id="_idIndexMarker177"/> type will enable us to pass a value of any type to our C++ functions. Now, let us define the Lua types in C++.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Defining Lua types in C++</h2>
<p>The first order <a id="_idIndexMarker178"/>of business <a id="_idIndexMarker179"/>is how we can define a Lua type in C++. We want a clear definition of Lua types, so things such as <code>std::string</code> are no longer unique enough.</p>
<p>Since C++11, we have <em class="italic">enum class</em> support. We can limit our Lua types with an enum class in C++ as follows:</p>
<pre class="source-code">
enum class LuaType
{
    nil,
    boolean,
    number,
    string,
};</pre>
<p>For now, we only support the Lua basic types that can map to simple C++ types. You can put this declaration in a file named <code>LuaType.hpp</code> and include it in <code>LuaExecutor.h</code> as shown here:</p>
<pre class="source-code">
#include "LuaType.hpp"</pre>
<p>We call it <code>*.hpp</code> because we will put the type implementations in the header file directly and inline all the functions. This is partly because the implementation classes will be simple, and partly because this is a book, and limiting the number of lines of code is important. You can separate the code into a header file and a source file or name this header file with<a id="_idIndexMarker180"/> implementations <code>LuaType.h</code>. This depends on convention, as per <a id="_idIndexMarker181"/>each company or organization, and there are many ways to do something in C++.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Implementing Lua types in C++</h2>
<p>As explained, we will <a id="_idIndexMarker182"/>use simple classes without inheritance. Each<a id="_idIndexMarker183"/> class will have two fields: a <code>type</code> field of <code>LuaType</code> we just defined, and a <code>value</code> field for the actual data storage in C++.</p>
<p>In <code>LuaType.hpp</code>, implement four structures. In C++, a structure is the same as a class, but with public access to its members by default. We use structures conventionally when we want to define data. First, implement <code>LuaType::nil</code>:</p>
<pre class="source-code">
#include &lt;cstddef&gt;
struct LuaNil final
{
    const LuaType type = LuaType::nil;
    const std::nullptr_t value = nullptr;
    static LuaNil make() { return LuaNil(); }
private:
    LuaNil() = default;
};</pre>
<p>We choose to use <code>nullptr</code> to represent a Lua nil value. Its type is <code>std::nullptr_t</code>. We also make the constructor private and provide a static function to <a id="_idIndexMarker184"/>create <a id="_idIndexMarker185"/>new objects.</p>
<p class="callout-heading">Design patterns</p>
<p class="callout">Here, we used a design pattern – the static factory method with a private constructor. In our implementation, this will prevent creating objects on the heap with <code>new</code>. The C++ structures for Lua types do not provide copy constructors either. This is a design choice – you either fully support passing it around and assigning to it or limit its usage. In this book, we limit its usage purely when interacting with the Lua executor on the C++ stack. If you have another layer above the Lua executor, you need to convert the structures to C++ basic types or your own type. This helps with abstraction.</p>
<p>Similarly, implement <code>LuaType::boolean</code>:</p>
<pre class="source-code">
struct LuaBoolean final
{
    const LuaType type = LuaType::boolean;
    const bool value;
    static LuaBoolean make(const bool value)
    {
        return LuaBoolean(value);
    }
private:
    LuaBoolean(const bool value) : value(value) {}
};</pre>
<p>The static <code>make</code> function accepts a <code>boolean</code> value to create an instance. In the private constructor, we use a member initializer list to initialize the <code>value</code> member variable.</p>
<p>For <code>LuaType::number</code>, we choose to use the C++ double type to store the value:</p>
<pre class="source-code">
struct LuaNumber final
{
    const LuaType type = LuaType::number;
    const double value;
    static LuaNumber make(const double value)
    {
        return LuaNumber(value);
    }
private:
    LuaNumber(const double value) : value(value) {}
};</pre>
<p>Lua itself does<a id="_idIndexMarker186"/> not <a id="_idIndexMarker187"/>distinguish between an integer and a float in the basic <em class="italic">number</em> type, but if you need to, you can create two C++ types for integers and floats separately. To do this, you can use the Lua <code>lua_isinteger</code> library function to check whether the number is an integer. If it is not, it is a double. In this book, we only implement mappings for the basic Lua types. In a gaming system, you might want to enforce using the float type. In an embedded system, you might want to enforce using the integer type. Or, you can support using both in a project. This is easy to achieve by referencing the implementation for <code>LuaNumber</code>.</p>
<p class="callout-heading">Linking knowledge</p>
<p class="callout">In Lua code, you can use the <code>math.type</code> library function to check whether a number is an integer or a float.</p>
<p>And finally, for <code>LuaType::string</code>, we use <code>std::string</code> to store the value:</p>
<pre class="source-code">
#include &lt;string&gt;
struct LuaString final
{
    const LuaType type = LuaType::string;
    const std::string value;
    static LuaString make(const std::string &amp;value)
    {
        return LuaString(value);
    }
private:
    LuaString(const std::string &amp;value) : value(value) {}
};</pre>
<p>This<a id="_idIndexMarker188"/> concludes <a id="_idIndexMarker189"/>our type implementations. Next is where all the magic happens.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Implementing a union type</h2>
<p>We have<a id="_idIndexMarker190"/> defined a <code>LuaType</code> enum class to identify Lua types, and <a id="_idIndexMarker191"/>structures to represent Lua values of different types. When we want to pass a Lua value around, we need a type to represent them all. Without using a common base class, we can use <code>std::variant</code>. It is a template class taking a list of types as its parameters. Then it can safely represent any of these types in code. To see it in action, add the following to <code>LuaType.hpp</code>:</p>
<pre class="source-code">
#include &lt;variant&gt;
using LuaValue = std::variant&lt;
    LuaNil, LuaBoolean, LuaNumber, LuaString&gt;;</pre>
<p>The <code>using</code> keyword <a id="_idIndexMarker192"/>creates a type alias, <code>LuaValue</code>. It can represent any of the four specified types in the template parameters.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Working with the union type</h2>
<p>If you have not <a id="_idIndexMarker193"/>used <code>std::variant</code> before, you may <a id="_idIndexMarker194"/>have wondered how can we tell which actual type it is holding. If you pass a value of <code>LuaValue</code> around, you cannot access the <code>type</code> or the <code>value</code> field directly. This is because there is no common base class. At compile time, the compiler does not know what fields are supported by simply looking at the <code>std::variant</code> variable. To do this, we need a small twist. C++17 also provides <code>std::visit</code> to help with this. Let us implement a helper function to get the <code>LuaType</code> from a <code>LuaValue</code>. In <code>LuaType.hpp</code>, add the code as follows:</p>
<pre class="source-code">
inline LuaType getLuaType(const LuaValue &amp;value)
{
    return std::visit(
        [](const auto &amp;v) { return v.type; },
        value);
}</pre>
<p>This function is an <code>the call site more efficient. Moreover, it needs to be an inline function because we are implementing it in the header file directly. Without the <strong class="source-inline">inline</code> keyword, the function may get included in different source files with the same symbol, which leads to link errors.</p>
<p><code>std::visit</code> takes two arguments. The first is<a id="_idIndexMarker196"/> a C++ <code>std::visit</code> makes the type information available. If you have never come across this concept or usage before, it may take some time to digest. You can consider this<a id="_idIndexMarker197"/> callable a <strong class="bold">lambda</strong>. If you have used lambda from other programming languages, such as Java, Kotlin, Swift, or Python, the C++ one is very similar. In other programming languages, more often than not, the lambda is the last parameter, which is <a id="_idIndexMarker198"/>called a <strong class="bold">trailing lambda</strong> and in some cases is easier to read. The best way to learn about C++ lambda is to use it and try to feel comfortable with it until you have fully mastered it.</p>
<p>With this, let us implement another helper function to get the string representation of each<a id="_idIndexMarker199"/> type. In <code>LuaTypp.hpp</code>, add <a id="_idIndexMarker200"/>the following function:</p>
<pre class="source-code">
inline std::string
getLuaValueString(const LuaValue &amp;value)
{
    switch (getLuaType(value))
    {
    case LuaType::nil:
        return "nil";
    case LuaType::boolean:
        return std::get&lt;LuaBoolean&gt;(value).value
            ? "true" : "false";
    case LuaType::number:
        return std::to_string(
            std::get&lt;LuaNumber&gt;(value).value);
    case LuaType::string:
        return  std::get&lt;LuaString&gt;(value).value;
    }
}</pre>
<p>This will help us to test our implementations in the rest of this chapter by getting what is stored in a <code>LuaValue</code>. You can use <code>std::get</code> to get a specific type from a <code>std::variant</code> union.</p>
<p>We have talked about <code>std::variant</code>, <code>std::visit</code>, and <code>std::get</code>, but not enough to be a C++ expert in this area. Before moving on, feel free to research more on them.</p>
<p>Next, let us use the <a id="_idIndexMarker201"/>Lua mapping we have implemented to make <a id="_idIndexMarker202"/>calling Lua functions more flexible. First, we will get rid of the hardcoded <code>std::string</code> used for the <code>call</code> function in our Lua executor.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Supporting different argument types</h1>
<p>In the last chapter, w<a id="_idIndexMarker203"/>e implemented our C++ function to call a Lua function as follows:</p>
<pre class="source-code">
std::string call(const std::string &amp;function,
                 const std::string &amp;param);</pre>
<p>Our goal in this step is to make it more general and we want the following instead:</p>
<pre class="source-code">
LuaValue call(const std::string &amp;function,
              const LuaValue &amp;param);</pre>
<p>In fact, go ahead and change this in <code>LuaExecutor.h</code>. To make it work, we will implement helper functions to push onto and pop from the Lua stack, with our <code>LuaValue</code> C++ type instead of <code>std::string</code>. Let us work on pushing onto the stack first.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Pushing onto the stack</h2>
<p>In the previous <a id="_idIndexMarker204"/>call function, we pushed the <code>param</code> argument of the <code>std::string</code> type onto the Lua stack with the following:</p>
<pre class="source-code">
lua_pushstring(L, param.c_str());</pre>
<p>To support more Lua types, we can implement a <code>pushValue</code> method that takes <code>LuaValue</code> as an argument and calls different <code>lua_pushX</code> Lua library functions based on the <code>type</code> field of <code>LuaValue</code>.</p>
<p>In <code>LuaExecutor.h</code>, add the declaration as follows:</p>
<pre class="source-code">
class LuaExecutor
{
private:
    void pushValue(const LuaValue &amp;value);
};</pre>
<p>And in <code>LuaExecutor.cc</code>, implement the <code>pushValue</code> function:</p>
<pre class="source-code">
void LuaExecutor::pushValue(const LuaValue &amp;value)
{
    switch (getLuaType(value))
    {
    case LuaType::nil:
        lua_pushnil(L);
        break;
    case LuaType::boolean:
        lua_pushboolean(L,
            std::get&lt;LuaBoolean&gt;(value).value ? 1 : 0);
        break;
    case LuaType::number:
        lua_pushnumber(L,
            std::get&lt;LuaNumber&gt;(value).value);
        break;
    case LuaType::string:
        lua_pushstring(L,
            std::get&lt;LuaString&gt;(value).value.c_str());
        break;
    }
}</pre>
<p>Our implementation only uses one <code>switch</code> statement on <code>LuaType</code>. We implemented <code>getLuaType</code> in <code>LuaType.hpp</code> earlier in this chapter. In each <code>case</code>, we use <code>std::get</code> to get the typed <a id="_idIndexMarker205"/>value from the <code>LuaValue</code> type union. Next, we will look at the popping part.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Popping from the stack</h2>
<p>Popping from the<a id="_idIndexMarker206"/> Lua stack is a reverse operation of the pushing part. We will get the value from the Lua stack and use the Lua <code>lua_type</code> library function to check its Lua type, and then create a C++ <code>LuaValue</code> object with a matching <code>LuaType</code>.</p>
<p>To make things more modular, we will create two functions:</p>
<ul>
<li><code>getValue</code> to convert a Lua stack position to a <code>LuaValue</code></li>
<li><code>popValue</code> to pop and return the top of the stack</li>
</ul>
<p>Add the following declarations to <code>LuaExecutor.h</code>:</p>
<pre class="source-code">
class LuaExecutor
{
private:
    LuaValue getValue(int index);
    LuaValue popValue();
};</pre>
<p>In <code>LuaExecutor.cc</code>, let us first implement <code>getValue</code>:</p>
<pre class="source-code">
LuaValue LuaExecutor::getValue(int index)
{
    switch (lua_type(L, index))
    {
    case LUA_TNIL:
        return LuaNil::make();
    case LUA_TBOOLEAN:
        return LuaBoolean::make(
            lua_toboolean(L, index) == 1);
    case LUA_TNUMBER:
        return LuaNumber::make(
            (double)lua_tonumber(L, index));
    case LUA_TSTRING:
        return LuaString::make(lua_tostring(L, index));
    default:
        return LuaNil::make();
    }
}</pre>
<p>The code is quite <a id="_idIndexMarker207"/>straightforward. First, we check the Lua type of a requested stack location, and then we return a <code>LuaValue</code> accordingly. For the unsupported Lua types, for example, table and function, we just return <code>LuaNil</code> for now. With this, we can implement <code>popValue</code> as follows:</p>
<pre class="source-code">
LuaValue LuaExecutor::popValue()
{
    auto value = getValue(-1);
    lua_pop(L, 1);
    return value;
}</pre>
<p>We first call <code>getValue</code> with <code>-1</code> as the stack location to get the top of the stack. Then we pop the top of the stack.</p>
<p>With the stack operations<a id="_idIndexMarker208"/> implemented, we can now implement the new <code>call</code> function by putting the stack operations together.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor101"/>Putting it together</h2>
<p>Take a moment to <a id="_idIndexMarker209"/>read the old <code>call</code> function implementation again. It is shown as follows:</p>
<pre class="source-code">
std::string LuaExecutor::call(
    const std::string &amp;function,
    const std::string &amp;param)
{
    int type = lua_getglobal(L, function.c_str());
    assert(LUA_TFUNCTION == type);
    lua_pushstring(L, param.c_str());
    pcall(1, 1);
    return popString();
}</pre>
<p>To implement our new <code>call</code> function, not much needs to be changed. We only need to replace the two lines of code doing stack operations with the new helper functions we have just implemented. Write the new call function in <code>LuaExecutor.cc</code> as follows:</p>
<pre class="source-code">
LuaValue LuaExecutor::call(
    const std::string &amp;function, const LuaValue &amp;param)
{
    int type = lua_getglobal(L, function.c_str());
    assert(LUA_TFUNCTION == type);
    pushValue(param);
    pcall(1, 1);
    return popValue();
}</pre>
<p>We have replaced the lines working with <code>std::string</code> with new lines working with <code>LuaValue</code>.</p>
<p>Since we have a dedicated <code>getValue</code> function and <code>popValue</code> to covert a raw Lua value to a <code>LuaValue</code>, we can take the chance to make <code>popString</code> use them as well. Rewrite it as follows:</p>
<pre class="source-code">
std::string LuaExecutor::popString()
{
    auto result = std::get&lt;LuaString&gt;(popValue());
    return result.value;
}</pre>
<p>Here, we have gotten rid of the use of Lua library functions in <code>popString</code>. It is a good practice to limit the dependency on a third-party library to only a few functions. Another way to think about <a id="_idIndexMarker210"/>this is, in a class, internally, there can be low-level functions and high-level functions.</p>
<p>Next, let us test our improved Lua executor.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor102"/>Testing it out</h2>
<p>Because we have <a id="_idIndexMarker211"/>used C++17 features to implement <code>LuaValue</code>, we will write the test code in modern C++ as well. Write <code>main.cpp</code> as follows:</p>
<pre class="source-code">
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    lua-&gt;executeFile("script.lua");
    auto value1 = lua-&gt;call(
        "greetings", LuaString::make("C++"));
    std::cout &lt;&lt; getLuaValueString(value1) &lt;&lt; std::endl;
    auto value2 = lua-&gt;call(
        "greetings", LuaNumber::make(3.14));
    std::cout &lt;&lt; getLuaValueString(value2) &lt;&lt; std::endl;
    return 0;
}</pre>
<p>In this test code, we first use <code>std::unique_ptr</code> to hold our Lua executor and its listener, and then load the Lua script with the <code>greetings</code> Lua function. This Lua function is from the last chapter. The real actions are calling the Lua function twice: first with <code>LuaString</code>, then with <code>LuaNumber</code>.</p>
<p>Compile and run the test code. If you have done everything correctly, you should see the following output:</p>
<pre class="source-code">
Hello C++
Hello 3.14</pre>
<p>If you see compiler<a id="_idIndexMarker212"/> or linker errors, do not feel discouraged. It is common to see a few cryptic error messages when building new C++ code, especially when applying new knowledge. Trace the errors and try to correct them. You can also compare with the code in GitHub if you need to.</p>
<p class="callout-heading">Note</p>
<p class="callout">We have learned a lot so far. Our improved Lua executor can call Lua functions with a more flexible argument, although it is still only accepting one argument. By now, you should be comfortable and confident in using a common C++ type to represent different Lua types. Take a break and reflect, before moving on to further improve our Lua executor to call Lua functions with a variable number of arguments.</p>
<p>Now, let us <a id="_idIndexMarker213"/>continue to improve our Lua executor.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Supporting a variable number of arguments</h1>
<p>The Lua <code>function</code> supports a variable <a id="_idIndexMarker214"/>number of arguments. Let us implement one in <code>script.lua</code>:</p>
<pre class="source-code">
function greetings(...)
    local result = "Hello"
    for i, v in ipairs{...} do
        result = result .. " " .. v .. ","
    end
    return result
end</pre>
<p>This will return a greeting message and include all arguments in the message. The three dots (<code>...</code>) indicate that the function takes a variable number of arguments. We can iterate through the arguments with <code>ipairs</code>.</p>
<p>How can we support this in C++? For the stack operations, we only need to push more values. The main decision is how we should declare the Lua executor <code>call</code> function to accept a variable number of arguments.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>Implementing the C++ function</h2>
<p>Since C++11, we <a id="_idIndexMarker215"/>can<a id="_idIndexMarker216"/> use<a id="_idIndexMarker217"/> a <strong class="bold">variadic function template</strong> to <a id="_idIndexMarker218"/>pass a <strong class="bold">parameter pack</strong>. A parameter pack is a list of arguments of any size.</p>
<p>In <code>LuaExecutor.h</code>, change the <code>call</code> function declaration to the following:</p>
<pre class="source-code">
template &lt;typename... Ts&gt;
LuaValue call(const std::string &amp;function,
              const Ts &amp;...params);</pre>
<p><code>typename... Ts</code> defines a template parameter pack, and the function takes it as the <code>params</code> argument.</p>
<p>Now, let us implement it. Delete the <code>call</code> implementation in <code>LuaExecutor.cc</code>. Since we are now<a id="_idIndexMarker219"/> using templates, we<a id="_idIndexMarker220"/> need to put the implementation in the header file. In <code>LuaExecutor.h</code>, add the code as follows:</p>
<pre class="source-code">
template &lt;typename... Ts&gt;
LuaValue LuaExecutor::call(const std::string &amp;function,
                           const Ts &amp;...params)
{
    int type = lua_getglobal(L, function.c_str());
    assert(LUA_TFUNCTION == type);
    for (auto param :
        std::initializer_list&lt;LuaValue&gt;{params...})
    {
        pushValue(param);
    }
    pcall(sizeof...(params), 1);
    return popValue();
}</pre>
<p>This implementation can be broken down into four steps, separated by empty lines in code:</p>
<ul>
<li>It gets the Lua function to call. This has not changed.</li>
<li>It pushes the C++ function arguments. Here, we choose to make a <code>std::initializer_list</code> from the parameter pack and loop through it.</li>
<li>It calls the Lua function. We use <code>sizeof...(params)</code> to get the size of the parameter pack and tell Lua we are sending that many arguments.</li>
<li>It gets the return value from the Lua function and returns it.</li>
</ul>
<p>There is more than one way to accomplish <em class="italic">step 2</em>. You can use a lambda to unpack the parameter pack, and there are even different options to write this lambda. When, in due course, <strong class="bold">C++20</strong> gets <a id="_idIndexMarker221"/>adopted, you will have even more options. Those are, however, outside the scope of this book. Here, we choose to use a more conventional way to implement, so<a id="_idIndexMarker222"/> that it is <a id="_idIndexMarker223"/>easier to understand by more people.</p>
<p>Next, let us test whether our implementation works.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>Testing it out</h2>
<p>In <code>main.cpp</code>, replace <a id="_idIndexMarker224"/>the lines that call <code>lua-&gt;call</code> and print the result as follows:</p>
<pre class="source-code">
auto result = lua-&gt;call("greetings",
    LuaString::make("C++"), LuaString::make("Lua"));
std::cout &lt;&lt; getLuaValueString(result) &lt;&lt; std::endl;</pre>
<p>In the test code, we have passed two strings to the Lua <code>greetings</code> function. Since we support a variable number of arguments, you can pass as many arguments as you want, zero included. You should see an output similar to <code>Hello </code><code>C++, Lua,</code>.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Some more words on our mechanism</h2>
<p>By now, we have<a id="_idIndexMarker225"/> implemented in our Lua executor a general function to call any Lua functions, and with any number of arguments. Please take a moment to ponder on the following points, which will deepen your understanding:</p>
<ul>
<li><em class="italic">The Lua function being called does not need to be declared as accepting a variable number of arguments, while our C++ function is.</em> When calling a Lua function from C++, you always need to tell the Lua library how many arguments have been pushed onto the stack.</li>
<li><em class="italic">The Lua function does not need to return a value.</em> You can try to comment out the return statement in the <code>greetings</code> function. The C++ side will get a <code>LuaNil</code>, because the Lua library guarantees to push the requested number of return values onto the stack, using nil when the Lua function does not return enough values.</li>
<li><em class="italic">The Lua function can return more than one value.</em> We will only get the first value, and the Lua library will discard the rest, because when calling the Lua function, we requested only one return value.</li>
</ul>
<p>Our current implementation already supports most of the use cases for calling plain Lua functions, except for<a id="_idIndexMarker226"/> the last point mentioned above. Next, we will support multiple return values to complete the Lua function call mechanism.</p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/>Supporting multiple return values</h1>
<p>To work on retrieving<a id="_idIndexMarker227"/> multiple return values, let us first make a Lua function that actually does that. In <code>script.lua</code>, add the following function:</p>
<pre class="source-code">
function dump_params(...)
    local results = {}
    for i, v in ipairs{...} do
        results[i] = i .. ": " .. tostring(v) ..
            " [" .. type(v) .. "]"
    end
    return table.unpack(results)
end</pre>
<p>This will get every argument and print out its type. We first put them in a table, then we unpack the table so that each table entry is returned as a separate value.</p>
<p>Now, we have some decisions to make. We are happy with the current <code>call</code> function except for its return value. However, we cannot overload a function in C++ for a different return type. We need to create another function that returns a list of values.</p>
<p>How can we get multiple return values from Lua? Compared with <code>call</code>, there are two differences that we need to tackle:</p>
<ul>
<li>How can we tell the Lua library that we are expecting a variable number of return values, instead of a fixed number?</li>
<li>How can we get this variable number of return values in C++?</li>
</ul>
<p>To tackle the first problem, while calling the Lua library <code>lua_pcall</code> function, we can specify a magic number for the number of expected return values: <code>LUA_MULTRET</code>. This means that we will take whatever the Lua function returns, without the library discarding extra return values or padding with nil. This magic number is the only special case to specify the number of return values. It is internally defined as <code>-1</code> in <code>lua.h</code>.</p>
<p>To tackle the second problem, we only need to count how many elements there are in the Lua stack before calling the Lua function, and how many elements there are after calling the Lua function. This is because the Lua library pushes all return values onto the stack, so the new <a id="_idIndexMarker228"/>elements in the stack are the return values. We have implemented <code>popValue</code> to pop the top of the stack. We need another function to pop more than one value from the stack.</p>
<p>With the two problems solved, let us start to implement.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>Implementing the C++ function</h2>
<p>In <code>LuaExecutor.h</code>, add <a id="_idIndexMarker229"/>the following declarations:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    template &lt;typename... Ts&gt;
    std::vector&lt;LuaValue&gt; vcall(
        const std::string &amp;function,
        const Ts &amp;...params);
private:
    std::vector&lt;LuaValue&gt; popValues(int n);
};</pre>
<p>We added another function to call Lua functions. We call it <code>vcall</code> because it returns a <code>std::vector</code>. We also added a <code>popValues</code> helper function to pop the top <code>n</code> elements from the Lua stack.</p>
<p>First, let us<a id="_idIndexMarker230"/> implement <code>vcall</code> in <code>LuaExecutor.h</code>:</p>
<pre class="source-code">
template &lt;typename... Ts&gt;
std::vector&lt;LuaValue&gt; LuaExecutor::vcall(
    const std::string &amp;function, const Ts &amp;...params)
{
    int stackSz = lua_gettop(L);
    int type = lua_getglobal(L, function.c_str());
    assert(LUA_TFUNCTION == type);
    for (auto param :
        std::initializer_list&lt;LuaValue&gt;{params...})
    {
        pushValue(param);
    }
    if (pcall(sizeof...(params), LUA_MULTRET))
    {
        int nresults = lua_gettop(L) - stackSz;
        return popValues(nresults);
    }
    return std::vector&lt;LuaValue&gt;();
}</pre>
<p>We now have five steps, which are explained as follows:</p>
<ol>
<li>Record the stack size before doing anything else with <code>lua_gettop</code>.</li>
<li>Get the Lua function onto the stack with <code>lua_getglobal</code>.</li>
<li>Push all the arguments onto the stack with <code>pushValue</code>.</li>
<li>Call the Lua function with <code>pcall</code> and pass <code>LUA_MULTRET</code> to indicate that we will take all the return values from the Lua function. The Lua library will guarantee to pop all elements you pushed in <em class="italic">step 2</em> and <em class="italic">step 3</em>.</li>
<li>Pop all the return values from the stack and return them with <code>popValues</code>. We check the stack size again. The new stack size minus the original stack size stored in <code>stackSz</code> is the number of values returned.</li>
</ol>
<p>Next, we <a id="_idIndexMarker231"/>will implement the final piece, the helper function, to pop all return values from the Lua stack. In <code>LuaExecutor.cc</code>, add the following code:</p>
<pre class="source-code">
std::vector&lt;LuaValue&gt; LuaExecutor::popValues(int n)
{
    std::vector&lt;LuaValue&gt; results;
    for (int i = n; i &gt; 0; --i)
    {
        results.push_back(getValue(-i));
    }
    lua_pop(L, n);
    return results;
}</pre>
<p>Lua pushes the first return value onto the stack, then the second, and so on. So, the top of the stack needs to be stored at the end of the vector. Here, we read the return values in sequence, starting from the middle of the stack and moving toward the top of the stack. <code>-i</code> is the <code>ith</code> position <a id="_idIndexMarker232"/>counting from the top of the stack.</p>
<p>Next, let’s test this out.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>Testing it out</h2>
<p>In <code>main.cpp</code>, change the<a id="_idIndexMarker233"/> test code as follows:</p>
<pre class="source-code">
auto results = lua-&gt;vcall(
    "dump_params",
    LuaString::make("C++"),
    LuaString::make("Lua"),
    LuaNumber::make(3.14),
    LuaBoolean::make(true),
    LuaNil::make());
for (auto result : results)
{
    std::cout &lt;&lt; getLuaValueString(result) &lt;&lt; std::endl;
}</pre>
<p>We are passing a list of different types of <code>LuaValue</code> (<code>LuaString</code>, <code>LuaNumber</code>, <code>LuaBoolean</code> and <code>LuaNil</code>) to our new function. This will output the following:</p>
<pre class="source-code">
1: C++ [string]
2: Lua [string]
3: 3.14 [number]
4: true [boolean]</pre>
<p>Have you observed anything unusual? We have passed five arguments but only got four return values! <code>LuaNil</code> is not printed out. Why? This is because, in <code>dump_params</code>, we used <code>table.unpack</code> to return multiple values. Lua’s <code>table.unpack</code> will stop when it sees a nil value. If you move <code>LuaNil::make()</code> to the middle of the list, you will miss more return<a id="_idIndexMarker234"/> values. This is expected. This is a Lua thing. Similar to a C++ <code>char*</code> string, it will end when it first sees a <code>NULL</code> character.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Summary</h1>
<p>In this chapter, we first explored how to map Lua types to C++ types, with the goal of ease of use in C++ function calls. Then, we learned about a general way to call any Lua functions.</p>
<p>This chapter progressed step by step. You continued to improve the Lua executor. Each step produced a milestone. This, in turn, was based on the work from the last chapter. Going through the following exercises will also give you a chance to recap what you have learned with hands-on coding. We will continue the book with this methodology.</p>
<p>In the next chapter, we will learn how to integrate Lua tables.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Exercises</h1>
<ol>
<li>Implement <code>LuaType::function</code> and <code>LuaFunction</code> to cover the Lua function type. Do not worry about the value field in <code>LuaFunction</code>. You can use <code>nullptr</code>. To test it, you need to call a Lua function that returns another function, and in C++, print out that the return value is a function.</li>
<li>Implement <code>LuaType::table</code> and <code>LuaTable</code> to cover the Lua table type. Follow the same instructions as for the previous question.</li>
<li>In the last chapter, we implemented <code>getGlobalString</code> and <code>setGlobal</code> to work with Lua global values. Rewrite those two methods to support more types. You can use the new names <code>getGlobal</code> and <code>setGlobal</code>, and use <code>LuaValue</code>.</li>
<li>Implement a private <code>dumpStack</code> debug function. This function will dump the current Lua stack. You only need to support the currently supported types in <code>LuaValue</code>. Insert a call to this function in different places in <code>LuaExecutor</code>. This will deepen your understanding of the Lua stack.</li>
</ol>
</div>
</div></body></html>