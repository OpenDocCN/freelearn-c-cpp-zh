["```cpp\n%a1 = getelementptr i32, <2 x i32>* %a, i32 1 \n```", "```cpp\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  Type *u32Ty = Type::getInt32Ty(Context);\n  Type *vecTy = VectorType::get(u32Ty, 2);\n  Type *ptrTy = vecTy->getPointerTo(0);\n  FunctionType *funcType =\n      FunctionType::get(Builder.getInt32Ty(), ptrTy, false);\n  Function *fooFunc =\n      Function::Create(funcType, Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nValue *getGEP(IRBuilder<> &Builder, Value *Base, Value *Offset) {\n  return Builder.CreateGEP(Builder.getInt32Ty(), Base, Offset, \"a1\");\n}\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\nstatic std::vector<std::string> FunArgs;\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  Type *u32Ty = Type::getInt32Ty(Context);\n  Type *vecTy = VectorType::get(u32Ty, 2);\n  Type *ptrTy = vecTy->getPointerTo(0);\n  FunctionType *funcType =\n      FunctionType::get(Builder.getInt32Ty(), ptrTy, false);\n  Function *fooFunc =\n      Function::Create(funcType, Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nvoid setFuncArgs(Function *fooFunc, std::vector<std::string> FunArgs) {\n  unsigned Idx = 0;\n  Function::arg_iterator AI, AE;\n  for (AI = fooFunc->arg_begin(), AE = fooFunc->arg_end(); AI != AE;\n       ++AI, ++Idx)\n    AI->setName(FunArgs[Idx]);\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nValue *getGEP(IRBuilder<> &Builder, Value *Base, Value *Offset) {\n  return Builder.CreateGEP(Builder.getInt32Ty(), Base, Offset, \"a1\");\n}\n\nint main(int argc, char *argv[]) {\n  FunArgs.push_back(\"a\");\n  static IRBuilder<> Builder(Context);\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  setFuncArgs(fooFunc, FunArgs);\n  Value *Base = fooFunc->arg_begin();\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n  Value *gep = getGEP(Builder, Base, Builder.getInt32(1));\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -fno-rtti -o toy\n$ ./toy\n\n```", "```cpp\n; ModuleID = 'my compiler'\n\ndefine i32 @foo(<2 x i32>* %a) {\nentry:\n  %a1 = getelementptr i32, <2 x i32>* %a, i32 1\n  ret i32 0\n}\n```", "```cpp\n%val = load i32, i32* a1\n```", "```cpp\nValue *getLoad(IRBuilder<> &Builder, Value *Address) {\n  return Builder.CreateLoad(Address, \"load\");\n}\n```", "```cpp\n   builder.CreateRet(val);\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\nstatic std::vector<std::string> FunArgs;\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  Type *u32Ty = Type::getInt32Ty(Context);\n  Type *vecTy = VectorType::get(u32Ty, 2);\n  Type *ptrTy = vecTy->getPointerTo(0);\n  FunctionType *funcType =\n      FunctionType::get(Builder.getInt32Ty(), ptrTy, false);\n  Function *fooFunc =\n      Function::Create(funcType, Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nvoid setFuncArgs(Function *fooFunc, std::vector<std::string> FunArgs) {\n  unsigned Idx = 0;\n  Function::arg_iterator AI, AE;\n  for (AI = fooFunc->arg_begin(), AE = fooFunc->arg_end(); AI != AE;\n       ++AI, ++Idx)\n    AI->setName(FunArgs[Idx]);\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nValue *getGEP(IRBuilder<> &Builder, Value *Base, Value *Offset) {\n  return Builder.CreateGEP(Builder.getInt32Ty(), Base, Offset, \"a1\");\n}\n\nValue *getLoad(IRBuilder<> &Builder, Value *Address) {\n return Builder.CreateLoad(Address, \"load\");\n}\n\nint main(int argc, char *argv[]) {\n  FunArgs.push_back(\"a\");\n  static IRBuilder<> Builder(Context);\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  setFuncArgs(fooFunc, FunArgs);\n  Value *Base = fooFunc->arg_begin();\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n  Value *gep = getGEP(Builder, Base, Builder.getInt32(1));\n Value *load = getLoad(Builder, gep);\n  Builder.CreateRet(load);\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -fno-rtti -o toy\n$ ./toy\n\n```", "```cpp\n; ModuleID = 'my compiler'\n\ndefine i32 @foo(<2 x i32>* %a) {\nentry:\n  %a1 = getelementptr i32, <2 x i32>* %a, i32 1\n  %load = load i32, i32* %a1\n  ret i32 %load\n}\n```", "```cpp\nvoid getStore(IRBuilder<> &Builder, Value *Address, Value *V) {\n  Builder.CreateStore(V, Address);\n}\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\nstatic std::vector<std::string> FunArgs;\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  Type *u32Ty = Type::getInt32Ty(Context);\n  Type *vecTy = VectorType::get(u32Ty, 2);\n  Type *ptrTy = vecTy->getPointerTo(0);\n  FunctionType *funcType =\n      FunctionType::get(Builder.getInt32Ty(), ptrTy, false);\n  Function *fooFunc =\n      Function::Create(funcType, Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nvoid setFuncArgs(Function *fooFunc, std::vector<std::string> FunArgs) {\n  unsigned Idx = 0;\n  Function::arg_iterator AI, AE;\n  for (AI = fooFunc->arg_begin(), AE = fooFunc->arg_end(); AI != AE;\n       ++AI, ++Idx)\n    AI->setName(FunArgs[Idx]);\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nValue *createArith(IRBuilder<> &Builder, Value *L, Value *R) {\n  return Builder.CreateMul(L, R, \"multmp\");\n}\n\nValue *getGEP(IRBuilder<> &Builder, Value *Base, Value *Offset) {\n  return Builder.CreateGEP(Builder.getInt32Ty(), Base, Offset, \"a1\");\n}\n\nValue *getLoad(IRBuilder<> &Builder, Value *Address) {\n  return Builder.CreateLoad(Address, \"load\");\n}\n\nvoid getStore(IRBuilder<> &Builder, Value *Address, Value *V) {\n Builder.CreateStore(V, Address);\n}\n\nint main(int argc, char *argv[]) {\n  FunArgs.push_back(\"a\");\n  static IRBuilder<> Builder(Context);\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  setFuncArgs(fooFunc, FunArgs);\n  Value *Base = fooFunc->arg_begin();\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n  Value *gep = getGEP(Builder, Base, Builder.getInt32(1));\n  Value *load = getLoad(Builder, gep);\n  Value *constant = Builder.getInt32(16);\n  Value *val = createArith(Builder, load, constant);\n  getStore(Builder, gep, val);\n  Builder.CreateRet(val);\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -fno-rtti -o toy\n$ ./toy\n\n```", "```cpp\n; ModuleID = 'my compiler'\n\ndefine i32 @foo(<2 x i32>* %a) {\nentry:\n  %a1 = getelementptr i32, <2 x i32>* %a, i32 1\n  %load = load i32, i32* %a1\n  %multmp = mul i32 %load, 16\n  store i32 %multmp, i32* %a1\n  ret i32 %multmp\n}\n```", "```cpp\n%vec0 = insertelement <4 x double> Vec, %val0, %idx\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\nstatic std::vector<std::string> FunArgs;\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  Type *u32Ty = Type::getInt32Ty(Context);\n  Type *vecTy = VectorType::get(u32Ty, 4);\n  FunctionType *funcType =\n      FunctionType::get(Builder.getInt32Ty(), vecTy, false);\n  Function *fooFunc =\n      Function::Create(funcType, Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nvoid setFuncArgs(Function *fooFunc, std::vector<std::string> FunArgs) {\n  unsigned Idx = 0;\n  Function::arg_iterator AI, AE;\n  for (AI = fooFunc->arg_begin(), AE = fooFunc->arg_end(); AI != AE;\n       ++AI, ++Idx)\n    AI->setName(FunArgs[Idx]);\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nValue *getInsertElement(IRBuilder<> &Builder, Value *Vec, Value *Val,\n Value *Index) {\n return Builder.CreateInsertElement(Vec, Val, Index);\n}\n\nint main(int argc, char *argv[]) {\n  FunArgs.push_back(\"a\");\n  static IRBuilder<> Builder(Context);\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  setFuncArgs(fooFunc, FunArgs);\n\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n\n  Value *Vec = fooFunc->arg_begin();\n  for (unsigned int i = 0; i < 4; i++)\n    Value *V = getInsertElement(Builder, Vec,     Builder.getInt32((i + 1) * 10), Builder.getInt32(i));\n\n  Builder.CreateRet(Builder.getInt32(0));\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -fno-rtti -o toy\n$ ./toy \n\n```", "```cpp\n; ModuleID = 'my compiler'\n\ndefine i32 @foo(<4 x i32> %a) {\nentry:\n  %0 = insertelement <4 x i32> %a, i32 10, i32 0\n  %1 = insertelement <4 x i32> %a, i32 20, i32 1\n  %2 = insertelement <4 x i32> %a, i32 30, i32 2\n  %3 = insertelement <4 x i32> %a, i32 40, i32 3\n  ret i32 0\n}\n```", "```cpp\nresult = extractelement <4 x i32> %vec, i32 %idx\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\nstatic std::vector<std::string> FunArgs;\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  Type *u32Ty = Type::getInt32Ty(Context);\n  Type *vecTy = VectorType::get(u32Ty, 4);\n  FunctionType *funcType =\n      FunctionType::get(Builder.getInt32Ty(), vecTy, false);\n  Function *fooFunc =\n      Function::Create(funcType, Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nvoid setFuncArgs(Function *fooFunc, std::vector<std::string> FunArgs) {\n  unsigned Idx = 0;\n  Function::arg_iterator AI, AE;\n  for (AI = fooFunc->arg_begin(), AE = fooFunc->arg_end(); AI != AE;\n       ++AI, ++Idx)\n    AI->setName(FunArgs[Idx]);\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nValue *createArith(IRBuilder<> &Builder, Value *L, Value *R) {\n  return Builder.CreateAdd(L, R, \"add\");\n}\n\nValue *getExtractElement(IRBuilder<> &Builder, Value *Vec, Value *Index) {\n return Builder.CreateExtractElement(Vec, Index);\n}\n\nint main(int argc, char *argv[]) {\n  FunArgs.push_back(\"a\");\n  static IRBuilder<> Builder(Context);\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  setFuncArgs(fooFunc, FunArgs);\n\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n\n  Value *Vec = fooFunc->arg_begin();\n  SmallVector<Value *, 4> V;\n  for (unsigned int i = 0; i < 4; i++)\n    V[i] = getExtractElement(Builder, Vec, Builder.getInt32(i));\n\n  Value *add1 = createArith(Builder, V[0], V[1]);\n  Value *add2 = createArith(Builder, add1, V[2]);\n  Value *add = createArith(Builder, add2, V[3]);\n\n  Builder.CreateRet(add);\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -fno-rtti -o toy\n$ ./toy \n\n```", "```cpp\nModuleID = 'my compiler'\n\ndefine i32 @foo(<4 x i32> %a) {\nentry:\n  %0 = extractelement <4 x i32> %a, i32 0\n  %1 = extractelement <4 x i32> %a, i32 1\n  %2 = extractelement <4 x i32> %a, i32 2\n  %3 = extractelement <4 x i32> %a, i32 3\n  %add = add i32 %0, %1\n  %add1 = add i32 %add, %2\n  %add2 = add i32 %add1, %3\n  ret i32 %add2\n}\n```"]