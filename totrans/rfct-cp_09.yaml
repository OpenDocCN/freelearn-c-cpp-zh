- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Code Formatting and Naming Conventions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码格式化和命名约定
- en: In the vast and complex landscape of software development, some topics may seem
    less significant at first glance, yet they hold enormous value when considered
    in the broader context of creating robust and maintainable software. Code formatting
    is one such topic. While it might appear to be a mere aesthetic concern, it plays
    an essential role in enhancing code readability, simplifying maintenance, and
    fostering effective collaboration among team members. The significance of these
    aspects becomes even more pronounced in languages such as C++, where the structure
    and syntax can easily become complex.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的广阔而复杂的领域中，一些主题在第一眼看来可能不那么重要，然而，在创建健壮和可维护的软件的更广泛背景下考虑时，它们却具有巨大的价值。代码格式化就是这样一种主题。虽然它可能看起来只是美学上的关注点，但它对提高代码可读性、简化维护以及促进团队成员之间有效协作起着至关重要的作用。这些方面的意义在C++等语言中更为突出，在这些语言中，结构和语法可以很容易地变得复杂。
- en: In this chapter, we will delve deep into the nuances of code formatting, providing
    you with a comprehensive understanding of its importance. But understanding the
    “why” is only the first step; it’s equally crucial to know the “how.” Therefore,
    we will also explore the various tools available for automatically formatting
    your C++ code, taking a close look at their features and possibilities, as well
    as how they can be configured to meet your project’s specific needs. From industry-standard
    tools such as Clang-Format to editor-specific plugins, we’ll examine how to make
    these powerful utilities work for you.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨代码格式的细微差别，为你提供对其重要性的全面理解。但理解“为什么”只是第一步；同样重要的是要知道“如何”。因此，我们还将探讨可用于自动格式化你的C++代码的各种工具，仔细研究它们的功能和可能性，以及如何配置它们以满足你项目的特定需求。从行业标准工具如Clang-Format到特定编辑器的插件，我们将探讨如何让这些强大的实用工具为你所用。
- en: By the end of this chapter, you’ll have not only a thorough understanding of
    why code formatting is essential but also the practical knowledge to implement
    consistent and effective formatting across your C++ projects. So, let’s turn the
    page and embark on this enlightening journey.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你不仅将深入理解代码格式化为什么是必要的，还将获得在C++项目中实施一致和有效格式化的实际知识。因此，让我们翻到下一页，开始这段启发性的旅程。
- en: Why is code formatting important?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码格式化为什么重要？
- en: The importance of code formatting in software development, especially in languages
    such as C++, can’t be overstated. Let’s begin with readability, which is crucial
    because code is often read more frequently than it is written. Proper indentation
    and spacing give the code a visual structure, facilitating a quick understanding
    of its flow and logic. In a well-formatted code base, it’s easier to scan through
    the code to identify key elements such as loops, conditionals, and sections. This,
    in turn, reduces the need for excessive comments since the code often becomes
    self-explanatory.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 代码格式化在软件开发中的重要性，尤其是在C++等语言中，不容小觑。让我们从可读性开始，这是至关重要的，因为代码通常被阅读的次数比被编写的次数多。适当的缩进和间距为代码提供了视觉结构，有助于快速理解其流程和逻辑。在一个格式良好的代码库中，更容易扫描代码以识别关键元素，如循环、条件和部分。这反过来又减少了过度注释的需求，因为代码往往变得自我解释。
- en: When it comes to maintainability, consistent code formatting is a boon. Well-structured
    code is easier to debug. For instance, a consistent indentation can quickly highlight
    unclosed brackets or scope issues, making it easier to spot errors. Well-formatted
    code also enables developers to isolate sections of code more effectively, which
    is essential for both debugging and refactoring. Additionally, maintainability
    is not just about the here and now; it’s about future-proofing the code. As the
    code base evolves, a consistent formatting style ensures that new additions are
    easier to integrate.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到可维护性时，一致的代码格式化是一大福音。结构良好的代码更容易调试。例如，一致的缩进可以迅速突出未关闭的大括号或作用域问题，使错误更容易被发现。格式良好的代码还使开发者能够更有效地隔离代码部分，这对于调试和重构都是至关重要的。此外，可维护性不仅仅是关于现在和未来；它关乎代码的未来保障。随着代码库的发展，一致的格式化风格确保了新添加的内容更容易集成。
- en: Collaboration is another area where consistent code formatting plays a significant
    role. In a team setting, having a unified code style reduces the cognitive load
    for each team member. It allows developers to focus more on the logic and implementation
    of the code rather than getting sidetracked by stylistic inconsistencies. This
    is particularly beneficial during code reviews, where the uniform style enables
    reviewers to focus on the core logic and potential issues instead of being distracted
    by varying formatting styles. For new team members, a consistently formatted code
    base can be much easier to understand, helping them get up to speed more quickly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 协作是另一个领域，其中一致的代码格式化发挥着重要作用。在团队环境中，统一的代码风格可以减少每个团队成员的认知负荷。它允许开发者更多地关注代码的逻辑和实现，而不是被风格上的不一致所分散。这在代码审查期间尤其有益，统一的风格使得审查者可以专注于核心逻辑和潜在问题，而不是被不同的格式化风格所干扰。对于新团队成员来说，一致的代码库更容易理解，有助于他们更快地熟悉情况。
- en: Moreover, code formatting plays a role in quality assurance and can be automated
    to some extent. Many teams utilize automated formatting tools to ensure that the
    code base maintains a consistent style, which not only reduces the likelihood
    of human error but can also be a factor in code quality metrics. Automated checks
    for code formatting can be integrated into the CI/CD pipeline, making it a part
    of the overall best practices for the project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，代码格式化在质量保证中发挥着作用，并且在某种程度上可以自动化。许多团队利用自动化格式化工具来确保代码库保持一致的风格，这不仅降低了人为错误的可能性，还可以成为代码质量指标的一个因素。代码格式的自动化检查可以集成到CI/CD管道中，使其成为项目整体最佳实践的一部分。
- en: Finally, let’s not forget the impact of code formatting on version control.
    A consistent coding style ensures that version histories and diffs accurately
    reflect changes in code logic, not just style adjustments. This makes it easier
    to track changes, identify issues, and understand the evolution of the code base
    over time using tools such as `git blame` and `git history`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不要忘记代码格式化对版本控制的影响。一致的编码风格确保版本历史和diff准确反映了代码逻辑的变化，而不仅仅是风格调整。这使得使用如`git blame`和`git
    history`等工具跟踪更改、识别问题以及理解代码库随时间演变变得更加容易。
- en: In conclusion, proper code formatting serves both a functional and aesthetic
    purpose. It enhances readability, simplifies maintenance, and fosters collaboration,
    all of which contribute to the effective and efficient development of robust and
    maintainable software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，适当的代码格式化既具有功能性又具有美学性。它提高了可读性，简化了维护，并促进了协作，所有这些都对开发健壮和可维护的软件的有效和高效发展做出了贡献。
- en: Overview of existing tools that facilitate compliance with coding conventions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现有工具概述，以促进遵守编码规范
- en: The world of C++ development has seen an ever-increasing focus on writing clean,
    maintainable code. One of the cornerstones of this approach is adherence to well-defined
    coding conventions. Thankfully, several tools can help automate this process,
    making it easier for developers to focus on solving actual problems rather than
    fretting over code aesthetics. In this section, we’ll take a broad look at some
    of the most popular and widely used tools for enforcing coding conventions in
    C++ projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++开发的世界一直在不断加强对编写干净、可维护代码的关注。这种方法的一个基石是遵守定义良好的编码规范。幸运的是，有几个工具可以帮助自动化这个过程，使开发者能够更多地关注解决实际问题，而不是担心代码的美观。在本节中，我们将广泛探讨一些在C++项目中强制执行编码规范的最受欢迎和最广泛使用的工具。
- en: cpplint
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cpplint
- en: cpplint is a Python-based tool that aims to check your C++ code against Google’s
    style guide, providing a less flexible but highly focused toolset for maintaining
    coding conventions. If you or your team admire Google’s C++ coding standards,
    cpplint offers a straightforward path to ensure compliance within your project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: cpplint是一个基于Python的工具，旨在检查您的C++代码是否符合谷歌的风格指南，提供了一个不太灵活但高度集中的工具集，用于维护编码规范。如果您或您的团队欣赏谷歌的C++编码标准，cpplint提供了一个简单的方法来确保项目中的合规性。
- en: cpplint comes with a set of predefined checks based on Google’s C++ style guide.
    These checks cover a variety of aspects, from file headers to indentation, and
    from variable naming to the inclusion of unnecessary headers. The tool is executed
    from the command line, and its output offers clear guidance on which parts of
    the code violate the guidelines, often providing hints on how to correct these
    issues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: cpplint附带了一组基于Google C++风格指南的预定义检查。这些检查涵盖了从文件头到缩进，从变量命名到包含不必要的头文件等多个方面。该工具从命令行执行，其输出提供了关于哪些代码部分违反了指南的明确指导，通常还提供了如何纠正这些问题的提示。
- en: Being Python-based, cpplint enjoys the advantage of being cross-platform. You
    can easily integrate it into development environments across Windows, macOS, and
    Linux, making it a convenient choice for diverse teams.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于Python，cpplint享有跨平台的优点。你可以轻松地将它集成到Windows、macOS和Linux等开发环境中，使其成为多团队便捷的选择。
- en: The command-line nature of cpplint allows it to be easily integrated into a
    variety of development pipelines. It can be included in pre-commit hooks, part
    of a CI system, or even be set to run at specific intervals during development.
    Several IDEs and text editors also provide plugins to run cpplint automatically
    on file save or during a build.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: cpplint的命令行特性使其能够轻松集成到各种开发流程中。它可以包含在预提交钩子中，作为CI系统的一部分，甚至可以在开发过程中设定特定的时间间隔运行。几个IDE和文本编辑器也提供了插件，可以在文件保存或构建过程中自动运行cpplint。
- en: While it doesn’t offer the same level of customization as some other tools,
    cpplint has the advantage of being backed by Google, and it follows a widely respected
    style guide. The tool has extensive documentation that not only explains how to
    use cpplint but also dives into the reasoning behind specific coding conventions,
    offering valuable insights into the principles of writing clean, maintainable
    C++ code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不像一些其他工具那样提供相同级别的定制化，但cpplint的优势在于它由Google支持，并遵循一个广受尊敬的风格指南。该工具具有广泛的文档，不仅解释了如何使用cpplint，还深入探讨了特定编码约定的推理，为编写清晰、可维护的C++代码提供了宝贵的见解。
- en: The primary limitation of cpplint is its lack of flexibility. The tool is designed
    to enforce Google’s coding standards and offers limited scope for customization.
    This can be a drawback if your project has unique formatting requirements or if
    you’re working within a team that has already adopted a different set of conventions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: cpplint的主要局限性在于其缺乏灵活性。该工具旨在强制执行Google的编码标准，并提供有限的定制范围。如果你的项目有独特的格式化要求，或者你在一个已经采用不同约定集的团队中工作，这可能会成为一个缺点。
- en: In conclusion, cpplint serves as a focused tool for C++ developers who wish
    to adopt Google’s C++ style guide within their projects. While it may not offer
    the wide range of customization features found in some other tools, its simplicity,
    ease of integration, and adherence to well-respected coding standards make it
    a valuable asset for many development teams.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，cpplint是C++开发者希望在其项目中采用Google C++风格指南的专注工具。虽然它可能不像一些其他工具那样提供广泛的定制化功能，但其简单性、易于集成和遵循广受尊敬的编码标准使其成为许多开发团队的宝贵资产。
- en: More information about cpplint can be found on the official page ([https://github.com/google/styleguide/tree/gh-pages/cpplint](https://github.com/google/styleguide/tree/gh-pages/cpplint))
    and in the forked GitHub repository maintained by enthusiasts ([https://github.com/cpplint/cpplint](https://github.com/cpplint/cpplint)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于cpplint的信息可以在官方页面（[https://github.com/google/styleguide/tree/gh-pages/cpplint](https://github.com/google/styleguide/tree/gh-pages/cpplint)）和由爱好者维护的GitHub仓库（[https://github.com/cpplint/cpplint](https://github.com/cpplint/cpplint)）中找到。
- en: Artistic Style
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Artistic Style
- en: In the realm of code formatting tools, **Artistic Style** (**Astyle**) holds
    a unique position. It is designed to be a fast, small, and, above all, simple
    tool that supports multiple programming languages, including C++. One of the standout
    features of Astyle is its ease of use, making it a particularly good choice for
    smaller projects or for teams who are venturing into the world of automated code
    formatting for the first time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码格式化工具领域，**Artistic Style**（**Astyle**）占据着独特的位置。它被设计成一个快速、小巧且最重要的是简单的工具，支持包括C++在内的多种编程语言。Astyle的突出特点之一是易于使用，这使得它特别适合小型项目或初次尝试自动化代码格式化的团队。
- en: Astyle provides a set of predefined styles such as ANSI, GNU, and Google, among
    others, which can serve as good starting points for your project’s coding conventions.
    Additionally, it offers options to adjust indentation, align variables and pointers,
    and even sort modifiers, among other things. These can be controlled through command-line
    options or a configuration file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Astyle提供了一系列预定义的样式，如ANSI、GNU和Google等，这些可以作为你项目编码约定的良好起点。此外，它还提供了调整缩进、对齐变量和指针，甚至排序修饰符等选项。这些可以通过命令行选项或配置文件来控制。
- en: A major benefit of Astyle is its cross-platform nature. It can be used on Windows,
    macOS, and Linux, making it a versatile choice for teams with diverse development
    environments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Astyle的一个主要优点是其跨平台性。它可以在Windows、macOS和Linux上使用，使其成为具有多样化开发环境的团队的多功能选择。
- en: One of the strong suits of Astyle is its ease of integration into various development
    pipelines. It can be easily hooked into pre-commit scripts, integrated into the
    most popular text editors, and even added to your CI process.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Astyle的一个显著优点是它易于集成到各种开发流程中。它可以轻松地集成到预提交脚本中，集成到最流行的文本编辑器中，甚至添加到你的持续集成过程中。
- en: Although it may not have as extensive a community as some other tools, Astyle
    has been around for quite some time and has built up a solid user base. Its documentation
    is straightforward to understand, providing clear guidance even for those who
    are new to the concept of automated code formatting.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Astyle可能没有一些其他工具那样广泛的社区，但它已经存在了相当长的时间，并建立了一个稳固的用户基础。它的文档易于理解，即使对于刚开始接触自动化代码格式化概念的人来说，也能提供清晰的指导。
- en: While Astyle is feature-rich, it’s worth noting that it might not be the best
    fit for extremely large or complex projects that require highly specialized formatting
    rules. It offers fewer customization options compared to some other tools, which
    could be a limitation if your project has very specific formatting requirements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Astyle功能丰富，但值得注意的是，它可能不是最适合需要高度专业化格式化规则的超大型或复杂项目的最佳选择。与其他一些工具相比，它提供的定制选项较少，如果你的项目有非常具体的格式化要求，这可能会成为一个限制。
- en: 'In summary, Astyle serves as a robust and easy-to-use tool for automating code
    formatting in C++ projects. Its simplicity, ease of integration, and cross-platform
    support make it an attractive option for many developers. Whether you are new
    to automated code formatting or looking for a simpler alternative, Astyle offers
    a straightforward way to ensure that your code base adheres to consistent coding
    conventions. For more information, please refer to the project’s official page:
    [https://astyle.sourceforge.net/astyle.html](https://astyle.sourceforge.net/astyle.html).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Astyle是一个强大且易于使用的工具，用于自动化C++项目的代码格式化。它的简单性、易于集成和跨平台支持使其成为许多开发者的吸引选项。无论你是自动代码格式化的新手还是寻找更简单的替代方案，Astyle都提供了一种简单直接的方式来确保你的代码库遵循一致的编码约定。有关更多信息，请参阅项目的官方页面：[https://astyle.sourceforge.net/astyle.html](https://astyle.sourceforge.net/astyle.html)。
- en: Uncrustify
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Uncrustify
- en: When it comes to the realm of code formatting in C++, Uncrustify stands out
    for its incredible range of customization options. This powerful tool offers a
    level of granularity that few other formatters can match, making it an ideal choice
    for large and complex projects with highly specific formatting needs. If you’re
    someone who relishes the ability to fine-tune every aspect of your code’s appearance,
    then Uncrustify is worth a closer look.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到C++代码格式化的领域时，Uncrustify因其令人难以置信的定制选项而脱颖而出。这个强大的工具提供了一种粒度，这是其他格式化工具难以匹敌的，使其成为具有高度特定格式化需求的大型和复杂项目的理想选择。如果你喜欢精细调整代码外观的每一方面，那么Uncrustify值得你仔细看看。
- en: Uncrustify supports an extensive set of formatting options, allowing developers
    to customize everything from indentation levels and brace styles to the alignment
    of comments and code constructs. All these options can be set in a configuration
    file that can then be shared across a development team to ensure consistent formatting.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Uncrustify支持广泛的格式化选项，允许开发者从缩进级别和括号样式到注释和代码结构的对齐进行自定义。所有这些选项都可以在配置文件中设置，然后可以在开发团队之间共享，以确保格式的一致性。
- en: Uncrustify is cross-platform compatible and can be easily used in development
    environments on Windows, macOS, and Linux. It is not tied to any specific development
    environment and offers a variety of integration paths. It can be set up as a pre-commit
    hook in your version control system, integrated into popular IDEs through plugins,
    or even included as a step in your CI pipeline. Because of its command-line nature,
    integrating Uncrustify into various tools and workflows is typically straightforward.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Uncrustify是跨平台兼容的，可以轻松用于Windows、macOS和Linux上的开发环境。它不受任何特定开发环境的限制，并提供多种集成路径。它可以设置为版本控制系统中的预提交钩子，通过插件集成到流行的IDE中，甚至可以作为CI管道中的一步。由于其命令行特性，将Uncrustify集成到各种工具和工作流程中通常很简单。
- en: Uncrustify has an active community and its documentation, although sometimes
    considered dense, is comprehensive. This provides developers with a rich source
    of information for understanding the tool’s extensive capabilities. While the
    configuration can be challenging due to its sheer volume of options, numerous
    online resources and forums offer guidance, tips, and best practices for making
    the most of Uncrustify’s features.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Uncrustify有一个活跃的社区，其文档尽管有时被认为内容密集，但非常全面。这为开发者提供了丰富的信息来源，以了解工具的广泛功能。虽然由于其选项数量庞大，配置可能具有挑战性，但众多在线资源和论坛提供了指导、技巧和最佳实践，以充分利用Uncrustify的功能。
- en: The most notable limitation of Uncrustify is its complexity. The tool’s strength
    – its myriad customization options – can also be a weakness, especially for smaller
    projects or teams that don’t require such a high level of configurability. Additionally,
    the steep learning curve could be a barrier for teams looking for a quick solution
    to implement consistent code formatting.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Uncrustify最显著的局限性是其复杂性。这个工具的优势——其众多的定制选项——也可能成为一种劣势，尤其是对于不需要如此高配置级别的较小项目或团队来说。此外，陡峭的学习曲线可能成为寻求快速解决方案以实现一致代码格式的团队的障碍。
- en: 'In summary, Uncrustify offers an unmatched level of customization for those
    looking to fine-tune their C++ code formatting to the nth degree. Its wide array
    of features, coupled with extensive documentation and an active community, makes
    it a robust choice for teams seeking to enforce very specific coding standards.
    If you’re up for the challenge of mastering its many options, Uncrustify can serve
    as an invaluable tool for maintaining a clean and consistent code base. For more
    detailed information, please refer to the official GitHub page: [https://github.com/uncrustify/uncrustify](https://github.com/uncrustify/uncrustify).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Uncrustify为那些希望将C++代码格式调整到极致的人提供了无与伦比的定制水平。其广泛的功能，加上详尽的文档和活跃的社区，使其成为寻求强制执行非常具体编码标准的团队的稳健选择。如果你愿意接受掌握其众多选项的挑战，Uncrustify可以作为一个无价的工具，用于维护干净和一致的代码库。如需更详细的信息，请参阅官方GitHub页面：[https://github.com/uncrustify/uncrustify](https://github.com/uncrustify/uncrustify)。
- en: Editor plugins
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑器插件
- en: In an age where development teams are more diverse than ever, relying on a single
    IDE for code formatting can be problematic. Not only does it force developers
    to adapt to a specific work environment – potentially hindering their performance
    – but it also creates challenges in maintaining a consistent code style across
    different IDEs. Furthermore, such reliance poses complications for integrating
    code formatting into CI/CD pipelines. This is where editor plugins come into play
    as a more flexible and universal solution.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个开发团队比以往任何时候都更加多样化的时代，依赖单一IDE进行代码格式化可能会出现问题。这不仅迫使开发者适应特定的工作环境——可能阻碍他们的表现——而且还在维护不同IDE之间的一致代码风格上造成挑战。此外，这种依赖性在将代码格式化集成到CI/CD管道中也会引起复杂性。这就是编辑器插件发挥作用的地方，作为一个更灵活和通用的解决方案。
- en: One of the key advantages of editor plugins is their wide availability across
    multiple text editors and IDEs. Whether your team prefers Visual Studio Code,
    Sublime Text, Vim, or Emacs, chances are there’s a plugin available that integrates
    with your chosen code formatting tool. This means every team member can work in
    the development environment they are most comfortable with, without compromising
    on code consistency.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器插件的一个关键优势是它们在多个文本编辑器和IDE中的广泛可用性。无论你的团队更喜欢Visual Studio Code、Sublime Text、Vim还是Emacs，很可能有一个插件可以与你的所选代码格式化工具集成。这意味着每个团队成员都可以在他们最舒适的开发环境中工作，而不会牺牲代码的一致性。
- en: ditor plugins often act as wrappers around standalone formatting tools such
    as Clang-Format, Astyle, and Uncrustify. This facilitates an easy transition,
    especially if your team is already using one of these tools. The configuration
    files for these tools can be shared, ensuring that the same formatting rules are
    applied irrespective of the editor being used.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器插件通常作为Clang-Format、Astyle和Uncrustify等独立格式化工具的包装器。这促进了轻松的过渡，特别是如果您的团队已经在使用这些工具之一。这些工具的配置文件可以共享，确保无论使用哪种编辑器，都应用相同的格式化规则。
- en: Since many editor plugins leverage standalone command-line tools for code formatting,
    they naturally fit well into CI/CD pipelines. This eliminates the need to rely
    on IDE-specific tools, which may not be easily adaptable to CI/CD systems. With
    a standalone tool, the same formatting checks can be performed both locally by
    developers and automatically within the CI/CD pipeline, ensuring consistency across
    the board.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多编辑器插件利用独立的命令行工具进行代码格式化，它们自然适合CI/CD管道。这消除了依赖于IDE特定工具的需要，这些工具可能不易适应CI/CD系统。使用独立工具，相同的格式化检查可以在本地由开发者执行，也可以在CI/CD管道中自动执行，确保全面的一致性。
- en: While editor plugins offer a versatile approach to code formatting, they do
    come with their own set of limitations. First, not all editors may support the
    full range of available formatting tools, although most popular editors have a
    wide range of plugins. Second, while installing and configuring plugins is generally
    straightforward, it does require an initial setup effort from each developer on
    the team.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编辑器插件提供了代码格式化的灵活方法，但它们也带来了一组自己的限制。首先，并非所有编辑器都支持所有可用的格式化工具的全范围，尽管大多数流行的编辑器都有广泛的插件。其次，尽管安装和配置插件通常很简单，但它确实需要团队中的每个开发者进行初始设置。
- en: Editor plugins provide an accessible and universal solution for implementing
    code formatting across diverse development environments. Their flexibility allows
    team members to choose their preferred editors without sacrificing code consistency,
    and their compatibility with standalone formatting tools makes them an excellent
    fit for inclusion in CI/CD pipelines. For teams that prioritize both developer
    autonomy and code consistency, editor plugins offer a balanced and effective approach.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器插件提供了一种可访问且通用的解决方案，用于在多样化的开发环境中实现代码格式化。它们的灵活性允许团队成员选择他们偏好的编辑器，而不会牺牲代码的一致性，并且它们与独立格式化工具的兼容性使它们非常适合包含在CI/CD管道中。对于既重视开发者自主权又重视代码一致性的团队来说，编辑器插件提供了一种平衡且有效的方法。
- en: Clang-Format
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clang-Format
- en: When it comes to discussing code formatting tools that have gained significant
    traction in the C++ community, Clang-Format undoubtedly takes a front seat. Often
    considered the Swiss Army knife of code formatting, this tool combines robustness
    with a wealth of customization options. As this chapter’s favorite, we will delve
    deeper into its intricacies, exploring its extensive features and configurations
    in subsequent sections.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论在C++社区中获得显著关注的代码格式化工具时，Clang-Format无疑占据了首位。通常被认为是代码格式化的瑞士军刀，这个工具结合了稳健性和丰富的自定义选项。作为本章的宠儿，我们将深入探讨其复杂性，在后续章节中探索其广泛的功能和配置。
- en: At its core, Clang-Format is designed to automatically reformat code so that
    it complies with a set of specified rules. These rules can range from handling
    whitespace and indentation to more complex aspects such as code block alignment
    and comment reformatting. Configuration is usually done via a `.clang-format`
    file, where developers can define their style preferences in a structured manner.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Clang-Format旨在自动重新格式化代码，使其符合一组指定的规则。这些规则可以从处理空白和缩进到更复杂的方面，如代码块对齐和注释重新格式化。配置通常通过`.clang-format`文件完成，开发者可以以结构化的方式定义他们的样式偏好。
- en: Clang-Format offers excellent cross-platform support, functioning seamlessly
    on Windows, macOS, and Linux. This ensures that irrespective of the development
    environment, your team can benefit from consistent code formatting.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format提供了出色的跨平台支持，在Windows、macOS和Linux上无缝运行。这确保了无论开发环境如何，您的团队都可以从一致的代码格式化中受益。
- en: Clang-Format shines due to its ease of integration. It can be invoked directly
    from the command line, included in scripts, or used via plugins in virtually any
    major text editor or IDE. This flexibility ensures that each developer can integrate
    it into their workflow, regardless of their choice of editor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 因其易于集成而备受赞誉。它可以直接从命令行调用，包含在脚本中，或通过几乎任何主要文本编辑器或 IDE 的插件使用。这种灵活性确保每个开发者都可以根据自己的选择将其集成到他们的工作流程中。
- en: The command-line nature of Clang-Format also allows it to easily fit into CI/CD
    pipelines. With configuration files that can be stored and version-controlled
    alongside your code base, it ensures that the CI/CD system applies the same formatting
    rules as any developer would locally.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 的命令行特性也使其能够轻松地融入 CI/CD 流水线。通过将配置文件存储在代码库旁边并进行版本控制，它确保 CI/CD 系统应用与任何本地开发者相同的格式化规则。
- en: With strong backing from a broad community of developers and extensive documentation,
    Clang-Format has a wealth of resources available for new and experienced users
    alike. This community support becomes particularly beneficial when you’re looking
    to resolve issues or customize complex formatting rules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在广泛的开发者社区和丰富的文档支持下，Clang-Format 为新用户和经验丰富的用户都提供了丰富的资源。当您寻求解决问题时，这种社区支持尤其有益，或者当您想要自定义复杂的格式化规则时。
- en: Given its capabilities and my personal preference for this tool, the latter
    sections of this chapter will dive deeper into the world of Clang-Format. From
    setting up your first `.clang-format` file to exploring some of its more advanced
    features, we’ll cover how to make the most of what this powerful tool has to offer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到其功能和我对这个工具的个人偏好，本章的后半部分将更深入地探讨 Clang-Format 的世界。从设置您的第一个 `.clang-format`
    文件到探索其一些更高级的功能，我们将介绍如何充分利用这个强大工具所能提供的一切。
- en: Clang-Format configuration – a deep dive into customizing your formatting rules
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clang-Format 配置 – 深入了解自定义格式化规则
- en: When it comes to configuring Clang-Format, the possibilities are almost endless,
    allowing you to tweak even the most minute details of your code’s appearance.
    However, for those who are new to this tool or those who wish to quickly adopt
    a widely accepted set of rules, Clang-Format allows you to derive configurations
    from existing presets. These presets serve as solid foundations upon which you
    can build a tailored formatting style that suits your project’s specific needs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到配置 Clang-Format 时，可能性几乎是无限的，允许您调整代码外观的每一个最细微的细节。然而，对于新接触这个工具或希望快速采用广泛接受的规则集的人来说，Clang-Format
    允许您从现有预设中派生配置。这些预设作为坚实的基石，您可以在其基础上构建适合项目特定需求的定制格式化风格。
- en: Leveraging existing presets
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用现有预设
- en: 'Clang-Format offers several built-in presets that adhere to popular coding
    standards. These include the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 提供了几个内置预设，这些预设遵循流行的编码标准。以下是一些：
- en: '`LLVM`: Adheres to the LLVM coding standards'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLVM`: 遵循 LLVM 编码标准'
- en: '`Google`: Follows Google’s C++ style guide'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Google`: 遵循 Google 的 C++ 风格指南'
- en: '`Chromium`: Based on Chromium’s style guide, a variant of Google’s style guide'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chromium`: 基于 Chromium 的风格指南，是 Google 风格指南的一个变体'
- en: '`Mozilla`: Follows the Mozilla coding standards'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mozilla`: 遵循 Mozilla 编码标准'
- en: '`WebKit`: Adheres to the WebKit coding standards'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebKit`: 遵循 WebKit 编码标准'
- en: 'To use one of these presets, simply set the `BasedOnStyle` option in your `.clang-format`
    configuration file, like so:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些预设之一，只需在您的 `.clang-format` 配置文件中设置 `BasedOnStyle` 选项，如下所示：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This tells Clang-Format to apply the Google C++ style guide as a base and then
    apply any additional customizations you specify.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Clang-Format 以 Google C++ 风格指南为基础，然后应用您指定的任何附加自定义设置。
- en: Extending and overriding presets
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和覆盖预设
- en: 'After choosing a preset that aligns closest with your team’s coding philosophy,
    you can start customizing specific rules. The `.clang-format` file allows you
    to override or extend the preset’s rules by listing them under the `BasedOnStyle`
    option. For example, an extended `.clang-format` example can demonstrate how to
    fine-tune various aspects of code formatting. The following is a sample configuration
    file that starts with Google’s style as a base and then customizes several specific
    aspects, such as indentation width, brace wrapping, and the alignment of consecutive
    assignments:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择与您团队编码哲学最接近的预设之后，您可以开始自定义特定规则。`.clang-format` 文件允许您通过在 `BasedOnStyle` 选项下列出它们来覆盖或扩展预设的规则。例如，一个扩展的
    `.clang-format` 示例可以展示如何微调代码格式的各个方面。以下是一个示例配置文件，它以 Google 风格为基础，然后自定义了几个特定方面，例如缩进宽度、花括号包装和连续赋值的对齐：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s take a closer look at the options we chose here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看我们在这里选择的一些选项：
- en: '`IndentWidth` and `TabWidth`: These set the number of spaces for indentation
    and tabs, respectively. Here, `UseTab: Never` specifies not to use tabs for indentation.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IndentWidth` 和 `TabWidth`：这些分别设置缩进和制表符的空格数。在这里，`UseTab: Never` 指定不使用制表符进行缩进。'
- en: '`BreakBeforeBraces` and `BraceWrapping`: These options customize when to break
    before opening braces in various situations such as classes, functions, and namespaces.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BreakBeforeBraces` 和 `BraceWrapping`：这些选项自定义在类、函数和命名空间等不同情况下在打开花括号之前何时断行。'
- en: '`AlignAfterOpenBracket`, `AlignConsecutiveAssignments`, and so on: These control
    how various code elements, such as open brackets and consecutive assignments,
    are aligned.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AlignAfterOpenBracket`、`AlignConsecutiveAssignments` 等等：这些控制各种代码元素（如开括号和连续赋值）的对齐方式。'
- en: '`SpaceBeforeParens`, `SpaceInEmptyParentheses`, and so on: These manage spaces
    in different scenarios, such as before parentheses in control statements or within
    empty parentheses.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpaceBeforeParens`、`SpaceInEmptyParentheses` 等等：这些管理在不同场景中的空格，例如在控制语句中的括号之前或空括号内。'
- en: '`MaxEmptyLinesToKeep`: This option limits the maximum number of consecutive
    empty lines to keep.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MaxEmptyLinesToKeep`：此选项限制要保留的最大连续空行数。'
- en: '`ColumnLimit`: This option sets a column limit per line to ensure the code
    doesn’t exceed the specified limit, enhancing readability.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ColumnLimit`：此选项设置每行的列限制，以确保代码不超过指定的限制，从而提高可读性。'
- en: The `.clang-format` file should be placed in the root directory of your project
    and committed to your version control system so that every team member and your
    CI/CD pipeline can use the same configuration for consistent code formatting.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`.clang-format` 文件应放置在您项目的根目录中，并提交到您的版本控制系统，以便每个团队成员和您的 CI/CD 管道可以使用相同的配置进行一致的代码格式化。'
- en: Ignoring specific lines with Clang-Format
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Clang-Format 忽略特定行
- en: While Clang-Format is an excellent tool for maintaining a consistent coding
    style across a project, there might be occasions when you’d prefer to keep certain
    lines or blocks of code untouched. Thankfully, Clang-Format provides the functionality
    to exclude specific lines or code blocks from formatting. This can be particularly
    useful for lines where the original formatting is essential for readability or
    lines that contain generated code that should not be altered.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Clang-Format 是一个在项目内保持一致编码风格的优秀工具，但有时您可能希望保留某些行或代码块不变。幸运的是，Clang-Format 提供了排除特定行或代码块以进行格式化的功能。这对于原始格式对于可读性至关重要或包含不应更改的生成代码的行尤其有用。
- en: 'To ignore a particular line or block of code, you can use special comment markers.
    Place `// clang-format off` before the line or block of code that you want to
    ignore, and then use `// clang-format on` after the line or block to resume normal
    formatting. Here’s an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要忽略特定的行或代码块，您可以使用特殊的注释标记。在您想要忽略的行或代码块之前放置 `// clang-format off`，然后在行或代码块之后使用
    `// clang-format on` 以恢复正常格式化。以下是一个示例：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, Clang-Format will not touch `int  variableNameNotFormatted=42;`,
    but will apply the specified formatting rules to `int properlyFormattedVariable
    =` `43;`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，Clang-Format 不会修改 `int  variableNameNotFormatted=42;`，但会应用指定的格式化规则到 `int
    properlyFormattedVariable =` `43;`。
- en: This feature offers a fine-grained level of control over the formatting process,
    allowing you to combine the benefits of automated formatting with the nuances
    that may be required for specific coding situations. Feel free to include this
    in your chapter to provide a complete view of what Clang-Format offers for code
    style management.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能提供了对格式化过程的精细控制，允许你结合自动格式化的好处和特定编码情况下可能需要的细微差别。请随意将此内容包含在你的章节中，以提供一个完整的 Clang-Format
    在代码风格管理方面提供的视图。
- en: Endless options for configuration
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无尽的配置选项
- en: 'Since Clang-Format is based on the Clang compiler’s code parser, it can provide
    the most precise analysis of source code and, as a result, the most endless configuration
    options. The complete list of possible settings can be found on the official page:
    [https://clang.llvm.org/docs/ClangFormatStyleOptions.html](https://clang.llvm.org/docs/ClangFormatStyleOptions.html).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Clang-Format 基于 Clang 编译器的代码解析器，它可以提供对源代码的最精确分析，因此提供了最无尽的配置选项。可能的设置完整列表可以在官方页面找到：[https://clang.llvm.org/docs/ClangFormatStyleOptions.html](https://clang.llvm.org/docs/ClangFormatStyleOptions.html)。
- en: Version control and sharing
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制和共享
- en: It’s generally a good practice to include your `.clang-format` file in your
    project’s version control system. This ensures that every member of your team,
    as well as your CI/CD system, uses the same set of formatting rules, leading to
    a more consistent and maintainable code base.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将你的 `.clang-format` 文件包含在你的项目的版本控制系统是一个好的做法。这确保了你的团队每个成员以及你的 CI/CD 系统都使用相同的格式化规则集，从而使得代码库更加一致和易于维护。
- en: Integrating Clang-Format into the build system
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Clang-Format 集成到构建系统中
- en: In today’s software development landscape, CMake stands as a de facto industry
    standard for build systems. It offers a powerful and flexible way to manage builds
    across different platforms and compilers. Integrating Clang-Format – a tool for
    automatically formatting C++ code – into your CMake build process can help ensure
    consistent code formatting across your project. In this section, we’ll delve into
    how this can be achieved effectively.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的软件开发环境中，CMake 作为构建系统的行业事实标准。它提供了一种强大且灵活的方式来管理不同平台和编译器的构建。将 Clang-Format（一个用于自动格式化
    C++ 代码的工具）集成到你的 CMake 构建过程中可以帮助确保项目中的代码格式一致性。在本节中，我们将深入探讨如何有效地实现这一点。
- en: 'First, you must start by identifying the Clang-Format executable on your system
    using CMake’s `find_program()` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须使用 CMake 的 `find_program()` 函数在你的系统上识别 Clang-Format 可执行文件：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, you must gather all the source files you wish to format. The `file(GLOB_RECURSE
    ...)` function is useful for this purpose:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须收集你希望格式化的所有源文件。`file(GLOB_RECURSE ...)` 函数对此很有用：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, there’s a slight hiccup: this approach also includes files from your
    build directory, which you likely don’t want to format. This also usually applies
    to third-party directories. Fortunately, you can filter these out using CMake’s
    `list(FILTER ...)` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个小插曲：这种方法也会包括你的构建目录中的文件，你很可能不希望格式化这些文件。这通常也适用于第三方目录。幸运的是，你可以使用 CMake
    的 `list(FILTER ...)` 函数来过滤掉这些文件：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, you must create a custom CMake target that, when built, runs Clang-Format
    on your gathered source files:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须创建一个自定义的 CMake 目标，当构建时，它会运行 Clang-Format 对你的源文件进行格式化：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By doing this, you can create a custom target named `clang-format` that developers
    can run to automatically format all the source files in the project while ignoring
    any files in the build directory. Executing this target can be done with a simple
    `make clang-format` or `cmake --build . --target clang-format` command, ensuring
    that consistent formatting is maintained with ease.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，你可以创建一个名为 `clang-format` 的自定义目标，开发者可以运行它来自动格式化项目中的所有源文件，同时忽略构建目录中的任何文件。执行此目标可以通过简单的
    `make clang-format` 或 `cmake --build . --target clang-format` 命令来完成，确保轻松地保持格式的一致性。
- en: Including this Clang-Format and CMake integration in your build process not
    only helps in maintaining a consistent coding style but also facilitates easier
    code reviews and collaborative development. Feel free to incorporate these insights
    and code snippets into your project or any technical documentation you’re working
    on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的构建过程中包含 Clang-Format 和 CMake 的集成不仅有助于保持一致的编码风格，还便于代码审查和协作开发。请随意将这些见解和代码片段纳入你的项目或你正在工作的任何技术文档中。
- en: Clang-Format report examples
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clang-Format 报告示例
- en: 'Let’s prepare a simple example to demonstrate the Clang-Format tool in action.
    We will create a basic C++ source file named `main.cpp` with some formatting issues.
    Then, we will run Clang-Format on this file to automatically correct the formatting
    and generate a report of the changes made:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备一个简单的例子来演示 Clang-Format 工具的实际应用。我们将创建一个名为 `main.cpp` 的基本 C++ 源文件，其中包含一些格式问题。然后，我们将对这个文件运行
    Clang-Format 以自动纠正格式并生成更改报告：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will try to analyze it with the Clang-Format tool and a ruleset we defined
    earlier in `.clang-format`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用 Clang-Format 工具和我们在 `.clang-format` 中定义的规则集来分析它：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, the errors are not very descriptive. However, most of the time,
    developers can understand what’s wrong with the code. The tool is not only able
    to detect the issues but also fix them. Let’s run the tool to fix the formatting
    issues `make clang-format` and see the results:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，错误描述并不详细。然而，大多数时候，开发者可以理解代码中的问题。该工具不仅能够检测问题，还能修复它们。让我们运行工具来修复格式问题 `make
    clang-format` 并查看结果：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code is now properly formatted and can be used in the project. This example
    can be included in your chapter to demonstrate the practical application of Clang-Format
    in a real-world scenario. In the future, developers may add more formatting rules
    to the `.clang-format` file and re-format the whole project by running the `make`
    `clang-format` command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在格式正确，可以用于项目。这个例子可以包含在你的章节中，以展示 Clang-Format 在实际场景中的实际应用。将来，开发者可能会向 `.clang-format`
    文件添加更多格式规则，并通过运行 `make clang-format` 命令重新格式化整个项目。
- en: Extending for code format checks for CI
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 CI 代码格式检查
- en: When setting up CI pipelines, it’s often beneficial to only check whether the
    code complies with the established formatting rules rather than automatically
    modifying the source files. This ensures that any code that doesn’t meet the style
    guidelines is flagged, prompting the developer to fix it manually. Clang-Format
    supports this use case with the `--dry-run` and `--Werror` options, which, when
    combined, cause the tool to exit with a non-zero status code if any file is reformatted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 CI 管道时，通常只检查代码是否遵守既定的格式规则，而不是自动修改源文件，这样做往往是有益的。这确保了任何不符合风格指南的代码都会被标记出来，提示开发者手动修复。Clang-Format
    通过 `--dry-run` 和 `--Werror` 选项支持这种用法，当这两个选项结合使用时，如果任何文件被重新格式化，工具将以非零状态码退出。
- en: 'You can extend the existing CMake setup so that it includes a new custom target
    that only checks the code format. Here’s how to do this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以扩展现有的 CMake 设置，使其包括一个新自定义目标，该目标仅检查代码格式。以下是这样做的方法：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this extended setup, a new custom target named `check-clang-format` has been
    added. The `--dry-run` option ensures that no files are modified, while `-Werror`
    causes Clang-Format to exit with an error code if any formatting discrepancies
    are found. This target can be run with `make check-clang-format` or `cmake --build
    . --``target check-clang-format`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个扩展设置中，已添加一个名为 `check-clang-format` 的新自定义目标。`--dry-run` 选项确保没有文件被修改，而 `-Werror`
    会导致 Clang-Format 在发现任何格式差异时以错误代码退出。此目标可以通过 `make check-clang-format` 或 `cmake
    --build . --target check-clang-format` 运行。
- en: Now, in your CI pipeline script, you can invoke this custom target to enforce
    code-style checks. If the code is not formatted according to the guidelines specified,
    the build will fail, alerting the team that there is a formatting issue that needs
    to be resolved.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的 CI 管道脚本中，您可以调用此自定义目标来强制执行代码风格检查。如果代码没有按照指定的指南进行格式化，构建将失败，提醒团队存在需要解决的格式问题。
- en: 'For example, in our `.clang-format` file, we set the indent width to four spaces,
    but the `main.cpp` file only uses two:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的 `.clang-format` 文件中，我们将缩进宽度设置为四个空格，但 `main.cpp` 文件只使用了两个：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we run the checker, it shows the problematic code without changing it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行检查器，它会显示有问题的代码，但不会更改它：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By adding this custom target to your CMake setup, you add an additional layer
    of quality assurance to your project. It ensures that no code that violates the
    established formatting guidelines can make its way into the code base unnoticed.
    This is particularly helpful in collaborative environments where multiple developers
    might be contributing to the same project. Feel free to include this advanced
    example and its rationale in your technical content.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此自定义目标添加到您的 CMake 设置中，您为项目添加了一个额外的质量保证层。这确保了任何违反既定格式指南的代码都无法未经注意地进入代码库。这在多个开发者可能共同参与同一项目的协作环境中尤其有用。请随意将此高级示例及其理由包含在您的技术内容中。
- en: Clang-Format support across various editors
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clang-Format 在各种编辑器中的支持
- en: Clang-Format enjoys extensive support across a multitude of text editors and
    IDEs, streamlining the code-formatting process irrespective of your development
    environment. One of the significant advantages of integrating Clang-Format directly
    into your IDE or text editor is the ability to invoke it effortlessly, right from
    your development environment. Even better, many editors support automatically
    triggering Clang-Format upon saving a file. This feature can be a massive boon
    to productivity and code quality as it ensures that every saved version of a source
    file adheres to the project’s coding standards without requiring manual intervention.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 在众多文本编辑器和 IDE 中得到了广泛的支持，简化了代码格式化过程，无论你的开发环境如何。将 Clang-Format 直接集成到你的
    IDE 或文本编辑器中的一个显著优势是能够轻松调用它，直接从你的开发环境中调用。更好的是，许多编辑器支持在保存文件时自动触发 Clang-Format。这个功能可以极大地提高生产力和代码质量，因为它确保了每个保存的源文件都遵循项目的编码标准，而无需人工干预。
- en: 'In Visual Studio Code, there are a few plugins that provide integration with
    Clang-Format:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，有一些插件提供了与 Clang-Format 的集成：
- en: '**C/C+**, by Microsoft: [https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C/C++**, by Microsoft: [https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)'
- en: '**Clang-Format**, by Xaver Hellauer: [https://marketplace.visualstudio.com/items?itemName=xaver.clang-format](https://marketplace.visualstudio.com/items?itemName=xaver.clang-format)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clang-Format**, by Xaver Hellauer: [https://marketplace.visualstudio.com/items?itemName=xaver.clang-format](https://marketplace.visualstudio.com/items?itemName=xaver.clang-format)'
- en: '**ClangD**, by the LLVM (the creators of Clang, Clang-Format, and other tools):
    [https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd](https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClangD**, by the LLVM (the creators of Clang, Clang-Format, and other tools):
    [https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd](https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd)'
- en: Vim and NeoVim users can leverage plugins such as `vim-clang-format` to integrate
    Clang-Format, and even map it to specific keyboard shortcuts for quick formatting.
    Also, it can usually be enabled via an LSP provider plugin or feature.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Vim 和 NeoVim 用户可以利用如 `vim-clang-format` 的插件来集成 Clang-Format，甚至将其映射到特定的键盘快捷键以实现快速格式化。此外，通常可以通过
    LSP 提供器插件或功能来启用它。
- en: For developers using the full-fledged version of Visual Studio, Clang-Format
    integration is built-in; you can easily specify a `.clang-format` configuration
    file and the IDE will use it when you format your code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用完整版 Visual Studio 的开发者，Clang-Format 集成是内置的；你可以轻松指定一个 `.clang-format` 配置文件，IDE
    将在格式化代码时使用它。
- en: Similarly, JetBrains’ CLion supports Clang-Format out of the box, allowing users
    to import `.clang-format` configuration files directly into the project settings.
    This broad range of editor support makes it effortless to maintain consistent
    code formatting across diverse development teams as each team member can use their
    preferred tools without compromising on code quality.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，JetBrains 的 CLion 默认支持 Clang-Format，允许用户直接将 `.clang-format` 配置文件导入到项目设置中。这种广泛的编辑器支持使得在多样化的开发团队中保持一致的代码格式变得轻而易举，因为每个团队成员都可以使用他们偏好的工具，而不会影响代码质量。
- en: Checking name styling
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查命名风格
- en: After meticulously formatting our code to ensure that spaces, asterisks, alignments,
    and brace positions are all in place, there remains one final frontier to unify
    – naming style. Ensuring consistency in naming conventions across classes, variables,
    functions, and other identifiers can often be a painstaking process, usually relegated
    to vigilant peer reviews. However, there’s an automated way to achieve this, thereby
    reducing manual effort and error.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在仔细格式化我们的代码以确保空格、星号、对齐和括号位置都正确之后，还剩下最后一个要统一的前沿领域——命名风格。确保类、变量、函数和其他标识符的命名约定一致性通常是一个费力的过程，通常被委派给警觉的同行评审。然而，有一种自动化的方法可以实现这一点，从而减少人工努力和错误。
- en: Clang-Tidy comes to the rescue for this purpose. While we’ll dive deeper into
    the various capabilities of Clang-Tidy in the next chapter, it’s worth noting
    that it’s more than just a linter. It offers a plethora of checks for not just
    syntactic sugar but also semantic analysis and readability. One of its most useful
    features in the context of naming conventions is the identifier naming check.
    By configuring this check, you can enforce project-wide rules for naming various
    entities.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Tidy为此目的提供了帮助。虽然我们将在下一章深入探讨Clang-Tidy的各种功能，但值得注意的是，它不仅仅是一个代码检查器。它提供了大量的检查，不仅包括语法糖，还包括语义分析和可读性。在命名约定方面，它最有用的功能之一是标识符命名检查。通过配置这个检查，你可以强制执行项目中各种实体的命名规则。
- en: 'Let’s say you want your class, struct, and enum names to be `CamelCase`, your
    namespaces, variables, functions, and methods to be `lower_case`, and your constants
    to be `UPPER_CASE`. Additionally, you prefer that private and protected variables
    have a trailing underscore, `_`, while public ones do not. All of these requirements
    can be configured in a simple `.clang-tidy` file, which Clang-Tidy will read to
    enforce your naming rules:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想让你的类、结构体和枚举的名称使用`CamelCase`格式，你的命名空间、变量、函数和方法使用`lower_case`格式，而你的常量使用`UPPER_CASE`格式。此外，你更喜欢私有和受保护的变量后面有一个尾随下划线`_`，而公共变量则没有。所有这些要求都可以在一个简单的`.clang-tidy`文件中配置，Clang-Tidy会读取这个文件来强制执行你的命名规则：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These rules can be endlessly extended with the highest resolution. The full
    documentation for existing checks is available at [https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html](https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则可以无限扩展到最高分辨率。现有检查的完整文档可在[https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html](https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html)找到。
- en: By incorporating Clang-Tidy into your build process and CI pipeline, you can
    automate the enforcement of these naming conventions, making the code base easier
    to read, maintain, and collaborate on. We will delve deeper into configuring and
    using Clang-Tidy for various other checks in the upcoming chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将Clang-Tidy集成到你的构建过程和CI管道中，你可以自动化这些命名约定的强制执行，使代码库更容易阅读、维护和协作。我们将在下一章深入探讨配置和使用Clang-Tidy进行各种其他检查。
- en: Integrating Clang-Tidy into the build system
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Clang-Tidy集成到构建系统中
- en: 'We can adapt our existing CMake setup so that it includes Clang-Tidy checks,
    similar to what we did with Clang-Format. Here’s a sample CMake script that sets
    up custom targets for running Clang-Tidy on a C++ project:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调整现有的CMake设置，使其包括Clang-Tidy检查，类似于我们处理Clang-Format的方式。以下是一个示例CMake脚本，它为在C++项目上运行Clang-Tidy设置了自定义目标：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this script, we locate the `clang-tidy` executable using `find_program`.
    Similar to the Clang-Format setup, we then gather all the source files from the
    root directory recursively, making sure we exclude those in the build directory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们使用`find_program`定位`clang-tidy`可执行文件。类似于Clang-Format的设置，然后我们递归地收集根目录下的所有源文件，确保排除构建目录中的文件。
- en: 'Two custom targets are added here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里添加了两个自定义目标：
- en: '`clang-tidy`: This target runs Clang-Tidy on all gathered source files. The
    `-p=${CMAKE_BINARY_DIR}` flag specifies the build directory containing the `compile_commands.json`
    file, which Clang-Tidy uses for its checks. This JSON file is generated by CMake
    and contains information about how each source file in the project is compiled.
    It includes details such as the compiler options, include directories, defines,
    and so on. Clang-Tidy uses this information to understand the build context of
    each source file, allowing it to perform more accurate and meaningful checks.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clang-tidy`：这个目标会在所有收集到的源文件上运行Clang-Tidy。`-p=${CMAKE_BINARY_DIR}`标志指定包含`compile_commands.json`文件的构建目录，Clang-Tidy使用这个文件进行检查。这个JSON文件由CMake生成，包含有关项目中每个源文件如何编译的信息。它包括编译器选项、包含目录、定义等信息。Clang-Tidy使用这些信息来理解每个源文件的构建上下文，从而允许它执行更准确和有意义的检查。'
- en: '`check-clang-tidy`: This target performs the same operation but with the `--warnings-as-errors=*`
    flag. This will treat all warnings as errors, which is especially useful for CI/CD
    pipelines to ensure code quality.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check-clang-tidy`：这个目标执行相同的操作，但带有`--warnings-as-errors=*`标志。这将把所有警告视为错误，这对于CI/CD管道确保代码质量特别有用。'
- en: As in your previous setup, running these custom targets can be done via `make
    clang-tidy` or `make check-clang-tidy` or their equivalent `cmake --build . --target
    clang-tidy` and `cmake --build . --``target check-clang-tidy`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与您之前的设置一样，运行这些自定义目标可以通过 `make clang-tidy` 或 `make check-clang-tidy` 或其等效的 `cmake
    --build . --target clang-tidy` 和 `cmake --build . --target check-clang-tidy` 来完成。
- en: By integrating Clang-Tidy into your CMake build process, you’ll be providing
    another layer of automated code quality checks, much like you did with Clang-Format.
    Feel free to include this in your chapter for a comprehensive look at automated
    code quality assurance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 Clang-Tidy 集成到您的 CMake 构建过程中，您将提供另一层自动代码质量检查，就像您使用 Clang-Format 所做的那样。请随意将其包含在您的章节中，以全面了解自动代码质量保证。
- en: Checking source code name styling with Clang-Tidy
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Clang-Tidy 检查源代码命名风格
- en: 'Now that we’ve successfully configured Clang-Tidy’s rules and integrated the
    tool into our CMake build system, it’s time for a real-world test. For this purpose,
    we’ll use a snippet of C++ code that deliberately violates the naming conventions
    we’ve established:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功配置了 Clang-Tidy 的规则并将工具集成到我们的 CMake 构建系统中，是时候进行实际测试了。为此，我们将使用一段故意违反我们已建立的命名约定的
    C++ 代码：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we run `make clang-tidy`, Clang-Tidy will spring into action, scanning
    the offending code and flagging any naming issues directly in the terminal output.
    I’ve only provided a partial output here to save space:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `make clang-tidy` 时，Clang-Tidy 将迅速行动，扫描违规代码，并在终端输出中直接标记任何命名问题。这里只提供了部分输出以节省空间：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This exercise demonstrates the tangible benefits of integrating Clang-Tidy into
    the build process. It not only identifies deviations from established naming conventions
    in the code but also provides an opportunity for immediate rectification. It’s
    an invaluable step toward maintaining a code base that is not just functional
    but also consistently well-structured. It’s advisable to include the `make clang-tidy`
    command in your CI pipeline. By doing so, you can automatically validate the naming
    conventions and other code styling rules for every commit made to your repository.
    This will help ensure that any new contributions to the code base conform to the
    established guidelines. If a commit fails the Clang-Tidy checks, the CI pipeline
    can flag it for review, making it easier to maintain a consistent, high-quality
    code base. This added layer of automation eliminates the need for manual checks
    for these issues, thus streamlining the code review process and making your development
    workflow more efficient.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了将 Clang-Tidy 集成到构建过程中的实际好处。它不仅识别了代码中与既定命名约定的偏差，而且还提供了立即纠正的机会。这是维护一个不仅功能性强而且结构一致的代码库的宝贵步骤。建议将
    `make clang-tidy` 命令包含到您的 CI 流程中。通过这样做，您可以自动验证提交到您的存储库的每个提交的命名约定和其他代码风格规则。这将有助于确保任何对代码库的新贡献都符合既定指南。如果提交未通过
    Clang-Tidy 检查，CI 流程可以将其标记为待审阅，从而更容易维护一致、高质量的代码库。这一额外的自动化层消除了对这些问题的手动检查需求，从而简化了代码审查过程，并使您的开发工作流程更加高效。
- en: Fixing naming issues automatically
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动修复命名问题
- en: 'The real power of Clang-Tidy lies in its ability to not just identify issues
    but also to rectify them automatically. Manual fixes can be time-consuming and
    error-prone, making automation incredibly valuable in a fast-paced development
    environment. Fortunately, Clang-Tidy excels in this area. Most of the fixes suggested
    by the tool can be applied automatically, saving you countless hours of manual
    labor and potential errors. To apply these automatic fixes, simply run `make clang-tidy`
    in your terminal. The tool will scan the code for violations, and where possible,
    it will automatically correct the code so that it aligns with your configured
    guidelines:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Tidy 的真正力量在于它不仅能够识别问题，还能够自动修复它们。手动修复可能耗时且容易出错，在快节奏的开发环境中，自动化变得极其宝贵。幸运的是，Clang-Tidy
    在这个领域表现出色。工具建议的大多数修复都可以自动应用，为您节省了大量手动劳动和潜在的错误。要应用这些自动修复，只需在您的终端中运行 `make clang-tidy`。该工具将扫描代码中的违规行为，并在可能的情况下自动纠正代码，使其与您配置的指南保持一致：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that not only were the classes, methods, and variables definitions updated
    but also references to them. This functionality makes Clang-Tidy not just a diagnostic
    tool but a valuable assistant in maintaining the overall quality of your code
    base.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不仅类、方法和变量的定义已更新，而且对它们的引用也已更新。这一功能使 Clang-Tidy 不仅是一个诊断工具，而且在维护代码库的整体质量方面也是一个宝贵的助手。
- en: Important caveats
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: 'There are some important caveats to consider when using Clang-Tidy. Let’s take
    a look:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Clang-Tidy 时有一些重要的注意事项需要考虑。让我们看看：
- en: '**Single versus multiple instances**: The CMake configuration we’ve discussed
    runs a single instance of Clang-Tidy to check and fix all the source files. While
    this may be sufficient for smaller projects, it can become a bottleneck for larger
    code bases with numerous checks. In such scenarios, it might be more efficient
    to divide the source code into logical groups and run multiple instances of Clang-Tidy
    in parallel. This strategy can significantly reduce the time it takes to scan
    the entire code base.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单个实例与多个实例**: 我们讨论的 CMake 配置运行单个 Clang-Tidy 实例来检查和修复所有源文件。虽然这可能对较小的项目足够，但对于具有众多检查的大型代码库来说，可能会成为瓶颈。在这种情况下，将源代码划分为逻辑组并并行运行多个
    Clang-Tidy 实例可能更有效率。这种策略可以显著减少扫描整个代码库所需的时间。'
- en: '**Commit before fixing**: While Clang-Tidy’s ability to automatically fix issues
    is invaluable, it’s advised to use this feature only on code that has been committed
    to your version control system. Some of the checks provided by Clang-Tidy can
    be unstable and, in rare instances, may even introduce bugs. Committing your code
    beforehand ensures that you have a stable point to revert to if things go awry.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在修复前提交**: 虽然 Clang-Tidy 自动修复问题的能力非常有价值，但建议仅在已提交到您的版本控制系统的代码上使用此功能。Clang-Tidy
    提供的一些检查可能不稳定，而且在极少数情况下甚至可能引入错误。提前提交您的代码可以确保您有一个稳定的点可以回退，以防事情出错。'
- en: '`User` struct was initialized using C++20 designated initializer lists, as
    shown in the following example:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User` 结构体使用 C++20 指定初始化列表进行初始化，如下例所示：'
- en: '[PRE18]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Clang-Tidy will fix the `name_` variable and the `execute` constant in their
    definition but will completely ignore the initializer, which will eventually lead
    to a compilation error.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Clang-Tidy 将修复 `name_` 变量和 `execute` 常量在其定义中，但将完全忽略初始化器，这最终会导致编译错误。
- en: Being aware of these caveats allows you to employ Clang-Tidy more effectively
    and leverage its strengths while mitigating potential risks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些注意事项可以使您更有效地使用 Clang-Tidy，并利用其优势同时减轻潜在风险。
- en: Example project
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例项目
- en: For those who wish to delve deeper into the details and get hands-on experience
    with the configuration and usage of Clang-Tidy and Clang-Format, an example project
    complete with the CMake setup and code snippets is available on GitHub ([https://github.com/f-squirrel/clang-format-tidy](https://github.com/f-squirrel/clang-format-tidy)).
    This will allow you to better understand the nuances and practical applications
    of integrating these tools into your C++ projects. Feel free to clone the repository,
    experiment with the code, and even contribute to enhancing it further.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些希望深入了解细节并亲身体验 Clang-Tidy 和 Clang-Format 的配置和使用的人来说，GitHub 上有一个包含 CMake 设置和代码片段的示例项目（[https://github.com/f-squirrel/clang-format-tidy](https://github.com/f-squirrel/clang-format-tidy)）。这将使您更好地理解将这些工具集成到您的
    C++ 项目中的细微差别和实际应用。您可以自由地克隆存储库，实验代码，甚至进一步贡献以增强它。
- en: Clang-Tidy support across various editors
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clang-Tidy 在各种编辑器中的支持
- en: The IDE and editor support for Clang-Tidy is broadly similar to that for Clang-Format,
    making it equally accessible and easy to integrate into your development workflow.
    The principal advantage of this integrated support is the immediate feedback loop
    it offers. As you code, Clang-Tidy warnings and errors will appear directly within
    your IDE, enabling you to spot potential issues without having to leave the development
    environment. This is immensely valuable for maintaining code quality in real time,
    rather than as a separate step.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Tidy 和 Clang-Format 的 IDE 和编辑器支持大致相似，这使得它同样易于访问并集成到您的开发工作流程中。这种集成支持的优点是它提供的即时反馈循环。当您编码时，Clang-Tidy
    的警告和错误将直接在您的 IDE 中显示，让您无需离开开发环境就能发现潜在的问题。这对于实时维护代码质量而不是作为单独的步骤来说非常有价值。
- en: 'Moreover, many IDEs also provide an interface to apply Clang-Tidy’s automatic
    fixes directly from within the editor, making it easier than ever to adhere to
    your coding standards. For example, the following screenshot of Visual Studio
    Code illustrates the inline warnings:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多 IDE 也提供了从编辑器内部直接应用 Clang-Tidy 自动修复的界面，这使得遵守您的编码标准比以往任何时候都更容易。例如，以下 Visual
    Studio Code 的截图显示了内联警告：
- en: '![Figure 9.1 – Warnings](img/B19606_09_01.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 警告](img/B19606_09_01.jpg)'
- en: Figure 9.1 – Warnings
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 警告
- en: 'The following screenshot shows the fixes that can be applied to them:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了可以应用于它们的修复：
- en: '![Figure 9.2 – Applicable fixes](img/B19606_09_02.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 可应用修复](img/B19606_09_02.jpg)'
- en: Figure 9.2 – Applicable fixes
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 可应用修复
- en: This real-time, in-editor feedback mechanism can significantly boost your productivity
    and code quality, making Clang-Tidy not just a static code analysis tool but an
    integral part of your coding process.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实时、在编辑器中的反馈机制可以显著提高你的生产力和代码质量，使Clang-Tidy不仅仅是一个静态代码分析工具，而是你编码过程中的一个重要组成部分。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we navigated the essential landscape of automated code quality
    maintenance, focusing particularly on code formatting and naming conventions.
    We started by providing an overview of existing tools that can help enforce coding
    standards, then zeroed in on Clang-Format and Clang-Tidy as comprehensive solutions
    for these issues. We learned not only how to use these tools to automatically
    check and fix our code but also how to seamlessly integrate them into our build
    system, CI pipelines, and code editors.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了自动化代码质量维护的基本领域，特别关注代码格式和命名约定。我们首先概述了现有的可以帮助强制执行编码标准的工具，然后聚焦于Clang-Format和Clang-Tidy作为这些问题的全面解决方案。我们不仅学习了如何使用这些工具自动检查和修复我们的代码，还学习了如何无缝地将它们集成到我们的构建系统、CI管道和代码编辑器中。
- en: By doing so, we’ve laid a strong foundation for ensuring that our code remains
    consistent and adheres to best practices, all with minimal manual intervention.
    This sets the stage perfectly for the next chapter, where we will dive deeper
    into the realm of static code analysis, further solidifying our commitment to
    high-quality, maintainable code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们为确保我们的代码保持一致并遵循最佳实践奠定了坚实的基础，这一切都只需最少的手动干预。这为下一章的深入探讨静态代码分析领域做好了完美的铺垫，进一步巩固了我们致力于高质量、可维护代码的承诺。
