- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code Formatting and Naming Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the vast and complex landscape of software development, some topics may seem
    less significant at first glance, yet they hold enormous value when considered
    in the broader context of creating robust and maintainable software. Code formatting
    is one such topic. While it might appear to be a mere aesthetic concern, it plays
    an essential role in enhancing code readability, simplifying maintenance, and
    fostering effective collaboration among team members. The significance of these
    aspects becomes even more pronounced in languages such as C++, where the structure
    and syntax can easily become complex.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delve deep into the nuances of code formatting, providing
    you with a comprehensive understanding of its importance. But understanding the
    “why” is only the first step; it’s equally crucial to know the “how.” Therefore,
    we will also explore the various tools available for automatically formatting
    your C++ code, taking a close look at their features and possibilities, as well
    as how they can be configured to meet your project’s specific needs. From industry-standard
    tools such as Clang-Format to editor-specific plugins, we’ll examine how to make
    these powerful utilities work for you.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have not only a thorough understanding of
    why code formatting is essential but also the practical knowledge to implement
    consistent and effective formatting across your C++ projects. So, let’s turn the
    page and embark on this enlightening journey.
  prefs: []
  type: TYPE_NORMAL
- en: Why is code formatting important?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The importance of code formatting in software development, especially in languages
    such as C++, can’t be overstated. Let’s begin with readability, which is crucial
    because code is often read more frequently than it is written. Proper indentation
    and spacing give the code a visual structure, facilitating a quick understanding
    of its flow and logic. In a well-formatted code base, it’s easier to scan through
    the code to identify key elements such as loops, conditionals, and sections. This,
    in turn, reduces the need for excessive comments since the code often becomes
    self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to maintainability, consistent code formatting is a boon. Well-structured
    code is easier to debug. For instance, a consistent indentation can quickly highlight
    unclosed brackets or scope issues, making it easier to spot errors. Well-formatted
    code also enables developers to isolate sections of code more effectively, which
    is essential for both debugging and refactoring. Additionally, maintainability
    is not just about the here and now; it’s about future-proofing the code. As the
    code base evolves, a consistent formatting style ensures that new additions are
    easier to integrate.
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration is another area where consistent code formatting plays a significant
    role. In a team setting, having a unified code style reduces the cognitive load
    for each team member. It allows developers to focus more on the logic and implementation
    of the code rather than getting sidetracked by stylistic inconsistencies. This
    is particularly beneficial during code reviews, where the uniform style enables
    reviewers to focus on the core logic and potential issues instead of being distracted
    by varying formatting styles. For new team members, a consistently formatted code
    base can be much easier to understand, helping them get up to speed more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, code formatting plays a role in quality assurance and can be automated
    to some extent. Many teams utilize automated formatting tools to ensure that the
    code base maintains a consistent style, which not only reduces the likelihood
    of human error but can also be a factor in code quality metrics. Automated checks
    for code formatting can be integrated into the CI/CD pipeline, making it a part
    of the overall best practices for the project.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s not forget the impact of code formatting on version control.
    A consistent coding style ensures that version histories and diffs accurately
    reflect changes in code logic, not just style adjustments. This makes it easier
    to track changes, identify issues, and understand the evolution of the code base
    over time using tools such as `git blame` and `git history`.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, proper code formatting serves both a functional and aesthetic
    purpose. It enhances readability, simplifies maintenance, and fosters collaboration,
    all of which contribute to the effective and efficient development of robust and
    maintainable software.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of existing tools that facilitate compliance with coding conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world of C++ development has seen an ever-increasing focus on writing clean,
    maintainable code. One of the cornerstones of this approach is adherence to well-defined
    coding conventions. Thankfully, several tools can help automate this process,
    making it easier for developers to focus on solving actual problems rather than
    fretting over code aesthetics. In this section, we’ll take a broad look at some
    of the most popular and widely used tools for enforcing coding conventions in
    C++ projects.
  prefs: []
  type: TYPE_NORMAL
- en: cpplint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: cpplint is a Python-based tool that aims to check your C++ code against Google’s
    style guide, providing a less flexible but highly focused toolset for maintaining
    coding conventions. If you or your team admire Google’s C++ coding standards,
    cpplint offers a straightforward path to ensure compliance within your project.
  prefs: []
  type: TYPE_NORMAL
- en: cpplint comes with a set of predefined checks based on Google’s C++ style guide.
    These checks cover a variety of aspects, from file headers to indentation, and
    from variable naming to the inclusion of unnecessary headers. The tool is executed
    from the command line, and its output offers clear guidance on which parts of
    the code violate the guidelines, often providing hints on how to correct these
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Being Python-based, cpplint enjoys the advantage of being cross-platform. You
    can easily integrate it into development environments across Windows, macOS, and
    Linux, making it a convenient choice for diverse teams.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line nature of cpplint allows it to be easily integrated into a
    variety of development pipelines. It can be included in pre-commit hooks, part
    of a CI system, or even be set to run at specific intervals during development.
    Several IDEs and text editors also provide plugins to run cpplint automatically
    on file save or during a build.
  prefs: []
  type: TYPE_NORMAL
- en: While it doesn’t offer the same level of customization as some other tools,
    cpplint has the advantage of being backed by Google, and it follows a widely respected
    style guide. The tool has extensive documentation that not only explains how to
    use cpplint but also dives into the reasoning behind specific coding conventions,
    offering valuable insights into the principles of writing clean, maintainable
    C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: The primary limitation of cpplint is its lack of flexibility. The tool is designed
    to enforce Google’s coding standards and offers limited scope for customization.
    This can be a drawback if your project has unique formatting requirements or if
    you’re working within a team that has already adopted a different set of conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, cpplint serves as a focused tool for C++ developers who wish
    to adopt Google’s C++ style guide within their projects. While it may not offer
    the wide range of customization features found in some other tools, its simplicity,
    ease of integration, and adherence to well-respected coding standards make it
    a valuable asset for many development teams.
  prefs: []
  type: TYPE_NORMAL
- en: More information about cpplint can be found on the official page ([https://github.com/google/styleguide/tree/gh-pages/cpplint](https://github.com/google/styleguide/tree/gh-pages/cpplint))
    and in the forked GitHub repository maintained by enthusiasts ([https://github.com/cpplint/cpplint](https://github.com/cpplint/cpplint)).
  prefs: []
  type: TYPE_NORMAL
- en: Artistic Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the realm of code formatting tools, **Artistic Style** (**Astyle**) holds
    a unique position. It is designed to be a fast, small, and, above all, simple
    tool that supports multiple programming languages, including C++. One of the standout
    features of Astyle is its ease of use, making it a particularly good choice for
    smaller projects or for teams who are venturing into the world of automated code
    formatting for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Astyle provides a set of predefined styles such as ANSI, GNU, and Google, among
    others, which can serve as good starting points for your project’s coding conventions.
    Additionally, it offers options to adjust indentation, align variables and pointers,
    and even sort modifiers, among other things. These can be controlled through command-line
    options or a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: A major benefit of Astyle is its cross-platform nature. It can be used on Windows,
    macOS, and Linux, making it a versatile choice for teams with diverse development
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: One of the strong suits of Astyle is its ease of integration into various development
    pipelines. It can be easily hooked into pre-commit scripts, integrated into the
    most popular text editors, and even added to your CI process.
  prefs: []
  type: TYPE_NORMAL
- en: Although it may not have as extensive a community as some other tools, Astyle
    has been around for quite some time and has built up a solid user base. Its documentation
    is straightforward to understand, providing clear guidance even for those who
    are new to the concept of automated code formatting.
  prefs: []
  type: TYPE_NORMAL
- en: While Astyle is feature-rich, it’s worth noting that it might not be the best
    fit for extremely large or complex projects that require highly specialized formatting
    rules. It offers fewer customization options compared to some other tools, which
    could be a limitation if your project has very specific formatting requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, Astyle serves as a robust and easy-to-use tool for automating code
    formatting in C++ projects. Its simplicity, ease of integration, and cross-platform
    support make it an attractive option for many developers. Whether you are new
    to automated code formatting or looking for a simpler alternative, Astyle offers
    a straightforward way to ensure that your code base adheres to consistent coding
    conventions. For more information, please refer to the project’s official page:
    [https://astyle.sourceforge.net/astyle.html](https://astyle.sourceforge.net/astyle.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Uncrustify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to the realm of code formatting in C++, Uncrustify stands out
    for its incredible range of customization options. This powerful tool offers a
    level of granularity that few other formatters can match, making it an ideal choice
    for large and complex projects with highly specific formatting needs. If you’re
    someone who relishes the ability to fine-tune every aspect of your code’s appearance,
    then Uncrustify is worth a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Uncrustify supports an extensive set of formatting options, allowing developers
    to customize everything from indentation levels and brace styles to the alignment
    of comments and code constructs. All these options can be set in a configuration
    file that can then be shared across a development team to ensure consistent formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Uncrustify is cross-platform compatible and can be easily used in development
    environments on Windows, macOS, and Linux. It is not tied to any specific development
    environment and offers a variety of integration paths. It can be set up as a pre-commit
    hook in your version control system, integrated into popular IDEs through plugins,
    or even included as a step in your CI pipeline. Because of its command-line nature,
    integrating Uncrustify into various tools and workflows is typically straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Uncrustify has an active community and its documentation, although sometimes
    considered dense, is comprehensive. This provides developers with a rich source
    of information for understanding the tool’s extensive capabilities. While the
    configuration can be challenging due to its sheer volume of options, numerous
    online resources and forums offer guidance, tips, and best practices for making
    the most of Uncrustify’s features.
  prefs: []
  type: TYPE_NORMAL
- en: The most notable limitation of Uncrustify is its complexity. The tool’s strength
    – its myriad customization options – can also be a weakness, especially for smaller
    projects or teams that don’t require such a high level of configurability. Additionally,
    the steep learning curve could be a barrier for teams looking for a quick solution
    to implement consistent code formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, Uncrustify offers an unmatched level of customization for those
    looking to fine-tune their C++ code formatting to the nth degree. Its wide array
    of features, coupled with extensive documentation and an active community, makes
    it a robust choice for teams seeking to enforce very specific coding standards.
    If you’re up for the challenge of mastering its many options, Uncrustify can serve
    as an invaluable tool for maintaining a clean and consistent code base. For more
    detailed information, please refer to the official GitHub page: [https://github.com/uncrustify/uncrustify](https://github.com/uncrustify/uncrustify).'
  prefs: []
  type: TYPE_NORMAL
- en: Editor plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an age where development teams are more diverse than ever, relying on a single
    IDE for code formatting can be problematic. Not only does it force developers
    to adapt to a specific work environment – potentially hindering their performance
    – but it also creates challenges in maintaining a consistent code style across
    different IDEs. Furthermore, such reliance poses complications for integrating
    code formatting into CI/CD pipelines. This is where editor plugins come into play
    as a more flexible and universal solution.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key advantages of editor plugins is their wide availability across
    multiple text editors and IDEs. Whether your team prefers Visual Studio Code,
    Sublime Text, Vim, or Emacs, chances are there’s a plugin available that integrates
    with your chosen code formatting tool. This means every team member can work in
    the development environment they are most comfortable with, without compromising
    on code consistency.
  prefs: []
  type: TYPE_NORMAL
- en: ditor plugins often act as wrappers around standalone formatting tools such
    as Clang-Format, Astyle, and Uncrustify. This facilitates an easy transition,
    especially if your team is already using one of these tools. The configuration
    files for these tools can be shared, ensuring that the same formatting rules are
    applied irrespective of the editor being used.
  prefs: []
  type: TYPE_NORMAL
- en: Since many editor plugins leverage standalone command-line tools for code formatting,
    they naturally fit well into CI/CD pipelines. This eliminates the need to rely
    on IDE-specific tools, which may not be easily adaptable to CI/CD systems. With
    a standalone tool, the same formatting checks can be performed both locally by
    developers and automatically within the CI/CD pipeline, ensuring consistency across
    the board.
  prefs: []
  type: TYPE_NORMAL
- en: While editor plugins offer a versatile approach to code formatting, they do
    come with their own set of limitations. First, not all editors may support the
    full range of available formatting tools, although most popular editors have a
    wide range of plugins. Second, while installing and configuring plugins is generally
    straightforward, it does require an initial setup effort from each developer on
    the team.
  prefs: []
  type: TYPE_NORMAL
- en: Editor plugins provide an accessible and universal solution for implementing
    code formatting across diverse development environments. Their flexibility allows
    team members to choose their preferred editors without sacrificing code consistency,
    and their compatibility with standalone formatting tools makes them an excellent
    fit for inclusion in CI/CD pipelines. For teams that prioritize both developer
    autonomy and code consistency, editor plugins offer a balanced and effective approach.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to discussing code formatting tools that have gained significant
    traction in the C++ community, Clang-Format undoubtedly takes a front seat. Often
    considered the Swiss Army knife of code formatting, this tool combines robustness
    with a wealth of customization options. As this chapter’s favorite, we will delve
    deeper into its intricacies, exploring its extensive features and configurations
    in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, Clang-Format is designed to automatically reformat code so that
    it complies with a set of specified rules. These rules can range from handling
    whitespace and indentation to more complex aspects such as code block alignment
    and comment reformatting. Configuration is usually done via a `.clang-format`
    file, where developers can define their style preferences in a structured manner.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Format offers excellent cross-platform support, functioning seamlessly
    on Windows, macOS, and Linux. This ensures that irrespective of the development
    environment, your team can benefit from consistent code formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Format shines due to its ease of integration. It can be invoked directly
    from the command line, included in scripts, or used via plugins in virtually any
    major text editor or IDE. This flexibility ensures that each developer can integrate
    it into their workflow, regardless of their choice of editor.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line nature of Clang-Format also allows it to easily fit into CI/CD
    pipelines. With configuration files that can be stored and version-controlled
    alongside your code base, it ensures that the CI/CD system applies the same formatting
    rules as any developer would locally.
  prefs: []
  type: TYPE_NORMAL
- en: With strong backing from a broad community of developers and extensive documentation,
    Clang-Format has a wealth of resources available for new and experienced users
    alike. This community support becomes particularly beneficial when you’re looking
    to resolve issues or customize complex formatting rules.
  prefs: []
  type: TYPE_NORMAL
- en: Given its capabilities and my personal preference for this tool, the latter
    sections of this chapter will dive deeper into the world of Clang-Format. From
    setting up your first `.clang-format` file to exploring some of its more advanced
    features, we’ll cover how to make the most of what this powerful tool has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Format configuration – a deep dive into customizing your formatting rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to configuring Clang-Format, the possibilities are almost endless,
    allowing you to tweak even the most minute details of your code’s appearance.
    However, for those who are new to this tool or those who wish to quickly adopt
    a widely accepted set of rules, Clang-Format allows you to derive configurations
    from existing presets. These presets serve as solid foundations upon which you
    can build a tailored formatting style that suits your project’s specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging existing presets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang-Format offers several built-in presets that adhere to popular coding
    standards. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LLVM`: Adheres to the LLVM coding standards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Google`: Follows Google’s C++ style guide'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chromium`: Based on Chromium’s style guide, a variant of Google’s style guide'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mozilla`: Follows the Mozilla coding standards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebKit`: Adheres to the WebKit coding standards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use one of these presets, simply set the `BasedOnStyle` option in your `.clang-format`
    configuration file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This tells Clang-Format to apply the Google C++ style guide as a base and then
    apply any additional customizations you specify.
  prefs: []
  type: TYPE_NORMAL
- en: Extending and overriding presets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After choosing a preset that aligns closest with your team’s coding philosophy,
    you can start customizing specific rules. The `.clang-format` file allows you
    to override or extend the preset’s rules by listing them under the `BasedOnStyle`
    option. For example, an extended `.clang-format` example can demonstrate how to
    fine-tune various aspects of code formatting. The following is a sample configuration
    file that starts with Google’s style as a base and then customizes several specific
    aspects, such as indentation width, brace wrapping, and the alignment of consecutive
    assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the options we chose here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IndentWidth` and `TabWidth`: These set the number of spaces for indentation
    and tabs, respectively. Here, `UseTab: Never` specifies not to use tabs for indentation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BreakBeforeBraces` and `BraceWrapping`: These options customize when to break
    before opening braces in various situations such as classes, functions, and namespaces.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AlignAfterOpenBracket`, `AlignConsecutiveAssignments`, and so on: These control
    how various code elements, such as open brackets and consecutive assignments,
    are aligned.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpaceBeforeParens`, `SpaceInEmptyParentheses`, and so on: These manage spaces
    in different scenarios, such as before parentheses in control statements or within
    empty parentheses.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MaxEmptyLinesToKeep`: This option limits the maximum number of consecutive
    empty lines to keep.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ColumnLimit`: This option sets a column limit per line to ensure the code
    doesn’t exceed the specified limit, enhancing readability.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `.clang-format` file should be placed in the root directory of your project
    and committed to your version control system so that every team member and your
    CI/CD pipeline can use the same configuration for consistent code formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring specific lines with Clang-Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Clang-Format is an excellent tool for maintaining a consistent coding
    style across a project, there might be occasions when you’d prefer to keep certain
    lines or blocks of code untouched. Thankfully, Clang-Format provides the functionality
    to exclude specific lines or code blocks from formatting. This can be particularly
    useful for lines where the original formatting is essential for readability or
    lines that contain generated code that should not be altered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ignore a particular line or block of code, you can use special comment markers.
    Place `// clang-format off` before the line or block of code that you want to
    ignore, and then use `// clang-format on` after the line or block to resume normal
    formatting. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, Clang-Format will not touch `int  variableNameNotFormatted=42;`,
    but will apply the specified formatting rules to `int properlyFormattedVariable
    =` `43;`.
  prefs: []
  type: TYPE_NORMAL
- en: This feature offers a fine-grained level of control over the formatting process,
    allowing you to combine the benefits of automated formatting with the nuances
    that may be required for specific coding situations. Feel free to include this
    in your chapter to provide a complete view of what Clang-Format offers for code
    style management.
  prefs: []
  type: TYPE_NORMAL
- en: Endless options for configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Clang-Format is based on the Clang compiler’s code parser, it can provide
    the most precise analysis of source code and, as a result, the most endless configuration
    options. The complete list of possible settings can be found on the official page:
    [https://clang.llvm.org/docs/ClangFormatStyleOptions.html](https://clang.llvm.org/docs/ClangFormatStyleOptions.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Version control and sharing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s generally a good practice to include your `.clang-format` file in your
    project’s version control system. This ensures that every member of your team,
    as well as your CI/CD system, uses the same set of formatting rules, leading to
    a more consistent and maintainable code base.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Clang-Format into the build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s software development landscape, CMake stands as a de facto industry
    standard for build systems. It offers a powerful and flexible way to manage builds
    across different platforms and compilers. Integrating Clang-Format – a tool for
    automatically formatting C++ code – into your CMake build process can help ensure
    consistent code formatting across your project. In this section, we’ll delve into
    how this can be achieved effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must start by identifying the Clang-Format executable on your system
    using CMake’s `find_program()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you must gather all the source files you wish to format. The `file(GLOB_RECURSE
    ...)` function is useful for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there’s a slight hiccup: this approach also includes files from your
    build directory, which you likely don’t want to format. This also usually applies
    to third-party directories. Fortunately, you can filter these out using CMake’s
    `list(FILTER ...)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you must create a custom CMake target that, when built, runs Clang-Format
    on your gathered source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, you can create a custom target named `clang-format` that developers
    can run to automatically format all the source files in the project while ignoring
    any files in the build directory. Executing this target can be done with a simple
    `make clang-format` or `cmake --build . --target clang-format` command, ensuring
    that consistent formatting is maintained with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Including this Clang-Format and CMake integration in your build process not
    only helps in maintaining a consistent coding style but also facilitates easier
    code reviews and collaborative development. Feel free to incorporate these insights
    and code snippets into your project or any technical documentation you’re working
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Format report examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s prepare a simple example to demonstrate the Clang-Format tool in action.
    We will create a basic C++ source file named `main.cpp` with some formatting issues.
    Then, we will run Clang-Format on this file to automatically correct the formatting
    and generate a report of the changes made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will try to analyze it with the Clang-Format tool and a ruleset we defined
    earlier in `.clang-format`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the errors are not very descriptive. However, most of the time,
    developers can understand what’s wrong with the code. The tool is not only able
    to detect the issues but also fix them. Let’s run the tool to fix the formatting
    issues `make clang-format` and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code is now properly formatted and can be used in the project. This example
    can be included in your chapter to demonstrate the practical application of Clang-Format
    in a real-world scenario. In the future, developers may add more formatting rules
    to the `.clang-format` file and re-format the whole project by running the `make`
    `clang-format` command.
  prefs: []
  type: TYPE_NORMAL
- en: Extending for code format checks for CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When setting up CI pipelines, it’s often beneficial to only check whether the
    code complies with the established formatting rules rather than automatically
    modifying the source files. This ensures that any code that doesn’t meet the style
    guidelines is flagged, prompting the developer to fix it manually. Clang-Format
    supports this use case with the `--dry-run` and `--Werror` options, which, when
    combined, cause the tool to exit with a non-zero status code if any file is reformatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can extend the existing CMake setup so that it includes a new custom target
    that only checks the code format. Here’s how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this extended setup, a new custom target named `check-clang-format` has been
    added. The `--dry-run` option ensures that no files are modified, while `-Werror`
    causes Clang-Format to exit with an error code if any formatting discrepancies
    are found. This target can be run with `make check-clang-format` or `cmake --build
    . --``target check-clang-format`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in your CI pipeline script, you can invoke this custom target to enforce
    code-style checks. If the code is not formatted according to the guidelines specified,
    the build will fail, alerting the team that there is a formatting issue that needs
    to be resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our `.clang-format` file, we set the indent width to four spaces,
    but the `main.cpp` file only uses two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we run the checker, it shows the problematic code without changing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By adding this custom target to your CMake setup, you add an additional layer
    of quality assurance to your project. It ensures that no code that violates the
    established formatting guidelines can make its way into the code base unnoticed.
    This is particularly helpful in collaborative environments where multiple developers
    might be contributing to the same project. Feel free to include this advanced
    example and its rationale in your technical content.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Format support across various editors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clang-Format enjoys extensive support across a multitude of text editors and
    IDEs, streamlining the code-formatting process irrespective of your development
    environment. One of the significant advantages of integrating Clang-Format directly
    into your IDE or text editor is the ability to invoke it effortlessly, right from
    your development environment. Even better, many editors support automatically
    triggering Clang-Format upon saving a file. This feature can be a massive boon
    to productivity and code quality as it ensures that every saved version of a source
    file adheres to the project’s coding standards without requiring manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, there are a few plugins that provide integration with
    Clang-Format:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C/C+**, by Microsoft: [https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clang-Format**, by Xaver Hellauer: [https://marketplace.visualstudio.com/items?itemName=xaver.clang-format](https://marketplace.visualstudio.com/items?itemName=xaver.clang-format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ClangD**, by the LLVM (the creators of Clang, Clang-Format, and other tools):
    [https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd](https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vim and NeoVim users can leverage plugins such as `vim-clang-format` to integrate
    Clang-Format, and even map it to specific keyboard shortcuts for quick formatting.
    Also, it can usually be enabled via an LSP provider plugin or feature.
  prefs: []
  type: TYPE_NORMAL
- en: For developers using the full-fledged version of Visual Studio, Clang-Format
    integration is built-in; you can easily specify a `.clang-format` configuration
    file and the IDE will use it when you format your code.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, JetBrains’ CLion supports Clang-Format out of the box, allowing users
    to import `.clang-format` configuration files directly into the project settings.
    This broad range of editor support makes it effortless to maintain consistent
    code formatting across diverse development teams as each team member can use their
    preferred tools without compromising on code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Checking name styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After meticulously formatting our code to ensure that spaces, asterisks, alignments,
    and brace positions are all in place, there remains one final frontier to unify
    – naming style. Ensuring consistency in naming conventions across classes, variables,
    functions, and other identifiers can often be a painstaking process, usually relegated
    to vigilant peer reviews. However, there’s an automated way to achieve this, thereby
    reducing manual effort and error.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Tidy comes to the rescue for this purpose. While we’ll dive deeper into
    the various capabilities of Clang-Tidy in the next chapter, it’s worth noting
    that it’s more than just a linter. It offers a plethora of checks for not just
    syntactic sugar but also semantic analysis and readability. One of its most useful
    features in the context of naming conventions is the identifier naming check.
    By configuring this check, you can enforce project-wide rules for naming various
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want your class, struct, and enum names to be `CamelCase`, your
    namespaces, variables, functions, and methods to be `lower_case`, and your constants
    to be `UPPER_CASE`. Additionally, you prefer that private and protected variables
    have a trailing underscore, `_`, while public ones do not. All of these requirements
    can be configured in a simple `.clang-tidy` file, which Clang-Tidy will read to
    enforce your naming rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These rules can be endlessly extended with the highest resolution. The full
    documentation for existing checks is available at [https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html](https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html).
  prefs: []
  type: TYPE_NORMAL
- en: By incorporating Clang-Tidy into your build process and CI pipeline, you can
    automate the enforcement of these naming conventions, making the code base easier
    to read, maintain, and collaborate on. We will delve deeper into configuring and
    using Clang-Tidy for various other checks in the upcoming chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Clang-Tidy into the build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can adapt our existing CMake setup so that it includes Clang-Tidy checks,
    similar to what we did with Clang-Format. Here’s a sample CMake script that sets
    up custom targets for running Clang-Tidy on a C++ project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this script, we locate the `clang-tidy` executable using `find_program`.
    Similar to the Clang-Format setup, we then gather all the source files from the
    root directory recursively, making sure we exclude those in the build directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two custom targets are added here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clang-tidy`: This target runs Clang-Tidy on all gathered source files. The
    `-p=${CMAKE_BINARY_DIR}` flag specifies the build directory containing the `compile_commands.json`
    file, which Clang-Tidy uses for its checks. This JSON file is generated by CMake
    and contains information about how each source file in the project is compiled.
    It includes details such as the compiler options, include directories, defines,
    and so on. Clang-Tidy uses this information to understand the build context of
    each source file, allowing it to perform more accurate and meaningful checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check-clang-tidy`: This target performs the same operation but with the `--warnings-as-errors=*`
    flag. This will treat all warnings as errors, which is especially useful for CI/CD
    pipelines to ensure code quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in your previous setup, running these custom targets can be done via `make
    clang-tidy` or `make check-clang-tidy` or their equivalent `cmake --build . --target
    clang-tidy` and `cmake --build . --``target check-clang-tidy`.
  prefs: []
  type: TYPE_NORMAL
- en: By integrating Clang-Tidy into your CMake build process, you’ll be providing
    another layer of automated code quality checks, much like you did with Clang-Format.
    Feel free to include this in your chapter for a comprehensive look at automated
    code quality assurance.
  prefs: []
  type: TYPE_NORMAL
- en: Checking source code name styling with Clang-Tidy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we’ve successfully configured Clang-Tidy’s rules and integrated the
    tool into our CMake build system, it’s time for a real-world test. For this purpose,
    we’ll use a snippet of C++ code that deliberately violates the naming conventions
    we’ve established:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run `make clang-tidy`, Clang-Tidy will spring into action, scanning
    the offending code and flagging any naming issues directly in the terminal output.
    I’ve only provided a partial output here to save space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This exercise demonstrates the tangible benefits of integrating Clang-Tidy into
    the build process. It not only identifies deviations from established naming conventions
    in the code but also provides an opportunity for immediate rectification. It’s
    an invaluable step toward maintaining a code base that is not just functional
    but also consistently well-structured. It’s advisable to include the `make clang-tidy`
    command in your CI pipeline. By doing so, you can automatically validate the naming
    conventions and other code styling rules for every commit made to your repository.
    This will help ensure that any new contributions to the code base conform to the
    established guidelines. If a commit fails the Clang-Tidy checks, the CI pipeline
    can flag it for review, making it easier to maintain a consistent, high-quality
    code base. This added layer of automation eliminates the need for manual checks
    for these issues, thus streamlining the code review process and making your development
    workflow more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing naming issues automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The real power of Clang-Tidy lies in its ability to not just identify issues
    but also to rectify them automatically. Manual fixes can be time-consuming and
    error-prone, making automation incredibly valuable in a fast-paced development
    environment. Fortunately, Clang-Tidy excels in this area. Most of the fixes suggested
    by the tool can be applied automatically, saving you countless hours of manual
    labor and potential errors. To apply these automatic fixes, simply run `make clang-tidy`
    in your terminal. The tool will scan the code for violations, and where possible,
    it will automatically correct the code so that it aligns with your configured
    guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that not only were the classes, methods, and variables definitions updated
    but also references to them. This functionality makes Clang-Tidy not just a diagnostic
    tool but a valuable assistant in maintaining the overall quality of your code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Important caveats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some important caveats to consider when using Clang-Tidy. Let’s take
    a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single versus multiple instances**: The CMake configuration we’ve discussed
    runs a single instance of Clang-Tidy to check and fix all the source files. While
    this may be sufficient for smaller projects, it can become a bottleneck for larger
    code bases with numerous checks. In such scenarios, it might be more efficient
    to divide the source code into logical groups and run multiple instances of Clang-Tidy
    in parallel. This strategy can significantly reduce the time it takes to scan
    the entire code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commit before fixing**: While Clang-Tidy’s ability to automatically fix issues
    is invaluable, it’s advised to use this feature only on code that has been committed
    to your version control system. Some of the checks provided by Clang-Tidy can
    be unstable and, in rare instances, may even introduce bugs. Committing your code
    beforehand ensures that you have a stable point to revert to if things go awry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User` struct was initialized using C++20 designated initializer lists, as
    shown in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Clang-Tidy will fix the `name_` variable and the `execute` constant in their
    definition but will completely ignore the initializer, which will eventually lead
    to a compilation error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Being aware of these caveats allows you to employ Clang-Tidy more effectively
    and leverage its strengths while mitigating potential risks.
  prefs: []
  type: TYPE_NORMAL
- en: Example project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those who wish to delve deeper into the details and get hands-on experience
    with the configuration and usage of Clang-Tidy and Clang-Format, an example project
    complete with the CMake setup and code snippets is available on GitHub ([https://github.com/f-squirrel/clang-format-tidy](https://github.com/f-squirrel/clang-format-tidy)).
    This will allow you to better understand the nuances and practical applications
    of integrating these tools into your C++ projects. Feel free to clone the repository,
    experiment with the code, and even contribute to enhancing it further.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Tidy support across various editors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IDE and editor support for Clang-Tidy is broadly similar to that for Clang-Format,
    making it equally accessible and easy to integrate into your development workflow.
    The principal advantage of this integrated support is the immediate feedback loop
    it offers. As you code, Clang-Tidy warnings and errors will appear directly within
    your IDE, enabling you to spot potential issues without having to leave the development
    environment. This is immensely valuable for maintaining code quality in real time,
    rather than as a separate step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, many IDEs also provide an interface to apply Clang-Tidy’s automatic
    fixes directly from within the editor, making it easier than ever to adhere to
    your coding standards. For example, the following screenshot of Visual Studio
    Code illustrates the inline warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Warnings](img/B19606_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Warnings
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the fixes that can be applied to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Applicable fixes](img/B19606_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Applicable fixes
  prefs: []
  type: TYPE_NORMAL
- en: This real-time, in-editor feedback mechanism can significantly boost your productivity
    and code quality, making Clang-Tidy not just a static code analysis tool but an
    integral part of your coding process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we navigated the essential landscape of automated code quality
    maintenance, focusing particularly on code formatting and naming conventions.
    We started by providing an overview of existing tools that can help enforce coding
    standards, then zeroed in on Clang-Format and Clang-Tidy as comprehensive solutions
    for these issues. We learned not only how to use these tools to automatically
    check and fix our code but also how to seamlessly integrate them into our build
    system, CI pipelines, and code editors.
  prefs: []
  type: TYPE_NORMAL
- en: By doing so, we’ve laid a strong foundation for ensuring that our code remains
    consistent and adheres to best practices, all with minimal manual intervention.
    This sets the stage perfectly for the next chapter, where we will dive deeper
    into the realm of static code analysis, further solidifying our commitment to
    high-quality, maintainable code.
  prefs: []
  type: TYPE_NORMAL
