["```cpp\nenum class SelectMode{ Tiles, Entities, Emitters }; \nusing NameList = std::vector<std::pair<std::string, bool>>; \n\n```", "```cpp\nclass GUI_SelectionOptions { \npublic: \n  GUI_SelectionOptions(EventManager* l_eventManager, \n    GUI_Manager* l_guiManager, MapControls* l_controls, \n    GUI_MapTileSelector* l_selector, Map* l_map, TileMap* l_brush, \n    EntityManager* l_entityMgr, ParticleSystem* l_particles); \n  ~GUI_SelectionOptions(); \n\n  void Show(); \n  void Hide(); \n  void SetControlMode(ControlMode l_mode); \n  void SetSelectMode(SelectMode l_mode); \n  SelectMode GetSelectMode()const; \n  void SelectEntity(int l_id); \n  void SelectEmitter(Emitter* l_emitter); \n  sf::Vector2i GetSelectXRange() const; \n  sf::Vector2i GetSelectYRange() const; \n  unsigned int GetLowestLayer() const; \n  unsigned int GetHighestLayer() const; \n\n  void Update(); \n  void Draw(sf::RenderWindow* l_window); \n  bool MouseClick(const sf::Vector2f& l_pos); \n  void MouseRelease(); \n  void Reset(); \n\n  void SelectModeSwitch(EventDetails* l_details); \n  void OpenTileSelection(EventDetails* l_details); \n  void SolidToggle(EventDetails* l_details); \n  void CopySelection(EventDetails* l_details); \n  void PlaceSelection(EventDetails* l_details); \n  void RemoveSelection(EventDetails* l_details); \n  void ToggleLayers(EventDetails* l_details); \n  void SelectionOptionsElevation(EventDetails* l_details); \n  void SaveOptions(EventDetails* l_details); \nprivate: \n  void SelectionElevationUpdate(); \n  void UpdateSelectDrawable(); \n  void UpdateTileSelection(); \n  void UpdateEntitySelection(); \n  void UpdateEmitterSelection(); \n  void DeleteSelection(bool l_deleteAll); \n  ... \n}; \n\n```", "```cpp\nclass GUI_SelectionOptions { \nprivate: \n  ... \n  // Selection data. \n  SelectMode m_selectMode; \n  sf::RectangleShape m_selectDrawable; \n  sf::Color m_selectStartColor; \n  sf::Color m_selectEndColor; \n  sf::Color m_entityColor; \n  sf::Color m_emitterColor; \n  sf::Vector2i m_selectRangeX; \n  sf::Vector2i m_selectRangeY; \n  bool m_selectUpdate; \n  // Entity and emitter select info. \n  int m_entityId; \n  C_Position* m_entity; \n  Emitter* m_emitter; \n  NameList m_entityNames; \n  NameList m_emitterNames; \n  // Selection range. \n  unsigned int m_layerSelectLow; \n  unsigned int m_layerSelectHigh; \n  // Interfaces. \n  GUI_Interface* m_selectionOptions; \n  MapControls* m_mapControls; \n  GUI_MapTileSelector* m_tileSelector; \n  // Class ties. \n  EventManager* m_eventManager; \n  GUI_Manager* m_guiManager; \n  Map* m_map; \n  TileMap* m_brush; \n  EntityManager* m_entityManager; \n  ParticleSystem* m_particleSystem; \n}; \n\n```", "```cpp\nGUI_SelectionOptions::GUI_SelectionOptions( \n  EventManager* l_eventManager, GUI_Manager* l_guiManager, \n  MapControls* l_controls, GUI_MapTileSelector* l_selector, \n  Map* l_map, TileMap* l_brush, EntityManager* l_entityMgr, \n  ParticleSystem* l_particles) : \n  /* Processing arguments. */ \n  m_eventManager(l_eventManager), m_guiManager(l_guiManager), \n  m_mapControls(l_controls), m_tileSelector(l_selector), \n  m_map(l_map), m_brush(l_brush), m_entityManager(l_entityMgr), \n  m_particleSystem(l_particles), \n  /* Initializing default values of data members. */ \n  m_selectRangeX(-1, -1), m_selectRangeY(-1, -1), \n  m_layerSelectLow(0), m_layerSelectHigh(0), \n  m_selectMode(SelectMode::Tiles), m_entityId(-1), \n  m_entity(nullptr), m_emitter(nullptr), m_selectUpdate(true) \n{...} \n\n```", "```cpp\nGUI_SelectionOptions::GUI_SelectionOptions(...) \n{ \n  ... // Setting up callbacks. \n  m_guiManager->LoadInterface( \n    \"MapEditorSelectionOptions.interface\", \n    \"MapEditorSelectionOptions\"); \n  m_selectionOptions =  \n    m_guiManager->GetInterface(\"MapEditorSelectionOptions\"); \n  m_selectionOptions->SetPosition({ 0.f, 164.f }); \n  m_selectionOptions->SetActive(false); \n  m_selectStartColor = sf::Color(0, 0, 150, 120); \n  m_selectEndColor = sf::Color(0, 0, 255, 150); \n  m_entityColor = sf::Color(255, 0, 0, 150); \n  m_emitterColor = sf::Color(0, 255, 0, 150); \n\n  m_entityNames = Utils::GetFileList(Utils::GetWorkingDirectory() \n    + \"media/Entities/\", \"*.entity\"); \n  m_emitterNames = Utils::GetFileList(Utils::GetWorkingDirectory() \n    + \"media/Particles/\", \"*.particle\"); \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::Show() { \n  m_selectionOptions->SetActive(true); \n  m_guiManager->BringToFront(m_selectionOptions); \n} \nvoid GUI_SelectionOptions::Hide() { \n  m_selectionOptions->SetActive(false); \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::SetControlMode(ControlMode l_mode) { \n  if (l_mode != ControlMode::Brush && l_mode \n    != ControlMode::Select) \n  { return; } \n  SetSelectMode(SelectMode::Tiles); \n  if (l_mode == ControlMode::Brush) { \n    m_selectionOptions->SetActive(true); \n    m_selectionOptions->Focus(); \n    m_selectionOptions->GetElement(\"TileSelect\")->SetActive(true); \n  } else if (l_mode == ControlMode::Select) { \n    m_selectionOptions->SetActive(true); \n    m_selectionOptions->Focus(); \n    m_selectionOptions->GetElement(\"SolidToggle\")-> \n      SetActive(true); \n    m_selectionOptions->GetElement(\"CopySelection\")-> \n      SetActive(true); \n  } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::SetSelectMode(SelectMode l_mode) { \n  Reset(); \n  m_selectMode = l_mode; \n  m_selectionOptions->SetActive(true); \n  m_selectionOptions->Focus(); \n\n  if (l_mode == SelectMode::Tiles) { \n    ... // GUI Element manipulation. \n  } else if(l_mode == SelectMode::Entities) { \n    ... // GUI Element manipulation. \n    auto dropdown = static_cast<GUI_DropDownMenu*>( \n      m_selectionOptions->GetElement(\"SelectDropdown\"))-> \n      GetMenu(); \n    dropdown->PurgeEntries(); \n    for (auto& entity : m_entityNames) { \n      dropdown->AddEntry( \n        entity.first.substr(0, entity.first.find(\".entity\"))); \n    } \n    dropdown->Redraw(); \n  } else if (l_mode == SelectMode::Emitters) { \n    ... // GUI Element manipulation. \n    auto dropdown = static_cast<GUI_DropDownMenu*>( \n      m_selectionOptions->GetElement(\"SelectDropdown\"))-> \n      GetMenu(); \n    dropdown->PurgeEntries(); \n    for (auto& emitter : m_emitterNames) { \n      dropdown->AddEntry( \n        emitter.first.substr(0, emitter.first.find(\".particle\"))); \n    } \n    dropdown->Redraw(); \n  } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::SelectEntity(int l_id) { \n  if (l_id == -1) { \n    m_entityId = -1; \n    m_selectionOptions->GetElement(\"CopySelection\")-> \n      SetActive(false); \n    m_selectionOptions->GetElement(\"PlaceSelection\")-> \n      SetText(\"Place\"); \n    m_selectionOptions->GetElement(\"RemoveSelection\")-> \n      SetActive(false); \n    m_entity = nullptr; \n    return; \n  } \n  auto pos = m_entityManager-> \n    GetComponent<C_Position>(l_id, Component::Position); \n  if (!pos) { \n    m_entityId = -1; \n    m_selectionOptions->GetElement(\"CopySelection\")-> \n      SetActive(false); \n    m_selectionOptions->GetElement(\"PlaceSelection\")-> \n      SetText(\"Place\"); \n    m_selectionOptions->GetElement(\"RemoveSelection\")-> \n      SetActive(false); \n    m_entity = nullptr; \n    return; \n  } \n  m_selectionOptions->GetElement(\"CopySelection\")-> \n    SetActive(true); \n  m_selectionOptions->GetElement(\"PlaceSelection\")-> \n    SetText(\"Edit\"); \n  m_selectionOptions->GetElement(\"RemoveSelection\")-> \n    SetActive(true); \n  m_entityId = l_id; \n  m_entity = pos; \n  m_selectionOptions->GetElement(\"InfoText\")-> \n    SetText(std::to_string(m_entityId)); \n  m_selectUpdate = true; \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::SelectEmitter(Emitter* l_emitter) { \n  m_emitter = l_emitter; \n  if (!l_emitter) { \n    m_selectionOptions->GetElement(\"CopySelection\")-> \n      SetActive(false); \n    m_selectionOptions->GetElement(\"PlaceSelection\")-> \n      SetText(\"Place\"); \n    m_selectionOptions->GetElement(\"RemoveSelection\")-> \n      SetActive(false); \n    return; \n  } \n  m_selectionOptions->GetElement(\"CopySelection\")-> \n    SetActive(true); \n  m_selectionOptions->GetElement(\"PlaceSelection\")-> \n    SetText(\"Edit\"); \n  m_selectionOptions->GetElement(\"RemoveSelection\")-> \n    SetActive(true); \n  m_selectionOptions->GetElement(\"InfoText\")->SetText(m_emitter-> \n    GetGenerators()); \n  m_selectionOptions->GetElement(\"EmitRate\")-> \n    SetText(std::to_string(m_emitter->GetEmitRate())); \n  m_selectUpdate = true; \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::SelectModeSwitch( \n  EventDetails* l_details) \n{ \n  if (m_selectMode == SelectMode::Tiles) { \n    if (m_mapControls->GetMode() != ControlMode::Select) { \n      m_mapControls->SelectMode(ControlMode::Select); \n    } \n    SetSelectMode(SelectMode::Entities); \n  } else if (m_selectMode == SelectMode::Entities) { \n    SetSelectMode(SelectMode::Emitters); \n  } else { SetSelectMode(SelectMode::Tiles); } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::OpenTileSelection( \n  EventDetails* l_details) \n{ \n  if (!m_tileSelector->IsActive()) { \n    m_tileSelector->Show(); \n    return; \n  } \n  m_mapControls->SelectMode(ControlMode::Brush); \n  if (m_tileSelector->CopySelection(*m_brush)) { \n    m_selectionOptions->GetElement(\"Solidity\")->SetText(\"False\"); \n    m_mapControls->RedrawBrush(); \n  } \n  m_selectionOptions->GetElement(\"InfoText\")->SetText( \n    std::to_string(m_brush->GetTileCount())); \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::SolidToggle(EventDetails* l_details) { \n  auto mode = m_mapControls->GetMode(); \n  if (m_mapControls->GetMode() != ControlMode::Brush \n    && mode != ControlMode::Select) \n  { return; } \n  auto element = m_selectionOptions->GetElement(\"Solidity\"); \n  auto state = element->GetText(); \n  bool solid = false; \n  std::string newText; \n  if (state == \"True\") { newText = \"False\"; } \n  else { solid = true; newText = \"True\"; } \n  element->SetText(newText); \n  sf::Vector2u start; \n  sf::Vector2u finish; \n  TileMap* map = nullptr; \n  if (mode == ControlMode::Brush) { \n    map = m_brush; \n    start = sf::Vector2u(0, 0); \n    finish = map->GetMapSize() - sf::Vector2u(1, 1); \n  } else if (mode == ControlMode::Select) { \n    map = m_map->GetTileMap(); \n    start = sf::Vector2u(m_selectRangeX.x, m_selectRangeY.x); \n    finish = sf::Vector2u(m_selectRangeX.y, m_selectRangeY.y); \n  } \n\n  for (auto x = start.x; x <= finish.x; ++x) { \n    for (auto y = start.y; y <= finish.y; ++y) { \n      for (auto layer = m_layerSelectLow; \n        layer < m_layerSelectHigh; ++layer) \n      { \n        auto tile = map->GetTile(x, y, layer); \n        if (!tile) { continue; } \n        tile->m_solid = solid; \n      } \n    } \n  } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::CopySelection(EventDetails* l_details) \n{ \n  if (m_selectRangeX.x == -1) { return; } \n  auto size = sf::Vector2u( \n    m_selectRangeX.y - m_selectRangeX.x, \n    m_selectRangeY.y - m_selectRangeY.x); \n  size.x += 1; \n  size.y += 1; \n  m_brush->Purge(); \n  m_brush->SetMapSize(size); \n  unsigned int b_x = 0, b_y = 0, b_l = 0; \n  bool solid = false, mixed = false; \n  unsigned short changes = 0; \n  for (auto x = m_selectRangeX.x; x <= m_selectRangeX.y; ++x) { \n    for (auto y = m_selectRangeY.x; y <= m_selectRangeY.y; ++y) { \n      for (auto layer = m_layerSelectLow; \n        layer <= m_layerSelectHigh; ++layer) \n      { \n        auto tile = m_map->GetTile(x, y, layer); \n        if (!tile) { ++b_l; continue; } \n        auto newTile = m_brush->SetTile( \n          b_x, b_y, b_l, tile->m_properties->m_id); \n        if (!newTile) { continue; } \n        if (!mixed) { \n          if (tile->m_solid && !solid) { \n            solid = true; ++changes; \n          } else if (solid) { \n            solid = false; ++changes; \n          } \n          if (changes >= 2) { mixed = true; } \n        } \n        *newTile = *tile; \n        ++b_l; \n      } \n      b_l = 0; \n      ++b_y; \n    } \n    b_y = 0; \n    ++b_x; \n  } \n  m_layerSelectHigh = m_layerSelectLow + \n    m_brush->GetHighestElevation(); \n  if (m_layerSelectHigh >= Sheet::Num_Layers) { \n    auto difference = (m_layerSelectHigh - Sheet::Num_Layers) + 1; \n    m_layerSelectHigh = Sheet::Num_Layers - 1; \n    m_layerSelectLow -= difference; \n  } \n  SelectionElevationUpdate(); \n  m_mapControls->SelectMode(ControlMode::Brush); \n  m_selectionOptions->GetElement(\"InfoText\")-> \n    SetText(std::to_string(m_brush->GetTileCount())); \n  m_selectionOptions->GetElement(\"Solidity\")-> \n    SetText((mixed ? \"Mixed\" : (solid ? \"True\" : \"False\"))); \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::PlaceSelection(EventDetails* l_details) \n{ \n  if (m_selectMode == SelectMode::Tiles) { return; } \n  auto dropdownValue = static_cast<GUI_DropDownMenu*>( \n    m_selectionOptions->GetElement(\"SelectDropdown\"))-> \n    GetMenu()->GetSelected(); \n  if (dropdownValue.empty()) { return; } \n  if (m_selectMode == SelectMode::Entities) { \n    if (!m_entity || m_entityId == -1) { \n      // New entity. \n      auto id = m_entityManager->AddEntity(dropdownValue); \n      if (id == -1) { return; } \n      SelectEntity(id); \n    } \n    SaveOptions(nullptr); \n  } else if (m_selectMode == SelectMode::Emitters) { \n    if (!m_emitter) { \n      // New emitter. \n      auto text = m_selectionOptions-> \n        GetElement(\"EmitRate\")->GetText(); \n      auto rate = std::stoi(text); \n      auto emitter = m_particleSystem->AddEmitter( \n        sf::Vector3f(0.f, 0.f, 0.f), dropdownValue, rate, \n        StateType::MapEditor); \n      SelectEmitter(emitter); \n    } \n    SaveOptions(nullptr); \n  } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::RemoveSelection( \n  EventDetails* l_details) \n{ \n  DeleteSelection(l_details->m_shiftPressed); \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::DeleteSelection(bool l_deleteAll) { \n  if (m_selectMode == SelectMode::Tiles) { \n    if (m_selectRangeX.x == -1) { return; } \n    auto layerRange = (l_deleteAll ? \n      sf::Vector2u(0, Sheet::Num_Layers - 1) : \n      sf::Vector2u(m_layerSelectLow, m_layerSelectHigh)); \n\n    m_map->GetTileMap()->RemoveTiles( \n      sf::Vector2u(m_selectRangeX), \n      sf::Vector2u(m_selectRangeY), \n      layerRange); \n    m_map->ClearMapTexture( \n      sf::Vector3i(m_selectRangeX.x, \n        m_selectRangeY.x, layerRange.x), \n      sf::Vector3i(m_selectRangeX.y, \n        m_selectRangeY.y, layerRange.y)); \n  } else if (m_selectMode == SelectMode::Entities) { \n    if (!m_entity || m_entityId == -1) { return; } \n    m_entityManager->RemoveEntity(m_entityId); \n    SelectEntity(-1); \n  } else if (m_selectMode == SelectMode::Emitters) { \n    if (!m_emitter) { return; } \n    m_particleSystem->RemoveEmitter(m_emitter); \n    SelectEmitter(nullptr); \n  } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::SelectionOptionsElevation( \n  EventDetails* l_details) \n{ \n  int low = 0, high = 0; \n  bool shift = sf::Keyboard::isKeyPressed(sf::Keyboard::LShift); \n  if (l_details->m_name == \"MapEditor_SelectOptionsPlus\") { \n    if (shift) { high = 1; } else { low = 1; } \n  } else if(l_details->m_name == \"MapEditor_SelectOptionsMinus\") { \n    if (shift) { high = -1; } else { low = -1; } \n  } \n\n  auto mode = m_mapControls->GetMode(); \n\n  if (mode == ControlMode::Brush) { \n    if (high != 0) { return; } // only working with low values. \n    int l = m_layerSelectLow + low; \n    if (l < 0 || l >= Sheet::Num_Layers) { return; } \n    if (l + m_brush->GetHighestElevation() >= \n      Sheet::Num_Layers) \n    { return; } \n    m_layerSelectLow = l; \n    m_layerSelectHigh = l + m_brush->GetHighestElevation(); \n    SelectionElevationUpdate(); \n  } else if (mode == ControlMode::Select) { \n    int l = m_layerSelectLow + low; \n    int h = m_layerSelectHigh + high; \n    if (l < 0 || l >= Sheet::Num_Layers) { return; } \n    if (h < 0 || h >= Sheet::Num_Layers) { return; } \n    if (m_layerSelectLow == m_layerSelectHigh && !shift) { \n      m_layerSelectLow += low; \n      m_layerSelectLow += high; \n      m_layerSelectHigh = m_layerSelectLow; \n    } else { \n      m_layerSelectLow = l; \n      m_layerSelectHigh = h; \n    } \n    if (m_layerSelectLow > m_layerSelectHigh) { \n      std::swap(m_layerSelectLow, m_layerSelectHigh); \n    } \n    SelectionElevationUpdate(); \n  } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::SelectionElevationUpdate() { \n  if (!m_selectionOptions->IsActive()) { return; } \n  m_selectionOptions->GetElement(\"Elevation\")->SetText( \n    std::to_string(m_layerSelectLow) + \n    (m_layerSelectLow != m_layerSelectHigh ? \n    \" - \" + std::to_string(m_layerSelectHigh) : \"\") \n  ); \n  SaveOptions(nullptr); \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::SaveOptions(EventDetails* l_details) { \n  if (m_selectMode == SelectMode::Tiles) { return; } \n\n  auto x = m_selectionOptions->GetElement(\"Pos_X\")->GetText(); \n  auto y = m_selectionOptions->GetElement(\"Pos_Y\")->GetText(); \n  auto z = m_selectionOptions->GetElement(\"Pos_Z\")->GetText(); \n\n  auto c_x = std::stoi(x); \n  auto c_y = std::stoi(y); \n  auto c_z = std::stoi(z); \n\n  if (m_selectMode == SelectMode::Entities) { \n    if (!m_entity || m_entityId == -1) { return; } \n    m_entity->SetPosition(sf::Vector2f(c_x, c_y)); \n    m_entity->SetElevation(m_layerSelectLow); \n  } else if (m_selectMode == SelectMode::Emitters) { \n    if (!m_emitter) { return; } \n    auto emitRate = m_selectionOptions-> \n      GetElement(\"EmitRate\")->GetText(); \n    auto c_rate = std::stoi(emitRate); \n    m_emitter->SetPosition(sf::Vector3f(c_x, c_y, c_z)); \n    m_emitter->SetEmitRate(c_rate); \n  } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::Update() { \n  if (m_selectUpdate) { UpdateSelectDrawable(); } \n  if (!m_mapControls->IsInAction()) { return; } \n  if (m_selectMode == SelectMode::Tiles) {UpdateTileSelection();} \n  else if (m_selectMode == SelectMode::Entities) { \n    UpdateEntitySelection(); \n  } else if (m_selectMode == SelectMode::Emitters) { \n    UpdateEmitterSelection(); \n  } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::UpdateSelectDrawable() { \n  if (m_selectMode == SelectMode::Entities) { \n    if (m_entityId == -1) { return; } \n    if (!m_entity) { return; } \n    if (m_entityManager->HasComponent(m_entityId, \n      Component::Collidable)) \n    { \n      auto col = m_entityManager-> \n        GetComponent<C_Collidable>(m_entityId, \n        Component::Collidable); \n      auto primitive = col->GetCollidable(); \n      m_selectDrawable.setPosition(primitive.left, primitive.top); \n      m_selectDrawable.setSize( \n        sf::Vector2f(primitive.width, primitive.height)); \n    } else if (m_entityManager->HasComponent(m_entityId, \n      Component::SpriteSheet)) \n    { \n      auto drawable = m_entityManager-> \n        GetComponent<C_SpriteSheet>(m_entityId, \n        Component::SpriteSheet); \n      auto pos = drawable->GetSpriteSheet()->GetSpritePosition(); \n      auto size = drawable->GetSpriteSheet()->GetSpriteSize(); \n      m_selectDrawable.setPosition(pos); \n      m_selectDrawable.setSize(sf::Vector2f(size)); \n    } else { \n      m_selectDrawable.setPosition( \n        m_entity->GetPosition() - sf::Vector2f(16.f, 16.f)); \n      m_selectDrawable.setSize(sf::Vector2f(32.f, 32.f)); \n    } \n  } else if (m_selectMode == SelectMode::Emitters) { \n    if (!m_emitter) { return; } \n    auto pos = sf::Vector2f( \n      m_emitter->GetPosition().x, m_emitter->GetPosition().y); \n    m_selectDrawable.setPosition(pos - sf::Vector2f(16.f, 16.f)); \n    m_selectDrawable.setSize(sf::Vector2f(32.f, 32.f)); \n  } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::UpdateTileSelection() { \n  auto& tileStart = m_mapControls->GetMouseTileStart(); \n  auto& mouseTile = m_mapControls->GetMouseTile(); \n\n  auto start = sf::Vector2f( \n    (tileStart.x + (tileStart.x > mouseTile.x ? 1 : 0)) \n      * Sheet::Tile_Size, \n    (tileStart.y + (tileStart.y > mouseTile.y ? 1 : 0)) \n      * Sheet::Tile_Size \n  ); \n\n  auto end = sf::Vector2f( \n    (mouseTile.x + (tileStart.x <= mouseTile.x ? 1 : 0)) \n      * Sheet::Tile_Size, \n    (mouseTile.y + (tileStart.y <= mouseTile.y ? 1 : 0)) \n      * Sheet::Tile_Size \n  ); \n\n  m_selectDrawable.setPosition( \n    (start.x <= end.x ? start.x : end.x), \n    (start.y <= end.y ? start.y : end.y) \n  ); \n\n  m_selectDrawable.setFillColor(m_selectStartColor); \n  m_selectDrawable.setSize({ \n    std::abs(end.x - start.x), \n    std::abs(end.y - start.y) \n  }); \n  m_selectRangeX = sf::Vector2i( \n    std::min(tileStart.x, mouseTile.x), \n    std::max(tileStart.x, mouseTile.x) \n  ); \n  m_selectRangeY = sf::Vector2i( \n    std::min(tileStart.y, mouseTile.y), \n    std::max(tileStart.y, mouseTile.y) \n  ); \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::UpdateEntitySelection() { \n  if (!m_mapControls->IsInAction()) { return; } \n  if (!m_entity) { return; } \n  m_entity->MoveBy(m_mapControls->GetMouseDifference()); \n  auto elevation = m_entity->GetElevation(); \n  m_selectionOptions->GetElement(\"Pos_X\")-> \n    SetText(std::to_string(static_cast<int>( \n      m_entity->GetPosition().x))); \n  m_selectionOptions->GetElement(\"Pos_Y\")-> \n    SetText(std::to_string(static_cast<int>( \n      m_entity->GetPosition().y))); \n  m_selectionOptions->GetElement(\"Elevation\")-> \n    SetText(std::to_string(elevation)); \n  m_layerSelectLow = elevation; \n  m_layerSelectHigh = elevation; \n  m_selectUpdate = true; \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::UpdateEmitterSelection() { \n  if (!m_mapControls->IsInAction()) { return; } \n  if (!m_emitter) { return; } \n  auto emitPos = m_emitter->GetPosition(); \n  auto position = sf::Vector2f(emitPos.x, emitPos.y); \n  position += m_mapControls->GetMouseDifference(); \n  m_emitter->SetPosition( \n    { position.x, position.y, m_emitter->GetPosition().z }); \n  m_selectionOptions->GetElement(\"Pos_X\")-> \n    SetText(std::to_string(static_cast<int>(emitPos.x))); \n  m_selectionOptions->GetElement(\"Pos_Y\")-> \n    SetText(std::to_string(static_cast<int>(emitPos.y))); \n  m_selectionOptions->GetElement(\"Pos_Z\")-> \n    SetText(std::to_string(static_cast<int>(emitPos.z))); \n  m_selectUpdate = true; \n} \n\n```", "```cpp\nbool GUI_SelectionOptions::MouseClick(const sf::Vector2f& l_pos) { \n  if (m_selectMode == SelectMode::Tiles) { return true; } \n  bool madeSelection = false; \n  if (m_selectMode == SelectMode::Entities) { \n    int entity = -1; \n    if (m_mapControls->DrawSelectedLayers()) { \n      entity = m_entityManager->FindEntityAtPoint(l_pos, \n        m_layerSelectLow, m_layerSelectHigh); \n    } else { \n      entity = m_entityManager->FindEntityAtPoint(l_pos); \n    } \n    SelectEntity(entity); \n    madeSelection = entity != -1; \n  } else if (m_selectMode == SelectMode::Emitters) { \n    Emitter* emitter = nullptr; \n    if (m_mapControls->DrawSelectedLayers()) { \n      emitter = m_particleSystem->FindEmitter(l_pos, \n        sf::Vector2f(32.f, 32.f), m_layerSelectLow, \n          m_layerSelectHigh); \n    } else { \n      emitter = m_particleSystem->FindEmitter( \n        l_pos, sf::Vector2f(32.f, 32.f)); \n    } \n    SelectEmitter(emitter); \n    madeSelection = emitter != nullptr; \n  } \n  if (!madeSelection) { \n    m_selectionOptions->GetElement(\"Pos_X\")-> \n      SetText(std::to_string(static_cast<int>(l_pos.x))); \n    m_selectionOptions->GetElement(\"Pos_Y\")-> \n      SetText(std::to_string(static_cast<int>(l_pos.y))); \n  } \n  return madeSelection; \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::MouseRelease() { \n  if (m_selectMode == SelectMode::Tiles) { \n    m_selectDrawable.setFillColor(m_selectEndColor); \n    m_selectionOptions->GetElement(\"CopySelection\")-> \n      SetActive(true); \n    m_selectionOptions->GetElement(\"RemoveSelection\")-> \n      SetActive(true); \n\n    bool solid = false, mixed = false; \n    unsigned short changes = 0; \n    for (auto x = m_selectRangeX.x; x <= m_selectRangeX.y \n      && !mixed; ++x) \n    { \n      for (auto y = m_selectRangeY.x; y <= m_selectRangeY.y \n        && !mixed; ++y) \n      { \n        for (auto layer = m_layerSelectLow; \n          layer <= m_layerSelectHigh && !mixed; ++layer) \n        { \n          auto tile = m_map->GetTile(x, y, layer); \n          if (!tile) { continue; } \n          if (tile->m_solid && !solid) { \n            solid = true; \n            ++changes; \n          } else if (tile->m_solid && !solid) { \n            solid = false; \n            ++changes; \n          } \n          if (changes >= 2) { mixed = true; } \n        } \n      } \n    } \n    m_selectionOptions->GetElement(\"Solidity\")-> \n      SetText((mixed ? \"Mixed\" : (solid ? \"True\" : \"False\"))); \n  } else if (m_selectMode == SelectMode::Entities) { \n    m_selectDrawable.setFillColor(m_entityColor); \n  } else if (m_selectMode == SelectMode::Emitters) { \n    m_selectDrawable.setFillColor(m_emitterColor); \n  } \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::Reset() { \n  auto defaultVector = sf::Vector2i(-1, -1); \n  m_selectRangeX = defaultVector; \n  m_selectRangeY = defaultVector; \n  m_entityId = -1; \n  m_entity = nullptr; \n  m_emitter = nullptr; \n  static_cast<GUI_DropDownMenu*>( \n    m_selectionOptions->GetElement(\"SelectDropdown\"))-> \n    GetMenu()->ResetSelected(); \n  ... // GUI Element manipulation. \n} \n\n```", "```cpp\nvoid GUI_SelectionOptions::Draw(sf::RenderWindow* l_window) { \n  auto mode = m_mapControls->GetMode(); \n  if (mode == ControlMode::Select) { \n    if (m_selectMode == SelectMode::Tiles && \n      m_selectRangeX.x == -1) \n    { return; } \n    if (m_selectMode == SelectMode::Entities && !m_entity) \n    { return; } \n    if (m_selectMode == SelectMode::Emitters && !m_emitter) \n    { return; } \n    l_window->draw(m_selectDrawable); \n  } \n} \n\n```", "```cpp\nunsigned int GUI_SelectionOptions::GetLowestLayer() const{ \n  return m_layerSelectLow; \n} \nunsigned int GUI_SelectionOptions::GetHighestLayer() const{  \n  return m_layerSelectHigh; \n} \nSelectMode GUI_SelectionOptions::GetSelectMode() const{ \n  return m_selectMode; \n} \nsf::Vector2i GUI_SelectionOptions::GetSelectXRange() const{ \n  return sf::Vector2i( \n    std::min(m_selectRangeX.x, m_selectRangeX.y), \n    std::max(m_selectRangeX.x, m_selectRangeX.y)); \n} \nsf::Vector2i GUI_SelectionOptions::GetSelectYRange() const{ \n  return sf::Vector2i( \n    std::min(m_selectRangeY.x, m_selectRangeY.y), \n    std::max(m_selectRangeY.x, m_selectRangeY.y)); \n} \n\n```", "```cpp\nclass GUI_MapTileSelector { \npublic: \n  GUI_MapTileSelector(EventManager* l_eventManager, \n    GUI_Manager* l_guiManager, TextureManager* l_textureManager); \n  ~GUI_MapTileSelector(); \n  void Show(); \n  void Hide(); \n  bool IsActive() const; \n  void SetSheetTexture(const std::string& l_texture); \n  void UpdateInterface(); \n  bool CopySelection(TileMap& l_tileMap) const; \n  void TileSelect(EventDetails* l_details); \n  void Close(EventDetails* l_details); \nprivate: \n  EventManager* m_eventManager; \n  GUI_Manager* m_guiManager; \n  TextureManager* m_textureManager; \n\n  GUI_Interface* m_interface; \n  sf::RenderTexture m_selectorTexture; \n  sf::Sprite m_tileMapSprite; \n  sf::RectangleShape m_shape; \n  std::string m_sheetTexture; \n\n  sf::Vector2u m_startCoords; \n  sf::Vector2u m_endCoords; \n  bool m_selected; \n}; \n\n```", "```cpp\nGUI_MapTileSelector::GUI_MapTileSelector( \n  EventManager* l_eventManager, GUI_Manager* l_guiManager, \n  TextureManager* l_textureManager) : \n  m_eventManager(l_eventManager), m_guiManager(l_guiManager), \n  m_textureManager(l_textureManager), m_selected(false) \n{ \n  m_eventManager->AddCallback(StateType::MapEditor, \n    \"MapEditor_TileSelectClick\", \n    &GUI_MapTileSelector::TileSelect, this); \n  m_eventManager->AddCallback(StateType::MapEditor, \n    \"MapEditor_TileSelectRelease\", \n    &GUI_MapTileSelector::TileSelect, this); \n  m_eventManager->AddCallback(StateType::MapEditor,  \n    \"MapEditor_TileSelectClose\", \n    &GUI_MapTileSelector::Close, this); \n\n  m_guiManager->LoadInterface(\"MapEditorTileSelect.interface\", \n    \"MapEditorTileSelect\"); \n  m_interface = m_guiManager->GetInterface(\"MapEditorTileSelect\"); \n  m_interface->SetContentRectSize( \n    sf::Vector2i(m_interface->GetSize()-sf::Vector2f(32.f,32.f))); \n  m_interface->SetContentOffset({ 16.f, 16.f }); \n  m_interface->PositionCenterScreen(); \n  m_interface->SetActive(false); \n\n  m_shape.setFillColor({ 0, 0, 150, 150 }); \n  m_shape.setSize({ Sheet::Tile_Size, Sheet::Tile_Size }); \n  m_shape.setPosition(0.f, 0.f); \n} \n\n```", "```cpp\nGUI_MapTileSelector::~GUI_MapTileSelector() { \n  ... // Callbacks and interface removal. \n  if (!m_sheetTexture.empty()) { \n    m_textureManager->ReleaseResource(m_sheetTexture); \n  } \n} \n\n```", "```cpp\nvoid GUI_MapTileSelector::SetSheetTexture( \n  const std::string& l_texture) \n{ \n  if (!m_sheetTexture.empty()) { \n    m_textureManager->ReleaseResource(m_sheetTexture); \n  } \n  m_sheetTexture = l_texture; \n  m_textureManager->RequireResource(m_sheetTexture);  \n  m_tileMapSprite.setTexture( \n    *m_textureManager->GetResource(m_sheetTexture)); \n  m_tileMapSprite.setPosition({ 0.f, 0.f }); \n  auto size = m_tileMapSprite.getTexture()->getSize(); \n  m_selectorTexture.create(size.x, size.y); \n  m_selectorTexture.clear({ 0,0,0,0 }); \n  m_selectorTexture.draw(m_tileMapSprite); \n  m_selectorTexture.display(); \n\n  auto element = static_cast<GUI_Sprite*>( \n    m_interface->GetElement(\"TileSprite\")); \n  element->SetTexture(m_selectorTexture); \n} \n\n```", "```cpp\nvoid GUI_MapTileSelector::UpdateInterface() { \n  m_selectorTexture.clear({ 0,0,0,0 }); \n  m_selectorTexture.draw(m_tileMapSprite); \n  m_selectorTexture.draw(m_shape); \n  m_selectorTexture.display(); \n\n  m_interface->RequestContentRedraw(); \n} \n\n```", "```cpp\nbool GUI_MapTileSelector::CopySelection(TileMap& l_tileMap) const{ \n  if (!m_selected) { return false; } \n  l_tileMap.Purge(); \n  auto TileCoordsStart = m_startCoords / \n    static_cast<unsigned int>(Sheet::Tile_Size); \n  auto TileCoordsEnd = m_endCoords / \n    static_cast<unsigned int>(Sheet::Tile_Size); \n  auto size = TileCoordsEnd - TileCoordsStart; \n  l_tileMap.SetMapSize(size + sf::Vector2u(1,1)); \n\n  auto sheetSize = m_textureManager->GetResource( \n    l_tileMap.GetTileSet().GetTextureName())->getSize(); \n  auto nPerRow = sheetSize.x / Sheet::Tile_Size; \n\n  auto t_x = 0, t_y = 0; \n  for (auto x = TileCoordsStart.x; x <= TileCoordsEnd.x; ++x) { \n    for (auto y = TileCoordsStart.y; y <= TileCoordsEnd.y; ++y) { \n      auto coordinate = (y * nPerRow) + x; \n      auto tile = l_tileMap.SetTile(t_x, t_y, 0, coordinate); \n      // Always layer 0\\. \n      if (!tile) { ++t_y; continue; } \n      tile->m_solid = false; \n      ++t_y; \n    } \n    t_y = 0; \n    ++t_x; \n  } \n  return true; \n} \n\n```", "```cpp\nvoid GUI_MapTileSelector::TileSelect(EventDetails* l_details) { \n  if (l_details->m_name == \"MapEditor_TileSelectClick\") { \n    m_startCoords = sf::Vector2u(l_details->m_mouse); \n    m_endCoords = sf::Vector2u(l_details->m_mouse); \n    m_selected = false; \n  } else { \n    if (l_details->m_mouse.x < 0 || l_details->m_mouse.y < 0) { \n      m_endCoords = sf::Vector2u(0, 0); \n      return; \n    } \n    m_endCoords = sf::Vector2u(l_details->m_mouse); \n    m_selected = true; \n  } \n\n  if (m_startCoords.x > m_endCoords.x) { \n    std::swap(m_startCoords.x, m_endCoords.x); \n  } \n  if (m_startCoords.y > m_endCoords.y) { \n    std::swap(m_startCoords.y, m_endCoords.y); \n  } \n\n  auto start = sf::Vector2i(m_startCoords.x / Sheet::Tile_Size, \n    m_startCoords.y / Sheet::Tile_Size); \n  start *= static_cast<int>(Sheet::Tile_Size); \n  auto end = sf::Vector2i(m_endCoords.x / Sheet::Tile_Size, \n    m_endCoords.y / Sheet::Tile_Size); \n  end *= static_cast<int>(Sheet::Tile_Size); \n\n  m_shape.setPosition(sf::Vector2f(start)); \n  m_shape.setSize(sf::Vector2f(end - start) + \n    sf::Vector2f(Sheet::Tile_Size, Sheet::Tile_Size)); \n  UpdateInterface(); \n} \n\n```", "```cpp\nvoid GUI_MapTileSelector::Close(EventDetails* l_details){ Hide();} \nvoid GUI_MapTileSelector::Show() { \n  m_interface->SetActive(true); \n  m_interface->Focus(); \n} \nvoid GUI_MapTileSelector::Hide() {m_interface->SetActive(false);} \nbool GUI_MapTileSelector::IsActive() const{ \n  return m_interface->IsActive(); \n} \n\n```"]