["```cpp\nGPIO_InitTypeDef GPIO_InitStruct = {0};\n//PC10 is UART4_TX PC11 is UART4_RX\nGPIO_InitStruct.Pin = GPIO_PIN_10 | GPIO_PIN_11;\nGPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\nGPIO_InitStruct.Pull = GPIO_NOPULL;\nGPIO_InitStruct.Alternate = GPIO_AF8_UART4;\nHAL_GPIO_Init(GPIOC, &GPIO_InitStruct);\n```", "```cpp\n__UART4_CLK_ENABLE();\n```", "```cpp\nHAL_StatusTypeDef retVal;\nUART_HandleTypeDef uartInitStruct;\nuartInitStruct.Instance = STM_UART_PERIPH;\nuartInitStruct.Init.BaudRate = Baudrate;\nuartInitStruct.Init.WordLength = UART_WORDLENGTH_8B;\nuartInitStruct.Init.StopBits = UART_STOPBITS_1;\nuartInitStruct.Init.Parity = UART_PARITY_NONE;\nuartInitStruct.Init.Mode = UART_MODE_TX_RX;\nuartInitStruct.Init.HwFlowCtl = UART_HWCONTROL_NONE;\nuartInitStruct.Init.OverSampling = UART_OVERSAMPLING_16;\nuartInitStruct.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;\nuartInitStruct.hdmatx = DmaTx;\nuartInitStruct.hdmarx = DmaRx;\nuartInitStruct.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;\nretVal = HAL_UART_Init(&uartInitStruct);\nassert_param(retVal == HAL_OK);\n```", "```cpp\nvoid polledUartReceive( void* NotUsed )\n{\n    uint8_t nextByte;\n    //setup UART\n    STM_UartInit(USART2, 9600, NULL, NULL);\n    while(1)\n    {\n        while(!(USART2->ISR & USART_ISR_RXNE_Msk)); nextByte = USART2->RDR; xQueueSend(uart2_BytesReceived, &nextByte, 0); }\n}\n```", "```cpp\nvoid uartPrintOutTask( void* NotUsed)\n{\n    char nextByte;    \n    while(1)\n    {\n        xQueueReceive(uart2_BytesReceived, &nextByte, portMAX_DELAY);\n        SEGGER_SYSVIEW_PrintfHost(\"%c\", nextByte);    \n    }\n}\n```", "```cpp\nvoid uartPrintOutTask( void* NotUsed)\n{\n  char nextByte;\n  STM_UartInit(USART2, 9600, NULL, NULL);\n  startReceiveInt();\n\n  while(1)\n  {\n    xQueueReceive(uart2_BytesReceived, &nextByte, portMAX_DELAY);\n    SEGGER_SYSVIEW_PrintfHost(\"%c\", nextByte);\n  }\n}\n```", "```cpp\nstatic bool rxInProgress = false;\n\nvoid startReceiveInt( void )\n{\n    rxInProgress = true;\n    USART2->CR3 |= USART_CR3_EIE; //enable error interrupts\n    //enable peripheral and Rx not empty interrupts\n    USART2->CR1 |= (USART_CR1_UE | USART_CR1_RXNEIE);  \n\n    NVIC_SetPriority(USART2_IRQn, 6);\n    NVIC_EnableIRQ(USART2_IRQn);\n}\n```", "```cpp\nvoid USART2_IRQHandler( void )\n{\n    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;\n    SEGGER_SYSVIEW_RecordEnterISR();\n\n    //error flag clearing omitted for brevity\n\n    if( USART2->ISR & USART_ISR_RXNE_Msk)\n    {\n        uint8_t tempVal = (uint8_t) USART2->RDR;\n\n        if(rxInProgress)\n        {\n            xQueueSendFromISR(uart2_BytesReceived, &tempVal, \n                              &xHigherPriorityTaskWoken);\n      }\n      SEGGER_SYSVIEW_RecordExitISR();\n      portYIELD_FROM_ISR(xHigherPriorityTaskWoken);\n}\n```", "```cpp\nstatic bool rxInProgress = false;\nstatic uint_fast16_t rxLen = 0;\nstatic uint8_t* rxBuff = NULL;\nstatic uint_fast16_t rxItr = 0;\n\nint32_t startReceiveInt( uint8_t* Buffer, uint_fast16_t Len )\n{\n    if(!rxInProgress && (Buffer != NULL))\n    {\n        rxInProgress = true;\n        rxLen = Len;\n        rxBuff = Buffer;\n        rxItr = 0;\n        USART2->CR3 |= USART_CR3_EIE; //enable error interrupts\n        USART2->CR1 |= (USART_CR1_UE | USART_CR1_RXNEIE);\n        NVIC_SetPriority(USART2_IRQn, 6);\n        NVIC_EnableIRQ(USART2_IRQn);\n        return 0;\n    }\n    return -1;\n}\n```", "```cpp\nvoid uartPrintOutTask( void* NotUsed)\n{\n  uint8_t rxData[20];\n  uint8_t expectedLen = 16;\n  memset((void*)rxData, 0, 20);\n\n  STM_UartInit(USART2, 9600, NULL, NULL);\n```", "```cpp\nwhile(1)\n{\n    startReceiveInt(rxData, expectedLen);\n    if(xSemaphoreTake(rxDone, 100) == pdPASS)\n    {\n        if(expectedLen == rxItr)\n        {\n            SEGGER_SYSVIEW_PrintfHost(\"received: \");\n            SEGGER_SYSVIEW_Print((char*)rxData);\n        }\n        else\n        {\n            SEGGER_SYSVIEW_PrintfHost(\"expected %i bytes received\" \n                                      \"%i\", expectedLen, rxItr);\n```", "```cpp\nstatic bool rxInProgress = false;\nstatic uint_fast16_t rxLen = 0;\nstatic uint8_t* rxBuff = NULL;\nstatic uint_fast16_t rxItr = 0;\n```", "```cpp\nvoid USART2_IRQHandler( void )\n{\n     portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;\n     SEGGER_SYSVIEW_RecordEnterISR();\n```", "```cpp\n\n if( USART2->ISR & ( USART_ISR_ORE_Msk |\n                     USART_ISR_NE_Msk |\n                     USART_ISR_FE_Msk |\n                     USART_ISR_PE_Msk ))\n{\n    USART2->ICR |= (USART_ICR_FECF |\n                    USART_ICR_PECF |\n                    USART_ICR_NCF |\n                    USART_ICR_ORECF);\n    if(rxInProgress)\n    {\n        rxInProgress = false;\n        xSemaphoreGiveFromISR(rxDone,\n        &xHigherPriorityTaskWoken);\n    }\n}\n```", "```cpp\nif( USART2->ISR & USART_ISR_RXNE_Msk)\n{\n    uint8_t tempVal = (uint8_t) USART2->RDR;\n    if(rxInProgress)\n    {\n        rxBuff[rxItr++] = tempVal;\n        if(rxItr >= rxLen)\n        {\n            rxInProgress = false;\n            xSemaphoreGiveFromISR(rxDone, &xHigherPriorityTaskWoken);\n        }\n    }\n}\nSEGGER_SYSVIEW_RecordExitISR();\nportYIELD_FROM_ISR(xHigherPriorityTaskWoken);\n```", "```cpp\nvoid setupUSART2DMA( void )\n{\n  __HAL_RCC_DMA1_CLK_ENABLE();\n\n  NVIC_SetPriority(DMA1_Stream5_IRQn, 6);\n  NVIC_EnableIRQ(DMA1_Stream5_IRQn);\n```", "```cpp\n  HAL_StatusTypeDef retVal;\n  memset(&usart2DmaRx, 0, sizeof(usart2DmaRx));\n  usart2DmaRx.Instance = DMA1_Stream5; //stream 5 is for USART2 Rx\n\n  //channel 4 is for USART2 Rx/Tx\n  usart2DmaRx.Init.Channel = DMA_CHANNEL_4;\n\n  //transfering out of memory and into the peripheral register\n  usart2DmaRx.Init.Direction = DMA_PERIPH_TO_MEMORY;\n  usart2DmaRx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; //no FIFO\n\n  //transfer 1 at a time\n  usart2DmaRx.Init.MemBurst = DMA_MBURST_SINGLE; \n  usart2DmaRx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\n\n  //increment 1 byte at a time\n  usart2DmaRx.Init.MemInc = DMA_MINC_ENABLE;\n\n  //flow control mode set to normal\n  usart2DmaRx.Init.Mode = DMA_NORMAL; \n\n  //write 1 at a time to the peripheral\n  usart2DmaRx.Init.PeriphBurst = DMA_PBURST_SINGLE; \n\n  //always keep the peripheral address the same (the RX data\n  //register is always in the same location)\n  usart2DmaRx.Init.PeriphInc = DMA_PINC_DISABLE;\n\n  usart2DmaRx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\n\n  usart2DmaRx.Init.Priority = DMA_PRIORITY_HIGH;\n  retVal = HAL_DMA_Init(&usart2DmaRx);\n  assert_param( retVal == HAL_OK );\n\n  //enable transfer complete interrupts\n  DMA1_Stream5->CR |= DMA_SxCR_TCIE; \n\n  //set the DMA receive mode flag in the USART\n  USART2->CR3 |= USART_CR3_DMAR_Msk;\n```", "```cpp\nvoid DMA1_Stream5_IRQHandler(void)\n{\n  portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;\n  SEGGER_SYSVIEW_RecordEnterISR();\n\n  if(rxInProgress && (DMA1->HISR & DMA_HISR_TCIF5))\n {\n rxInProgress = false;\n DMA1->HIFCR |= DMA_HIFCR_CTCIF5;\n xSemaphoreGiveFromISR(rxDone, &xHigherPriorityTaskWoken);\n }\n  SEGGER_SYSVIEW_RecordExitISR();\n  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);\n}\n```", "```cpp\nStreamBufferHandle_t xStreamBufferCreate( size_t xBufferSizeBytes,\n                                          size_t xTriggerLevelBytes);\n```", "```cpp\n#define NUM_BYTES 100\n#define MIN_NUM_BYTES 2\nStreamBufferHandle_t rxStream = NULL;\nrxStream = xStreamBufferCreate( NUM_BYTES , MIN_NUM_BYTES);\nassert_param(rxStream != NULL);\n```", "```cpp\nsize_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,\n                             void *pvRxData,\n                             size_t xBufferLengthBytes,\n                             TickType_t xTicksToWait );\n```", "```cpp\nvoid uartPrintOutTask( void* NotUsed)\n{\n    static const uint8_t maxBytesReceived = 16;\n    uint8_t rxBufferedData[maxBytesReceived];\n\n    //initialization code omitted for brevity\n    while(1)\n    {\n        uint8_t numBytes = xStreamBufferReceive(  rxStream,\n rxBufferedData,\n maxBytesReceived,\n 100 );\n        if(numBytes > 0)\n        {\n          SEGGER_SYSVIEW_PrintfHost(\"received: \");\n          SEGGER_SYSVIEW_Print((char*)rxBufferedData);\n        }\n        else\n        {\n          SEGGER_SYSVIEW_PrintfHost(\"timeout\");\n ...\n```", "```cpp\n//setup second address for double buffered mode\nDMA1_Stream5->M1AR = (uint32_t) rxData2;\n```", "```cpp\n//NOTE: HAL_DMA_Start explicitly disables double buffer mode\n// so we'll explicitly enable double buffer mode later when\n// the actual transfer is started\nif(HAL_DMA_Start(&usart2DmaRx, (uint32_t)&(USART2->RDR), (uint32_t)rxData1,\n                 RX_BUFF_LEN) != HAL_OK)\n{\n    return -1;\n}\n\n//disable the stream and controller so we can setup dual buffers\n__HAL_DMA_DISABLE(&usart2DmaRx);\n//set the double buffer mode\nDMA1_Stream5->CR |= DMA_SxCR_DBM;\n//re-enable the stream and controller\n__HAL_DMA_ENABLE(&usart2DmaRx);\nDMA1_Stream5->CR |= DMA_SxCR_EN;\n```", "```cpp\nvoid DMA1_Stream5_IRQHandler(void)\n{\n    uint16_t numWritten = 0;\n    uint8_t* currBuffPtr = NULL;\n    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;\n    SEGGER_SYSVIEW_RecordEnterISR();\n\n    if(rxInProgress && (DMA1->HISR & DMA_HISR_TCIF5))\n    {\n        if(DMA1_Stream5->CR & DMA_SxCR_CT)\n            currBuffPtr = rxData1;\n        else\n            currBuffPtr = rxData2;\n\n        numWritten = xStreamBufferSendFromISR(  rxStream,\n                                                currBuffPtr,\n                                                RX_BUFF_LEN,\n                                                &xHigherPriorityTaskWoken);\n        while(numWritten != RX_BUFF_LEN);\n\n        DMA1->HIFCR |= DMA_HIFCR_CTCIF5;\n    }\n    SEGGER_SYSVIEW_RecordExitISR();\n    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);\n}\n```", "```cpp\n while(1)\n {\n     xQueueReceive(uart2_BytesReceived, &nextByte, portMAX_DELAY);\n    //do something with the byte received\n     SEGGER_SYSVIEW_PrintfHost(\"%c\", nextByte);\n }\n```", "```cpp\ntypedef struct\n{\n    uint8_t redLEDState : 1;     \n    uint8_t blueLEDState : 1;\n    uint8_t greenLEDState : 1;\n    uint32_t msDelayTime;\n}LedStates_t;\n```", "```cpp\nLedStates_t nextCmd;\nwhile(1)\n{\n    if(xQueueReceive(ledCmdQueue, &nextCmd, portMAX_DELAY) == pdTRUE)\n    {\n        if(nextCmd.redLEDState == 1)\n            RedLed.On();\n        else\n             . . .\n```", "```cpp\nuint8_t ledCmdBuff[5];\nstartReceiveInt(ledCmdBuff, 5);\n//wait for reception to complete\nxSemaphoreTake(cmdReceived, portMAX_DELAY);\n//populate an led command with data received from the serial port\nLedStates_t ledCmd = parseMsg(ledCmdBuff);\n//send the command to the queue\nxQueueSend(ledCmdQueue, &ledCmd, portMAX_DELAY);\n```"]