<html><head></head><body>
<div id="_idContainer049">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 class="chapterTitle" id="_idParaDest-92"><span class="koboSpan" id="kobo.2.1">Beyond Classes – Fundamental C++ Concepts</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Historically, C++ started as C with classes, making classes one of the first concepts for developers with a C background to learn. </span><span class="koboSpan" id="kobo.3.2">In the previous chapter, we covered classes in detail, and before proceeding with more advanced concepts, we will cover other fundamental C++ concepts that make it so much more than C with classes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">Before we move on to more advanced topics, it’s important to explore other fundamental concepts that make C++ distinct. </span><span class="koboSpan" id="kobo.4.2">In this chapter, we’re going to cover the following main topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5.1">Namespaces</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Function overloading</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Interoperability with C</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">References</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Standard library containers and algorithms</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-93"><span class="koboSpan" id="kobo.10.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.11.1">To get the most out of this chapter, I strongly recommend using Compiler Explorer (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.12.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.13.1">) as you read through the examples. </span><span class="koboSpan" id="kobo.13.2">Select GCC as your compiler and target x86 architecture. </span><span class="koboSpan" id="kobo.13.3">This will allow you to see standard output (stdio) results and better observe the code’s behavior. </span><span class="koboSpan" id="kobo.13.4">As we are using modern C++ features make sure to select C++23 standard, by adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.14.1">-std=c++23</span></code><span class="koboSpan" id="kobo.15.1"> in compiler options box.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.16.1">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly. </span><span class="koboSpan" id="kobo.16.2">The examples are available at GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter06"><span class="url"><span class="koboSpan" id="kobo.17.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter06</span></span></a><span class="koboSpan" id="kobo.18.1">).</span></p>
<h1 class="heading-1" id="_idParaDest-94"><span class="koboSpan" id="kobo.19.1">Namespaces</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.20.1">Namespaces</span></strong><span class="koboSpan" id="kobo.21.1"> in C++ are</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.22.1"> used as scope specifiers for accessing type names, functions, variables, and so on. </span><span class="koboSpan" id="kobo.22.2">They allow us to more easily differentiate types and function names in large code bases that use many software components and where there are often similar identifiers. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.23.1">In C, we usually add a prefix to types and functions to make it easier to differentiate, for example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.24.1">typedef</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.25.1">struct</span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.26.1">hal_uart_stm32</span></span><span class="hljs-class"><span class="koboSpan" id="kobo.27.1">{</span></span><span class="koboSpan" id="kobo.28.1">
    UART_HandleTypeDef huart_;
    USART_TypeDef *instance_; 
} hal_uart_stm32;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.29.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.30.1">hal_init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.31.1">()</span></span><span class="koboSpan" id="kobo.32.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.33.1">uint32_t</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.34.1">hal_get_ms</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.35.1">()</span></span><span class="koboSpan" id="kobo.36.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.37.1">In C++, we can use namespaces instead of C-style identifier prefixes to organize code in logical groups, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.38.1">namespace</span></span><span class="koboSpan" id="kobo.39.1"> hal {
</span><span class="hljs-type"><span class="koboSpan" id="kobo.40.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.41.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.42.1">()</span></span><span class="koboSpan" id="kobo.43.1">;
std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.44.1">uint32_t</span></span><span class="koboSpan" id="kobo.45.1"> tick_count;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.46.1">std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.47.1">uint32_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.48.1">get_ms</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.49.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.50.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.51.1">return</span></span><span class="koboSpan" id="kobo.52.1"> tick_count;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.53.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.54.1">uart_stm32</span></span><span class="koboSpan" id="kobo.55.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.56.1">private</span></span><span class="koboSpan" id="kobo.57.1">:
    UART_HandleTypeDef huart_;
    USART_TypeDef *instance_; 
};
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.58.1">All members of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">hal</span></code><span class="koboSpan" id="kobo.60.1"> namespace are accessible unqualified from within the namespace. </span><span class="koboSpan" id="kobo.60.2">To access identifiers from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">hal</span></code><span class="koboSpan" id="kobo.62.1"> namespace, in code outside of it, we use the namespace as a qualifier followed by scope resolution operator (</span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">::</span></code><span class="koboSpan" id="kobo.64.1">), as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.65.1">hal::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.66.1">init</span></span><span class="koboSpan" id="kobo.67.1">();
std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.68.1">uint32_t</span></span><span class="koboSpan" id="kobo.69.1"> time_now = hal::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.70.1">get_ms</span></span><span class="koboSpan" id="kobo.71.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.72.1">In this example, beside</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.73.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">hal</span></code><span class="koboSpan" id="kobo.75.1"> namespace, we also see the </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">std</span></code><span class="koboSpan" id="kobo.77.1"> namespace, which we used in previous examples. </span><span class="koboSpan" id="kobo.77.2">C++ standard library types and functions are declared in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.78.1">std</span></code><span class="koboSpan" id="kobo.79.1"> namespace.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.80.1">We can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.81.1">using</span></code><span class="koboSpan" id="kobo.82.1"> directive to access an identifier without qualifiers, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.83.1">using</span></span><span class="koboSpan" id="kobo.84.1"> std::array;
array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.85.1">int</span></span><span class="koboSpan" id="kobo.86.1">, 4&gt; arr;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.87.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">using</span></code><span class="koboSpan" id="kobo.89.1"> directive can also be used for the entire namespace, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.90.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.91.1">namespace</span></span><span class="koboSpan" id="kobo.92.1"> std;
array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.93.1">int</span></span><span class="koboSpan" id="kobo.94.1">, 4&gt; arr;
vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.95.1">int</span></span><span class="koboSpan" id="kobo.96.1">&gt; vec;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.97.1">It is recommended to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">using</span></code><span class="koboSpan" id="kobo.99.1"> directive sparingly, especially with </span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">std</span></code><span class="koboSpan" id="kobo.101.1">, using it for a limited scope, or even better, to bring in individual identifiers only.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.102.1">The same namespace can be used across different header files to declare identifiers. </span><span class="koboSpan" id="kobo.102.2">For example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">std::vector</span></code><span class="koboSpan" id="kobo.104.1"> is declared in </span><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">vector.h</span></code><span class="koboSpan" id="kobo.106.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.107.1">std::array</span></code><span class="koboSpan" id="kobo.108.1"> is declared in </span><code class="inlineCode"><span class="koboSpan" id="kobo.109.1">array.h</span></code><span class="koboSpan" id="kobo.110.1"> header files. </span><span class="koboSpan" id="kobo.110.2">This allows us to organize code from different headers that logically belong to the same group in a namespace.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.111.1">Functions and types that are not declared within an explicit namespace are part of a global namespace. </span><span class="koboSpan" id="kobo.111.2">It is a good practice to organize all code in namespaces. </span><span class="koboSpan" id="kobo.111.3">The only function that can’t be declared within a namespace and must be in a global namespace is </span><code class="inlineCode"><span class="koboSpan" id="kobo.112.1">main</span></code><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">To access the identifier from the global namespace, we use the scope resolution operator, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.114.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.115.1">int</span></span><span class="koboSpan" id="kobo.116.1"> ret_val = </span><span class="hljs-number"><span class="koboSpan" id="kobo.117.1">0</span></span><span class="koboSpan" id="kobo.118.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.119.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.120.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.121.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.122.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.123.1">return</span></span><span class="koboSpan" id="kobo.124.1"> ::ret_val;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.125.1">The line </span><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">return ::ret_val;</span></code><span class="koboSpan" id="kobo.127.1"> uses the scope resolution operator, </span><code class="inlineCode"><span class="koboSpan" id="kobo.128.1">::</span></code><span class="koboSpan" id="kobo.129.1">, without specifying a namespace. </span><span class="koboSpan" id="kobo.129.2">This</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.130.1"> means it refers to the global namespace. </span><span class="koboSpan" id="kobo.130.2">So, </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">::ret_val</span></code><span class="koboSpan" id="kobo.132.1"> accesses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.133.1">ret_val</span></code><span class="koboSpan" id="kobo.134.1"> variable defined outside of any function or class—that is, at the global scope.</span></p>
<h2 class="heading-2" id="_idParaDest-95"><span class="koboSpan" id="kobo.135.1">Unnamed namespaces</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.136.1">A namespace can be</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.137.1"> declared without the name qualifier. </span><span class="koboSpan" id="kobo.137.2">This allows us to declare functions and types that are local to the translation unit they are declared in. </span><span class="koboSpan" id="kobo.137.3">In the following example, we can see an example of an unnamed namespace:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.138.1">namespace</span></span><span class="koboSpan" id="kobo.139.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.140.1">constexpr</span></span><span class="koboSpan" id="kobo.141.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.142.1">size_t</span></span><span class="koboSpan" id="kobo.143.1"> c_max_retries;
std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.144.1">size_t</span></span><span class="koboSpan" id="kobo.145.1"> counter;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.146.1">In the code, we have an unnamed namespace with a few variables declared in it. </span><span class="koboSpan" id="kobo.146.2">They have </span><strong class="keyWord"><span class="koboSpan" id="kobo.147.1">internal linkage</span></strong><span class="koboSpan" id="kobo.148.1">, meaning </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.149.1">they cannot be accessed by code from other translation units. </span><span class="koboSpan" id="kobo.149.2">We can achieve the same </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.150.1">effect both in C and C++ by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.151.1">static</span></code><span class="koboSpan" id="kobo.152.1"> storage specifier.</span></p>
<h2 class="heading-2" id="_idParaDest-96"><span class="koboSpan" id="kobo.153.1">Nested namespaces</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.154.1">Namespaces can also </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.155.1">be nested. </span><span class="koboSpan" id="kobo.155.2">We can have a namespace within a namespace, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.156.1">namespace</span></span><span class="koboSpan" id="kobo.157.1"> sensors {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.158.1">namespace</span></span><span class="koboSpan" id="kobo.159.1"> environmental {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.160.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.161.1">temperature</span></span><span class="koboSpan" id="kobo.162.1"> {
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.163.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.164.1">humidity</span></span><span class="koboSpan" id="kobo.165.1"> {
};
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.166.1">namespace</span></span><span class="koboSpan" id="kobo.167.1"> indoor_air_quality{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.168.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.169.1">c02</span></span><span class="koboSpan" id="kobo.170.1">{
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.171.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.172.1">pm2_5</span></span><span class="koboSpan" id="kobo.173.1">{
};
};
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.174.1">In this example, we have organized sensors in namespaces. </span><span class="koboSpan" id="kobo.174.2">We have a top-level namespace, </span><code class="inlineCode"><span class="koboSpan" id="kobo.175.1">sensors</span></code><span class="koboSpan" id="kobo.176.1">, which has two namespaces: </span><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">environmental</span></code><span class="koboSpan" id="kobo.178.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.179.1">indoor_air_quality</span></code><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">C++17 standard allows us to write namespaces, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.181.1">namespace</span></span><span class="koboSpan" id="kobo.182.1"> sensors::environmental {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.183.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.184.1">temperature</span></span><span class="koboSpan" id="kobo.185.1"> {
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.186.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.187.1">humidity</span></span><span class="koboSpan" id="kobo.188.1"> {
};
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.189.1">Namespaces are a good way to make the code more readable, as they allow us to keep identifiers </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.190.1">short, without C-style prefixes.</span></p>
<h1 class="heading-1" id="_idParaDest-97"><span class="koboSpan" id="kobo.191.1">Function overloading</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.192.1">In the previous chapter, when </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.193.1">we discussed inheritance, we </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.194.1">mentioned </span><strong class="keyWord"><span class="koboSpan" id="kobo.195.1">static binding</span></strong><span class="koboSpan" id="kobo.196.1">. </span><span class="koboSpan" id="kobo.196.2">We saw that we can have the same function names for functions that belong to different classes. </span><span class="koboSpan" id="kobo.196.3">However, we can also have the same function names for different function parameters, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.197.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.198.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.199.1">&lt;cstdio&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.200.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.201.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.202.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.203.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.204.1"> a)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.205.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.206.1">printf</span></span><span class="koboSpan" id="kobo.207.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.208.1">"Int %d\r\n"</span></span><span class="koboSpan" id="kobo.209.1">, a);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.210.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.211.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.212.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.213.1">float</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.214.1"> a)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.215.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.216.1">printf</span></span><span class="koboSpan" id="kobo.217.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.218.1">"Float %2.f\r\n"</span></span><span class="koboSpan" id="kobo.219.1">, a);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.220.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.221.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.222.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.223.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.224.1">print</span></span><span class="koboSpan" id="kobo.225.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.226.1">2</span></span><span class="koboSpan" id="kobo.227.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.228.1">print</span></span><span class="koboSpan" id="kobo.229.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.230.1">2.f</span></span><span class="koboSpan" id="kobo.231.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.232.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.233.1">0</span></span><span class="koboSpan" id="kobo.234.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.235.1">In this example, we have two </span><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">print</span></code><span class="koboSpan" id="kobo.237.1"> functions. </span><span class="koboSpan" id="kobo.237.2">One of them has an </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">int</span></code><span class="koboSpan" id="kobo.239.1"> as a parameter and the second one has a </span><code class="inlineCode"><span class="koboSpan" id="kobo.240.1">float</span></code><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">On the call site, the compiler will pick a </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">print</span></code><span class="koboSpan" id="kobo.243.1"> function based on the arguments passed to the function call.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.244.1">Functions with the same names within the same scope are called </span><strong class="keyWord"><span class="koboSpan" id="kobo.245.1">overloaded functions</span></strong><span class="koboSpan" id="kobo.246.1">. </span><span class="koboSpan" id="kobo.246.2">Instead of having two different names, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">print_int</span></code><span class="koboSpan" id="kobo.248.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">print_float</span></code><span class="koboSpan" id="kobo.250.1">, we can use the same name for both these functions and let the compiler decide which function to call.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.251.1">To distinguish between the two overloaded </span><code class="inlineCode"><span class="koboSpan" id="kobo.252.1">print</span></code><span class="koboSpan" id="kobo.253.1"> functions – one accepting an </span><code class="inlineCode"><span class="koboSpan" id="kobo.254.1">int</span></code><span class="koboSpan" id="kobo.255.1"> parameter and the other a </span><code class="inlineCode"><span class="koboSpan" id="kobo.256.1">float</span></code><span class="koboSpan" id="kobo.257.1"> – the compiler employs a technique </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.258.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.259.1">name mangling</span></strong><span class="koboSpan" id="kobo.260.1">. </span><span class="koboSpan" id="kobo.260.2">Name mangling modifies function names by encoding additional information, such as parameter types, into them. </span><span class="koboSpan" id="kobo.260.3">This ensures that each overloaded function has a unique symbol in the compiled code. </span><span class="koboSpan" id="kobo.260.4">If we examine the assembly output of the previous example, we can observe these mangled names:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-symbol"><span class="koboSpan" id="kobo.261.1">_Z5printi:</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.262.1">mov</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.263.1">r1</span></span><span class="koboSpan" id="kobo.264.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.265.1">r0</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.266.1">ldr</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.267.1">r0</span></span><span class="koboSpan" id="kobo.268.1">, .L2
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.269.1">b</span></span><span class="koboSpan" id="kobo.270.1">       printf
</span><span class="hljs-symbol"><span class="koboSpan" id="kobo.271.1">_Z5printf:</span></span><span class="koboSpan" id="kobo.272.1">
        vcvt.f64.f32    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.273.1">d16</span></span><span class="koboSpan" id="kobo.274.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.275.1">s0</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.276.1">ldr</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.277.1">r0</span></span><span class="koboSpan" id="kobo.278.1">, .L5
        vmov    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.279.1">r2</span></span><span class="koboSpan" id="kobo.280.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.281.1">r3</span></span><span class="koboSpan" id="kobo.282.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.283.1">d16</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.284.1">b</span></span><span class="koboSpan" id="kobo.285.1">       printf
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.286.1">We see that the compiler assigned </span><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">_Z5printi</span></code><span class="koboSpan" id="kobo.288.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.289.1">_Z5printf</span></code><span class="koboSpan" id="kobo.290.1"> labels to </span><code class="inlineCode"><span class="koboSpan" id="kobo.291.1">print</span></code><span class="koboSpan" id="kobo.292.1"> functions with </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">int</span></code><span class="koboSpan" id="kobo.294.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">float</span></code><span class="koboSpan" id="kobo.296.1"> parameters respectively. </span><span class="koboSpan" id="kobo.296.2">This allows it to dispatch function calls according to argument matching.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.297.1">Overloaded functions</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.298.1"> can have a different number of arguments. </span><span class="koboSpan" id="kobo.298.2">Return types cannot be used for function overloading. </span><span class="koboSpan" id="kobo.298.3">Two functions with the same name and same arguments cannot have different return types. </span><span class="koboSpan" id="kobo.298.4">The following code would result in a compile error:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.299.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.300.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.301.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.302.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.303.1"> a)</span></span><span class="koboSpan" id="kobo.304.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.305.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.306.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.307.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.308.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.309.1"> a)</span></span><span class="koboSpan" id="kobo.310.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.311.1">This code would be treated by the compiler as a function redeclaration and would result in an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.312.1">Function overloading</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.313.1"> is a basic but powerful feature of C++ that provides a mechanism for compile-time or static polymorphism.</span></p>
<h1 class="heading-1" id="_idParaDest-98"><span class="koboSpan" id="kobo.314.1">Interoperability with C</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.315.1">Code examples from </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.316.1">previous chapters that you were able to run in a Renode simulator are using both C++ and C code. </span><span class="koboSpan" id="kobo.316.2">We used vendor provided HAL library and </span><strong class="keyWord"><span class="koboSpan" id="kobo.317.1">Common Microcontroller Software Interface Standard</span></strong><span class="koboSpan" id="kobo.318.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.319.1">CMSIS</span></strong><span class="koboSpan" id="kobo.320.1">) by Arm, both written in C and contained</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.321.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.322.1">platform</span></code><span class="koboSpan" id="kobo.323.1"> folder.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.324.1">If you take a look at the </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">CMakeLists.txt</span></code><span class="koboSpan" id="kobo.326.1"> file and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">add_executable</span></code><span class="koboSpan" id="kobo.328.1"> function in it, you will see listed C files from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">platform</span></code><span class="koboSpan" id="kobo.330.1"> folder and just a few C++ files. </span><span class="koboSpan" id="kobo.330.2">Building a project will provide the following console output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.331.1">[  7%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal.c.o
[ 15%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_cortex.c.o
[ 23%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_gpio.c.o
[ 30%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_rcc.c.o
[ 38%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_uart.c.o
[ 46%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_uart_ex.c.o
[ 53%] Building ASM object CMakeFiles/bare.elf.dir/platform/startup_stm32f072xb.s.o
[ 61%] Building C object CMakeFiles/bare.elf.dir/platform/src/stm32f0xx_hal_msp.c.o
[ 69%] Building C object CMakeFiles/bare.elf.dir/platform/src/stm32f0xx_it.c.o
[ 76%] Building C object CMakeFiles/bare.elf.dir/platform/src/system_stm32f0xx.c.o
[ 84%] Building CXX object CMakeFiles/bare.elf.dir/app/src/main.cpp.o
[ 92%] Building CXX object CMakeFiles/bare.elf.dir/hal/uart/src/uart_stm32.cpp.o
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.332.1">[100%</span></span><span class="language-bash"><span class="koboSpan" id="kobo.333.1">] Linking CXX executable bare.elf</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.334.1">Every C and C++ file is treated as a translation unit and built separately by C and C++ compilers respectively. </span><span class="koboSpan" id="kobo.334.2">After</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.335.1"> compilation, both C and C++ object files are linked into a single ELF file.</span></p>
<h2 class="heading-2" id="_idParaDest-99"><span class="koboSpan" id="kobo.336.1">External and Language Linkage in C++</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.337.1">Variables and functions</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.338.1"> that</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.339.1"> can be referred to from other translation units</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.340.1"> have </span><strong class="keyWord"><span class="koboSpan" id="kobo.341.1">external linkage</span></strong><span class="koboSpan" id="kobo.342.1">. </span><span class="koboSpan" id="kobo.342.2">This allows them to be linked with code in other files provided that the compiler has access to declarations. </span><span class="koboSpan" id="kobo.342.3">They also have a property called </span><strong class="keyWord"><span class="koboSpan" id="kobo.343.1">language linkage</span></strong><span class="koboSpan" id="kobo.344.1">. </span><span class="koboSpan" id="kobo.344.2">This </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.345.1">property allows linking C++ with C code. </span><span class="koboSpan" id="kobo.345.2">C language linkage in C++ is declared using the following syntax:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.346.1">extern</span></span><span class="koboSpan" id="kobo.347.1"> "C" {
</span><span class="hljs-type"><span class="koboSpan" id="kobo.348.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.349.1">c_func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.350.1">()</span></span><span class="koboSpan" id="kobo.351.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.352.1">Declaration with C language linkage will be linked according to C language linkage conventions, preventing name mangling (among other things) to ensure proper linking with code compiled within a C translation unit.</span></p>
<h2 class="heading-2" id="_idParaDest-100"><span class="koboSpan" id="kobo.353.1">C standard library in C++</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.354.1">C++ wraps the C standard </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.355.1">library and provides header files with the same name</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.356.1"> as the C language version but with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.357.1">c</span></code><span class="koboSpan" id="kobo.358.1"> prefix and no extension. </span><span class="koboSpan" id="kobo.358.2">For example, the C++ equivalent for the C language header file </span><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">&lt;stdlib.h&gt;</span></code><span class="koboSpan" id="kobo.360.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">&lt;cstdlib&gt;</span></code><span class="koboSpan" id="kobo.362.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.363.1">In GCC, implementation C++ wrappers include C standard library headers; for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">&lt;cstdio&gt;</span></code><span class="koboSpan" id="kobo.365.1"> includes </span><code class="inlineCode"><span class="koboSpan" id="kobo.366.1">&lt;stdio.h&gt;</span></code><span class="koboSpan" id="kobo.367.1">. </span><span class="koboSpan" id="kobo.367.2">If you dive into </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">&lt;stdio.h&gt;</span></code><span class="koboSpan" id="kobo.369.1">, you can see that it guards function declarations with </span><code class="inlineCode"><span class="koboSpan" id="kobo.370.1">__BEGIN_DECLS</span></code><span class="koboSpan" id="kobo.371.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.372.1">__END_DECLS</span></code><span class="koboSpan" id="kobo.373.1"> macros. </span><span class="koboSpan" id="kobo.373.2">Here’s the definition of these macros:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.374.1">/* C++ needs to know that types and declarations are C, not C++.  </span><span class="koboSpan" id="kobo.374.2">*/</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.375.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.376.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.377.1">    __cplusplus</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.378.1"># </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.379.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.380.1"> __BEGIN_DECLS    extern </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.381.1">"C"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.382.1"> {</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.383.1"># </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.384.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.385.1"> __END_DECLS    }</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.386.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.387.1">else</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.388.1"># </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.389.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.390.1"> __BEGIN_DECLS</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.391.1"># </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.392.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.393.1"> __END_DECLS</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.394.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.395.1">endif</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.396.1">Here, we can see </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.397.1">that </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.398.1">standard C library headers take care of C++ compatibility by adding a language linkage specifier if a C++ compiler is used. </span><span class="koboSpan" id="kobo.398.2">This practice is also used in many HAL implementations provided by microcontroller vendors. </span><span class="koboSpan" id="kobo.398.3">If you open any C header file in </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">platform/STM32F0xx_HAL_Driver/Inc</span></code><span class="koboSpan" id="kobo.400.1">, you will see that declarations are guarded with a C language linkage specifier when they are accessed by the C++ compiler, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.401.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.402.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.403.1"> __cplusplus</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.404.1">extern</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.405.1">"C"</span></span><span class="koboSpan" id="kobo.406.1"> {
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.407.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.408.1">endif</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.409.1">// Declarations</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.410.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.411.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.412.1"> __cplusplus</span></span><span class="koboSpan" id="kobo.413.1">
}
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.414.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.415.1">endif</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.416.1">C libraries are often used by C++ programs, especially in the embedded domain, so it is always a good idea to guard them with a language linkage specifier. </span><span class="koboSpan" id="kobo.416.2">If we are using a C library in a C++ program in which headers are not guarded internally, we can guard the headers at the </span><code class="inlineCode"><span class="koboSpan" id="kobo.417.1">include</span></code><span class="koboSpan" id="kobo.418.1"> site, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.419.1">extern</span></span><span class="koboSpan" id="kobo.420.1"> "C" {
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.421.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.422.1">include</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.423.1"> "c_library.h"</span></span><span class="koboSpan" id="kobo.424.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.425.1">The language </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.426.1">linkage </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.427.1">specifier for C language ensures proper linking of C++ code that is using C code, which is often a case in embedded projects.</span></p>
<h1 class="heading-1" id="_idParaDest-101"><span class="koboSpan" id="kobo.428.1">References</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.429.1">In the previous chapter, we briefly mentioned references without explaining them in detail. </span><span class="koboSpan" id="kobo.429.2">References are </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.430.1">object aliases; that is, they refer to objects and as such they must be immediately initialized. </span><span class="koboSpan" id="kobo.430.2">They are not objects, so there are no pointers to references or arrays of references.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.431.1">There are two different types of references in C++: </span><strong class="keyWord"><span class="koboSpan" id="kobo.432.1">lvalue</span></strong><span class="koboSpan" id="kobo.433.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.434.1">rvalue</span></strong><span class="koboSpan" id="kobo.435.1"> references.</span></p>
<h2 class="heading-2" id="_idParaDest-102"><span class="koboSpan" id="kobo.436.1">Value categories</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.437.1">C++ expressions have</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.438.1"> either lvalue or rvalue value categories. </span><span class="koboSpan" id="kobo.438.2">There </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.439.1">is a more detailed division of value categories, but we will stay with this simple one which has a historical origin.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.440.1">Lvalues</span></strong><span class="koboSpan" id="kobo.441.1"> usually appear on the left side of the assignment expression, but this is not always the case. </span><span class="koboSpan" id="kobo.441.2">Lvalues have an address that the program can access. </span><span class="koboSpan" id="kobo.441.3">Here are some examples of lvalues:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.442.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.443.1">bar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.444.1">()</span></span><span class="koboSpan" id="kobo.445.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.446.1">int</span></span><span class="koboSpan" id="kobo.447.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.448.1">42</span></span><span class="koboSpan" id="kobo.449.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.450.1">// a is lvalue</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.451.1">int</span></span><span class="koboSpan" id="kobo.452.1"> b = a; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.453.1">// a can also appear on the right side</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.454.1">int</span></span><span class="koboSpan" id="kobo.455.1"> * p = &amp;a; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.456.1">// pointer p is lvalue</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.457.1">void</span></span><span class="koboSpan" id="kobo.458.1">(*bar_ptr)() = bar; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.459.1">// func pointer bar_ptr is lvalue</span></span>
</code></pre>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.460.1">Rvalues</span></strong><span class="koboSpan" id="kobo.461.1"> usually appear on the right side of the assignment expression. </span><span class="koboSpan" id="kobo.461.2">Examples are literals, function calls that do not return references, and built-in operator calls. </span><span class="koboSpan" id="kobo.461.3">We can think of them as temporary values. </span><span class="koboSpan" id="kobo.461.4">Some rvalues are shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.462.1">int</span></span><span class="koboSpan" id="kobo.463.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.464.1">42</span></span><span class="koboSpan" id="kobo.465.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.466.1">// 42 is rvalue</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.467.1">int</span></span><span class="koboSpan" id="kobo.468.1"> b = a + </span><span class="hljs-number"><span class="koboSpan" id="kobo.469.1">16</span></span><span class="koboSpan" id="kobo.470.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.471.1">// a + 16 is rvalue</span></span><span class="koboSpan" id="kobo.472.1">
std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.473.1">size_t</span></span><span class="koboSpan" id="kobo.474.1"> size = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.475.1">sizeof</span></span><span class="koboSpan" id="kobo.476.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.477.1">int</span></span><span class="koboSpan" id="kobo.478.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.479.1">// sizeof(int) is rvalue</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.480.1">Here is another, full example to help you better understand rvalues:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.481.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.482.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.483.1">&lt;cstdio&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.484.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.485.1">my_struct</span></span><span class="koboSpan" id="kobo.486.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.487.1">int</span></span><span class="koboSpan" id="kobo.488.1"> a_;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.489.1">my_struct</span></span><span class="koboSpan" id="kobo.490.1">() : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.491.1">a_</span></span><span class="koboSpan" id="kobo.492.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.493.1">0</span></span><span class="koboSpan" id="kobo.494.1">) {}
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.495.1">my_struct</span></span><span class="koboSpan" id="kobo.496.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.497.1">int</span></span><span class="koboSpan" id="kobo.498.1"> a) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.499.1">a_</span></span><span class="koboSpan" id="kobo.500.1">(a) {}
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.501.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.502.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.503.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.504.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.505.1">printf</span></span><span class="koboSpan" id="kobo.506.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.507.1">"a_ = %d\r\n"</span></span><span class="koboSpan" id="kobo.508.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.509.1">my_struct</span></span><span class="koboSpan" id="kobo.510.1">().a_);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.511.1">printf</span></span><span class="koboSpan" id="kobo.512.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.513.1">"a_ = %d\r\n"</span></span><span class="koboSpan" id="kobo.514.1">, (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.515.1">my_struct</span></span><span class="koboSpan" id="kobo.516.1">()=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.517.1">my_struct</span></span><span class="koboSpan" id="kobo.518.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.519.1">16</span></span><span class="koboSpan" id="kobo.520.1">)).a_);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.521.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.522.1">0</span></span><span class="koboSpan" id="kobo.523.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.524.1">In the preceding</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.525.1"> example, we can see the </span><code class="inlineCode"><span class="koboSpan" id="kobo.526.1">my_struct()</span></code><span class="koboSpan" id="kobo.527.1"> rvalue</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.528.1"> expression on the left side of the assignment operator. </span><span class="koboSpan" id="kobo.528.2">The output of the example is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.529.1">a_ = 0
a_ = 16
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.530.1">In the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">printf</span></code><span class="koboSpan" id="kobo.532.1"> call, we make a call to the constructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">my_struct</span></code><span class="koboSpan" id="kobo.534.1">, which returns a temporary object, and we access the </span><code class="inlineCode"><span class="koboSpan" id="kobo.535.1">a_</span></code><span class="koboSpan" id="kobo.536.1"> member. </span><span class="koboSpan" id="kobo.536.2">In the next line, we have the following expression: </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">my_struct()=my_struct(16)</span></code><span class="koboSpan" id="kobo.538.1">. </span><span class="koboSpan" id="kobo.538.2">On the left side of this expression, we have a call to the default constructor, which returns a temporary object. </span><span class="koboSpan" id="kobo.538.3">Then we assign the result of the call to a constructor that accepts </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">int</span></code><span class="koboSpan" id="kobo.540.1"> to a temporary object on the left side, which will copy one</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.541.1"> temporary </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.542.1">object to the other one.</span></p>
<h2 class="heading-2" id="_idParaDest-103"><span class="koboSpan" id="kobo.543.1">Lvalue references</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.544.1">Lvalue references</span></strong><span class="koboSpan" id="kobo.545.1"> are </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.546.1">used as </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.547.1">aliases for existing objects. </span><span class="koboSpan" id="kobo.547.2">They can also be const-qualified. </span><span class="koboSpan" id="kobo.547.3">We declare them by adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.548.1">&amp;</span></code><span class="koboSpan" id="kobo.549.1"> to type names. </span><span class="koboSpan" id="kobo.549.2">The following code demonstrates the usage of lvalue references:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.550.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.551.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.552.1">&lt;cstdio&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.553.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.554.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.555.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.556.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.557.1">int</span></span><span class="koboSpan" id="kobo.558.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.559.1">42</span></span><span class="koboSpan" id="kobo.560.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.561.1">int</span></span><span class="koboSpan" id="kobo.562.1">&amp; a_ref = a;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.563.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.564.1">int</span></span><span class="koboSpan" id="kobo.565.1">&amp; a_const_ref = a;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.566.1">printf</span></span><span class="koboSpan" id="kobo.567.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.568.1">"a = %d\r\n"</span></span><span class="koboSpan" id="kobo.569.1">, a);
    a_ref = </span><span class="hljs-number"><span class="koboSpan" id="kobo.570.1">16</span></span><span class="koboSpan" id="kobo.571.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.572.1">printf</span></span><span class="koboSpan" id="kobo.573.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.574.1">"a = %d\r\n"</span></span><span class="koboSpan" id="kobo.575.1">, a);
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.576.1">// a_const_ref = 16; compiler error</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.577.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.578.1">0</span></span><span class="koboSpan" id="kobo.579.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.580.1">As shown in the example, we can manipulate the object using the reference. </span><span class="koboSpan" id="kobo.580.2">In the case of a constant reference, any attempts to change the value will result in a compiler error.</span></p>
<h2 class="heading-2" id="_idParaDest-104"><span class="koboSpan" id="kobo.581.1">Rvalue references</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.582.1">Rvalue references</span></strong><span class="koboSpan" id="kobo.583.1"> are </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.584.1">used to extend the lifetime of temporary rvalues. </span><span class="koboSpan" id="kobo.584.2">We </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.585.1">declare them using </span><code class="inlineCode"><span class="koboSpan" id="kobo.586.1">&amp;&amp;</span></code><span class="koboSpan" id="kobo.587.1"> next to the type name. </span><span class="koboSpan" id="kobo.587.2">Here are example usages of rvalue references:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.588.1">int</span></span><span class="koboSpan" id="kobo.589.1">&amp;&amp; a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.590.1">42</span></span><span class="koboSpan" id="kobo.591.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.592.1">int</span></span><span class="koboSpan" id="kobo.593.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.594.1">0</span></span><span class="koboSpan" id="kobo.595.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.596.1">// int&amp;&amp; b_ref = b; compiler error</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.597.1">int</span></span><span class="koboSpan" id="kobo.598.1">&amp;&amp; b_ref = b + </span><span class="hljs-number"><span class="koboSpan" id="kobo.599.1">10</span></span><span class="koboSpan" id="kobo.600.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.601.1">// ok, b + 10 is rvalue</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.602.1">Rvalue references cannot be bound to lvalues. </span><span class="koboSpan" id="kobo.602.2">Attempting to do so will result in a compiler error. </span><span class="koboSpan" id="kobo.602.3">Rvalue references are important for resource management, and they are used in move semantics, which allow resources to be moved from one object to another.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.603.1">If we take a look at the documentation for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.604.1">push_back</span></code><span class="koboSpan" id="kobo.605.1"> method of </span><code class="inlineCode"><span class="koboSpan" id="kobo.606.1">std::vector</span></code><span class="koboSpan" id="kobo.607.1">, we will see two declarations:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.608.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.609.1">push_back</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.610.1">( </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.611.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.612.1"> T&amp; value )</span></span><span class="koboSpan" id="kobo.613.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.614.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.615.1">push_back</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.616.1">( T&amp;&amp; value )</span></span><span class="koboSpan" id="kobo.617.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.618.1">The first declaration is used to initialize a new vector member by copying </span><code class="inlineCode"><span class="koboSpan" id="kobo.619.1">value</span></code><span class="koboSpan" id="kobo.620.1">. </span><span class="koboSpan" id="kobo.620.2">The second declaration with rvalue reference will move </span><code class="inlineCode"><span class="koboSpan" id="kobo.621.1">value</span></code><span class="koboSpan" id="kobo.622.1">, meaning that a new vector member will take ownership of dynamically allocated resources from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.623.1">value</span></code><span class="koboSpan" id="kobo.624.1"> object. </span><span class="koboSpan" id="kobo.624.2">Let’s take a look at the following </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.625.1">example </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.626.1">to understand the basics of move semantics:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.627.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.628.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.629.1">&lt;string&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.630.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.631.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.632.1">&lt;vector&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.633.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.634.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.635.1">&lt;cstdio&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.636.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.637.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.638.1">()</span></span><span class="koboSpan" id="kobo.639.1">
{
    std::string str = </span><span class="hljs-string"><span class="koboSpan" id="kobo.640.1">"Hello world, this is move semantics demo!!!"</span></span><span class="koboSpan" id="kobo.641.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.642.1">printf</span></span><span class="koboSpan" id="kobo.643.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.644.1">"str.data address is %p\r\n"</span></span><span class="koboSpan" id="kobo.645.1">, (</span><span class="hljs-type"><span class="koboSpan" id="kobo.646.1">void</span></span><span class="koboSpan" id="kobo.647.1">*)str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.648.1">data</span></span><span class="koboSpan" id="kobo.649.1">());
    std::vector&lt;std::string&gt; v;
    v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.650.1">push_back</span></span><span class="koboSpan" id="kobo.651.1">(str);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.652.1">printf</span></span><span class="koboSpan" id="kobo.653.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.654.1">"str after copy is &lt;%s&gt;\r\n"</span></span><span class="koboSpan" id="kobo.655.1">, str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.656.1">data</span></span><span class="koboSpan" id="kobo.657.1">());
    v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.658.1">push_back</span></span><span class="koboSpan" id="kobo.659.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.660.1">move</span></span><span class="koboSpan" id="kobo.661.1">(str));
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.662.1">//v.push_back(static_cast&lt;std::string&amp;&amp;&gt;(str));</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.663.1">printf</span></span><span class="koboSpan" id="kobo.664.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.665.1">"str after move is &lt;%s&gt;\r\n"</span></span><span class="koboSpan" id="kobo.666.1">, str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.667.1">data</span></span><span class="koboSpan" id="kobo.668.1">());
    
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.669.1">for</span></span><span class="koboSpan" id="kobo.670.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.671.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.672.1">auto</span></span><span class="koboSpan" id="kobo.673.1"> &amp; s:v) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.674.1">printf</span></span><span class="koboSpan" id="kobo.675.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.676.1">"s is &lt;%s&gt;\r\n"</span></span><span class="koboSpan" id="kobo.677.1">, s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.678.1">data</span></span><span class="koboSpan" id="kobo.679.1">());
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.680.1">printf</span></span><span class="koboSpan" id="kobo.681.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.682.1">"s.data address is %p\r\n"</span></span><span class="koboSpan" id="kobo.683.1">, (</span><span class="hljs-type"><span class="koboSpan" id="kobo.684.1">void</span></span><span class="koboSpan" id="kobo.685.1">*)s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.686.1">data</span></span><span class="koboSpan" id="kobo.687.1">());
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.688.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.689.1">0</span></span><span class="koboSpan" id="kobo.690.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.691.1">In this example, we have two calls to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.692.1">push_back</span></code><span class="koboSpan" id="kobo.693.1"> method of </span><code class="inlineCode"><span class="koboSpan" id="kobo.694.1">std::vector&lt;std::string&gt;</span></code><span class="koboSpan" id="kobo.695.1">. </span><span class="koboSpan" id="kobo.695.2">The first call, </span><code class="inlineCode"><span class="koboSpan" id="kobo.696.1">v.push_back(str);</span></code><span class="koboSpan" id="kobo.697.1">, performs a copy of </span><code class="inlineCode"><span class="koboSpan" id="kobo.698.1">str</span></code><span class="koboSpan" id="kobo.699.1"> into the vector. </span><span class="koboSpan" id="kobo.699.2">After this operation, the original str remains unchanged, which is confirmed by the output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.700.1">str.data address is 0x84c2b0
str after copy is &lt;Hello world, this is move semantics demo!!!&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.701.1">The second call, </span><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">v.push_back(std::move(str));</span></code><span class="koboSpan" id="kobo.703.1">, uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">std::move</span></code><span class="koboSpan" id="kobo.705.1"> to cast </span><code class="inlineCode"><span class="koboSpan" id="kobo.706.1">str</span></code><span class="koboSpan" id="kobo.707.1"> to an rvalue reference. </span><span class="koboSpan" id="kobo.707.2">This signals to the compiler that the resources of </span><code class="inlineCode"><span class="koboSpan" id="kobo.708.1">str</span></code><span class="koboSpan" id="kobo.709.1"> can be moved rather than copied. </span><span class="koboSpan" id="kobo.709.2">As a</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.710.1"> result, the internal data of </span><code class="inlineCode"><span class="koboSpan" id="kobo.711.1">str</span></code><span class="koboSpan" id="kobo.712.1"> is transferred to the </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.713.1">new string in the vector, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.714.1">str</span></code><span class="koboSpan" id="kobo.715.1"> is left in a valid but unspecified state, often becoming empty:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.716.1">str after move is &lt;&gt;
s is &lt;Hello world, this is move semantics demo!!!&gt;
s.data address is 0x84d330
s is &lt;Hello world, this is move semantics demo!!!&gt;
s.data address is 0x84c2b0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.717.1">In the preceding output, we are also printing addresses of the string’s underlying character arrays using </span><code class="inlineCode"><span class="koboSpan" id="kobo.718.1">s.data()</span></code><span class="koboSpan" id="kobo.719.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">str.data()</span></code><span class="koboSpan" id="kobo.721.1">.Here’s what’s happening:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.722.1">The original </span><code class="inlineCode"><span class="koboSpan" id="kobo.723.1">str</span></code><span class="koboSpan" id="kobo.724.1"> has its data at address </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">0x84c2b0</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.726.1">After copying str into the vector, the first element, </span><code class="inlineCode"><span class="koboSpan" id="kobo.727.1">v[0]</span></code><span class="koboSpan" id="kobo.728.1">, has its own copy of the data at a different address (</span><code class="inlineCode"><span class="koboSpan" id="kobo.729.1">0x84d330</span></code><span class="koboSpan" id="kobo.730.1">), confirming that a deep copy was made</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.731.1">After the move, the second element, </span><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">v[1]</span></code><span class="koboSpan" id="kobo.733.1">, in the vector now points to the original data address, </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">0x84c2b0</span></code><span class="koboSpan" id="kobo.735.1">. </span><span class="koboSpan" id="kobo.735.2">This indicates that the internal data of </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">str</span></code><span class="koboSpan" id="kobo.737.1"> was moved into </span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">v[1]</span></code><span class="koboSpan" id="kobo.739.1"> without copying. </span><span class="koboSpan" id="kobo.739.2">This is just a </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.740.1">glimpse into move semantics; there is much </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.741.1">more to it, but as it is used mostly for managing dynamically allocated resources, we will not cover it in more detail.</span></p>
<h1 class="heading-1" id="_idParaDest-105"><span class="koboSpan" id="kobo.742.1">Standard library containers and algorithms</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.743.1">We have already discussed some of the containers from the C++ library, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.744.1">std::vector</span></code><span class="koboSpan" id="kobo.745.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">std::array</span></code><span class="koboSpan" id="kobo.747.1">, in previous chapters. </span><span class="koboSpan" id="kobo.747.2">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">std::vector</span></code><span class="koboSpan" id="kobo.749.1"> relies on dynamic memory allocation, </span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">std::array</span></code><span class="koboSpan" id="kobo.751.1"> is usually the container of choice in embedded applications.</span></p>
<h2 class="heading-2" id="_idParaDest-106"><span class="koboSpan" id="kobo.752.1">Array</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.753.1">Arrays from</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.754.1"> the standard library allocate a contiguous block of memory on the </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.755.1">stack. </span><span class="koboSpan" id="kobo.755.2">We can consider an array as a simple wrapper of a C-style array that contains the size of the array inside the type. </span><span class="koboSpan" id="kobo.755.3">It is a templated type that is instantiated with an underlying data type and size.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.756.1">We can access members of the array using a method that will throw an exception if indexed with an out-of-bounds index. </span><span class="koboSpan" id="kobo.756.2">This makes it a safer option than a C-style array as it allows us to catch out-of-bounds access runtime errors and handle them. </span><span class="koboSpan" id="kobo.756.3">If exceptions are disabled, we can set a global terminate handler with our functionality. </span><span class="koboSpan" id="kobo.756.4">We had the opportunity to see this in </span><a href="Chapter_02.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.757.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.758.1"> of this book when we were discussing exceptions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.759.1">We can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.760.1">std:array</span></code><span class="koboSpan" id="kobo.761.1"> to create a vector-like container that we can use with container adaptors such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.762.1">std::stack</span></code><span class="koboSpan" id="kobo.763.1"> or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">std::priority</span></code><span class="koboSpan" id="kobo.765.1"> queue. </span><span class="koboSpan" id="kobo.765.2">We will call our new type </span><code class="inlineCode"><span class="koboSpan" id="kobo.766.1">fixed_vector</span></code><span class="koboSpan" id="kobo.767.1">. </span><span class="koboSpan" id="kobo.767.2">It will inherit from </span><code class="inlineCode"><span class="koboSpan" id="kobo.768.1">std::array</span></code><span class="koboSpan" id="kobo.769.1"> and implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">push_back</span></code><span class="koboSpan" id="kobo.771.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.772.1">pop_back</span></code><span class="koboSpan" id="kobo.773.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.774.1">empty</span></code><span class="koboSpan" id="kobo.775.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">end</span></code><span class="koboSpan" id="kobo.777.1"> methods. </span><span class="koboSpan" id="kobo.777.2">Here is an implementation of our new type using an array </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.778.1">from the standard</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.779.1"> library:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.780.1">template</span></span><span class="koboSpan" id="kobo.781.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.782.1">typename</span></span><span class="koboSpan" id="kobo.783.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.784.1">size_t</span></span><span class="koboSpan" id="kobo.785.1"> S&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.786.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.787.1">fixed_vector</span></span><span class="koboSpan" id="kobo.788.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.789.1">public</span></span><span class="koboSpan" id="kobo.790.1"> std::array&lt;T, S&gt; {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.791.1">public</span></span><span class="koboSpan" id="kobo.792.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.793.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.794.1">push_back</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.795.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.796.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.797.1"> T &amp;el)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.798.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.799.1">if</span></span><span class="koboSpan" id="kobo.800.1">(cnt_ &lt; S) {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.801.1">this</span></span><span class="koboSpan" id="kobo.802.1">-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.803.1">at</span></span><span class="koboSpan" id="kobo.804.1">(cnt_) = el;
            ++cnt_;
        }
    }
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.805.1">T &amp;</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.806.1">back</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.807.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.808.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.809.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.810.1">this</span></span><span class="koboSpan" id="kobo.811.1">-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.812.1">at</span></span><span class="koboSpan" id="kobo.813.1">(cnt_</span><span class="hljs-number"><span class="koboSpan" id="kobo.814.1">-1</span></span><span class="koboSpan" id="kobo.815.1">);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.816.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.817.1">pop_back</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.818.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.819.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.820.1">if</span></span><span class="koboSpan" id="kobo.821.1">(cnt_) {
            --cnt_;
        }
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.822.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.823.1">end</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.824.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.825.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.826.1">return</span></span><span class="koboSpan" id="kobo.827.1"> std::array&lt;T, S&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.828.1">begin</span></span><span class="koboSpan" id="kobo.829.1">() + cnt_;
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.830.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.831.1">empty</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.832.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.833.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.834.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.835.1">return</span></span><span class="koboSpan" id="kobo.836.1"> cnt_ == </span><span class="hljs-number"><span class="koboSpan" id="kobo.837.1">0</span></span><span class="koboSpan" id="kobo.838.1">;
    }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.839.1">private</span></span><span class="koboSpan" id="kobo.840.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.841.1">size_t</span></span><span class="koboSpan" id="kobo.842.1"> cnt_ = </span><span class="hljs-number"><span class="koboSpan" id="kobo.843.1">0</span></span><span class="koboSpan" id="kobo.844.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.845.1">Our new type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.846.1">fixed_vector</span></code><span class="koboSpan" id="kobo.847.1">, exploits the underlying </span><code class="inlineCode"><span class="koboSpan" id="kobo.848.1">std::array</span></code><span class="koboSpan" id="kobo.849.1"> and implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.850.1">push_back</span></code><span class="koboSpan" id="kobo.851.1"> function to add elements at the end of the array. </span><span class="koboSpan" id="kobo.851.2">If we want to add more elements than is possible, it will fail silently. </span><span class="koboSpan" id="kobo.851.3">This behavior can be adjusted as per the application’s requirements. </span><span class="koboSpan" id="kobo.851.4">It also implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.852.1">back</span></code><span class="koboSpan" id="kobo.853.1"> method, which returns an lvalue reference to the last element, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.854.1">pop_back</span></code><span class="koboSpan" id="kobo.855.1">, which decrements the private member, </span><code class="inlineCode"><span class="koboSpan" id="kobo.856.1">cnt_</span></code><span class="koboSpan" id="kobo.857.1">, used to keep track of the number of elements stored in the container.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.858.1">We can use our </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.859.1">new </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.860.1">container type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.861.1">fixed_vector</span></code><span class="koboSpan" id="kobo.862.1">, as an underlying container type for container adaptors such as stacks and priority queues.</span></p>
<h2 class="heading-2" id="_idParaDest-107"><span class="koboSpan" id="kobo.863.1">Container adaptors</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.864.1">Stack is a</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.865.1"> simple </span><strong class="keyWord"><span class="koboSpan" id="kobo.866.1">Last In-First Out</span></strong><span class="koboSpan" id="kobo.867.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.868.1">LIFO</span></strong><span class="koboSpan" id="kobo.869.1">) container adaptor, and</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.870.1"> the priority queue will sort the elements </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.871.1">when inserting them. </span><span class="koboSpan" id="kobo.871.2">We can see how to use them with </span><code class="inlineCode"><span class="koboSpan" id="kobo.872.1">fixed_vector</span></code><span class="koboSpan" id="kobo.873.1"> in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.874.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.875.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.876.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.877.1">{
    std::priority_queue&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.878.1">int</span></span><span class="koboSpan" id="kobo.879.1">, fixed_vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.880.1">int</span></span><span class="koboSpan" id="kobo.881.1">, 10&gt;&gt; pq;
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.882.1">push</span></span><span class="koboSpan" id="kobo.883.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.884.1">10</span></span><span class="koboSpan" id="kobo.885.1">);
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.886.1">push</span></span><span class="koboSpan" id="kobo.887.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.888.1">4</span></span><span class="koboSpan" id="kobo.889.1">);
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.890.1">push</span></span><span class="koboSpan" id="kobo.891.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.892.1">8</span></span><span class="koboSpan" id="kobo.893.1">);
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.894.1">push</span></span><span class="koboSpan" id="kobo.895.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.896.1">1</span></span><span class="koboSpan" id="kobo.897.1">);
    pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.898.1">push</span></span><span class="koboSpan" id="kobo.899.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.900.1">2</span></span><span class="koboSpan" id="kobo.901.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.902.1">printf</span></span><span class="koboSpan" id="kobo.903.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.904.1">"Popping elements from priority queue: "</span></span><span class="koboSpan" id="kobo.905.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.906.1">while</span></span><span class="koboSpan" id="kobo.907.1">(!pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.908.1">empty</span></span><span class="koboSpan" id="kobo.909.1">()) {
       </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.910.1">printf</span></span><span class="koboSpan" id="kobo.911.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.912.1">"%d "</span></span><span class="koboSpan" id="kobo.913.1">, pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.914.1">top</span></span><span class="koboSpan" id="kobo.915.1">());
       pq.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.916.1">pop</span></span><span class="koboSpan" id="kobo.917.1">();
    }
    std::stack&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.918.1">int</span></span><span class="koboSpan" id="kobo.919.1">, fixed_vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.920.1">int</span></span><span class="koboSpan" id="kobo.921.1">, 10&gt;&gt; st;
    st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.922.1">push</span></span><span class="koboSpan" id="kobo.923.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.924.1">10</span></span><span class="koboSpan" id="kobo.925.1">);
    st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.926.1">push</span></span><span class="koboSpan" id="kobo.927.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.928.1">4</span></span><span class="koboSpan" id="kobo.929.1">);
    st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.930.1">push</span></span><span class="koboSpan" id="kobo.931.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.932.1">8</span></span><span class="koboSpan" id="kobo.933.1">);
    st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.934.1">push</span></span><span class="koboSpan" id="kobo.935.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.936.1">1</span></span><span class="koboSpan" id="kobo.937.1">);
    st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.938.1">push</span></span><span class="koboSpan" id="kobo.939.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.940.1">2</span></span><span class="koboSpan" id="kobo.941.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.942.1">printf</span></span><span class="koboSpan" id="kobo.943.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.944.1">"\r\nPopping elements from stack (LIFO): "</span></span><span class="koboSpan" id="kobo.945.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.946.1">while</span></span><span class="koboSpan" id="kobo.947.1">(!st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.948.1">empty</span></span><span class="koboSpan" id="kobo.949.1">()) {
       </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.950.1">printf</span></span><span class="koboSpan" id="kobo.951.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.952.1">"%d "</span></span><span class="koboSpan" id="kobo.953.1">, st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.954.1">top</span></span><span class="koboSpan" id="kobo.955.1">());
       st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.956.1">pop</span></span><span class="koboSpan" id="kobo.957.1">();
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.958.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.959.1">0</span></span><span class="koboSpan" id="kobo.960.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.961.1">In this example, we are using </span><code class="inlineCode"><span class="koboSpan" id="kobo.962.1">fixed_vector</span></code><span class="koboSpan" id="kobo.963.1"> to instantiate </span><code class="inlineCode"><span class="koboSpan" id="kobo.964.1">std::stack</span></code><span class="koboSpan" id="kobo.965.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.966.1">std::priority_queue</span></code><span class="koboSpan" id="kobo.967.1"> templated types. </span><span class="koboSpan" id="kobo.967.2">If we run this program, we will get the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.968.1">Popping elements from priority queue: 10 8 4 2 1
Popping elements from stack (LIFO): 2 1 8 4 10
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.969.1">As you can see from the output, elements in the priority queue are sorted, and those in the stack are popped by the LIFO principle.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.970.1">The standard </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.971.1">library provides a variety of containers, and we</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.972.1"> have just scratched the surface of the possibilities that it provides. </span><span class="koboSpan" id="kobo.972.2">It also provides algorithms that operate on containers.</span></p>
<h2 class="heading-2" id="_idParaDest-108"><span class="koboSpan" id="kobo.973.1">Algorithms</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.974.1">C++ standard library </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.975.1">offers a huge set of templated </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.976.1">algorithm functions contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.977.1">algorithm</span></code><span class="koboSpan" id="kobo.978.1"> header that play well with different container types. </span><span class="koboSpan" id="kobo.978.2">We will go through some of them now.</span></p>
<h3 class="heading-3" id="_idParaDest-109"><span class="koboSpan" id="kobo.979.1">std::copy and std::copy_if</span></h3>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">std::copy</span></code><span class="koboSpan" id="kobo.981.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.982.1">std::copy_if</span></code><span class="koboSpan" id="kobo.983.1"> are </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.984.1">used to copy elements</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.985.1"> from one container to another. </span><code class="inlineCode"><span class="koboSpan" id="kobo.986.1">std::copy_if</span></code><span class="koboSpan" id="kobo.987.1"> also accepts a predicate function that controls whether a member is copied or not, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.988.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.989.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.990.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.991.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.992.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.993.1">&lt;vector&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.994.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.995.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.996.1">&lt;array&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.997.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.998.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.999.1">&lt;algorithm&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1000.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1001.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1002.1">&lt;numeric&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1003.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1004.1">print_container</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1005.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1006.1">const</span></span><span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1007.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1008.1">&amp; container)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1009.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1010.1">for</span></span><span class="koboSpan" id="kobo.1011.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1012.1">auto</span></span><span class="koboSpan" id="kobo.1013.1">&amp; elem: container) {
       </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1014.1">printf</span></span><span class="koboSpan" id="kobo.1015.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1016.1">"%d "</span></span><span class="koboSpan" id="kobo.1017.1">, elem);
    }
       </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1018.1">printf</span></span><span class="koboSpan" id="kobo.1019.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1020.1">"\r\n"</span></span><span class="koboSpan" id="kobo.1021.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1022.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1023.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1024.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1025.1">{
    std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1026.1">int</span></span><span class="koboSpan" id="kobo.1027.1">, 10&gt; src{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1028.1">0</span></span><span class="koboSpan" id="kobo.1029.1">};
    std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1030.1">int</span></span><span class="koboSpan" id="kobo.1031.1">, 10&gt; dst{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1032.1">0</span></span><span class="koboSpan" id="kobo.1033.1">};
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1034.1">iota</span></span><span class="koboSpan" id="kobo.1035.1">(src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1036.1">begin</span></span><span class="koboSpan" id="kobo.1037.1">(), src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1038.1">end</span></span><span class="koboSpan" id="kobo.1039.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1040.1">0</span></span><span class="koboSpan" id="kobo.1041.1">);
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1042.1">copy_if</span></span><span class="koboSpan" id="kobo.1043.1">(src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1044.1">begin</span></span><span class="koboSpan" id="kobo.1045.1">(), src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1046.1">end</span></span><span class="koboSpan" id="kobo.1047.1">(), dst.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1048.1">begin</span></span><span class="koboSpan" id="kobo.1049.1">(),[] 
        (</span><span class="hljs-type"><span class="koboSpan" id="kobo.1050.1">int</span></span><span class="koboSpan" id="kobo.1051.1"> x) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1052.1">return</span></span><span class="koboSpan" id="kobo.1053.1"> x &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1054.1">3</span></span><span class="koboSpan" id="kobo.1055.1">;});
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1056.1">print_container</span></span><span class="koboSpan" id="kobo.1057.1">(src);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1058.1">print_container</span></span><span class="koboSpan" id="kobo.1059.1">(dst);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1060.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1061.1">0</span></span><span class="koboSpan" id="kobo.1062.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1063.1">In this example, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1064.1">std::iota</span></code><span class="koboSpan" id="kobo.1065.1"> from the numeric header to initialize the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1066.1">src</span></code><span class="koboSpan" id="kobo.1067.1"> array with incrementing values, starting with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1068.1">0</span></code><span class="koboSpan" id="kobo.1069.1">. </span><span class="koboSpan" id="kobo.1069.2">Then, we copy all elements from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1070.1">src</span></code><span class="koboSpan" id="kobo.1071.1"> array to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1072.1">dst</span></code><span class="koboSpan" id="kobo.1073.1"> array that are </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.1074.1">larger</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.1075.1"> than 3 using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1076.1">std::copy_if</span></code><span class="koboSpan" id="kobo.1077.1">.</span></p>
<h3 class="heading-3" id="_idParaDest-110"><span class="koboSpan" id="kobo.1078.1">std::sort</span></h3>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1079.1">std::sort</span></code><span class="koboSpan" id="kobo.1080.1"> is </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.1081.1">used to sort elements in a container. </span><span class="koboSpan" id="kobo.1081.2">In the following example, we will </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.1082.1">generate elements randomly and sort them:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1083.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1084.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1085.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1086.1">{
    std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1087.1">int</span></span><span class="koboSpan" id="kobo.1088.1">, 10&gt; src{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1089.1">0</span></span><span class="koboSpan" id="kobo.1090.1">};
    std::random_device rd;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.1091.1">std::mt19937 </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1092.1">gen</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1093.1">(rd())</span></span><span class="koboSpan" id="kobo.1094.1">;
    std::uniform_int_distribution&lt;&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1095.1">distrib</span></span><span class="koboSpan" id="kobo.1096.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1097.1">1</span></span><span class="koboSpan" id="kobo.1098.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1099.1">6</span></span><span class="koboSpan" id="kobo.1100.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1101.1">auto</span></span><span class="koboSpan" id="kobo.1102.1"> rand = [&amp;](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1103.1">int</span></span><span class="koboSpan" id="kobo.1104.1"> x) -&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.1105.1">int</span></span><span class="koboSpan" id="kobo.1106.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1107.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1108.1">distrib</span></span><span class="koboSpan" id="kobo.1109.1">(gen);
    };
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1110.1">transform</span></span><span class="koboSpan" id="kobo.1111.1">(src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1112.1">begin</span></span><span class="koboSpan" id="kobo.1113.1">(), src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1114.1">end</span></span><span class="koboSpan" id="kobo.1115.1">(), src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1116.1">begin</span></span><span class="koboSpan" id="kobo.1117.1">(), rand);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1118.1">print_container</span></span><span class="koboSpan" id="kobo.1119.1">(src);
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1120.1">sort</span></span><span class="koboSpan" id="kobo.1121.1">(src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1122.1">begin</span></span><span class="koboSpan" id="kobo.1123.1">(), src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1124.1">end</span></span><span class="koboSpan" id="kobo.1125.1">());
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1126.1">print_container</span></span><span class="koboSpan" id="kobo.1127.1">(src);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1128.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1129.1">0</span></span><span class="koboSpan" id="kobo.1130.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1131.1">In this example, we populate the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1132.1">src</span></code><span class="koboSpan" id="kobo.1133.1"> array using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1134.1">std::transform</span></code><span class="koboSpan" id="kobo.1135.1">, which applies a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1136.1">rand</span></code><span class="koboSpan" id="kobo.1137.1"> lambda to every member of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1138.1">src</span></code><span class="koboSpan" id="kobo.1139.1"> array. </span><span class="koboSpan" id="kobo.1139.2">We used types from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1140.1">random</span></code><span class="koboSpan" id="kobo.1141.1"> header to generate random numbers between 1 and 6. </span><span class="koboSpan" id="kobo.1141.2">After we populate the array with random numbers, we sort it using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1142.1">std::sort</span></code><span class="koboSpan" id="kobo.1143.1">. </span><span class="koboSpan" id="kobo.1143.2">A possible output of this program is shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1144.1">6 6 1 1 6 5 4 4 1 1
1 1 1 1 4 4 5 6 6 6
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1145.1">We first see values in the array before sorting and then applying </span><code class="inlineCode"><span class="koboSpan" id="kobo.1146.1">std::sort</span></code><span class="koboSpan" id="kobo.1147.1">. </span><span class="koboSpan" id="kobo.1147.2">We could have populated the initial array in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1148.1">for</span></code><span class="koboSpan" id="kobo.1149.1"> loop, but we used the opportunity to demonstrate </span><code class="inlineCode"><span class="koboSpan" id="kobo.1150.1">std:transform</span></code><span class="koboSpan" id="kobo.1151.1"> here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1152.1">These were some of</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.1153.1"> the algorithms from the C++ standard library; there </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.1154.1">are many more that can be used to effectively solve common tasks in containers.</span></p>
<h1 class="heading-1" id="_idParaDest-111"><span class="koboSpan" id="kobo.1155.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1156.1">In this chapter, we covered C++ fundamentals such as namespaces, function overloading, references, and standard library containers and algorithms. </span><span class="koboSpan" id="kobo.1156.2">We also learned how C interoperability is implemented and used in C++ programs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1157.1">In the next chapter, we will learn about error-handling mechanisms in C++.</span></p>
</div>
</body></html>