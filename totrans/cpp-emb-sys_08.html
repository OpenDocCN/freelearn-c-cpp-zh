<html><head></head><body>
<div><h1 class="chapterNumber">6</h1>
<h1 class="chapterTitle" id="_idParaDest-92">Beyond Classes – Fundamental C++ Concepts</h1>
<p class="normal">Historically, C++ started as C with classes, making classes one of the first concepts for developers with a C background to learn. In the previous chapter, we covered classes in detail, and before proceeding with more advanced concepts, we will cover other fundamental C++ concepts that make it so much more than C with classes.</p>
<p class="normal">Before we move on to more advanced topics, it’s important to explore other fundamental concepts that make C++ distinct. In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li class="bulletList">Namespaces</li>
<li class="bulletList">Function overloading</li>
<li class="bulletList">Interoperability with C</li>
<li class="bulletList">References</li>
<li class="bulletList">Standard library containers and algorithms</li>
</ul>
<h1 class="heading-1" id="_idParaDest-93">Technical requirements</h1>
<p class="normal">To get the most out of this chapter, I strongly recommend using Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) as you read through the examples. Select GCC as your compiler and target x86 architecture. This will allow you to see standard output (stdio) results and better observe the code’s behavior. As we are using modern C++ features make sure to select C++23 standard, by adding <code class="inlineCode">-std=c++23</code> in compiler options box.</p>
<p class="normal">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly. The examples are available at GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter06">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter06</a>).</p>
<h1 class="heading-1" id="_idParaDest-94">Namespaces</h1>
<p class="normal"><strong class="keyWord">Namespaces</strong> in C++ are<a id="_idIndexMarker315"/> used as scope specifiers for accessing type names, functions, variables, and so on. They allow us to more easily differentiate types and function names in large code bases that use many software components and where there are often similar identifiers. </p>
<p class="normal">In C, we usually add a prefix to types and functions to make it easier to differentiate, for example:</p>
<pre class="programlisting code"><code class="hljs-code">typedef struct hal_uart_stm32{
    UART_HandleTypeDef huart_;
    USART_TypeDef *instance_; 
} hal_uart_stm32;
void hal_init();
uint32_t hal_get_ms();
</code></pre>
<p class="normal">In C++, we can use namespaces instead of C-style identifier prefixes to organize code in logical groups, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">namespace hal {
void init();
std::uint32_t tick_count;
std::uint32_t get_ms() {
    return tick_count;
}
class uart_stm32 {
private:
    UART_HandleTypeDef huart_;
    USART_TypeDef *instance_; 
};
};
</code></pre>
<p class="normal">All members of the <code class="inlineCode">hal</code> namespace are accessible unqualified from within the namespace. To access identifiers from the <code class="inlineCode">hal</code> namespace, in code outside of it, we use the namespace as a qualifier followed by scope resolution operator (<code class="inlineCode">::</code>), as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">hal::init();
std::uint32_t time_now = hal::get_ms();
</code></pre>
<p class="normal">In this example, beside<a id="_idIndexMarker316"/> the <code class="inlineCode">hal</code> namespace, we also see the <code class="inlineCode">std</code> namespace, which we used in previous examples. C++ standard library types and functions are declared in the <code class="inlineCode">std</code> namespace.</p>
<p class="normal">We can use the <code class="inlineCode">using</code> directive to access an identifier without qualifiers, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">using std::array;
array&lt;int, 4&gt; arr;
</code></pre>
<p class="normal">The <code class="inlineCode">using</code> directive can also be used for the entire namespace, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">using namespace std;
array&lt;int, 4&gt; arr;
vector&lt;int&gt; vec;
</code></pre>
<p class="normal">It is recommended to use <code class="inlineCode">using</code> directive sparingly, especially with <code class="inlineCode">std</code>, using it for a limited scope, or even better, to bring in individual identifiers only.</p>
<p class="normal">The same namespace can be used across different header files to declare identifiers. For example, <code class="inlineCode">std::vector</code> is declared in <code class="inlineCode">vector.h</code>, and <code class="inlineCode">std::array</code> is declared in <code class="inlineCode">array.h</code> header files. This allows us to organize code from different headers that logically belong to the same group in a namespace.</p>
<p class="normal">Functions and types that are not declared within an explicit namespace are part of a global namespace. It is a good practice to organize all code in namespaces. The only function that can’t be declared within a namespace and must be in a global namespace is <code class="inlineCode">main</code>. To access the identifier from the global namespace, we use the scope resolution operator, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">const int ret_val = 0;
int main() {
    return ::ret_val;
}
</code></pre>
<p class="normal">The line <code class="inlineCode">return ::ret_val;</code> uses the scope resolution operator, <code class="inlineCode">::</code>, without specifying a namespace. This<a id="_idIndexMarker317"/> means it refers to the global namespace. So, <code class="inlineCode">::ret_val</code> accesses the <code class="inlineCode">ret_val</code> variable defined outside of any function or class—that is, at the global scope.</p>
<h2 class="heading-2" id="_idParaDest-95">Unnamed namespaces</h2>
<p class="normal">A namespace can be<a id="_idIndexMarker318"/> declared without the name qualifier. This allows us to declare functions and types that are local to the translation unit they are declared in. In the following example, we can see an example of an unnamed namespace:</p>
<pre class="programlisting code"><code class="hljs-code">namespace {
constexpr std::size_t c_max_retries;
std::size_t counter;
};
</code></pre>
<p class="normal">In the code, we have an unnamed namespace with a few variables declared in it. They have <strong class="keyWord">internal linkage</strong>, meaning <a id="_idIndexMarker319"/>they cannot be accessed by code from other translation units. We can achieve the same <a id="_idIndexMarker320"/>effect both in C and C++ by using the <code class="inlineCode">static</code> storage specifier.</p>
<h2 class="heading-2" id="_idParaDest-96">Nested namespaces</h2>
<p class="normal">Namespaces can also <a id="_idIndexMarker321"/>be nested. We can have a namespace within a namespace, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">namespace sensors {
namespace environmental {
class temperature {
};
class humidity {
};
};
namespace indoor_air_quality{
class c02{
};
class pm2_5{
};
};
};
</code></pre>
<p class="normal">In this example, we have organized sensors in namespaces. We have a top-level namespace, <code class="inlineCode">sensors</code>, which has two namespaces: <code class="inlineCode">environmental</code> and <code class="inlineCode">indoor_air_quality</code>. C++17 standard allows us to write namespaces, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">namespace sensors::environmental {
class temperature {
};
class humidity {
};
};
</code></pre>
<p class="normal">Namespaces are a good way to make the code more readable, as they allow us to keep identifiers <a id="_idIndexMarker322"/>short, without C-style prefixes.</p>
<h1 class="heading-1" id="_idParaDest-97">Function overloading</h1>
<p class="normal">In the previous chapter, when <a id="_idIndexMarker323"/>we discussed inheritance, we <a id="_idIndexMarker324"/>mentioned <strong class="keyWord">static binding</strong>. We saw that we can have the same function names for functions that belong to different classes. However, we can also have the same function names for different function parameters, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
void print(int a) {
    printf("Int %d\r\n", a);
}
void print(float a) {
    printf("Float %2.f\r\n", a);
}
int main() {
    print(2);
    print(2.f);
    return 0;
}
</code></pre>
<p class="normal">In this example, we have two <code class="inlineCode">print</code> functions. One of them has an <code class="inlineCode">int</code> as a parameter and the second one has a <code class="inlineCode">float</code>. On the call site, the compiler will pick a <code class="inlineCode">print</code> function based on the arguments passed to the function call.</p>
<p class="normal">Functions with the same names within the same scope are called <strong class="keyWord">overloaded functions</strong>. Instead of having two different names, such as <code class="inlineCode">print_int</code> and <code class="inlineCode">print_float</code>, we can use the same name for both these functions and let the compiler decide which function to call.</p>
<p class="normal">To distinguish between the two overloaded <code class="inlineCode">print</code> functions – one accepting an <code class="inlineCode">int</code> parameter and the other a <code class="inlineCode">float</code> – the compiler employs a technique <a id="_idIndexMarker325"/>called <strong class="keyWord">name mangling</strong>. Name mangling modifies function names by encoding additional information, such as parameter types, into them. This ensures that each overloaded function has a unique symbol in the compiled code. If we examine the assembly output of the previous example, we can observe these mangled names:</p>
<pre class="programlisting code"><code class="hljs-code">_Z5printi:
        mov     r1, r0
        ldr     r0, .L2
        b       printf
_Z5printf:
        vcvt.f64.f32    d16, s0
        ldr     r0, .L5
        vmov    r2, r3, d16
        b       printf
</code></pre>
<p class="normal">We see that the compiler assigned <code class="inlineCode">_Z5printi</code> and <code class="inlineCode">_Z5printf</code> labels to <code class="inlineCode">print</code> functions with <code class="inlineCode">int</code> and <code class="inlineCode">float</code> parameters respectively. This allows it to dispatch function calls according to argument matching.</p>
<p class="normal">Overloaded functions<a id="_idIndexMarker326"/> can have a different number of arguments. Return types cannot be used for function overloading. Two functions with the same name and same arguments cannot have different return types. The following code would result in a compile error:</p>
<pre class="programlisting code"><code class="hljs-code">int print(int a);
void print(int a);
</code></pre>
<p class="normal">This code would be treated by the compiler as a function redeclaration and would result in an error.</p>
<p class="normal">Function overloading<a id="_idIndexMarker327"/> is a basic but powerful feature of C++ that provides a mechanism for compile-time or static polymorphism.</p>
<h1 class="heading-1" id="_idParaDest-98">Interoperability with C</h1>
<p class="normal">Code examples from <a id="_idIndexMarker328"/>previous chapters that you were able to run in a Renode simulator are using both C++ and C code. We used vendor provided HAL library and <strong class="keyWord">Common Microcontroller Software Interface Standard</strong> (<strong class="keyWord">CMSIS</strong>) by Arm, both written in C and contained<a id="_idIndexMarker329"/> in the <code class="inlineCode">platform</code> folder.</p>
<p class="normal">If you take a look at the <code class="inlineCode">CMakeLists.txt</code> file and the <code class="inlineCode">add_executable</code> function in it, you will see listed C files from the <code class="inlineCode">platform</code> folder and just a few C++ files. Building a project will provide the following console output:</p>
<pre class="programlisting con"><code class="hljs-con">[  7%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal.c.o
[ 15%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_cortex.c.o
[ 23%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_gpio.c.o
[ 30%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_rcc.c.o
[ 38%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_uart.c.o
[ 46%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_uart_ex.c.o
[ 53%] Building ASM object CMakeFiles/bare.elf.dir/platform/startup_stm32f072xb.s.o
[ 61%] Building C object CMakeFiles/bare.elf.dir/platform/src/stm32f0xx_hal_msp.c.o
[ 69%] Building C object CMakeFiles/bare.elf.dir/platform/src/stm32f0xx_it.c.o
[ 76%] Building C object CMakeFiles/bare.elf.dir/platform/src/system_stm32f0xx.c.o
[ 84%] Building CXX object CMakeFiles/bare.elf.dir/app/src/main.cpp.o
[ 92%] Building CXX object CMakeFiles/bare.elf.dir/hal/uart/src/uart_stm32.cpp.o
[100%] Linking CXX executable bare.elf
</code></pre>
<p class="normal">Every C and C++ file is treated as a translation unit and built separately by C and C++ compilers respectively. After<a id="_idIndexMarker330"/> compilation, both C and C++ object files are linked into a single ELF file.</p>
<h2 class="heading-2" id="_idParaDest-99">External and Language Linkage in C++</h2>
<p class="normal">Variables and functions<a id="_idIndexMarker331"/> that<a id="_idIndexMarker332"/> can be referred to from other translation units<a id="_idIndexMarker333"/> have <strong class="keyWord">external linkage</strong>. This allows them to be linked with code in other files provided that the compiler has access to declarations. They also have a property called <strong class="keyWord">language linkage</strong>. This <a id="_idIndexMarker334"/>property allows linking C++ with C code. C language linkage in C++ is declared using the following syntax:</p>
<pre class="programlisting code"><code class="hljs-code">extern "C" {
void c_func();
}
</code></pre>
<p class="normal">Declaration with C language linkage will be linked according to C language linkage conventions, preventing name mangling (among other things) to ensure proper linking with code compiled within a C translation unit.</p>
<h2 class="heading-2" id="_idParaDest-100">C standard library in C++</h2>
<p class="normal">C++ wraps the C standard <a id="_idIndexMarker335"/>library and provides header files with the same name<a id="_idIndexMarker336"/> as the C language version but with a <code class="inlineCode">c</code> prefix and no extension. For example, the C++ equivalent for the C language header file <code class="inlineCode">&lt;stdlib.h&gt;</code> is <code class="inlineCode">&lt;cstdlib&gt;</code>.</p>
<p class="normal">In GCC, implementation C++ wrappers include C standard library headers; for example, <code class="inlineCode">&lt;cstdio&gt;</code> includes <code class="inlineCode">&lt;stdio.h&gt;</code>. If you dive into <code class="inlineCode">&lt;stdio.h&gt;</code>, you can see that it guards function declarations with <code class="inlineCode">__BEGIN_DECLS</code> and <code class="inlineCode">__END_DECLS</code> macros. Here’s the definition of these macros:</p>
<pre class="programlisting code"><code class="hljs-code">/* C++ needs to know that types and declarations are C, not C++.  */
#ifdef    __cplusplus
# define __BEGIN_DECLS    extern "C" {
# define __END_DECLS    }
#else
# define __BEGIN_DECLS
# define __END_DECLS
#endif
</code></pre>
<p class="normal">Here, we can see <a id="_idIndexMarker337"/>that <a id="_idIndexMarker338"/>standard C library headers take care of C++ compatibility by adding a language linkage specifier if a C++ compiler is used. This practice is also used in many HAL implementations provided by microcontroller vendors. If you open any C header file in <code class="inlineCode">platform/STM32F0xx_HAL_Driver/Inc</code>, you will see that declarations are guarded with a C language linkage specifier when they are accessed by the C++ compiler, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">#ifdef __cplusplus
extern "C" {
#endif
// Declarations
#ifdef __cplusplus
}
#endif
</code></pre>
<p class="normal">C libraries are often used by C++ programs, especially in the embedded domain, so it is always a good idea to guard them with a language linkage specifier. If we are using a C library in a C++ program in which headers are not guarded internally, we can guard the headers at the <code class="inlineCode">include</code> site, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">extern "C" {
#include "c_library.h"
}
</code></pre>
<p class="normal">The language <a id="_idIndexMarker339"/>linkage <a id="_idIndexMarker340"/>specifier for C language ensures proper linking of C++ code that is using C code, which is often a case in embedded projects.</p>
<h1 class="heading-1" id="_idParaDest-101">References</h1>
<p class="normal">In the previous chapter, we briefly mentioned references without explaining them in detail. References are <a id="_idIndexMarker341"/>object aliases; that is, they refer to objects and as such they must be immediately initialized. They are not objects, so there are no pointers to references or arrays of references.</p>
<p class="normal">There are two different types of references in C++: <strong class="keyWord">lvalue</strong> and <strong class="keyWord">rvalue</strong> references.</p>
<h2 class="heading-2" id="_idParaDest-102">Value categories</h2>
<p class="normal">C++ expressions have<a id="_idIndexMarker342"/> either lvalue or rvalue value categories. There <a id="_idIndexMarker343"/>is a more detailed division of value categories, but we will stay with this simple one which has a historical origin.</p>
<p class="normal"><strong class="keyWord">Lvalues</strong> usually appear on the left side of the assignment expression, but this is not always the case. Lvalues have an address that the program can access. Here are some examples of lvalues:</p>
<pre class="programlisting code"><code class="hljs-code">void bar();
int a = 42; // a is lvalue
int b = a; // a can also appear on the right side
int * p = &amp;a; // pointer p is lvalue
void(*bar_ptr)() = bar; // func pointer bar_ptr is lvalue
</code></pre>
<p class="normal"><strong class="keyWord">Rvalues</strong> usually appear on the right side of the assignment expression. Examples are literals, function calls that do not return references, and built-in operator calls. We can think of them as temporary values. Some rvalues are shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">int a = 42; // 42 is rvalue
int b = a + 16; // a + 16 is rvalue
std::size_t size = sizeof(int); // sizeof(int) is rvalue
</code></pre>
<p class="normal">Here is another, full example to help you better understand rvalues:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
struct my_struct {
    int a_;
    my_struct() : a_(0) {}
    my_struct(int a) : a_(a) {}
};
int main() {
    printf("a_ = %d\r\n", my_struct().a_);
    printf("a_ = %d\r\n", (my_struct()=my_struct(16)).a_);
    return 0;
}
</code></pre>
<p class="normal">In the preceding<a id="_idIndexMarker344"/> example, we can see the <code class="inlineCode">my_struct()</code> rvalue<a id="_idIndexMarker345"/> expression on the left side of the assignment operator. The output of the example is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">a_ = 0
a_ = 16
</code></pre>
<p class="normal">In the first <code class="inlineCode">printf</code> call, we make a call to the constructor of <code class="inlineCode">my_struct</code>, which returns a temporary object, and we access the <code class="inlineCode">a_</code> member. In the next line, we have the following expression: <code class="inlineCode">my_struct()=my_struct(16)</code>. On the left side of this expression, we have a call to the default constructor, which returns a temporary object. Then we assign the result of the call to a constructor that accepts <code class="inlineCode">int</code> to a temporary object on the left side, which will copy one<a id="_idIndexMarker346"/> temporary <a id="_idIndexMarker347"/>object to the other one.</p>
<h2 class="heading-2" id="_idParaDest-103">Lvalue references</h2>
<p class="normal"><strong class="keyWord">Lvalue references</strong> are <a id="_idIndexMarker348"/>used as <a id="_idIndexMarker349"/>aliases for existing objects. They can also be const-qualified. We declare them by adding <code class="inlineCode">&amp;</code> to type names. The following code demonstrates the usage of lvalue references:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
int main() {
    int a = 42;
    int&amp; a_ref = a;
    const int&amp; a_const_ref = a;
    printf("a = %d\r\n", a);
    a_ref = 16;
    printf("a = %d\r\n", a);
    // a_const_ref = 16; compiler error
    return 0;
}
</code></pre>
<p class="normal">As shown in the example, we can manipulate the object using the reference. In the case of a constant reference, any attempts to change the value will result in a compiler error.</p>
<h2 class="heading-2" id="_idParaDest-104">Rvalue references</h2>
<p class="normal"><strong class="keyWord">Rvalue references</strong> are <a id="_idIndexMarker350"/>used to extend the lifetime of temporary rvalues. We <a id="_idIndexMarker351"/>declare them using <code class="inlineCode">&amp;&amp;</code> next to the type name. Here are example usages of rvalue references:</p>
<pre class="programlisting code"><code class="hljs-code">int&amp;&amp; a = 42;
int b = 0;
// int&amp;&amp; b_ref = b; compiler error
int&amp;&amp; b_ref = b + 10; // ok, b + 10 is rvalue
</code></pre>
<p class="normal">Rvalue references cannot be bound to lvalues. Attempting to do so will result in a compiler error. Rvalue references are important for resource management, and they are used in move semantics, which allow resources to be moved from one object to another.</p>
<p class="normal">If we take a look at the documentation for the <code class="inlineCode">push_back</code> method of <code class="inlineCode">std::vector</code>, we will see two declarations:</p>
<pre class="programlisting code"><code class="hljs-code">void push_back( const T&amp; value );
void push_back( T&amp;&amp; value );
</code></pre>
<p class="normal">The first declaration is used to initialize a new vector member by copying <code class="inlineCode">value</code>. The second declaration with rvalue reference will move <code class="inlineCode">value</code>, meaning that a new vector member will take ownership of dynamically allocated resources from the <code class="inlineCode">value</code> object. Let’s take a look at the following <a id="_idIndexMarker352"/>example <a id="_idIndexMarker353"/>to understand the basics of move semantics:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
int main()
{
    std::string str = "Hello world, this is move semantics demo!!!";
    printf("str.data address is %p\r\n", (void*)str.data());
    std::vector&lt;std::string&gt; v;
    v.push_back(str);
    printf("str after copy is &lt;%s&gt;\r\n", str.data());
    v.push_back(std::move(str));
    //v.push_back(static_cast&lt;std::string&amp;&amp;&gt;(str));
    printf("str after move is &lt;%s&gt;\r\n", str.data());
    
    for(const auto &amp; s:v) {
        printf("s is &lt;%s&gt;\r\n", s.data());
        printf("s.data address is %p\r\n", (void*)s.data());
    }
    return 0;
}
</code></pre>
<p class="normal">In this example, we have two calls to the <code class="inlineCode">push_back</code> method of <code class="inlineCode">std::vector&lt;std::string&gt;</code>. The first call, <code class="inlineCode">v.push_back(str);</code>, performs a copy of <code class="inlineCode">str</code> into the vector. After this operation, the original str remains unchanged, which is confirmed by the output:</p>
<pre class="programlisting con"><code class="hljs-con">str.data address is 0x84c2b0
str after copy is &lt;Hello world, this is move semantics demo!!!&gt;
</code></pre>
<p class="normal">The second call, <code class="inlineCode">v.push_back(std::move(str));</code>, uses <code class="inlineCode">std::move</code> to cast <code class="inlineCode">str</code> to an rvalue reference. This signals to the compiler that the resources of <code class="inlineCode">str</code> can be moved rather than copied. As a<a id="_idIndexMarker354"/> result, the internal data of <code class="inlineCode">str</code> is transferred to the <a id="_idIndexMarker355"/>new string in the vector, and <code class="inlineCode">str</code> is left in a valid but unspecified state, often becoming empty:</p>
<pre class="programlisting con"><code class="hljs-con">str after move is &lt;&gt;
s is &lt;Hello world, this is move semantics demo!!!&gt;
s.data address is 0x84d330
s is &lt;Hello world, this is move semantics demo!!!&gt;
s.data address is 0x84c2b0
</code></pre>
<p class="normal">In the preceding output, we are also printing addresses of the string’s underlying character arrays using <code class="inlineCode">s.data()</code> and <code class="inlineCode">str.data()</code>.Here’s what’s happening:</p>
<ul>
<li class="bulletList">The original <code class="inlineCode">str</code> has its data at address <code class="inlineCode">0x84c2b0</code></li>
<li class="bulletList">After copying str into the vector, the first element, <code class="inlineCode">v[0]</code>, has its own copy of the data at a different address (<code class="inlineCode">0x84d330</code>), confirming that a deep copy was made</li>
</ul>
<p class="normal">After the move, the second element, <code class="inlineCode">v[1]</code>, in the vector now points to the original data address, <code class="inlineCode">0x84c2b0</code>. This indicates that the internal data of <code class="inlineCode">str</code> was moved into <code class="inlineCode">v[1]</code> without copying. This is just a <a id="_idIndexMarker356"/>glimpse into move semantics; there is much <a id="_idIndexMarker357"/>more to it, but as it is used mostly for managing dynamically allocated resources, we will not cover it in more detail.</p>
<h1 class="heading-1" id="_idParaDest-105">Standard library containers and algorithms</h1>
<p class="normal">We have already discussed some of the containers from the C++ library, such as <code class="inlineCode">std::vector</code> and <code class="inlineCode">std::array</code>, in previous chapters. As <code class="inlineCode">std::vector</code> relies on dynamic memory allocation, <code class="inlineCode">std::array</code> is usually the container of choice in embedded applications.</p>
<h2 class="heading-2" id="_idParaDest-106">Array</h2>
<p class="normal">Arrays from<a id="_idIndexMarker358"/> the standard library allocate a contiguous block of memory on the <a id="_idIndexMarker359"/>stack. We can consider an array as a simple wrapper of a C-style array that contains the size of the array inside the type. It is a templated type that is instantiated with an underlying data type and size.</p>
<p class="normal">We can access members of the array using a method that will throw an exception if indexed with an out-of-bounds index. This makes it a safer option than a C-style array as it allows us to catch out-of-bounds access runtime errors and handle them. If exceptions are disabled, we can set a global terminate handler with our functionality. We had the opportunity to see this in <a href="Chapter_02.xhtml"><em class="italic">Chapter 2</em></a> of this book when we were discussing exceptions.</p>
<p class="normal">We can use <code class="inlineCode">std:array</code> to create a vector-like container that we can use with container adaptors such as <code class="inlineCode">std::stack</code> or a <code class="inlineCode">std::priority</code> queue. We will call our new type <code class="inlineCode">fixed_vector</code>. It will inherit from <code class="inlineCode">std::array</code> and implement the <code class="inlineCode">push_back</code>, <code class="inlineCode">pop_back</code>, <code class="inlineCode">empty</code>, and <code class="inlineCode">end</code> methods. Here is an implementation of our new type using an array <a id="_idIndexMarker360"/>from the standard<a id="_idIndexMarker361"/> library:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, size_t S&gt; class fixed_vector : public std::array&lt;T, S&gt; {
  public:
    void push_back(const T &amp;el) {
        if(cnt_ &lt; S) {
            this-&gt;at(cnt_) = el;
            ++cnt_;
        }
    }
    T &amp;back() {
        return this-&gt;at(cnt_-1);
    }
    void pop_back() {
        if(cnt_) {
            --cnt_;
        }
    }
    auto end() {
        return std::array&lt;T, S&gt;::begin() + cnt_;
    }
    bool empty() const {
        return cnt_ == 0;
    }
  private:
    size_t cnt_ = 0;
};
</code></pre>
<p class="normal">Our new type, <code class="inlineCode">fixed_vector</code>, exploits the underlying <code class="inlineCode">std::array</code> and implements the <code class="inlineCode">push_back</code> function to add elements at the end of the array. If we want to add more elements than is possible, it will fail silently. This behavior can be adjusted as per the application’s requirements. It also implements the <code class="inlineCode">back</code> method, which returns an lvalue reference to the last element, and <code class="inlineCode">pop_back</code>, which decrements the private member, <code class="inlineCode">cnt_</code>, used to keep track of the number of elements stored in the container.</p>
<p class="normal">We can use our <a id="_idIndexMarker362"/>new <a id="_idIndexMarker363"/>container type, <code class="inlineCode">fixed_vector</code>, as an underlying container type for container adaptors such as stacks and priority queues.</p>
<h2 class="heading-2" id="_idParaDest-107">Container adaptors</h2>
<p class="normal">Stack is a<a id="_idIndexMarker364"/> simple <strong class="keyWord">Last In-First Out</strong> (<strong class="keyWord">LIFO</strong>) container adaptor, and<a id="_idIndexMarker365"/> the priority queue will sort the elements <a id="_idIndexMarker366"/>when inserting them. We can see how to use them with <code class="inlineCode">fixed_vector</code> in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">int main() {
    std::priority_queue&lt;int, fixed_vector&lt;int, 10&gt;&gt; pq;
    pq.push(10);
    pq.push(4);
    pq.push(8);
    pq.push(1);
    pq.push(2);
    printf("Popping elements from priority queue: ");
    while(!pq.empty()) {
       printf("%d ", pq.top());
       pq.pop();
    }
    std::stack&lt;int, fixed_vector&lt;int, 10&gt;&gt; st;
    st.push(10);
    st.push(4);
    st.push(8);
    st.push(1);
    st.push(2);
    printf("\r\nPopping elements from stack (LIFO): ");
    while(!st.empty()) {
       printf("%d ", st.top());
       st.pop();
    }
    return 0;
}
</code></pre>
<p class="normal">In this example, we are using <code class="inlineCode">fixed_vector</code> to instantiate <code class="inlineCode">std::stack</code> and <code class="inlineCode">std::priority_queue</code> templated types. If we run this program, we will get the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Popping elements from priority queue: 10 8 4 2 1
Popping elements from stack (LIFO): 2 1 8 4 10
</code></pre>
<p class="normal">As you can see from the output, elements in the priority queue are sorted, and those in the stack are popped by the LIFO principle.</p>
<p class="normal">The standard <a id="_idIndexMarker367"/>library provides a variety of containers, and we<a id="_idIndexMarker368"/> have just scratched the surface of the possibilities that it provides. It also provides algorithms that operate on containers.</p>
<h2 class="heading-2" id="_idParaDest-108">Algorithms</h2>
<p class="normal">C++ standard library <a id="_idIndexMarker369"/>offers a huge set of templated <a id="_idIndexMarker370"/>algorithm functions contained in the <code class="inlineCode">algorithm</code> header that play well with different container types. We will go through some of them now.</p>
<h3 class="heading-3" id="_idParaDest-109">std::copy and std::copy_if</h3>
<p class="normal"><code class="inlineCode">std::copy</code> and <code class="inlineCode">std::copy_if</code> are <a id="_idIndexMarker371"/>used to copy elements<a id="_idIndexMarker372"/> from one container to another. <code class="inlineCode">std::copy_if</code> also accepts a predicate function that controls whether a member is copied or not, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
void print_container(const auto&amp; container) {
    for(auto&amp; elem: container) {
       printf("%d ", elem);
    }
       printf("\r\n");
}
int main() {
    std::array&lt;int, 10&gt; src{0};
    std::array&lt;int, 10&gt; dst{0};
    std::iota(src.begin(), src.end(), 0);
    std::copy_if(src.begin(), src.end(), dst.begin(),[] 
        (int x) {return x &gt; 3;});
    print_container(src);
    print_container(dst);
    return 0;
}
</code></pre>
<p class="normal">In this example, we use <code class="inlineCode">std::iota</code> from the numeric header to initialize the <code class="inlineCode">src</code> array with incrementing values, starting with <code class="inlineCode">0</code>. Then, we copy all elements from the <code class="inlineCode">src</code> array to the <code class="inlineCode">dst</code> array that are <a id="_idIndexMarker373"/>larger<a id="_idIndexMarker374"/> than 3 using <code class="inlineCode">std::copy_if</code>.</p>
<h3 class="heading-3" id="_idParaDest-110">std::sort</h3>
<p class="normal"><code class="inlineCode">std::sort</code> is <a id="_idIndexMarker375"/>used to sort elements in a container. In the following example, we will <a id="_idIndexMarker376"/>generate elements randomly and sort them:</p>
<pre class="programlisting code"><code class="hljs-code">int main() {
    std::array&lt;int, 10&gt; src{0};
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution&lt;&gt; distrib(1, 6);
    auto rand = [&amp;](int x) -&gt; int {
        return distrib(gen);
    };
    std::transform(src.begin(), src.end(), src.begin(), rand);
    print_container(src);
    std::sort(src.begin(), src.end());
    print_container(src);
    return 0;
}
</code></pre>
<p class="normal">In this example, we populate the <code class="inlineCode">src</code> array using <code class="inlineCode">std::transform</code>, which applies a <code class="inlineCode">rand</code> lambda to every member of the <code class="inlineCode">src</code> array. We used types from the <code class="inlineCode">random</code> header to generate random numbers between 1 and 6. After we populate the array with random numbers, we sort it using <code class="inlineCode">std::sort</code>. A possible output of this program is shown here:</p>
<pre class="programlisting con"><code class="hljs-con">6 6 1 1 6 5 4 4 1 1
1 1 1 1 4 4 5 6 6 6
</code></pre>
<p class="normal">We first see values in the array before sorting and then applying <code class="inlineCode">std::sort</code>. We could have populated the initial array in a <code class="inlineCode">for</code> loop, but we used the opportunity to demonstrate <code class="inlineCode">std:transform</code> here.</p>
<p class="normal">These were some of<a id="_idIndexMarker377"/> the algorithms from the C++ standard library; there <a id="_idIndexMarker378"/>are many more that can be used to effectively solve common tasks in containers.</p>
<h1 class="heading-1" id="_idParaDest-111">Summary</h1>
<p class="normal">In this chapter, we covered C++ fundamentals such as namespaces, function overloading, references, and standard library containers and algorithms. We also learned how C interoperability is implemented and used in C++ programs.</p>
<p class="normal">In the next chapter, we will learn about error-handling mechanisms in C++.</p>
</div>
</body></html>