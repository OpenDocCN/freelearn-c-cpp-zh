- en: Exploring Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索函数
- en: Whenever you need to create a large application, it is a wise decision to divide
    it into manageable chunks, called **functions**. Functions are small modules that
    represent tasks that can be executed independently. The code written inside a
    function can be invoked several times, which helps to avoid repetitive statements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要创建一个大型应用程序时，将其划分为可管理的块，称为**函数**，是一个明智的决定。函数是表示可以独立执行的任务的小模块。函数内部编写的代码可以被多次调用，这有助于避免重复的语句。
- en: Functions help in the teamwork, debugging, and scaling of any application. Whenever
    you want to add more features to an application, simply add a few functions to
    it. When calling functions, the caller function may pass certain arguments, called
    **actual arguments**; these are then assigned to the parameters of the function.
    The parameters are also known as formal parameters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有助于任何应用程序的团队合作、调试和扩展。每当您想向应用程序添加更多功能时，只需向其中添加几个函数即可。在调用函数时，调用函数可能会传递某些参数，称为**实际参数**；这些参数随后被分配给函数的参数。参数也被称为形式参数。
- en: The following recipes will help you understand how functions can be used to
    make complex applications easier and more manageable. Normally, a function can
    return only a single value. But in this chapter, we will learn a technique to
    return more than one value from a function. We will also learn how to apply recursion
    in functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下食谱将帮助您了解如何使用函数使复杂的应用程序更容易管理和操作。通常，一个函数只能返回一个值。但在这章中，我们将学习一种从函数中返回多个值的技术。我们还将学习如何在函数中应用递归。
- en: 'In this chapter, we will cover the following recipes on strings:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下字符串相关的食谱：
- en: Determining whether a number is an Armstrong number
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断一个数是否是阿姆斯特朗数
- en: Returning the maximum and minimum values of an array
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回数组的最大值和最小值
- en: Finding GCD using recursion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用递归查找最大公约数（GCD）
- en: Converting a binary number into a hexadecimal number
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制数转换为十六进制数
- en: Determining whether a number is a palindrome
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断一个数是否是回文数
- en: As I will be using a stack structure in the recipes in this chapter, let's have
    a quick introduction to stack.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我将在本章的食谱中使用栈结构，让我们快速介绍一下栈。
- en: What is a stack?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是栈？
- en: 'A Stack is a structure that can be implemented with arrays as well as linked
    lists. It is a sort of a bucket where the value you enter will be added at the
    bottom. The next item that you add to a stack will be kept just above the item
    that was added previously. The procedure of adding a value to the stack is called
    a `push` operation and the procedure of getting a value out of the stack is called
    a `pop` operation. The location where the value can be added or taken out of the
    stack is pointed at by a pointer called **top**. The value of the **top** pointer
    is **-1** when the stack is empty:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种可以用数组以及链表实现的抽象数据类型。它类似于一个桶，您输入的值将被添加到桶底。您接下来添加到栈中的下一个项将位于之前添加的项之上。将值添加到栈中的过程称为`push`操作，从栈中获取值的过程称为`pop`操作。可以添加或取出值的栈位置的指针称为**top**。当栈为空时，**top**指针的值是**-1**：
- en: '![](img/34321603-bd0c-4774-bf42-a057d40dd21e.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34321603-bd0c-4774-bf42-a057d40dd21e.png)'
- en: Figure 3.1
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1
- en: 'When the `push` operation is executed, the value of **top** is incremented
    by **1**, so that it can point to the location in the stack where the value can
    be pushed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`push`操作时，**top**的值增加**1**，以便它可以指向栈中可以推入值的位置：
- en: '![](img/d24cf70f-618e-4bba-a2a9-53c433dbf139.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d24cf70f-618e-4bba-a2a9-53c433dbf139.png)'
- en: Figure 3.2
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2
- en: 'Now, the next value that will be pushed will be kept above value 1\. More precisely,
    the value of the **top** pointer will be incremented by **1**, making its value
    1, and the next value will be pushed to the **stack[1]** location, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一个将被推入的值将位于值 1 之上。更确切地说，**top**指针的值将增加**1**，使其值为 1，下一个值将被推到**stack[1]**位置，如下所示：
- en: '![](img/32a351fe-0e7f-4289-86ca-a77cddc573b3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32a351fe-0e7f-4289-86ca-a77cddc573b3.png)'
- en: Figure 3.3
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3
- en: So, you can see that the stack is a **Last In First Out** (**LIFO**) structure;
    that is, the last value that was pushed sits at the top.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到栈是一个**后进先出**（**LIFO**）结构；也就是说，最后被推入的值位于顶部。
- en: Now, when we execute a `pop` operation, the value at the top, that is, value
    **2**, will be popped out first, followed by the popping out of value **1**. Basically,
    in the `pop` operation, the value pointed at by the **top** pointer is taken out,
    and then the value of **top** is decremented by 1 so that it can point at the
    next value to be popped out.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们执行一个`pop`操作时，顶部的值，即值**2**，将被首先弹出，然后是值**1**的弹出。基本上，在`pop`操作中，由**top**指针指向的值被取出，然后**top**的值递减1，以便它可以指向下一个要弹出的值。
- en: Now, that we've understood stacks, let's begin with the first recipe.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了栈，让我们从第一个菜谱开始。
- en: Finding whether a number is an Armstrong number
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找一个数字是否是阿姆斯特朗数
- en: An Armstrong number is a three-digit integer that is the sum of the cubes of
    its digits. This simply means that if *xyz = x³+y³+z³*, it is an Armstrong number.
    For example, 153 is an Armstrong number because *1³+5³+3³ = 153*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 阿姆斯特朗数是一个三位整数，它是其各个位上数字的立方和。这简单地说，如果*xyz = x³+y³+z³*，则它是一个阿姆斯特朗数。例如，153是一个阿姆斯特朗数，因为*1³+5³+3³
    = 153*。
- en: Similarly, a number that comprises four digits is an Armstrong number if the
    sum of its digits raised to the power of four results in that number. For example, *pqrs
    = p⁴+q ⁴+r ⁴+s⁴.*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果一个数字由四个数字组成，并且其各个位上数字的四次方和等于该数字，那么这个数字就是一个阿姆斯特朗数。例如，*pqrs = p⁴+q⁴+r⁴+s⁴*。
- en: How to do it…
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Enter a number to assign to the `n` variable:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个数字分配给`n`变量：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Invoke the `findarmstrong` function. The value assigned to `n` will get passed
    to this function:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`findarmstrong`函数。分配给`n`的值将传递到这个函数：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the function, the passed argument, n, is assigned to the `numb` parameter.
    Execute a `while` loop to separate out all the digits in the `numb` parameter:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，传递的参数n被分配给`numb`参数。执行一个`while`循环来分离`numb`参数中的所有数字：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `while` loop, apply the mod 10 (`%10`) operator on the number assigned
    to the `numb` variable. The mod operator divides a number and returns the remainder:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，对分配给`numb`变量的数字应用模10（`%10`）运算符。模运算符将一个数字除以并返回余数：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Push the remainder to the stack:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数推入栈：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Remove the last digit of the number in the `numb` variable by dividing the
    `numb` variable by `10`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`numb`变量除以`10`来移除`numb`变量中的最后一位数字：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Repeat steps 4 to 6 until the number in the `numb` variable becomes 0\. In
    addition, create a `count` counter to count the number of digits in the number.
    Initialize the counter to `0` and it will get incremented during the `while` loop:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤4到6，直到`numb`变量中的数字变为0。此外，创建一个`count`计数器来计算数字中的位数。将计数器初始化为`0`，它将在`while`循环期间递增：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Pop all the digits from the stack and raise it to the given power. To pop all
    the digits from the stack, execute a `while` loop that will execute until `top`
    is greater than or equal to `0`, that is, until the stack is empty:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出栈中的所有数字，并将其提升到给定的幂。为了弹出栈中的所有数字，执行一个`while`循环，该循环将执行，直到`top`大于或等于`0`，即直到栈为空：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `while` loop, pop off a digit from the stack and raise it to the
    power of `count`, which is the count of the number of digits in the selected number.
    Then, add all the digits to the `value`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环内部，从栈中弹出一个数字，并将其提升到`count`的幂，其中`count`是所选数字的位数。然后，将这些数字加到`value`上：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compare the number in the `value` variable with the number in the `numb` variable,
    and code it to return the value of `1` if both the compared numbers match:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`value`变量中的数字与`numb`变量中的数字进行比较，如果比较的数字匹配，则返回`1`的值：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the numbers in the `numb` and `value` variables are the same, returning the
    Boolean value of `1`, that means the number is an Armstrong number.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`numb`和`value`变量中的数字相同，返回布尔值`1`，这意味着该数字是一个阿姆斯特朗数。
- en: 'Here is the `armstrong.c` program for finding out whether the specified number
    is an Armstrong number:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于找出指定数字是否为阿姆斯特朗数的`armstrong.c`程序：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's go behind the scenes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'First, we will apply the mod **10** operator to separate our digits. Assuming
    the number entered by us is **153**, you can see that **153** is divided by **10**
    and the remaining **3** is pushed to the stack:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将应用模**10**运算符来分离我们的数字。假设我们输入的数字是**153**，你可以看到**153**除以**10**，余下的**3**被推入栈中：
- en: '![](img/a36dff84-2a1a-40e4-9f6d-626f46b204c4.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a36dff84-2a1a-40e4-9f6d-626f46b204c4.png)'
- en: Figure 3.4
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4
- en: The value in the stack is pushed at the index location indicated by **top**. Initially, the
    value of **top** is -1. It is so because before the `push` operation, the value
    of **top** is incremented by 1, and the array is zero-based, that is, the first
    element in the array is placed at the 0 index location. Consequently, the value
    of **top** has to be initialized to -1\. As mentioned, the value of **top** is
    incremented by 1 before pushing, that is, the value of **top** will become **0**, and
    the remainder of **3** is pushed to **stack[0]**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 栈中的值被推入由 **top** 指示的索引位置。最初，**top** 的值是 -1。这是因为在进行 `push` 操作之前，**top** 的值增加
    1，而数组是零基的，也就是说，数组的第一个元素放置在 0 索引位置。因此，**top** 的值必须初始化为 -1。如前所述，在推入之前，**top** 的值增加
    1，即 **top** 的值将变为 **0**，余数 **3** 被推入 **stack[0]**。
- en: In the stack, the value of `top` is incremented by 1 to indicate the location
    in the stack where the value will be pushed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈中，`top` 的值增加 1，以指示将要推入栈中的值的栈位置。
- en: 'We will again apply the mod **10** operator to the **15** quotient. The remainder
    that we will get is **5**, which will be pushed to the stack. Again, before pushing
    to the stack, the value of **top**, which was 0, is incremented to 1\. At **stack[1]**,
    the remainder is pushed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次应用模 **10** 运算符到 **15** 的商上。我们将得到的余数是 **5**，它将被推入栈中。同样，在推入栈之前，**top** 的值，原本是
    0，被增加到 1。在 **stack[1]**，余数被推入：
- en: '![](img/576b0f6b-b356-4f46-af8a-6b3b92fb5aec.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/576b0f6b-b356-4f46-af8a-6b3b92fb5aec.png)'
- en: Figure 3.5
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5
- en: 'To the **1** quotient, we will again apply the mod **10** operator. But because
    1 is not divisible by **10**, **1** itself will be considered as the remainder
    and will be pushed to the stack. The value of **top** will again be incremented
    by 1 and **1** will be pushed to **stack[2]**:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **1** 的商，我们将再次应用模 **10** 运算符。但是因为 1 不能被 **10** 整除，所以 **1** 本身将被视为余数并推入栈中。`top`
    的值将再次增加 1，**1** 将被推入 **stack[2]**：
- en: '![](img/cdc5263b-c2ba-469e-a96c-2ba772e27adc.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdc5263b-c2ba-469e-a96c-2ba772e27adc.png)'
- en: Figure 3.6
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6
- en: Once all the digits are separated and placed in the stack, we will pop them
    out one by one. Then, we will raise each digit to the power equal to the count
    of the digits. Because the number **153** consists of three digits, each digit
    is raised to the power of **3**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有数字都被分离并放置在栈中，我们将逐个弹出它们。然后，我们将每个数字提升到等于数字个数的幂。因为数字 **153** 由三个数字组成，每个数字都被提升到
    **3** 的幂。
- en: 'While popping values out of the stack, the value indicated by the **top** pointer
    is popped out. The value of **top** is **2**, hence the value at **stack[2]**,
    that is, **1**, is popped out and raised to the power of **3**, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当从栈中弹出值时，由 **top** 指针指示的值被弹出。**top** 的值是 **2**，因此 **stack[2]** 中的值，即 **1**，被弹出并提升到
    **3** 的幂，如下所示：
- en: '![](img/9be5fb2b-60c5-499f-b37e-b3efae996ce6.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9be5fb2b-60c5-499f-b37e-b3efae996ce6.png)'
- en: Figure 3.7
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7
- en: 'After the `pop` operation, the value of **top** will be decremented to 1 to
    indicate the next location to be popped out. Next, the value at **stack[1]** will
    be popped out and raised to the power of **3**. We will then add this value to
    our previous popped-out one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出操作后，**top** 的值将减少到 1，以指示下一个要弹出的位置。接下来，**stack[1]** 中的值将被弹出并提升到 **3** 的幂。然后，我们将这个值添加到之前弹出的值中：
- en: '![](img/8a08cff2-e263-4875-bf5a-d251d7881b1a.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a08cff2-e263-4875-bf5a-d251d7881b1a.png)'
- en: Figure 3.8
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8
- en: 'After the popping-out operation, the value of **top** is decremented by 1,
    now making its value **0**. So, the value at **stack[0]** is popped out and raised
    to the power of **3**. The result is added to our earlier computation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出操作完成后，**top** 的值减少 1，现在其值为 **0**。因此，**stack[0]** 中的值被弹出并提升到 **3** 的幂。结果是添加到我们之前的计算中：
- en: '![](img/3bf83d80-13ee-478b-bfe3-44f7a8db459f.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bf83d80-13ee-478b-bfe3-44f7a8db459f.png)'
- en: Figure 3.9
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9
- en: The result after computing **1³ + 5³ + 3³** is **153**, which is the same as
    the original number. This proves that **153** is an Armstrong number.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 **1³ + 5³ + 3³** 的结果是 **153**，这与原始数字相同。这证明了 **153** 是一个阿姆斯特朗数。
- en: 'Let''s use GCC to compile the `armstrong.c` program, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `armstrong.c` 程序，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s check whether `127` is an Armstrong number:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `127` 是否是阿姆斯特朗数：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s check whether `153` is an Armstrong number:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `153` 是否是阿姆斯特朗数：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s check whether `1634` is an Armstrong number:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `1634` 是否是阿姆斯特朗数：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Voilà! We've successfully made a function to find whether a specified number
    is an Armstrong number or not.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功创建了一个函数来查找指定的数字是否是阿姆斯特朗数。
- en: Now, let's move on to the next recipe!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Returning maximum and minimum values in an array
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数组中返回最大和最小值
- en: C functions cannot return more than one value. But what if you want a function
    to return more than one value? The solution is to store the values to be returned
    in an array and make the function return the array instead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C 函数不能返回超过一个值。但如果你想让一个函数返回多个值怎么办？解决方案是将要返回的值存储在一个数组中，并让函数返回这个数组。
- en: In this recipe, we will make a function return two values, the maximum and minimum
    values, and store them in another array. Thereafter, the array containing the
    maximum and minimum values will be returned from the function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个函数返回两个值，即最大值和最小值，并将它们存储在另一个数组中。然后，包含最大值和最小值的数组将从函数中返回。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The size of the array whose maximum and minimum values have to be found out
    is not fixed, hence we will define a macro called `max` of size `100`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要找出最大和最小值的数组的大小不是固定的，因此我们将定义一个大小为 `100` 的宏 `max`：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will define an `arr` array of the max size, that is, `100` elements:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个最大大小的 `arr` 数组，即 `100` 个元素：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will be prompted to specify the number of elements in the array; the length
    you enter will be assigned to the `n` variable:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被提示指定数组中的元素数量；你输入的长度将被分配给 `n` 变量：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Execute a `for` loop for `n` number of times to accept `n` values for the `arr` array:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个 `for` 循环 `n` 次以接受 `arr` 数组的 `n` 个值：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Invoke the `maxmin` function to pass the `arr` array and its length, `n`, to
    it. The array that will be returned by the `maxmin` function will be assigned
    to the integer pointer, `*p`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `maxmin` 函数，将 `arr` 数组和它的长度 `n` 传递给它。`maxmin` 函数将返回的数组将赋值给整数指针 `*p`：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you look at the function definition, `int *maxmin(int ar[], int v){ }`,
    the `arr` and `n` arguments passed to the `maxmin` function are assigned to the
    `ar` and `v` parameters, respectively. In the `maxmin` function, define an `mm` array
    of two elements:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你查看函数定义 `int *maxmin(int ar[], int v){ }` 时，传递给 `maxmin` 函数的 `arr` 和 `n` 参数分别被分配给
    `ar` 和 `v` 参数。在 `maxmin` 函数中，定义一个包含两个元素的 `mm` 数组：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To compare it with the rest of the elements, the first element of `ar` array
    is stored at `mm[0]` and `mm[1]`. A loop is executed from the `1` value till the
    end of the length of the array and within the loop, the following two formulas
    are applied:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了与数组中的其余元素进行比较，将 `ar` 数组的第一元素存储在 `mm[0]` 和 `mm[1]` 中。执行一个从 `1` 值到数组长度末尾的循环，并在循环中应用以下两个公式：
- en: 'We will use `mm[0]` to store the minimum value of the `arr` array. The value
    in `mm[0]` is compared with the rest of the elements. If the value in `mm[0]`
    is greater than any of the array elements, we will assign the smaller element
    to `mm[0]`:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 `mm[0]` 来存储 `arr` 数组的最大值。`mm[0]` 中的值将与数组中的其余元素进行比较。如果 `mm[0]` 中的值大于数组中的任何元素，我们将较小的元素赋值给
    `mm[0]`：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will use `mm[1]` to store the maximum value of the `arr` array. If the value
    at `mm[1]` is found to be smaller than any of the rest of the array element, we
    will assign the larger array element to `mm[1]`:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 `mm[1]` 来存储 `arr` 数组的最大值。如果发现 `mm[1]` 的值小于数组中的任何其他元素，我们将较大的数组元素赋值给 `mm[1]`：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After the execution of the `for` loop, the `mm` array will have the minimum
    and maximum values of the `arr` array at `mm[0]` and `mm[1]`, respectively. We
    will return this `mm` array to the `main` function where the `*p` pointer is set
    to point at the returned array, `mm`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `for` 循环执行后，`mm` 数组将包含 `arr` 数组的最大和最小值，分别位于 `mm[0]` 和 `mm[1]`。我们将返回这个 `mm`
    数组到 `main` 函数，其中 `*p` 指针被设置为指向返回的数组 `mm`：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `*p` pointer will first point to the memory address of the first index
    location, that is, `mm[0]`. Then, the content of that memory address, that is,
    the minimum value of the array, is displayed. After that, the value of the `*p` pointer
    is incremented by 1 to make it point to the memory address of the next element
    in the array, that is, the `mm[1]` location:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指针 `*p` 首先将指向第一个索引位置的内存地址，即 `mm[0]`。然后，显示该内存地址的内容，即数组的最小值。之后，将 `*p` 指针的值增加 1，使其指向数组中下一个元素的内存地址，即
    `mm[1]` 位置：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `mm[1]` index location contains the maximum value of the array. Finally,
    the maximum value pointed to by the `*p` pointer is displayed on the screen:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**mm[1]**索引位置包含数组的最大值。最后，通过`*p`指针指向的最大值将在屏幕上显示：'
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `returnarray.c` program explains how an array can be returned from a function.
    Basically, the program returns the minimum and maximum values of an array:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`returnarray.c`程序解释了如何从函数中返回数组。基本上，该程序返回数组的最大值和最小值：'
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, let's go behind the scenes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will use two arrays in this recipe. The first array will contain the values
    from which the maximum and minimum values have to be found. The second array will
    be used to store the minimum and maximum values of the first array.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用两个数组。第一个数组将包含需要找到最大值和最小值的值。第二个数组将用于存储第一个数组的最小值和最大值。
- en: 'Let''s call the first array **arr** and define it to contain five elements
    with the following values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将第一个数组称为**arr**，并定义它包含以下值的五个元素：
- en: '![](img/3a4a75ea-5c7d-4df6-aea0-22b4450bdc1a.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a4a75ea-5c7d-4df6-aea0-22b4450bdc1a.png)'
- en: Figure 3.10
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10
- en: 'Let''s call our second array **mm**. The first location, **mm[0]**, of the **mm** array
    will be used for storing the minimum value and the second location, **mm[1]**,
    for storing the maximum value of the **arr** array. To enable comparison of the
    elements of the **mm** array with the elements of the **arr** array, copy the
    first element of the **arr** array at **arr[0]** to both **mm[0]** and **mm[1]**:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称我们的第二个数组为**mm**。**mm**数组的第一个位置，**mm[0]**，将用于存储最小值，第二个位置，**mm[1]**，将用于存储**arr**数组的最小值和最大值。为了使**mm**数组的元素与**arr**数组的元素进行比较，将**arr**数组的第一个元素**arr[0]**复制到**mm[0]**和**mm[1]**：
- en: '![](img/b2a64a98-5764-4b94-b97f-1d44d6889b35.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2a64a98-5764-4b94-b97f-1d44d6889b35.png)'
- en: Figure 3.11
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11
- en: 'Now, we will compare the rest of the elements of the **arr** array with **mm[0]**
    and **mm[1]**. To keep the minimum value at **mm[0]**, any element smaller than
    the value at **mm[0]** will be assigned to **mm[0]**. Values larger than **mm[0]** are
    simply ignored. For example, the value at **arr[1]** is smaller than that at **mm[0]**,
    that is, 8 < 30\. So, the smaller value will be assigned to **mm[0]**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将比较**arr**数组中剩余的元素与**mm[0]**和**mm[1]**。为了保持**mm[0]**中的最小值，任何小于**mm[0]**中值的元素将被分配给**mm[0]**。大于**mm[0]**的值将被简单地忽略。例如，**arr[1]**中的值小于**mm[0]**中的值，即8
    < 30。因此，较小的值将被分配给**mm[0]**：
- en: '![](img/01805e53-5780-46be-8208-23cff08a12e9.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01805e53-5780-46be-8208-23cff08a12e9.png)'
- en: Figure 3.12
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12
- en: We will apply reverse logic to the element at **mm[1]**. Because we want the maximum
    value of the **arr** array at **mm[1]**, any element found larger than the value
    at **mm[1]** will be assigned to **mm[1]**. All smaller values will be simply
    ignored.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对**mm[1]**中的元素应用反向逻辑。因为我们想要**arr**数组在**mm[1]**中的最大值，所以任何找到的比**mm[1]**中的值大的元素将被分配给**mm[1]**。所有较小的值将被简单地忽略。
- en: 'We will continue this process with the next element in the **arr** array, which
    is **arr[2].** Because 77 > 8, it will be ignored when compared with **mm[0]**.
    But 77 > 30, so it will be assigned to **mm[1]**:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用**arr**数组中的下一个元素进行此过程，该元素是**arr[2]**。因为77 > 8，所以当与**mm[0]**比较时将被忽略。但是77
    > 30，所以它将被分配给**mm[1]**：
- en: '![](img/90d201b4-b466-44a1-bf6d-247e6ffc3a73.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90d201b4-b466-44a1-bf6d-247e6ffc3a73.png)'
- en: Figure 3.13
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13
- en: 'We will repeat this procedure with the rest of the elements of the **arr** array.
    Once all the elements of the **arr** array are compared with both the elements
    of the **mm** array, we will have the minimum and maximum values at **mm[0]**
    and **mm[1]**, respectively:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**arr**数组的其余元素重复此过程。一旦**arr**数组的所有元素都与**mm**数组的元素进行比较，我们将在**mm[0]**和**mm[1]**中分别得到最小值和最大值：
- en: '![](img/33b2b70c-8899-4f6a-a0e5-0fcbc98cedc2.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33b2b70c-8899-4f6a-a0e5-0fcbc98cedc2.png)'
- en: Figure 3.14
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14
- en: 'Let''s use GCC to compile the `returnarray.c` program, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`returnarray.c`程序，如下所示：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is the output of the program:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Voilà! We've successfully returned the maximum and minimum values in an array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功返回了数组中的最大值和最小值。
- en: Now, let's move on to the next recipe!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Finding the greatest common divisor using recursion
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归查找最大公约数
- en: In this recipe, we will use recursive functions to find the **greatest common
    divisor** (**GCD)**, also known as the highest common factor) of two or more integers.
    The GCD is the largest positive integer that divides each of the integers. For
    example, the GCD of 8 and 12 is 4, and the GCD of 9 and 18 is 9.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用递归函数来找到两个或多个整数的最大公约数（**GCD**），也称为最大公因数。GCD 是能够整除每个整数的最大正整数。例如，8
    和 12 的 GCD 是 4，9 和 18 的 GCD 是 9。
- en: How to do it…
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The `int gcd(int x, int y)` recursive function finds the GCD of two integers,
    x and y, using the following three rules:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`int gcd(int x, int y)` 递归函数使用以下三个规则来找到两个整数 x 和 y 的最大公约数：'
- en: If y=0, the GCD of `x` and `y` is `x`.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 y=0，则 `x` 和 `y` 的最大公约数是 `x`。
- en: If x mod y is 0, the GCD of x and y is y.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 x mod y 为 0，则 x 和 y 的最大公约数是 y。
- en: Otherwise, the GCD of x and y is `gcd(y, (x mod y))`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，x 和 y 的最大公约数是 `gcd(y, (x mod y))`。
- en: 'Follow the given steps to find the GCD of two integers recursively:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤递归地找到两个整数的最大公约数：
- en: 'You will be prompted to enter two integers. Assign the integers entered to
    two variables, `u` and `v`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被提示输入两个整数。将输入的整数赋给两个变量，`u` 和 `v`：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Invoke the `gcd` function and pass the `x` and `y` values to it. The `x` and
    `y` values will be assigned to the `a` and `b` parameters, respectively. Assign
    the GCD value returned by the `gcd` function to the `g` variable:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `gcd` 函数并将 `x` 和 `y` 的值传递给它。`x` 和 `y` 的值将分别赋给 `a` 和 `b` 参数。将 `gcd` 函数返回的最大公约数值赋给
    `g` 变量：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `gcd` function, `a % b` is executed. The `%` (mod) operator divides
    the number and returns the remainder:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `gcd` 函数中，执行 `a % b`。`%`（模）运算符将数字除以并返回余数：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the remainder is non-zero, call the `gcd` function again, but this time
    the arguments will be `gcd(b,a % b)`, that is, `gcd(b,m)`, where `m` stands for
    the mod operation:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果余数是非零的，则再次调用 `gcd` 函数，但这次参数将是 `gcd(b,a % b)`，即 `gcd(b,m)`，其中 `m` 代表模运算：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If this again results in a non-zero remainder, that is, if `b % m` is non-zero,
    repeat the `gcd` function with the new values obtained from the previous execution:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这再次产生非零余数，即如果 `b % m` 是非零的，则使用从上次执行中获得的新值重复 `gcd` 函数：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the result of `b % m` is zero, `b` is the GCD of the supplied arguments
    and is returned back to the `main` function:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `b % m` 的结果是零，则 `b` 是提供的参数的最大公约数，并将其返回到 `main` 函数：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result, `b`, that is returned back to the `main` function is assigned to
    the `g` variable, which is then displayed on the screen:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `main` 函数的结果 `b` 被分配给 `g` 变量，然后显示在屏幕上：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `gcd.c` program explains how the greatest common divisor of two integers
    is computed through the recursive function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcd.c` 程序解释了如何通过递归函数计算两个整数的最大公约数：'
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, let's go behind the scenes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看背后的情况。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'Let''s assume we want to find the GCD of two integers, **18** and **24**. To
    do so, we will invoke the `gcd(x,y)` function, which in this case is `gcd(18,24)`.
    Because **24**, that is, y, is not zero, Rule 1 is not applicable here. Next,
    we will use Rule 2 to check whether `18%24` (`x % y`) is equal to **0**. Because
    **18** cannot be divided by **24**, **18** will be the remainder:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找到两个整数 **18** 和 **24** 的最大公约数。为此，我们将调用 `gcd(x,y)` 函数，在这种情况下是 `gcd(18,24)`。因为
    **24**，即 `y`，不是零，所以规则 1 在这里不适用。接下来，我们将使用规则 2 来检查 `18%24` (`x % y`) 是否等于 **0**。因为
    **18** 不能被 **24** 整除，所以 **18** 将是余数：
- en: '![](img/7b79b3f0-b216-4b53-b651-307af39db939.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b79b3f0-b216-4b53-b651-307af39db939.png)'
- en: Figure 3.15
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15
- en: 'Since the parameters of Rule 2 were also not met, we will use Rule 3\. We will
    invoke the `gcd` function with the `gcd(b,m)` argument, which is `gcd(24,18%24)`.
    Now, m stands for the mod operation. At this stage, we will again apply Rule 2
    and collect the remainder:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于规则 2 的参数也没有满足，我们将使用规则 3。我们将使用 `gcd(b,m)` 参数调用 `gcd` 函数，即 `gcd(24,18%24)`。现在，`m`
    代表模运算。在这个阶段，我们将再次应用规则 2 并收集余数：
- en: '![](img/ed70fd9d-5a89-4a58-8cf0-9ba032fc5057.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed70fd9d-5a89-4a58-8cf0-9ba032fc5057.png)'
- en: Figure 3.16
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16
- en: 'Because the result of `24%18` is a non-zero value, we will invoke the `gcd`
    function again with the `gcd(b, m)` argument, which is now `gcd(18, 24%18)`, since
    we were left with **18** and **6** from the previous execution. We will again
    apply Rule 2 to this execution. When **18** is divided by **6**, the remainder
    is **0**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `24%18` 的结果是非零值，所以我们将再次使用 `gcd(b, m)` 参数调用 `gcd` 函数，现在是 `gcd(18, 24%18)`，因为我们从上次执行中留下了
    **18** 和 **6**。我们将再次将规则 2 应用于此执行。当 **18** 除以 **6** 时，余数是 **0**：
- en: '![](img/1c063c94-df3c-496d-a531-63ec718a1bec.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c063c94-df3c-496d-a531-63ec718a1bec.png)'
- en: Figure 3.17
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17
- en: At this stage, we have finally fulfilled the requirements of one of the rules,
    Rule 2\. If you recall, Rule 2 says that if x mod y is **0**, the GCD is y. Because
    the result of **18** mod **6** is **0**, the GCD of **18** and **24** is **6**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们终于满足了规则之一，即规则2。如果你还记得，规则2说的是如果x mod y等于**0**，则最大公约数是y。因为**18** mod **6**的结果是**0**，所以**18**和**24**的最大公约数是**6**。
- en: 'Let''s use GCC to compile the `gcd.c` program, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`gcd.c`程序，如下所示：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is the output of the program:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Voilà! We've successfully found the GCD using recursion.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用递归找到了最大公约数。
- en: Now, let's move on to the next recipe!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Converting a binary number into a hexadecimal number
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将二进制数转换为十六进制数
- en: In this recipe, we will learn how to convert a binary number into a hexadecimal
    number. A binary number comprises two bits, 0 and 1\. To convert a binary number
    into a hexadecimal number, we first need to convert the binary number into a decimal
    number and then convert the resulting decimal number to hexadecimal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何将二进制数转换为十六进制数。二进制数由两个位组成，即0和1。要将二进制数转换为十六进制数，我们首先需要将二进制数转换为十进制数，然后将得到的十进制数转换为十六进制。
- en: How to do it…
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Enter a binary number and assign it to the `b` variable:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个二进制数并将其赋值给`b`变量：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Invoke the `intodecimal` function to convert the binary number into a decimal
    number, and pass the `b` variable to it as an argument. Assign the decimal number
    returned by the `intodecimal` function to the `d` variable:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`intodecimal`函数将二进制数转换为十进制数，并将`b`变量作为参数传递给它。将`intodecimal`函数返回的十进制数赋值给`d`变量：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: On looking at the `intodecimal` definition, `int intodecimal(int bin) { }`,
    we can see that the `b` argument is assigned to the `bin` parameter of the `intodecimal`
    function.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查看`intodecimal`定义`int intodecimal(int bin) { }`时，我们可以看到`b`参数被分配给`intodecimal`函数的`bin`参数。
- en: 'Separate all the binary digits and multiply them by 2 raised to the power of
    their position in the binary number. Sum the results to get the decimal equivalent.
    To separate each binary digit, we need to execute a `while` loop until the binary
    number is greater than `0`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有二进制位分开，并将它们乘以二进制数中它们的位置的`2`的幂。将结果相加以获取等效的十进制数。为了分离每个二进制位，我们需要执行一个`while`循环，直到二进制数大于`0`：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Within the `while` loop, apply the mod 10 operator on the binary number and
    push the remainder to the stack:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，对二进制数应用mod 10运算符并将余数推送到栈中：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Execute another `while` loop to get the decimal number of all the binary digits
    from the stack. The `while` loop will execute until the stack becomes empty (that
    is, until the value of `top` is greater than or equal to `0`):'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行另一个`while`循环，从栈中获取所有二进制位的十进制数。`while`循环将执行，直到栈为空（即，直到`top`的值大于或等于`0`）：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `while` loop, pop off all the binary digits from the stack and multiply
    each one by `2` raised to the power of `top`. Sum the results to get the decimal
    equivalent of the entered binary number:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，弹出栈中的所有二进制位，并将每个位乘以`2`的`top`次幂。将结果相加以获取输入二进制数的十进制等效值：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Invoke the `intohexa` function and pass the binary number and the decimal number
    to it to get the hexadecimal number:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`intohexa`函数，并将二进制数和十进制数传递给它以获取十六进制数：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Apply the mod `16` operator in the `intohexa` function on the decimal number
    to get its hexadecimal. Push the remainder that you get to the stack. Apply mod
    `16` to the quotient again and repeat the process until the quotient becomes smaller
    than `16`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`intohexa`函数中对十进制数应用mod `16`运算符以获取其十六进制数。将得到的余数推送到栈中。再次对商应用mod `16`并重复此过程，直到商小于`16`：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Pop off the remainders that are pushed to the stack to display the hexadecimal
    number:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出推送到栈中的余数以显示十六进制数：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the remainder that is popped off from the stack is less than 10, it is displayed
    as such. Otherwise, it is converted to its equivalent letter, as mentioned in
    the following table, and the resulting letter is displayed:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从栈中弹出的余数小于10，则按原样显示。否则，将其转换为等效字母，如以下表格中所述，并将结果字母显示出来：
- en: '| **Decimal** | **Hexadecimal** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **十进制** | **十六进制** |'
- en: '| 10 | A |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 10 | A |'
- en: '| 11 | B |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 11 | B |'
- en: '| 12 | C |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 12 | C |'
- en: '| 13 | D |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 13 | D |'
- en: '| 14 | E |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 14 | E |'
- en: '| 15 | F |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 15 | F |'
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `binarytohexa.c` program explains how a binary number can be converted
    into a hexadecimal number:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`binarytohexa.c`程序解释了如何将二进制数转换为十六进制数：'
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, let's go behind the scenes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first step is to convert the binary number into a decimal number. To do
    so, we will separate all the binary digits and multiply each by **2** raised to
    the power of their position in the binary number. We will then apply the mod **10** operator
    in order to separate the binary number into individual digits. Every time mod
    **10** is applied to the binary number, its last digit is separated and then pushed
    to the stack.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将二进制数转换为十进制数。为此，我们将分离所有二进制位，并将每个位乘以二进制数中其位置的**2**的幂。然后，我们将应用模**10**运算符以将二进制数分离成单独的数字。每次对二进制数应用模**10**时，其最后一个数字都会被分离并推入栈中。
- en: Let's assume that the binary number that we need to convert into a hexadecimal
    format is **110001**. We will apply the mod **10** operator to this binary number.
    The mod operator divides the number and returns the remainder. On application
    of the mod **10** operator, the last binary digit—in other words the rightmost
    digit will be returned as the remainder (as is the case with all divisions by
    **10**).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要将二进制数**110001**转换为十六进制格式。我们将对此二进制数应用模**10**运算符。模运算符将数字除以并返回余数。应用模**10**运算符后，最后一个二进制位（换句话说，最右边的位）将作为余数返回（所有除以**10**的情况都是如此）。
- en: 'The operation is pushed in the stack at the location indicated by the **top**
    pointer. The value of **top** is initially -1\. Before pushing to the stack, the
    value of **top** is incremented by 1\. So, the value of **top** increments to
    0 and the binary digit that appeared as the remainder (in this case, 1) is pushed
    to **stack[0]** (see *Figure 3.18*), and**11000** is returned as the quotient:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 操作被推入由**top**指针指示的位置。**top**的初始值为-1。在推入栈之前，**top**的值增加1。因此，**top**的值增加到0，作为余数的二进制位（在这种情况下，为1）被推入**stack[0]**（见*图3.18*），并且**11000**作为商返回：
- en: '![](img/41c50e5b-0332-4a43-a71c-9ea179a153b2.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41c50e5b-0332-4a43-a71c-9ea179a153b2.png)'
- en: Figure 3.18
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18
- en: 'We will again apply the mod **10** operator to the quotient to separate the
    last digit of the present binary number. This time, **0** will be returned as
    the remainder and **1100** as the quotient on the application of the mod **10**
    operator. The remainder is again pushed to the stack. As mentioned before, the
    value of **top** is incremented before applying the `push` operation. As the value
    of **top** was **0**, it is incremented to **1** and our new remainder, **0**,
    is pushed to **stack[1]**:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次对商应用模**10**运算符以分离当前二进制数的最后一个数字。这次，模**10**运算符将返回余数**0**和商**1100**。余数再次被推入栈中。如前所述，在应用`push`操作之前，**top**的值会增加。由于**top**的值为**0**，它增加到**1**，我们新的余数**0**被推入**stack[1]**：
- en: '![](img/3b430279-777e-44bb-8776-3919ec581aad.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b430279-777e-44bb-8776-3919ec581aad.png)'
- en: Figure 3.19
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19
- en: 'We will repeat this procedure until all the digits of the binary number are
    separated and pushed to the stack, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复此过程，直到将二进制数的所有数字分离并推入栈中，如下所示：
- en: '![](img/2f060848-a1c9-4c71-93bd-9777de3ab8fe.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f060848-a1c9-4c71-93bd-9777de3ab8fe.png)'
- en: Figure 3.20
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20
- en: Once that's done, the next step is to pop the digits out one by one and multiply
    every digit by **2** raised to the power of **top**. For example, **2** raised
    to the power of top means **2** will be raised to the value of the index location
    from where the binary digit was popped off. The value from the stack is popped
    out from the location indicated by **top**.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，下一步是逐个弹出数字，并将每个数字乘以**2**的**top**次方。例如，**2**的**top**次方意味着**2**将提升到从弹出二进制位的位置的索引值。从栈中弹出的值是从**top**指针指示的位置弹出的。
- en: 'The value of **top** is currently **5**, hence the element at **stack[5]** will
    be popped out and multiplied by **2** raised to the power **5**, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶级**的值目前为**5**，因此**stack[5]**位置的元素将被弹出并乘以**2**的**5**次方，如下所示：'
- en: '![](img/121a2a0e-4474-4fde-87ea-005350876818.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/121a2a0e-4474-4fde-87ea-005350876818.png)'
- en: Figure 3.21
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21
- en: 'After popping a value from the stack, the value of **top** is decremented by
    1 to point at the next element to be popped out. The procedure is repeated until
    every digit is popped out and multiplied by **2** raised to the power of its top
    location value. *Figure 3.19* shows how all the binary digits are popped from
    the stack and multiplied by **2** raised to the power of **top**:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从栈中弹出一个值后，`top`的值减少1，以指向下一个要弹出的元素。重复此过程，直到所有数字都被弹出并乘以**2**的**top**位置值的幂。*图3.19*显示了如何从栈中弹出所有二进制位并乘以**2**的**top**次幂：
- en: '![](img/ec5d96f3-ae58-493d-a0ba-9954d54cdb2c.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec5d96f3-ae58-493d-a0ba-9954d54cdb2c.png)'
- en: Figure 3.22
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22
- en: The resulting number we get is the decimal equivalent of the binary number that
    was entered by the user.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果是用户输入的二进制数的十进制等价数。
- en: Now, to convert a decimal number into a hexadecimal format, we will divide it
    by 16\. We need to keep dividing the number until the quotient becomes smaller
    than `16`. The remainders of the division are displayed in LIFO order. If the
    remainder is below 10, it is displayed as is; otherwise, its equivalent letter
    is displayed. You can use the preceding table to find the equivalent letter if
    you get a remainder between 10 and 15.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将十进制数转换为十六进制格式，我们将它除以16。我们需要继续除以这个数，直到商小于16。除法的余数以后进先出（LIFO）的顺序显示。如果余数小于10，则直接显示；否则，显示其等效字母。如果你得到10到15之间的余数，可以使用前面的表格来找到等效字母。
- en: 'In the following figure, you can see that the decimal number **49** is divided
    by **16**. The remainders are displayed in LIFO order to display the hexadecimal,
    hence 31 is the hexadecimal of the binary number **110001**. You don’t need to
    apply the preceding table as both the remainders are less than 10:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到十进制数**49**被除以**16**。余数以后进先出（LIFO）的顺序显示，以显示十六进制，因此31是二进制数**110001**的十六进制表示。由于余数都小于10，所以不需要应用前面的表格：
- en: '![](img/e08ed714-487a-4d7d-ae17-f20202ade8e9.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e08ed714-487a-4d7d-ae17-f20202ade8e9.png)'
- en: Figure 3.23
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23
- en: 'Let''s use GCC to compile the `binaryintohexa.c` program, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`binaryintohexa.c`程序，如下所示：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here is one output of the program:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的一个输出：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is another output of the program:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的一个输出：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Voilà! We've successfully converted a binary number into a hexadecimal number.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功将二进制数转换为十六进制数。
- en: Now, let's move on to the next recipe!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Finding whether a number is a palindrome
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找一个数是否是回文数
- en: A palindrome number is one that appears the same when read forward and backward.
    For example, 123 is not a palindrome but 737 is. To find out whether a number
    is a palindrome, we need to split it into separate digits and convert the unit
    of the original number to hundred and the hundred to unit.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 回文数是指正向和反向读取时都相同的数。例如，123不是回文数，但737是。要找出一个数是否是回文数，我们需要将其分解成单独的数字，并将原始数的个位转换为百位，百位转换为个位。
- en: 'For example, a `pqr` number will be called a **palindrome** **number** if `pqr=rqp`.
    And `pqr` will be equal to `rqp` only if the following is true:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个`pqr`数字如果`pqr=rqp`，则被称为**回文****数**。只有当以下条件成立时，`pqr`才会等于`rqp`：
- en: '*p x 100 + q x 10 + r = r x 100 + q x 10 + p*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*p x 100 + q x 10 + r = r x 100 + q x 10 + p*'
- en: In other words, we will have to multiply the digit in the unit place by 10²
    to convert it into the hundreds and convert the digit in the hundreds place to unit by
    multiplying it by 1\. If the result matches the original number, it is a palindrome.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要将个位上的数字乘以10²，将其转换为百位，然后将百位上的数字乘以1来转换为个位。如果结果与原始数字相同，那么它就是一个回文数。
- en: How to do it…
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Enter a number to assign to the `n` variable:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个数字以分配给变量`n`：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Invoke the `findpalindrome` function and pass the number in the `n` variable
    to it as an argument:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`findpalindrome`函数，并将变量`n`中的数字作为参数传递给它：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `n` argument is assigned to the `numb` parameter in the `findpalindrome`
    function. We need to separate each digit of the number; to do so, we will execute
    a `while` loop for the time the value in the `numb` variable is greater than `0`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`n`参数在`findpalindrome`函数中被分配给`numb`参数。我们需要分离数字的每一位；为此，我们将执行一个`while`循环，直到`numb`变量的值大于0：'
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Within the `while` loop, we will apply mod 10 on the number. On application
    of the mod `10` operator, we will get the remainder, which is basically the last
    digit of the number:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，我们将对数字应用模10。在应用模`10`运算符后，我们将得到余数，这实际上是数字的最后一位：
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Push that remainder to the stack:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将那个余数推入栈中：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Because the last digit of the number is separated, we need to remove the last
    digit from the existing number. That is done by dividing the number by 10 and
    truncating the fraction. The `while` loop will terminate when the number is individually
    divided into separate digits and all the digits are pushed to the stack:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为数字的最后一位被分离出来，所以我们需要从现有的数字中移除最后一位。这是通过将数字除以10并截断分数来完成的。`while`循环将在数字被单独分成各个数字并将所有数字推入栈中时终止：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The number at the top of the stack will be the hundred and the one at the bottom
    of the stack will be the unit of the original number. Recall that we need to convert
    the hundred of the original number to the unit and vice versa. Pop all the digits
    out from the stack one by one and multiply each of them by `10` raised to a power.
    The power will be 0 for the first digit that is popped off. The power will be
    incremented with every value that is popped off. After being multiplied by `10`
    raised to the respective power, the digits are added into a separate variable,
    called `value`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 栈顶的数字将是百位，而栈底的数字将是原始数字的个位。回想一下，我们需要将原始数字的百位转换为个位，反之亦然。逐个弹出栈中的所有数字，并将每个数字乘以10的幂。对于第一个弹出的数字，幂将是0。每次弹出值时，幂都会增加。在将数字乘以相应的10的幂后，这些数字被添加到一个单独的变量中，称为`value`：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the numbers in the `numb` and `value` variables match, that means the number
    is a palindrome. If the number is a palindrome, the `findpalindrome` function
    will return a value of `1`, otherwise it will return a value of `0`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`numb`和`value`变量中的数字匹配，这意味着这个数字是一个回文数。如果数字是回文数，`findpalindrome`函数将返回值`1`，否则它将返回值`0`：
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `findpalindrome.c` program determines whether the entered number is a palindrome
    number:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`findpalindrome.c`程序确定输入的数字是否是回文数：'
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, let's go behind the scenes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后发生了什么。
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's assume that the number we entered is **737**. Now, we want to know whether **737**
    is a palindrome. We will start by applying the mod **10** operator on **737**.
    On application, we will receive the remainder, **7**, and the quotient, **73**.
    The remainder, **7**, will be pushed to the stack. Before pushing to the stack,
    however, the value of the **top** pointer is incremented by 1\. The value of **top**
    is -1 initially; it is incremented to **0** and the remainder of **7** is pushed to **stack[0]** (see
    *Figure 3.21* ).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们输入的数字是**737**。现在，我们想知道**737**是否是一个回文数。我们将首先对**737**应用模**10**运算符。应用后，我们将收到余数，**7**，和商，**73**。余数，**7**，将被推入栈中。然而，在推入栈之前，**top**指针的值会增加1。**top**的初始值是-1；它增加到**0**，余数**7**被推入**stack[0]**（见*图3.21*）。
- en: 'The mod **10** operator returns the last digit of the number as the remainder.
    The quotient that we get on the application of the mod **10** operator is the
    original number with its last digit removed. That is, the quotient that we will
    get on the application of mod **10** operator on **737** is **73**:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 模**10**运算符返回数字的最后一位作为余数。应用模**10**运算符得到的商是移除最后一位的原始数字。也就是说，我们对**737**应用模**10**运算符得到的商是**73**：
- en: '![](img/bc80e6f2-d3d2-4bf0-8e3c-92e0928abec1.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc80e6f2-d3d2-4bf0-8e3c-92e0928abec1.png)'
- en: Figure 3.24
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24
- en: 'To the quotient, **73**, we will apply the mod **10** operator again. The remainder
    will be the last digit, which is **3**, and the quotient will be **7**. The value
    of **top** is incremented by 1, making its value 1, and the remainder is pushed
    to **stack[1]**. To the quotient, **7**, we will again apply the mod **10** operator.
    Because **7** cannot be divided by **10**, **7** itself is returned and is pushed
    to the stack. Again, before the `push` operation, the value of **top** is incremented
    by 1, making its value **2**. The value of **7** will be pushed to **stack[2]**:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对商，**73**，我们将再次应用模**10**运算符。余数将是最后一位，即**3**，商将是**7**。**top**的值增加1，使其值变为1，余数被推入**stack[1]**。然后，对商，**7**，我们再次应用模**10**运算符。因为**7**不能被**10**整除，所以**7**本身被返回并推入栈中。再次，在`push`操作之前，**top**的值增加1，使其值变为**2**。**7**将被推入**stack[2]**：
- en: '![](img/b73eda63-524a-41cb-8894-2edcefc99280.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b73eda63-524a-41cb-8894-2edcefc99280.png)'
- en: Figure 3.25
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25
- en: 'After separating the number into individual digits, we need to pop each digit
    from the stack one by one and multiply each one by **10** raised to a power. The
    power will be **0** for the topmost digit on the stack and will increment by 1
    after every `pop` operation. The digit that will be popped from the stack will
    be the one indicated to by the top pointer. The value of **top** is **2**, so
    the digit on **stack[2]** is popped out and is multiplied by **10** raised to
    power of **0**:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数字分解成单个数字后，我们需要逐个弹出栈中的每个数字，并将每个数字乘以 **10** 的幂。对于栈顶的数字，其幂为 **0**，每次弹出操作后，幂会增加
    1。将被弹出的数字将是顶指针指示的数字。**top** 的值为 **2**，因此 **stack[2]** 上的数字被弹出，并乘以 **10** 的 **0**
    次幂：
- en: '![](img/6bebbc2a-81ad-44d2-8aa6-00aa8fc65571.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6bebbc2a-81ad-44d2-8aa6-00aa8fc65571.png)'
- en: Figure 3.26
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26
- en: 'After every `pop` operation, the value of **top** is decremented by 1 and the
    value of the power is incremented by 1\. The next digit that will be popped out
    from the stack is the one on **stack[1]**. That is, **3** will be popped out and
    multiplied by **10** raised to the power of **1**. Thereafter, the value of **top**
    will be decremented by 1, that is, the value of **top** will become **0**, and
    the value of the power will be incremented by 1, that is, the value of the power
    that was **1** will be incremented to **2**. The digit on **stack[0] **will be
    popped out and multiplied by **10** raised to the power of **2**:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 每次弹出操作后，**top** 的值减少 1，幂的值增加 1。下一个将被弹出的数字是 **stack[1]** 上的数字。也就是说，**3** 将被弹出，并乘以
    **10** 的 **1** 次幂。之后，**top** 的值将减少 1，即 **top** 的值将变为 **0**，幂的值将增加 1，即之前为 **1**
    的幂将增加到 **2**。**stack[0]** 上的数字将被弹出，并乘以 **10** 的 **2** 次幂：
- en: '![](img/55a2916d-a8ca-41c2-9a81-8c16ab812ee1.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55a2916d-a8ca-41c2-9a81-8c16ab812ee1.png)'
- en: Figure 3.27
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27
- en: All the digits that are multiplied by **10** raised to the respective power
    are then summed. Because the result of the computation matches the original number,
    **737** is a palindrome.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所有乘以相应幂的数字然后相加。因为计算结果与原始数字匹配，**737** 是一个回文数。
- en: 'Let''s use GCC to compile the `findpalindrome.c` program, as shown in the following
    statement:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `findpalindrome.c` 程序，如下所示：
- en: '[PRE62]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s check whether `123` is a palindrome number:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `123` 是否是一个回文数：
- en: '[PRE63]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s check whether `737` is a palindrome number:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `737` 是否是一个回文数：
- en: '[PRE64]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Voilà! We've successfully determined whether a number was a palindrome.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功确定了数字是否是回文数。
