- en: Input and Collision
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和碰撞
- en: This chapter covers recipes surrounding game control input (keyboard, mouse,
    and gamepad), and collisions with obstacles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了围绕游戏控制输入（键盘、鼠标和游戏手柄）以及与障碍物碰撞的食谱。
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Axis Mappings – keyboard, mouse, and gamepad directional input for an FPS character
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轴映射 – FPS 角色的键盘、鼠标和游戏手柄方向输入
- en: Axis Mappings – normalized input
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轴映射 – 标准化输入
- en: Action Mappings – one-button responses for an FPS character
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作映射 – FPS 角色的单按钮响应
- en: Adding Axis and Action Mappings from C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C++ 添加轴和动作映射
- en: Mouse UI input handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标 UI 输入处理
- en: UMG keyboard UI shortcut keys
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMG 键盘 UI 快捷键
- en: Collision – letting objects pass through one another using Ignore
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞 – 使用 Ignore 允许对象相互穿过
- en: Collision – picking up objects using Overlap
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞 – 使用 Overlap 拾取对象
- en: Collision – preventing interpenetration using Block
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞 – 使用 Block 防止相互穿透
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Good input controls are extremely important in your game. Providing all of the
    keyboard, mouse, and especially gamepad input is going to make your game much
    more palatable to users.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的输入控制对您的游戏至关重要。提供所有键盘、鼠标，尤其是游戏手柄输入将使您的游戏对用户更具吸引力。
- en: '![](img/79860469-0fa4-4790-bc3c-53efc1f3c422.png) You can use Xbox 360 and
    PlayStation controllers on your Windows PC – they have USB input. Check your local
    electronics shops for USB game controllers to find some good ones. You can also
    use a wireless controller with the proper receiver to connect to your PC.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/79860469-0fa4-4790-bc3c-53efc1f3c422.png) 您可以在 Windows PC 上使用 Xbox
    360 和 PlayStation 控制器 – 它们具有 USB 输入。请检查您当地的电子产品商店以找到一些好的 USB 游戏控制器。您还可以使用带有适当接收器的无线控制器连接到您的
    PC。'
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用 Unreal Engine 4，并使用 Visual Studio 2017 作为 IDE。有关如何安装这两款软件及其要求的说明，请参阅本书第
    1 章，*UE4 开发工具*。
- en: Axis Mappings – keyboard, mouse, and gamepad directional input for an FPS character
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轴映射 – FPS 角色的键盘、鼠标和游戏手柄方向输入
- en: 'There are two types of input mapping: **Axis mappings** and **Action mappings**.
    Axis mappings are inputs that you hold down for an extended period of time to
    get their effect (for example, holding the *W* key to move the player forward),
    while Action mappings are one-off inputs (such as pressing the *A* button on the
    gamepad or spacebar on the keyboard to make the player jump). In this recipe,
    we''ll cover how to set up keyboard, mouse, and gamepad axis-mapped input controls
    to move an FPS character.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输入映射有两种类型：**轴映射**和**动作映射**。轴映射是您需要按住一段时间以获得其效果的输入（例如，按住 *W* 键使玩家向前移动），而动作映射是一次性输入（例如，在游戏手柄上按下
    *A* 按钮或在键盘上按下空格键使玩家跳跃）。在本食谱中，我们将介绍如何设置键盘、鼠标和游戏手柄的轴映射输入控制，以移动 FPS 角色。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must have a UE4 project, which has a main character player in it and a ground
    plane to walk on, ready for this recipe.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须有一个 UE4 项目，其中包含一个主要角色玩家和一个可以行走的地面平面，为这个食谱做好准备。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a C++ class and select `Character` as the parent class. Then, hit `Next`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 C++ 类，并将 `Character` 作为父类。然后，点击 `Next`：
- en: '![](img/9341ddb3-a54d-4733-905b-6a49fbfd43bb.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9341ddb3-a54d-4733-905b-6a49fbfd43bb.png)'
- en: 'Under the Name property, type in `Warrior`, and then click on Create Class:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名称属性下，输入 `Warrior`，然后点击创建类：
- en: '![](img/d443a1e9-8f02-4ee1-9572-4c22c0457ccb.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d443a1e9-8f02-4ee1-9572-4c22c0457ccb.png)'
- en: We will dive into doing the implementation after we do some setup inside UE4.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE4 内部进行一些设置后，我们将进行实现。
- en: 'Launch UE4 and right-click on the Warrior class. Then, select Create Blueprint
    class based on Warrior:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 UE4，右键单击“Warrior”类。然后，选择基于“Warrior”创建蓝图类：
- en: '![](img/80b8efda-da55-4d8c-a1d1-fa188e117e7f.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80b8efda-da55-4d8c-a1d1-fa188e117e7f.png)'
- en: 'From the menu that pops up, set the name to `BP_Warrior` and then select Create
    Blueprint Class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出的菜单中，将名称设置为 `BP_Warrior`，然后选择创建蓝图类：
- en: '![](img/a5161b2d-dae5-400d-aec0-9620df861b22.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5161b2d-dae5-400d-aec0-9620df861b22.png)'
- en: Close the Blueprints menu that was just opened.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭刚刚打开的蓝图菜单。
- en: 'Create and select a new Blueprint for your `GameMode` class, by going to Settings
    | Project Settings | Maps & Modes:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到设置 | 项目设置 | 地图和模式来创建并选择一个新的 `GameMode` 类的蓝图：
- en: '![](img/a5c90fe1-9f45-4ca6-b7ff-b5047325f24f.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5c90fe1-9f45-4ca6-b7ff-b5047325f24f.png)'
- en: 'Click on the + icon beside the default GameMode drop-down menu, which will
    create a new Blueprint of the `GameMode` class. Put a name of your choice (say,
    `BP_GameMode`):'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击默认 GameMode 下拉菜单旁边的 + 图标，这将创建一个 `GameMode` 类的新蓝图。为它起一个你喜欢的名字（比如 `BP_GameMode`）：
- en: '![](img/ef3f7b68-b9a3-4c57-8ef3-41a4b818ae9e.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef3f7b68-b9a3-4c57-8ef3-41a4b818ae9e.png)'
- en: Double-click the new `BP_GameMode` Blueprint class that you created to edit
    it. It can be found in the `Contents\Blueprints` folder from the Content Browser.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击你创建的新 `BP_GameMode` 蓝图类进行编辑。它可以在内容浏览器的 `Contents\Blueprints` 文件夹中找到。
- en: 'Once your `BP_GameMode` blueprint is opened, select your Blueprinted `BP_Warrior` class
    as the Default Pawn Class:'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的 `BP_GameMode` 蓝图打开，选择你的蓝图类 `BP_Warrior` 作为默认的兵种类：
- en: '![](img/264fec32-0e72-4195-8ea1-b732a7b731d8.png)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/264fec32-0e72-4195-8ea1-b732a7b731d8.png)'
- en: The location of the Default Pawn Class property.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认兵种类属性的位置。
- en: To set up the keyboard's input, which will drive the player, open Settings | Project
    Settings | Input. (Input can be found under the Engine subsection.) In the following
    steps, we will complete the process that drives the player forward in the game.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置驱动玩家的键盘输入，请打开设置 | 项目设置 | 输入。（输入可以在引擎子部分下找到。）在以下步骤中，我们将完成驱动玩家在游戏中前进的过程。
- en: 'Click on the + icon beside the Axis Mappings heading:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击轴映射标题旁边的 + 图标：
- en: '![](img/f23a8d03-3707-4ca2-9380-432bdcb8ba78.png)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/f23a8d03-3707-4ca2-9380-432bdcb8ba78.png)'
- en: Axis Mappings supports continuous (button-held) input, while Action Mappings supports
    one-off events.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 轴映射支持连续（按钮保持）输入，而动作映射支持一次性事件。
- en: Give a name to the Axis mapping. This first example will show how to move the
    player forward, so name it something like `Forward`.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给轴映射起一个名字。这个第一个例子将展示如何移动玩家前进，所以可以命名为 `Forward`。
- en: Underneath Forward, select a keyboard key to assign to this Axis mapping, such
    as *W*.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“转发”下，选择一个键盘键来分配给这个轴映射，例如 *W*。
- en: 'Click on the + icon beside Forward and select a game controller input to map
    so that you can move the player forward (such as Gamepad Left Thumbstick Up):'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“前进”旁边的 + 图标，选择一个游戏控制器输入进行映射，以便你可以移动玩家前进（例如游戏手柄左侧摇杆向上）：
- en: '![](img/eb847eef-39cf-4d97-8023-028dc25d6d52.png)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/eb847eef-39cf-4d97-8023-028dc25d6d52.png)'
- en: 'Complete Axis Mappings for Back, Left, and Right with keyboard, gamepad, and,
    optionally, mouse input bindings for each:'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用键盘、游戏手柄，以及可选的鼠标输入绑定，完成向后、向左和向右的轴映射：
- en: '![](img/58185746-bbc4-45b6-8bc1-8f2241951473.png)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/58185746-bbc4-45b6-8bc1-8f2241951473.png)'
- en: 'Now, return to the `.h` file. We will need to add some new function definitions,
    which we will be writing:'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回到 `.h` 文件。我们需要添加一些新的函数定义，我们将要编写：
- en: '[PRE0]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From your C++ code, override the `SetupPlayerInputComponent` function for the
    `AWarrior` class, as follows:'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的 C++ 代码中，为 `AWarrior` 类重写 `SetupPlayerInputComponent` 函数，如下所示：
- en: '[PRE1]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Provide a `Forward` function inside your `AWarrior` class, as follows:'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `AWarrior` 类中提供一个 `Forward` 函数，如下所示：
- en: '[PRE2]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Write and complete functions for the rest of the input directions, that is, `AWarrior::Back`,
    `AWarrior::Left`, and `AWarrior::Right`:'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其余的输入方向编写和完成函数，即 `AWarrior::Back`、`AWarrior::Left` 和 `AWarrior::Right`：
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Return to Unreal and compile your code. Afterwards, play and game and confirm
    that you can now move with both the keyboard and the left thumbstick on your gamepad:'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unreal 并编译你的代码。之后，玩游戏并确认你现在可以使用键盘和游戏手柄的左侧摇杆移动：
- en: '![](img/9ffd2ff0-6c1f-440a-8b80-6ba07b10605b.png)'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/9ffd2ff0-6c1f-440a-8b80-6ba07b10605b.png)'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The UE4 Engine allows wire-up input events directly to C++ function calls. The
    functions that are called by an input event are member functions of some class.
    In the preceding example, we routed both the pressing of the *W* key and holding
    of the gamepad's Left Thumbstick Up to the `AWarrior::Forward` C++ function. The
    instance to call `AWarrior::Forward` on is the instance that routed the controller's
    input. That is controlled by the object set as the player's avatar in the `GameMode`
    class.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: UE4 引擎允许将输入事件直接连接到 C++ 函数调用。由输入事件调用的函数是某个类的成员函数。在上面的例子中，我们将 *W* 键的按下和游戏手柄左侧摇杆向上的保持连接到了
    `AWarrior::Forward` C++ 函数。调用 `AWarrior::Forward` 的实例是路由控制器输入的实例。这由 `GameMode`
    类中设置为玩家角色的对象控制。
- en: See also
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Instead of entering the input axis bindings in the UE4 editor, you can actually
    code it in from C++. We'll describe this in detail in a later recipe, *Adding
    Axis and Action Mappings from C++.*
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你实际上可以在UE4编辑器中输入输入轴绑定，而不是用C++编写代码。我们将在后面的配方中详细描述，*从C++添加轴和动作映射*。
- en: Axis Mappings – normalized input
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轴映射 – 归一化输入
- en: As you may have noticed, inputs of 1.0 right and 1.0 forward will actually sum
    to a total of 2.0 units of speed. This means it is possible to move faster diagonally
    than it is to move in purely forward, backward, left, or right directions. What
    we really should do is clamp off any input value that results in speed in excess
    of 1.0 units while maintaining the direction of input indicated. We can do this
    by storing the previous input values and overriding the `::Tick()` function.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所注意到的，1.0向右和1.0向前的输入实际上会相加到总共2.0个单位的速度。这意味着你可以以比纯前、后、左或右方向移动更快的速度进行对角移动。我们真正应该做的是，在保持输入指示的方向的同时，限制任何导致速度超过1.0单位的输入值。我们可以通过存储先前的输入值并覆盖`::Tick()`函数来实现这一点。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work on this recipe, you must have completed the previous one with our `Warrior`
    class as we will be adding to it.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要完成这个配方，你必须完成之前的配方，其中包含我们的`Warrior`类，因为我们将在其基础上添加内容。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Go to your `Warrior.h` file and add the following property:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你的`Warrior.h`文件，并添加以下属性：
- en: '[PRE4]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will then need to initialize the variable inside of the class constructor:'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在类构造函数内部初始化变量：
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Update the `::Forward`, `::Back`, `::Right`, and `::Left` functions, as follows:'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`::Forward`、`::Back`、`::Right`和`::Left`函数，如下所示：
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `AWarrior::Tick()` function, modify the input values after normalizing
    any oversize in the input vector:'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AWarrior::Tick()`函数中，修改输入值，在归一化任何输入向量的超尺寸之后：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We normalize the input vector when it is over a magnitude of 1.0\. This constricts
    the maximum input velocity to 1.0 units (rather than 2.0 units when full up and
    full right are pressed, for example).
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当输入向量的幅度超过1.0时，我们对其进行归一化。这限制了最大输入速度为1.0单位（例如，当全按向上和向右时，为2.0单位）。
- en: Action Mappings – one-button responses for an FPS character
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作映射 – FPS角色的单键响应
- en: An Action mapping is for handling single-button pushes (not buttons that are
    held down). For buttons that should be held down, be sure to use an Axis mapping
    instead.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动作映射是用于处理单键按下的（不是按下的按钮）。对于应该按下的按钮，请确保使用轴映射。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have a UE4 project ready with the actions that you need to complete, such as
    `Jump` or `ShootGun`.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 准备好一个包含你需要完成的动作的UE4项目，例如`Jump`或`ShootGun`。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open Settings | Project Settings | Input.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开设置 | 项目设置 | 输入。
- en: 'Go to the Action Mappings heading and click on the + icon beside it:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往动作映射标题，并点击其旁边的+图标：
- en: '![](img/a65fdfd6-0f69-4512-8ba5-82d282b9e325.png)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![截图](img/a65fdfd6-0f69-4512-8ba5-82d282b9e325.png)'
- en: Start to type in the actions that should be mapped to button pushes. For example,
    type in `Jump` for the first Action.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始输入应该映射到按钮按下的动作。例如，为第一个动作输入`Jump`。
- en: Click on the arrow to the left of the action to open up the menu and then select
    a key to press for that action to occur, for example, Space Bar.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击动作左侧的箭头以打开菜单，然后选择一个按键来触发该动作，例如空格键。
- en: If you would like the same action triggered by another key push, click on the
    + beside your Action Mappings name and select another key to trigger the Action.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望另一个按键触发相同动作，请点击动作映射名称旁边的+，并选择另一个按键来触发动作。
- en: 'If you want the Shift, Ctrl, Alt, or Cmd keys to be held down for the Action
    to occur, be sure to indicate that in the checkboxes to the right of the key selection
    box:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望Shift、Ctrl、Alt或Cmd键被按下以触发动作，请确保在键选择框右侧的复选框中表明这一点：
- en: '![](img/0a79a026-ca19-4dc7-9c1c-8b274c320eff.png)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![截图](img/0a79a026-ca19-4dc7-9c1c-8b274c320eff.png)'
- en: 'To link your Action to a C++ code function, you need to override the `SetupPlayerInputComponent(UInputControl*
    control )` function. Enter the following code inside that function:'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将你的动作链接到C++代码函数，你需要覆盖`SetupPlayerInputComponent(UInputControl* control )`函数。在该函数内部输入以下代码：
- en: '[PRE8]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compile your script and play the game. Whenever you press the *spacebar*, you
    should see the player jump in the air! Refer to the following screenshot:'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的脚本并玩游戏。每次你按下空格键时，你应该看到玩家跳到空中！请参考以下截图：
- en: '![](img/2d487813-cd64-4250-a1cc-8bb083d862f8.png)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![截图](img/2d487813-cd64-4250-a1cc-8bb083d862f8.png)'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '**Action Mappings** are single-button-push events that fire off C++ code to
    run in response to them. You can define any number of actions that you wish in
    the UE4 Editor, but be sure to tie up Action Mappings to actual key pushes in
    C++.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**动作映射**是单按钮点击事件，会触发C++代码执行以响应它们。您可以在UE4编辑器中定义任何数量的动作，但请确保将动作映射与C++中的实际按键点击关联起来。'
- en: You may notice that the `Jump` function we are calling, when we use our action,
    already exists when we added a reference to it. That is because the `Character`
    class already contains an implementation for it. Note that the default implementation
    doesn't feel like a usual jump – it's more of a rise and float action.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能会注意到，当我们使用动作时调用的`Jump`函数，当我们添加对其的引用时已经存在。这是因为`Character`类已经包含了对它的实现。请注意，默认实现并不像常规跳跃那样感觉——它更像是一种上升和漂浮的动作。
- en: You can find more information on the `Character` class and the pre-built functions
    it has at [https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/ACharacter/index.html](https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/ACharacter/index.html).
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在[https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/ACharacter/index.html](https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/ACharacter/index.html)上找到有关`Character`类及其预构建函数的更多信息。
- en: See also
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can list the Actions that you want mapped from C++ code. See the following
    recipe, *Adding Axis and Action Mappings from C++*, for this.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从C++代码中列出您想要映射的动作。请参阅以下配方，*从C++添加轴和动作映射*。
- en: Adding Axis and Action Mappings from C++
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C++添加轴和动作映射
- en: Axis Mappings and Action Mappings can be added to your game via the UE4 Editor
    and is often how designers will do it, but we can also add them directly from
    C++ code. Since the connections to C++ functions is from C++ code anyway, you
    may find it more convenient to define your Axis and Action Mappings in C++ as
    well.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 轴映射和动作映射可以通过UE4编辑器添加到您的游戏中，这也是设计师通常会采用的方法，但我们也可以直接从C++代码中添加它们。由于连接到C++函数的连接本身就是从C++代码中进行的，您可能会发现将轴和动作映射定义在C++中更方便。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need a UE4 project that you'd like to add some Axis and Action mappings
    to. You can delete the existing Axis and Action mappings listed in Settings |
    Project Settings | Input if you are adding them via C++ code.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要一个UE4项目，您希望向其中添加一些轴和动作映射。如果您通过C++代码添加，可以删除在设置 | 项目设置 | 输入中列出的现有轴和动作映射。
- en: 'To add your custom Axis and Action Mappings, there are two C++ functions that
    you need to know about: `UPlayerInput::AddAxisMapping` and `UPlayerInput:: AddActionMapping`.
    These are member functions that are available on the `UPlayerInput` object. The
    `UPlayerInput` object is inside the `PlayerController` object, and is accessible
    via the following code:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '要添加您自定义的轴和动作映射，您需要了解两个C++函数：`UPlayerInput::AddAxisMapping` 和 `UPlayerInput::
    AddActionMapping`。这些是`UPlayerInput`对象上的成员函数。`UPlayerInput`对象位于`PlayerController`对象内部，可以通过以下代码访问：'
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also use the two static member functions of `UPlayerInput` to create
    your Axis and Action Mappings if you''d prefer not to access player controllers
    individually:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您不想单独访问玩家控制器，您也可以使用`UPlayerInput`的两个静态成员函数来创建您的轴和动作映射：
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To begin, we need to define our `FInputAxisKeyMapping` or `FInputActionKeyMapping`
    objects, depending on whether you are hooking up an Axis key mapping (for buttons
    that are held down for input) or an Action key mapping (for one-off-event buttons
    that are pressed once for input).
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义我们的`FInputAxisKeyMapping`或`FInputActionKeyMapping`对象，具体取决于您是连接轴键映射（用于按下的输入按钮）还是动作键映射（用于一次性事件按钮，按下一次用于输入）。
- en: 'To use either of the following classes, we will need to include the following
    `.h` file:'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用以下任一类，我们需要包含以下`.h`文件：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For Axis key mappings, we define an `FInputAxisKeyMapping` object, as follows:'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于轴键映射，我们定义一个`FInputAxisKeyMapping`对象，如下所示：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will include the string name for the action, the key to press (use the
    EKeys `enum`), and whether or not *Shift*, *Ctrl*, *Alt*, or *cmd* (Mac) should
    be held to trigger the event.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将包括动作的字符串名称、要按下的键（使用EKeys `枚举`），以及是否需要按住*Shift*、*Ctrl*、*Alt*或*cmd*（Mac）来触发事件。
- en: 'For action key mappings, define `FInputActionKeyMapping`, as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于动作键映射，定义`FInputActionKeyMapping`，如下所示：
- en: '[PRE13]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will include the string name for the action, the key to press, and whether
    or not *Shift*, *Ctrl*, *Alt*, or *cmd* (Mac) should be held to trigger the event.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将包括动作的字符串名称、要按下的键，以及是否需要按住*Shift*、*Ctrl*、*Alt*或*cmd*（Mac）来触发事件。
- en: 'In your player `Pawn` class''s `SetupPlayerInputComponent` function, register
    your Axis and Action key mappings to the following:'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的玩家`Pawn`类的`SetupPlayerInputComponent`函数中，将你的轴和动作键映射注册到以下内容：
- en: 'The `PlayerInput` object connected to a specific controller:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到特定控制器的`PlayerInput`对象：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, you could register to the static member functions of the `UPlayerInput`
    object directly:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，你可以直接注册到`UPlayerInput`对象的静态成员函数：
- en: '[PRE15]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ensure that you're using the correct function for Axis versus Action Mappings!
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你使用的是轴映射和动作映射的正确函数！
- en: 'Register your Action and Axis Mappings to C++ functions using C++ code, just
    like we did in the preceding two recipes, for example:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C++代码，就像我们在前面的两个菜谱中所做的那样，将你的动作和轴映射注册到C++函数中，例如：
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Action and Axis Mapping registration functions allow you to set up your
    input mappings from C++ code directly. The C++ coded input mappings are essentially
    the same as entering the input mappings in the Settings | Project Settings | Input
    dialog.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动作和轴映射注册函数允许你直接从C++代码设置输入映射。C++编码的输入映射基本上与在设置 | 项目设置 | 输入对话框中输入输入映射相同。
- en: Mouse UI input handling
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标UI输入处理
- en: When using the **Unreal Motion Graphics** (**UMG**) toolkit, you will find that
    mouse events are very easy to handle. We can register C++ functions to run after
    mouse clicks or other types of interactions with the UMG components.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用**Unreal运动图形**（**UMG**）工具包时，你会发现鼠标事件处理非常简单。我们可以将C++函数注册为在鼠标点击或其他类型的UMG组件交互后运行。
- en: Usually, event registration will be via Blueprints; however, in this recipe,
    we will outline how to write and wire up C++ functions to UMG events.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，事件注册将通过蓝图进行；然而，在这个菜谱中，我们将概述如何编写和连接C++函数到UMG事件。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: Create a UMG canvas in your UE4 project. From there, we'll register event handlers
    for the `OnClicked`, `OnPressed`, and `OnReleased` events.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的UE4项目中创建一个UMG画布。从那里，我们将为`OnClicked`、`OnPressed`和`OnReleased`事件注册事件处理器。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Right-click in your Content Browser (or click on Add New) and select User Interface
    | Widget Blueprint, as shown in the following screenshot. This will add an editable
    widget blueprint to your project:'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的内容浏览器中右键单击（或点击添加新内容），然后选择用户界面 | 小部件蓝图，如图所示。这将向你的项目添加一个可编辑的小部件蓝图：
- en: '![](img/451daeed-ffb0-4715-9eea-28085c8b1096.png)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/451daeed-ffb0-4715-9eea-28085c8b1096.png)'
- en: Double-click on your Widget Blueprint to edit it.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击你的小部件蓝图进行编辑。
- en: 'Add a button to the interface by dragging it from the palette on the left:'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从左侧的调色板拖动来向界面添加一个按钮：
- en: '![](img/4bd1c07c-a8bd-493a-95f6-db057cb0b315.png)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/4bd1c07c-a8bd-493a-95f6-db057cb0b315.png)'
- en: Scroll down the Details panel for your button until you find the Events subsection.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的详细信息面板向下滚动，直到找到事件子部分。
- en: 'Click on the + icon beside any event that you''d like to handle:'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击你想要处理的事件旁边的+图标：
- en: '![](img/b0d70320-f08a-4d4d-80e5-b026be6eeb6c.png)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/b0d70320-f08a-4d4d-80e5-b026be6eeb6c.png)'
- en: 'Connect the event that appears in Blueprints to any C++ `UFUNCTION()` that
    has the `BlueprintCallable` tag in the macro. For example, in your `GameModeBase`
    class derivative, you could include a function such as the following one:'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在蓝图中出现的事件连接到任何具有`BlueprintCallable`标记的C++ `UFUNCTION()`。例如，在你的`GameModeBase`类派生中，你可以包含如下函数：
- en: '[PRE17]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Trigger the function call by routing to it in the Blueprint diagram under the
    event of your choice. For example, I used the `OnClick` function. Once created,
    I used the Get Game Mode node to get our current game mode and then `Cast to Chapter06_GameModeBase`
    to gain access to the `ButtonClicked` function:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在蓝图图中的选择事件下路由到它来触发函数调用。例如，我使用了`OnClick`函数。一旦创建，我使用了获取游戏模式节点来获取我们当前的游戏模式，然后`Cast
    to Chapter06_GameModeBase`来访问`ButtonClicked`函数：
- en: '![](img/8f4f3430-4d15-4359-ad22-e5abb7091743.png)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/8f4f3430-4d15-4359-ad22-e5abb7091743.png)'
- en: Note that for this to work, ensure that you have set the Game Mode for the level/project
    as `Chapter_06GameModeBase`.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，为了使这生效，确保你已将级别/项目的游戏模式设置为`Chapter_06GameModeBase`。
- en: Construct and display your UI by calling Create Widget, followed by Add to Viewport
    in the `BeginPlay` function of your `GameModeBase` (or any such main object) or
    through the Level Blueprint.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`GameModeBase`（或任何此类主对象）的`BeginPlay`函数中调用`Create Widget`，然后添加到视图中，构建并显示你的UI。或者，通过级别蓝图进行：
- en: 'To do this via C++, you''ll need to go to the `Chapter_06.Build.cs` file and
    modify the following line:'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要通过C++这样做，你需要转到`Chapter_06.Build.cs`文件并修改以下行：
- en: '[PRE18]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Afterwards, add the following property and function to the `Chapter_06GameModeBase.h`
    file:'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将以下属性和函数添加到 `Chapter_06GameModeBase.h` 文件中：
- en: '[PRE19]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, update the C++ file:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新 C++ 文件：
- en: '[PRE20]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we need to set Widget to our created menu. To do that, from the Content
    Browser, right-click on the `Chapter06_GameModeBase` from the C++ `Classes\Chapter_06`
    folder and create a new Blueprint from it. Once at the Blueprints menu, go to
    the Details tab and under the UI section, set the Widget to the item you wish
    to display:'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将小部件设置到我们创建的菜单中。为此，从内容浏览器中，在 C++ `Classes\Chapter_06` 文件夹中的 `Chapter06_GameModeBase`
    上右键单击，并从中创建一个新的蓝图。一旦进入蓝图菜单，转到详细信息选项卡，在 UI 部分，将小部件设置为你要显示的项目：
- en: '![](img/a99bff0f-a8cb-43ef-b2a6-c9cfb004d3ef.png)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/a99bff0f-a8cb-43ef-b2a6-c9cfb004d3ef.png)'
- en: 'Finally, go to Settings | World Settings. From there, change the Game Mode
    Override to your Blueprint version of the GameMode:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，转到设置 | 世界设置。从那里，将游戏模式覆盖更改为你的游戏模式蓝图版本：
- en: '![](img/1a52c677-c0a4-4edd-95a3-ca9712391c4a.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/1a52c677-c0a4-4edd-95a3-ca9712391c4a.png)'
- en: Then, open the Output Log by going to Window | Developer Tools | Output Log
    and then play the game. You should see the button displayed on your screen. If
    you click on it, you should see a message displayed on the Output Log!
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过转到窗口 | 开发者工具 | 输出日志来打开输出日志，并开始游戏。你应该在屏幕上看到按钮。如果你点击它，你应该在输出日志中看到一个消息显示！
- en: '![](img/60719194-7e50-46ce-961f-af9231f654a5.png)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/60719194-7e50-46ce-961f-af9231f654a5.png)'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Your widget's Blueprint button events can be easily connected to Blueprint events,
    or C++ functions by creating  a `UFUNCTION()` that has the `BlueprintCallable` tag
    in the macro.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的小部件蓝图按钮事件可以轻松连接到蓝图事件或 C++ 函数，通过创建一个带有 `BlueprintCallable` 标签的 `UFUNCTION()`
    来实现：
- en: For more information on using UMG and building simple menus and displaying them
    using Blueprints, check out [https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/CreatingWidgets](https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/CreatingWidgets).
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于使用 UMG 和构建简单菜单以及使用蓝图显示它们的信息，请查看[https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/CreatingWidgets](https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/CreatingWidgets)。
- en: UMG keyboard UI shortcut keys
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG 键盘 UI 快捷键
- en: Every user interface needs shortcut keys associated with it. To program these
    into your UMG interface, you can simply wire up certain key combinations to an
    Action Mapping. When the Action triggers, just invoke the same Blueprints function
    that the UI button itself triggers.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个用户界面都需要与之关联的快捷键。要将这些编程到你的 UMG 界面中，你可以简单地连接某些键组合到一个动作映射中。当动作触发时，只需调用 UI 按钮本身触发的相同蓝图函数。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a UMG interface created already, as shown in the previous recipe.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该已经创建了一个 UMG 界面，如前一个菜谱所示。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In Settings | Project Settings | Input, define a new Action Mapping for your
    hot key event, for example, `HotKey_UIButton_Spell`:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置 | 项目设置 | 输入中，为你的热键事件定义一个新的动作映射，例如，`HotKey_UIButton_Spell`：
- en: '![](img/70e3025e-174f-4ae7-8be2-139b9ae12850.png)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/70e3025e-174f-4ae7-8be2-139b9ae12850.png)'
- en: 'Wire up the event to your UI''s function call either in Blueprints or in C++
    code. In our case, I will add it to the `AWarrior` class we created previously
    by adding it to the `SetupPlayerInputComponent` function:'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图或 C++ 代码中将事件连接到你的 UI 函数调用。在我们的例子中，我将将其添加到我们之前创建的 `AWarrior` 类中，通过将其添加到 `SetupPlayerInputComponent`
    函数中：
- en: '[PRE21]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile your script and then open the World Settings by going to Settings |
    World Settings. Under Selected GameMode, set the Default Pawn Class to `BP_Warrior`.
    You should now notice that you can either press your key or press the button to
    execute the `ButtonClicked` function we created in the previous recipe!
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的脚本，然后通过转到设置 | 世界设置来打开世界设置。在所选游戏模式下，将默认兵种类设置为 `BP_Warrior`。你现在应该注意到，你可以按你的键或按按钮来执行我们在上一个菜谱中创建的
    `ButtonClicked` 函数！
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Wiring up an Action Mapping with a short circuit to the function that's called
    by the UI will allow you to implement hot keys in your game program nicely.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将动作映射连接到由 UI 调用的函数的短路，这将允许你在游戏程序中优雅地实现热键。
- en: Collision – letting objects pass through one another using Ignore
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞 - 使用忽略让对象相互穿过
- en: 'Collision settings are fairly easy to get started with. There are three classes
    of intersection for collisions:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 碰撞设置相对容易入门。碰撞有三个交集类别：
- en: '`Ignore`: Collisions that pass through each other without any notification.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`忽略`：没有任何通知就相互穿过的碰撞。'
- en: '`Overlap`: Collisions that trigger the `OnBeginOverlap` and `OnEndOverlap`
    events. Interpenetration of objects with an `Overlap` setting is allowed.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Overlap`：触发`OnBeginOverlap`和`OnEndOverlap`事件的碰撞。具有`Overlap`设置的物体之间的相互穿透是允许的。'
- en: '`Block`: Collisions that prevent all interpenetration, and prevent objects
    from overlapping each other at all.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Block`：防止所有相互穿透的碰撞，并防止物体相互重叠。'
- en: Objects are classed into one of many Object Types. The Collision settings for
    a particular Blueprint's Component allow you to class the object as an Object
    Type of your choice, as well as specify how that object collides with all other
    objects of all other types. This takes a tabular format in the Details | Collision
    section of the Blueprint Editor.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 物体被分类为许多对象类型之一。特定蓝图组件的碰撞设置允许您将对象分类为所选的对象类型，并指定该对象如何与其他所有类型的所有对象碰撞。这在蓝图编辑器的详细信息
    | 碰撞部分以表格格式表示。
- en: 'For example, the following screenshot shows the Collision settings for a character''s
    `CapsuleComponent`:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，以下截图显示了角色的`CapsuleComponent`的碰撞设置：
- en: '![](img/e187ec4e-1e2f-4603-8cf9-b4eddcf6ae3c.png)'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/e187ec4e-1e2f-4603-8cf9-b4eddcf6ae3c.png)'
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a UE4 project with some objects that you'd like to program intersections
    for.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该有一个UE4项目，其中包含一些您想要编程交叉的对象。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open the Blueprint Editor for the object that you'd like other objects to simply
    pass through and ignore. Under the Components listing, select the component that
    you'd like to program settings for.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您希望其他对象简单地穿过并忽略的对象的蓝图编辑器。在组件列表下，选择您想要编程设置的组件。
- en: 'With your component selected, see your Details tab (usually on the right).
    Under Collision Presets, select either the NoCollision or Custom... presets:'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择了组件后，查看您的详细信息标签页（通常位于右侧）。在碰撞预设下，选择“无碰撞”或“自定义...”预设：
- en: If you select the NoCollision preset, you can just leave it at that, and all
    collisions will be ignored.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您选择“无碰撞”预设，您可以直接保留它，并且所有碰撞都将被忽略。
- en: 'If you select the Custom... preset, then choose either of the following:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您选择“自定义...”预设，则可以选择以下任一项：
- en: NoCollision under the Collision Enabled drop-down menu.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“碰撞启用”下拉菜单中选择“无碰撞”。
- en: Select a collision mode under Collision Enabled involving Queries, and be sure
    to check the Ig
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“碰撞启用”下选择一个涉及查询的碰撞模式，并确保勾选忽略选项。
- en: nore checkbox for each Object Type that you'd like it to ignore collisions with.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您想要忽略碰撞的每个对象类型勾选忽略复选框。
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ignored collisions will not fire any events or prevent interpenetrations between
    objects marked as such. Note that if Object A is set to ignore Object B, it does
    not matter whether Object B is set to ignore Object A or not. They will ignore
    each other as long as one of them is set to ignore the other.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被忽略的碰撞不会触发任何事件或阻止标记为这样的对象之间的相互穿透。请注意，如果对象A被设置为忽略对象B，则无论对象B是否被设置为忽略对象A，都没有关系。只要其中之一被设置为忽略另一个，它们就会相互忽略。
- en: Collision – picking up objects using Overlap
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞 - 使用Overlap拾取对象
- en: Item pickup is a pretty important thing to do cleanly. In this recipe, we'll
    outline how to get item pickups working using Overlap events on Actor Component
    primitives.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有效地进行物品拾取是一项相当重要的事情。在本配方中，我们将概述如何使用Actor Component原语的Overlap事件来实现物品拾取。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The previous recipe, *Collisions – Letting objects pass through each other using
    Ignore*, describes the basics of collisions. You should read it for background
    before beginning this recipe. What we'll do here is create a New Object Channel...
    to identify `Item` class objects so that they can be programmed for overlaps,
    but only with the player avatar's collision volume.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的配方，“碰撞 - 使用忽略让对象相互穿过”描述了碰撞的基础。在开始此配方之前，您应该阅读它作为背景知识。我们在这里要创建一个新的对象通道...来识别“物品”类对象，以便它们可以被编程为重叠，但仅与玩家角色的碰撞体积重叠。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Start by creating a unique collision Channel for the `Item` object''s collision
    primitive. This is under Settings | Project Settings | Collision:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为“物品”对象的碰撞原语创建一个唯一的碰撞通道。这位于设置 | 项目设置 | 碰撞：
- en: '![](img/1c91758c-6e3b-454b-932d-0fa3f8e59e4a.png)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/1c91758c-6e3b-454b-932d-0fa3f8e59e4a.png)'
- en: Once there, create a new Object Channel by going to New Object Channel....
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到达那里后，通过转到“新建对象通道...”创建一个新的对象通道。
- en: 'Name the new Object Channel `Item` and set the Default Response to Overlap.
    Afterwards, hit the Accept button:'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的对象通道命名为“物品”并将默认响应设置为Overlap。之后，点击接受按钮：
- en: '![](img/aa9ee232-de0e-4b2b-8900-1910ce95c00d.png)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/aa9ee232-de0e-4b2b-8900-1910ce95c00d.png)'
- en: Take your `Item` actor and select the primitive component on it that is used
    to intersect for pickup with the player avatar. From the Details tab, go to the
    Collision section and under Collision Presets, change the option to Custom....
    Afterwards, set the Object Type of that primitive to `Item`.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的`Item`角色，并选择用于与玩家头像拾取相交的原始组件。从详细信息选项卡转到碰撞部分，在碰撞预设下，将选项更改为自定义...之后，将那个原始组件的对象类型设置为`Item`。
- en: 'Check the Overlap checkbox against the `Pawn` class Object Type, as shown in
    the following screenshot:'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，勾选`Pawn`类对象类型的重叠复选框：
- en: '![](img/37f20568-fa11-4711-baca-e6b1b0f521ed.png)'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/37f20568-fa11-4711-baca-e6b1b0f521ed.png)'
- en: 'Ensure that the Generate Overlap Events checkbox is checked:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已勾选生成重叠事件复选框：
- en: '![](img/21f4abc7-1789-47a8-98ef-99654ed333d0.png)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/21f4abc7-1789-47a8-98ef-99654ed333d0.png)'
- en: Location of the Generate Overlap Events property.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成重叠事件属性的定位。
- en: 'Take the player actor who will pick up the items (BP_Warrior for this example)
    and select the component on them that feels for the items. Usually, this will
    be their `CapsuleComponent`. Check Overlap with the `Item` object:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择将拾取物品的玩家角色（例如，本例中的BP_Warrior）并选择其上用于检测物品的组件。通常，这将是其`CapsuleComponent`。检查与`Item`对象的重叠：
- en: '![](img/c1a57159-25c1-4944-9692-917dd14f30ea.png)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/c1a57159-25c1-4944-9692-917dd14f30ea.png)'
- en: Now, the Player overlaps the item, and the item overlaps the player pawn. We
    do have to signal overlaps both ways (`Item` overlaps `Pawn` and `Pawn` Overlaps
    `Item`) for it to work properly. Ensure that Generate Overlap Events is also checked
    for the `Pawn` intersecting component.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，玩家与物品重叠，物品与玩家角色重叠。我们必须在两个方向上发出重叠信号（`Item`重叠`Pawn`和`Pawn`重叠`Item`），以便它能够正常工作。确保为`Pawn`相交组件也勾选了生成重叠事件。
- en: 'Next, we have to complete the `OnComponentBeginOverlap` event for either the
    item or the Player''s pickup volume, using either Blueprints or C++ code:'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须使用蓝图或C++代码完成物品或玩家拾取体积的`OnComponentBeginOverlap`事件：
- en: 'If you prefer Blueprints, in the Events section of the Details pane of the
    Items''s intersectable Component, click on the + icon beside the On Component
    Begin Overlap event:'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你更喜欢蓝图，在物品的可相交组件的详细信息窗格的事件部分，点击`On Component Begin Overlap`事件旁边的+图标：
- en: '![](img/6dee9413-e593-4c0a-922e-71eab50057a9.png)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/6dee9413-e593-4c0a-922e-71eab50057a9.png)'
- en: Use the `OnComponentBeginOverlap` event that appears in your `Actor` Blueprint
    diagram to wire in Blueprints code to run when an overlap with the Player's capsule
    volume occurs.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用出现在你的`Actor`蓝图图中的`OnComponentBeginOverlap`事件，将蓝图代码连接到当与玩家的胶囊体积发生重叠时运行。
- en: 'If you prefer C++, you can write and attach a C++ function to the `CapsuleComponent`.
    Write a member function in your player''s `Character` class (for example, the
    `Warrior.h` file) with a signature, as follows:'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你更喜欢C++，你可以为`CapsuleComponent`编写并附加一个C++函数。在你的玩家`Character`类（例如，`Warrior.h`文件）中编写一个成员函数，其签名如下：
- en: '[PRE22]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Complete the implementation of the `OnOverlapsBegin()` function in your `.cpp`
    file, making sure to end the function name with `_Implementation`:'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`.cpp`文件中完成`OnOverlapsBegin()`函数的实现，确保函数名以`_Implementation`结尾：
- en: '[PRE23]'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, provide a `PostInitializeComponents()` override to connect the `OnOverlapsBegin()`
    function with overlaps to the capsule in your avatar''s class, as follows:'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为你的头像类提供一个`PostInitializeComponents()`重写，将`OnOverlapsBegin()`函数与重叠连接到胶囊，如下所示：
- en: '[PRE24]'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compile your script and then run your project. You should see log messages
    when you enter and leave the object! Refer to the following screenshot:'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的脚本，然后运行你的项目。当你进入和离开对象时，你应该会看到日志消息！请参考以下截图：
- en: '![](img/98a6d7a0-dcf9-4da6-bc7b-50f130efa029.png)'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/98a6d7a0-dcf9-4da6-bc7b-50f130efa029.png)'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Overlap event that's raised by the engine allows code to run when two UE4
    `Actor` Components overlap, without preventing interpenetration of the objects.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引擎引发的Overlap事件允许代码在两个UE4 `Actor`组件重叠时运行，而不阻止对象的穿透。
- en: Collision – preventing interpenetration using Block
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞 - 使用阻塞防止穿透
- en: Blocking means that the `Actor` components will be prevented from interpenetration
    in the engine, and any collision between two primitive shapes will be resolved,
    and not overlapping, after collisions are found.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 阻塞意味着`Actor`组件在引擎中将被阻止穿透，并且任何两个原始形状之间的碰撞将在发现碰撞后解决，而不是重叠。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Begin with a UE4 project that has some objects with Actors that have collision
    primitives attached to them (`SphereComponents`, `CapsuleComponents`, or `BoxComponents`).
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从一个具有一些对象且这些对象有附加碰撞原始形状的演员的 UE4 项目开始（`SphereComponents`、`CapsuleComponents`
    或 `BoxComponents`）。
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the Blueprint of an actor that you want to block another actor with. For
    example, we want the Player actor to block other Player actor instances.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你想要阻止另一个演员的演员的蓝图。例如，我们想要玩家演员阻止其他玩家演员实例。
- en: 'Mark primitives inside the actor that you do not want interpenetrating with
    other components as blocking those components in the Details pane:'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你不想与其他组件发生穿透的原始形状标记在演员中，这样就可以在“详细信息”面板中阻止这些组件：
- en: '![](img/15215060-daac-41c6-a9db-c7b95e1be796.png)'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/15215060-daac-41c6-a9db-c7b95e1be796.png)'
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When objects b
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当对象 b
- en: lock one another, they will not be allowed to interpenetrate. Any interpenetration
    will be automatically resolved, and the objects will be pushed off each other. This
    is one of the details that often causes lots of headaches. For objects to actually
    block each other, they both have to be set to block.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果两个对象相互锁定，它们将不允许相互穿透。任何穿透都将自动解决，并且对象将被推开。这是经常引起许多头疼的问题之一。为了实际阻止彼此的对象，它们都必须设置为阻止。
- en: 'For more information, check out the official UE4 blog post on the subject:
    [https://www.unrealengine.com/en-US/blog/collision-filtering](https://www.unrealengine.com/en-US/blog/collision-filtering).'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息，请查看官方 UE4 博客文章：[https://www.unrealengine.com/en-US/blog/collision-filtering](https://www.unrealengine.com/en-US/blog/collision-filtering)。
- en: There's more...
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can override the `OnComponentHit` function to run code when two objects
    hit each other. This is distinct from the `OnComponentBeginOverlap` event.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以覆盖 `OnComponentHit` 函数，以便在两个对象相撞时运行代码。这与 `OnComponentBeginOverlap` 事件不同。
