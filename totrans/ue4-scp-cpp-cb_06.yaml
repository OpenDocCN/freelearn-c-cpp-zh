- en: Input and Collision
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers recipes surrounding game control input (keyboard, mouse,
    and gamepad), and collisions with obstacles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Axis Mappings – keyboard, mouse, and gamepad directional input for an FPS character
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axis Mappings – normalized input
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action Mappings – one-button responses for an FPS character
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Axis and Action Mappings from C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse UI input handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UMG keyboard UI shortcut keys
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision – letting objects pass through one another using Ignore
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision – picking up objects using Overlap
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision – preventing interpenetration using Block
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good input controls are extremely important in your game. Providing all of the
    keyboard, mouse, and especially gamepad input is going to make your game much
    more palatable to users.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79860469-0fa4-4790-bc3c-53efc1f3c422.png) You can use Xbox 360 and
    PlayStation controllers on your Windows PC – they have USB input. Check your local
    electronics shops for USB game controllers to find some good ones. You can also
    use a wireless controller with the proper receiver to connect to your PC.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Axis Mappings – keyboard, mouse, and gamepad directional input for an FPS character
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of input mapping: **Axis mappings** and **Action mappings**.
    Axis mappings are inputs that you hold down for an extended period of time to
    get their effect (for example, holding the *W* key to move the player forward),
    while Action mappings are one-off inputs (such as pressing the *A* button on the
    gamepad or spacebar on the keyboard to make the player jump). In this recipe,
    we''ll cover how to set up keyboard, mouse, and gamepad axis-mapped input controls
    to move an FPS character.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must have a UE4 project, which has a main character player in it and a ground
    plane to walk on, ready for this recipe.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a C++ class and select `Character` as the parent class. Then, hit `Next`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9341ddb3-a54d-4733-905b-6a49fbfd43bb.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Under the Name property, type in `Warrior`, and then click on Create Class:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d443a1e9-8f02-4ee1-9572-4c22c0457ccb.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: We will dive into doing the implementation after we do some setup inside UE4.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch UE4 and right-click on the Warrior class. Then, select Create Blueprint
    class based on Warrior:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/80b8efda-da55-4d8c-a1d1-fa188e117e7f.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'From the menu that pops up, set the name to `BP_Warrior` and then select Create
    Blueprint Class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a5161b2d-dae5-400d-aec0-9620df861b22.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Close the Blueprints menu that was just opened.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create and select a new Blueprint for your `GameMode` class, by going to Settings
    | Project Settings | Maps & Modes:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a5c90fe1-9f45-4ca6-b7ff-b5047325f24f.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Click on the + icon beside the default GameMode drop-down menu, which will
    create a new Blueprint of the `GameMode` class. Put a name of your choice (say,
    `BP_GameMode`):'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ef3f7b68-b9a3-4c57-8ef3-41a4b818ae9e.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Double-click the new `BP_GameMode` Blueprint class that you created to edit
    it. It can be found in the `Contents\Blueprints` folder from the Content Browser.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once your `BP_GameMode` blueprint is opened, select your Blueprinted `BP_Warrior` class
    as the Default Pawn Class:'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/264fec32-0e72-4195-8ea1-b732a7b731d8.png)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The location of the Default Pawn Class property.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To set up the keyboard's input, which will drive the player, open Settings | Project
    Settings | Input. (Input can be found under the Engine subsection.) In the following
    steps, we will complete the process that drives the player forward in the game.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the + icon beside the Axis Mappings heading:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f23a8d03-3707-4ca2-9380-432bdcb8ba78.png)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Axis Mappings supports continuous (button-held) input, while Action Mappings supports
    one-off events.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Give a name to the Axis mapping. This first example will show how to move the
    player forward, so name it something like `Forward`.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath Forward, select a keyboard key to assign to this Axis mapping, such
    as *W*.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the + icon beside Forward and select a game controller input to map
    so that you can move the player forward (such as Gamepad Left Thumbstick Up):'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eb847eef-39cf-4d97-8023-028dc25d6d52.png)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Complete Axis Mappings for Back, Left, and Right with keyboard, gamepad, and,
    optionally, mouse input bindings for each:'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/58185746-bbc4-45b6-8bc1-8f2241951473.png)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, return to the `.h` file. We will need to add some new function definitions,
    which we will be writing:'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From your C++ code, override the `SetupPlayerInputComponent` function for the
    `AWarrior` class, as follows:'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Provide a `Forward` function inside your `AWarrior` class, as follows:'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Write and complete functions for the rest of the input directions, that is, `AWarrior::Back`,
    `AWarrior::Left`, and `AWarrior::Right`:'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Return to Unreal and compile your code. Afterwards, play and game and confirm
    that you can now move with both the keyboard and the left thumbstick on your gamepad:'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9ffd2ff0-6c1f-440a-8b80-6ba07b10605b.png)'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: The UE4 Engine allows wire-up input events directly to C++ function calls. The
    functions that are called by an input event are member functions of some class.
    In the preceding example, we routed both the pressing of the *W* key and holding
    of the gamepad's Left Thumbstick Up to the `AWarrior::Forward` C++ function. The
    instance to call `AWarrior::Forward` on is the instance that routed the controller's
    input. That is controlled by the object set as the player's avatar in the `GameMode`
    class.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of entering the input axis bindings in the UE4 editor, you can actually
    code it in from C++. We'll describe this in detail in a later recipe, *Adding
    Axis and Action Mappings from C++.*
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Axis Mappings – normalized input
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have noticed, inputs of 1.0 right and 1.0 forward will actually sum
    to a total of 2.0 units of speed. This means it is possible to move faster diagonally
    than it is to move in purely forward, backward, left, or right directions. What
    we really should do is clamp off any input value that results in speed in excess
    of 1.0 units while maintaining the direction of input indicated. We can do this
    by storing the previous input values and overriding the `::Tick()` function.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: To work on this recipe, you must have completed the previous one with our `Warrior`
    class as we will be adding to it.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to your `Warrior.h` file and add the following property:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will then need to initialize the variable inside of the class constructor:'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Update the `::Forward`, `::Back`, `::Right`, and `::Left` functions, as follows:'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `AWarrior::Tick()` function, modify the input values after normalizing
    any oversize in the input vector:'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We normalize the input vector when it is over a magnitude of 1.0\. This constricts
    the maximum input velocity to 1.0 units (rather than 2.0 units when full up and
    full right are pressed, for example).
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Action Mappings – one-button responses for an FPS character
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: An Action mapping is for handling single-button pushes (not buttons that are
    held down). For buttons that should be held down, be sure to use an Axis mapping
    instead.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a UE4 project ready with the actions that you need to complete, such as
    `Jump` or `ShootGun`.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Settings | Project Settings | Input.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the Action Mappings heading and click on the + icon beside it:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a65fdfd6-0f69-4512-8ba5-82d282b9e325.png)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Start to type in the actions that should be mapped to button pushes. For example,
    type in `Jump` for the first Action.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the arrow to the left of the action to open up the menu and then select
    a key to press for that action to occur, for example, Space Bar.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you would like the same action triggered by another key push, click on the
    + beside your Action Mappings name and select another key to trigger the Action.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want the Shift, Ctrl, Alt, or Cmd keys to be held down for the Action
    to occur, be sure to indicate that in the checkboxes to the right of the key selection
    box:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a79a026-ca19-4dc7-9c1c-8b274c320eff.png)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'To link your Action to a C++ code function, you need to override the `SetupPlayerInputComponent(UInputControl*
    control )` function. Enter the following code inside that function:'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compile your script and play the game. Whenever you press the *spacebar*, you
    should see the player jump in the air! Refer to the following screenshot:'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d487813-cd64-4250-a1cc-8bb083d862f8.png)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Action Mappings** are single-button-push events that fire off C++ code to
    run in response to them. You can define any number of actions that you wish in
    the UE4 Editor, but be sure to tie up Action Mappings to actual key pushes in
    C++.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may notice that the `Jump` function we are calling, when we use our action,
    already exists when we added a reference to it. That is because the `Character`
    class already contains an implementation for it. Note that the default implementation
    doesn't feel like a usual jump – it's more of a rise and float action.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find more information on the `Character` class and the pre-built functions
    it has at [https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/ACharacter/index.html](https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/ACharacter/index.html).
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: You can list the Actions that you want mapped from C++ code. See the following
    recipe, *Adding Axis and Action Mappings from C++*, for this.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Axis and Action Mappings from C++
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Axis Mappings and Action Mappings can be added to your game via the UE4 Editor
    and is often how designers will do it, but we can also add them directly from
    C++ code. Since the connections to C++ functions is from C++ code anyway, you
    may find it more convenient to define your Axis and Action Mappings in C++ as
    well.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: You need a UE4 project that you'd like to add some Axis and Action mappings
    to. You can delete the existing Axis and Action mappings listed in Settings |
    Project Settings | Input if you are adding them via C++ code.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To add your custom Axis and Action Mappings, there are two C++ functions that
    you need to know about: `UPlayerInput::AddAxisMapping` and `UPlayerInput:: AddActionMapping`.
    These are member functions that are available on the `UPlayerInput` object. The
    `UPlayerInput` object is inside the `PlayerController` object, and is accessible
    via the following code:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also use the two static member functions of `UPlayerInput` to create
    your Axis and Action Mappings if you''d prefer not to access player controllers
    individually:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, we need to define our `FInputAxisKeyMapping` or `FInputActionKeyMapping`
    objects, depending on whether you are hooking up an Axis key mapping (for buttons
    that are held down for input) or an Action key mapping (for one-off-event buttons
    that are pressed once for input).
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use either of the following classes, we will need to include the following
    `.h` file:'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For Axis key mappings, we define an `FInputAxisKeyMapping` object, as follows:'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will include the string name for the action, the key to press (use the
    EKeys `enum`), and whether or not *Shift*, *Ctrl*, *Alt*, or *cmd* (Mac) should
    be held to trigger the event.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For action key mappings, define `FInputActionKeyMapping`, as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will include the string name for the action, the key to press, and whether
    or not *Shift*, *Ctrl*, *Alt*, or *cmd* (Mac) should be held to trigger the event.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your player `Pawn` class''s `SetupPlayerInputComponent` function, register
    your Axis and Action key mappings to the following:'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `PlayerInput` object connected to a specific controller:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, you could register to the static member functions of the `UPlayerInput`
    object directly:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ensure that you're using the correct function for Axis versus Action Mappings!
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Register your Action and Axis Mappings to C++ functions using C++ code, just
    like we did in the preceding two recipes, for example:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: The Action and Axis Mapping registration functions allow you to set up your
    input mappings from C++ code directly. The C++ coded input mappings are essentially
    the same as entering the input mappings in the Settings | Project Settings | Input
    dialog.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mouse UI input handling
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the **Unreal Motion Graphics** (**UMG**) toolkit, you will find that
    mouse events are very easy to handle. We can register C++ functions to run after
    mouse clicks or other types of interactions with the UMG components.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Usually, event registration will be via Blueprints; however, in this recipe,
    we will outline how to write and wire up C++ functions to UMG events.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a UMG canvas in your UE4 project. From there, we'll register event handlers
    for the `OnClicked`, `OnPressed`, and `OnReleased` events.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right-click in your Content Browser (or click on Add New) and select User Interface
    | Widget Blueprint, as shown in the following screenshot. This will add an editable
    widget blueprint to your project:'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/451daeed-ffb0-4715-9eea-28085c8b1096.png)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Double-click on your Widget Blueprint to edit it.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a button to the interface by dragging it from the palette on the left:'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4bd1c07c-a8bd-493a-95f6-db057cb0b315.png)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Scroll down the Details panel for your button until you find the Events subsection.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the + icon beside any event that you''d like to handle:'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b0d70320-f08a-4d4d-80e5-b026be6eeb6c.png)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Connect the event that appears in Blueprints to any C++ `UFUNCTION()` that
    has the `BlueprintCallable` tag in the macro. For example, in your `GameModeBase`
    class derivative, you could include a function such as the following one:'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Trigger the function call by routing to it in the Blueprint diagram under the
    event of your choice. For example, I used the `OnClick` function. Once created,
    I used the Get Game Mode node to get our current game mode and then `Cast to Chapter06_GameModeBase`
    to gain access to the `ButtonClicked` function:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f4f3430-4d15-4359-ad22-e5abb7091743.png)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note that for this to work, ensure that you have set the Game Mode for the level/project
    as `Chapter_06GameModeBase`.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Construct and display your UI by calling Create Widget, followed by Add to Viewport
    in the `BeginPlay` function of your `GameModeBase` (or any such main object) or
    through the Level Blueprint.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this via C++, you''ll need to go to the `Chapter_06.Build.cs` file and
    modify the following line:'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Afterwards, add the following property and function to the `Chapter_06GameModeBase.h`
    file:'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, update the C++ file:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we need to set Widget to our created menu. To do that, from the Content
    Browser, right-click on the `Chapter06_GameModeBase` from the C++ `Classes\Chapter_06`
    folder and create a new Blueprint from it. Once at the Blueprints menu, go to
    the Details tab and under the UI section, set the Widget to the item you wish
    to display:'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a99bff0f-a8cb-43ef-b2a6-c9cfb004d3ef.png)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Finally, go to Settings | World Settings. From there, change the Game Mode
    Override to your Blueprint version of the GameMode:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1a52c677-c0a4-4edd-95a3-ca9712391c4a.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Then, open the Output Log by going to Window | Developer Tools | Output Log
    and then play the game. You should see the button displayed on your screen. If
    you click on it, you should see a message displayed on the Output Log!
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/60719194-7e50-46ce-961f-af9231f654a5.png)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Your widget's Blueprint button events can be easily connected to Blueprint events,
    or C++ functions by creating  a `UFUNCTION()` that has the `BlueprintCallable` tag
    in the macro.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more information on using UMG and building simple menus and displaying them
    using Blueprints, check out [https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/CreatingWidgets](https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/CreatingWidgets).
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UMG keyboard UI shortcut keys
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Every user interface needs shortcut keys associated with it. To program these
    into your UMG interface, you can simply wire up certain key combinations to an
    Action Mapping. When the Action triggers, just invoke the same Blueprints function
    that the UI button itself triggers.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a UMG interface created already, as shown in the previous recipe.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Settings | Project Settings | Input, define a new Action Mapping for your
    hot key event, for example, `HotKey_UIButton_Spell`:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70e3025e-174f-4ae7-8be2-139b9ae12850.png)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Wire up the event to your UI''s function call either in Blueprints or in C++
    code. In our case, I will add it to the `AWarrior` class we created previously
    by adding it to the `SetupPlayerInputComponent` function:'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile your script and then open the World Settings by going to Settings |
    World Settings. Under Selected GameMode, set the Default Pawn Class to `BP_Warrior`.
    You should now notice that you can either press your key or press the button to
    execute the `ButtonClicked` function we created in the previous recipe!
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Wiring up an Action Mapping with a short circuit to the function that's called
    by the UI will allow you to implement hot keys in your game program nicely.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Collision – letting objects pass through one another using Ignore
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Collision settings are fairly easy to get started with. There are three classes
    of intersection for collisions:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Ignore`: Collisions that pass through each other without any notification.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Overlap`: Collisions that trigger the `OnBeginOverlap` and `OnEndOverlap`
    events. Interpenetration of objects with an `Overlap` setting is allowed.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Block`: Collisions that prevent all interpenetration, and prevent objects
    from overlapping each other at all.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects are classed into one of many Object Types. The Collision settings for
    a particular Blueprint's Component allow you to class the object as an Object
    Type of your choice, as well as specify how that object collides with all other
    objects of all other types. This takes a tabular format in the Details | Collision
    section of the Blueprint Editor.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, the following screenshot shows the Collision settings for a character''s
    `CapsuleComponent`:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/e187ec4e-1e2f-4603-8cf9-b4eddcf6ae3c.png)'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a UE4 project with some objects that you'd like to program intersections
    for.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the Blueprint Editor for the object that you'd like other objects to simply
    pass through and ignore. Under the Components listing, select the component that
    you'd like to program settings for.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With your component selected, see your Details tab (usually on the right).
    Under Collision Presets, select either the NoCollision or Custom... presets:'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you select the NoCollision preset, you can just leave it at that, and all
    collisions will be ignored.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you select the Custom... preset, then choose either of the following:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: NoCollision under the Collision Enabled drop-down menu.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select a collision mode under Collision Enabled involving Queries, and be sure
    to check the Ig
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: nore checkbox for each Object Type that you'd like it to ignore collisions with.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Ignored collisions will not fire any events or prevent interpenetrations between
    objects marked as such. Note that if Object A is set to ignore Object B, it does
    not matter whether Object B is set to ignore Object A or not. They will ignore
    each other as long as one of them is set to ignore the other.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Collision – picking up objects using Overlap
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Item pickup is a pretty important thing to do cleanly. In this recipe, we'll
    outline how to get item pickups working using Overlap events on Actor Component
    primitives.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe, *Collisions – Letting objects pass through each other using
    Ignore*, describes the basics of collisions. You should read it for background
    before beginning this recipe. What we'll do here is create a New Object Channel...
    to identify `Item` class objects so that they can be programmed for overlaps,
    but only with the player avatar's collision volume.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by creating a unique collision Channel for the `Item` object''s collision
    primitive. This is under Settings | Project Settings | Collision:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1c91758c-6e3b-454b-932d-0fa3f8e59e4a.png)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once there, create a new Object Channel by going to New Object Channel....
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the new Object Channel `Item` and set the Default Response to Overlap.
    Afterwards, hit the Accept button:'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aa9ee232-de0e-4b2b-8900-1910ce95c00d.png)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Take your `Item` actor and select the primitive component on it that is used
    to intersect for pickup with the player avatar. From the Details tab, go to the
    Collision section and under Collision Presets, change the option to Custom....
    Afterwards, set the Object Type of that primitive to `Item`.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the Overlap checkbox against the `Pawn` class Object Type, as shown in
    the following screenshot:'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/37f20568-fa11-4711-baca-e6b1b0f521ed.png)'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Ensure that the Generate Overlap Events checkbox is checked:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21f4abc7-1789-47a8-98ef-99654ed333d0.png)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Location of the Generate Overlap Events property.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Take the player actor who will pick up the items (BP_Warrior for this example)
    and select the component on them that feels for the items. Usually, this will
    be their `CapsuleComponent`. Check Overlap with the `Item` object:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c1a57159-25c1-4944-9692-917dd14f30ea.png)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now, the Player overlaps the item, and the item overlaps the player pawn. We
    do have to signal overlaps both ways (`Item` overlaps `Pawn` and `Pawn` Overlaps
    `Item`) for it to work properly. Ensure that Generate Overlap Events is also checked
    for the `Pawn` intersecting component.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we have to complete the `OnComponentBeginOverlap` event for either the
    item or the Player''s pickup volume, using either Blueprints or C++ code:'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you prefer Blueprints, in the Events section of the Details pane of the
    Items''s intersectable Component, click on the + icon beside the On Component
    Begin Overlap event:'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6dee9413-e593-4c0a-922e-71eab50057a9.png)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Use the `OnComponentBeginOverlap` event that appears in your `Actor` Blueprint
    diagram to wire in Blueprints code to run when an overlap with the Player's capsule
    volume occurs.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you prefer C++, you can write and attach a C++ function to the `CapsuleComponent`.
    Write a member function in your player''s `Character` class (for example, the
    `Warrior.h` file) with a signature, as follows:'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Complete the implementation of the `OnOverlapsBegin()` function in your `.cpp`
    file, making sure to end the function name with `_Implementation`:'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, provide a `PostInitializeComponents()` override to connect the `OnOverlapsBegin()`
    function with overlaps to the capsule in your avatar''s class, as follows:'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compile your script and then run your project. You should see log messages
    when you enter and leave the object! Refer to the following screenshot:'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98a6d7a0-dcf9-4da6-bc7b-50f130efa029.png)'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: The Overlap event that's raised by the engine allows code to run when two UE4
    `Actor` Components overlap, without preventing interpenetration of the objects.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Collision – preventing interpenetration using Block
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Blocking means that the `Actor` components will be prevented from interpenetration
    in the engine, and any collision between two primitive shapes will be resolved,
    and not overlapping, after collisions are found.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Begin with a UE4 project that has some objects with Actors that have collision
    primitives attached to them (`SphereComponents`, `CapsuleComponents`, or `BoxComponents`).
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从一个具有一些对象且这些对象有附加碰撞原始形状的演员的 UE4 项目开始（`SphereComponents`、`CapsuleComponents`
    或 `BoxComponents`）。
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the Blueprint of an actor that you want to block another actor with. For
    example, we want the Player actor to block other Player actor instances.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你想要阻止另一个演员的演员的蓝图。例如，我们想要玩家演员阻止其他玩家演员实例。
- en: 'Mark primitives inside the actor that you do not want interpenetrating with
    other components as blocking those components in the Details pane:'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你不想与其他组件发生穿透的原始形状标记在演员中，这样就可以在“详细信息”面板中阻止这些组件：
- en: '![](img/15215060-daac-41c6-a9db-c7b95e1be796.png)'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/15215060-daac-41c6-a9db-c7b95e1be796.png)'
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When objects b
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当对象 b
- en: lock one another, they will not be allowed to interpenetrate. Any interpenetration
    will be automatically resolved, and the objects will be pushed off each other. This
    is one of the details that often causes lots of headaches. For objects to actually
    block each other, they both have to be set to block.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果两个对象相互锁定，它们将不允许相互穿透。任何穿透都将自动解决，并且对象将被推开。这是经常引起许多头疼的问题之一。为了实际阻止彼此的对象，它们都必须设置为阻止。
- en: 'For more information, check out the official UE4 blog post on the subject:
    [https://www.unrealengine.com/en-US/blog/collision-filtering](https://www.unrealengine.com/en-US/blog/collision-filtering).'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息，请查看官方 UE4 博客文章：[https://www.unrealengine.com/en-US/blog/collision-filtering](https://www.unrealengine.com/en-US/blog/collision-filtering)。
- en: There's more...
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can override the `OnComponentHit` function to run code when two objects
    hit each other. This is distinct from the `OnComponentBeginOverlap` event.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以覆盖 `OnComponentHit` 函数，以便在两个对象相撞时运行代码。这与 `OnComponentBeginOverlap` 事件不同。
