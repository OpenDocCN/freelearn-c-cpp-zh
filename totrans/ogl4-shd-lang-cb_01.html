<html><head></head><body>
        

                            
                    <h1 class="header-title">Getting Started with GLSL</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Using a loading library to access the latest OpenGL functionality</li>
<li>Using GLM for mathematics</li>
<li>Determining the GLSL and OpenGL version</li>
<li>Compiling a shader</li>
<li>Linking a shader program</li>
<li>Saving and loading a shader binary</li>
<li>Loading a SPIR-V shader program</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>The <strong>OpenGL Shading Language</strong> (<strong>GLSL</strong>) Version 4 brings unprecedented power and flexibility to programmers interested in creating modern, interactive, and graphical programs. It allows us to harness the power of modern <strong>Graphics Processing Units</strong> (<strong>GPUs</strong>) in a straightforward way by providing a simple yet powerful language and API. Of course, the first step toward using GLSL is to create a program that utilizes the OpenGL API. GLSL programs don't stand on their own; they must be a part of a larger OpenGL program. In this chapter, we will provide some tips and techniques for getting started. We'll cover how to load, compile, link, and export a GLSL shader program. First, let's start with some background.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">GLSL</h1>
                
            
            
                
<p>The GLSL is a fundamental and integral part of the OpenGL API. Every program written using the OpenGL API will internally utilize one or several GLSL programs. These "mini-programs" are referred to as <strong>shader programs</strong>. A shader program usually consists of several components called <strong>shaders</strong>. Each shader executes within a different stage of the OpenGL pipeline. Each shader runs on the GPU, and as the name implies, they (typically) implement the algorithms related to lighting and shading effects. However, shaders are capable of doing much more than just shading. They can perform animation, generate additional geometry, tessellate geometry, or even perform generalized computation.</p>
<p>The field of study called <strong>General Purpose Computing on Graphics Processing Units</strong> (<strong>GPGPU</strong>) is concerned with the utilization of GPUs (often using specialized APIs such as CUDA or OpenCL) to perform general-purpose computations such as fluid dynamics, molecular dynamics, and cryptography. With compute shaders, introduced in OpenGL 4.3, we can now do GPGPU within OpenGL. See <a href="d67e01c8-8212-4d49-937f-6b1c62a57744.xhtml">Chapter 11</a>, <em>Using Compute Shaders</em>, for details about using compute shaders.</p>
<p>Shader programs are designed for direct execution on the GPU and are executed in parallel. For example, a fragment shader might be executed once for every pixel, with each execution running simultaneously. The number of processors on the graphics card determines how many can be executed at one time. This makes shader programs incredibly efficient, and provides the programmer with a simple API for implementing highly-parallel computation.</p>
<p>Shader programs form essential parts of the <em>OpenGL pipeline</em>. Prior to OpenGL Version 2.0, the shading algorithm was <em>hardcoded</em> into the pipeline and had only limited configurability. When we wanted to implement custom effects, we used various tricks to force the fixed-function pipeline into being more flexible than it really was. With the advent of GLSL, we now have the ability to replace this hardcoded functionality with our own programs written in GLSL, thus giving us a great deal of additional flexibility and power. For more details on this programmable pipeline, see the introduction to <a href="74703f9d-f69a-4b08-bb38-6e1066371207.xhtml">Chapter 3</a>, <em>The Basics of GLSL Shaders</em>.</p>
<p>In fact, OpenGL Version 3.2 and above not only provide this capability, but they require shader programs as part of every OpenGL program. The old fixed-function pipeline has been deprecated in favor of a new programmable pipeline, a key part of which is the shader program written in GLSL.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Profiles – core versus compatibility</h1>
                
            
            
                
<p>OpenGL Version 3.0 introduced a <strong>deprecation model</strong>, which allowed for the gradual removal of functions from the OpenGL specification. Functions or features can be marked as deprecated, meaning that they are expected to be removed from a future version of OpenGL. For example, immediate mode-rendering using <kbd>glBegin</kbd>/<kbd>glEnd</kbd> was marked as deprecated in version 3.0 and removed in version 3.1.</p>
<p>In order to maintain backwards compatibility, <strong>compatibility profiles</strong> were introduced with OpenGL 3.2. A programmer that is writing code for a particular version of OpenGL (with older features removed) would use the <strong>core profile</strong>. Those who wanted to maintain compatibility with older functionality could use the compatibility profile.</p>
<p>It may be somewhat confusing that there is also the concept of a <strong>forward-compatible</strong> context, which is distinguished slightly from the concept of a core/compatibility profile. A context that is considered forward-compatible basically indicates that all deprecated functionality has been removed. In other words, if a context is forward-compatible, it only includes functions that are in the core, but not those that were marked as deprecated. Some Windows APIs provide the ability to select a forward-compatible status along with the profile.</p>
<p>The steps for selecting a core or compatibility profile depend on the Windows system's API. For example, with GLFW, one can select a forward-compatible, 4.6 core profile using the following code:</p>
<pre>glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); 
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); 
glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); 
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); 
 
GLFWwindow *window = glfwCreateWindow(800, 600, "Title", nullptr, nullptr);</pre>
<p>All programs in this book are designed to be compatible with a forward-compatible OpenGL 4.6 core profile. However, many of them can be used with older versions or even compatibility profiles.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a loading library to access the latest OpenGL functionality</h1>
                
            
            
                
<p>The OpenGL <strong>application binary interface</strong> (<strong>ABI</strong>) is frozen to OpenGL Version 1.1 on Windows. Unfortunately for Windows developers, that means that it is not possible to link directly to functions that are provided in newer versions of OpenGL. Instead, one must gain access to the OpenGL functions by acquiring a function pointer at runtime. Getting access to the function pointers is not difficult, but requires somewhat tedious work, and has a tendency to clutter code. Additionally, Windows typically comes with a standard OpenGL <kbd>gl.h</kbd> file that also conforms to OpenGL 1.1.</p>
<p>The OpenGL wiki states that Microsoft has no plans to ever update the <kbd>gl.h</kbd> and <kbd>opengl32.lib</kbd> that come with their compilers. Thankfully, others have provided libraries that manage all of this for us by transparently providing the needed function pointers, while also exposing the needed functionality in header files. Such a library is called an <strong>OpenGL Loading Library</strong> (or <strong>OpenGL function loader</strong>), and there are several such libraries available. One of the oldest is <strong>OpenGL Extension Wrangler</strong> (<strong>GLEW</strong>). However, there are a few issues with GLEW. First, it provides one large header file that includes everything from all versions of OpenGL. It might be preferable to have a more streamlined header file that only includes functions that we might use. Second, GLEW is distributed as a library that needs to be compiled separately and linked into our project. I find it preferable to have a loader that can be included into a project simply by adding the source files and compiling them directly into our executable, avoiding the need to support another link-time dependency.</p>
<p>In this recipe, we'll use a loader generator named GLAD, available from <a href="https://github.com/Dav1dde/glad">https://github.com/Dav1dde/glad</a>. This very flexible and efficient library can generate a header that includes only the needed functionality, and also generates just a few files (a source file and a few headers) that we can add directly into our project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To use GLAD, you can either download and install it using <kbd>pip</kbd> (or from <a href="https://github.com/Dav1dde/glad">https://github.com/Dav1dde/glad</a> ), or you can use the web service available here: <a href="http://glad.dav1d.de/">http://glad.dav1d.de/</a>. If you choose to install it, you'll need Python. The install is simple and described in detail on the GitHub page.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The first step is to generate the header and source files for the OpenGL version and profile of your choice. For this example, we'll generate files for an OpenGL 4.6 core profile. We can then copy the files into our project and compile them directly alongside our code:</p>
<ol>
<li>To generate the header and source files, run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>glad --generator=c --out-path=GL --profile=core --api=gl=4.6</strong></pre>
<ol start="2">
<li>The previous step will generate its output into a directory named <kbd>GL</kbd>. There will be two directories: <kbd>GL/include</kbd> and <kbd>GL/src</kbd>. You can move the GL directory into your project as is, or move the individual files into appropriate locations. Include <kbd>GL/src/glad.c</kbd> in your build, and put <kbd>GL/include</kbd> into your <kbd>include</kbd> path. Within your program code, include <kbd>glad/glad.h</kbd> whenever you need access to the OpenGL functions. Note that this fully replaces <kbd>gl.h</kbd>, so there is no need to include that. </li>
<li>In order to initialize the function pointers, you need to make sure to call a function that does so. The needed function is <kbd>gladLoadGL()</kbd>. Somewhere just after the GL context is created (typically in an initialization function), and before any OpenGL functions are called, use the following code:</li>
</ol>
<pre style="padding-left: 60px">if(!gladLoadGL()) {<br/>  std::cerr &lt;&lt; "Unable to load OpenGL functions!" &lt;&lt; std::endl;<br/>  exit(EXIT_FAILURE);<br/>}</pre>
<p>That's all there is to it!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The command in step 1 generates a few header files and a source file. The header provides prototypes for all of the selected OpenGL functions, redefines them as function pointers, and defines all of the OpenGL constants as well. The source file provides initialization code for the function pointers as well as some other utility functions. We can include the <kbd>glad/glad.h</kbd> header file wherever we need prototypes for OpenGL functions, so all function entry points are available at compile time. At runtime, the <kbd>gladLoadGL()</kbd> call will initialize all available function pointers.</p>
<p class="mce-root"/>
<p>Some function pointers may not be successfully initialized. This might happen if your driver does not support the requested OpenGL version. If that happens, calling the functions will fail.</p>
<p>The command-line arguments available to GLAD are fully documented on the GitHub site and are available via <kbd>glad -h</kbd>. One can select any OpenGL version, select core/compatibility profiles, include desired extensions, and/or create debug callbacks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>GLAD provides a web service at <a href="http://glad.dav1d.de/">http://glad.dav1d.de/</a> that makes it easy to generate the loader source and header files without installing GLAD. Simply visit the URL, select the desired configuration, and the loader files will be generated and downloaded.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <kbd>ingredients/scenerunner.h</kbd> file in the example code</li>
<li>GLEW, an older, popular loader and extension manager, available from <a href="http://glew.sourceforge.net">http://glew.sourceforge.net</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Using GLM for mathematics</h1>
                
            
            
                
<p>Mathematics is the core to all of computer graphics. In earlier versions, OpenGL provided support for managing coordinate transformations and projections using the standard matrix stacks (<kbd>GL_MODELVIEW</kbd> and <kbd>GL_PROJECTION</kbd>). In modern versions of core OpenGL however, all of the functionality supporting the matrix stacks has been removed. Therefore, it is up to us to provide our own support for the usual transformation and projection matrices, and then pass them into our shaders. Of course, we could write our own matrix and vector classes to manage this, but some might prefer to use a ready-made, robust library.</p>
<p>One such library is <strong>OpenGL Mathematics</strong> (<strong>GLM</strong>), written by Christophe Riccio. Its design is based on the GLSL specification, so the syntax will be familiar to anyone using GLSL. Additionally, it provides extensions that include functionality similar to some of the much-missed OpenGL utility functions, such as <kbd>glOrtho</kbd>, <kbd>glRotate</kbd>, or <kbd>gluLookAt</kbd>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Since GLM is a header-only library, the installation is simple. Download the latest GLM distribution from <a href="http://glm.g-truc.net">http://glm.g-truc.net</a>. Then, unzip the archive file, and copy the <kbd>glm</kbd> directory contained inside to anywhere in your compiler's include path.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To use the GLM libraries, include the core header file, and headers for any extensions. For this example, we'll include the matrix transform extension:</p>
<pre>#include &lt;glm/glm.hpp&gt; 
#include &lt;glm/gtc/matrix_transform.hpp&gt; </pre>
<p>The GLM classes are available in the <kbd>glm</kbd> namespace. The following is an example of how you might go about making use of some of them:</p>
<pre>glm::vec4 position = glm::vec4( 1.0f, 0.0f, 0.0f, 1.0f ); 
glm::mat4 view = glm::lookAt( <br/>        glm::vec3(0.0f, 0.0f, 5.0f),<br/>        glm::vec3(0.0f, 0.0f, 0.0f),<br/>        glm::vec3(0.0f, 1.0f, 0.0f) <br/>   ); 
glm::mat4 model(1.0f);   // The identity matrix 
model = glm::rotate( model, 90.0f, glm::vec3(0.0f,1.0f,0.0) ); 
glm::mat4 mv = view * model; 
glm::vec4 transformed = mv * position; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The GLM library is a header-only library. All of the implementation is included within the header files. It doesn't require separate compilation and you don't need to link your program to it. Just placing the header files in your include path is all that's required!</p>
<p>The previous example first creates <kbd>vec4</kbd> (a four-component vector), which represents a position. Then, it creates a 4 x 4 view matrix by using the <kbd>glm::lookAt</kbd> function. This works in a similar fashion to the old <kbd>gluLookAt</kbd> function. Here, we set the camera's location at (0, 0, 5), looking toward the origin, with the <em>up</em> direction in the direction of the positive <em>y</em> axis. We then go on to create the model matrix by first storing the identity matrix in the <kbd>model</kbd> variable (via the single-argument constructor), and multiplying it by a rotation matrix using the <kbd>glm::rotate</kbd> function.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The multiplication here is implicitly done by the <kbd>glm::rotate</kbd> function. It multiplies its first parameter by the rotation matrix (on the right) that is generated by the function. The second parameter is the angle of rotation (in degrees), and the third parameter is the axis of rotation. Since before this statement, <kbd>model</kbd> is the identity matrix, the net result is that <kbd>model</kbd> becomes a rotation matrix of 90 degrees around the <em>y</em> axis.</p>
<p>Finally, we create our model-view matrix (<kbd>mv</kbd>) by multiplying the <kbd>view</kbd> and <kbd>model</kbd> variables, and then use the combined matrix to transform the position. Note that the multiplication operator has been overloaded to behave in the expected way.</p>
<p>The order is important here. Typically, the model matrix represents a transformation from object space to world space, and the view matrix is a transformation from world space to camera space. So to get a single matrix that transforms from object space to camera space, we want the model matrix to apply first. Therefore, the model matrix is multiplied on the right-hand side of the view matrix.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It is <em>not recommended</em> to import all of the GLM namespaces using the following command:</p>
<pre><strong>using namespace glm;</strong> </pre>
<p>This will most likely cause a number of namespace clashes. Instead, it is preferable to import symbols one at a time with the <kbd>using</kbd> statements as needed. For example:</p>
<pre>#include &lt;glm/glm.hpp&gt; 
using glm::vec3; 
using glm::mat4; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the GLM types as input to OpenGL</h1>
                
            
            
                
<p>GLM supports directly passing a GLM type to OpenGL using one of the OpenGL vector functions (with the <kbd>v</kbd> suffix). For example, to pass <kbd>mat4</kbd> named <kbd>proj</kbd> to OpenGL, we can use the following code:</p>
<pre>glm::mat4 proj = glm::perspective( viewAngle, aspect, nearDist, farDist ); 
glUniformMatrix4fv(location, 1, GL_FALSE, &amp;proj[0][0]); </pre>
<p>Alternatively, rather than using the ampersand operator, we can use the <kbd>glm::value_ptr</kbd> function to get a pointer to the content of the GLM type:  </p>
<pre>glUniformMatrix4fv(location, 1, GL_FALSE, glm::value_ptr(proj));</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The latter version requires including the header file <kbd>glm/gtc/type_ptr.hpp</kbd>. The use of <kbd>value_ptr</kbd> is arguably cleaner, and works for any GLM type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The Qt SDK includes many classes for vector/matrix mathematics, and is another good option if you're already using Qt</li>
<li>The GLM website (<a href="http://glm.g-truc.net">http://glm.g-truc.net</a>) has additional documentation and examples</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Determining the GLSL and OpenGL version</h1>
                
            
            
                
<p>In order to support a wide range of systems, it is essential to be able to query for the supported OpenGL and GLSL version of the current driver. It is quite simple to do so, and there are two main functions involved: <kbd>glGetString</kbd> and <kbd>glGetIntegerv</kbd>.</p>
<p>Note that these functions must be called after the OpenGL context has been created.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The following code will print the version information to <kbd>stdout</kbd>:</p>
<pre>const GLubyte *renderer = glGetString( GL_RENDERER ); 
const GLubyte *vendor = glGetString( GL_VENDOR ); 
const GLubyte *version = glGetString( GL_VERSION ); 
const GLubyte *glslVersion = <br/>       glGetString( GL_SHADING_LANGUAGE_VERSION ); 
 
GLint major, minor; 
glGetIntegerv(GL_MAJOR_VERSION, &amp;major); 
glGetIntegerv(GL_MINOR_VERSION, &amp;minor); 
 
printf("GL Vendor            : %s\n", vendor); 
printf("GL Renderer          : %s\n", renderer); 
printf("GL Version (string)  : %s\n", version); 
printf("GL Version (integer) : %d.%d\n", major, minor); 
printf("GLSL Version         : %s\n", glslVersion);</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Note that there are two different ways to retrieve the OpenGL version: using <kbd>glGetString</kbd> and <kbd>glGetIntegerv</kbd>. The former can be useful for providing readable output, but may not be as convenient for programmatically checking the version because of the need to parse the string. The string provided by <kbd>glGetString(GL_VERSION)</kbd> should always begin with the major and minor versions separated by a dot, however, the minor version could be followed with a vendor-specific build number. Additionally, the rest of the string can contain additional vendor-specific information and may also include information about the selected profile (see the <em>Introduction</em> section of this chapter). It is important to note that the use of <kbd>glGetIntegerv</kbd> to query for version information requires OpenGL 3.0 or greater.</p>
<p>The queries for <kbd>GL_VENDOR</kbd> and <kbd>GL_RENDERER</kbd> provide additional information about the OpenGL driver. The <kbd>glGetString(GL_VENDOR)</kbd> call returns the company responsible for the OpenGL implementation. The call to <kbd>glGetString(GL_RENDERER)</kbd> provides the name of the renderer, which is specific to a particular hardware platform (such as the ATI Radeon HD 5600 Series). Note that both of these do not vary from release to release, so they can be used to determine the current platform.</p>
<p>Of more importance to us in the context of this book is the call to <kbd>glGetString(GL_SHADING_LANGUAGE_VERSION)</kbd>, which provides the supported GLSL version number. This string should begin with the major and minor version numbers separated by a period, but similar to the <kbd>GL_VERSION</kbd> query, may include other vendor-specific information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It is often useful to query for the supported extensions of the current OpenGL implementation.  Extension names are indexed and can be individually queried by index. We use the <kbd>glGetStringi</kbd> variant for this. For example, to get the name of the extension stored at index <kbd>i</kbd>, we use <kbd>glGetStringi(GL_EXTENSIONS, i)</kbd>. To print a list of all extensions, we could use the following code:</p>
<pre>GLint nExtensions; 
glGetIntegerv(GL_NUM_EXTENSIONS, &amp;nExtensions); 
 
for( int i = 0; i &lt; nExtensions; i++ ) 
      printf("%s\n", glGetStringi( GL_EXTENSIONS, i ) );</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Compiling a shader</h1>
                
            
            
                
<p>To get started, we need to know how to compile our GLSL shaders. The GLSL compiler is built right into the OpenGL library, and shaders can only be compiled within the context of a running OpenGL program.</p>
<p>OpenGL 4.1 added the ability to save compiled shader programs to a file, enabling OpenGL programs to avoid the overhead of shader compilation by loading precompiled shader programs (see the <em>Saving and loading a shader binary</em> recipe). OpenGL 4.6 added the ability to load shader programs compiled to (or written in) SPIR-V, an intermediate language for defining shaders. See the <em>Loading an SPIR-V shader</em> recipe later in this chapter.</p>
<p>Compiling a shader involves creating a shader object, providing the source code (as a string or set of strings) to the shader object, and asking the shader object to compile the code. The process is roughly represented by the following diagram:</p>
<div><img src="img/90cfaa2f-79fa-495e-ae00-ce05d1b0152a.png" style="width:24.08em;height:11.33em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To compile a shader, we'll need a basic example to work with. Let's start with the following simple vertex shader. Save it in a file named <kbd>basic.vert.glsl</kbd>:</p>
<pre>#version 460<br/>in vec3 VertexPosition; 
in vec3 VertexColor; 
 
out vec3 Color; 
 
void main() 
{ 
   Color = VertexColor; 
   gl_Position = vec4( VertexPosition, 1.0 ); 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In case you're curious about what this code does, it works as a "pass-through" shader. It takes the <kbd>VertexPosition</kbd> and <kbd>VertexColor</kbd> input attributes and passes them to the fragment shader via the <kbd>gl_Position</kbd> and <kbd>Color</kbd> output variables.</p>
<p>Next, we'll need to build a basic shell for an OpenGL program using a Window toolkit that supports OpenGL. Examples of cross-platform toolkits include GLFW, GLUT, FLTK, Qt, and wxWidgets. Throughout this text, I'll make the assumption that you can create a basic OpenGL program with your favorite toolkit. Virtually all toolkits have a hook for an initialization function, a resize callback (called upon resizing the window), and a drawing callback (called for each window refresh). For the purposes of this recipe, we need a program that creates and initializes an OpenGL context; it need not do anything other than display an empty OpenGL window. Note that you'll also need to load the OpenGL function pointers (refer to the <em>Using a loading library to access the latest OpenGL functionality</em> recipe).</p>
<p>Finally, load the shader source code into <kbd>std::string</kbd> (or the char array). The following example assumes that the <kbd>shaderCode</kbd> variable is <kbd>std::string</kbd> containing the shader source code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To compile a shader, use the following steps:</p>
<ol>
<li>Create the shader object:</li>
</ol>
<pre style="padding-left: 60px">GLuint vertShader = glCreateShader( GL_VERTEX_SHADER ); 
if( 0 == vertShader ) { 
  std::cerr &lt;&lt; "Error creating vertex shader." &lt;&lt; std::endl;
  exit(EXIT_FAILURE); 
} </pre>
<ol start="2">
<li>Copy the source code into the shader object:</li>
</ol>
<pre style="padding-left: 60px">std::string shaderCode = loadShaderAsString("basic.vert.glsl"); 
const GLchar * codeArray[] = { shaderCode.c_str() }; 
glShaderSource( vertShader, 1, codeArray, NULL ); </pre>
<ol start="3">
<li>Compile the shader:</li>
</ol>
<pre style="padding-left: 60px">glCompileShader( vertShader );</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>Verify the compilation status:</li>
</ol>
<pre style="padding-left: 60px">GLint result; 
glGetShaderiv( vertShader, GL_COMPILE_STATUS, &amp;result ); 
if( GL_FALSE == result ) { 
  std::cerr &lt;&lt; "Vertex shader compilation failed!" &lt;&lt; std::endl;
 <br/>  // Get and print the info log
  GLint logLen; 
  glGetShaderiv(vertShader, GL_INFO_LOG_LENGTH, &amp;logLen); 
  if( logLen &gt; 0 ) { 
    std::string log(logLen, ' '); 
    GLsizei written; 
    glGetShaderInfoLog(vertShader, logLen, &amp;written, &amp;log[0]); 
    std::cerr &lt;&lt; "Shader log: " &lt;&lt; std::endl &lt;&lt; log;
  } 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The first step is to create the shader object using the <kbd>glCreateShader</kbd> function. The argument is the type of shader, and can be one of the following: <kbd>GL_VERTEX_SHADER</kbd>, <kbd>GL_FRAGMENT_SHADER</kbd>, <kbd>GL_GEOMETRY_SHADER</kbd>, <kbd>GL_TESS_EVALUATION_SHADER</kbd>, <kbd>GL_TESS_CONTROL_SHADER</kbd>, or (as of version 4.3) <kbd>GL_COMPUTE_SHADER</kbd>. In this case, since we are compiling a vertex shader, we use <kbd>GL_VERTEX_SHADER</kbd>. This function returns the value used for referencing the vertex shader object, sometimes called the <strong>object handle</strong>. We store that value in the <kbd>vertShader</kbd> variable. If an error occurs while creating the shader object, this function will return 0, so we check for that and if it occurs, we print an appropriate message and terminate.</p>
<p>Following the creation of the shader object, we load the source code into the shader object using the <kbd>glShaderSource</kbd> function. This function is designed to accept an array of strings (as opposed to just a single one) in order to support the option of compiling multiple sources (files, strings) at once. So before we call <kbd>glShaderSource</kbd>, we place a pointer to our source code into an array named <kbd>sourceArray</kbd>.</p>
<p>The first argument to <kbd>glShaderSource</kbd> is the handle to the shader object. The second is the number of source code strings that are contained in the array. The third argument is a pointer to an array of source code strings. The final argument is an array of <kbd>GLint</kbd> values that contain the length of each source code string in the previous argument.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the previous code, we pass a value of <kbd>NULL</kbd>, which indicates that each source code string is terminated by a null character. If our source code strings were not null terminated, then this argument must be a valid array. Note that once this function returns, the source code has been copied into the OpenGL internal memory, so the memory used to store the source code can be freed.</p>
<p>The next step is to compile the source code for the shader. We do this by simply calling <kbd>glCompileShader</kbd>, and passing the handle to the shader that is to be compiled. Of course, depending on the correctness of the source code, the compilation may fail, so the next step is to check whether the compilation was successful.</p>
<p>We can query for the compilation status by calling <kbd>glGetShaderiv</kbd>, which is a function for querying the attributes of a shader object. In this case, we are interested in the compilation status, so we use <kbd>GL_COMPILE_STATUS</kbd> as the second argument. The first argument is of course the handle to the shader object, and the third argument is a pointer to an integer where the status will be stored. The function provides a value of either <kbd>GL_TRUE</kbd> or <kbd>GL_FALSE</kbd> in the third argument, indicating whether the compilation was successful.</p>
<p>If the compile status is <kbd>GL_FALSE</kbd>, we can query for the shader log, which will provide additional details about the failure. We do so by first querying for the length of the log by calling <kbd>glGetShaderiv</kbd> again with a value of <kbd>GL_INFO_LOG_LENGTH</kbd>. This provides the length of the log in the <kbd>logLen</kbd> variable. Note that this includes the null termination character. We then allocate space for the log, and retrieve the log by calling <kbd>glGetShaderInfoLog</kbd>. The first parameter is the handle to the shader object, the second is the size of the character buffer for storing the log, the third argument is a pointer to an integer where the number of characters actually written (excluding the null terminator character) will be stored, and the fourth argument is a pointer to the character buffer for storing the log itself. Once the log is retrieved, we print it to <kbd>stderr</kbd> and free its memory space.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The previous example only demonstrated how to compile a vertex shader. There are several other types of shaders, including fragment, geometry, and tessellation shaders. The technique for compiling is nearly identical for each shader type. The only significant difference is the argument to <kbd>glCreateShader</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>It is also important to note that shader compilation is only the first step. Similar to a language like C++, we need to link the program. While shader programs can consist of a single shader, for many use cases we have to compile two or more shaders, and then the shaders must be linked together into a shader program object. We'll see the steps involved in linking in the next recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a shader object</h1>
                
            
            
                
<p>Shader objects can be deleted when no longer needed by calling <kbd>glDeleteShader</kbd>. This frees the memory used by the shader and invalidates its handle. Note that if a shader object is already attached to a program object (refer to the <em>Linking a shader program</em> recipe), it will not be immediately deleted, but flagged for deletion when it is detached from the program object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <kbd>chapter01/scenebasic.cpp</kbd> file in the example code</li>
<li>The <em>Linking a shader program</em> recipe</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Linking a shader program</h1>
                
            
            
                
<p>Once we have compiled our shaders and before we can actually install them into the OpenGL pipeline, we need to link them together into a shader program. Among other things, the linking step involves making the connections between input variables from one shader to output variables of another, and making the connections between the input/output variables of a shader to appropriate locations in the OpenGL environment.</p>
<p>Linking involves steps that are similar to those involved in compiling a shader. We attach each shader object to a new shader program object and then tell the shader program object to link (making sure that the shader objects are compiled before linking):</p>
<div><img src="img/c60725c9-ea4e-48c4-bc30-0ac5979bc266.png" style="width:20.17em;height:10.17em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we'll assume that you've already compiled two shader objects whose handles are stored in the <kbd>vertShader</kbd> and <kbd>fragShader</kbd> variables.</p>
<p>For this and a few other recipes in this chapter, we'll use the following source code for the fragment shader:</p>
<pre>#version 460 
 
in vec3 Color; 
out vec4 FragColor; 
 
void main() { 
  FragColor = vec4(Color, 1.0); 
} </pre>
<p>For the vertex shader, we'll use the source code from the previous recipe, <em>Compiling a shader</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In our OpenGL initialization function, and after the compilation of shader objects referred to by <kbd>vertShader</kbd> and <kbd>fragShader</kbd>, perform the following steps:</p>
<ol>
<li>Create the program object using the following code:</li>
</ol>
<pre style="padding-left: 60px">GLuint programHandle = glCreateProgram(); 
if( 0 == programHandle ) 
{ 
  std::cerr &lt;&lt; "Error creating program object." &lt;&lt; std::endl; 
  exit(EXIT_FAILURE); 
} </pre>
<ol start="2">
<li>Attach the shaders to the program object as follows:</li>
</ol>
<pre style="padding-left: 60px">glAttachShader( programHandle, vertShader ); 
glAttachShader( programHandle, fragShader ); </pre>
<ol start="3">
<li>Link the program:</li>
</ol>
<pre style="padding-left: 60px">glLinkProgram( programHandle );</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>Verify the link status:</li>
</ol>
<pre style="padding-left: 60px">GLint status; 
glGetProgramiv( programHandle, GL_LINK_STATUS, &amp;status ); 
if( GL_FALSE == status ) {
  std::cerr &lt;&lt; "Failed to link shader program!" &lt;&lt; std::endl;
  GLint logLen; 
  glGetProgramiv(programHandle, GL_INFO_LOG_LENGTH, &amp;logLen); 
  if( logLen &gt; 0 ) { 
    std::string(logLen, ' ');
    GLsizei written;
    glGetProgramInfoLog(programHandle, logLen, &amp;written, &amp;log[0]); 
    std::cerr &lt;&lt; "Program log: " &lt;&lt; std::endl &lt;&lt; log;
  } 
} </pre>
<ol start="5">
<li>If linking is successful, we can install the program into the OpenGL pipeline with <kbd>glUseProgram</kbd>:</li>
</ol>
<pre style="padding-left: 60px">else
  glUseProgram( programHandle );</pre>
<p>Regardless of whether the link was successful, it is a good idea to clean up our shader objects. Once the program is linked, they are not needed anymore:</p>
<pre>// Detach and delete shader objects<br/>glDetachShader(programHandle, vertShader);<br/>glDetachShader(programHandle, fragShader);<br/>glDeleteShader(vertShader);<br/>glDeleteShader(fragShader);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We start by calling <kbd>glCreateProgram</kbd> to create an empty program object. This function returns a handle to the program object, which we store in a variable named <kbd>programHandle</kbd>. If an error occurs with program creation, the function will return 0. We check for that, and if it occurs, we print an error message and exit.</p>
<p>Next, we attach each shader to the program object using <kbd>glAttachShader</kbd>. The first argument is the handle to the program object, and the second is the handle to the shader object to be attached.</p>
<p>Then, we link the program by calling <kbd>glLinkProgram</kbd>, providing the handle to the program object as the only argument. As with compilation, we check for the success or failure of the link, with the subsequent query.</p>
<p class="mce-root"/>
<p>We check the status of the link by calling <kbd>glGetProgramiv</kbd>. Similar to <kbd>glGetShaderiv</kbd>, <kbd>glGetProgramiv</kbd> allows us to query various attributes of the shader program. In this case, we ask for the status of the link by providing <kbd>GL_LINK_STATUS</kbd> as the second argument. The status is returned in the location pointed to by the third argument, in this case named <kbd>status</kbd>.</p>
<p>The link status is either <kbd>GL_TRUE</kbd> or <kbd>GL_FALSE</kbd>, indicating the success or failure of the link. If the value of the status is <kbd>GL_FALSE</kbd>, we retrieve and display the program information log, which should contain additional information and error messages. The program log is retrieved by the call to <kbd>glGetProgramInfoLog</kbd>. The first argument is the handle to the program object, the second is the size of the buffer to contain the log, the third is a pointer to a <kbd>GLsizei</kbd> variable where the number of bytes written to the buffer will be stored (excluding the null terminator), and the fourth is a pointer to the buffer that will store the log. The buffer can be allocated based on the size returned by the call to <kbd>glGetProgramiv</kbd> with the <kbd>GL_INFO_LOG_LENGTH</kbd> parameter. The string that is provided in <kbd>log</kbd> will be properly null terminated.</p>
<p>Finally, if the link is successful, we install the program into the OpenGL pipeline by calling <kbd>glUseProgram</kbd>, providing the handle to the program as the argument.</p>
<p>It is a good idea to detach and delete the shader object, regardless of whether the link is successful. However, if the shader objects might be needed to link another program, you should detach it from this program and skip deletion until later.</p>
<p>With the simple fragment shader from this recipe and the vertex shader from the previous recipe compiled, linked, and installed into the OpenGL pipeline, we have a complete OpenGL pipeline and are ready to begin rendering. Drawing a triangle and supplying different values for the <kbd>Color</kbd> attribute yields an image of a multi-colored triangle where the vertices are red, green, and blue, and inside the triangle, the three colors are interpolated, causing a blending of colors throughout:</p>
<div><img src="img/701126dc-268e-476c-8980-95009dce1ceb.png" style="width:17.00em;height:13.33em;"/></div>
<p>For details on how to render the triangle, see <a href="15752c1f-eee7-4117-9632-f08f84a9405d.xhtml">Chapter 2</a>, <em>Working with GLSL Programs</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You can use multiple shader programs within a single OpenGL program. They can be swapped in and out of the OpenGL pipeline by calling <kbd>glUseProgram</kbd> to select the desired program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shader input/output variables</h1>
                
            
            
                
<p>You may have noticed that the <kbd>Color</kbd> variable is used to send data from the vertex shader to the fragment shader. There is an output variable (<kbd>out vec3</kbd>) in the vertex shader and an input variable (<kbd>in vec3</kbd>) in the fragment shader, both with the same name. The value that the fragment shader receives is a value that is interpolated from the values of the corresponding output variable for each of the vertices (hence the blended colors in the earlier image). This interpolation is automatically done by hardware rasterizer before the execution of the fragment stage. </p>
<p>When linking a shader program, OpenGL makes the connections between input and output variables in the vertex and fragment shaders (among other things). If a vertex shader's output variable has the same name and type as a fragment shader's input variable, OpenGL will automatically <em>link</em> them together.</p>
<p>It is possible to connect (link) variables that do not have the same name or type by using layout qualifiers. With a layout qualifier, we can specify the location for each variable specifically. For example, suppose that I used this set of output variables in my vertex shader:</p>
<pre>layout (location=0) out vec4 VertColor;<br/>layout (location=1) out vec3 VertNormal;</pre>
<p>I could use these variables in the fragment shader:</p>
<pre>layout (location=0) in vec3 Color;<br/>layout (location=1) in vec3 Normal;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Despite the fact that these have different names (and for <kbd>Color</kbd>, types), they will be connected by the linker when the program is linked due to the fact that they are assigned the same locations. In this example, <kbd>VertColor</kbd> will be linked to <kbd>Color</kbd>, and <kbd>VertNormal</kbd> will be linked to <kbd>Normal</kbd>. This makes things more convenient. We're not required to use the same names for input/output variables, which gives us the flexibility to use names that might be more descriptive in each shader stage. More importantly, it is part of a larger framework, called <strong>separate shader objects</strong>. A full example of separate shader objects can be found in the <em>Using program pipelines</em> recipe.</p>
<p>In fact, this use of layout qualifiers to specify variable locations <em>is required</em> when compiling to SPIR-V (see the <em>Loading an SPIR-V shader program</em> recipe).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a shader program</h1>
                
            
            
                
<p>If a program is no longer needed, it can be deleted from OpenGL memory by calling <kbd>glDeleteProgram</kbd>, providing the program handle as the only argument. This invalidates the handle and frees the memory used by the program. Note that if the program object is currently in use, it will not be immediately deleted, but will be flagged for deletion when it is no longer in use.</p>
<p>Also, the deletion of a shader program detaches the shader objects that were attached to the program but does not delete them unless those shader objects have already been flagged for deletion by a previous call to <kbd>glDeleteShader</kbd>. Therefore, as mentioned before, it is a good idea to detach and delete them immediately, as soon as the program is linked, to avoid accidentally leaking shader objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <kbd>chapter01/scenebasic.cpp</kbd> file in the example code</li>
<li>The <em>Compiling a shader</em> recipe</li>
<li>The <em>Using program pipelines</em> recipe</li>
<li>The <em>Loading an SPIR-V shader program</em> recipe</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Saving and loading a shader binary</h1>
                
            
            
                
<p>OpenGL 4.1 introduced the <kbd>glGetProgramBinary</kbd> and <kbd>glProgramBinary</kbd> functions, which allow us to save and load compiled shader program binaries. Note that this functionality is still quite dependent on the OpenGL driver, and is not widely supported. For example, the Intel drivers on macOS do not support any binary formats.</p>
<p>Unfortunately, Apple has deprecated OpenGL in macOS Mojave.</p>
<p>In this recipe, we'll outline the steps involved in saving and loading a compiled shader program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll begin assuming that a shader program has been successfully compiled, and its ID is in the <kbd>program</kbd> variable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To save the shader binary, first verify that the driver supports at least one shader binary format:</p>
<pre>GLint formats = 0;<br/>glGetIntegerv(GL_NUM_PROGRAM_BINARY_FORMATS, &amp;formats);<br/>if( formats &lt; 1 ) {<br/>  std::cerr &lt;&lt; "Driver does not support any binary formats." &lt;&lt; std::endl;<br/>  exit(EXIT_FAILURE);<br/>}<br/></pre>
<p>Then, assuming at least one binary format is available, use <kbd>glGetProgramBinary</kbd> to retrieve the compiled shader code and write it to a file:</p>
<pre>// Get the binary length<br/>GLint length = 0;<br/>glGetProgramiv(program, GL_PROGRAM_BINARY_LENGTH, &amp;length);<br/><br/>// Retrieve the binary code<br/>std::vector&lt;GLubyte&gt; buffer(length);<br/>GLenum format = 0;<br/>glGetProgramBinary(program, length, NULL, &amp;format, buffer.data());<br/><br/>// Write the binary to a file.<br/>std::string fName("shader.bin");<br/>std::cout &lt;&lt; "Writing to " &lt;&lt; fName &lt;&lt; ", binary format = " &lt;&lt; format &lt;&lt; std::endl;<br/>std::ofstream out(fName.c_str(), std::ios::binary);<br/>out.write( reinterpret_cast&lt;char *&gt;(buffer.data()), length );<br/>out.close();</pre>
<p>To load and use a shader binary, retrieve the compiled program from storage, and use <kbd>glProgramBinary</kbd> to load it into the OpenGL context:</p>
<pre>GLuint program = glCreateProgram();<br/><br/>// Load binary from file<br/>std::ifstream inputStream("shader.bin", std::ios::binary);<br/>std::istreambuf_iterator&lt;char&gt; startIt(inputStream), endIt;<br/>std::vector&lt;char&gt; buffer(startIt, endIt);  // Load file<br/>inputStream.close();<br/><br/>// Install shader binary<br/>glProgramBinary(program, format, buffer.data(), buffer.size() );<br/><br/>// Check for success/failure<br/>GLint status;<br/>glGetprogramiv(program, GL_LINK_STATUS, &amp;status);<br/>if( GL_FALSE == status ) {<br/>  // Handle failure ...<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Drivers can support zero or more binary formats. The call to <kbd>glGetIntegerv</kbd> with the <kbd>GL_NUM_PROGRAM_BINARY_FORMATS</kbd> constant queries the driver to see how many are available. If this number is zero, the OpenGL driver does not support reading or writing shader binaries. If the value is one or more, we're good to go.</p>
<p>If at least one binary format is available, we can use <kbd>glGetProgramBinary</kbd> to retrieve the compiled shader code shown earlier. The function will write the binary format used to the location pointed to by the fourth parameter. In the preceding example, the data is stored in the vector named <kbd>buffer</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To load the shader binary, we can use <kbd>glProgramBinary</kbd>. This function will load a previously saved shader binary. It requires the binary format to be passed as the second parameter. We can then check <kbd>GL_LINK_STATUS</kbd> to verify that it was loaded without error.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <kbd>chapter01/scenebasic.cpp</kbd> file in the example code</li>
<li>The <em>Loading an SPIR-V shader program</em> recipe</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading a SPIR-V shader program</h1>
                
            
            
                
<p><strong>Standard, Portable Intermediate Representation - V</strong> (<strong>SPIR-V</strong>) is an intermediate language designed and standardized by the Khronos Group for shaders. It is intended to be a compiler target for a number of different languages. In the Vulkan API, shaders are required to be compiled to SPIR-V before they can be loaded. SPIR-V is intended to provide developers with the freedom to develop their shaders in any language they want (as long as it can be compiled to SPIR-V), and avoid the need for an OpenGL (or Vulkan) implementation to provide compilers for multiple languages. </p>
<p>Support for SPIR-V shader binaries was added to OpenGL core with version 4.6, but is also available via the <kbd>ARB_gl_spirv</kbd> extension for earlier OpenGL versions.</p>
<p>Currently, the Khronos Group provides a reference compiler for compiling GLSL to SPIR-V. It is available on GitHub at <a href="https://github.com/KhronosGroup/glslang">https://github.com/KhronosGroup/glslang</a>.</p>
<p>In this recipe, we'll go through the steps involved in precompiling a GLSL shader pair to SPIR-V, and then load it into an OpenGL program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Download and compile the OpenGL shader validator from <a href="https://github.com/KhronosGroup/glslang">https://github.com/KhronosGroup/glslang</a>. Make sure that the <kbd>glslangValidator</kbd> binary is available in your <kbd>PATH</kbd> command line. In this example, we'll use the shader pair located in the <kbd>basic.vert.glsl</kbd> and <kbd>basic.frag.glsl</kbd> files.</p>
<p>Note that you'll need to use explicit locations for all of your input/output variables in the shaders. For details, see the <em>Linking a shader program</em> recipe.</p>
<p class="mce-root"/>
<p>All variables used for input/output interfaces (in/out variables) must have a location assigned.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Start by compiling the shader pair into SPIR-V using the <kbd>glslangValidator</kbd> tool:</p>
<pre><strong>glslangValidator -G -o basic.vert.spv basic.vert.glsl</strong><br/><strong>glslangValidator -G -o basic.frag.spv basic.frag.glsl</strong></pre>
<p>If successful, this produces the <kbd>basic.vert.spv</kbd> and <kbd>basic.frag.spv</kbd> SPIR-V output files.</p>
<p>To load your SPIR-V shaders into an OpenGL program, use <kbd>glShaderBinary</kbd> and <kbd>glSpecializeShader</kbd>. With <kbd>glShaderBinary</kbd>, use <kbd>GL_SHADER_BINARY_FORMAT_SPIR_V</kbd> as the binary format:</p>
<pre>GLuint vertShader = glCreateShader(GL_VERTEX_SHADER);<br/><br/>// Load the shader into a std::vector<br/>std::ifstream inStream("basic.vert.spv", std::ios::binary);<br/>std::istreambuf_iterator&lt;char&gt; startIt(inStream), endIt;<br/>std::vector&lt;char&gt; buffer(startIt, endIt);<br/>inStream.close();<br/><br/>// Load using glShaderBinary<br/>glShaderBinary(1, &amp;vertShader, GL_SHADER_BINARY_FORMAT_SPIR_V, buffer.data(), buffer.size());<br/><br/>// Specialize the shader (specify the entry point)<br/>glSpecializeShader( vertShader, "main", 0, 0, 0);<br/><br/>// Check for success/failure<br/>GLint status;<br/>glGetShaderiv(vertShader, GL_COMPILE_STATUS, &amp;status);<br/>if( GL_FALSE == status ) {<br/>  // Loading failed...<br/>}</pre>
<p>The process is nearly exactly the same for the fragment shader; just use <kbd>GL_FRAGMENT_SHADER</kbd> instead of <kbd>GL_VERTEX_SHADER</kbd> on the first line.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Finally, we create the program object, attach the shaders, and link. This process is identical to that shown in the <em>Linking a shader program</em> recipe, so we won't reproduce it here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>glShaderBinary</kbd> function provides us with the ability to load shaders that have been compiled to the SPIR-V format. This part is fairly straightforward.</p>
<p>The function that might be a bit more confusing is <kbd>glSpecializeShader</kbd>. We are required to call this function before the shader stage can be linked. This call is needed because a single SPIR-V file can have multiple entry points, and SPIR-V files can have <em>specialization constants</em>, which are parameters that the user can provide before it is compiled into native code. </p>
<p>At a minimum, we need to define the entry point for our shader. Since the source language is GLSL, the entry point is <kbd>main</kbd>. We specify the entry point(s) via the second argument. For GLSL, we simply use the <kbd>main</kbd> constant string. The last three parameters can be used to define the specialization constants. The first of the three is the number of constants, the next is a pointer to an array of constant indices, and the last is a pointer to an array of constant values.</p>
<p>The process of specializing an SPIR-V shader is similar to compiling a GLSL shader. Before calling <kbd>glSpecializeShader</kbd>, or if specialization fails, the compile status will be <kbd>GL_FALSE</kbd>. If specialization succeeds, the compile status will be <kbd>GL_TRUE</kbd>. As with GLSL shaders, we can query the shader info log to get detailed error messages (see the <em>Compiling a shader</em> recipe).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>SPIR-V appears to be the future of shader programming in the Vulkan/OpenGL space. However, GLSL is not going away anytime soon. GLSL compilers still ship with OpenGL and there's currently no sign that they will be removed or deprecated. The OpenGL specification still considers GLSL to be the primary shading language. </p>
<p>However, if you're interested in getting on board with SPIR-V early, or you have an interest in moving toward Vulkan, it might be valuable to you to start working with SPIR-V now in OpenGL. Fortunately, that's possible, at least in recent versions of OpenGL.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The future of SPIR-V is very bright. There is already a (mostly complete) compiler for HLSL that targets SPIR-V, and it is likely that other languages will be developed soon. It's an exciting time for shader programming!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <kbd>chapter01/scenebasic.cpp</kbd> file in the example code</li>
<li>The <em>Compiling a shader</em> recipe</li>
<li>The <em>Linking a shader program</em> recipe</li>
</ul>


            

            
        
    </body></html>