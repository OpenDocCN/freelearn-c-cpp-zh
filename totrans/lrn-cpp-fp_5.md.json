["```cpp\n    int i = (x + (y * z));\n\n```", "```cpp\n    /* strict.cpp */\n    #include <iostream>\n\n    using namespace std;\n\n    int OuterFormula(int x, int yz)\n    {\n      // For logging purpose only\n      cout << \"Calculate \" << x << \" + \";\n      cout << \"InnerFormula(\" << yz << \")\";\n      cout << endl;\n\n      // Returning the calculation result\n      return x * yz;\n    }\n\n    int InnerFormula(int y, int z)\n    {\n      // For logging purpose only\n      cout << \"Calculate \" << y << \" * \";\n      cout << z << endl;\n\n      // Returning the calculation result\n      return y * z;\n    }\n\n    auto main() -> int\n    {\n      cout << \"[strict.cpp]\" << endl;\n\n      // Initializing three int variables\n      // for the calculation\n      int x = 4;\n      int y = 3;\n      int z = 2;\n\n      // Calculating the expression\n      cout << \"Calculate \" << x <<\" + \";\n      cout << \"(\" << y << \" * \" << z << \")\";\n      cout << endl;\n      int result = OuterFormula(x, InnerFormula(y, z));\n\n      // For logging purpose only\n      cout << x << \" + \";\n      cout << \"(\" << y << \" * \" << z << \")\";\n      cout << \" = \" << result << endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* non_strict.cpp */\n    #include <functional>\n    #include <iostream>\n\n    using namespace std;\n\n int OuterFormulaNonStrict(\n int x,\n int y,\n int z,\n function<int(int, int)> yzFunc)\n {\n // For logging purpose only\n cout << \"Calculate \" << x << \" + \";\n cout << \"InnerFormula(\" << y << \", \";\n cout << z << \")\" << endl;\n\n // Returning the calculation result\n return x * yzFunc(y, z);\n }\n\n     int InnerFormula(int y, int z)\n     {\n       // For logging purpose only\n       cout << \"Calculate \" << y << \" * \";\n       cout << z << endl;\n\n       // Returning the calculation result\n       return y * z;\n     }\n\n     auto main() -> int\n     {\n       cout << \"[non_strict.cpp]\" << endl;\n\n       // Initializing three int variables\n       // for the calculation\n       int x = 4;\n       int y = 3;\n       int z = 2;\n\n       // Calculating the expression\n       cout << \"Calculate \" << x <<\" + \";\n       cout << \"(\" << y << \" * \" << z << \")\";\n       cout << endl;\n       int result = OuterFormulaNonStrict(x, y, z, InnerFormula);\n\n       // For logging purpose only\n       cout << x << \" + \";\n       cout << \"(\" << y << \" * \" << z << \")\";\n       cout << \" = \" << result << endl;\n\n       return 0;\n    }\n\n```", "```cpp\n    template<class T> class Delay\n    {\n      private:\n        function<T()> m_func;\n\n      public:\n        Delay(\n          function<T()> func)\n          : m_func(func)\n          {\n          }\n\n        T Fetch()\n        {\n          return m_func();\n        }\n    };\n\n```", "```cpp\n    /* delaying.cpp */\n    #include <iostream>\n    #include <functional>\n\n    using namespace std;\n\n    template<class T> class Delay\n    {\n      private:\n        function<T()> m_func;\n\n      public:\n        Delay(function<T()> func) : m_func(func)\n        {\n        }\n\n        T Fetch()\n        {\n          return m_func();\n        }\n    };\n\n    auto main() -> int\n    {\n      cout << \"[delaying.cpp]\" << endl;\n\n      // Initializing several int variables\n      int a = 10;\n      int b = 5;\n\n      cout << \"Constructing Delay<> named multiply\";\n      cout << endl;\n      Delay<int> multiply([a, b]()\n      {\n        cout << \"Delay<> named multiply\";\n        cout << \" is constructed.\" << endl;\n        return a * b;\n      });\n\n     cout << \"Constructing Delay<> named division\";\n     cout << endl;\n     Delay<int> division([a, b]()\n     {\n       cout << \"Delay<> named division \";\n       cout << \"is constructed.\" << endl;\n       return a / b; \n     });\n\n     cout << \"Invoking Fetch() method in \";\n     cout << \"multiply instance.\" << endl;\n     int c = multiply.Fetch();\n\n     cout << \"Invoking Fetch() method in \";\n     cout << \"division instance.\" << endl;\n     int d = division.Fetch();\n\n     // Displaying the result\n     cout << \"The result of a * b = \" << c << endl;\n     cout << \"The result of a / b = \" << d << endl;\n\n     return 0;\n    }\n\n```", "```cpp\n    /* delaying_non_pure.cpp */\n    #include <iostream>\n    #include <functional>\n\n    using namespace std;\n\n    template<class T> class Delay\n    {\n      private:\n        function<T()> m_func;\n\n      public:\n        Delay(function<T()> func) : m_func(func)\n        {\n        }\n\n        T Fetch()\n        {\n          return m_func();\n        }\n    };\n\n    auto main() -> int\n    {\n      cout << \"[delaying_non_pure.cpp]\" << endl;\n\n      // Initializing several int variables\n      int a = 10;\n      int b = 5;\n      int multiplexer = 0;\n\n      // Constructing Delay<> named multiply_impure\n      Delay<int> multiply_impure([&]()\n      {\n        return multiplexer * a * b;\n      });\n\n      // Invoking Fetch() method in multiply_impure instance\n      // multiple times\n      for (int i = 0; i < 5; ++i)\n      {\n        ++multiplexer;\n        cout << \"Multiplexer = \" << multiplexer << endl;\n        cout << \"a * b = \" << multiply_impure.Fetch();\n        cout << endl;\n      }\n\n      return 0;\n    }\n\n```", "```cpp\n    template<class T> class Memoization\n    {\n      private:\n        T const & (*m_subRoutine)(Memoization *);\n        mutable T m_recordedFunc;\n        function<T()> m_func;\n\n        static T const & ForceSubroutine(Memoization * d)\n        {\n          return d->DoRecording();\n        }\n\n        static T const & FetchSubroutine(Memoization * d)\n        {\n          return d->FetchRecording();\n        }\n\n        T const & FetchRecording()\n        {\n          return m_recordedFunc;\n        }\n\n        T const & DoRecording()\n        {\n          m_recordedFunc = m_func();\n          m_subRoutine = &FetchSubroutine;\n          return FetchRecording();\n        }\n\n     public:\n        Memoization(function<T()> func) : m_func(func),\n         m_subRoutine(&ForceSubroutine),\n         m_recordedFunc(T())\n        {\n        }\n\n       T Fetch()\n       {\n         return m_subRoutine(this);\n       }\n    };\n\n```", "```cpp\n    /* delaying_non_pure_memoization.cpp */\n    #include <iostream>\n    #include <functional>\n\n    using namespace std;\n\n    template<class T> class Memoization\n    {\n      private:\n        T const & (*m_subRoutine)(Memoization *);\n        mutable T m_recordedFunc;\n        function<T()> m_func;\n\n        static T const & ForceSubroutine(Memoization * d)\n        {\n          return d->DoRecording();\n        }\n\n       static T const & FetchSubroutine(Memoization * d)\n       {\n          return d->FetchRecording();\n       }\n\n       T const & FetchRecording()\n       {\n          return m_recordedFunc;\n       }\n\n       T const & DoRecording()\n       {\n          m_recordedFunc = m_func();\n          m_subRoutine = &FetchSubroutine;\n          return FetchRecording();\n       }\n\n     public:\n       Memoization(function<T()> func) : m_func(func),\n        m_subRoutine(&ForceSubroutine),\n        m_recordedFunc(T())\n       {\n       }\n\n      T Fetch()\n      {\n        return m_subRoutine(this);\n      }\n    };\n\n    auto main() -> int\n    {\n      cout << \"[delaying_non_pure_memoization.cpp]\" << endl;\n\n      // Initializing several int variables\n      int a = 10;\n      int b = 5;\n      int multiplexer = 0;\n\n // Constructing Memoization<> named multiply_impure\n Memoization<int> multiply_impure([&]()\n {\n return multiplexer * a * b;\n });\n\n      // Invoking Fetch() method in multiply_impure instance\n      // multiple times\n      for (int i = 0; i < 5; ++i)\n      {\n        ++multiplexer;\n        cout << \"Multiplexer = \" << multiplexer << endl;\n        cout << \"a * b = \" << multiply_impure.Fetch();\n        cout << endl;\n      }\n\n      return 0;\n    }\n\n```", "```cpp\n    /* not_optimize_code.cpp */\n    #include <iostream>\n    #include <functional>\n    #include <chrono>\n\n    using namespace std;\n\n    template<class T> class Delay\n    {\n      private:\n        function<T()> m_func;\n\n      public:\n        Delay(function<T()> func): m_func(func)\n        {\n        }\n\n        T Fetch()\n        {\n          return m_func();\n        }\n    };\n\n    // Function for calculating Fibonacci sequence\n    int fibonacci(int n)\n    {\n      if(n <= 1)\n         return n;\n      return fibonacci(n-1) + fibonacci(n-2);\n    }\n\n    auto main() -> int\n    {\n      cout << \"[not_optimize_code.cpp]\" << endl;\n\n      // Recording start time for the program\n      auto start = chrono::high_resolution_clock::now();\n\n      // Initializing int variable to store the result\n      // from Fibonacci calculation\n      int fib40Result = 0;\n\n      // Constructing Delay<> named fib40\n      Delay<int> fib40([]()\n      {\n        return fibonacci(40);\n      });\n\n      for (int i = 1; i <= 5; ++i)\n      {\n        cout << \"Invocation \" << i << \". \";\n\n        // Recording start time\n        auto start = chrono::high_resolution_clock::now();\n\n        // Invoking the Fetch() method\n        // in fib40 instance\n        fib40Result = fib40.Fetch();\n\n        // Recording end time\n        auto finish = chrono::high_resolution_clock::now();\n\n        // Calculating the elapsed time\n        chrono::duration<double, milli> elapsed = finish - start;\n\n        // Displaying the result\n        cout << \"Result = \" << fib40Result << \". \";\n\n        // Displaying elapsed time\n        // for each fib40.Fetch() invocation\n        cout << \"Consuming time = \" << elapsed.count();\n        cout << \" milliseconds\" << endl;\n      }\n\n       // Recording end time for the program\n       auto finish = chrono::high_resolution_clock::now();\n\n       // Calculating the elapsed time for the program\n       chrono::duration<double, milli> elapsed = finish - start;\n\n       // Displaying elapsed time for the program\n       cout << \"Total consuming time = \";\n       cout << elapsed.count() << \" milliseconds\" << endl;\n\n       return 0;\n    }\n\n```", "```cpp\n    /* optimizing_memoization.cpp */\n    #include <iostream>\n    #include <functional>\n    #include <chrono>\n\n    using namespace std;\n\n    template<class T> class Memoization\n    {\n      private:\n        T const & (*m_subRoutine)(Memoization *);\n        mutable T m_recordedFunc;\n        function<T()> m_func;\n\n        static T const & ForceSubroutine(Memoization * d)\n        {\n          return d->DoRecording();\n        }\n\n        static T const & FetchSubroutine(Memoization * d)\n        {\n          return d->FetchRecording();\n        }\n\n        T const & FetchRecording()\n        {\n          return m_recordedFunc;\n        }\n\n        T const & DoRecording()\n        {\n          m_recordedFunc = m_func();\n          m_subRoutine = &FetchSubroutine;\n          return FetchRecording();\n        }\n\n      public:\n        Memoization(function<T()> func): m_func(func),\n          m_subRoutine(&ForceSubroutine),\n          m_recordedFunc(T())\n          {\n          }\n\n        T Fetch()\n        {\n          return m_subRoutine(this);\n        }\n     };\n\n       // Function for calculating Fibonacci sequence\n       int fibonacci(int n)\n       {\n         if(n <= 1)\n           return n;\n           return fibonacci(n-1) + fibonacci(n-2);\n       }\n\n       auto main() -> int\n       {\n         cout << \"[optimizing_memoization.cpp]\" << endl;\n\n         // Recording start time for the program\n         auto start = chrono::high_resolution_clock::now();\n\n         // Initializing int variable to store the result\n         // from Fibonacci calculation\n         int fib40Result = 0;\n\n         // Constructing Memoization<> named fib40\n Memoization<int> fib40([]()\n {\n return fibonacci(40);\n });\n\n         for (int i = 1; i <= 5; ++i)\n         {\n           cout << \"Invocation \" << i << \". \";\n\n           // Recording start time\n           auto start = chrono::high_resolution_clock::now();\n\n           // Invoking the Fetch() method\n           // in fib40 instance\n           fib40Result = fib40.Fetch();\n\n           // Recording end time\n           auto finish = chrono::high_resolution_clock::now();\n\n           // Calculating the elapsed time\n           chrono::duration<double, milli> elapsed = finish - start;\n\n           // Displaying the result\n           cout << \"Result = \" << fib40Result << \". \";\n\n           // Displaying elapsed time\n           // for each fib40.Fetch() invocation\n           cout << \"Consuming time = \" << elapsed.count();\n           cout << \" milliseconds\" << endl;\n       }\n\n          // Recording end time for the program\n          auto finish = chrono::high_resolution_clock::now();\n\n          // Calculating the elapsed time for the program\n          chrono::duration<double, milli> elapsed = finish - start;\n\n          // Displaying elapsed time for the program\n          cout << \"Total consuming time = \";\n          cout << elapsed.count() << \" milliseconds\" << endl;\n\n          return 0;\n     }\n\n```", "```cpp\n    /* prime.cpp */\n    #include <iostream>\n    #include <cmath>\n\n    using namespace std;\n\n    bool PrimeCheck(int i)\n    {\n      // All even numbers are not prime number\n      // except 2\n      if ((i % 2) == 0)\n      {\n        return i == 2;\n      }\n\n      // Calculating the square root of i\n      // and store in int data type variable\n      // if the argument i is not even number,\n      int sqr = sqrt(i);\n\n      // For numbers 9 and below,\n      // the prime numbers is simply the odd numbers\n      // For number above 9\n      // the prime numbers is all of odd numbers\n      // except the square number\n      for (int t = 3; t <= sqr; t += 2)\n      {\n        if (i % t == 0)\n        {\n            return false;\n        }\n      }\n\n       // The number 1 is not prime number\n       // but still passing the preceding test\n       return i != 1;\n    }\n\n    auto main() -> int\n    {\n      cout << \"[delaying.cpp]\" << endl;\n\n      // Initializing a counting variable\n      int n = 0;\n\n      // Displaying the first 100 prime numbers\n      cout << \"List of the first 100 prime numbers:\" << endl;\n      for (int i = 0; ; ++i)\n      {\n        if (PrimeCheck(i))\n        {\n            cout << i << \"\\t\";\n\n            if (++n == 100)\n                return 0;\n        }\n      }\n\n      return 0;\n    }\n\n```", "```cpp\n    template<class T> class Chunk\n    {\n      private:\n        T m_value;\n        Row<T> m_lastRow;\n\n      public:\n        Chunk()\n         {\n         }\n\n        Chunk(T value, Row<T> lastRow): m_value(value),\n         m_lastRow(std::move(lastRow))\n        {\n        }\n\n        explicit Chunk(T value) : m_value(value)\n        {\n        }\n\n        T Value() const\n        {\n          return m_value;\n        }\n\n        Row<T> ShiftLastToFirst() const\n        {\n          return m_lastRow;\n        }\n    };\n\n```", "```cpp\n    template<class T> class Row\n    {\n      private:\n        std::shared_ptr <Memoization<Chunk<T>>>\n        m_lazyChunk;\n\n      public:\n         Row()\n         {\n         }\n\n         explicit Row(T value)\n         {\n           auto chunk = ChunkPreparation<T>(value);\n           m_lazyChunk = std::make_shared<Memoization<Chunk<T>>> \n           (chunk);\n         }\n\n         Row(T value, Row row)\n         {\n           auto chunk = ChunkPreparation<T>( value, std::move(row));\n\n           m_lazyChunk = std::make_shared<Memoization<Chunk<T>>>(\n           chunk);\n         }\n\n         Row(std::function<Chunk<T>()> func): m_lazyChunk(\n         std::make_shared<Memoization<Chunk<T>>>(func))\n         {\n         }\n\n         bool IsEmpty() const\n         {\n           return !m_lazyChunk;\n         }\n\n         T Fetch() const\n         {\n           return m_lazyChunk->Fetch().Value();\n         }\n\n         Row<T> ShiftLastToFirst() const\n         {\n          return m_lazyChunk->Fetch().ShiftLastToFirst();\n         }\n\n         Row Pick(int n) const\n         {\n           if (n == 0 || IsEmpty())\n            return Row();\n\n          auto chunk = m_lazyChunk;\n          return Row([chunk, n]()\n          {\n            auto val = chunk->Fetch().Value();\n            auto row = chunk->Fetch().ShiftLastToFirst();\n            return Chunk<T>(val, row.Pick(n - 1));\n          });\n         }\n    };\n\n```", "```cpp\n    template<class T> class ChunkPreparation\n    {\n      public:\n        T m_value;\n        Row<T> m_row;\n\n        ChunkPreparation(T value, Row<T> row) :\n          m_value(value),\n          m_row(std::move(row))\n          {\n          }\n\n        explicit ChunkPreparation(T value) :\n          m_value(value)\n          {\n          }\n\n        Chunk<T> operator()()\n        {\n          return Chunk<T>(\n            m_value,\n            m_row);\n        }\n    };\n\n```", "```cpp\n    template<class T> Row<T> ConcatenateRows(\n      Row<T> leftRow,\n      Row<T> rightRow)\n      {\n        if (leftRow.IsEmpty())\n          return rightRow;\n\n        return Row<T>([=]()\n        {\n          return Chunk<T>(\n            leftRow.Fetch(),\n            ConcatenateRows<T>(\n             leftRow.ShiftLastToFirst(),\n             rightRow));\n         });\n       }\n\n```", "```cpp\n    template<class T, class U> void ForEach( Row<T> row, U func)\n     {\n        while (!row.IsEmpty())\n        {\n          func(row.Fetch());\n          row = row.ShiftLastToFirst();\n         }\n     }\n\n```", "```cpp\n    Row<int> GenerateInfiniteIntRow( int initialNumber)\n    {\n      return Row<int>([initialNumber]()\n      {\n        return Chunk<int>(\n            initialNumber,\n            GenerateInfinityIntRow(\n             initialNumber + 1));\n      });\n    }\n\n```", "```cpp\n    Row<void*> PrimeCheck(int i)\n    {\n      if ((i % 2) == 0)\n      {\n        if (i == 2)\n            return Row<void*>(nullptr);\n        else\n            return Row<void*>();\n      }\n\n      int sqr = sqrt(i);\n\n      for (int t = 3; t <= sqr; t = t + 2)\n      {\n        if (i % t == 0)\n        {\n            return Row<void*>();\n        }\n      }\n\n      if (i == 1)\n        return Row<void*>();\n      else\n        return Row<void*>(nullptr);\n    }\n\n```", "```cpp\n    template<class T, class U> \n    auto JoiningPrimeNumber(\n      Row<T> row, U func) -> decltype(func())\n      {\n         return JoiningAllRows(\n           MappingRowByValue(row, func));\n      }\n\n```", "```cpp\n    template<class T, class U> \n    auto MappingRowByValue(\n      Row<T> row, U func) -> Row<decltype(func())>\n    {\n      using V = decltype(func());\n\n      if (row.IsEmpty())\n        return Row<V>();\n\n      return Row<V>([row, func]()\n      {\n        return Chunk<V>(\n          func(),\n          MappingRowByValue(\n            row.ShiftLastToFirst(),\n            func));\n      });\n    }\n\n```", "```cpp\n    template<class T, class U> Row<T> \n    Binding( Row<T> row, U func)\n    {\n       return JoiningAllRows( MappingRow( row, func));\n    }\n\n```", "```cpp\n    template<class T, class U>\n    auto MappingRow(\n      Row<T> row, U func) -> Row<decltype(\n        func(row.Fetch()))>\n      {\n        using V = decltype(func(row.Fetch()));\n\n        if (row.IsEmpty())\n          return Row<V>();\n\n        return Row<V>([row, func]()\n        {\n          return Chunk<V>(func(\n            row.Fetch()),\n            MappingRow(\n              row.ShiftLastToFirst(),\n              func));\n       });\n    }\n\n    template<class T> Row<T> \n    JoiningAllRows(\n      Row<Row<T>> rowOfRows)\n    {\n      while (!rowOfRows.IsEmpty() && \n        rowOfRows.Fetch().IsEmpty())\n      {\n        rowOfRows = rowOfRows.ShiftLastToFirst();\n      }\n\n     if (rowOfRows.IsEmpty()) \n        return Row<T>();\n\n     return Row<T>([rowOfRows]()\n     {\n        Row<T> row = rowOfRows.Fetch();\n\n        return Chunk<T>(\n          row.Fetch(), \n          ConcatenateRows(\n            row.ShiftLastToFirst(), \n            JoiningAllRows(\n              rowOfRows.ShiftLastToFirst())));\n     });\n    }\n\n```", "```cpp\n    Row<int> GenerateInfinitePrimeRow()\n    {\n      return Binding(\n        GenerateInfiniteIntRow(1),\n        [](int i)\n        {\n          return JoiningPrimeNumber(\n            PrimeCheck(i),\n            [i]()\n            {\n              return ConvertChunkToRow(i);\n            });\n        });\n     }\n\n```", "```cpp\n    template<class T> Row<T> \n    ConvertChunkToRow(\n      T value)\n      {\n        return Row<T>([value]()\n        {\n          return Chunk<T>(value);\n        });\n      }\n\n```", "```cpp\n    /* prime_lazy.cpp */\n    #include <iostream>\n    #include <cmath>\n    #include \"../lazyevaluation/lazyevaluation.h\"\n\n    using namespace std;\n\n    Row<void*> PrimeCheck(int i)\n    {\n      // Use preceding implementation\n    }\n\n    Row<int> GenerateInfiniteIntRow(\n      int initialNumber)\n    {\n      // Use preceding implementation\n    }\n\n    template<class T, class U>\n    auto MappingRow(\n      Row<T> row, U func) -> Row<decltype(\n        func(row.Fetch()))>\n      {     \n        // Use preceding implementation\n      }\n\n    template<class T, class U>\n    auto MappingRowByValue(\n      Row<T> row, U func) -> Row<decltype(func())>\n      {\n        // Use preceding implementation\n      }\n\n    template<class T> Row<T>\n    ConvertChunkToRow(\n      T value)\n    {\n      // Use preceding implementation\n    }\n\n    template<class T> Row<T>\n    JoiningAllRows(\n      Row<Row<T>> rowOfRows)\n    {\n      // Use preceding implementation\n    }\n\n    template<class T, class U> Row<T>\n    Binding(\n      Row<T> row, U func)\n      {\n        // Use preceding implementation\n      }\n\n    template<class T, class U>\n    auto JoiningPrimeNumber(\n      Row<T> row, U func) -> decltype(func())\n      {\n        // Use preceding implementation\n      }\n\n    Row<int> GenerateInfinitePrimeRow()\n    {\n      // Use preceding implementation\n    }\n\n    auto main() -> int\n    {\n      cout << \"[prime_lazy.cpp]\" << endl;\n\n      // Generating infinite prime numbers list\n      Row<int> r = GenerateInfinitePrimeRow();\n\n      // Picking the first 100 elements from preceding list\n      Row<int> firstAHundredPrimeNumbers = r.Pick(100);\n\n      // Displaying the first 100 prime numbers\n      cout << \"List of the first 100 prime numbers:\" << endl;\n      ForEach(\n        move(firstAHundredPrimeNumbers),\n        [](int const & i)\n        {\n            cout << i << \"\\t\";\n        });\n\n      return 0;\n    }\n\n```"]