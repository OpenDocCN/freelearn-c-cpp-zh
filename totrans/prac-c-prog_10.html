<html><head></head><body>
        

                            
                    <h1 class="header-title">Working with Graphs</h1>
                
            
            
                
<p>Graphs show information in pictorial format. In graphs, certain information is plotted and then those plotted points are connected through lines or bars. Each plotted point is called a <strong>vertex</strong> (the plural of this is vertices), and the lines connecting them are called <strong>edges</strong>. Graphs have the ability to display large volumes of data in an easy-to-understand manner. Therefore, when comparing huge or enormous data, graphs are generally preferred.</p>
<p>Graphs can be used in several applications that include displaying a certain route of transmission or flow of data packets. Graphs can also be used to represent a kind of connection between two cities or stations, where stations can be represented by vertices and the route can be represented by edges. On social media, even friends can be connected in the form of graphs where each person can be represented by vertices and the edges between them ensure that they are friends. Similarly, graphs can be used for representing different networks.</p>
<p>In this chapter, we will learn how to represent graphs using different data structures. We will also learn to traverse the graphs and create a minimum spanning tree from graphs. To be able to do so, we are going to look at the following recipes:</p>
<ul>
<li>Creating an adjacency matrix representation of a directed graph</li>
<li>Creating an adjacency matrix representation of an undirected graph</li>
<li>Creating an adjacency list representation of a directed graph</li>
<li>Carrying out the breadth-first traversal of a graph</li>
<li>Carrying out the depth-first traversal of a graph</li>
<li>Creating minimum spanning trees using Prim's algorithm</li>
<li>Creating minimum spanning trees using Kruskal's algorithm</li>
</ul>
<p>Before we begin with the recipes, let's have a quick introduction to the two main types of graphs.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Types of graphs</h1>
                
            
            
                
<p>Based on directions, graphs can be of two types: directed and undirected. Let's review both of them briefly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Directed graphs</h1>
                
            
            
                
<p>In a directed graph, the edges clearly show the direction from one vertex to another. An edge in a directed graph is usually represented as (v1, v2), which means that the edge is pointing from vertex v1 toward vertex v2. In other words, a (v1, v2) pair indicates that v1 is the starting vertex and v2 is the ending vertex. A directed graph is very useful in real-world applications and is used in the <strong>World Wide Web</strong> (<strong>WWW</strong>), Google's PageRank algorithm, and more. Consider the following directed graph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a5062c4e-8e1e-4a55-96f2-713e32046883.png" style="width:17.42em;height:15.83em;"/></p>
<p>Figure 10.1</p>
<p>Here, you can see an edge between vertices <strong>a</strong> and <strong>b</strong>. Because the edge is pointing from vertex <strong>a</strong> toward <strong>b</strong>, vertex <strong>a</strong> is considered to be the starting vertex and vertex <strong>b</strong> is considered the ending vertex. This edge can be represented as (<strong>a</strong>,<strong>b</strong>). Similarly, there is an edge from vertices <strong>a</strong> to <strong>c</strong>, which, in turn, can be represented as (<strong>a</strong>,<strong>c</strong>). Therefore, we can say that the preceding graph has the following set of vertices:</p>
<pre>(V) - { a,b,c,d,e}</pre>
<p>Additionally, the graph has the following set of edges:</p>
<pre>(E) - {(a,b), (a,c), (c,d), (c,e), (d,b), (d,e), (e,a), (e,b)}</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Undirected graphs</h1>
                
            
            
                
<p>An undirected graph is one in which the edges are present between vertices, but there is no specific direction identified – that is, there are no arrows at the end of the edges. Therefore, we cannot know which is the starting vertex and which one is the ending vertex. Undirected graphs are widely used in real-world applications such as Facebook and neural networks.</p>
<p>An edge between two vertices, <strong>a</strong> and <strong>b</strong>, in an undirected graph will mean that either of them can be a starting or ending vertex. Such an edge can be written as (<strong>a</strong>,<strong>b</strong>), that is, from <strong>a</strong> to <strong>b</strong>, as well as (<strong>b</strong>,<strong>a</strong>), that is, from <strong>b</strong> to <strong>a</strong>. The following diagram shows an undirected graph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/349dc9df-61a5-4b5d-9893-77c97c494847.png" style="width:17.42em;height:15.83em;"/></p>
<p>Figure 10.2</p>
<p>So, for this undirected graph, the following is the set of vertices:</p>
<pre>(V) - { a,b,c,d,e}</pre>
<p>Additionally, the graph will have the following set of edges:</p>
<pre>(E) - {(a,b), (b,a), (a,c), (c,a), (a,e), (e,a), (b,e), (e,b), (b,d), (d,b), (c,d), (d,c), (c,e), (e,c)}</pre>
<p class="mce-root">Now, let's begin with the recipes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an adjacency matrix representation of a directed graph</h1>
                
            
            
                
<p>An adjacency matrix is a square matrix that is used to represent a graph. The rows and columns of the matrix are labeled as per the graph vertices. So, if the graph vertices are <strong>1</strong>,<strong>2</strong>,...<strong>5</strong>, then the rows and columns of the adjacency matrix will be labeled as <strong>1</strong>,<strong>2</strong>,...<strong>5</strong>. Initially, the matrix is filled with all zeros (0). Then, the 0 at the <kbd>mat[i][j]</kbd> location (where <kbd>i</kbd> and <kbd>j</kbd> refer to the vertices) is replaced by 1 if there is an edge between the vertices of <kbd>i</kbd> and <kbd>j</kbd>. For example, if there is an edge from vertex <strong>2</strong> to vertex <strong>3</strong>, then at the <kbd>mat[2][3]</kbd> index location, the value of 0 will be replaced by <strong>1</strong>. In short, the elements of the adjacency matrix indicate whether pairs of vertices are adjacent or not in the graph.</p>
<p>Consider the following directed graph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a3baf581-8851-47ee-9edf-036a6dc43230.png" style="width:19.33em;height:17.25em;"/></p>
<p>Figure 10.3</p>
<p>Its adjacency matrix representation is as follows:</p>
<pre>5,5          1              2              3              4              5<br/>-----------------------------------------------------------------------------<br/>1            0              1              1              0              0<br/>2            0              0              0              0              0<br/>3            0              0              0              1              1<br/>4            0              1              0              0              1<br/>5            1              1              0              0              0</pre>
<p>The first row and the first column represent the vertices. If there is an edge between two vertices, then there will be a <kbd>1</kbd> value at the intersection of their respective row and column. The absence of an edge between them will be represented by <kbd>0</kbd>. The number of nonzero elements of an adjacency matrix indicates the number of edges in a directed graph.</p>
<p>Here are two drawbacks of adjacency matrix representation:</p>
<ul>
<li>This representation requires <em>n<sup>2</sup></em> elements to represent a graph having <em>n</em> vertices. If a directed graph has <em>e</em> edges, then (<em>n<sup>2</sup>-e</em>) elements in the matrix would be zeros. Therefore, for graphs with a very low number of edges, the matrix becomes very sparse.</li>
<li>Parallel edges cannot be represented by an adjacency matrix.</li>
</ul>
<p>In this recipe, we will learn how to make an adjacency matrix representation of a directed graph.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Perform the following steps to create an adjacency matrix representation of a graph:</p>
<ol>
<li>Ask the user for the number of vertices in the graph.</li>
<li>Define a square matrix that is equal to the number of vertices.</li>
<li>Initialize all the elements of the matrix to 0.</li>
<li>Ask the user to enter the edges. For each edge (<kbd>i</kbd>,<kbd>j</kbd>) entered by the user, replace 0 at the <kbd>mat[i][j]</kbd> index location.</li>
<li>Once all the edges are entered, display all of the elements of the adjacency matrix.</li>
</ol>
<p>The code for creating an adjacency matrix representation of a graph is as follows:</p>
<pre>//<strong>adjmatdirect.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>#define max 10<br/>int main() {<br/>  static int edg[max][max], i, j, v1, v2, numb;<br/>  printf("How many vertices are there? ");<br/>  scanf("%d", &amp; numb);<br/>  printf("We assume that the vertices are numbered from : ");<br/>  for (i = 1; i &lt;= numb; i++) printf("%d ", i);<br/>  printf("\nEnter the edges of the graph. Like 1 4 if there is an \n");<br/>  printf("edge between vertex 1 and 4. Enter 0 0 when over\n");<br/>  for (i = 1; i &lt;= numb * (numb - 1); i++) {<br/>    /* The for loop will run for at most numb*(numb-1) times because, <br/>       the number of edges are at most numb*(numb-1) where numb is <br/>       the number of vertices */<br/>    scanf("%d %d", &amp; v1, &amp; v2);<br/>    if (v1 == 0 &amp;&amp; v2 == 0) break;<br/>    edg[v1][v2] = 1;<br/>  }<br/>  printf("\nThe adjacency matrix for the graph is \n");<br/>  for (i = 1; i &lt;= numb; i++) printf("\t%d", i);<br/>  printf("\n-----------------------------------------------------\n");<br/>  for (i = 1; i &lt;= numb; i++) {<br/>    printf("%d |\t", i);<br/>    for (j = 1; j &lt;= numb; j++) {<br/>      printf("%d\t", edg[i][j]);<br/>    }<br/>    printf("\n");<br/>  }<br/>  return 0;<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Assuming that the directed graphs the user will specify in this program will not be of more than 10 vertices, define a macro called <kbd>max</kbd> of value <kbd>10</kbd> and a two-dimensional matrix called <kbd>edg</kbd>, consisting of max rows and max columns. However, you can always increase the size of the macro if you think the user can specify a graph of more than 10 vertices.</p>
<p>In order to initialize all of the elements of the <kbd>edg</kbd> matrix to 0, define it as a static matrix. Thereafter, the user will be prompted to specify how many vertices there are in the graph. Suppose the user enters 5 to indicate that there are 5 vertices in the graph, then that value will be assigned to the <kbd>numb</kbd> variable. </p>
<p>To make the recipe easy to understand, we assume that the vertices are sequentially numbered from 1 to 5. The user is prompted to specify the edges between the vertices. This means that if there is an edge between vertices 1 and 3, then the user is supposed to enter the edge as 1,3. The vertices entered representing these edges are then assigned to the vertices of v1 and v2. Because the user is asked to specify the edges of the graph and to enter <kbd>0 0</kbd> when over, when the edge is assigned to the vertices of v1 and v2, we first ensure that the vertices are not 0 and 0. If they are, the program will stop asking for more edges and will branch to the statement from where the display of the adjacency matrix begins. If the vertices in the edge are not zero, then a value, 1, is assigned in the two-dimensional <kbd>edg</kbd> matrix at the index location of <kbd>[v1][v2]</kbd>. So, if there is an edge between vertices 1 and 2, then value 1 will be assigned at the <kbd>edg[1][2]</kbd> index location, replacing the value 0 that was initially there.</p>
<p>When all the edges of the graph are entered, the user will enter the vertices as <kbd>0 0</kbd> to indicate that all the edges have been entered. In that case, a nested <kbd>for</kbd> loop is executed and all the elements of the <kbd>edg</kbd> matrix are displayed on screen.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during the compilation, this means the <kbd>adjmatdirect.c</kbd> program has successfully compiled into the <kbd>adjmatdirect.exe</kbd> file. On executing the file, the user will be prompted to specify the number of vertices and its edges. Once the vertices and edges are entered, the program will display the adjacency matrix representation of the graph (take a look at the following screenshot):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0108a289-b589-44a0-8bba-4528db949081.png" style="width:33.58em;height:29.83em;"/></p>
<p>Figure 10.4</p>
<p>Now, let's explore how to do the same thing for an undirected graph.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an adjacency matrix representation of an undirected graph</h1>
                
            
            
                
<p>By adding one more statement in this recipe's code, the same program can be used for creating the adjacency matrix representation of an undirected graph as well. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We refer to the same graph that was in the previous recipe; however, this time, there are no edges:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/23fcc3bf-4b99-4c22-8808-f609381d5611.png" style="width:14.25em;height:12.67em;"/></p>
<p>Figure 10.5</p>
<p>Its adjacency matrix representation is as follows:</p>
<pre>5,5          1              2              3              4              5<br/>----------------------------------------------------------------------------<br/>1            0              1              1              0              1<br/>2            1              0              0              1              1<br/>3            1              0              0              1              1<br/>4            0              1              1              0              1<br/>5            1              1              1              1              0</pre>
<p>The only difference between the programs of the directed and undirected graphs is that, in the latter, the edge is simply repeated. That is, if there is an edge between a and b, then it is considered to be two edges: one from a to b and the other from b to a.</p>
<p>The program for creating an adjacency matrix representation of an undirected graph is as follows:</p>
<pre>//<strong>adjmatundirect.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>#define max 10<br/><br/>int main() {<br/>  static int edg[max][max], i, j, v1, v2, numb;<br/>  printf("How many vertices are there? ");<br/>  scanf("%d", &amp; numb);<br/>  printf("We assume that the vertices are numbered from : ");<br/>  for (i = 1; i &lt;= numb; i++) printf("%d ", i);<br/>  printf("\nEnter the edges of the graph. Like 1 4 if there is an \n");<br/>  printf("edge between vertex 1 and 4. Enter 0 0 when over\n");<br/>  for (i = 1; i &lt;= numb * (numb - 1); i++) {<br/>    /* The for loop will run for at most numb*(numb-1) times because, the <br/>       number of edges are at most numb*(numb-1) where numb is the number <br/>       of vertices */<br/>    scanf("%d %d", &amp; v1, &amp; v2);<br/>    if (v1 == 0 &amp;&amp; v2 == 0) break;<br/>    edg[v1][v2] = 1;<br/>    edg[v2][v1] = 1;<br/>  }<br/>  printf("\nThe adjacency matrix for the graph is \n");<br/>  for (i = 1; i &lt;= numb; i++) printf("\t%d", i);<br/>  printf("\n----------------------------------------------------------\n");<br/>  for (i = 1; i &lt;= numb; i++) {<br/>    printf("%d |\t", i);<br/>    for (j = 1; j &lt;= numb; j++) {<br/>      printf("%d\t", edg[i][j]);<br/>    }<br/>    printf("\n");<br/>  }<br/>  return 0;<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>When you compare the preceding program with that of the directed graph, you will notice that only one extra statement has been added (marked in bold):</p>
<pre>edg[v2][v1]=1;</pre>
<p>That is, in the case of an edge from <kbd>v1</kbd> to <kbd>v2</kbd>, an edge in reverse is also assumed, that is, from <kbd>v2</kbd> to <kbd>v1</kbd>.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during the compilation, this means the <kbd>adjmatundirect.c</kbd> program has successfully compiled into the <kbd>adjmatundirect.exe</kbd> file. As expected, on running the file, the user will be prompted to specify the number of vertices and their edges. Once the number of vertices and edges are entered, the program will display the adjacency matrix representation of the undirected graph, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e870eb0c-3c29-4a96-81a2-ba2d39eb63fe.png" style="width:33.25em;height:37.67em;"/></p>
<p>Figure 10.6</p>
<p>Now, let's move on to the next recipe!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an adjacency list representation of a directed graph</h1>
                
            
            
                
<p>In an adjacency list representation, linked lists are used to represent the adjacent vertices of a vertex. That is, a separate linked list is made for the adjacent vertices of each vertex, and, in the end, all the vertices of the graph are connected. Because linked lists are used, this way of representing a graph uses memory in a more optimized manner. </p>
<p>Consider the following directed graph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fcfe1d39-0202-4cff-a19a-44e462f07844.png" style="width:13.67em;height:12.17em;"/></p>
<p>Figure 10.7</p>
<p>Its adjacency list representation is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a9282884-cdbe-41d8-a7d1-a427cd450009.png" style="width:13.33em;height:19.50em;"/></p>
<p>Figure 10.8</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You can see in the preceding diagram that the adjacent vertices of vertex <strong>1</strong> are connected in the form of a linked list. Because there are no adjacent vertices for vertex <strong>2</strong>, its pointer is pointing to <strong>NULL</strong>. Similarly, the adjacent vertices of vertex <strong>3</strong>, that is, vertices <strong>4</strong> and <strong>5</strong>, are connected to vertex <strong>3</strong> in the form of a linked list. Once a linked list of all the vertices of the entire graph is created, all the vertices become connected through a link.</p>
<p>In this recipe, we will learn how to create the adjacency list representation of a directed graph.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to create an adjacency list representation of a graph:</p>
<ol>
<li>Define a structure called <kbd>node</kbd> that contains three members. One member, <kbd>nme</kbd>, is for storing the vertex of the graph; another member, <kbd>vrt</kbd>, is for connecting vertices of the graph; and, finally, <kbd>edg</kbd> is for connecting the adjacent vertices of the vertex.</li>
<li>The user is asked to specify the count of the vertices in the graph.</li>
<li>A linked list is created where the <kbd>nme</kbd> member of each node contains the vertex of the graph.</li>
<li>All the nodes representing vertices of the graph are connected to each other using the <kbd>vrt</kbd> pointer.</li>
<li>Once all the vertices are entered, the user is prompted to enter the edges of the graph. The user can enter any number of edges and to indicate that all the edges are entered, the user can enter <kbd>0 0</kbd> for the edge.</li>
<li>When an edge is entered, for example, <kbd>b</kbd>, a <kbd>temp1</kbd> pointer is used and is set to point to vertex <kbd>a</kbd>.</li>
<li>A new node is created called <kbd>newNode</kbd>, and the vertex name <kbd>b</kbd> is assigned to the <kbd>nme</kbd> member of <kbd>newNode</kbd>.</li>
<li>One more pointer is used, called <kbd>temp2</kbd>, and is set to point to the last node that is connected to vertex <kbd>a</kbd>. Once <kbd>temp2</kbd> reaches the end of vertex <kbd>a</kbd>, the <kbd>edg</kbd> member of the <kbd>temp2</kbd> node is set to point to <kbd>newNode</kbd>, and hence establishing an edge between <kbd>a</kbd> and <kbd>b</kbd>.</li>
</ol>
<p>The program for creating the adjacency list representation of a directed graph is as follows:</p>
<pre>//<strong>adjlistdirect.c</strong><br/><br/>#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>struct node {<br/>  char nme;<br/>  struct node * vrt;<br/>  struct node * edg;<br/>};<br/><br/>int main() {<br/>  int numb, i, j, noe;<br/>  char v1, v2;<br/>  struct node * startList, * newNode, * temp1, * temp2;<br/>  printf("How many vertices are there ? ");<br/>  scanf("%d", &amp; numb);<br/>  startList = NULL;<br/>  printf("Enter all vertices names\n");<br/>  for (i = 1; i &lt;= numb; i++) {<br/>    if (startList == NULL) {<br/>      newNode = malloc(sizeof(struct node));<br/>      scanf(" %c", &amp; newNode - &gt; nme); /* There is a space before %c */<br/>      startList = newNode;<br/>      temp1 = newNode;<br/>      newNode - &gt; vrt = NULL;<br/>      newNode - &gt; edg = NULL;<br/>    } else {<br/>      newNode = malloc(sizeof(struct node));<br/>      scanf(" %c", &amp; newNode - &gt; nme);<br/>      /* There is a space before %c */<br/>      newNode - &gt; vrt = NULL;<br/>      newNode - &gt; edg = NULL;<br/>      temp1 - &gt; vrt = newNode;<br/>      temp1 = newNode;<br/>    }<br/>  }<br/>  printf("Enter the edges between vertices. Enter v1 v2, if there is an edge\n");<br/>  printf("between v1 and v2. Enter 0 0 if over\n");<br/>  noe = numb * (numb - 1);<br/>  for (j = 1; j &lt;= noe; j++) {<br/>    scanf(" %c %c", &amp; v1, &amp; v2);<br/>    /* There is a space before %c */<br/>    if (v1 == '0' &amp;&amp; v2 == '0') break;<br/>    temp1 = startList;<br/>    while (temp1 != NULL &amp;&amp; temp1 - &gt; nme != v1)<br/>      temp1 = temp1 - &gt; vrt;<br/>    if (temp1 == NULL) {<br/>      printf("Sorry no vertex exist by this name\n");<br/>      break;<br/>    }<br/>    temp2 = temp1;<br/>    while (temp2 - &gt; edg != NULL) temp2 = temp2 - &gt; edg;<br/>    newNode = malloc(sizeof(struct node));<br/>    newNode - &gt; nme = v2;<br/>    temp2 - &gt; edg = newNode;<br/>    newNode - &gt; edg = NULL;<br/>    newNode - &gt; vrt = NULL;<br/>  }<br/>  printf("\nAdjacency List representation of Graph is\n");<br/>  temp1 = startList;<br/>  while (temp1 != NULL) {<br/>    printf("%c\t", temp1 - &gt; nme);<br/>    temp2 = temp1 - &gt; edg;<br/>    while (temp2 != NULL) {<br/>      printf("%c\t", temp2 - &gt; nme);<br/>      temp2 = temp2 - &gt; edg;<br/>    }<br/>    printf("\n");<br/>    temp1 = temp1 - &gt; vrt;<br/>  }<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's assume we are working with the following directed graph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/555ca202-5a0e-491e-97f8-b069cbaeddd8.png" style="width:15.75em;height:14.33em;"/></p>
<p>Figure 10.9</p>
<p>The adjacency list representation of this graph is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/908066b7-5c0f-4b4b-8aaa-54f7933bfa76.png" style="width:14.75em;height:21.00em;"/></p>
<p>Figure 10.10</p>
<p>We define a structure called "node" comprising the following three members:</p>
<ul>
<li><kbd>nme</kbd>: This is for storing the vertex.</li>
<li><kbd>vrt</kbd>: A pointer to connect all the vertices of the graph.</li>
<li><kbd>edg</kbd>: A pointer that connects all the vertices that are connected to the current vertex:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/256393a7-3cbe-400f-9ecc-85b6f50aa46c.png" style="width:22.17em;height:12.00em;"/></p>
<p>Figure 10.11</p>
<p>The user is prompted to specify the number of vertices. Assuming the user enters the value of 5, the value of 5 will be assigned to the <kbd>numb</kbd> variable. A <kbd>startList</kbd> pointer is defined as <kbd>NULL</kbd>. The whole adjacency list will be accessed through this <kbd>startList</kbd> pointer and it will be set to point to the first vertex of the graph. The user is first asked to enter the names of the vertices.</p>
<p>Initially, the <kbd>startList</kbd> pointer is <kbd>NULL</kbd>, so a new node called <kbd>newNode</kbd> is created and the vertex name, say <kbd>a</kbd>, entered by the user is assigned to the <kbd>nme</kbd> member of <kbd>newNode</kbd>. The <kbd>startList</kbd> pointer is set to point to <kbd>newNode</kbd>. To connect more vertices with <kbd>newNode</kbd>, the <kbd>temp1</kbd> pointer is set to point to <kbd>newNode</kbd>. Initially, both the pointers, <kbd>vrt</kbd> and <kbd>edg</kbd>, are also set to <kbd>NULL</kbd>. Later, the <kbd>vrt</kbd> pointer will be set to point to other vertices and the <kbd>edg</kbd> pointer will be set to point to the vertices in which this current vertex is connected to. After the first iteration of the <kbd>for</kbd> loop, the node of the graph will look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c2d8f1c3-3240-490c-9c6a-34c34e92ec21.png" style="width:15.33em;height:10.75em;"/></p>
<p>Figure 10.12</p>
<p>In the second iteration of the <kbd>for</kbd> loop, because the <kbd>startList</kbd> pointer is no longer <kbd>NULL</kbd>, the <kbd>else</kbd> block will execute and, again, a new node is created, called <kbd>newNode</kbd>. Next, the vertex name is assigned to the named member of the <kbd>newNode</kbd>. Again, the <kbd>vrt</kbd> and <kbd>edg</kbd> pointers of <kbd>newNode</kbd> are set to <kbd>NULL</kbd>. To connect <kbd>newNode</kbd> to the earlier vertex, we will take the help of the <kbd>temp1</kbd> pointer. The <kbd>vrt</kbd> pointer of the node, which is pointed to by the <kbd>temp1</kbd> pointer, is set to point to <kbd>newNode</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/879493c2-998a-4f4d-97ae-6d741419e422.png" style="width:10.75em;height:11.08em;"/></p>
<p>Figure 10.13</p>
<p>Then, the <kbd>temp1</kbd> pointer is set to point to <kbd>newNode</kbd>, and the process is repeated for the rest of the vertices. Essentially, the <kbd>temp1</kbd> pointer is used for connecting more vertices. At the end of the <kbd>for</kbd> loop, the nodes will appear connected as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/22e98e49-d848-47c9-89d1-804949f6a2fb.png" style="width:10.00em;height:20.42em;"/></p>
<p>Figure 10.14</p>
<p>Once all the vertices of the graphs are entered, the user is asked to specify the edges between the vertices. Additionally, the user is asked to enter <kbd>0 0</kbd> when all the edges of the graph are entered. Suppose that the user enters <kbd>a b</kbd> to indicate there is an edge from vertex <kbd>a</kbd> to vertex <kbd>b</kbd>. The vertices are assigned to the <kbd>v1</kbd> and <kbd>v2</kbd> variables, respectively. We first ensure that the data in <kbd>v1</kbd> and <kbd>v2</kbd> is not 0. If yes, that means all the edges of the graph are entered and the program will jump to the statement from where the display of the adjacency list begins.</p>
<p>Then, to connect the <kbd>a</kbd> and <kbd>b</kbd> vertices, first, the <kbd>temp1</kbd> pointer is set to point to <kbd>startList</kbd>. The <kbd>temp1</kbd> pointer is set to find the node whose <kbd>nme</kbd> member is equal to the vertex entered in variable <kbd>v1</kbd>, that is, <kbd>a</kbd>. The <kbd>temp1</kbd> pointer is already pointing to vertex <kbd>a</kbd>. Thereafter, you need to find the last node that is connected to <kbd>temp1</kbd>. The <kbd>temp2</kbd> pointer is used for finding the last node connected to the node pointed to by <kbd>temp1</kbd>. Because this is the first edge being entered of vertex <kbd>a</kbd>, the <kbd>edg</kbd> member of the node pointed to by <kbd>temp2</kbd> is already <kbd>NULL</kbd>. So, a new node is created called <kbd>newNode</kbd>, and the vertex name in variable <kbd>v2</kbd>, that is, <kbd>b</kbd> is assigned to the <kbd>nme</kbd> variable of <kbd>newNode</kbd>. The <kbd>edg</kbd> and <kbd>vrt</kbd> members of <kbd>newNode</kbd> are set to <kbd>NULL</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/66abaa9d-3396-47a0-a427-035b56e28639.png" style="width:22.25em;height:21.25em;"/></p>
<p>Figure 10.15</p>
<p>The <kbd>edg</kbd> member of <kbd>temp2</kbd> is set to point to <kbd>newNode</kbd> as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/42b65eb4-af47-4abc-97ec-d3a6f0f27cbf.png" style="width:15.42em;height:24.08em;"/></p>
<p>Figure 10.16</p>
<p>The procedure is repeated for the rest of the edges entered by the user.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during the compilation, this means the <kbd>adjlistdirect.c</kbd> program has successfully compiled into the <kbd>adjlistdirect.exe</kbd> file. On executing the executable file, the user will be prompted to specify the number of vertices and their edges. Once the vertices and edges are entered, the program will display the adjacency list representation of the directed graph, as shown in the following screenshot:</p>
<div><img src="img/1b880d52-cd82-4e36-aa24-4ed14c6d2226.png" style="width:37.17em;height:35.08em;"/></div>
<p>Figure 10.17</p>
<p>Now, let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Carrying out the breadth-first traversal of a graph</h1>
                
            
            
                
<p>The traversal of a graph refers to when you visit each of the vertices of a graph exactly once in a well-defined order. To ensure that each vertex of the graph is visited only once and to know which vertices have already been visited, the best way is to mark them. We will also look at how vertices are marked in this recipe.</p>
<p>Breadth-first traversal tends to create very short and wide trees. It operates by vertices in layers, that is, the vertices closest to the start are evaluated first, and the most distant vertices are evaluated last. Hence, it is referred to as the level-by-level traversal of the tree. The breadth-first traversal of a graph is very popularly used for finding the shortest path between two locations (vertices), that is, the path with the least number of edges. It is also used to find the linked pages of a web page, broadcasting information, and more.</p>
<p>In this recipe, we will learn how to carry out the breadth-first traversal of a graph.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to carry out the breadth-first traversal of a graph:</p>
<ol>
<li>Add the first vertex of the graph into the queue. Any vertex can be chosen as a starting vertex.</li>
<li>Then, repeat the following <em>steps 3</em> to <em>8</em> until the queue is empty.</li>
<li>Take out the vertex from the queue and store it in a variable, say <kbd>v</kbd>.</li>
<li>Mark it as visited (the marking is done so that this vertex should not be traversed again).</li>
<li>Display the marked vertex.</li>
<li>Find out the adjacency vertices of the vertex <kbd>v</kbd>, and then perform <em>steps 7</em> to <em>8</em> on each of them.</li>
<li>If any of the adjacency vertices of <kbd>v</kbd> are not marked, mark it as visited.</li>
<li>Add the adjacency vertex to the queue.</li>
<li>Exit.</li>
</ol>
<p>The program for the breadth-first traversal of a graph is as follows:</p>
<pre>//<strong>breadthfirsttrav.c</strong><br/><br/>#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>#define max 20<br/><br/>enum Setmarked {<br/>  Y,<br/>  N<br/>};<br/>struct node {<br/>  char nme;<br/>  struct node * vrt;<br/>  struct node * edg;<br/>  enum Setmarked marked;<br/>};<br/><br/>struct node * que[max];<br/>int rear = -1, front = -1;<br/>void queue(struct node * paramNode);<br/>struct node * dequeue();<br/><br/>int main() {<br/>  int numb, i, j, noe;<br/>  char v1, v2;<br/>  struct node * startList, * newNode, * temp1, * temp2, * temp3;<br/>  printf("How many vertices are there ?");<br/>  scanf("%d", &amp; numb);<br/>  startList = NULL;<br/>  printf("Enter all vertices names\n");<br/>  for (i = 1; i &lt;= numb; i++) {<br/>    if (startList == NULL) {<br/>      newNode = malloc(sizeof(struct node));<br/>      scanf(" %c", &amp; newNode - &gt; nme);<br/>      /* There is a space before %c */<br/>      startList = newNode;<br/>      temp1 = newNode;<br/>      newNode - &gt; vrt = NULL;<br/>      newNode - &gt; edg = NULL;<br/>      newNode - &gt; marked = N;<br/>    } else {<br/>      newNode = malloc(sizeof(struct node));<br/>      scanf(" %c", &amp; newNode - &gt; nme);<br/>      /* There is a space before %c */<br/>      newNode - &gt; vrt = NULL;<br/>      newNode - &gt; edg = NULL;<br/>      newNode - &gt; marked = N;<br/>      temp1 - &gt; vrt = newNode;<br/>      temp1 = newNode;<br/>    }<br/>  }<br/>  printf("Enter the edges between vertices. Enter v1 v2, if there is an edge\n");<br/>  printf("between v1 and v2. Enter 0 0 if over\n");<br/>  noe = numb * (numb - 1);<br/>  for (j = 1; j &lt;= noe; j++) {<br/>    scanf(" %c %c", &amp; v1, &amp; v2);<br/>    /* There is a space before %c */<br/>    if (v1 == '0' &amp;&amp; v2 == '0') break;<br/>    temp1 = startList;<br/>    while (temp1 != NULL &amp;&amp; temp1 - &gt; nme != v1)<br/>      temp1 = temp1 - &gt; vrt;<br/>    if (temp1 == NULL) {<br/>      printf("Sorry no vertex exist by this name\n");<br/>      break;<br/>    }<br/>    temp2 = temp1;<br/>    while (temp2 - &gt; edg != NULL) temp2 = temp2 - &gt; edg;<br/>    newNode = malloc(sizeof(struct node));<br/>    newNode - &gt; nme = v2;<br/>    temp2 - &gt; edg = newNode;<br/>    newNode - &gt; edg = NULL;<br/>    newNode - &gt; vrt = NULL;<br/>  }<br/>  printf("\nAdjacency List representation of Graph is\n");<br/>  temp1 = startList;<br/>  while (temp1 != NULL) {<br/>    printf("%c\t", temp1 - &gt; nme);<br/>    temp2 = temp1 - &gt; edg;<br/>    while (temp2 != NULL) {<br/>      printf("%c\t", temp2 - &gt; nme);<br/>      temp2 = temp2 - &gt; edg;<br/>    }<br/>    printf("\n");<br/>    temp1 = temp1 - &gt; vrt;<br/>  }<br/>  printf("\nBreadth First traversal of the graph is \n");<br/>  temp1 = startList;<br/>  if (temp1 == NULL)<br/>    printf("Sorry no vertices in the graph\n");<br/>  else<br/>    queue(temp1);<br/>  while (rear != -1) {<br/>    temp3 = dequeue();<br/>    temp1 = startList;<br/>    while (temp1 - &gt; nme != temp3 - &gt; nme) temp1 = temp1 - &gt; vrt;<br/>    temp3 = temp1;<br/>    if (temp3 - &gt; marked == N) {<br/>      printf("%c\t", temp3 - &gt; nme);<br/>      temp3 - &gt; marked = Y;<br/>      temp2 = temp3 - &gt; edg;<br/>      while (temp2 != NULL) {<br/>        queue(temp2);<br/>        temp2 = temp2 - &gt; edg;<br/>      }<br/>    }<br/>  }<br/>  return 0;<br/>}<br/><br/>void queue(struct node * paramNode) {<br/>  rear++;<br/>  que[rear] = paramNode;<br/>  if (front == -1) front = 0;<br/>}<br/><br/>struct node * dequeue() {<br/>  struct node * tempNode;<br/>  if (front == rear) {<br/>    tempNode = que[front];<br/>    front = -1;<br/>    rear = -1;<br/>  } else {<br/>    tempNode = que[front];<br/>    front++;<br/>  }<br/>  return (tempNode);<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We are using the adjacency list representation of the directed graph from the previous recipe, <em>Creating an adjacency list representation of a directed graph</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1c4d94a8-b74d-4637-b21f-172779bab61c.png" style="width:12.58em;height:18.00em;"/></p>
<p>Figure 10.18</p>
<p>The <kbd>temp1</kbd> pointer is set to point to <kbd>startList</kbd>. That is, <kbd>temp1</kbd> is pointing to the node with vertex <kbd>a</kbd>. If <kbd>temp1</kbd> is not <kbd>NULL</kbd>, the node pointed to by the <kbd>temp1</kbd> pointer is added to the queue. The rear variable, which is -1 at the moment, is incremented to 0 and the <kbd>a</kbd> node is added to the array of <kbd>que</kbd> nodes at index location <kbd>0</kbd>. Because the value of the front index location is -1 currently, the front is also set to 0, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b33f87ad-50e3-4754-8199-16b074cef499.png" style="width:19.50em;height:8.92em;"/></p>
<p>Figure 10.19</p>
<p>Thereafter, the dequeue function is invoked to remove a node from the queue. Unsurprisingly, the node at the <kbd>que[0]</kbd> index location, that is, <kbd>a</kbd>, is returned and, because the values of <strong>front</strong> and <strong>rear</strong> are the same, the values of the <strong>front</strong> and <strong>rear</strong> indices are set to -1, to indicate that the queue is empty again.</p>
<p>The node containing vertex <kbd>a</kbd> is returned from the queue and is assigned to the <kbd>temp3</kbd> pointer. The <kbd>temp1</kbd> pointer is set to point to the <kbd>startList</kbd> pointer. The marked member of the <kbd>temp3</kbd> node, that is, vertex <kbd>a</kbd>, is set to <kbd>N</kbd> initially. The vertex name stored in the <kbd>nme</kbd> member of the node is displayed, that is, vertex <kbd>a</kbd> is displayed on screen.</p>
<p>After displaying vertex <kbd>a</kbd>, its marked member is set to <kbd>Y</kbd> to indicate that the node is visited and should not be traversed again. The next step is to find the adjacent vertices of vertex <kbd>a</kbd>. To do so, the <kbd>temp2</kbd> pointer is set to point to where the <kbd>edg</kbd> pointer of <kbd>temp3</kbd> is pointing. The <kbd>edg</kbd> pointer of <kbd>temp3</kbd> is pointing at vertex <kbd>b</kbd>, so <kbd>temp2</kbd> is set to point at vertex <kbd>b</kbd>. Again, the procedure is repeated. If <kbd>temp2</kbd> is not <kbd>NULL</kbd>, the <kbd>b</kbd> node is queued, that is, it is added to the <kbd>que[0]</kbd> index location. Because all of the nodes that are connected to vertex <kbd>a</kbd> have to be queued, the <kbd>temp2</kbd> pointer is set to point to the location where its <kbd>edg</kbd> pointer is pointing. The <kbd>edg</kbd> pointer of node <kbd>b</kbd> (in the adjacency list) is pointing to node <kbd>c</kbd>, so node <kbd>c</kbd> is also inserted into the queue at the <kbd>que[1]</kbd> index location as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/20e1aa1d-add2-48e9-b146-f0e7da5c9efd.png" style="width:15.42em;height:6.92em;"/></p>
<p>Figure 10.20</p>
<p class="mce-root"/>
<p>In the queue, nodes <kbd>b</kbd> and <kbd>c</kbd> are present. Now, again, the dequeue function is invoked; node <kbd>b</kbd> is removed from the queue and the <kbd>temp3</kbd> pointer is set to point to it. The <kbd>temp1</kbd> pointer is initially set to point to <kbd>startList</kbd> and, thereafter, by making use of its <kbd>vrt</kbd> pointer, the <kbd>temp1</kbd> pointer is set to point to vertex <kbd>b</kbd>. Because the marked member of node <kbd>b</kbd> is <kbd>N</kbd>, its vertex name, <kbd>b</kbd>, is displayed on screen followed by setting its marked member to <kbd>Y</kbd>. A <kbd>temp2</kbd> pointer is set to point to where the <kbd>edg</kbd> member of node <kbd>b</kbd> is pointing. The <kbd>edg</kbd> member of node <kbd>b</kbd> is pointing to <kbd>NULL</kbd>, so the next node in the queue is accessed, that is, node <kbd>c</kbd> is removed from the queue and the <kbd>temp3</kbd> pointer is set to point to it. Because the queue is again empty, the values of the <kbd>front</kbd> and <kbd>rear</kbd> variables are set to -1.</p>
<p>Again, the <kbd>temp1</kbd> pointer is set to point at vertex <kbd>c</kbd>, and the <kbd>c</kbd> node is displayed on screen, that is, it is traversed and its marked member is set to <kbd>Y</kbd>. So, up until now, nodes <kbd>a</kbd>, <kbd>b</kbd>, and <kbd>c</kbd> are displayed on screen. And the node that is attached to the <kbd>edg</kbd> member of <kbd>c</kbd> is added to the queue, that is, node <kbd>d</kbd> is added to the queue at the <kbd>que[0]</kbd> index location. Additionally, the node pointed to by the <kbd>edg</kbd> pointer of node <kbd>d</kbd> is accessed, that is, node <kbd>e</kbd> is also queued or, in other words, added at the <kbd>que[1]</kbd> index location as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c44d849e-75b0-467d-9350-d19cd652d4df.png" style="width:17.00em;height:7.75em;"/></p>
<p>Figure 10.21</p>
<p>Node <kbd>d</kbd> is removed from the queue and displayed (traversed). The nodes pointed to by their <kbd>edg</kbd> member are accessed and, if any of them is marked, then <kbd>N</kbd> is added to the queue. The whole procedure is repeated until the queue becomes empty. The sequence in which the vertices are displayed on screen forms the breadth-first traversal of the graph.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during the compilation, this means the <kbd>breadthfirsttrav.c</kbd> program has successfully compiled into the <kbd>breadthfirsttrav.exe</kbd> file. On executing the file, the user will be prompted to specify the count of vertices in the graph, followed by entering the vertices' names. Thereafter, the user is asked to enter the edges of the graph and to enter <kbd>0 0</kbd> when completed. After the edges of the graph have been entered, the adjacency list representation of the graph will be displayed, followed by the breadth-first traversal of the graph, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a9a64beb-e5b1-4991-8b86-cda91f9a5c98.png" style="width:34.17em;height:35.08em;"/></p>
<p>Figure 10.22</p>
<p>Now, let's move on to the next recipe!</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Carrying out the depth-first traversal of a graph</h1>
                
            
            
                
<p>In depth-first traversal (also called depth-first search), all nodes of a graph are visited by taking a path and going as deep as possible down that path. On reaching the end, you go back, pick up another path, and then repeat the process.</p>
<p>In this recipe, we will learn how to carry out the depth-first traversal of the graph.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps for the depth-first traversal of a graph:</p>
<ol>
<li>Push the first vertex of the graph into the stack. You can choose any vertex of the graph as the starting vertex.</li>
<li>Then, repeat the following <em>steps 3</em> to <em>7</em> until the stack is empty.</li>
<li>Pop the vertex from the stack and call it by any name, say, <kbd>v</kbd>.</li>
<li>Mark the popped vertex as visited. This marking is done so that this vertex should not be traversed again.</li>
<li>Display the marked vertex.</li>
<li>Find out the adjacency vertices of the <kbd>v</kbd> vertex, and then perform <em>step 7</em> on each of them.</li>
<li>If any of the adjacency vertices of <kbd>v</kbd> are not marked, mark them as visited and push them on to the stack.</li>
<li>Exit.</li>
</ol>
<p>The program for the depth-first traversal of a graph is as follows:</p>
<pre>//<strong>depthfirsttrav.c</strong><br/><br/><br/>#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#define max 20<br/><br/>enum Setmarked {Y,N};<br/>struct node {<br/>  char nme;<br/>  struct node * vrt;<br/>  struct node * edg;<br/>  enum Setmarked marked;<br/>};<br/><br/>struct node * stack[max];<br/>int top = -1;<br/>void push(struct node * h);<br/>struct node * pop();<br/><br/>int main() {<br/>  int numb, i, j, noe;<br/>  char v1, v2;<br/>  struct node * startList, * newNode, * temp1, * temp2, * temp3;<br/>  printf("How many vertices are there ?");<br/>  scanf("%d", &amp; numb);<br/>  startList = NULL;<br/>  printf("Enter all vertices names\n");<br/>  for (i = 1; i &lt;= numb; i++) {<br/>    if (startList == NULL) {<br/>      newNode = malloc(sizeof(struct node));<br/>      scanf(" %c", &amp; newNode - &gt; nme);<br/>      /* There is a white space before %c */<br/>      startList = newNode;<br/>      temp1 = newNode;<br/>      newNode - &gt; vrt = NULL;<br/>      newNode - &gt; edg = NULL;<br/>      newNode - &gt; marked = N;<br/>    } else {<br/>      newNode = malloc(sizeof(struct node));<br/>      scanf(" %c", &amp; newNode - &gt; nme);<br/>      /* There is a white space before %c */<br/>      newNode - &gt; vrt = NULL;<br/>      newNode - &gt; edg = NULL;<br/>      newNode - &gt; marked = N;<br/>      temp1 - &gt; vrt = newNode;<br/>      temp1 = newNode;<br/>    }<br/>  }<br/>  printf("Enter the edges between vertices. Enter v1 v2, if there is an edge\n");<br/>  printf("between v1 and v2. Enter 0 0 if over\n");<br/>  noe = numb * (numb - 1);<br/>  for (j = 1; j &lt;= noe; j++) {<br/>    scanf(" %c %c", &amp; v1, &amp; v2);<br/>    /* There is a white space before %c */<br/>    if (v1 == '0' &amp;&amp; v2 == '0') break;<br/>    temp1 = startList;<br/>    while (temp1 != NULL &amp;&amp; temp1 - &gt; nme != v1)<br/>      temp1 = temp1 - &gt; vrt;<br/>    if (temp1 == NULL) {<br/>      printf("Sorry no vertex exist by this name\n");<br/>      break;<br/>    }<br/>    temp2 = temp1;<br/>    while (temp2 - &gt; edg != NULL) temp2 = temp2 - &gt; edg;<br/>    newNode = malloc(sizeof(struct node));<br/>    newNode - &gt; nme = v2;<br/>    temp2 - &gt; edg = newNode;<br/>    newNode - &gt; edg = NULL;<br/>    newNode - &gt; vrt = NULL;<br/>  }<br/>  printf("\nAdjacency List representation of Graph is\n");<br/>  temp1 = startList;<br/>  while (temp1 != NULL) {<br/>    printf("%c\t", temp1 - &gt; nme);<br/>    temp2 = temp1 - &gt; edg;<br/>    while (temp2 != NULL) {<br/>      printf("%c\t", temp2 - &gt; nme);<br/>      temp2 = temp2 - &gt; edg;<br/>    }<br/>    printf("\n");<br/>    temp1 = temp1 - &gt; vrt;<br/>  }<br/>  printf("\nDepth First traversal of the graph is \n");<br/>  temp1 = startList;<br/>  if (temp1 == NULL)<br/>    printf("Sorry no vertices in the graph\n");<br/>  else<br/>    push(temp1);<br/>  while (top &gt;= 0) {<br/>    temp3 = pop();<br/>    temp1 = startList;<br/>    while (temp1 - &gt; nme != temp3 - &gt; nme) temp1 = temp1 - &gt; vrt;<br/>    temp3 = temp1;<br/>    if (temp3 - &gt; marked == N) {<br/>      printf("%c\t", temp3 - &gt; nme);<br/>      temp3 - &gt; marked = Y;<br/>      temp2 = temp3 - &gt; edg;<br/>      while (temp2 != NULL) {<br/>        push(temp2);<br/>        temp2 = temp2 - &gt; edg;<br/>      }<br/>    }<br/>  }<br/>  return 0;<br/>}<br/><br/>void push(struct node * h) {<br/>  top++;<br/>  stack[top] = h;<br/>}<br/><br/>struct node * pop() {<br/>  return (stack[top--]);<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We are using the adjacency list representation of the directed graph from the previous recipe, <em>Creating an adjacency list representation of a directed graph</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7b647493-abe4-4f75-ae85-9c4d161e9069.png" style="width:14.50em;height:20.75em;"/></p>
<p>Figure 10.23</p>
<p>The <kbd>temp1</kbd> pointer is set to point to <kbd>startList</kbd>, that is, at node <kbd>a</kbd>, which we have assumed as the starting vertex of the graph. We then ensure that if <kbd>temp1</kbd> is not <kbd>NULL</kbd>, then the node pointed to by the <kbd>temp1</kbd> pointer is pushed to the stack. The value of <kbd>top</kbd>, which is initially -1, is incremented to 0 and node <kbd>a</kbd> is added to the array of the nodes stack at index location <strong>0</strong>, as follows:</p>
<div><img src="img/33f8dbd6-9d25-46ba-a115-a37ab55a1701.png" style="width:15.67em;height:12.17em;"/></div>
<p>Figure 10.24</p>
<p>Thereafter, the <kbd>pop</kbd> function is invoked to remove the node from the stack. The node at the <kbd>stack[0]</kbd> index location is returned and the value of <kbd>top</kbd> is again decremented to -1.</p>
<p>The node containing vertex <kbd>a</kbd> is returned to the <kbd>temp3</kbd> pointer. The <kbd>temp1</kbd> pointer is set to point to the <kbd>startList</kbd> pointer. The marked member of the <kbd>temp3</kbd> node, that is, vertex <kbd>a</kbd>, is set to <kbd>N</kbd> initially. The vertex name stored in the <kbd>nme</kbd> member of the node is displayed, that is, vertex <kbd>a</kbd>, is displayed on screen. After displaying vertex <kbd>a</kbd>, its marked member is set to <kbd>Y</kbd> to indicate that the node is visited and should not be traversed again. The <kbd>temp2</kbd> pointer is set to point to where the <kbd>edg</kbd> pointer of <kbd>temp3</kbd> is pointing. The <kbd>edg</kbd> pointer of <kbd>temp3</kbd> is pointing to vertex <kbd>b</kbd>, so <kbd>temp2</kbd> is set to point to vertex <kbd>b</kbd>. Again, the procedure is repeated, that is, we check whether <kbd>temp2</kbd> is not <kbd>NULL</kbd>, and then node <kbd>b</kbd> is pushed to the stack at the <kbd>stack[0]</kbd> index location. Because all of the nodes that are connected to vertex <kbd>a</kbd> have to be pushed to the stack, the <kbd>temp2</kbd> pointer is set to point to the location that its <kbd>edg</kbd> pointer is pointing to. The <kbd>edg</kbd> pointer of node <kbd>b</kbd> (in the adjacency list) is pointing to node <kbd>c</kbd>, so node <kbd>c</kbd> is also pushed to the stack at the <kbd>stack[1]</kbd> index location, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/eea4b1f6-f2e8-4c38-92e6-0441a041ad3c.png" style="width:15.42em;height:11.58em;"/></p>
<p>Figure 10.25</p>
<p>In the stack, nodes <kbd>b</kbd> and <kbd>c</kbd> are present. Now, again, the <kbd>pop</kbd> function is invoked, and the node, <kbd>c</kbd>, is popped from the stack and the <kbd>temp3</kbd> pointer is set to point to it. The <kbd>temp1</kbd> pointer is initially set to point to <kbd>startList</kbd> and, thereafter, by making use of its <kbd>vrt</kbd> pointer, the <kbd>temp1</kbd> pointer is set to point to vertex <kbd>c</kbd>. Because the marked member of node <kbd>c</kbd> is <em>N</em>, its vertex name, <kbd>c</kbd>, is displayed on screen and its marked member is set to <kbd>Y</kbd>. So, up until now, nodes <kbd>a</kbd> and <kbd>c</kbd> are displayed on screen.</p>
<p>A <kbd>temp2</kbd> pointer is set to point to where the <kbd>edg</kbd> member of node <kbd>c</kbd> is pointing. The <kbd>edg</kbd> member of node <kbd>c</kbd> is pointing to node <kbd>d</kbd>, so the <kbd>d</kbd> node is pushed to the stack and the next adjacent node of <kbd>c</kbd> is accessed. The next adjacent node of node <kbd>c</kbd> is node <kbd>e</kbd>, which is also pushed to the stack as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/74775bfa-0ce9-4bea-9daf-c4b00b786233.png" style="width:15.17em;height:11.67em;"/></p>
<p>Figure 10.26</p>
<p>Again, the topmost node from the stack, node <kbd>e</kbd>, is popped, and the <kbd>temp3</kbd> pointer is set to point to it. Again, the <kbd>temp1</kbd> pointer is set to point to vertex <kbd>e</kbd>, and node <kbd>e</kbd> is displayed on screen, that is, it is traversed. Then, its marked member is set to <kbd>Y</kbd>, and the node that is attached to the <kbd>edg</kbd> member of <kbd>e</kbd> is pushed to the stack, that is, node <kbd>a</kbd> is pushed to the stack, followed by node <kbd>b</kbd>, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/644d22ba-f55e-42ad-bf63-44aa20e7507f.png" style="width:17.33em;height:13.17em;"/></p>
<p>Figure 10.27</p>
<p>Node <kbd>b</kbd> is popped and the <kbd>temp3</kbd> pointer is set to point to it. The <kbd>temp1</kbd> pointer is set to point to node <kbd>b</kbd>. Because the marked member of node <kbd>b</kbd> is <kbd>N</kbd>, stating that it is not yet traversed, vertex <kbd>b</kbd> is displayed on screen and its marked member is set to <kbd>Y</kbd>. Since there is no adjacent member of vertex <kbd>b</kbd>, the next node, <kbd>a</kbd>, in the stack is popped. Because vertex <kbd>a</kbd> has already been visited, the next node from the stack is popped: node <kbd>d</kbd>. The procedure is repeated, and the sequence of vertices displayed is considered as the depth-traversal of the graph.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during the compilation, this means the <kbd>depthfirsttrav.c</kbd> program has successfully compiled into the <kbd>depthfirsttrav.exe</kbd> file. On executing the file, the user will be prompted to specify the count of vertices in the graph, followed by entering the vertices' names. Thereafter, the user is asked to enter the edges of the graph and enter <kbd>0 0</kbd> when completed. After the edges of the graph are entered, the adjacency list representation of the graph will be displayed, followed by the depth-first traversal of the graph, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/795862d3-4917-42cd-94e8-e6245c4d90a6.png" style="width:31.83em;height:31.17em;"/></p>
<p>Figure 10.28</p>
<p>Now, let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating minimum spanning trees using Prim's algorithm</h1>
                
            
            
                
<p>In this recipe, we will learn how to create a minimum spanning tree. A minimum spanning tree of a graph with <em>n</em> number of nodes will have <em>n</em> nodes. In a connected weighted graph, each edge of the graph is assigned a non-negative number called the "weight of the edge." Then, any spanning tree of the graph is assigned a total weight obtained by adding the weights of the edges in the tree. A minimum spanning tree of a graph is a spanning tree whose total weight is as small as possible.</p>
<p>There are a number of techniques that you can use to create a minimum spanning tree for a weighted graph. One of these methods is called Prim's algorithm.</p>
<p>Prim's algorithm is part of the category of greedy algorithms, where vertices are connected with edges that have the lowest weights. An arbitrary node is chosen initially as the tree root. In an undirected graph, any node can be considered as the tree root and the nodes adjacent to it as its children. The nodes of the graph are then appended to the tree, one at a time, until all of the nodes of the graph are included. The node of the graph added to the tree at each point is adjacent to a node of the tree by an arc of minimum weight. The arc of minimum weight becomes a tree arc connecting this new node to the tree. When all the nodes of the graph have been added to the tree, a minimum spanning tree is said to be made for the graph.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to implement Prim's algorithm:</p>
<ol>
<li>Choose any vertex from the graph as the root of the minimum spanning tree. It can be any random vertex.</li>
<li>Find all of the edges from the vertex (or vertices in the tree) to other vertices in the graph. From those vertices, choose the vertex that has the edge with the minimum weight and add that vertex to the tree.</li>
<li>Repeat <em>step 2</em> until all the vertices of the graph are added to the minimum spanning tree.</li>
</ol>
<p>Consider the following weighted graph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1b0c7bf8-8cc4-42ca-b881-c5fb106e5356.png" style="width:15.83em;height:14.33em;"/></p>
<p>Figure 10.29</p>
<p>Now, to get the minimum spanning tree of this graph, we connect the vertices starting from vertex <kbd>a</kbd> (you can consider any vertex as the starting vertex of the graph). From the starting vertex, choose the nearest vertex having the lowest weight, and then repeat the procedure until all of the vertices are connected. In that way, we get the minimum spanning tree as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/524adce9-751f-4e6f-a5b8-5a0f23a813a0.png" style="width:16.67em;height:15.17em;"/></p>
<p>Figure 10.30</p>
<p>The preceding graph is called a tree because it is acyclic; it is called spanning because it covers every vertex.</p>
<p class="mce-root"/>
<p>The number of edges in a minimum spanning tree is <em>v-1</em>, where <em>v</em> is the number of vertices.</p>
<p>The program for creating a minimum spanning tree using Prim's algorithm is as follows:</p>
<pre class="mce-root">//<strong>prims.c</strong><br/><br/>#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#define max 20 <br/>struct node<br/>{<br/> int nme;<br/> int wt;<br/> struct node *vrt;<br/> struct node *edg;<br/> };<br/><br/>struct node *startList;<br/><br/>struct lst<br/>{<br/> int u,v;<br/> int wt;<br/> struct lst *next;<br/>}lst; <br/><br/>struct lst *pq=NULL;<br/>struct lst *tr=NULL;<br/>void addpqu(int a, int b, int w);<br/>void maketree();<br/>void disptree();<br/>struct lst *delet();<br/>int visited[max];<br/>int n,nov=0; <br/><br/>int main()<br/>{<br/> int i,j,noe,w;<br/> int a,b;<br/> struct node *newNode,*temp1,*temp2;<br/> printf ("How many vertices are there ?");<br/> scanf("%d",&amp;n);<br/> printf("The vertices are named\n");<br/> for(i=1;i&lt;=n;i++)printf("%d\t",i);<br/> printf("for convenience \n");<br/> startList=NULL;<br/> for(i=1;i&lt;=n;i++)<br/> {<br/>     if (startList==NULL)<br/>     {<br/>         newNode =malloc(sizeof (struct node));<br/>         newNode-&gt;nme=i;<br/>         startList=newNode;<br/>         temp1=newNode;<br/>         newNode-&gt;vrt=NULL;<br/>         newNode-&gt;edg=NULL;<br/>     }<br/>     else<br/>     {<br/>         newNode=malloc(sizeof (struct node));<br/>         newNode-&gt;nme=i;<br/>         newNode-&gt;vrt=NULL;<br/>         newNode-&gt;edg=NULL;<br/>         temp1-&gt;vrt=newNode;<br/>         temp1=newNode;<br/>     }<br/> }<br/> printf("Enter the edges between vertices. Enter 1 3, if there is an edge\n");<br/> printf("between 1 and 3. Enter 0 0 if over\n");<br/> noe=n*(n-1);<br/> for(j=1;j&lt;=noe;j++)<br/> {<br/>     printf("Enter edge ");<br/>     scanf("%d %d",&amp;a,&amp;b);<br/>     if(a==0 &amp;&amp; b==0)break;<br/>     printf("Enter weight ");<br/>     scanf("%d",&amp;w);<br/>     temp1=startList;<br/>     while(temp1!=NULL &amp;&amp; temp1-&gt;nme!=a)<br/>     {<br/>         temp1=temp1-&gt;vrt;<br/>     }<br/>     if(temp1==NULL)<br/>     {<br/>         printf("Sorry no vertex exist by this name\n");<br/>         break;<br/>     }<br/>     temp2=temp1;<br/>     while(temp2-&gt;edg!=NULL)temp2=temp2-&gt;edg;<br/>     newNode=malloc(sizeof (struct node));<br/>     newNode-&gt;nme=b;<br/>     newNode-&gt;wt=w;<br/>     temp2-&gt;edg=newNode;<br/>     newNode-&gt;edg=NULL;<br/>     newNode-&gt;vrt=NULL;<br/>     temp1=startList;<br/>     while(temp1!=NULL &amp;&amp; temp1-&gt;nme!=b)<br/>         temp1=temp1-&gt;vrt;<br/>     if(temp1==NULL)<br/>     {<br/>         printf("Sorry no vertex exist by this name\n");<br/>         break;<br/>     }<br/>     temp2=temp1;<br/>     while(temp2-&gt;edg!=NULL)temp2=temp2-&gt;edg;<br/>     newNode=malloc(sizeof (struct node));<br/>     newNode-&gt;nme=a;<br/>     newNode-&gt;wt=w;<br/>     temp2-&gt;edg=newNode;<br/>     newNode-&gt;edg=NULL;<br/>     newNode-&gt;vrt=NULL;<br/>}<br/>printf ("Adjacency List representation of Graph is\n");<br/>temp1=startList;<br/>while (temp1!=NULL)<br/>{<br/>     printf ("%d\t",temp1-&gt;nme);<br/>     temp2=temp1-&gt;edg;<br/>     while(temp2!=NULL)<br/>     {<br/>         printf("%d\t",temp2-&gt;nme);<br/>         temp2=temp2-&gt;edg;<br/>     }<br/>     printf("\n");<br/>     temp1=temp1-&gt;vrt;<br/>}<br/>temp1=startList;<br/>temp2=temp1-&gt;edg;<br/>while(temp2!=NULL)<br/>{<br/>    addpqu(temp1-&gt;nme,temp2-&gt;nme, temp2-&gt;wt);<br/>    temp2=temp2-&gt;edg;<br/>}<br/>maketree();<br/>disptree();<br/>return 0;<br/>}<br/><br/>void addpqu(int a, int b, int w)<br/>{<br/> struct lst *lstNode,*findloc1,*findloc2;<br/> lstNode=malloc(sizeof(struct lst));<br/> lstNode-&gt;u=a;<br/> lstNode-&gt;v=b;<br/> lstNode-&gt;wt=w;<br/> lstNode-&gt;next=NULL;<br/> if(pq==NULL)<br/> {<br/>     pq = lstNode;<br/> }<br/> else<br/> {<br/>     if(lstNode-&gt;wt &lt; pq-&gt;wt)<br/>     {<br/>         lstNode-&gt;next=pq;<br/>         pq=lstNode;<br/>     }<br/>     else<br/>     {<br/>         findloc1=pq;<br/>         while((findloc1!=NULL) &amp;&amp; (findloc1-&gt;wt &lt;= lstNode-&gt;wt))<br/>         {<br/>             findloc2=findloc1;<br/>             findloc1=findloc1-&gt;next;<br/>         }<br/>         findloc2-&gt;next=lstNode;<br/>         lstNode-&gt;next=findloc1;<br/>     }<br/>  }<br/>} <br/><br/>struct lst *delet()<br/>{<br/> struct lst *tempNode;<br/> if (pq !=NULL)<br/> {<br/>     tempNode=pq;<br/>     pq=pq-&gt;next;<br/>     return tempNode;<br/> }<br/> else<br/>     return NULL;<br/> } <br/><br/>void maketree()<br/>{<br/> struct lst *lstNode,*tempNode1,*tempNode2;<br/> struct node *x,*y;<br/> int i,j;<br/> while(nov &lt;n)<br/> {<br/>     nxt: lstNode=delet();<br/>     for(i=1;i&lt;=nov;i++)<br/>     {<br/>         if(visited[i]==lstNode-&gt;u)<br/>         {<br/>             for(j=1;j&lt;=nov;j++)<br/>                 if(visited[j]==lstNode-&gt;v) goto nxt;<br/>         }<br/>     }<br/>     for(i=1;i&lt;=nov;i++)<br/>         if(visited[i]==lstNode-&gt;u) goto rpt;<br/>     nov++;<br/>     visited[nov]=lstNode-&gt;u;<br/>     rpt: for(i=1;i&lt;=nov;i++)<br/>     {<br/>         if(visited[i]==lstNode-&gt;v) goto rptt;<br/>     }<br/>     nov++;<br/>     visited[nov]=lstNode-&gt;v;<br/>     rptt: lstNode-&gt;next=NULL;<br/>     if (tr==NULL)<br/>     {<br/>         tr=lstNode;<br/>         tempNode1=tr;<br/>     }<br/>     else<br/>     {<br/>         tempNode1-&gt;next=lstNode;<br/>         tempNode1=lstNode;<br/>     }<br/>     x=startList;<br/>     while(x-&gt;nme!=lstNode-&gt;v)x=x-&gt;vrt;<br/>     y=x-&gt;edg;<br/>     pq=NULL;<br/>     while(y!=NULL)<br/>     {<br/>         addpqu(x-&gt;nme,y-&gt;nme, y-&gt;wt);<br/>         y=y-&gt;edg;<br/>     }<br/>  }<br/>}<br/><br/>void disptree()<br/>{<br/> struct lst *t;<br/> t=tr;<br/> printf("Minimal Spanning tree with Prims Algorithm is \n");<br/> while(t!=NULL)<br/> {<br/>     printf("%d %d\n",t-&gt;u,t-&gt;v);<br/>     t=t-&gt;next;<br/> }<br/>} <br/><br/></pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The user is prompted to specify the number of vertices. Assuming the user enters <kbd>5</kbd>, the value of <kbd>5</kbd> will be assigned to variable <kbd>n</kbd>. The vertices will be automatically named <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, <kbd>4</kbd>, and <kbd>5</kbd> for convenience. A <kbd>startList</kbd> pointer of the node type is defined and is set to <kbd>NULL</kbd> initially. The <kbd>startList</kbd> pointer will be pointing to the first node of the adjacency linked list that will be created from the graph.</p>
<p>Two structures are defined: one is called <kbd>node</kbd> and the other is called <kbd>lst</kbd>. The <kbd>node</kbd> structure is for making the adjacency list representation of the graph and the <kbd>lst</kbd> structure is for creating a minimum spanning tree. Two pointers, <kbd>pq</kbd> and <kbd>tr</kbd>, are defined of the <kbd>lst</kbd> type and are defined as <kbd>NULL</kbd>.</p>
<p>To make the adjacency linked list representation, the first step is to create a linked list of the nodes, where each node represents a vertex of the graph. Because there are five vertices in the graph, a <kbd>for</kbd> loop is set to execute five times. Within the <kbd>for</kbd> loop, a node is created, called <kbd>newNode</kbd>, and the vertex number, <kbd>1</kbd>, is assigned to its <kbd>nme</kbd> member. The <kbd>startList</kbd> pointer is set to point to <kbd>newNode</kbd>. The <kbd>vrt</kbd> and <kbd>edg</kbd> members of <kbd>newNode</kbd> are set to <kbd>NULL</kbd>. The <kbd>temp1</kbd> pointer is also set to point to <kbd>newNode</kbd>. The <kbd>startList</kbd> pointer will keep pointing to the first node of the linked list, whereas the <kbd>temp1</kbd> pointer will be used for connecting other nodes, that is, other vertices.</p>
<p class="mce-root"/>
<p>In the next iteration of the <kbd>for</kbd> loop, again, a new node is created, called <kbd>newNode</kbd>, and the vertex number, <kbd>2</kbd>, will be assigned to it. The <kbd>vrt</kbd> and <kbd>edg</kbd> members of <kbd>newNode</kbd> are set to <kbd>NULL</kbd>. To connect with the existing vertices, <kbd>1</kbd>, the <kbd>vrt</kbd> member of <kbd>temp1</kbd> is set to point to <kbd>newNode</kbd>. Thereafter, <kbd>temp1</kbd> is set to point to <kbd>NewNode</kbd>. The <kbd>for</kbd> loop will execute for the time equal to the number of vertices, that is, five, hence creating five nodes that contain their respective vertex numbers. By the time the <kbd>for</kbd> loop terminates, the vertices will be created and will appear as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5159fa84-fbf8-4a76-bf99-4be637354681.png" style="width:11.83em;height:23.83em;"/></p>
<p>Figure 10.31</p>
<p>Once the vertices are created, the next step is to ask the user for the edges between the vertices. A graph having <em>n</em> vertices can, at most, have <em>n * (n-1)</em> edges. Because the number of vertices is five, so the node, that is, the number of edges variable, is initialized to <em>5*4=20</em>. A <kbd>for</kbd> loop, <kbd>j</kbd>, is set to execute from 1 to 20, asking the user to enter the edges and their respective weights. Suppose that the user enters an edge as <kbd>1 2</kbd>, which will be assigned to the <kbd>a</kbd> and <kbd>b</kbd> variables, respectively; the weight entered is <kbd>1</kbd>, which is assigned to the <kbd>w</kbd> variable.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To create this edge, the <kbd>temp1</kbd> pointer is set to point to <kbd>startList</kbd>. To create a (<em>1</em>,<em>2</em>) edge, the <kbd>temp1</kbd> pointer is set to point to the node whose <kbd>nme</kbd> member is equal to 1. Currently, <kbd>temp1</kbd> is already pointing to vertex <kbd>1</kbd>. The next step is to add vertex <kbd>2</kbd> at the end of vertex <kbd>1</kbd>. To find the end of a vertex, we will take the help of another pointer, called <kbd>temp2</kbd>. The <kbd>temp2</kbd> pointer is first set to point to the node that the <kbd>temp1</kbd> pointer is pointing to. Thereafter, using its <kbd>edg</kbd> pointer, <kbd>temp2</kbd> is set to point to the last node of vertex <kbd>1</kbd>. Then, a new node is created, called <kbd>newNode</kbd>, and the value of <kbd>2</kbd> is assigned to the <kbd>nme</kbd> member of <kbd>newNode</kbd>. The weight, <kbd>1</kbd>, in the <kbd>w</kbd> variable is assigned to the <kbd>wt</kbd> member of <kbd>newNode</kbd>. The <kbd>edge</kbd> and <kbd>vrt</kbd> pointers of <kbd>newNode</kbd> are set to <kbd>NULL</kbd>. And, finally, the <kbd>edg</kbd> member of <kbd>temp2</kbd> is set to point to <kbd>newNode</kbd>. Therefore, vertices <kbd>1</kbd> and <kbd>2</kbd> are now connected.</p>
<p>This is an undirected graph, and edge (<em>1</em>,<em>2</em>) can also mean an edge from <kbd>2</kbd> to <kbd>1</kbd>. So, we need an edge from vertex <kbd>2</kbd> to <kbd>1</kbd>. The <kbd>temp1</kbd> pointer is set to point to <kbd>startList</kbd>. Using its <kbd>vrt</kbd> pointer, the <kbd>temp1</kbd> pointer is set to move further until it reaches vertex <kbd>2</kbd>.</p>
<p>Once <kbd>temp1</kbd> reaches vertex <kbd>2</kbd>, the next step is to set the <kbd>temp2</kbd> pointer to point to the last node of vertex <kbd>2</kbd>. After doing so, a new node, called <kbd>newNode</kbd>, is created and the value of <kbd>1</kbd> is assigned to its <kbd>nme</kbd> member. Additionally, the weight in the <kbd>w</kbd> variable is assigned to the <kbd>wt</kbd> member of <kbd>newNode</kbd>. To connect these nodes that contain vertices <kbd>2</kbd> and <kbd>1</kbd>, the edge pointer of <kbd>temp2</kbd> is set to point to <kbd>newNode</kbd>. The <kbd>edg</kbd> and <kbd>vrt</kbd> pointers of <kbd>newNode</kbd> are set to <kbd>NULL</kbd>. Therefore, vertices <kbd>2</kbd> and <kbd>1</kbd> are connected now too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying the adjacency linked list</h1>
                
            
            
                
<p>After entering all of the edges along with their weights, the adjacency list has to be displayed. To do this, a <kbd>temp1</kbd> pointer is set to point to <kbd>startList</kbd>. A <kbd>while</kbd> loop will execute until the <kbd>temp1</kbd> pointer reaches <kbd>NULL</kbd>. So, the <kbd>temp1</kbd> pointer will point to vertex <kbd>1</kbd> initially. Thereafter, by taking the help of the second pointer, <kbd>temp2</kbd>, all the edges of the <kbd>temp1</kbd> pointer (that is, vertex <kbd>1</kbd>) are accessed and displayed on screen. After displaying all the edges of vertex <kbd>1</kbd>, by making use of the <kbd>vrt</kbd> member, the <kbd>temp1</kbd> pointer is set to point to the next vertex, that is, to vertex <kbd>2</kbd>. Again, the <kbd>temp2</kbd> pointer is set to point at vertex <kbd>2</kbd>, and, using its <kbd>edg</kbd> member, all the edges of vertex <kbd>2</kbd> are displayed. The procedure is repeated for all the vertices of the graph.</p>
<p class="mce-root"/>
<p>The adjacency list will appear as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0f1a953c-745e-4efc-b4b6-7dcd4f3f6e3b.png" style="width:21.67em;height:21.50em;"/></p>
<p>Figure 10.32</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the minimum spanning tree</h1>
                
            
            
                
<p>To make the minimum spanning tree, we need to adjust the edges of the vertices in ascending order. The <kbd>temp1</kbd> pointer is set to point at <kbd>startList</kbd>, that is, vertex <kbd>1</kbd>. The <kbd>temp2</kbd> pointer is set to point to where the <kbd>edg</kbd> pointer of <kbd>temp1</kbd> is pointing to, that is, vertex <kbd>2</kbd>.</p>
<p>Now, until <kbd>temp2</kbd> becomes <kbd>NULL</kbd>, the <kbd>addpqu</kbd> function is invoked and vertices <kbd>1</kbd> and <kbd>2</kbd>, and their weight, <kbd>1</kbd>, are passed to it. In the <kbd>addpqu</kbd> function, a structure is created called <kbd>lstNode</kbd> of the <kbd>lst</kbd> type. The <kbd>1</kbd> and <kbd>2</kbd> vertices and their weight, <kbd>1</kbd>, are assigned to the <kbd>u</kbd>, <kbd>v</kbd>, and <kbd>wt</kbd> members, respectively. The next pointer of <kbd>lstNode</kbd> is set to <kbd>NULL</kbd>. Additionally, a pointer, <kbd>pq</kbd>, is set to point to <kbd>lstNode</kbd>.</p>
<p>Following this, the <kbd>temp2</kbd> pointer is set to point to where its <kbd>edg</kbd> pointer is pointing, that is, vertex <kbd>3</kbd>. Again, the <kbd>addpqu</kbd> function is called and vertices <kbd>1</kbd> and <kbd>3</kbd> and weight <kbd>3</kbd> are passed to it. In the <kbd>addpqu</kbd> function, again, a new node is creating, called <kbd>lstNode</kbd>, and vertices <kbd>1</kbd> and <kbd>3</kbd> and weight <kbd>3</kbd> are assigned to its <kbd>u</kbd>, <kbd>v</kbd>, and <kbd>wt</kbd> members, respectively. The next pointer of <kbd>lstNode</kbd> is set to <kbd>NULL</kbd>.</p>
<p>Because the nodes have to be arranged in ascending order of their weights, the <kbd>wt</kbd> member of <kbd>lstNode</kbd> and the previous node, <kbd>pq</kbd>, are compared. The <kbd>wt</kbd> member of <kbd>lstNode</kbd> is 3, which is greater than the <kbd>wt</kbd> member of the <kbd>pq</kbd> node, which is 1. So, the help of two pointers, <kbd>findloc1</kbd> and <kbd>findloc2</kbd>, is taken. One pointer is set to point to the weights of <kbd>lstNode</kbd>, and the <kbd>pq</kbd> nodes are compared.</p>
<p>Let's choose a vertex, <kbd>1</kbd>, and add it to the minimum spanning tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/eb496930-0a18-4b6d-8c2d-f9c16e428d00.png" style="width:5.08em;height:4.83em;"/></p>
<p>Figure 10.33</p>
<p>Now, from vertex <kbd>1</kbd>, there are edges to the vertices of <kbd>3</kbd>, <kbd>2</kbd>, and <kbd>5</kbd>, but the edge with the minimum weight is to vertex <kbd>2</kbd>. So, vertex <kbd>2</kbd> is also added to the minimum spanning tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f5423d76-6f09-47cc-b12f-159128ef27e1.png" style="width:5.33em;height:16.75em;"/></p>
<p>Figure 10.34</p>
<p>Again, from vertices <kbd>1</kbd> and <kbd>2</kbd> in the minimum spanning tree, we search for all the edges that lead to other vertices. We find that edges (<strong>1</strong>,<strong>5</strong>) and (<strong>2</strong>,<strong>5</strong>) have the same weight, so we can choose either of the vertices. Let's add edge (<strong>2</strong>,<strong>5</strong>) to the minimum spanning tree:</p>
<div><img src="img/933474db-e3fa-44d4-9bb2-ac8265cf25b4.png" style="width:12.00em;height:7.83em;"/></div>
<p>Figure 10.35</p>
<p>From the vertices of <kbd>1</kbd>, <kbd>2</kbd>, and <kbd>5</kbd> in the minimum spanning tree, we search for the edges with the lowest weights. Edge (<strong>5</strong>,<strong>3</strong>) has the minimum weight of <kbd>1</kbd>, so edge (<strong>5</strong>,<strong>3</strong>) is added to the minimum spanning tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/24884208-c29b-4c57-b327-771c88b032dc.png" style="width:12.25em;height:8.25em;"/></p>
<p>Figure 10.36</p>
<p>Now, we need to find the edge that leads to vertex <kbd>4</kbd> from the existing vertices in the minimum spanning tree. Edge (<strong>3</strong>,<strong>4</strong>) has the lowest weight and is, therefore, added to the minimum spanning tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/886fbfc6-e0d7-46d2-9723-68671d6940fa.png" style="width:11.75em;height:10.67em;"/></p>
<p>Figure 10.37</p>
<p>On compiling and running the program, you should get an output that is similar to the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/39c364df-efd7-4d91-b77d-7f45731f6473.png" style="width:36.83em;height:44.33em;"/></p>
<p>Figure 10.38</p>
<p>Now, let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating minimum spanning trees using Kruskal's algorithm</h1>
                
            
            
                
<p>In this recipe, we will learn how to make a minimum spanning tree using Kruskal's algorithm. </p>
<p>A minimum/minimal spanning tree of an undirected graph is a tree that is formed from graph edges that connect all of the vertices of the graph at the lowest total cost. A minimum spanning tree can exist if, and only if, the graph is connected. A graph is said to be connected if there exists a path between any two vertices.</p>
<p>Here, the nodes of the graph are initially considered as <em>n</em> distinct partial trees with one node each. At each step of the algorithm, two distinct partial trees are connected into a single partial tree by an edge of the graph. When only one partial tree exists (for instance, after <em>n-1</em> such steps), it is a minimum spanning tree.</p>
<p>The connecting arc of minimum cost is used to connect two distinct trees. To do this, the arcs can be placed in a priority queue based on weight. The arc of lowest weight is then examined to see whether it connects two distinct trees. To determine whether an arc <em>(x, y)</em> connects two distinct trees, we can implement the trees with a father field in each node. Then, we can traverse all the ancestors of <em>x</em> and <em>y</em> to obtain the root of the tree connecting them. If the root of the two trees is the same node, and <em>x</em> and <em>y</em> are already in the same tree, then arc <em>(x, y)</em> is discarded, and the arc of the next lowest weight is examined.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to create a minimum spanning tree using Kruskal's algorithm:</p>
<ol>
<li>Sort the edge list in ascending order of their weights.</li>
<li>Pick up the edge at the top of the edge list (with the smallest weight).</li>
<li>Remove this edge from the edge list.</li>
<li>Connect the two vertices with the given edge. If, by connecting the vertices, a cycle is made in the graph, then discard the edge.</li>
<li>Repeat the preceding <em>steps 2</em> to <em>4</em> until <em>n-1</em> edges are added or the list of edges is complete.</li>
</ol>
<p>The program for creating a minimum spanning tree using Kruskal's algorithm is as follows:</p>
<pre>//<strong>kruskal.c</strong><br/><br/>#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#define max 20<br/><br/>struct node<br/>{<br/> int nme;<br/> int wt;<br/> struct node *v;<br/> struct node *e;<br/>}; <br/><br/>typedef struct lst<br/>{<br/> int u,v;<br/> int wt;<br/> struct lst *nxt;<br/>}lst; <br/><br/>lst *pq=NULL;<br/>lst *tr=NULL;<br/>void addpqu(int a, int b, int w);<br/>void maketree();<br/>void disptree();<br/>lst *delet();<br/>int parent[max]; <br/><br/>int main()<br/>{<br/> int n,i,j,noe,w;<br/> int a,b;<br/> struct node *adj,*newNode,*p,*q;<br/> printf ("How many vertices are there ? ");<br/> scanf("%d",&amp;n);<br/> for(i=1;i&lt;=n;i++)parent[i]=0;<br/> printf("The vertices are named\n");<br/> for(i=1;i&lt;=n;i++)printf("%d\t",i);<br/> printf("for convenience \n");<br/> for(i=1;i&lt;=n;i++)<br/> {<br/>     if (i==1)<br/>     {<br/>         newNode =malloc(sizeof (struct node));<br/>         newNode-&gt;nme=i;<br/>         adj=newNode;<br/>         p=newNode;<br/>         newNode-&gt;v=NULL;<br/>         newNode-&gt;e=NULL;<br/>     }<br/>     else<br/>     {<br/>         newNode=malloc(sizeof (struct node));<br/>         newNode-&gt;nme=i;<br/>         newNode-&gt;v=NULL;<br/>         newNode-&gt;e=NULL;<br/>         p-&gt;v=newNode;<br/>         p=newNode;<br/>     }<br/> }<br/> printf("Enter the edges between vertices. Enter 1 3, if there is an edge\n");<br/> printf("between 1 and 3. Enter 0 0 if over\n");<br/> noe=n*(n-1);<br/> for(j=1;j&lt;=noe;j++)<br/> {<br/>     printf("Enter edge: ");<br/>     scanf("%d %d",&amp;a,&amp;b);<br/>     if(a==0 &amp;&amp; b==0)break;<br/>     printf("Enter weight: ");<br/>     scanf("%d",&amp;w);<br/>     p=adj;<br/>     while(p!=NULL &amp;&amp; p-&gt;nme!=a)<br/>         p=p-&gt;v;<br/>     if(p==NULL)<br/>     {<br/>         printf("Sorry no vertex exist by this name\n");<br/>         break;<br/>     }<br/>     q=p;<br/>     while(q-&gt;e!=NULL)q=q-&gt;e;<br/>     newNode=malloc(sizeof (struct node));<br/>     newNode-&gt;nme=b;<br/>     newNode-&gt;wt=w;<br/>     q-&gt;e=newNode;<br/>     newNode-&gt;e=NULL;<br/>     newNode-&gt;v=NULL;<br/>     addpqu(a,b,w);<br/> }<br/> printf ("Adjacency List representation of Graph is\n");<br/> p=adj;<br/> while (p!=NULL)<br/> {<br/>     printf ("%d\t",p-&gt;nme);<br/>     q=p-&gt;e;<br/>     while(q!=NULL)<br/>     {<br/>         printf("%d\t",q-&gt;nme);<br/>         q=q-&gt;e;<br/>     }<br/>     printf("\n");<br/>     p=p-&gt;v;<br/> }<br/> maketree();<br/> disptree();<br/> return 0;<br/>} <br/><br/>void addpqu(int a, int b, int w)<br/>{<br/> lst *newNode,*k,*h;<br/> newNode=(lst *)malloc(sizeof(lst));<br/> newNode-&gt;u=a;<br/> newNode-&gt;v=b;<br/> newNode-&gt;wt=w;<br/> newNode-&gt;nxt=NULL;<br/> if(pq==NULL)<br/>     pq = newNode;<br/> else<br/> {<br/>     if(newNode-&gt;wt &lt; pq-&gt;wt)<br/>     {<br/>         newNode-&gt;nxt=pq;<br/>         pq=newNode;<br/>     }<br/>     else<br/>     {<br/>         k=pq;<br/>         while((k!=NULL) &amp;&amp;(k-&gt;wt &lt;= newNode-&gt;wt))<br/>         {<br/>             h=k;<br/>             k=k-&gt;nxt;<br/>         }<br/>         h-&gt;nxt=newNode;<br/>         newNode-&gt;nxt=k;<br/>     }<br/>   }<br/> } <br/><br/>lst *delet()<br/>{<br/> lst *q;<br/> if (pq !=NULL)<br/> {<br/>     q=pq;<br/>     pq=pq-&gt;nxt;<br/>     return q;<br/> }<br/> else<br/>     return NULL;<br/> } <br/><br/>void maketree()<br/>{<br/> lst *newNode,*p;<br/> int x,y,r1,r2;<br/> newNode=delet();<br/> while(newNode !=NULL)<br/> {<br/>     newNode-&gt;nxt=NULL;<br/>     x=newNode-&gt;u;<br/>     y=newNode-&gt;v;<br/>     while(x&gt;0)<br/>     {<br/>         r1=x;<br/>         x=parent[x];<br/>     }<br/>     while(y&gt;0)<br/>     {<br/>         r2=y;<br/>         y=parent[y];<br/>     }<br/>     if(r1 !=r2)<br/>     {<br/>         parent[r2]=r1;<br/>         if (tr==NULL)<br/>         {<br/>             tr=newNode;<br/>             p=tr;<br/>         }<br/>         else<br/>         {<br/>             p-&gt;nxt=newNode;<br/>             p=newNode;<br/>         }<br/>     }<br/>     newNode=delet();<br/>   }<br/> } <br/><br/>void disptree()<br/>{<br/> lst *t;<br/> t=tr;<br/> printf("Minimal Spanning tree with Kruskal Algorithm is \n");<br/> while(t!=NULL)<br/> {<br/>     printf("%d %d\n",t-&gt;u,t-&gt;v);<br/>     t=t-&gt;nxt;<br/> }<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Consider the following undirected graph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e060dfd4-857c-4bee-8c2b-a4227ffa6368.png" style="width:16.33em;height:14.83em;"/></p>
<p>Figure 10.39</p>
<p>Because the graph has five vertices, the minimum spanning tree will have four edges. The first step in Kruskal's algorithm is that the edges of the graph are first sorted in ascending order of their weights:</p>
<pre>Weight   Src    Dest<br/> 1        1      2<br/> 1        3      5<br/> 2        1      5<br/> 2        2      5<br/> 2        3      4<br/> 3        1      3<br/> 3        2      4<br/> 4        4      5</pre>
<p>Now, we will pick up one edge at a time from the preceding table, and, if it does not make a cycle, we will include it in the minimum spanning tree. We begin with edge (<strong>1</strong>,<strong>2</strong>). There is no cycle in this edge; therefore, it is included in the minimum spanning tree as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0498f249-59d5-454c-9e36-7bc7a2c18def.png" style="width:3.83em;height:10.33em;"/></p>
<p>Figure 10.40</p>
<p>The next edge in the table is (<strong>3</strong>,<strong>5</strong>). This edge also does not make a cycle, so it included in the minimum spanning tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4804d6e5-ff89-4c34-b7d8-7a852bb5a93a.png" style="width:11.00em;height:7.42em;"/></p>
<p>Figure 10.41</p>
<p>Next, pick edge (<strong>1</strong>,<strong>5</strong>). Again, no cycle is made with this edge, so it is included in the minimum spanning tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/89b8c93c-7e07-4359-8216-e79bcd431954.png" style="width:11.42em;height:7.67em;"/></p>
<p>Figure 10.42</p>
<p>The next edge in the table is (<strong>2</strong>,<strong>5</strong>) but it does make a cycle, so it is discarded. The next edge in the table is (<strong>3</strong>,<strong>4</strong>). Edge (<strong>3</strong>,<strong>4</strong>) does not make a cycle; therefore, it is added to the minimum spanning tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bbbf0062-1f58-453c-bdf6-38f165e9c773.png" style="width:11.42em;height:10.33em;"/></p>
<p>Figure 10.43</p>
<p>The number of vertices is 5, so the number of edges will be <em>v-1</em>, that is, 4, and we have 4 edges, so our minimum spanning tree is complete.</p>
<p>On compiling and running the <kbd>kruskal.c</kbd> program, we get an output that is similar to the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/36d6d6ef-83f6-4a64-bb0e-fa68d2ac2538.png" style="width:30.17em;height:15.42em;"/></p>
<p>Figure 3.44</p>
<p>As you can see, we get the adjacency list representation and the minimal spanning tree using Kruskal's algorithm in the output.</p>


            

            
        
    </body></html>