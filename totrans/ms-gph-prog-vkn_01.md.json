["```cpp\n$ tar -xvf vulkansdk-linux-x86_64-1.2.198.1.tar.gz\n```", "```cpp\n    export VULKAN_SDK=~/vulkan/1.2.198.1/x86_64\n    ```", "```cpp\n    export PATH=$VULKAN_SDK/bin:$PATH\n    ```", "```cpp\n    export LD_LIBRARY_PATH=$VULKAN_SDK/lib:\n    ```", "```cpp\n    $LD_LIBRARY_PATH\n    ```", "```cpp\n    export VK_LAYER_PATH=$VULKAN_SDK/etc/vulkan/\n    ```", "```cpp\n    explicit_layer.d\n    ```", "```cpp\n    source ~/Downloads/1.2.198.1/setup-env.sh\n    ```", "```cpp\n$ cmake -B build -DCMAKE_BUILD_TYPE=Debug\n```", "```cpp\n$ cmake -B build -DCMAKE_BUILD_TYPE=Release\n```", "```cpp\n$ cmake --build build --target chapter1 -- -j 4\n```", "```cpp\nstruct GpuDevice {\n  BufferHandle create_buffer( const BufferCreation& bc );\n  TextureHandle create_texture( const TextureCreation& tc\n  );\n  ...\n  void destroy_buffer( BufferHandle& handle );\n  void destroy_texture( TextureHandle& handle );\n```", "```cpp\nGpuDevice gpu;\n// Create the main ImGUI vertex buffer\nBufferCreation bc;\nbc.set( VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,\n  ResourceUsageType::Dynamic, 65536 )\n  .set_name( \"VB_ImGui\" );\nBufferHandle imgui_vb = gpu.create(bc);\n…\n// Destroy the main ImGUI vertex buffer\ngpu.destroy(imgui_vb);\n```", "```cpp\nstruct Buffer {\n    VkBuffer                        vk_buffer;\n    VmaAllocation                   vma_allocation;\n    VkDeviceMemory                  vk_device_memory;\n    VkDeviceSize                    vk_device_size;\n    VkBufferUsageFlags              type_flags      = 0;\n    u32                             size            = 0;\n    u32                             global_offset   = 0;\n    BufferHandle                    handle;\n    BufferHandle                    parent_buffer;\n    const char* name                = nullptr;\n}; // struct Buffer\n```", "```cpp\n\"scene\": 0,\n\"scenes\": [\n    {\n        \"nodes\": [\n            0,\n            1,\n            2,\n            3,\n            4,\n            5\n        ]\n    }\n],\n```", "```cpp\n\"nodes\": [\n    {\n        \"mesh\": 0,\n        \"name\": \"Hose_low\"\n    },\n]\n```", "```cpp\n\"buffers\": [\n    {\n        \"uri\": \"FlightHelmet.bin\",\n        \"byteLength\": 3227148\n    }\n],\n\"bufferViews\": [\n    {\n        \"buffer\": 0,\n        \"byteLength\": 568332,\n        \"name\": \"bufferViewScalar\"\n    },\n]\n```", "```cpp\n\"accessors\": [\n    {\n        \"bufferView\": 1,\n        \"byteOffset\": 125664,\n        \"componentType\": 5126,\n        \"count\": 10472,\n        \"type\": \"VEC3\",\n        \"name\": \"accessorNormals\"\n    }\n]\n```", "```cpp\n\"meshes\": [\n    {\n        \"primitives\": [\n            {\n                \"attributes\": {\n                    \"POSITION\": 1,\n                    \"TANGENT\": 2,\n                    \"NORMAL\": 3,\n                    \"TEXCOORD_0\": 4\n                },\n                \"indices\": 0,\n                \"material\": 0\n            }\n        ],\n        \"name\": \"Hose_low\"\n    }\n]\n```", "```cpp\n\"materials\": [\n    {\n        \"pbrMetallicRoughness\": {\n            \"baseColorTexture\": {\n                \"index\": 2\n            },\n            \"metallicRoughnessTexture\": {\n                \"index\": 1\n            }\n        },\n        \"normalTexture\": {\n            \"index\": 0\n        },\n        \"occlusionTexture\": {\n            \"index\": 1\n        },\n        \"doubleSided\": true,\n        \"name\": \"HoseMat\"\n    }\n]\n```", "```cpp\n\"textures\": [\n    {\n        \"sampler\": 0,\n        \"source\": 0,\n        \"name\": \"FlightHelmet_Materials_RubberWoodMat_Nor\n                 mal.png\"\n    },\n],\n\"images\": [\n    {\n        \"uri\": \"FlightHelmet_Materials_RubberWoodMat_Nor\n                mal.png\"\n    },\n],\n\"samplers\": [\n    {\n        \"magFilter\": 9729,\n        \"minFilter\": 9987\n    }\n]\n```", "```cpp\nchar gltf_file[512]{ };\nmemcpy( gltf_file, argv[ 1 ], strlen( argv[ 1] ) );\nfile_name_from_path( gltf_file );\nglTF::glTF scene = gltf_load_file( gltf_file );\n```", "```cpp\nArray<TextureResource> images;\nimages.init( allocator, scene.images_count );\nfor ( u32 image_index = 0; image_index\n  < scene.images_count; ++image_index ) {\n    glTF::Image& image = scene.images[ image_index ];\n    TextureResource* tr = renderer.create_texture(\n        image.uri.data, image.uri.data );\n    images.push( *tr );\n}\nArray<SamplerResource> samplers;\nsamplers.init( allocator, scene.samplers_count );\nfor ( u32 sampler_index = 0; sampler_index\n  < scene.samplers_count; ++sampler_index ) {\n  glTF::Sampler& sampler = scene.samplers[ sampler_index ];\n  SamplerCreation creation;\n  creation.min_filter = sampler.min_filter == glTF::\n      Sampler::Filter::LINEAR ? VK_FILTER_LINEAR :\n          VK_FILTER_NEAREST;\n  creation.mag_filter = sampler.mag_filter == glTF::\n      Sampler::Filter::LINEAR ? VK_FILTER_LINEAR :\n          VK_FILTER_NEAREST;\n  SamplerResource* sr = renderer.create_sampler( creation\n  );\n  samplers.push( *sr );\n}\n```", "```cpp\nArray<void*> buffers_data;\nbuffers_data.init( allocator, scene.buffers_count );\nfor ( u32 buffer_index = 0; buffer_index\n  < scene.buffers_count; ++buffer_index ) {\n    glTF::Buffer& buffer = scene.buffers[ buffer_index ];\n    FileReadResult buffer_data = file_read_binary(\n        buffer.uri.data, allocator );\n    buffers_data.push( buffer_data.data );\n}\nArray<BufferResource> buffers;\nbuffers.init( allocator, scene.buffer_views_count );\nfor ( u32 buffer_index = 0; buffer_index\n  < scene.buffer_views_count; ++buffer_index ) {\n    glTF::BufferView& buffer = scene.buffer_views[\n        buffer_index ];\n    u8* data = ( u8* )buffers_data[ buffer.buffer ] +\n        buffer.byte_offset;\n    VkBufferUsageFlags flags =\n        VK_BUFFER_USAGE_VERTEX_BUFFER_BIT |\n            VK_BUFFER_USAGE_INDEX_BUFFER_BIT;\n    BufferResource* br = renderer.create_buffer( flags,\n        ResourceUsageType::Immutable, buffer.byte_length,\n            data, buffer.name.data );\n    buffers.push( *br );\n}\n```", "```cpp\nfor ( u32 mesh_index = 0; mesh_index < scene.meshes_count;\n  ++mesh_index ) {\n    glTF::Mesh& mesh = scene.meshes[ mesh_index ];\n    glTF::MeshPrimitive& mesh_primitive = mesh.primitives[\n        0 ];\n    glTF::Accessor& position_accessor = scene.accessors[\n        gltf_get_attribute_accessor_index(\n        mesh_primitive.attributes, mesh_primitive.\n        attribute_count, \"POSITION\" ) ];\n    glTF::BufferView& position_buffer_view =\n        scene.buffer_views[ position_accessor.buffer_view\n        ];\n    BufferResource& position_buffer_gpu = buffers[\n        position_accessor.buffer_view ];\n    MeshDraw mesh_draw{ };\n    mesh_draw.position_buffer = position_buffer_gpu.handle;\n    mesh_draw.position_offset = position_accessor.\n                                byte_offset;\n}\n```", "```cpp\nDescriptorSetCreation rl_creation{};\nrl_creation.set_layout( cube_rll ).buffer( cube_cb, 0 );\nrl_creation.texture_sampler( diffuse_texture_gpu.handle,\n    diffuse_sampler_gpu.handle, 1 );\nrl_creation.texture_sampler( roughness_texture_gpu.handle,\n    roughness_sampler_gpu.handle, 2 );\nrl_creation.texture_sampler( normal_texture_gpu.handle,\n    normal_sampler_gpu.handle, 3 );\nrl_creation.texture_sampler( occlusion_texture_gpu.handle,\n    occlusion_sampler_gpu.handle, 4 );\n mesh_draw.descriptor_set = gpu.create_descriptor_set(\n     rl_creation );\n```", "```cpp\nfor ( u32 mesh_index = 0; mesh_index < mesh_draws.size;\n  ++mesh_index ) {\n    MeshDraw mesh_draw = mesh_draws[ mesh_index ];\n    gpu_commands->bind_vertex_buffer( sort_key++,\n        mesh_draw.position_buffer, 0,\n            mesh_draw.position_offset );\n    gpu_commands->bind_vertex_buffer( sort_key++,\n        mesh_draw.tangent_buffer, 1,\n            mesh_draw.tangent_offset );\n    gpu_commands->bind_vertex_buffer( sort_key++,\n        mesh_draw.normal_buffer, 2,\n            mesh_draw.normal_offset );\n    gpu_commands->bind_vertex_buffer( sort_key++,\n        mesh_draw.texcoord_buffer, 3,\n            mesh_draw.texcoord_offset );\n    gpu_commands->bind_index_buffer( sort_key++,\n        mesh_draw.index_buffer, mesh_draw.index_offset );\n    gpu_commands->bind_descriptor_set( sort_key++,\n        &mesh_draw.descriptor_set, 1, nullptr, 0 );\n    gpu_commands->draw_indexed( sort_key++,\n        TopologyType::Triangle, mesh_draw.count, 1, 0, 0,\n            0 );\n}\n```", "```cpp\nfloat NdotH = dot(N, H);\nfloat alpha_squared = alpha * alpha;\nfloat d_denom = ( NdotH * NdotH ) * ( alpha_squared - 1.0 )\n    + 1.0;\nfloat distribution = ( alpha_squared * heaviside( NdotH ) )\n    / ( PI * d_denom * d_denom );\nfloat NdotL = dot(N, L);\nfloat NdotV = dot(N, V);\nfloat HdotL = dot(H, L);\nfloat HdotV = dot(H, V);\nfloat visibility = ( heaviside( HdotL ) / ( abs( NdotL ) +\n  sqrt( alpha_squared + ( 1.0 - alpha_squared ) *\n  ( NdotL * NdotL ) ) ) ) * ( heaviside( HdotV ) /\n  ( abs( NdotV ) + sqrt( alpha_squared +\n  ( 1.0 - alpha_squared ) *\n  ( NdotV * NdotV ) ) ) );\nfloat specular_brdf = visibility * distribution;\n```", "```cpp\nvec3 diffuse_brdf = (1 / PI) * base_colour.rgb;\n```", "```cpp\n// f0 in the formula notation refers to the base colour\n   here\nvec3 conductor_fresnel = specular_brdf * ( base_colour.rgb\n  + ( 1.0 - base_colour.rgb ) * pow( 1.0 - abs( HdotV ),\n      5 ) );\n// f0 in the formula notation refers to the value derived\n   from ior = 1.5\nfloat f0 = 0.04; // pow( ( 1 - ior ) / ( 1 + ior ), 2 )\nfloat fr = f0 + ( 1 - f0 ) * pow(1 - abs( HdotV ), 5 );\nvec3 fresnel_mix = mix( diffuse_brdf, vec3(\n                        specular_brdf ), fr );\n```", "```cpp\nvec3 material_colour = mix( resnel_mix,\n                            conductor_fresnel, metalness );\n```"]