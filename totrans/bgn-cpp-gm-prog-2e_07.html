<html><head></head><body>
		<div id="_idContainer055">
			<h1 id="_idParaDest-151"><a id="_idTextAnchor154"/><em class="italic">Chapter 6</em>: Object-Oriented Programming – Starting the Pong Game</h1>
			<p>In this chapter, there's quite a large amount of theory, but the theory will give us the knowledge that we need to start using <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) with some expertise. Furthermore, we will not waste any time in putting that theory to good use as we will use it to code the next project, a Pong game. We will get to look behind the scenes at how we can create new types that we can use as objects by coding a class. First, we will look at a simplified Pong scenario so that we can learn about some class basics, and then we will start again and code a Pong game for real using the principles we have learned.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Learn about OOP and classes using a hypothetical <strong class="source-inline">Bat</strong> class</li>
				<li>Start working on the Pong game and code a real class to represent the player's bat</li>
			</ul>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor155"/>OOP</h1>
			<p>Object-oriented programming is a programming paradigm that we could consider to be almost the standard way to code. It is true there are non-OOP ways to code and there are even some non-OOP game coding languages/libraries. However, since we are starting from scratch, there is no reason to do things in any other way.</p>
			<p>OOP will do the following:</p>
			<ul>
				<li>Make our code easier to manage, change, or update</li>
				<li>Make our code quicker and more reliable to write</li>
				<li>Make it possible to easily use other people's code (like we have with SFML)</li>
			</ul>
			<p>We have already seen the third benefit in action. Let's discuss exactly what OOP is.</p>
			<p>OOP is a way of programming that involves breaking our requirements down into chunks that are more manageable than the whole. Each chunk is self-contained yet potentially reusable by other programs, while working together as a whole with the other chunks. These chunks are what we have been referring to as objects. </p>
			<p>When we plan and code an object, we do so with a <strong class="bold">class</strong>. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">A class can be thought of as the blueprint of an object.</p>
			<p>We implement an object <em class="italic">of</em> a class. This is called an <strong class="bold">instance</strong> of a class. Think about a house blueprint. You can't live in it, but you can build a house from it. You build an instance of the house. Often, when we design classes for our games, we write them to represent real-world <em class="italic">things</em>. In the next project, we will write classes for a bat that the player controls and a ball that the player can bounce around the screen with the bat. However, OOP is more than this. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">OOP is a <em class="italic">way</em> of doing things, a methodology that defines best practices.</p>
			<p>The three core principles of OOP are <strong class="bold">encapsulation</strong>, <strong class="bold">polymorphism</strong>, and <strong class="bold">inheritance</strong>. This might sound complex but, taken a step at a time, this is reasonably straightforward.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor156"/>Encapsulation</h2>
			<p><strong class="bold">Encapsulation</strong> means keeping the internal workings of your code safe from interference from the code that uses it. You can achieve this by allowing only the variables and functions you choose to be accessed. This means your code can always be updated, extended, or improved without affecting the programs that use it, provided the exposed parts are still accessed in the same way.</p>
			<p>As an example, with proper encapsulation, it wouldn't matter whether the SFML team needed to update the way their <strong class="source-inline">Sprite</strong> class works. If the function signatures remain the same, they don't have to worry about what goes on inside. The code that we wrote before the update will still work after the update. </p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor157"/>Polymorphism</h2>
			<p><strong class="bold">Polymorphism</strong> allows us to write code that is less dependent on the <em class="italic">types</em> we are trying to manipulate. This will make our code clearer and more efficient. Polymorphism means <em class="italic">different forms</em>. If the objects that we code can be more than one type of thing, then we can take advantage of this. Polymorphism might sound a little bit like black magic at this point. We will use polymorphism in the fourth project, which we will start in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>,<em class="italic"> Abstraction and Code Management – Making Better Use of OOP</em>. Everything will become clearer.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor158"/>Inheritance</h2>
			<p>Just like it sounds, <strong class="bold">inheritance</strong> means we can harness all the features and benefits of other peoples' classes, including encapsulation and polymorphism, while further refining their code specifically to our situation. We will use inheritance for the first time at the same time as we use polymorphism.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor159"/>Why use OOP?</h2>
			<p>When written properly, OOP allows you to add new features without worrying about how they interact with existing features. When you do have to change a class, its self-contained (encapsulated) nature means less or perhaps even zero consequences for other parts of the program. </p>
			<p>You can use other people's code (like the SFML classes) without knowing or perhaps even caring for how it works inside.</p>
			<p>OOP and, by extension, SFML, allows you to write games that use complicated concepts such as multiple cameras, multiplayer, OpenGL, directional sound, and more besides—all of this without breaking a sweat.</p>
			<p>You can create multiple, similar, yet different versions of a class without starting the class from scratch by using inheritance.</p>
			<p>You can still use the functions intended for the original type of object with your new object because of polymorphism.</p>
			<p>All this makes sense really. And as we know, C++ was designed from the start with all this OOP in mind.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The ultimate key to success with OOP and making games (or any other type of app), other than the determination to succeed, is planning and design. It is not so much just "knowing" all the C++, SFML, and OOP topics that will help you to write great code, but rather applying all that knowledge to write code that is well-structured/designed. The code in this book is presented in an order and manner that's appropriate for learning about the various C++ topics in a gaming context. The art and science of structuring your code is called <strong class="bold">design patterns</strong>. As your code gets longer and more complex, effective use of design patterns will become more important. The good news is that we don't need to invent these design patterns ourselves. We will need to learn about them as our projects get more complex. As our projects become more complex, our design patterns will evolve too.</p>
			<p>In this project, we will learn about and use basic classes and encapsulation. As this book progresses, we will get a bit more daring and use inheritance, polymorphism, and other OOP-related C++ features too.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor160"/>What exactly is a class?</h2>
			<p>A class is a bunch of code that can contains functions, variables, loops, and all the other C++ syntax we have already learned about. Each new class will be declared in its own <strong class="source-inline">.h</strong> code file with the same name as the class, while its functions will be defined in their own <strong class="source-inline">.cpp</strong> file.</p>
			<p>Once we have written a class, we can use it to make as many objects from it as we want. Remember, the class is the blueprint, and we make objects based on the blueprint. The house isn't the blueprint, just like the object isn't the class. It is an object made <em class="italic">from</em> the class.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You can think of an object as a variable and the class as a type.</p>
			<p>Of course, with all this talk of OOP and classes, we haven't actually seen any code. Let's fix that now.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor161"/>The theory of a Pong Bat</h1>
			<p>What follows is a hypothetical discussion of how we might use OOP to get started with the Pong project by coding a Bat class. Don't add any code to the project just yet as what follows is over-simplified in order to explain the theory. Later in this chapter, we will code it for real. When we get to coding the class for real, it will actually be quite different, but the principles we will learn about here will prepare us for success.</p>
			<p>We will begin by exploring variables and functions as part of a class.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor162"/>The class variable and function declarations</h2>
			<p>A bat that bounces a ball would be an excellent first candidate for a class.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you don't know what Pong is, then take a look at this link: <a href="https://en.wikipedia.org/wiki/Pong">https://en.wikipedia.org/wiki/Pong</a>.</p>
			<p>Let's take a look at a hypothetical <strong class="source-inline">Bat.h</strong> file:</p>
			<p class="source-code">class Bat</p>
			<p class="source-code">{</p>
			<p class="source-code">    private:</p>
			<p class="source-code">        // Length of the pong bat</p>
			<p class="source-code">        int m_Length = 100;</p>
			<p class="source-code">        // Height of the pong bat</p>
			<p class="source-code">        int m_Height = 10;</p>
			<p class="source-code">        // Location on x axis</p>
			<p class="source-code">        int m_XPosition;      </p>
			<p class="source-code">        // Location on y axis</p>
			<p class="source-code">        int m_YPosition;      </p>
			<p class="source-code">    public:</p>
			<p class="source-code">        void moveRight();</p>
			<p class="source-code">        void moveLeft();</p>
			<p class="source-code">};</p>
			<p>At first glance, the code might appear a little complex, but when it has been explained, we will see there are very few concepts we haven't already covered.</p>
			<p>The first thing to notice is that a new class is declared using the <strong class="source-inline">class</strong> keyword, followed by the name of the class and that the entire declaration is enclosed in curly braces, followed by a closing semicolon:</p>
			<p class="source-code">class Bat</p>
			<p class="source-code">{</p>
			<p class="source-code">    …</p>
			<p class="source-code">    …</p>
			<p class="source-code">};</p>
			<p>Now, let's take a look at the variable declarations and their names: </p>
			<p class="source-code">// Length of the pong bat</p>
			<p class="source-code">int m_Length = 100; </p>
			<p class="source-code">// Height of the pong bat</p>
			<p class="source-code">int m_Height = 10;</p>
			<p class="source-code">// Location on x axis</p>
			<p class="source-code">int m_XPosition;      </p>
			<p class="source-code">// Location on y axis</p>
			<p class="source-code">int m_YPosition;</p>
			<p>All the names are prefixed with <strong class="source-inline">m_</strong>. This <strong class="source-inline">m_</strong> prefix is not compulsory, but it is a good convention. Variables that are declared as part of the class are called <strong class="bold">member variables</strong>. Prefixing with an <strong class="source-inline">m_</strong> makes it plain when we are dealing with a member variable. When we write functions for our classes, we will start to see local (non-member) variables and parameters as well. The <strong class="source-inline">m_</strong> convention will then prove itself useful.</p>
			<p>Also, notice that all the variables are in a section of the code headed with the <strong class="source-inline">private:</strong> keyword. Scan your eyes over the previous code and note that the body of the class code is separated into two sections:</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // more code here</p>
			<p class="source-code">public:</p>
			<p class="source-code">    // More code here</p>
			<p>The <strong class="source-inline">public</strong> and <strong class="source-inline">private</strong> keywords control the encapsulation of our class. Anything that is private cannot be accessed directly by the user of an instance/object of the class. If you are designing a class for others to use, you don't want them to be able to alter anything at will. Note that member variables do not have to be private, but good encapsulation is achieved by making them private whenever possible.</p>
			<p>This means that our four member variables (<strong class="source-inline">m_Length</strong>, <strong class="source-inline">m_Height</strong>, <strong class="source-inline">m_XPosition</strong>, and <strong class="source-inline">m_YPosition</strong>) cannot be accessed directly by our game engine from the <strong class="source-inline">main</strong> function. They can only be accessed indirectly by the code of the class. This is encapsulation in action. For the <strong class="source-inline">m_Length</strong> and <strong class="source-inline">m_Height</strong> variables, this is fairly easy to accept as long as we don't need to change the size of the bat. The <strong class="source-inline">m_XPosition</strong> and <strong class="source-inline">m_YPosition</strong> member variables, however, need to be accessed, or how on earth will we move the bat?</p>
			<p>This problem is solved in the <strong class="source-inline">public:</strong> section of the code, as follows:</p>
			<p class="source-code">void moveRight();</p>
			<p class="source-code">void moveLeft();</p>
			<p>The class provides two functions that are public and will be usable with an object of the <strong class="source-inline">Bat</strong> type. When we look at the definitions of these functions, we will see how exactly these functions manipulate the private variables. </p>
			<p>In summary, we have a bunch of inaccessible (private) variables that cannot be used from the <strong class="source-inline">main</strong> function. This is good because encapsulation makes our code less error-prone and more maintainable. We then solve the problem of moving the bat by providing indirect access to the <strong class="source-inline">m_XPosition</strong> and <strong class="source-inline">m_YPosition</strong> variables by providing two public functions.</p>
			<p>The code in the <strong class="source-inline">main</strong> function can call these functions using an instance of the class, but the code inside the functions control exactly how the variables are used.</p>
			<p>Let's take a look at the function definitions.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor163"/>The class function definitions</h2>
			<p>The function definitions we will write in this book will all go in a separate file to the class and function declarations. We will use files with the same name as the class and the <strong class="source-inline">.cpp</strong> file extension. So, for example, the following code would go in a file called <strong class="source-inline">Bat.cpp</strong>. Look at the following code, which has just one new concept:</p>
			<p class="source-code">#include "Bat.h"</p>
			<p class="source-code">void Bat::moveRight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Move the bat a pixel to the right</p>
			<p class="source-code">    xPosition ++;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Bat::moveLeft()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Move the bat a pixel to the left</p>
			<p class="source-code">    xPosition --;</p>
			<p class="source-code">}</p>
			<p>The first thing to note is that we must use an include directive to include the class and function declarations from the <strong class="source-inline">Bat.h</strong> file.</p>
			<p>The new concept we can see here is the use of the <strong class="bold">scope resolution operator</strong>, <strong class="source-inline">::</strong>. Since the functions belong to a class, we must write the signature part by prefixing the function name with the class name, as well as <strong class="source-inline">::</strong>. <strong class="source-inline">void Bat::moveLeft()</strong> and <strong class="source-inline">void Bat::moveRight</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Actually, we have briefly seen the scope resolution operator before, that is, whenever we declare an object of a class, and we have not previously used <strong class="source-inline">using namespace..</strong>.</p>
			<p>Note that we could have put the function definitions and declarations in one file, like this:</p>
			<p class="source-code">class Bat</p>
			<p class="source-code">{</p>
			<p class="source-code">    private:</p>
			<p class="source-code">        // Length of the pong bat</p>
			<p class="source-code">        int m_Length = 100; </p>
			<p class="source-code">        // Length of the pong bat</p>
			<p class="source-code">        int m_Height = 10;</p>
			<p class="source-code">        // Location on x axis</p>
			<p class="source-code">        int m_XPosition;      </p>
			<p class="source-code">        // Location on y axis</p>
			<p class="source-code">        int m_YPosition;      </p>
			<p class="source-code">    public:</p>
			<p class="source-code">        void Bat::moveRight()</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Move the bat a pixel to the right</p>
			<p class="source-code">            xPosition ++;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        void Bat::moveLeft()</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Move the bat a pixel to the left</p>
			<p class="source-code">            xPosition --;</p>
			<p class="source-code">        }</p>
			<p class="source-code">};</p>
			<p>However, when our classes get longer (as they will with our first Zombie Arena class), it is more organized to separate the function definitions into their own file. Furthermore, header files are considered "public", and are often used for documentation purposes if other people will be using the code that we write.</p>
			<p>But how do we use a class once we have coded it?</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor164"/>Using an instance of a class</h2>
			<p>Despite all the code we have seen related to classes, we haven't actually used the class. We already know how to do this as we have used the SFML classes many times already.</p>
			<p>First, we would create an instance of the <strong class="source-inline">Bat</strong> class, like this:</p>
			<p class="source-code">Bat bat;</p>
			<p>The <strong class="source-inline">bat</strong> object has all the variables we declared in <strong class="source-inline">Bat.h</strong>. We just can't access them directly. We can, however, move our bat using its public functions, like this:</p>
			<p class="source-code">bat.moveLeft();</p>
			<p>Or we can move it like this:</p>
			<p class="source-code">bat.moveRight();</p>
			<p>Remember that <strong class="source-inline">bat</strong> <em class="italic">is a</em> <strong class="source-inline">Bat</strong>, and as such it has all the member variables and has all of the functions available to it.</p>
			<p>Later, we may decide to make our Pong game multiplayer. In the <strong class="source-inline">main</strong> function, we could change the code so that the game has two bats, perhaps like this:</p>
			<p class="source-code">Bat bat;</p>
			<p class="source-code"><strong class="bold">Bat bat2;</strong></p>
			<p>It is vitally important to realize that each of these instances of <strong class="source-inline">Bat</strong> are separate objects with their very own set of variables. There are more ways to initialize an instance of a class, and we will see an example of this when we code the <strong class="source-inline">Bat</strong> class for real, next.</p>
			<p>Now, we can start the project for real.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor165"/>Creating the Pong project</h1>
			<p>Since setting up a project is a fiddly process, we will go through it a step by step, like we did for the Timber!!! project. I won't show you the same screenshots that I did for the Timber!!! project, but the process is the same, so flip back to <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em> if you want a reminder of the locations of the various project properties:</p>
			<ol>
				<li>Start Visual Studio and click on the <strong class="bold">Create New Project</strong> button. Or, if you still have the Timber!!! project open, you can select <strong class="bold">File</strong> | <strong class="bold">New project</strong>.</li>
				<li>In the window shown next, choose <strong class="bold">Console app</strong> and click the <strong class="bold">Next</strong> button. You will then see the <strong class="bold">Configure your new project</strong> window. </li>
				<li>In the <strong class="bold">Configure your new project</strong> window, type <strong class="source-inline">Pong</strong> in the <strong class="bold">Project</strong> <strong class="bold">name</strong> field. Note that this causes Visual Studio to automatically configure the <strong class="bold">Solution name</strong> field so that it has the same name.</li>
				<li>In the <strong class="bold">Location</strong> field, browse to the <strong class="source-inline">VS Projects</strong> folder that we created in Chapter 1. Like the Timber!!! project, this will be the location that all our project files will be kept. </li>
				<li>Check the option to <strong class="bold">Place solution and project in the same directory</strong>.</li>
				<li>When you have completed these steps, click <strong class="bold">Create</strong>. The project is generated by Visual Studio, including some C++ code in the <strong class="source-inline">main.cpp</strong> file, like it was previously. </li>
				<li>We will now configure the project to use the SFML files that we put in the <strong class="source-inline">SFML</strong> folder. From the main menu, select <strong class="bold">Project</strong> | <strong class="bold">Pong properties…</strong>. At this stage, you should have the <strong class="bold">Pong Property Pages</strong> window open. </li>
				<li>In the <strong class="bold">Pong Property Pages</strong> window, select <strong class="bold">All Configurations</strong> from the <strong class="bold">Configuration:</strong> drop-down.</li>
				<li>Now, select <strong class="bold">C/C++</strong> and then <strong class="bold">General</strong> from the left-hand menu.</li>
				<li>After, locate the <strong class="bold">Additional Include Directories</strong> edit box and type the drive letter where your SFML folder is located, followed by <strong class="source-inline">\SFML\include</strong>. The full path to type, if you located your <strong class="source-inline">SFML</strong> folder on your D drive, is <strong class="source-inline">D:\SFML\include</strong>. Change your path if you installed SFML on a different drive.</li>
				<li>Click <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Now, still in the same window, perform these steps. From the left-hand menu, select <strong class="bold">Linker</strong> and then <strong class="bold">General</strong>.</li>
				<li>Now, find the <strong class="bold">Additional Library Directories</strong> edit box and type the drive letter where your <strong class="source-inline">SFML</strong> folder is, followed by <strong class="source-inline">\SFML\lib</strong>. So, the full path to type if you located your <strong class="source-inline">SFML</strong> folder on your D drive is <strong class="source-inline">D:\SFML\lib</strong>. Change your path if you installed SFML on a different drive.</li>
				<li>Click <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Next, still in the same window, perform these steps. Switch the <strong class="bold">Configuration:</strong> drop-down to <strong class="bold">Debug </strong>as we will be running and testing Pong in debug mode.</li>
				<li>Select <strong class="bold">Linker</strong> and then <strong class="bold">Input</strong>.</li>
				<li>Find the <strong class="bold">Additional Dependencies</strong> edit box and click into it on the far left-hand side. Now, copy and paste/type in the following: <strong class="source-inline">sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;</strong>. Be extra careful to place the cursor exactly at the start of the edit box's current content so that you don't overwrite any of the text that is already there.</li>
				<li>Click <strong class="bold">OK</strong>.</li>
				<li> Click <strong class="bold">Apply</strong> and then <strong class="bold">OK</strong>.</li>
				<li>Now, we need to copy the SFML <strong class="source-inline">.dll</strong> files into the main project directory. My main project directory is <strong class="source-inline">D:\VS Projects\Pong</strong>. It was created by Visual Studio in the previous steps. If you put your <strong class="source-inline">VS Projects</strong> folder somewhere else, then perform this step there instead. The files we need to copy into the project folder are located in our <strong class="source-inline">SFML\bin</strong> folder. Open a window for each of the two locations and highlight all the files in the <strong class="source-inline">SFML\bin</strong> folder.</li>
				<li>Now, copy and paste the highlighted files into the project folder, that is, <strong class="source-inline">D:\VS Projects\Pong</strong>.</li>
			</ol>
			<p>We now have the project properties configured and ready to go.</p>
			<p>We will be displaying some text for a HUD (Heads Up Display) in this game that will show the player's score and remaining lives. For this, we need a font.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Download this free-for-personal-use font from <a href="http://www.dafont.com/theme.php?cat=302">http://www.dafont.com/theme.php?cat=302</a> and unzip the download. Or feel free to use a font of your choice. You will just need to make some minor changes to the code when we load the font.</p>
			<p>Create a new folder called <strong class="source-inline">fonts</strong> in the <strong class="source-inline">VS Projects\Pong</strong> folder and add the <strong class="source-inline">DS-DIGIT.ttf</strong> file into the <strong class="source-inline">VS Projects\Pong\fonts</strong> folder.</p>
			<p>We are now ready to code our first C++ class.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor166"/>Coding the Bat class</h1>
			<p>The simple Pong bat example was a good way of introducing the basics of classes. Classes can be simple and short, like the preceding <strong class="source-inline">Bat</strong> class, but they can also be longer and more complicated and contain other objects made from other classes.</p>
			<p>When it comes to making games, there is a few vital things missing from the hypothetical <strong class="source-inline">Bat</strong> class. It might be fine for all these private member variables and public functions, but how will we draw anything? Our Pong bat needs a sprite, and in some games, they will also need a texture. Furthermore, we need a way to control the rate of animation of all our game objects, just like we did with the bee and the clouds in the previous project. We can include other objects in our class in exactly the same way that we included them in the <strong class="source-inline">main.cpp</strong> file. Let's code our <strong class="source-inline">Bat</strong> class for real so that we can see how we can solve all these issues.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor167"/>Coding Bat.h</h2>
			<p>To get started, we will code the header file. Right-click on <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> window and select <strong class="bold">ADD</strong> | <strong class="bold">New Item</strong>. Next, choose the <strong class="bold">Header File (.h)</strong> option and name the new file <strong class="source-inline">Bat.h</strong>. Click the <strong class="bold">Add</strong> button. We are now ready to code the file.</p>
			<p>Add the following code to <strong class="source-inline">Bat.h</strong>:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Bat</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    Vector2f m_Position;</p>
			<p class="source-code">    // A RectangleShape object</p>
			<p class="source-code">    RectangleShape m_Shape;</p>
			<p class="source-code">    float m_Speed = 1000.0f;</p>
			<p class="source-code">    bool m_MovingRight = false;</p>
			<p class="source-code">    bool m_MovingLeft = false;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    Bat(float startX, float startY);</p>
			<p class="source-code">    FloatRect getPosition();</p>
			<p class="source-code">    RectangleShape getShape();</p>
			<p class="source-code">    void moveLeft();</p>
			<p class="source-code">    void moveRight();</p>
			<p class="source-code">    void stopLeft();</p>
			<p class="source-code">    void stopRight();</p>
			<p class="source-code">    void update(Time dt);</p>
			<p class="source-code">};</p>
			<p>First, note the <strong class="source-inline">#pragma once</strong> declaration at the top of the file. This prevents the file from being processed by the compiler more than once. As our games get more complicated with perhaps dozens of classes, this will speed up compilation time.</p>
			<p>Note the names of the member variables and the parameters and return types of the functions. We have a <strong class="source-inline">Vector2f</strong> called <strong class="source-inline">m_Position</strong>, which will hold the horizontal and vertical position of the player's bat. We also have an SFML <strong class="source-inline">RectangleShape</strong>, which will be the actual bat that appears on the screen.</p>
			<p>There are two Boolean members that will track which direction, if any, the bat is currently moving in, and we have a <strong class="source-inline">float</strong> called <strong class="source-inline">m_Speed</strong> that tells us the number of pixels per second that the bat can move at when the player decides to move it left or right.</p>
			<p>The next part of the code needs some explanation since we have a function called <strong class="source-inline">Bat</strong>; this is the exact same name as the class. This is called a constructor.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor168"/>Constructor functions</h2>
			<p>When a class is coded, a special function is created by the compiler. We don't see this function in our code, but it is there. It is called a constructor. It is the function that would have been called if we used our hypothetical <strong class="source-inline">Bat</strong> class example.</p>
			<p>When we need to write some code to prepare an object for use, often a good place to do this is in the constructor. When we want the constructor to do anything other than simply create an instance, we must replace the default (unseen) constructor provided by the compiler. This is what we will do with the <strong class="source-inline">Bat</strong> constructor function.</p>
			<p>Notice that the <strong class="source-inline">Bat</strong> constructor takes two <strong class="source-inline">float</strong> parameters. This is perfect for initializing the position on the screen when we first create a <strong class="source-inline">Bat</strong> object. Also note that constructors have no return type, not even <strong class="source-inline">void</strong>. </p>
			<p>We will soon use the constructor function, <strong class="source-inline">Bat</strong>, to put this game object into its starting position. Remember that this function is called at the time that an object of the <strong class="source-inline">Bat</strong> type is declared.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor169"/>Continuing with the Bat.h explanation</h2>
			<p>Next is the <strong class="source-inline">getPosition</strong> function, which returns a <strong class="source-inline">FloatRect</strong>, the four points that define a rectangle. Then, we have <strong class="source-inline">getShape</strong>, which returns a <strong class="source-inline">RectangleShape</strong>. This will be used so that we can return to the main game loop,  <strong class="source-inline">m_Shape</strong>, so that it can be drawn.</p>
			<p>We also have the <strong class="source-inline">moveLeft</strong>, <strong class="source-inline">moveRight</strong>, <strong class="source-inline">stopLeft</strong>, and <strong class="source-inline">stopRight</strong> functions, which are for controlling if, when, and in which direction the bat will be in motion.</p>
			<p>Finally, we have the <strong class="source-inline">update</strong> function, which takes a <strong class="source-inline">Time</strong> parameter. This function will be used to calculate how to move the bat each frame. As a bat and a ball will both move quite differently to each other, it makes sense to encapsulate the movement code inside the class. We will call the <strong class="source-inline">update</strong> function once each frame of the game from the <strong class="source-inline">main</strong> function.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You can probably guess that the <strong class="source-inline">Ball</strong> class will also have an <strong class="source-inline">update</strong> function.</p>
			<p>Now, we can code <strong class="source-inline">Bat.cpp</strong>, which will implement all the definitions and use the member variables.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor170"/>Coding Bat.cpp</h2>
			<p>Let's create the file, and then we can start discussing the code. Right-click the <strong class="bold">Source Files</strong> folder in the Solution Explorer window. Now, select <strong class="bold">C++ File (.cpp)</strong> and enter <strong class="source-inline">Bat.cpp</strong> in the <strong class="bold">Name:</strong> field. Click the <strong class="bold">Add</strong> button and our new file will be created for us.</p>
			<p>We will divide the code for this file into two parts to make discussing it simpler. </p>
			<p>First, code the <strong class="source-inline">Bat</strong> constructor function, as follows:</p>
			<p class="source-code">#include "Bat.h"</p>
			<p class="source-code"> </p>
			<p class="source-code">// This the constructor and it is called when we create an object</p>
			<p class="source-code">Bat::Bat(float startX, float startY)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Position.x = startX;</p>
			<p class="source-code">    m_Position.y = startY;</p>
			<p class="source-code"> </p>
			<p class="source-code">    m_Shape.setSize(sf::Vector2f(50, 5));</p>
			<p class="source-code">    m_Shape.setPosition(m_Position);</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we can see that we include the <strong class="source-inline">bat.h</strong> file. This makes all the functions and variables that were declared previously in <strong class="source-inline">bat.h</strong> available to us.</p>
			<p>We implement the constructor because we need to do some work to get the instance set up, and the default unseen empty constructor provided by the compiler is not sufficient. Remember that the constructor is the code that runs when we initialize an instance of <strong class="source-inline">Bat</strong>.</p>
			<p>Notice that we use the <strong class="source-inline">Bat::Bat</strong> syntax as the function name to make it clear we are using the <strong class="source-inline">Bat</strong> function from the <strong class="source-inline">Bat</strong> class.</p>
			<p>This constructor receives two <strong class="source-inline">float</strong> values, <strong class="source-inline">startX</strong> and <strong class="source-inline">startY</strong>. The next thing that happens is we assign these values to <strong class="source-inline">m_Position.x</strong> and <strong class="source-inline">m_Position.y</strong>. The <strong class="source-inline">Vector2f</strong> named <strong class="source-inline">m_Position</strong> now holds the values that were passed in, and because <strong class="source-inline">m_Position</strong> is a member variable, these values are accessible throughout the class. Note, however, that <strong class="source-inline">m_Position</strong> was declared as <strong class="source-inline">private</strong> and will not accessible in our <strong class="source-inline">main</strong> function file—not directly, anyway. We will see how we can resolve this issue soon.</p>
			<p>Finally, in the constructor, we initialize the <strong class="source-inline">RectangleShape</strong> called <strong class="source-inline">m_Shape</strong> by setting its size and position. This is different to how we coded the hypothetical <strong class="source-inline">Bat</strong> class in the <em class="italic">The theory of a Pong Bat</em> section. The SFML <strong class="source-inline">Sprite</strong> class has convenient variables for size and position that we can access using the <strong class="source-inline">setSize</strong> and <strong class="source-inline">setPosition</strong> functions, so we don't need the hypothetical <strong class="source-inline">m_Length</strong> and <strong class="source-inline">m_Height</strong> anymore.</p>
			<p>Furthermore, note that we will need to vary how we initialize the <strong class="source-inline">Bat</strong> class (compared to the hypothetical <strong class="source-inline">Bat</strong> class) to suit our custom constructor.</p>
			<p>We need to implement the remaining five functions of the <strong class="source-inline">Bat</strong> class. Add the following code to <strong class="source-inline">Bat.cpp</strong> after the constructor we just discussed:</p>
			<p class="source-code">FloatRect Bat::getPosition()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Shape.getGlobalBounds();</p>
			<p class="source-code">}</p>
			<p class="source-code">RectangleShape Bat::getShape()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Shape;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Bat::moveLeft()</p>
			<p class="source-code">{</p>
			<p class="source-code">     m_MovingLeft = true;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Bat::moveRight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_MovingRight = true;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Bat::stopLeft()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_MovingLeft = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Bat::stopRight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_MovingRight = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Bat::update(Time dt)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_MovingLeft) {</p>
			<p class="source-code">        m_Position.x -= m_Speed * dt.asSeconds();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_MovingRight) {</p>
			<p class="source-code">        m_Position.x += m_Speed * dt.asSeconds();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    m_Shape.setPosition(m_Position);</p>
			<p class="source-code">}</p>
			<p>Let's go through the code we have just added.</p>
			<p>First, we have the <strong class="source-inline">getPosition</strong> function. All it does is return a <strong class="source-inline">FloatRect</strong> to the code that called it. The <strong class="source-inline">m_Shape.getGlobalBounds</strong> line of code returns a <strong class="source-inline">FloatRect</strong> that is initialized with the coordinates of the four corners of the <strong class="source-inline">RectangleShape</strong>, that is, <strong class="source-inline">m_Shape</strong>. We will call this function from the <strong class="source-inline">main</strong> function when we are determining whether the ball has hit the bat.</p>
			<p>Next, we have the <strong class="source-inline">getShape</strong> function. All this function does is pass a copy of <strong class="source-inline">m_Shape</strong> to the calling code. This is necessary so that we can draw the bat in the <strong class="source-inline">main</strong> function. When we code a public function with the sole purpose of passing back private data from a class, we call it a getter function.</p>
			<p>Now, we can look at the <strong class="source-inline">moveLeft</strong>, <strong class="source-inline">moveRight</strong>, <strong class="source-inline">stopLeft</strong>, and <strong class="source-inline">stopRight</strong> functions. All they do is set the <strong class="source-inline">m_MovingLeft</strong> and <strong class="source-inline">m_MovingRight</strong> Boolean variables appropriately so that they keep track of the player's current intentions. Note, however, that they don't do anything to the <strong class="source-inline">RectangleShape</strong> instance or the <strong class="source-inline">FloatRect</strong> instance that determine the position. This is just what we need.</p>
			<p>The last function in the <strong class="source-inline">Bat</strong> class is <strong class="source-inline">update</strong>. We will call this function once per frame of the game. The <strong class="source-inline">update</strong> function will grow in complexity as our game projects get more complicated. For now, all we need to do is tweak <strong class="source-inline">m_Position</strong>, depending on whether the player is moving left or right. Note that the formula that's used to do this tweak is the same one that we used for updating the bee and the clouds in the Timber!!! project. The code multiplies the speed by the delta time and then adds or subtracts it from the position. This causes the bat to move relative to how long the frame took to update. Next, the code sets the position of <strong class="source-inline">m_Shape</strong> with whatever the latest values held in <strong class="source-inline">m_Position</strong> happen to be. </p>
			<p>Having an <strong class="source-inline">update</strong> function in our <strong class="source-inline">Bat</strong> class rather than the <strong class="source-inline">main</strong> function is encapsulation. Rather than updating the positions of all the game objects in the <strong class="source-inline">main</strong> function like we did in the Timber!!! project, each object will be responsible for updating themselves. As we will do next, however, we will call this <strong class="source-inline">update</strong> function from the <strong class="source-inline">main</strong> function.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor171"/>Using the Bat class and coding the main function</h1>
			<p>Switch to the <strong class="source-inline">main.cpp</strong> file that was automatically generated when we created the project. Delete all its auto-generated code and add the code that follows.</p>
			<p>Code the <strong class="source-inline">Pong.cpp</strong> file as follows:</p>
			<p class="source-code">#include "Bat.h"</p>
			<p class="source-code">#include &lt;sstream&gt;</p>
			<p class="source-code">#include &lt;cstdlib&gt;</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Create a video mode object</p>
			<p class="source-code">    VideoMode vm(1920, 1080);</p>
			<p class="source-code">    // Create and open a window for the game</p>
			<p class="source-code">    RenderWindow window(vm, "Pong", Style::Fullscreen);</p>
			<p class="source-code">    int score = 0;</p>
			<p class="source-code">    int lives = 3;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Create a bat at the bottom center of the screen</p>
			<p class="source-code">    Bat bat(1920 / 2, 1080 - 20);</p>
			<p class="source-code">    // We will add a ball in the next chapter</p>
			<p class="source-code">    // Create a Text object called HUD</p>
			<p class="source-code">    Text hud;</p>
			<p class="source-code">    // A cool retro-style font</p>
			<p class="source-code">    Font font;</p>
			<p class="source-code">    font.loadFromFile("fonts/DS-DIGI.ttf");</p>
			<p class="source-code">    // Set the font to our retro-style</p>
			<p class="source-code">    hud.setFont(font);</p>
			<p class="source-code">    // Make it nice and big</p>
			<p class="source-code">    hud.setCharacterSize(75);</p>
			<p class="source-code">    // Choose a color</p>
			<p class="source-code">    hud.setFillColor(Color::White);</p>
			<p class="source-code">    hud.setPosition(20, 20);</p>
			<p class="source-code">    // Here is our clock for timing everything</p>
			<p class="source-code">    Clock clock;</p>
			<p class="source-code">    while (window.isOpen())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        /*</p>
			<p class="source-code">        Handle the player input</p>
			<p class="source-code">        ****************************</p>
			<p class="source-code">        ****************************</p>
			<p class="source-code">        ****************************</p>
			<p class="source-code">        */</p>
			<p class="source-code">        /*</p>
			<p class="source-code">        Update the bat, the ball and the HUD</p>
			<p class="source-code">        *****************************</p>
			<p class="source-code">        *****************************</p>
			<p class="source-code">        *****************************</p>
			<p class="source-code">        */</p>
			<p class="source-code">        </p>
			<p class="source-code">        </p>
			<p class="source-code">        /*</p>
			<p class="source-code">        Draw the bat, the ball and the HUD</p>
			<p class="source-code">        *****************************</p>
			<p class="source-code">        *****************************</p>
			<p class="source-code">        *****************************</p>
			<p class="source-code">        */</p>
			<p class="source-code">        </p>
			<p class="source-code">    }</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the structure is similar to the one we used in the Timber!!! project. The first exception, however, is when we create an instance of the <strong class="source-inline">Bat</strong> class:</p>
			<p class="source-code">// Create a bat</p>
			<p class="source-code">Bat bat(1920 / 2, 1080 - 20);</p>
			<p>The preceding code calls the constructor function to create a new instance of the <strong class="source-inline">Bat</strong> class. The code passes in the required arguments and allows the <strong class="source-inline">Bat</strong> class to initialize its position in the center of the screen near the bottom. This is the perfect position for our bat to start.</p>
			<p>Also note that I have used comments to indicate where the rest of the code will eventually be placed. It is all within the game loop, just like it was in the Timber!!! project. Here is where the rest of the code will go again, just to remind you:</p>
			<p class="source-code">      /*</p>
			<p class="source-code">        Handle the player input</p>
			<p class="source-code">        …</p>
			<p class="source-code">        /*</p>
			<p class="source-code">        Update the bat, the ball and the HUD</p>
			<p class="source-code">        …</p>
			<p class="source-code">        </p>
			<p class="source-code">        </p>
			<p class="source-code">        /*</p>
			<p class="source-code">        Draw the bat, the ball and the HUD</p>
			<p class="source-code">        …</p>
			<p>Next, add the code to the <strong class="source-inline">Handle the player input</strong> section, as follows:</p>
			<p class="source-code">Event event;</p>
			<p class="source-code">while (window.pollEvent(event))</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (event.type == Event::Closed)</p>
			<p class="source-code">        // Quit the game when the window is closed</p>
			<p class="source-code">        window.close();</p>
			<p class="source-code">}</p>
			<p class="source-code">// Handle the player quitting</p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Escape))</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.close();</p>
			<p class="source-code">}</p>
			<p class="source-code">// Handle the pressing and releasing of the arrow keys</p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Left))</p>
			<p class="source-code">{</p>
			<p class="source-code">    bat.moveLeft();</p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">{</p>
			<p class="source-code">    bat.stopLeft();</p>
			<p class="source-code">}</p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Right))</p>
			<p class="source-code">{</p>
			<p class="source-code">    bat.moveRight();</p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">{</p>
			<p class="source-code">    bat.stopRight();</p>
			<p class="source-code">}</p>
			<p>The preceding code handles the player quitting the game by pressing the <em class="italic">Escape</em> key, exactly like it did in the Timber!!! project. Next, there are two <strong class="source-inline">if</strong> – <strong class="source-inline">else</strong> structures that handle the player moving the bat. Let's analyze the first of these two structures:</p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Left))</p>
			<p class="source-code">{</p>
			<p class="source-code">    bat.moveLeft();</p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">{</p>
			<p class="source-code">    bat.stopLeft();</p>
			<p class="source-code">}</p>
			<p>The preceding code will detect whether the player is holding down the left arrow cursor key on the keyboard. If they are, then the <strong class="source-inline">moveLeft</strong> function is called on the <strong class="source-inline">Bat</strong> instance. When this function is called, the <strong class="source-inline">true</strong> value is set to the <strong class="source-inline">m_MovingLeft</strong> private Boolean variable. If, however, the left arrow key is not being held down, then the <strong class="source-inline">stopLeft</strong> function is called and the <strong class="source-inline">m_MovingLeft</strong> is set to <strong class="source-inline">false</strong>.</p>
			<p>The exact same process is then repeated in the next <strong class="source-inline">if</strong> – <strong class="source-inline">else</strong> block of code to handle the player pressing (or not pressing) the right arrow key.</p>
			<p>Next, add the following code to the <strong class="source-inline">Update the bat the ball and the HUD</strong> section, as follows:</p>
			<p class="source-code">// Update the delta time</p>
			<p class="source-code">Time dt = clock.restart();</p>
			<p class="source-code">bat.update(dt);</p>
			<p class="source-code">// Update the HUD text</p>
			<p class="source-code">std::stringstream ss;</p>
			<p class="source-code">ss &lt;&lt; "Score:" &lt;&lt; score &lt;&lt; "  Lives:" &lt;&lt; lives;</p>
			<p class="source-code">hud.setString(ss.str());</p>
			<p>In the preceding code, we use the exact same timing technique that we used for the Timber!!! project, only this time, we call <strong class="source-inline">update</strong> on the <strong class="source-inline">Bat</strong> instance and pass in the delta time. Remember that, when the <strong class="source-inline">Bat</strong> class receives the delta time, it will use the value to move the bat based on the previously received movement instructions from the player and the desired speed of the bat.</p>
			<p>Next, add the following code to the <strong class="source-inline">Draw the bat, the ball and the HUD</strong> section, as follows:</p>
			<p class="source-code">window.clear();</p>
			<p class="source-code">window.draw(hud);</p>
			<p class="source-code">window.draw(bat.getShape());</p>
			<p class="source-code">window.display();</p>
			<p>In the preceding code, we clear the screen, draw the text for the HUD, and use the <strong class="source-inline">bat.getShape</strong> function to grab the <strong class="source-inline">RectangleShape</strong> instance from the <strong class="source-inline">Bat</strong> instance and draw it to the screen. Finally, we call <strong class="source-inline">window.display</strong>, just like we did in the previous project, to draw the bat in its current position.</p>
			<p>At this stage, you can run the game and you will see the HUD and a bat. The bat can be moved smoothly left and right using the arrow/cursor keys:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Image86209.jpg" alt=""/>
				</div>
			</div>
			<p><a id="_idTextAnchor172"/>Congratulations! That is the first class, all coded and deployed.</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor173"/>Summary</h1>
			<p>In this chapter, we discovered the basics of OOP, such as how to code and use a class, including making use of encapsulation to control how code outside of our classes can access the member variables, but only to the extent and in the manner that we want it to. This is just like SFML classes, which allow us to create and use <strong class="source-inline">Sprite</strong> and <strong class="source-inline">Text</strong> instances, but only in the way they were designed to be used.</p>
			<p>Don't concern yourself too much if some of the details around OOP and classes are not entirely clear. The reason I say this is because we will spend the rest of this book coding classes and the more we use them, the clearer they will become.</p>
			<p>Furthermore, we have a working bat and a HUD for our Pong game.</p>
			<p>In the next chapter, we will code the <strong class="source-inline">Ball</strong> class and get it bouncing around the screen. We will then be able to add collision detection and finish the game.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor174"/>FAQ</h1>
			<p>Q) I have learned other languages and OOP seems much simpler in C++. Is this a correct assessment?</p>
			<p>A) This was an introduction to OOP and its basic fundamentals. There is more to it than this. We will learn about more OOP concepts and details throughout this book.</p>
		</div>
	</body></html>