<html><head></head><body>
		<div><h1 id="_idParaDest-151"><a id="_idTextAnchor154"/><em class="italic">Chapter 6</em>: Object-Oriented Programming – Starting the Pong Game</h1>
			<p>In this chapter, there's quite a large amount of theory, but the theory will give us the knowledge that we need to start using <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) with some expertise. Furthermore, we will not waste any time in putting that theory to good use as we will use it to code the next project, a Pong game. We will get to look behind the scenes at how we can create new types that we can use as objects by coding a class. First, we will look at a simplified Pong scenario so that we can learn about some class basics, and then we will start again and code a Pong game for real using the principles we have learned.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Learn about OOP and classes using a hypothetical <code>Bat</code> class</li>
				<li>Start working on the Pong game and code a real class to represent the player's bat</li>
			</ul>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor155"/>OOP</h1>
			<p>Object-oriented programming is a programming paradigm that we could consider to be almost the standard way to code. It is true there are non-OOP ways to code and there are even some non-OOP game coding languages/libraries. However, since we are starting from scratch, there is no reason to do things in any other way.</p>
			<p>OOP will do the following:</p>
			<ul>
				<li>Make our code easier to manage, change, or update</li>
				<li>Make our code quicker and more reliable to write</li>
				<li>Make it possible to easily use other people's code (like we have with SFML)</li>
			</ul>
			<p>We have already seen the third benefit in action. Let's discuss exactly what OOP is.</p>
			<p>OOP is a way of programming that involves breaking our requirements down into chunks that are more manageable than the whole. Each chunk is self-contained yet potentially reusable by other programs, while working together as a whole with the other chunks. These chunks are what we have been referring to as objects. </p>
			<p>When we plan and code an object, we do so with a <strong class="bold">class</strong>. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">A class can be thought of as the blueprint of an object.</p>
			<p>We implement an object <em class="italic">of</em> a class. This is called an <strong class="bold">instance</strong> of a class. Think about a house blueprint. You can't live in it, but you can build a house from it. You build an instance of the house. Often, when we design classes for our games, we write them to represent real-world <em class="italic">things</em>. In the next project, we will write classes for a bat that the player controls and a ball that the player can bounce around the screen with the bat. However, OOP is more than this. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">OOP is a <em class="italic">way</em> of doing things, a methodology that defines best practices.</p>
			<p>The three core principles of OOP are <strong class="bold">encapsulation</strong>, <strong class="bold">polymorphism</strong>, and <strong class="bold">inheritance</strong>. This might sound complex but, taken a step at a time, this is reasonably straightforward.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor156"/>Encapsulation</h2>
			<p><strong class="bold">Encapsulation</strong> means keeping the internal workings of your code safe from interference from the code that uses it. You can achieve this by allowing only the variables and functions you choose to be accessed. This means your code can always be updated, extended, or improved without affecting the programs that use it, provided the exposed parts are still accessed in the same way.</p>
			<p>As an example, with proper encapsulation, it wouldn't matter whether the SFML team needed to update the way their <code>Sprite</code> class works. If the function signatures remain the same, they don't have to worry about what goes on inside. The code that we wrote before the update will still work after the update. </p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor157"/>Polymorphism</h2>
			<p><strong class="bold">Polymorphism</strong> allows us to write code that is less dependent on the <em class="italic">types</em> we are trying to manipulate. This will make our code clearer and more efficient. Polymorphism means <em class="italic">different forms</em>. If the objects that we code can be more than one type of thing, then we can take advantage of this. Polymorphism might sound a little bit like black magic at this point. We will use polymorphism in the fourth project, which we will start in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>,<em class="italic"> Abstraction and Code Management – Making Better Use of OOP</em>. Everything will become clearer.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor158"/>Inheritance</h2>
			<p>Just like it sounds, <strong class="bold">inheritance</strong> means we can harness all the features and benefits of other peoples' classes, including encapsulation and polymorphism, while further refining their code specifically to our situation. We will use inheritance for the first time at the same time as we use polymorphism.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor159"/>Why use OOP?</h2>
			<p>When written properly, OOP allows you to add new features without worrying about how they interact with existing features. When you do have to change a class, its self-contained (encapsulated) nature means less or perhaps even zero consequences for other parts of the program. </p>
			<p>You can use other people's code (like the SFML classes) without knowing or perhaps even caring for how it works inside.</p>
			<p>OOP and, by extension, SFML, allows you to write games that use complicated concepts such as multiple cameras, multiplayer, OpenGL, directional sound, and more besides—all of this without breaking a sweat.</p>
			<p>You can create multiple, similar, yet different versions of a class without starting the class from scratch by using inheritance.</p>
			<p>You can still use the functions intended for the original type of object with your new object because of polymorphism.</p>
			<p>All this makes sense really. And as we know, C++ was designed from the start with all this OOP in mind.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The ultimate key to success with OOP and making games (or any other type of app), other than the determination to succeed, is planning and design. It is not so much just "knowing" all the C++, SFML, and OOP topics that will help you to write great code, but rather applying all that knowledge to write code that is well-structured/designed. The code in this book is presented in an order and manner that's appropriate for learning about the various C++ topics in a gaming context. The art and science of structuring your code is called <strong class="bold">design patterns</strong>. As your code gets longer and more complex, effective use of design patterns will become more important. The good news is that we don't need to invent these design patterns ourselves. We will need to learn about them as our projects get more complex. As our projects become more complex, our design patterns will evolve too.</p>
			<p>In this project, we will learn about and use basic classes and encapsulation. As this book progresses, we will get a bit more daring and use inheritance, polymorphism, and other OOP-related C++ features too.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor160"/>What exactly is a class?</h2>
			<p>A class is a bunch of code that can contains functions, variables, loops, and all the other C++ syntax we have already learned about. Each new class will be declared in its own <code>.h</code> code file with the same name as the class, while its functions will be defined in their own <code>.cpp</code> file.</p>
			<p>Once we have written a class, we can use it to make as many objects from it as we want. Remember, the class is the blueprint, and we make objects based on the blueprint. The house isn't the blueprint, just like the object isn't the class. It is an object made <em class="italic">from</em> the class.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You can think of an object as a variable and the class as a type.</p>
			<p>Of course, with all this talk of OOP and classes, we haven't actually seen any code. Let's fix that now.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor161"/>The theory of a Pong Bat</h1>
			<p>What follows is a hypothetical discussion of how we might use OOP to get started with the Pong project by coding a Bat class. Don't add any code to the project just yet as what follows is over-simplified in order to explain the theory. Later in this chapter, we will code it for real. When we get to coding the class for real, it will actually be quite different, but the principles we will learn about here will prepare us for success.</p>
			<p>We will begin by exploring variables and functions as part of a class.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor162"/>The class variable and function declarations</h2>
			<p>A bat that bounces a ball would be an excellent first candidate for a class.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you don't know what Pong is, then take a look at this link: <a href="https://en.wikipedia.org/wiki/Pong">https://en.wikipedia.org/wiki/Pong</a>.</p>
			<p>Let's take a look at a hypothetical <code>Bat.h</code> file:</p>
			<pre>class Bat
{
    private:
        // Length of the pong bat
        int m_Length = 100;
        // Height of the pong bat
        int m_Height = 10;
        // Location on x axis
        int m_XPosition;      
        // Location on y axis
        int m_YPosition;      
    public:
        void moveRight();
        void moveLeft();
};</pre>
			<p>At first glance, the code might appear a little complex, but when it has been explained, we will see there are very few concepts we haven't already covered.</p>
			<p>The first thing to notice is that a new class is declared using the <code>class</code> keyword, followed by the name of the class and that the entire declaration is enclosed in curly braces, followed by a closing semicolon:</p>
			<pre>class Bat
{
    …
    …
};</pre>
			<p>Now, let's take a look at the variable declarations and their names: </p>
			<pre>// Length of the pong bat
int m_Length = 100; 
// Height of the pong bat
int m_Height = 10;
// Location on x axis
int m_XPosition;      
// Location on y axis
int m_YPosition;</pre>
			<p>All the names are prefixed with <code>m_</code>. This <code>m_</code> prefix is not compulsory, but it is a good convention. Variables that are declared as part of the class are called <code>m_</code> makes it plain when we are dealing with a member variable. When we write functions for our classes, we will start to see local (non-member) variables and parameters as well. The <code>m_</code> convention will then prove itself useful.</p>
			<p>Also, notice that all the variables are in a section of the code headed with the <code>private:</code> keyword. Scan your eyes over the previous code and note that the body of the class code is separated into two sections:</p>
			<pre>private:
    // more code here
public:
    // More code here</pre>
			<p>The <code>public</code> and <code>private</code> keywords control the encapsulation of our class. Anything that is private cannot be accessed directly by the user of an instance/object of the class. If you are designing a class for others to use, you don't want them to be able to alter anything at will. Note that member variables do not have to be private, but good encapsulation is achieved by making them private whenever possible.</p>
			<p>This means that our four member variables (<code>m_Length</code>, <code>m_Height</code>, <code>m_XPosition</code>, and <code>m_YPosition</code>) cannot be accessed directly by our game engine from the <code>main</code> function. They can only be accessed indirectly by the code of the class. This is encapsulation in action. For the <code>m_Length</code> and <code>m_Height</code> variables, this is fairly easy to accept as long as we don't need to change the size of the bat. The <code>m_XPosition</code> and <code>m_YPosition</code> member variables, however, need to be accessed, or how on earth will we move the bat?</p>
			<p>This problem is solved in the <code>public:</code> section of the code, as follows:</p>
			<pre>void moveRight();
void moveLeft();</pre>
			<p>The class provides two functions that are public and will be usable with an object of the <code>Bat</code> type. When we look at the definitions of these functions, we will see how exactly these functions manipulate the private variables. </p>
			<p>In summary, we have a bunch of inaccessible (private) variables that cannot be used from the <code>main</code> function. This is good because encapsulation makes our code less error-prone and more maintainable. We then solve the problem of moving the bat by providing indirect access to the <code>m_XPosition</code> and <code>m_YPosition</code> variables by providing two public functions.</p>
			<p>The code in the <code>main</code> function can call these functions using an instance of the class, but the code inside the functions control exactly how the variables are used.</p>
			<p>Let's take a look at the function definitions.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor163"/>The class function definitions</h2>
			<p>The function definitions we will write in this book will all go in a separate file to the class and function declarations. We will use files with the same name as the class and the <code>.cpp</code> file extension. So, for example, the following code would go in a file called <code>Bat.cpp</code>. Look at the following code, which has just one new concept:</p>
			<pre>#include "Bat.h"
void Bat::moveRight()
{
    // Move the bat a pixel to the right
    xPosition ++;
}
void Bat::moveLeft()
{
    // Move the bat a pixel to the left
    xPosition --;
}</pre>
			<p>The first thing to note is that we must use an include directive to include the class and function declarations from the <code>Bat.h</code> file.</p>
			<p>The new concept we can see here is the use of the <code>::</code>. Since the functions belong to a class, we must write the signature part by prefixing the function name with the class name, as well as <code>::</code>. <code>void Bat::moveLeft()</code> and <code>void Bat::moveRight</code>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Actually, we have briefly seen the scope resolution operator before, that is, whenever we declare an object of a class, and we have not previously used <code>using namespace..</code>.</p>
			<p>Note that we could have put the function definitions and declarations in one file, like this:</p>
			<pre>class Bat
{
    private:
        // Length of the pong bat
        int m_Length = 100; 
        // Length of the pong bat
        int m_Height = 10;
        // Location on x axis
        int m_XPosition;      
        // Location on y axis
        int m_YPosition;      
    public:
        void Bat::moveRight()
        {
            // Move the bat a pixel to the right
            xPosition ++;
        }
        void Bat::moveLeft()
        {
            // Move the bat a pixel to the left
            xPosition --;
        }
};</pre>
			<p>However, when our classes get longer (as they will with our first Zombie Arena class), it is more organized to separate the function definitions into their own file. Furthermore, header files are considered "public", and are often used for documentation purposes if other people will be using the code that we write.</p>
			<p>But how do we use a class once we have coded it?</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor164"/>Using an instance of a class</h2>
			<p>Despite all the code we have seen related to classes, we haven't actually used the class. We already know how to do this as we have used the SFML classes many times already.</p>
			<p>First, we would create an instance of the <code>Bat</code> class, like this:</p>
			<pre>Bat bat;</pre>
			<p>The <code>bat</code> object has all the variables we declared in <code>Bat.h</code>. We just can't access them directly. We can, however, move our bat using its public functions, like this:</p>
			<pre>bat.moveLeft();</pre>
			<p>Or we can move it like this:</p>
			<pre>bat.moveRight();</pre>
			<p>Remember that <code>bat</code> <em class="italic">is a</em> <code>Bat</code>, and as such it has all the member variables and has all of the functions available to it.</p>
			<p>Later, we may decide to make our Pong game multiplayer. In the <code>main</code> function, we could change the code so that the game has two bats, perhaps like this:</p>
			<pre>Bat bat;
<strong class="bold">Bat bat2;</strong></pre>
			<p>It is vitally important to realize that each of these instances of <code>Bat</code> are separate objects with their very own set of variables. There are more ways to initialize an instance of a class, and we will see an example of this when we code the <code>Bat</code> class for real, next.</p>
			<p>Now, we can start the project for real.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor165"/>Creating the Pong project</h1>
			<p>Since setting up a project is a fiddly process, we will go through it a step by step, like we did for the Timber!!! project. I won't show you the same screenshots that I did for the Timber!!! project, but the process is the same, so flip back to <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em> if you want a reminder of the locations of the various project properties:</p>
			<ol>
				<li>Start Visual Studio and click on the <strong class="bold">Create New Project</strong> button. Or, if you still have the Timber!!! project open, you can select <strong class="bold">File</strong> | <strong class="bold">New project</strong>.</li>
				<li>In the window shown next, choose <strong class="bold">Console app</strong> and click the <strong class="bold">Next</strong> button. You will then see the <strong class="bold">Configure your new project</strong> window. </li>
				<li>In the <code>Pong</code> in the <strong class="bold">Project</strong> <strong class="bold">name</strong> field. Note that this causes Visual Studio to automatically configure the <strong class="bold">Solution name</strong> field so that it has the same name.</li>
				<li>In the <code>VS Projects</code> folder that we created in Chapter 1. Like the Timber!!! project, this will be the location that all our project files will be kept. </li>
				<li>Check the option to <strong class="bold">Place solution and project in the same directory</strong>.</li>
				<li>When you have completed these steps, click <code>main.cpp</code> file, like it was previously. </li>
				<li>We will now configure the project to use the SFML files that we put in the <code>SFML</code> folder. From the main menu, select <strong class="bold">Project</strong> | <strong class="bold">Pong properties…</strong>. At this stage, you should have the <strong class="bold">Pong Property Pages</strong> window open. </li>
				<li>In the <strong class="bold">Pong Property Pages</strong> window, select <strong class="bold">All Configurations</strong> from the <strong class="bold">Configuration:</strong> drop-down.</li>
				<li>Now, select <strong class="bold">C/C++</strong> and then <strong class="bold">General</strong> from the left-hand menu.</li>
				<li>After, locate the <code>\SFML\include</code>. The full path to type, if you located your <code>SFML</code> folder on your D drive, is <code>D:\SFML\include</code>. Change your path if you installed SFML on a different drive.</li>
				<li>Click <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Now, still in the same window, perform these steps. From the left-hand menu, select <strong class="bold">Linker</strong> and then <strong class="bold">General</strong>.</li>
				<li>Now, find the <code>SFML</code> folder is, followed by <code>\SFML\lib</code>. So, the full path to type if you located your <code>SFML</code> folder on your D drive is <code>D:\SFML\lib</code>. Change your path if you installed SFML on a different drive.</li>
				<li>Click <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Next, still in the same window, perform these steps. Switch the <strong class="bold">Configuration:</strong> drop-down to <strong class="bold">Debug </strong>as we will be running and testing Pong in debug mode.</li>
				<li>Select <strong class="bold">Linker</strong> and then <strong class="bold">Input</strong>.</li>
				<li>Find the <code>sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;</code>. Be extra careful to place the cursor exactly at the start of the edit box's current content so that you don't overwrite any of the text that is already there.</li>
				<li>Click <strong class="bold">OK</strong>.</li>
				<li> Click <strong class="bold">Apply</strong> and then <strong class="bold">OK</strong>.</li>
				<li>Now, we need to copy the SFML <code>.dll</code> files into the main project directory. My main project directory is <code>D:\VS Projects\Pong</code>. It was created by Visual Studio in the previous steps. If you put your <code>VS Projects</code> folder somewhere else, then perform this step there instead. The files we need to copy into the project folder are located in our <code>SFML\bin</code> folder. Open a window for each of the two locations and highlight all the files in the <code>SFML\bin</code> folder.</li>
				<li>Now, copy and paste the highlighted files into the project folder, that is, <code>D:\VS Projects\Pong</code>.</li>
			</ol>
			<p>We now have the project properties configured and ready to go.</p>
			<p>We will be displaying some text for a HUD (Heads Up Display) in this game that will show the player's score and remaining lives. For this, we need a font.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Download this free-for-personal-use font from <a href="http://www.dafont.com/theme.php?cat=302">http://www.dafont.com/theme.php?cat=302</a> and unzip the download. Or feel free to use a font of your choice. You will just need to make some minor changes to the code when we load the font.</p>
			<p>Create a new folder called <code>fonts</code> in the <code>VS Projects\Pong</code> folder and add the <code>DS-DIGIT.ttf</code> file into the <code>VS Projects\Pong\fonts</code> folder.</p>
			<p>We are now ready to code our first C++ class.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor166"/>Coding the Bat class</h1>
			<p>The simple Pong bat example was a good way of introducing the basics of classes. Classes can be simple and short, like the preceding <code>Bat</code> class, but they can also be longer and more complicated and contain other objects made from other classes.</p>
			<p>When it comes to making games, there is a few vital things missing from the hypothetical <code>Bat</code> class. It might be fine for all these private member variables and public functions, but how will we draw anything? Our Pong bat needs a sprite, and in some games, they will also need a texture. Furthermore, we need a way to control the rate of animation of all our game objects, just like we did with the bee and the clouds in the previous project. We can include other objects in our class in exactly the same way that we included them in the <code>main.cpp</code> file. Let's code our <code>Bat</code> class for real so that we can see how we can solve all these issues.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor167"/>Coding Bat.h</h2>
			<p>To get started, we will code the header file. Right-click on <code>Bat.h</code>. Click the <strong class="bold">Add</strong> button. We are now ready to code the file.</p>
			<p>Add the following code to <code>Bat.h</code>:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
class Bat
{
private:
    Vector2f m_Position;
    // A RectangleShape object
    RectangleShape m_Shape;
    float m_Speed = 1000.0f;
    bool m_MovingRight = false;
    bool m_MovingLeft = false;
public:
    Bat(float startX, float startY);
    FloatRect getPosition();
    RectangleShape getShape();
    void moveLeft();
    void moveRight();
    void stopLeft();
    void stopRight();
    void update(Time dt);
};</pre>
			<p>First, note the <code>#pragma once</code> declaration at the top of the file. This prevents the file from being processed by the compiler more than once. As our games get more complicated with perhaps dozens of classes, this will speed up compilation time.</p>
			<p>Note the names of the member variables and the parameters and return types of the functions. We have a <code>Vector2f</code> called <code>m_Position</code>, which will hold the horizontal and vertical position of the player's bat. We also have an SFML <code>RectangleShape</code>, which will be the actual bat that appears on the screen.</p>
			<p>There are two Boolean members that will track which direction, if any, the bat is currently moving in, and we have a <code>float</code> called <code>m_Speed</code> that tells us the number of pixels per second that the bat can move at when the player decides to move it left or right.</p>
			<p>The next part of the code needs some explanation since we have a function called <code>Bat</code>; this is the exact same name as the class. This is called a constructor.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor168"/>Constructor functions</h2>
			<p>When a class is coded, a special function is created by the compiler. We don't see this function in our code, but it is there. It is called a constructor. It is the function that would have been called if we used our hypothetical <code>Bat</code> class example.</p>
			<p>When we need to write some code to prepare an object for use, often a good place to do this is in the constructor. When we want the constructor to do anything other than simply create an instance, we must replace the default (unseen) constructor provided by the compiler. This is what we will do with the <code>Bat</code> constructor function.</p>
			<p>Notice that the <code>Bat</code> constructor takes two <code>float</code> parameters. This is perfect for initializing the position on the screen when we first create a <code>Bat</code> object. Also note that constructors have no return type, not even <code>void</code>. </p>
			<p>We will soon use the constructor function, <code>Bat</code>, to put this game object into its starting position. Remember that this function is called at the time that an object of the <code>Bat</code> type is declared.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor169"/>Continuing with the Bat.h explanation</h2>
			<p>Next is the <code>getPosition</code> function, which returns a <code>FloatRect</code>, the four points that define a rectangle. Then, we have <code>getShape</code>, which returns a <code>RectangleShape</code>. This will be used so that we can return to the main game loop,  <code>m_Shape</code>, so that it can be drawn.</p>
			<p>We also have the <code>moveLeft</code>, <code>moveRight</code>, <code>stopLeft</code>, and <code>stopRight</code> functions, which are for controlling if, when, and in which direction the bat will be in motion.</p>
			<p>Finally, we have the <code>update</code> function, which takes a <code>Time</code> parameter. This function will be used to calculate how to move the bat each frame. As a bat and a ball will both move quite differently to each other, it makes sense to encapsulate the movement code inside the class. We will call the <code>update</code> function once each frame of the game from the <code>main</code> function.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You can probably guess that the <code>Ball</code> class will also have an <code>update</code> function.</p>
			<p>Now, we can code <code>Bat.cpp</code>, which will implement all the definitions and use the member variables.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor170"/>Coding Bat.cpp</h2>
			<p>Let's create the file, and then we can start discussing the code. Right-click the <code>Bat.cpp</code> in the <strong class="bold">Name:</strong> field. Click the <strong class="bold">Add</strong> button and our new file will be created for us.</p>
			<p>We will divide the code for this file into two parts to make discussing it simpler. </p>
			<p>First, code the <code>Bat</code> constructor function, as follows:</p>
			<pre>#include "Bat.h"
 
// This the constructor and it is called when we create an object
Bat::Bat(float startX, float startY)
{
    m_Position.x = startX;
    m_Position.y = startY;
 
    m_Shape.setSize(sf::Vector2f(50, 5));
    m_Shape.setPosition(m_Position);
}</pre>
			<p>In the preceding code, we can see that we include the <code>bat.h</code> file. This makes all the functions and variables that were declared previously in <code>bat.h</code> available to us.</p>
			<p>We implement the constructor because we need to do some work to get the instance set up, and the default unseen empty constructor provided by the compiler is not sufficient. Remember that the constructor is the code that runs when we initialize an instance of <code>Bat</code>.</p>
			<p>Notice that we use the <code>Bat::Bat</code> syntax as the function name to make it clear we are using the <code>Bat</code> function from the <code>Bat</code> class.</p>
			<p>This constructor receives two <code>float</code> values, <code>startX</code> and <code>startY</code>. The next thing that happens is we assign these values to <code>m_Position.x</code> and <code>m_Position.y</code>. The <code>Vector2f</code> named <code>m_Position</code> now holds the values that were passed in, and because <code>m_Position</code> is a member variable, these values are accessible throughout the class. Note, however, that <code>m_Position</code> was declared as <code>private</code> and will not accessible in our <code>main</code> function file—not directly, anyway. We will see how we can resolve this issue soon.</p>
			<p>Finally, in the constructor, we initialize the <code>RectangleShape</code> called <code>m_Shape</code> by setting its size and position. This is different to how we coded the hypothetical <code>Bat</code> class in the <em class="italic">The theory of a Pong Bat</em> section. The SFML <code>Sprite</code> class has convenient variables for size and position that we can access using the <code>setSize</code> and <code>setPosition</code> functions, so we don't need the hypothetical <code>m_Length</code> and <code>m_Height</code> anymore.</p>
			<p>Furthermore, note that we will need to vary how we initialize the <code>Bat</code> class (compared to the hypothetical <code>Bat</code> class) to suit our custom constructor.</p>
			<p>We need to implement the remaining five functions of the <code>Bat</code> class. Add the following code to <code>Bat.cpp</code> after the constructor we just discussed:</p>
			<pre>FloatRect Bat::getPosition()
{
    return m_Shape.getGlobalBounds();
}
RectangleShape Bat::getShape()
{
    return m_Shape;
}
void Bat::moveLeft()
{
     m_MovingLeft = true;
}
void Bat::moveRight()
{
    m_MovingRight = true;
}
void Bat::stopLeft()
{
    m_MovingLeft = false;
}
void Bat::stopRight()
{
    m_MovingRight = false;
}
void Bat::update(Time dt)
{
    if (m_MovingLeft) {
        m_Position.x -= m_Speed * dt.asSeconds();
    }
    if (m_MovingRight) {
        m_Position.x += m_Speed * dt.asSeconds();
    }
    m_Shape.setPosition(m_Position);
}</pre>
			<p>Let's go through the code we have just added.</p>
			<p>First, we have the <code>getPosition</code> function. All it does is return a <code>FloatRect</code> to the code that called it. The <code>m_Shape.getGlobalBounds</code> line of code returns a <code>FloatRect</code> that is initialized with the coordinates of the four corners of the <code>RectangleShape</code>, that is, <code>m_Shape</code>. We will call this function from the <code>main</code> function when we are determining whether the ball has hit the bat.</p>
			<p>Next, we have the <code>getShape</code> function. All this function does is pass a copy of <code>m_Shape</code> to the calling code. This is necessary so that we can draw the bat in the <code>main</code> function. When we code a public function with the sole purpose of passing back private data from a class, we call it a getter function.</p>
			<p>Now, we can look at the <code>moveLeft</code>, <code>moveRight</code>, <code>stopLeft</code>, and <code>stopRight</code> functions. All they do is set the <code>m_MovingLeft</code> and <code>m_MovingRight</code> Boolean variables appropriately so that they keep track of the player's current intentions. Note, however, that they don't do anything to the <code>RectangleShape</code> instance or the <code>FloatRect</code> instance that determine the position. This is just what we need.</p>
			<p>The last function in the <code>Bat</code> class is <code>update</code>. We will call this function once per frame of the game. The <code>update</code> function will grow in complexity as our game projects get more complicated. For now, all we need to do is tweak <code>m_Position</code>, depending on whether the player is moving left or right. Note that the formula that's used to do this tweak is the same one that we used for updating the bee and the clouds in the Timber!!! project. The code multiplies the speed by the delta time and then adds or subtracts it from the position. This causes the bat to move relative to how long the frame took to update. Next, the code sets the position of <code>m_Shape</code> with whatever the latest values held in <code>m_Position</code> happen to be. </p>
			<p>Having an <code>update</code> function in our <code>Bat</code> class rather than the <code>main</code> function is encapsulation. Rather than updating the positions of all the game objects in the <code>main</code> function like we did in the Timber!!! project, each object will be responsible for updating themselves. As we will do next, however, we will call this <code>update</code> function from the <code>main</code> function.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor171"/>Using the Bat class and coding the main function</h1>
			<p>Switch to the <code>main.cpp</code> file that was automatically generated when we created the project. Delete all its auto-generated code and add the code that follows.</p>
			<p>Code the <code>Pong.cpp</code> file as follows:</p>
			<pre>#include "Bat.h"
#include &lt;sstream&gt;
#include &lt;cstdlib&gt;
#include &lt;SFML/Graphics.hpp&gt;
int main()
{
    // Create a video mode object
    VideoMode vm(1920, 1080);
    // Create and open a window for the game
    RenderWindow window(vm, "Pong", Style::Fullscreen);
    int score = 0;
    int lives = 3;
    
    // Create a bat at the bottom center of the screen
    Bat bat(1920 / 2, 1080 - 20);
    // We will add a ball in the next chapter
    // Create a Text object called HUD
    Text hud;
    // A cool retro-style font
    Font font;
    font.loadFromFile("fonts/DS-DIGI.ttf");
    // Set the font to our retro-style
    hud.setFont(font);
    // Make it nice and big
    hud.setCharacterSize(75);
    // Choose a color
    hud.setFillColor(Color::White);
    hud.setPosition(20, 20);
    // Here is our clock for timing everything
    Clock clock;
    while (window.isOpen())
    {
        /*
        Handle the player input
        ****************************
        ****************************
        ****************************
        */
        /*
        Update the bat, the ball and the HUD
        *****************************
        *****************************
        *****************************
        */
        
        
        /*
        Draw the bat, the ball and the HUD
        *****************************
        *****************************
        *****************************
        */
        
    }
    return 0;
}</pre>
			<p>In the preceding code, the structure is similar to the one we used in the Timber!!! project. The first exception, however, is when we create an instance of the <code>Bat</code> class:</p>
			<pre>// Create a bat
Bat bat(1920 / 2, 1080 - 20);</pre>
			<p>The preceding code calls the constructor function to create a new instance of the <code>Bat</code> class. The code passes in the required arguments and allows the <code>Bat</code> class to initialize its position in the center of the screen near the bottom. This is the perfect position for our bat to start.</p>
			<p>Also note that I have used comments to indicate where the rest of the code will eventually be placed. It is all within the game loop, just like it was in the Timber!!! project. Here is where the rest of the code will go again, just to remind you:</p>
			<pre>      /*
        Handle the player input
        …
        /*
        Update the bat, the ball and the HUD
        …
        
        
        /*
        Draw the bat, the ball and the HUD
        …</pre>
			<p>Next, add the code to the <code>Handle the player input</code> section, as follows:</p>
			<pre>Event event;
while (window.pollEvent(event))
{
    if (event.type == Event::Closed)
        // Quit the game when the window is closed
        window.close();
}
// Handle the player quitting
if (Keyboard::isKeyPressed(Keyboard::Escape))
{
    window.close();
}
// Handle the pressing and releasing of the arrow keys
if (Keyboard::isKeyPressed(Keyboard::Left))
{
    bat.moveLeft();
}
else
{
    bat.stopLeft();
}
if (Keyboard::isKeyPressed(Keyboard::Right))
{
    bat.moveRight();
}
else
{
    bat.stopRight();
}</pre>
			<p>The preceding code handles the player quitting the game by pressing the <em class="italic">Escape</em> key, exactly like it did in the Timber!!! project. Next, there are two <code>if</code> – <code>else</code> structures that handle the player moving the bat. Let's analyze the first of these two structures:</p>
			<pre>if (Keyboard::isKeyPressed(Keyboard::Left))
{
    bat.moveLeft();
}
else
{
    bat.stopLeft();
}</pre>
			<p>The preceding code will detect whether the player is holding down the left arrow cursor key on the keyboard. If they are, then the <code>moveLeft</code> function is called on the <code>Bat</code> instance. When this function is called, the <code>true</code> value is set to the <code>m_MovingLeft</code> private Boolean variable. If, however, the left arrow key is not being held down, then the <code>stopLeft</code> function is called and the <code>m_MovingLeft</code> is set to <code>false</code>.</p>
			<p>The exact same process is then repeated in the next <code>if</code> – <code>else</code> block of code to handle the player pressing (or not pressing) the right arrow key.</p>
			<p>Next, add the following code to the <code>Update the bat the ball and the HUD</code> section, as follows:</p>
			<pre>// Update the delta time
Time dt = clock.restart();
bat.update(dt);
// Update the HUD text
std::stringstream ss;
ss &lt;&lt; "Score:" &lt;&lt; score &lt;&lt; "  Lives:" &lt;&lt; lives;
hud.setString(ss.str());</pre>
			<p>In the preceding code, we use the exact same timing technique that we used for the Timber!!! project, only this time, we call <code>update</code> on the <code>Bat</code> instance and pass in the delta time. Remember that, when the <code>Bat</code> class receives the delta time, it will use the value to move the bat based on the previously received movement instructions from the player and the desired speed of the bat.</p>
			<p>Next, add the following code to the <code>Draw the bat, the ball and the HUD</code> section, as follows:</p>
			<pre>window.clear();
window.draw(hud);
window.draw(bat.getShape());
window.display();</pre>
			<p>In the preceding code, we clear the screen, draw the text for the HUD, and use the <code>bat.getShape</code> function to grab the <code>RectangleShape</code> instance from the <code>Bat</code> instance and draw it to the screen. Finally, we call <code>window.display</code>, just like we did in the previous project, to draw the bat in its current position.</p>
			<p>At this stage, you can run the game and you will see the HUD and a bat. The bat can be moved smoothly left and right using the arrow/cursor keys:</p>
			<div><div><img src="img/Image86209.jpg" alt=""/>
				</div>
			</div>
			<p><a id="_idTextAnchor172"/>Congratulations! That is the first class, all coded and deployed.</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor173"/>Summary</h1>
			<p>In this chapter, we discovered the basics of OOP, such as how to code and use a class, including making use of encapsulation to control how code outside of our classes can access the member variables, but only to the extent and in the manner that we want it to. This is just like SFML classes, which allow us to create and use <code>Sprite</code> and <code>Text</code> instances, but only in the way they were designed to be used.</p>
			<p>Don't concern yourself too much if some of the details around OOP and classes are not entirely clear. The reason I say this is because we will spend the rest of this book coding classes and the more we use them, the clearer they will become.</p>
			<p>Furthermore, we have a working bat and a HUD for our Pong game.</p>
			<p>In the next chapter, we will code the <code>Ball</code> class and get it bouncing around the screen. We will then be able to add collision detection and finish the game.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor174"/>FAQ</h1>
			<p>Q) I have learned other languages and OOP seems much simpler in C++. Is this a correct assessment?</p>
			<p>A) This was an introduction to OOP and its basic fundamentals. There is more to it than this. We will learn about more OOP concepts and details throughout this book.</p>
		</div>
	</body></html>