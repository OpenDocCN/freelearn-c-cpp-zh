<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer109">
			<h1 id="_idParaDest-191" class="chapter-number"><a id="_idTextAnchor335"/>12</h1>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor336"/>Serial Peripheral Interface (SPI)</h1>
			<p>In this chapter, we will learn about the <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) protocol, another <a id="_idIndexMarker835"/>important communication protocol widely used in <span class="No-Break">embedded systems.</span></p>
			<p>We will start by delving into the basics of the SPI protocol, understanding its master-slave architecture, data transfer modes, and typical use cases. Next, we will examine the key registers of the SPI peripheral in STM32 microcontrollers, providing detailed insights into their configuration and usage. Finally, we will apply this knowledge to develop a bare-metal SPI driver, demonstrating practical implementation <span class="No-Break">and testing.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Overview of the <span class="No-Break">SPI protocol</span></li>
				<li>The STM32F4 <span class="No-Break">SPI peripherals</span><a id="_idTextAnchor337"/></li>
				<li>Developing the <span class="No-Break">SPI driver</span></li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of the SPI protocol and be equipped to develop bare-metal drivers <span class="No-Break">for SPI.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor338"/>Technical requirements</h1>
			<p>All code examples for this chapter can be found on GitHub at the <span class="No-Break">following link:</span></p>
			<p><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span><span id="_idTextAnchor339"/></a></p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor340"/>Overview of the SPI protocol</h1>
			<p>Let’s dive <a id="_idIndexMarker836"/>into what SPI is, its key features, how it works, and some of the nuances that make it <span class="No-Break">so powerful.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor341"/>What is SPI?</h2>
			<p>SPI is a <em class="italic">synchronous</em> serial <a id="_idIndexMarker837"/>communication protocol <a id="_idIndexMarker838"/>developed by Motorola. Unlike <strong class="bold">Universal Asynchronous Receiver-Transmitter</strong> (<strong class="bold">UART</strong>), which is asynchronous, SPI <em class="italic">relies on a clock signal</em> to synchronize data transfer between devices. It’s designed for short-distance communication (usually no more than 30 cm), primarily between a microcontroller and peripheral devices such as sensors, SD cards, and display modules. Let’s see its <span class="No-Break">key features.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor342"/>Key features of SPI</h2>
			<p>SPI stands <a id="_idIndexMarker839"/>out due to its efficiency. Here are some of its <span class="No-Break">key features:</span></p>
			<ul>
				<li><strong class="bold">Full-duplex communication</strong>: SPI supports simultaneous data transmission <span class="No-Break">and reception</span></li>
				<li><strong class="bold">High speed</strong>: SPI can <a id="_idIndexMarker840"/>operate at much higher speeds compared to protocols such as <strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>) <span class="No-Break">and UART</span></li>
				<li><strong class="bold">Master-slave architecture</strong>: One master device controls communication, while one or more slave <span class="No-Break">devices respond</span></li>
				<li><strong class="bold">Flexible data length</strong>: Can handle various data lengths, commonly 8 bits, but not limited <span class="No-Break">to that</span></li>
			</ul>
			<p>To be able to connect two SPI devices, we must understand the <span class="No-Break">SPI interface.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor343"/>The SPI interface</h2>
			<p>SPI uses four <a id="_idIndexMarker841"/>primary lines for communication, each <a id="_idIndexMarker842"/>with several alternative names you <span class="No-Break">might encounter:</span></p>
			<ul>
				<li><strong class="bold">Master In Slave Out (MISO)</strong>: Also <a id="_idIndexMarker843"/>known as <strong class="bold">Serial Data Out</strong> (<strong class="bold">SDO</strong>) or <strong class="bold">Data Out</strong> (<strong class="bold">DOUT</strong>), this <a id="_idIndexMarker844"/>line carries <a id="_idIndexMarker845"/>data from the slave device to <span class="No-Break">the master</span></li>
				<li><strong class="bold">Master Out Slave In (MOSI)</strong>: Also <a id="_idIndexMarker846"/>known as <strong class="bold">Serial Data In</strong> (<strong class="bold">SDI</strong>) or <strong class="bold">Data In</strong> (<strong class="bold">DIN</strong>), this <a id="_idIndexMarker847"/>line carries <a id="_idIndexMarker848"/>data from the master device to <span class="No-Break">the slave</span></li>
				<li><strong class="bold">Serial Clock (SCK)</strong>: Also <a id="_idIndexMarker849"/>referred to as <strong class="bold">SCLK</strong> (or simply <strong class="bold">CLK</strong>), this is the clock signal generated by the master to synchronize <span class="No-Break">data transfer</span></li>
				<li><strong class="bold">Slave Select (SS)</strong>: Also <a id="_idIndexMarker850"/>known as <strong class="bold">Chip Select</strong> (<strong class="bold">CS</strong>) or <strong class="bold">Not Slave Select</strong><strong class="bold"> </strong>(<strong class="bold">NSS</strong>), this line <a id="_idIndexMarker851"/>is used by the master <a id="_idIndexMarker852"/>to select which slave device to <span class="No-Break">communicate with</span></li>
			</ul>
			<p>When multiple <a id="_idIndexMarker853"/>slaves are used, each slave typically has its own SS line, allowing the <a id="_idIndexMarker854"/>master to control communication with each slave individually. <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.1</em> illustrates the SPI connection between a single master and<a id="_idTextAnchor344"/><a id="_idTextAnchor345"/> a <span class="No-Break">single slave:</span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B21914_12_1.jpg" alt="Figure 12.1: The SPI interface" width="1206" height="430"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: The SPI interface</p>
			<p><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.2</em> depicts the SPI setup with a single master controlling <span class="No-Break">multiple slaves:</span></p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B21914_12_2.jpg" alt="Figure 12.2: The SPI interface – multiple slaves" width="1215" height="1017"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: The SPI interface – multiple slaves</p>
			<p>When multiple <a id="_idIndexMarker855"/>slaves are connected to a single SPI bus, managing <a id="_idIndexMarker856"/>the MISO line is crucial to avoid communication errors. Since all slaves share this line, non-selected slaves could interfere with the signal from the selected slave if not properly controlled. To prevent such issues, several techniques are used. One <a id="_idIndexMarker857"/>common method is <strong class="bold">tri-state buffering</strong>, where each slave’s MISO line enters a high-impedance (high-Z) state when its CS line is inactive, effectively disconnecting it from the bus. This ensures only the selected slave drives the <a id="_idIndexMarker858"/>MISO line, preventing bus contention. Another approach is the <strong class="bold">open-drain configuration</strong> with a pull-up resistor, where the MISO line is left floating (high-Z) when transmitting a 1 and pulled low by the selected slave when transmitting a 0. This reduces contention risks but may result in slower communication speeds due to the time delay introduced by the <span class="No-Break">pull-up resistor.</span></p>
			<p>Let’s see how the SPI <span class="No-Break">protocol works.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor346"/>How SPI works</h2>
			<p>SPI works <a id="_idIndexMarker859"/>on a simple principle: the master generates a clock signal and selects a slave to communicate with by <em class="italic">pulling the corresponding SS line low</em>. Data is then exchanged simultaneously between the master and the slave over the MOSI and <span class="No-Break">MISO lines.</span></p>
			<p>Here’s a <span class="No-Break">step-by-step breakdown:</span></p>
			<ol>
				<li><strong class="bold">Initialization</strong>: The master sets the clock frequency and data format (for example, <span class="No-Break">8-bit data).</span></li>
				<li><strong class="bold">Slave selection</strong>: The master pulls the SS line of the target slave low. In a multi-slave configuration, where each slave has its own CS line, the master first sets all CS lines high (inactive) before sending any initialization messages. This ensures that uninitialized slaves don’t mistakenly respond to commands not intended for them. Once all CS lines are confirmed high, the master then activates the CS line of the desired slave by pulling it low to begin <span class="No-Break">controlled communication.</span></li>
				<li><strong class="bold">Data transmission</strong>: The master sends data to the slave on the MOSI line, while the slave sends data to the master on the <span class="No-Break">MISO line.</span></li>
				<li><strong class="bold">Clock synchronization</strong>: The master controls the clock, ensuring data is sampled and shifted at the <span class="No-Break">correct times.</span></li>
				<li><strong class="bold">Completion</strong>: Once the data transfer is complete, the master pulls the SS line high, deselecting <span class="No-Break">the slave.</span></li>
			</ol>
			<p>To successfully implement an SPI driver, it’s essential to understand key SPI configuration parameters. Let’s explore them one by one, starting with <strong class="bold">Clock Phase</strong> (<strong class="bold">CPHA</strong>) and <strong class="bold">Clock </strong><span class="No-Break"><strong class="bold">Polarity</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CPOL</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor347"/>CPHA and CPOL</h2>
			<p>In SPI <a id="_idIndexMarker860"/>communication, the settings for CPHA and CPOL determine <a id="_idIndexMarker861"/>the timing and characteristics of the clock signal used to synchronize data transfer between the master and slave devices. These settings are crucial for ensuring that data is correctly sampled and interpreted by both the master and the slave. Here’s a detailed look at how CPHA and CPOL affect <span class="No-Break">SPI communication.</span></p>
			<h3>CPOL</h3>
			<p>CPOL <a id="_idIndexMarker862"/>determines the idle state of the clock signal (SCK). It controls whether the clock signal is high or low when no data is <span class="No-Break">being transferred:</span></p>
			<ul>
				<li><strong class="bold">CPOL = 0</strong>: The clock signal is low (0) when idle. This means that the clock line remains low between <span class="No-Break">data transmissions.</span></li>
				<li><strong class="bold">CPOL = 1</strong>: The clock signal is high (1) when idle. This means that the clock line remains high between <span class="No-Break">data transmissions.</span></li>
			</ul>
			<h3>CPHA</h3>
			<p>CPHA <a id="_idIndexMarker863"/>determines when data is sampled and when it is shifted out. It controls the edge of the clock signal on which data is read <span class="No-Break">and written:</span></p>
			<ul>
				<li><strong class="bold">CPHA = 0</strong>: Data is sampled on the leading edge (first edge) of the clock pulse and shifted out on the trailing edge (<span class="No-Break">second edge)</span></li>
				<li><strong class="bold">CPHA = 1</strong>: Data is shifted out on the leading edge (first edge) of the clock pulse and sampled on the trailing edge (<span class="No-Break">second edge)</span></li>
			</ul>
			<p>The combination of CPOL and CPHA results in four different SPI modes, each affecting the timing of data sampling <span class="No-Break">and shifting.</span></p>
			<p>Selecting the appropriate SPI mode is crucial for ensuring proper communication between the master and slave devices. Both devices must be configured to use the same CPOL and CPHA settings to correctly interpret the data being exchanged. The choice of mode depends on the specific requirements of the devices and the timing constraints of the application. Let’s move on to SPI <span class="No-Break">data modes.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor348"/>Data modes</h2>
			<p>SPI is <a id="_idIndexMarker864"/>flexible with the data length it can handle. While <strong class="bold">8-bit</strong> data transfers are common, SPI can be configured to handle different data lengths, such as <strong class="bold">16-bit</strong> or <strong class="bold">32-bit</strong> transfers, depending on the application. The master and slave devices need to agree on the data length to ensure accurate communication. The last configuration parameter is the <span class="No-Break">SPI speed.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor349"/>SPI speed</h2>
			<p>One of SPI’s significant advantages is its speed. SPI can operate at very high frequencies, typically <a id="_idIndexMarker865"/>up to several tens of <strong class="bold">MHz</strong>, depending on the hardware capabilities of the master and slave devices. The actual speed used in an application depends on <span class="No-Break">several factors:</span></p>
			<ul>
				<li><strong class="bold">Device capabilities</strong>: The maximum speed supported by both the master and <span class="No-Break">the slave</span></li>
				<li><strong class="bold">Signal integrity</strong>: Higher speeds can lead to signal integrity issues such as crosstalk and reflections, especially over <span class="No-Break">longer distances</span></li>
				<li><strong class="bold">Power consumption</strong>: Higher speeds consume more power, which might be a consideration in <span class="No-Break">battery-powered applications</span></li>
			</ul>
			<p>This concludes our overview of the SPI protocol. In the next section, we will analyze the SPI peripheral in the <span class="No-Break">STM32F4 microcontroller.</span></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor350"/>The STM32F4 SPI peripherals</h1>
			<p>As with <a id="_idIndexMarker866"/>other peripherals, STM32 microcontrollers often include several SPI peripherals; the number varies depending on the specific model. The STM32F411 microcontroller has five SPI peripherals, namely <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">SPI1</span></li>
				<li><span class="No-Break">SPI2</span></li>
				<li><span class="No-Break">SPI3</span></li>
				<li><span class="No-Break">SPI4</span></li>
				<li><span class="No-Break">SPI5</span></li>
			</ul>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor351"/>Key features</h2>
			<p>Here are <a id="_idIndexMarker867"/>some of the <span class="No-Break">key features:</span></p>
			<ul>
				<li><strong class="bold">Full-duplex and half-duplex communication</strong>: Supports simultaneous two-way communication (full-duplex) or one-way <span class="No-Break">communication (half-duplex)</span></li>
				<li><strong class="bold">Master/slave configuration</strong>: Each SPI peripheral can be configured as either a master or a <span class="No-Break">slave device</span></li>
				<li><strong class="bold">Flexible data size</strong>: Supports data sizes ranging from 4 to <span class="No-Break">16 bits</span></li>
				<li><strong class="bold">High-speed communication</strong>: Capable of operating at speeds up to 42 MHz in master mode and up to 21 MHz in <span class="No-Break">slave mode</span></li>
				<li><strong class="bold">Direct Memory Access (DMA) support</strong>: DMA support for efficient data transfer without <span class="No-Break">CPU intervention</span></li>
				<li><strong class="bold">Negative SS (NSS) pin management</strong>: Hardware management of the NSS pin for <span class="No-Break">multi-slave configurations</span></li>
				<li><strong class="bold">Cyclic Redundancy Check (CRC) calculation</strong>: Built-in hardware CRC calculation for data <span class="No-Break">integrity verification</span></li>
				<li><strong class="bold">Bidirectional mode</strong>: Supports bidirectional data mode, allowing a single data line to be used for both sending and <span class="No-Break">receiving data</span></li>
			</ul>
			<p>Let’s examine the key registers of <span class="No-Break">this peripheral.</span></p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor352"/>Key SPI registers</h2>
			<p>To get <a id="_idIndexMarker868"/>SPI up and running on the STM32F411 <a id="_idIndexMarker869"/>microcontroller, we need to configure several registers that control various aspects of the SPI peripheral. Let’s break down the main registers we’ll be working with, starting with the <strong class="bold">Control Register </strong><span class="No-Break"><strong class="bold">1</strong></span><span class="No-Break"> register.</span></p>
			<h3>SPI Control Register 1 (SPI_CR1)</h3>
			<p>The <strong class="source-inline">SPI_CR1</strong> register <a id="_idIndexMarker870"/>is central to configuring the SPI <a id="_idIndexMarker871"/>peripheral. It includes settings that define the <strong class="bold">SPI mode</strong>, <strong class="bold">data format</strong>, <strong class="bold">clock settings</strong>, and more. Key bits in this register include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">CPHA</strong>: This bit determines on which clock edge the data is sampled. Setting <strong class="source-inline">CPHA</strong> to <strong class="source-inline">0</strong> means data is sampled on the first edge (leading edge), while setting it to <strong class="source-inline">1</strong> means data is sampled on the second edge (<span class="No-Break">trailing edge).</span></li>
				<li><strong class="bold">CPOL</strong>: This bit sets the idle state of the clock line. Setting <strong class="source-inline">CPOL</strong> to <strong class="source-inline">0</strong> means the clock is low when idle, and setting it to <strong class="source-inline">1</strong> means the clock is high <span class="No-Break">when idle.</span></li>
				<li><strong class="bold">Master Selection (MSTR)</strong>: This bit configures the SPI peripheral as either a master <a id="_idIndexMarker872"/>or a slave. Setting <strong class="source-inline">MSTR</strong> to <strong class="source-inline">1</strong> makes <a id="_idIndexMarker873"/>the SPI peripheral a master, while <strong class="source-inline">0</strong> sets it as <span class="No-Break">a slave.</span></li>
				<li><strong class="bold">Baud Rate Control (BR[2:0])</strong>: These bits configure the baud rate for <span class="No-Break">SPI communication.</span></li>
				<li><strong class="bold">SPI Enable (SPE)</strong>: This bit enables the SPI peripheral. We need to set <strong class="source-inline">SPE</strong> to <strong class="source-inline">1</strong> to activate <span class="No-Break">SPI communication.</span></li>
				<li><strong class="bold">Frame Format (LSBFIRST)</strong>: This <a id="_idIndexMarker874"/>bit determines <a id="_idIndexMarker875"/>the bit order in data transmission. Setting <strong class="source-inline">LSBFIRST</strong> to <strong class="source-inline">0</strong> transmits the <strong class="bold">most significant bit</strong> (<strong class="bold">MSB</strong>) first, while <strong class="source-inline">1</strong> transmits the <strong class="bold">least significant bit</strong> (<span class="No-Break"><strong class="bold">LSB</strong></span><span class="No-Break">) first.</span></li>
				<li><strong class="bold">SS Internal (SSI)</strong>: This bit is used in master mode to internally control the <span class="No-Break">SS line.</span></li>
				<li><strong class="bold">Software Slave Management (SSM)</strong>: Setting this bit to <strong class="source-inline">1</strong> enables software management of the SS line, allowing the master to control <span class="No-Break">it manually.</span></li>
			</ul>
			<p>Next, we have the SPI <span class="No-Break">Status Register.</span></p>
			<h3>SPI Status Register (SPI_SR)</h3>
			<p>The <strong class="source-inline">SPI_SR</strong> register <a id="_idIndexMarker876"/>provides real-time status <a id="_idIndexMarker877"/>updates on the SPI peripheral, informing us about various operational states and flags. Key bits in this register include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Receive Buffer Not Empty (RXNE)</strong>: This flag indicates that the receive buffer contains <span class="No-Break">unread data</span></li>
				<li><strong class="bold">Transmit Buffer Empty (TXE)</strong>: This flag signals that the transmit buffer is empty and ready for <span class="No-Break">new data</span></li>
				<li><strong class="bold">CRC Error Flag (CRCERR)</strong>: This flag is set when a CRC error is detected, indicating <a id="_idIndexMarker878"/>possible <span class="No-Break">data corruption</span></li>
				<li><strong class="bold">Mode Fault (MODF)</strong>: This <a id="_idIndexMarker879"/>flag signals a mode fault, often due to incorrect <span class="No-Break">master/slave configuration</span></li>
				<li><strong class="bold">Overrun Flag (OVR)</strong>: This flag indicates an overrun condition, where the receive buffer wasn’t read <span class="No-Break">in time</span></li>
				<li><strong class="bold">Busy Flag (BSY)</strong>: This flag indicates that the SPI peripheral is currently engaged in a transmission <span class="No-Break">or reception</span></li>
			</ul>
			<p>The last key register is the <span class="No-Break">Data Register.</span></p>
			<h3>SPI Data Register (SPI_DR)</h3>
			<p>The <strong class="source-inline">SPI_DR</strong> register <a id="_idIndexMarker880"/>is the conduit for data <a id="_idIndexMarker881"/>transmission and reception. It’s where we write data to be sent out and read data that’s <span class="No-Break">been received:</span></p>
			<ul>
				<li><strong class="bold">Transmitting data</strong>: When we write to the <strong class="source-inline">SPI_DR</strong> register, data is sent out over the <span class="No-Break"><strong class="source-inline">MOSI</strong></span><span class="No-Break"> line</span></li>
				<li><strong class="bold">Receiving data</strong>: When we read from the <strong class="source-inline">SPI_DR</strong>, you get the data that was received on the <span class="No-Break"><strong class="source-inline">MISO</strong></span><span class="No-Break"> line</span></li>
			</ul>
			<p>With these registers in mind, we’re now ready to develop the SPI driver. Let’s jump into that in<a id="_idTextAnchor353"/> the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor354"/>Developing the SPI driver</h1>
			<p>Create a copy <a id="_idIndexMarker882"/>of your previous project in your IDE and rename this copied project to <strong class="source-inline">SPI</strong>. Next, create a new file named <strong class="source-inline">spi.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">spi.h</strong> in the <strong class="source-inline">Inc</strong> folder. Populate your <strong class="source-inline">spi.c</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="bold">#include "spi.h" </strong>
<strong class="bold">#define</strong> SPI1EN            (1U&lt;&lt;12)
<strong class="bold">#define</strong> GPIOAEN            (1U&lt;&lt;0)
<strong class="bold">#define</strong> SR_TXE            (1U&lt;&lt;1)
<strong class="bold">#define</strong> SR_RXNE            (1U&lt;&lt;0)
<strong class="bold">#define</strong> SR_BSY            (1U&lt;&lt;7)
<strong class="bold">void spi_gpio_init(void)</strong>
{
    /*Enable clock access to GPIOA*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*Set PA5,PA6,PA7 mode to alternate function*/
    /*PA5*/
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;10);
    GPIOA-&gt;MODER |=(1U&lt;&lt;11);
    /*PA6*/
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;12);
    GPIOA-&gt;MODER |=(1U&lt;&lt;13);
    /*PA7*/
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;14);
    GPIOA-&gt;MODER |=(1U&lt;&lt;15);
    /*Set PA9 as output pin*/
    GPIOA-&gt;MODER |=(1U&lt;&lt;18);
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;19);
    /*Set PA5,PA6,PA7 alternate function type to SPI1*/
    /*PA5*/
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;20);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;21);
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;22);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;23);
    /*PA6*/
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;24);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;25);
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;26);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;27);
    /*PA7*/
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;28);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;29);
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;30);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;31);
}</pre>			<p>Next, we have <a id="_idIndexMarker883"/>the function for configuring the <span class="No-Break">SPI parameters:</span></p>
			<pre class="source-code">
<strong class="bold">void spi1_config(void)</strong>
{
    /*Enable clock access to SPI1 module*/
    RCC-&gt;APB2ENR |= SPI1EN;
    /*Set clock to fPCLK/4*/
    SPI1-&gt;CR1 |=(1U&lt;&lt;3);
    SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;4);
    SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;5);
    /*Set CPOL to 1 and CPHA to 1*/
    SPI1-&gt;CR1 |=(1U&lt;&lt;0);
    SPI1-&gt;CR1 |=(1U&lt;&lt;1);
    /*Enable full <strong class="bold">duplex</strong>*/
    SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;10);
    /*Set MSB first*/
    SPI1-&gt;CR1 &amp;= ~(1U&lt;&lt;7);
    /*Set mode to MASTER*/
    SPI1-&gt;CR1 |= (1U&lt;&lt;2);
    /*Set 8 bit data mode*/
    SPI1-&gt;CR1 &amp;= ~(1U&lt;&lt;11);
    /*Select software slave management by
     * setting SSM=1 and SSI=1*/
    SPI1-&gt;CR1 |= (1&lt;&lt;8);
    SPI1-&gt;CR1 |= (1&lt;&lt;9);
    /*Enable SPI module*/
    SPI1-&gt;CR1 |= (1&lt;&lt;6);
}
<strong class="bold">void spi1_transmit</strong>(uint8_t *data,uint32_t size)
{
    uint32_t i=0;
    uint8_t temp;
    <strong class="bold">while</strong>(i&lt;size)
    {
        /*Wait until TXE is set*/
        <strong class="bold">while</strong>(!(SPI1-&gt;SR &amp; (SR_TXE))){}
        /*Write the data to the data register*/
        SPI1-&gt;DR = data[i];
        i++;
    }
    /*Wait until TXE is set*/
    <strong class="bold">while</strong>(!(SPI1-&gt;SR &amp; (SR_TXE))){}
    /*Wait for BUSY flag to reset*/
    <strong class="bold">while</strong>((SPI1-&gt;SR &amp; (SR_BSY))){}
    /*Clear OVR flag*/
    temp = SPI1-&gt;DR;
    temp = SPI1-&gt;SR;
}</pre>			<p>Here is the function for <span class="No-Break">receiving data:</span></p>
			<pre class="source-code">
<strong class="bold">void spi1_receive</strong>(uint8_t *data,uint32_t size)
{
    <strong class="bold">while</strong>(size)
    {
        /*Send dummy data*/
        SPI1-&gt;DR =0;
        /*Wait for RXNE flag to be set*/
        <strong class="bold">while</strong>(!(SPI1-&gt;SR &amp; (SR_RXNE))){}
        /*Read data from data register*/
        *data++ = (SPI1-&gt;DR);
        size--;
    }
}</pre>			<p>Finally, we have the functions for controlling the <span class="No-Break">CS pin:</span></p>
			<pre class="source-code">
<strong class="bold">void cs_enable(void)</strong>
{
    GPIOA-&gt;ODR &amp;=~(1U&lt;&lt;9);
}</pre>			<p>And then, the function for deselecting <span class="No-Break">the slave:</span></p>
			<pre class="source-code">
/*Pull high to disable*/
<strong class="bold">void cs_disable</strong>(<strong class="bold">void</strong>)
{
    GPIOA-&gt;ODR |=(1U&lt;&lt;9);
}</pre>			<p>Let’s walk <a id="_idIndexMarker884"/>through each part of the SPI initialization and communication code. We’ll start by looking at the defined macros and then dive into <span class="No-Break">each function.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor355"/>Defined macros</h2>
			<p>Let’s break <a id="_idIndexMarker885"/>down the meaning of the macros and <span class="No-Break">their functions:</span></p>
			<pre class="source-code">
#define SPI1EN      (1U&lt;&lt;12)
#define GPIOAEN     (1U&lt;&lt;0)
#define SR_TXE      (1U&lt;&lt;1)
#define SR_RXNE     (1U&lt;&lt;0)
#define SR_BSY      (1U&lt;&lt;7)</pre>			<p>Over here, we see <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">SPI1EN</strong>: This is defined as <strong class="source-inline">(1U&lt;&lt;12)</strong>, which sets bit 12. It’s used to enable the clock for the <span class="No-Break">SPI1 peripheral.</span></li>
				<li><strong class="source-inline">GPIOAEN</strong>: This is defined as <strong class="source-inline">(1U&lt;&lt;0)</strong>, which sets bit 0. This enables the clock <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">GPIOA</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">SR_TXE</strong>: This is <a id="_idIndexMarker886"/>defined as <strong class="source-inline">(1U&lt;&lt;1)</strong>. This indicates that the transmit buffer <span class="No-Break">is empty.</span></li>
				<li><strong class="source-inline">SR_RXNE</strong>: This is defined as <strong class="source-inline">(1U&lt;&lt;0)</strong>. This indicates that the receive buffer is <span class="No-Break">not empty.</span></li>
				<li><strong class="source-inline">SR_BSY</strong>: This is defined as <strong class="source-inline">(1U&lt;&lt;7)</strong>. This indicates that the SPI interface is busy with <span class="No-Break">a transfer.</span></li>
			</ul>
			<p>Let’s break down the <span class="No-Break">initialization function.</span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor356"/>GPIO initialization for SPI</h2>
			<p>Let’s analyze the configuration of the SPI1 <span class="No-Break">GPIO pins:</span></p>
			<pre class="source-code">
RCC-&gt;AHB1ENR |= GPIOAEN;</pre>			<p>This line <a id="_idIndexMarker887"/>enables the clock for <strong class="source-inline">GPIOA</strong> by setting the appropriate bit in the <strong class="source-inline">AHB1</strong> peripheral clock <span class="No-Break">enable register:</span></p>
			<pre class="source-code">
/*PA5*/
GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;10);
GPIOA-&gt;MODER |=(1U&lt;&lt;11);
/*PA6*/
GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;12);
GPIOA-&gt;MODER |=(1U&lt;&lt;13);
/*PA7*/
GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;14);
GPIOA-&gt;MODER |=(1U&lt;&lt;15);</pre>			<p>These lines configure <strong class="source-inline">PA5</strong>, <strong class="source-inline">PA6</strong>, and <strong class="source-inline">PA7</strong> pins to alternate function modes, necessary <span class="No-Break">for SPI:</span></p>
			<pre class="source-code">
GPIOA-&gt;MODER |= (1U&lt;&lt;18);
GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;19);</pre>			<p>This <a id="_idIndexMarker888"/>configures <strong class="source-inline">PA9</strong> as a general-purpose output pin, which will be used <span class="No-Break">for SS:</span></p>
			<pre class="source-code">
/*PA5*/
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;20);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;21);
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;22);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;23);
/*PA6*/
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;24);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;25);
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;26);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;27);
/*PA7*/
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;28);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;29);
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;30);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;31);</pre>			<p>These lines set the alternate function registers to configure <strong class="source-inline">PA5</strong>, <strong class="source-inline">PA6</strong>, and <strong class="source-inline">PA7</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">SPI1</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor357"/>SPI1 configuration</h2>
			<p>Next, we have the code for configuring the <span class="No-Break">SPI parameters:</span></p>
			<pre class="source-code">
RCC-&gt;APB2ENR |= SPI1EN;</pre>			<p>This line <a id="_idIndexMarker889"/>enables the clock for <strong class="source-inline">SPI1</strong> by setting the appropriate bit in the <strong class="source-inline">APB2</strong> peripheral clock <span class="No-Break">enable register:</span></p>
			<pre class="source-code">
SPI1-&gt;CR1 |=(1U&lt;&lt;3);
SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;4);
SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;5);</pre>			<p>These lines configure the SPI clock prescaler to set the baud rate by dividing the <strong class="source-inline">APB2</strong> peripheral clock by 4, as SPI1 is connected to the <strong class="source-inline">APB2</strong> bus. The baud rate is determined <a id="_idIndexMarker890"/>by the <strong class="bold">Baud Rate</strong> (<strong class="bold">BR</strong>) bits in the SPI Control Register (SPI1-&gt;CR1). In this case, setting the BR bits (bit 5 to bit 3) to <strong class="source-inline">001</strong> results in the peripheral clock being divided by 4, which dictates the speed at which data is transferred over the <span class="No-Break">SPI bus:</span></p>
			<pre class="source-code">
SPI1-&gt;CR1 |=(1U&lt;&lt;0);
SPI1-&gt;CR1 |=(1U&lt;&lt;1);</pre>			<p>These lines set the clock polarity and phase to ensure correct <span class="No-Break">data sampling:</span></p>
			<pre class="source-code">
SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;10);</pre>			<p>This line ensures that full-duplex mode is enabled for simultaneous transmit <span class="No-Break">and receive:</span></p>
			<pre class="source-code">
SPI1-&gt;CR1 &amp;= ~(1U&lt;&lt;7);</pre>			<p>This line configures SPI to transmit the <span class="No-Break">MSB first:</span></p>
			<pre class="source-code">
SPI1-&gt;CR1 |= (1U&lt;&lt;2);</pre>			<p>This line sets <strong class="source-inline">SPI1</strong> to master mode, making it the controller of the <span class="No-Break">SPI bus:</span></p>
			<pre class="source-code">
SPI1-&gt;CR1 &amp;= ~(1U&lt;&lt;11);</pre>			<p>This line configures the SPI data frame size to <span class="No-Break"><strong class="source-inline">8</strong></span><span class="No-Break"> bits:</span></p>
			<pre class="source-code">
SPI1-&gt;CR1 |= (1&lt;&lt;8);
SPI1-&gt;CR1 |= (1&lt;&lt;9);</pre>			<p>These lines <a id="_idIndexMarker891"/>enable <strong class="bold">software management</strong> of the <span class="No-Break"><strong class="source-inline">SS</strong></span><span class="No-Break"> line.</span></p>
			<pre class="source-code">
SPI1-&gt;CR1 |= (1&lt;&lt;6);</pre>			<p>This line enables the SPI peripheral <span class="No-Break">for operation:</span></p>
			<p>Let’s move on to the <span class="No-Break"><strong class="source-inline">spi1_transmit()</strong></span><span class="No-Break"> function.</span></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor358"/>Transmitting data with SPI</h2>
			<p>This <a id="_idIndexMarker892"/>snippet deals with transmitting <span class="No-Break">the data:</span></p>
			<pre class="source-code">
while (!(SPI1-&gt;SR &amp; (SR_TXE))) {}</pre>			<p>This loop waits until the transmit buffer is empty before sending the <span class="No-Break">next byte:</span></p>
			<pre class="source-code">
SPI1-&gt;DR = data[i];</pre>			<p>This line sends the current byte <span class="No-Break">of data:</span></p>
			<pre class="source-code">
while ((SPI1-&gt;SR &amp; (SR_BSY))) {}</pre>			<p>This ensures the SPI bus is not busy <span class="No-Break">before continuing:</span></p>
			<pre class="source-code">
temp = SPI1-&gt;DR;
temp = SPI1-&gt;SR;</pre>			<p>These two lines play a crucial role in managing the SPI communication process. After the master transmits data through the SPI Data Register, the same register captures the data received from the slave. To ensure incoming data is properly processed, we read the Data Register, even if we don’t need the value. This read operation automatically clears the OVR flag. It’s also advisable to read the Status Register as part of <span class="No-Break">this process.</span></p>
			<p>Next, we have the <span class="No-Break"><strong class="source-inline">spi1_receive()</strong></span><span class="No-Break"> function.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor359"/>SPI data reception</h2>
			<p>This deals with receiving <span class="No-Break">the data:</span></p>
			<pre class="source-code">
SPI1-&gt;DR = 0;</pre>			<p>This line <a id="_idIndexMarker893"/>sends dummy data to generate <span class="No-Break">clock pulses:</span></p>
			<pre class="source-code">
while (!(SPI1-&gt;SR &amp; (SR_RXNE))) {}</pre>			<p>This line waits until data <span class="No-Break">is received:</span></p>
			<pre class="source-code">
*data++ = (SPI1-&gt;DR);</pre>			<p>This line reads the <span class="No-Break">received data:</span></p>
			<p>The last functions are the <strong class="source-inline">cs_enable()</strong> and <span class="No-Break"><strong class="source-inline">cs_disable()</strong></span><span class="No-Break"> functions.</span></p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor360"/>CS management</h2>
			<p>This line <a id="_idIndexMarker894"/>pulls the SS line <a id="_idTextAnchor361"/>low to enable the <span class="No-Break">slave device:</span></p>
			<pre class="source-code">
GPIOA-&gt;ODR &amp;= ~(1U &lt;&lt; 9);</pre>			<p>This line pulls the SS line high to disable the <span class="No-Break">slave device:</span></p>
			<pre class="source-code">
GPIOA-&gt;ODR |= (1U &lt;&lt; 9);</pre>			<p>Our next task is to populate the <span class="No-Break"><strong class="source-inline">spi.h</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor362"/>The header file</h2>
			<p>Here <a id="_idIndexMarker895"/>is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> SPI_H_
<strong class="bold">#define</strong> SPI_H_
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">void spi_gpio_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void spi1_config</strong>(<strong class="bold">void</strong>);
<strong class="bold">void spi1_transmit</strong>(uint8_t *data,uint32_t size);
<strong class="bold">void spi1_receive</strong>(uint8_t *data,uint32_t size);
<strong class="bold">void cs_enable</strong>(<strong class="bold">void</strong>);
<strong class="bold">void cs_disable</strong>(<strong class="bold">void</strong>);
<strong class="bold">#endif</strong></pre>			<p>Over here, we are <a id="_idIndexMarker896"/>simply exposing the functions to make them accessible in <span class="No-Break">other files.</span></p>
			<p>To effectively <a id="_idIndexMarker897"/>test the SPI driver, we need a sui<a id="_idTextAnchor363"/>table slave device. In the next section, we’ll dive into the <strong class="bold">ADXL345 accelerometer</strong>, which we’ll use as our slave device to test the <span class="No-Break">SPI driver.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor364"/>Getting to know the ADXL345 accelerometer</h2>
			<p><strong class="source-inline">ADXL345</strong> is a gem <a id="_idIndexMarker898"/>in the world of digital accelerometers, and it’s perfect for testing our SPI module. Let’s dive into what makes this device so special and ho<a id="_idTextAnchor365"/>w it fits into our embedded <span class="No-Break">system projects.</span></p>
			<h3>What is ADXL345?</h3>
			<p>ADXL345 is <a id="_idIndexMarker899"/>a small, thin, ultralow <a id="_idIndexMarker900"/>power, <strong class="bold">3-axis accelerometer</strong> that can measure <strong class="bold">static acceleration of gravity</strong> in tilt-sensing <a id="_idIndexMarker901"/>applications, as well as <strong class="bold">dynamic acceleration</strong> resulting from motion or shock. It’s versatile, highly accurate, and can handle a variety of tasks with ease. This accelerometer offers high-resolution (up to <strong class="source-inline">13</strong>-bit) measurements with a selectable measurement range of <strong class="bold">±2 g</strong>, <strong class="bold">±4 g</strong>, <strong class="bold">±8 g</strong>, or <strong class="bold">±</strong><span class="No-Break"><strong class="bold">16 g</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B21914_12_3.jpg" alt="Figure 12.3: The ADXL345" width="300" height="387"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: The ADXL345</p>
			<p>Let’s analyze its <span class="No-Break">key features.</span></p>
			<h3>Key features of the ADXL345</h3>
			<p>Following is <a id="_idIndexMarker902"/>a list of the <span class="No-Break">ADXL345’s features:</span></p>
			<ul>
				<li><strong class="bold">Ultralow power</strong>: The device consumes as little as 23 µA in measurement mode and just 0.1 µA in standby mode, making it ideal for <span class="No-Break">battery-powered applications.</span></li>
				<li><strong class="bold">User-selectable resolution</strong>: We can choose a resolution from 10 to 13 bits, providing a scale factor of 4 mg/LSB across all <span class="No-Break">g ranges.</span></li>
				<li><strong class="bold">Flexible interface</strong>: The ADXL345 supports both SPI (3- and 4-wire) and I2C digital interfaces, giving us flexibility in how you integrate it into <span class="No-Break">your system.</span></li>
				<li><strong class="bold">Special sensing functions</strong>: It includes single tap, double tap, and free-fall detection, along with activity/inactivity monitoring. These functions can be individually mapped to two interrupt output pins, making it highly responsive to <span class="No-Break">physical events.</span></li>
				<li><strong class="bold">Wide supply voltage range</strong>: It operates from 2.0 V to 3.6 V, accommodating various <span class="No-Break">power configurations.</span></li>
				<li><strong class="bold">Robust performance</strong>: The ADXL345 can withstand a shock of up to 10,000 g, ensuring durability in <span class="No-Break">rugged applications.</span></li>
			</ul>
			<p>Let’s see some of its <span class="No-Break">common applications.</span></p>
			<h3>Applications</h3>
			<p>Given its <a id="_idIndexMarker903"/>robust feature set, the ADXL345 is well suited for a range <span class="No-Break">of applications:</span></p>
			<ul>
				<li><strong class="bold">Industrial equipment</strong>: For machinery monitoring and <span class="No-Break">fault detection</span></li>
				<li><strong class="bold">Aerospace equipment</strong>: In systems where reliability and precision <span class="No-Break">are paramount</span></li>
				<li><strong class="bold">Consumer electronics</strong>: Examples are smartphones, gaming devices, and <span class="No-Break">wearable technology</span></li>
				<li><strong class="bold">Health and sports</strong>: For tracking motion and activity in health <span class="No-Break">monitoring devices</span></li>
			</ul>
			<p>Let’s take a closer look at its <span class="No-Break">sensing function.</span></p>
			<h3>Sensing function</h3>
			<p>At its core, the ADXL345 measures acceleration along three axes: <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em>. The data is available <a id="_idIndexMarker904"/>in a 16-bit two's complement format and can be accessed via either the SPI or <span class="No-Break">I2C interface.</span></p>
			<p>The following are its <span class="No-Break">sensing functions:</span></p>
			<ul>
				<li><strong class="bold">Activity and inactivity monitoring</strong>: The accelerometer can detect movement or the absence thereof, making it great for sleep monitoring and <span class="No-Break">fitness applications</span></li>
				<li><strong class="bold">Tap detection</strong>: It can recognize single and double taps in any direction, which is useful for <span class="No-Break">gesture-based controls</span></li>
				<li><strong class="bold">Free-fall detection</strong>: The device can detect if it’s in free fall, which can be used in safety systems to trigger an alert or <span class="No-Break">a response</span></li>
			</ul>
			<p><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.4</em> shows the <em class="italic">x</em>, <em class="italic">y</em>, and <span class="No-Break"><em class="italic">z</em></span><span class="No-Break"> axes:</span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B21914_12_4.jpg" alt="Figure 12.4: The x, y, and z axes" width="648" height="608"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4: The x, y, and z axes</p>
			<p>The ADXL345 also offers various low-power modes to help manage power consumption intelligently. These modes allow the device to enter sleep or standby states based on our defined thresholds and <span class="No-Break">activity levels.</span></p>
			<p>It also <a id="_idIndexMarker905"/>includes a 32-level <strong class="bold">FIFO buffer</strong>, which helps in storing data <a id="_idIndexMarker906"/>temporarily to reduce the load on the host processor. This buffer is especially useful in applications requiring high data throughput or when the processor is busy with other tasks. Lastly, its pinout <span class="No-Break">is straightforward:</span></p>
			<ul>
				<li><strong class="bold">VDD I/O</strong>: Digital interface <span class="No-Break">supply voltage</span></li>
				<li><span class="No-Break"><strong class="bold">GND</strong></span><span class="No-Break">: Ground</span></li>
				<li><strong class="bold">CS</strong>: CS for <span class="No-Break">SPI communication</span></li>
				<li><strong class="bold">INT1 and INT2</strong>: Interrupt <span class="No-Break">output pins</span></li>
				<li><strong class="bold">SDA/SDI/SDIO</strong>: Serial data line for I2C or <span class="No-Break">SPI input</span></li>
				<li><strong class="bold">SCL/SCLK</strong>: Serial clock line for I2C <span class="No-Break">or SPI</span></li>
			</ul>
			<p>Before we dive into developing the driver for this slave device, let’s first explore some key concepts of <span class="No-Break">acceleration measurement.</span></p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor366"/>Understanding key concepts – static acceleration of gravity, tilt-sensing, and dynamic acceleration</h2>
			<p>When working with accelerometers such as the ADXL345, it’s important to grasp some fundamental concepts that underpin their operation and applications. Let’s break down what static acceleration of gravity, tilt-sensing, and dynamic <span class="No-Break">acceleration mean.</span></p>
			<h3>Static acceleration of gravity</h3>
			<p><strong class="bold">Static acceleration of gravity</strong> refers to the constant acceleration due to gravity that acts on <a id="_idIndexMarker907"/>an object at rest. This acceleration is always present and has a magnitude of approximately <strong class="bold">9.8 meters per second squared (m/s²)</strong> on the surface of <span class="No-Break">the Earth.</span></p>
			<p>In the context of an accelerometer such as the ADXL345, static acceleration is used to determine the orientation of the device. When the accelerometer is at rest and positioned flat, it measures the static acceleration of gravity along the <em class="italic">z</em> axis, which helps to identify which direction is “down.” This capability is crucial for applications such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Orientation detection</strong>: Determining the device’s orientation relative to the <span class="No-Break">Earth’s surface</span></li>
				<li><strong class="bold">Tilt-sensing</strong>: Measuring the tilt angle of the device by observing how gravity’s force changes across <span class="No-Break">different axes</span></li>
			</ul>
			<p>The next important concept <span class="No-Break">is tilt-sensing.</span></p>
			<h3>Tilt-sensing</h3>
			<p><strong class="bold">Tilt-sensing</strong> is the <a id="_idIndexMarker908"/>process of measuring the angle at which an object is tilted with respect to the force of gravity. This is achieved by analyzing the static acceleration readings from <span class="No-Break">the accelerometer.</span></p>
			<p>Imagine holding a tablet. When you tilt it forward, backward, or sideways, the accelerometer inside detects changes in the static acceleration along its <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> axes. By comparing these changes, the device can calculate the tilt angle. Here’s how <span class="No-Break">it works:</span></p>
			<ul>
				<li><strong class="bold">X-axis tilt</strong>: If the device is tilted along the <em class="italic">x</em> axis, the static acceleration detected on the <em class="italic">x</em> axis will increase or decrease depending on the direction of <span class="No-Break">the tilt.</span></li>
				<li><strong class="bold">Y-axis tilt</strong>: Similarly, tilting along the <em class="italic">y</em> axis will cause variations in the static acceleration readings on the <span class="No-Break"><em class="italic">y</em></span><span class="No-Break"> axis.</span></li>
				<li><strong class="bold">Z-axis stability</strong>: The <em class="italic">z</em> axis usually detects the full force of gravity when the device is lying flat. Changes in tilt cause redistributions of this force among the <em class="italic">x</em> and <span class="No-Break"><em class="italic">y</em></span><span class="No-Break"> axes.</span></li>
			</ul>
			<p>Tilt-sensing is<a id="_idIndexMarker909"/> widely used in applications such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Screen orientation</strong>: Automatically adjusting the display from portrait to <span class="No-Break">landscape mode</span></li>
				<li><strong class="bold">Gaming controllers</strong>: Detecting movements and tilts to <span class="No-Break">enhance gameplay</span></li>
				<li><strong class="bold">Industrial equipment</strong>: Monitoring the tilt of machinery or vehicles for stability <span class="No-Break">and safety</span></li>
			</ul>
			<p>The final key concept is <span class="No-Break">dynamic acceleration.</span></p>
			<h3>Dynamic acceleration</h3>
			<p><strong class="bold">Dynamic acceleration</strong> refers to the acceleration that results from motion or external forces <a id="_idIndexMarker910"/>acting on the device. Unlike static acceleration, which is constant, dynamic acceleration varies based on how the device <span class="No-Break">is moving.</span></p>
			<p>For instance, if you shake or move the accelerometer, it measures these changes as dynamic acceleration. This type of acceleration is crucial for <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Motion detection</strong>: Identifying when the device is moved, which can be used in fitness trackers to <span class="No-Break">count steps</span></li>
				<li><strong class="bold">Shock or impact sensing</strong>: Detecting sudden impacts or vibrations, useful in crash detection systems or <span class="No-Break">drop tests</span></li>
				<li><strong class="bold">Vibration monitoring</strong>: Measuring vibrations in industrial machinery to predict failures or <span class="No-Break">maintenance needs</span></li>
			</ul>
			<p>Before wrapping up this section, let’s clarify one more concept we introduced <span class="No-Break">earlier: “g.”</span></p>
			<p>When dealing with accelerometers such as the ADXL345, you often come across terms such as ±2 g, ±4 g, ±8 g, or ±16 g. These terms are crucial for understanding the measurement capabilities and limits of the device. Let’s break down what g means and how these ranges affect the performance and application of <span class="No-Break">an accelerometer.</span></p>
			<h3>What is g?</h3>
			<p>The term <em class="italic">g</em> refers to <a id="_idIndexMarker911"/>the acceleration due to gravity at the Earth’s surface, which is approximately 9.8 <strong class="bold">meters per second squared</strong> (<strong class="bold">m/s²</strong>). It is used as a unit of measurement for acceleration. When we say an accelerometer can measure ±2 g, it means it can detect accelerations up to twice the force of gravity in either direction along <span class="No-Break">an axis.</span></p>
			<p>With this clarified, we are now ready to develop the driver for the <span class="No-Break">ADXL345 device.</span></p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor367"/>Developing the ADXL345 driver</h2>
			<p>Create a <a id="_idIndexMarker912"/>new file named <strong class="source-inline">adxl345.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">adxl345.h</strong> in the <span class="No-Break"><strong class="source-inline">Inc</strong></span><span class="No-Break"> folder.</span></p>
			<h3>The header file</h3>
			<p>Pop<a id="_idTextAnchor368"/>ulate <a id="_idIndexMarker913"/>the <strong class="source-inline">adxl345.h</strong> file <span class="No-Break">with this:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> ADXL345_H_
<strong class="bold">#define</strong> ADXL345_H_
#include "spi.h"
#include &lt;stdint.h&gt;
#define ADXL345_REG_DEVID                (0x00)
#define ADXL345_REG_DATA_FORMAT          (0x31)
#define ADXL345_REG_POWER_CTL            (0x2D)
#define ADXL345_REG_DATA_START           (0x32)
#define ADXL345_RANGE_4G                 (0x01)
#define ADXL345_RESET                    (0x00)
#define ADXL345_MEASURE_BIT              (0x08)
#define ADXL345_MULTI_BYTE_ENABLE        (0x40)
#define ADXL345_READ_OPERATION           (0x80)
void adxl_init (void);
void adxl_read(uint8_t address, uint8_t * rxdata);
<strong class="bold">#endif</strong></pre>			<p>The <strong class="source-inline">adxl345.h</strong> file begins <a id="_idIndexMarker914"/>by including our SPI driver with <strong class="source-inline">#include "spi.h"</strong> and proceeds to define the necessary macros. Let’s break down <span class="No-Break">the macros:</span></p>
			<ul>
				<li><strong class="source-inline">ADXL345_REG_DEVID (0x00)</strong>: This macro defines the register address for the device ID of <span class="No-Break">the ADXL345</span></li>
				<li><strong class="source-inline">ADXL345_REG_DATA_FORMAT (0x31)</strong>: This macro defines the register address for setting the data format of <span class="No-Break">the ADXL345</span></li>
				<li><strong class="source-inline">ADXL345_REG_POWER_CTL (0x2D)</strong>: This macro defines the register address for the power control settings of <span class="No-Break">the ADXL345</span></li>
				<li><strong class="source-inline">ADXL345_REG_DATA_START (0x32)</strong>: This macro defines the starting register address for reading acceleration data from <span class="No-Break">the ADXL345</span></li>
				<li><strong class="source-inline">ADXL345_RANGE_4G (0x01)</strong>: This macro defines the value to set the measurement range of the ADXL345 <span class="No-Break">to ±4g</span></li>
				<li><strong class="source-inline">ADXL345_RESET (0x00)</strong>: This macro defines the reset value for <span class="No-Break">certain registers</span></li>
				<li><strong class="source-inline">ADXL345_MEASURE_BIT (0x08)</strong>: This macro defines the bit value to enable measurement mode in the power <span class="No-Break">control register</span></li>
				<li><strong class="source-inline">ADXL345_MULTI_BYTE_ENABLE (0x40)</strong>: This macro defines the bit to enable <span class="No-Break">multi-byte operations</span></li>
				<li><strong class="source-inline">ADXL345_READ_OPERATION (0x80)</strong>: This macro defines the bit to specify a <span class="No-Break">read operation</span></li>
			</ul>
			<p>Next, we populate the <span class="No-Break"><strong class="source-inline">adxl345.c</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "adxl345.h"
<strong class="bold">void adxl_read</strong>(uint8_t address, uint8_t * rxdata)
{
      /*Set read operation*/
      address |= ADXL345_READ_OPERATION;
      /*Enable multi-byte*/
      address |= ADXL345_MULTI_BYTE_ENABLE;
      /*Pull <strong class="bold">cs</strong> line low to enable slave*/
      cs_enable();
      /*Send address*/
      spi1_transmit(&amp;address,1);
      /*Read 6 bytes */
      spi1_receive(rxdata,6);
      /*Pull <strong class="bold">cs</strong> line high to disable slave*/
      cs_disable();
}
<strong class="bold">void adxl_write</strong> (uint8_t address, uint8_t value)
{
  uint8_t data[2];
  /*Enable multi-byte, place address into buffer*/
  data[0] = address|ADXL345_MULTI_BYTE_ENABLE;
  /*Place data into buffer*/
  data[1] = value;
  /*Pull <strong class="bold">cs</strong> line low to enable slave*/
  cs_enable();
  /*Transmit data and address*/
  spi1_transmit(data, 2);
  /*Pull <strong class="bold">cs</strong> line high to disable slave*/
  cs_disable();
}
<strong class="bold">void adxl_init</strong> (<strong class="bold">void</strong>)
{
    /*Enable SPI <strong class="bold">gpio</strong>*/
    spi_gpio_init();
    /*<strong class="bold">Config</strong> SPI*/
    spi1_config();
    /*Set data format range to +-4g*/
    adxl_write (ADXL345_REG_DATA_FORMAT, ADXL345_RANGE_4G);
    /*Reset all bits*/
    adxl_write (ADXL345_REG_POWER_CTL, ADXL345_RESET);
    /*Configure power control measure bit*/
    adxl_write (ADXL345_REG_POWER_CTL, ADXL345_MEASURE_BIT);
}</pre>			<p>Let’s analyze <a id="_idIndexMarker915"/>the functions line by line, starting with the <span class="No-Break"><strong class="source-inline">adxl_read()</strong></span><span class="No-Break"> function.</span></p>
			<h3>Function – adxl_read()</h3>
			<p>Let’s <a id="_idIndexMarker916"/>break down the <span class="No-Break">read function:</span></p>
			<ul>
				<li><strong class="source-inline">address |= ADXL345_READ_OPERATION;</strong>: This line sets the MSB of the address to indicate a <span class="No-Break">read operation</span></li>
				<li><strong class="source-inline">address |= ADXL345_MULTI_BYTE_ENABLE;</strong>: This sets the multi-byte bit to enable <span class="No-Break">multi-byte operations</span></li>
				<li><strong class="source-inline">cs_enable();</strong>: This function pulls the CS line low, enabling communication with <span class="No-Break">the ADXL345</span></li>
				<li><strong class="source-inline">spi1_transmit(&amp;address, 1);</strong>: This transmits the address (with read and multi-byte bits set) to <span class="No-Break">the ADXL345</span></li>
				<li><strong class="source-inline">spi1_receive(rxdata, 6);</strong>: This line reads 6 bytes of data from the ADXL345 and stores it in the buffer pointed to <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">rxdata</strong></span></li>
				<li><strong class="source-inline">cs_disable();</strong>: This function <a id="_idIndexMarker917"/>pulls the CS line high, ending communication with <span class="No-Break">the ADXL345</span></li>
			</ul>
			<p>Next, we have the <span class="No-Break"><strong class="source-inline">adxl_write()</strong></span><span class="No-Break"> function.</span></p>
			<h3>Function – adxl_write</h3>
			<p>Let’s go <a id="_idIndexMarker918"/>through each line of <span class="No-Break">this function:</span></p>
			<ul>
				<li><strong class="source-inline">data[0] = address | ADXL345_MULTI_BYTE_ENABLE;</strong>: This sets the multi-byte bit and stores the modified address in <span class="No-Break">the buffer</span></li>
				<li><strong class="source-inline">data[1] = value;</strong>: This stores the data to be written in <span class="No-Break">the buffer</span></li>
				<li><strong class="source-inline">cs_enable();</strong>: This function pulls the CS line low, enabling communication with <span class="No-Break">the ADXL345</span></li>
				<li><strong class="source-inline">spi1_transmit(data, 2);</strong>: This transmits the address and data to the ADXL345 in <span class="No-Break">one transaction</span></li>
				<li><strong class="source-inline">cs_disable();</strong>: This function pulls the CS line high, ending communication with <span class="No-Break">the ADXL345</span></li>
			</ul>
			<p>Finally, we have the <span class="No-Break"><strong class="source-inline">adxl_init()</strong></span><span class="No-Break"> function.</span></p>
			<h3>Function – adxl_init</h3>
			<p>Let’s <a id="_idIndexMarker919"/>analyze the <span class="No-Break">initialization function:</span></p>
			<ul>
				<li><strong class="source-inline">spi_gpio_init();</strong>: This function initializes the GPIO pins needed for <span class="No-Break">SPI communication</span></li>
				<li><strong class="source-inline">spi1_config();</strong>: This function configures the SPI settings (clock speed, <span class="No-Break">mode, etc.)</span></li>
				<li><strong class="source-inline">adxl_write(ADXL345_REG_DATA_FORMAT, ADXL345_RANGE_4G);</strong>: This line writes to the data format register to set the measurement range of the ADXL345 <span class="No-Break">to ±4g</span></li>
				<li><strong class="source-inline">adxl_write(ADXL345_REG_POWER_CTL, ADXL345_RESET);</strong>: This line writes <a id="_idIndexMarker920"/>to the power control register to reset <span class="No-Break">all bits</span></li>
				<li><strong class="source-inline">adxl_write(ADXL345_REG_POWER_CTL, ADXL345_MEASURE_BIT);</strong>: This line write<a id="_idTextAnchor369"/>s to the power control register to set the measure bit, enabling <span class="No-Break">measurement mode</span></li>
			</ul>
			<p>We are now ready to test the driver inside the <strong class="source-inline">main.c</strong> file. Update your <strong class="source-inline">main.c</strong> file as <span class="No-Break">shown next:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">#include</strong> "adxl345.h"
//Variables for storing accelerometer data
int16_t accel_x, accel_y, accel_z;
<strong class="bold">double</strong> accel_x_g, accel_y_g, accel_z_g;
uint8_t data_buffer[6];
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    uart_init();
    // Initialize the ADXL345 accelerometer
    adxl_init();
    <strong class="bold">while</strong> (1)
    {
        // Read accelerometer data starting from the data start 
        // register
        adxl_read(ADXL345_REG_DATA_START, data_buffer);
        // Combine high and low bytes to form the accelerometer data
        accel_x = (int16_t)((data_buffer[1] &lt;&lt; 8) | data_buffer[0]);
        accel_y = (int16_t)((data_buffer[3] &lt;&lt; 8) | data_buffer[2]);
        accel_z = (int16_t)((data_buffer[5] &lt;&lt; 8) | data_buffer[4]);
        // Convert raw data to g values
        accel_x_g = accel_x * 0.0078;
        accel_y_g = accel_y * 0.0078;
        accel_z_g = accel_z * 0.0078;
        //Print values for debugging purposes
        <strong class="bold">printf</strong>("accel_x : %d accel_y : %d  accel_z : %d\n\
        r",accel_x,accel_y,accel_z);
    }
    <strong class="bold">return</strong> 0;
}</pre>			<p>Let’s <a id="_idIndexMarker921"/>break down the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span></p>
			<ul>
				<li><strong class="source-inline">accel_x, accel_y, accel_z</strong>: These are variables to store the raw accelerometer data for <span class="No-Break">each axis.</span></li>
				<li><strong class="source-inline">accel_x_g, accel_y_g, accel_z_g</strong>: These are variables to store the converted accelerometer data in <span class="No-Break">g units.</span></li>
				<li><strong class="source-inline">data_buffer[6]</strong>: This is a buffer to hold the raw data bytes read from <span class="No-Break">the ADXL345.</span></li>
				<li><strong class="source-inline">adxl_init()</strong>: This initializes the <span class="No-Break">ADXL345 accelerometer.</span></li>
				<li><strong class="source-inline">adxl_read(ADXL345_REG_DATA_START, data_buffer);</strong>: This line reads data from the ADXL345 starting at the specified register (<strong class="source-inline">ADXL345_REG_DATA_START</strong>). The data is stored <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">data_buffer</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Finally, we have the lines for constructing the final <span class="No-Break">16-bit values:</span></p>
			<pre class="source-code">
accel_x = (int16_t)((data_buffer[1] &lt;&lt; 8) | data_buffer[0]);
accel_y = (int16_t)((data_buffer[3] &lt;&lt; 8) | data_buffer[2]);
accel_z = (int16_t)((data_buffer[5] &lt;&lt; 8) | data_buffer[4]);</pre>			<p>The data read from the ADXL345 is in 2 bytes (high and low) for each axis. These lines combine the bytes to form 16-bit values for <span class="No-Break">each axis:</span></p>
			<pre class="source-code">
accel_x_g = accel_x * 0.0078;
accel_y_g = accel_y * 0.0078;
accel_z_g = accel_z * 0.0078;</pre>			<p>These lines convert the raw accelerometer values to <span class="No-Break">g values:</span></p>
			<pre class="source-code">
<strong class="bold">printf</strong>("accel_x : %d accel_y : %d  accel_z : %d\n\r",accel_x,accel_y,accel_z);</pre>			<p>This line <a id="_idIndexMarker922"/>outputs the raw accelerometer data for <span class="No-Break">debugging purposes:</span></p>
			<p>Now, let’s test the project. To test the project, compile the code and run it on your microcontroller. Open RealTerm or another serial terminal application and configure it with the appropriate port and baud rate to view the debug messages. Press the black pushbutton on the development board to reset the microcontroller. You should see the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> accelerometer values continuously being printed. Try moving the accelerometer to observe the values <span class="No-Break">change significantly.</span></p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor370"/>Summary</h1>
			<p>In this chapter, we explored the SPI protocol, a widely used communication protocol in embedded systems for efficient data transfer between microcontrollers and peripherals. We began by understanding the basic principles of SPI, including its master-slave architecture, data transfer modes, and typical use cases, emphasizing its advantages such as full-duplex communication and <span class="No-Break">high-speed operation.</span></p>
			<p>Next, we examined the SPI peripheral in STM32F4 microcontrollers, focusing on critical registers such as SPI Control Register 1 (<strong class="source-inline">SPI_CR1</strong>), SPI Status Register (<strong class="source-inline">SPI_SR</strong>), and SPI Data Register (<strong class="source-inline">SPI_DR</strong>). We detailed how to configure these registers to set up the SPI peripheral for communication, covering important aspects such as <strong class="bold">clock polarity</strong> (<strong class="bold">CPOL</strong>) and <strong class="bold">clock phase</strong> (<strong class="bold">CPHA</strong>), data frame size, and <span class="No-Break">master/slave configuration.</span></p>
			<p>We then applied this theoretical knowledge by developing a bare-metal SPI driver. The development process included initializing the SPI peripheral, implementing data transmission and reception functions, and handling CS management. We also integrated the SPI driver with an ADXL345 accelerometer, using SPI to communicate with the sensor and retrieve acceleration data. Finally, we tested the driver by reading and displaying the accelerometer data in <span class="No-Break">real time.</span></p>
			<p>In the next chapter, we will explore the final of the three most common communication protocols in embedded <span class="No-Break">systems: I2C.</span></p>
		</div>
	</div>
</div>
</body></html>