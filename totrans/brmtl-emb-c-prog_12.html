<html><head></head><body>
<div><div><div><h1 id="_idParaDest-191" class="chapter-number"><a id="_idTextAnchor335"/>12</h1>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor336"/>Serial Peripheral Interface (SPI)</h1>
			<p>In this chapter, we will learn about the <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) protocol, another <a id="_idIndexMarker835"/>important communication protocol widely used in embedded systems.</p>
			<p>We will start by delving into the basics of the SPI protocol, understanding its master-slave architecture, data transfer modes, and typical use cases. Next, we will examine the key registers of the SPI peripheral in STM32 microcontrollers, providing detailed insights into their configuration and usage. Finally, we will apply this knowledge to develop a bare-metal SPI driver, demonstrating practical implementation and testing.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Overview of the SPI protocol</li>
				<li>The STM32F4 SPI peripherals<a id="_idTextAnchor337"/></li>
				<li>Developing the SPI driver</li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of the SPI protocol and be equipped to develop bare-metal drivers for SPI.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor338"/>Technical requirements</h1>
			<p>All code examples for this chapter can be found on GitHub at the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a></p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor340"/>Overview of the SPI protocol</h1>
			<p>Let’s dive <a id="_idIndexMarker836"/>into what SPI is, its key features, how it works, and some of the nuances that make it so powerful.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor341"/>What is SPI?</h2>
			<p>SPI is a <em class="italic">synchronous</em> serial <a id="_idIndexMarker837"/>communication protocol <a id="_idIndexMarker838"/>developed by Motorola. Unlike <strong class="bold">Universal Asynchronous Receiver-Transmitter</strong> (<strong class="bold">UART</strong>), which is asynchronous, SPI <em class="italic">relies on a clock signal</em> to synchronize data transfer between devices. It’s designed for short-distance communication (usually no more than 30 cm), primarily between a microcontroller and peripheral devices such as sensors, SD cards, and display modules. Let’s see its key features.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor342"/>Key features of SPI</h2>
			<p>SPI stands <a id="_idIndexMarker839"/>out due to its efficiency. Here are some of its key features:</p>
			<ul>
				<li><strong class="bold">Full-duplex communication</strong>: SPI supports simultaneous data transmission and reception</li>
				<li><strong class="bold">High speed</strong>: SPI can <a id="_idIndexMarker840"/>operate at much higher speeds compared to protocols such as <strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>) and UART</li>
				<li><strong class="bold">Master-slave architecture</strong>: One master device controls communication, while one or more slave devices respond</li>
				<li><strong class="bold">Flexible data length</strong>: Can handle various data lengths, commonly 8 bits, but not limited to that</li>
			</ul>
			<p>To be able to connect two SPI devices, we must understand the SPI interface.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor343"/>The SPI interface</h2>
			<p>SPI uses four <a id="_idIndexMarker841"/>primary lines for communication, each <a id="_idIndexMarker842"/>with several alternative names you might encounter:</p>
			<ul>
				<li><strong class="bold">Master In Slave Out (MISO)</strong>: Also <a id="_idIndexMarker843"/>known as <strong class="bold">Serial Data Out</strong> (<strong class="bold">SDO</strong>) or <strong class="bold">Data Out</strong> (<strong class="bold">DOUT</strong>), this <a id="_idIndexMarker844"/>line carries <a id="_idIndexMarker845"/>data from the slave device to the master</li>
				<li><strong class="bold">Master Out Slave In (MOSI)</strong>: Also <a id="_idIndexMarker846"/>known as <strong class="bold">Serial Data In</strong> (<strong class="bold">SDI</strong>) or <strong class="bold">Data In</strong> (<strong class="bold">DIN</strong>), this <a id="_idIndexMarker847"/>line carries <a id="_idIndexMarker848"/>data from the master device to the slave</li>
				<li><strong class="bold">Serial Clock (SCK)</strong>: Also <a id="_idIndexMarker849"/>referred to as <strong class="bold">SCLK</strong> (or simply <strong class="bold">CLK</strong>), this is the clock signal generated by the master to synchronize data transfer</li>
				<li><strong class="bold">Slave Select (SS)</strong>: Also <a id="_idIndexMarker850"/>known as <strong class="bold">Chip Select</strong> (<strong class="bold">CS</strong>) or <strong class="bold">Not Slave Select</strong><strong class="bold"> </strong>(<strong class="bold">NSS</strong>), this line <a id="_idIndexMarker851"/>is used by the master <a id="_idIndexMarker852"/>to select which slave device to communicate with</li>
			</ul>
			<p>When multiple <a id="_idIndexMarker853"/>slaves are used, each slave typically has its own SS line, allowing the <a id="_idIndexMarker854"/>master to control communication with each slave individually. <em class="italic">Figure 12</em><em class="italic">.1</em> illustrates the SPI connection between a single master and<a id="_idTextAnchor344"/><a id="_idTextAnchor345"/> a single slave:</p>
			<div><div><img src="img/B21914_12_1.jpg" alt="Figure 12.1: The SPI interface" width="1206" height="430"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: The SPI interface</p>
			<p><em class="italic">Figure 12</em><em class="italic">.2</em> depicts the SPI setup with a single master controlling multiple slaves:</p>
			<div><div><img src="img/B21914_12_2.jpg" alt="Figure 12.2: The SPI interface – multiple slaves" width="1215" height="1017"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: The SPI interface – multiple slaves</p>
			<p>When multiple <a id="_idIndexMarker855"/>slaves are connected to a single SPI bus, managing <a id="_idIndexMarker856"/>the MISO line is crucial to avoid communication errors. Since all slaves share this line, non-selected slaves could interfere with the signal from the selected slave if not properly controlled. To prevent such issues, several techniques are used. One <a id="_idIndexMarker857"/>common method is <strong class="bold">tri-state buffering</strong>, where each slave’s MISO line enters a high-impedance (high-Z) state when its CS line is inactive, effectively disconnecting it from the bus. This ensures only the selected slave drives the <a id="_idIndexMarker858"/>MISO line, preventing bus contention. Another approach is the <strong class="bold">open-drain configuration</strong> with a pull-up resistor, where the MISO line is left floating (high-Z) when transmitting a 1 and pulled low by the selected slave when transmitting a 0. This reduces contention risks but may result in slower communication speeds due to the time delay introduced by the pull-up resistor.</p>
			<p>Let’s see how the SPI protocol works.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor346"/>How SPI works</h2>
			<p>SPI works <a id="_idIndexMarker859"/>on a simple principle: the master generates a clock signal and selects a slave to communicate with by <em class="italic">pulling the corresponding SS line low</em>. Data is then exchanged simultaneously between the master and the slave over the MOSI and MISO lines.</p>
			<p>Here’s a step-by-step breakdown:</p>
			<ol>
				<li><strong class="bold">Initialization</strong>: The master sets the clock frequency and data format (for example, 8-bit data).</li>
				<li><strong class="bold">Slave selection</strong>: The master pulls the SS line of the target slave low. In a multi-slave configuration, where each slave has its own CS line, the master first sets all CS lines high (inactive) before sending any initialization messages. This ensures that uninitialized slaves don’t mistakenly respond to commands not intended for them. Once all CS lines are confirmed high, the master then activates the CS line of the desired slave by pulling it low to begin controlled communication.</li>
				<li><strong class="bold">Data transmission</strong>: The master sends data to the slave on the MOSI line, while the slave sends data to the master on the MISO line.</li>
				<li><strong class="bold">Clock synchronization</strong>: The master controls the clock, ensuring data is sampled and shifted at the correct times.</li>
				<li><strong class="bold">Completion</strong>: Once the data transfer is complete, the master pulls the SS line high, deselecting the slave.</li>
			</ol>
			<p>To successfully implement an SPI driver, it’s essential to understand key SPI configuration parameters. Let’s explore them one by one, starting with <strong class="bold">Clock Phase</strong> (<strong class="bold">CPHA</strong>) and <strong class="bold">Clock </strong><strong class="bold">Polarity</strong> (<strong class="bold">CPOL</strong>).</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor347"/>CPHA and CPOL</h2>
			<p>In SPI <a id="_idIndexMarker860"/>communication, the settings for CPHA and CPOL determine <a id="_idIndexMarker861"/>the timing and characteristics of the clock signal used to synchronize data transfer between the master and slave devices. These settings are crucial for ensuring that data is correctly sampled and interpreted by both the master and the slave. Here’s a detailed look at how CPHA and CPOL affect SPI communication.</p>
			<h3>CPOL</h3>
			<p>CPOL <a id="_idIndexMarker862"/>determines the idle state of the clock signal (SCK). It controls whether the clock signal is high or low when no data is being transferred:</p>
			<ul>
				<li><strong class="bold">CPOL = 0</strong>: The clock signal is low (0) when idle. This means that the clock line remains low between data transmissions.</li>
				<li><strong class="bold">CPOL = 1</strong>: The clock signal is high (1) when idle. This means that the clock line remains high between data transmissions.</li>
			</ul>
			<h3>CPHA</h3>
			<p>CPHA <a id="_idIndexMarker863"/>determines when data is sampled and when it is shifted out. It controls the edge of the clock signal on which data is read and written:</p>
			<ul>
				<li><strong class="bold">CPHA = 0</strong>: Data is sampled on the leading edge (first edge) of the clock pulse and shifted out on the trailing edge (second edge)</li>
				<li><strong class="bold">CPHA = 1</strong>: Data is shifted out on the leading edge (first edge) of the clock pulse and sampled on the trailing edge (second edge)</li>
			</ul>
			<p>The combination of CPOL and CPHA results in four different SPI modes, each affecting the timing of data sampling and shifting.</p>
			<p>Selecting the appropriate SPI mode is crucial for ensuring proper communication between the master and slave devices. Both devices must be configured to use the same CPOL and CPHA settings to correctly interpret the data being exchanged. The choice of mode depends on the specific requirements of the devices and the timing constraints of the application. Let’s move on to SPI data modes.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor348"/>Data modes</h2>
			<p>SPI is <a id="_idIndexMarker864"/>flexible with the data length it can handle. While <strong class="bold">8-bit</strong> data transfers are common, SPI can be configured to handle different data lengths, such as <strong class="bold">16-bit</strong> or <strong class="bold">32-bit</strong> transfers, depending on the application. The master and slave devices need to agree on the data length to ensure accurate communication. The last configuration parameter is the SPI speed.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor349"/>SPI speed</h2>
			<p>One of SPI’s significant advantages is its speed. SPI can operate at very high frequencies, typically <a id="_idIndexMarker865"/>up to several tens of <strong class="bold">MHz</strong>, depending on the hardware capabilities of the master and slave devices. The actual speed used in an application depends on several factors:</p>
			<ul>
				<li><strong class="bold">Device capabilities</strong>: The maximum speed supported by both the master and the slave</li>
				<li><strong class="bold">Signal integrity</strong>: Higher speeds can lead to signal integrity issues such as crosstalk and reflections, especially over longer distances</li>
				<li><strong class="bold">Power consumption</strong>: Higher speeds consume more power, which might be a consideration in battery-powered applications</li>
			</ul>
			<p>This concludes our overview of the SPI protocol. In the next section, we will analyze the SPI peripheral in the STM32F4 microcontroller.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor350"/>The STM32F4 SPI peripherals</h1>
			<p>As with <a id="_idIndexMarker866"/>other peripherals, STM32 microcontrollers often include several SPI peripherals; the number varies depending on the specific model. The STM32F411 microcontroller has five SPI peripherals, namely the following:</p>
			<ul>
				<li>SPI1</li>
				<li>SPI2</li>
				<li>SPI3</li>
				<li>SPI4</li>
				<li>SPI5</li>
			</ul>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor351"/>Key features</h2>
			<p>Here are <a id="_idIndexMarker867"/>some of the key features:</p>
			<ul>
				<li><strong class="bold">Full-duplex and half-duplex communication</strong>: Supports simultaneous two-way communication (full-duplex) or one-way communication (half-duplex)</li>
				<li><strong class="bold">Master/slave configuration</strong>: Each SPI peripheral can be configured as either a master or a slave device</li>
				<li><strong class="bold">Flexible data size</strong>: Supports data sizes ranging from 4 to 16 bits</li>
				<li><strong class="bold">High-speed communication</strong>: Capable of operating at speeds up to 42 MHz in master mode and up to 21 MHz in slave mode</li>
				<li><strong class="bold">Direct Memory Access (DMA) support</strong>: DMA support for efficient data transfer without CPU intervention</li>
				<li><strong class="bold">Negative SS (NSS) pin management</strong>: Hardware management of the NSS pin for multi-slave configurations</li>
				<li><strong class="bold">Cyclic Redundancy Check (CRC) calculation</strong>: Built-in hardware CRC calculation for data integrity verification</li>
				<li><strong class="bold">Bidirectional mode</strong>: Supports bidirectional data mode, allowing a single data line to be used for both sending and receiving data</li>
			</ul>
			<p>Let’s examine the key registers of this peripheral.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor352"/>Key SPI registers</h2>
			<p>To get <a id="_idIndexMarker868"/>SPI up and running on the STM32F411 <a id="_idIndexMarker869"/>microcontroller, we need to configure several registers that control various aspects of the SPI peripheral. Let’s break down the main registers we’ll be working with, starting with the <strong class="bold">Control Register </strong><strong class="bold">1</strong> register.</p>
			<h3>SPI Control Register 1 (SPI_CR1)</h3>
			<p>The <code>SPI_CR1</code> register <a id="_idIndexMarker870"/>is central to configuring the SPI <a id="_idIndexMarker871"/>peripheral. It includes settings that define the <strong class="bold">SPI mode</strong>, <strong class="bold">data format</strong>, <strong class="bold">clock settings</strong>, and more. Key bits in this register include the following:</p>
			<ul>
				<li><code>CPHA</code> to <code>0</code> means data is sampled on the first edge (leading edge), while setting it to <code>1</code> means data is sampled on the second edge (trailing edge).</li>
				<li><code>CPOL</code> to <code>0</code> means the clock is low when idle, and setting it to <code>1</code> means the clock is high when idle.</li>
				<li><code>MSTR</code> to <code>1</code> makes <a id="_idIndexMarker873"/>the SPI peripheral a master, while <code>0</code> sets it as a slave.</li>
				<li><strong class="bold">Baud Rate Control (BR[2:0])</strong>: These bits configure the baud rate for SPI communication.</li>
				<li><code>SPE</code> to <code>1</code> to activate SPI communication.</li>
				<li><code>LSBFIRST</code> to <code>0</code> transmits the <code>1</code> transmits the <strong class="bold">least significant bit</strong> (<strong class="bold">LSB</strong>) first.</li>
				<li><strong class="bold">SS Internal (SSI)</strong>: This bit is used in master mode to internally control the SS line.</li>
				<li><code>1</code> enables software management of the SS line, allowing the master to control it manually.</li>
			</ul>
			<p>Next, we have the SPI Status Register.</p>
			<h3>SPI Status Register (SPI_SR)</h3>
			<p>The <code>SPI_SR</code> register <a id="_idIndexMarker876"/>provides real-time status <a id="_idIndexMarker877"/>updates on the SPI peripheral, informing us about various operational states and flags. Key bits in this register include the following:</p>
			<ul>
				<li><strong class="bold">Receive Buffer Not Empty (RXNE)</strong>: This flag indicates that the receive buffer contains unread data</li>
				<li><strong class="bold">Transmit Buffer Empty (TXE)</strong>: This flag signals that the transmit buffer is empty and ready for new data</li>
				<li><strong class="bold">CRC Error Flag (CRCERR)</strong>: This flag is set when a CRC error is detected, indicating <a id="_idIndexMarker878"/>possible data corruption</li>
				<li><strong class="bold">Mode Fault (MODF)</strong>: This <a id="_idIndexMarker879"/>flag signals a mode fault, often due to incorrect master/slave configuration</li>
				<li><strong class="bold">Overrun Flag (OVR)</strong>: This flag indicates an overrun condition, where the receive buffer wasn’t read in time</li>
				<li><strong class="bold">Busy Flag (BSY)</strong>: This flag indicates that the SPI peripheral is currently engaged in a transmission or reception</li>
			</ul>
			<p>The last key register is the Data Register.</p>
			<h3>SPI Data Register (SPI_DR)</h3>
			<p>The <code>SPI_DR</code> register <a id="_idIndexMarker880"/>is the conduit for data <a id="_idIndexMarker881"/>transmission and reception. It’s where we write data to be sent out and read data that’s been received:</p>
			<ul>
				<li><code>SPI_DR</code> register, data is sent out over the <code>MOSI</code> line</li>
				<li><code>SPI_DR</code>, you get the data that was received on the <code>MISO</code> line</li>
			</ul>
			<p>With these registers in mind, we’re now ready to develop the SPI driver. Let’s jump into that in<a id="_idTextAnchor353"/> the next section.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor354"/>Developing the SPI driver</h1>
			<p>Create a copy <a id="_idIndexMarker882"/>of your previous project in your IDE and rename this copied project to <code>SPI</code>. Next, create a new file named <code>spi.c</code> in the <code>Src</code> folder and another file named <code>spi.h</code> in the <code>Inc</code> folder. Populate your <code>spi.c</code> file with the following code:</p>
			<pre class="source-code">
<strong class="bold">#include "spi.h" </strong>
<strong class="bold">#define</strong> SPI1EN            (1U&lt;&lt;12)
<strong class="bold">#define</strong> GPIOAEN            (1U&lt;&lt;0)
<strong class="bold">#define</strong> SR_TXE            (1U&lt;&lt;1)
<strong class="bold">#define</strong> SR_RXNE            (1U&lt;&lt;0)
<strong class="bold">#define</strong> SR_BSY            (1U&lt;&lt;7)
<strong class="bold">void spi_gpio_init(void)</strong>
{
    /*Enable clock access to GPIOA*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*Set PA5,PA6,PA7 mode to alternate function*/
    /*PA5*/
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;10);
    GPIOA-&gt;MODER |=(1U&lt;&lt;11);
    /*PA6*/
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;12);
    GPIOA-&gt;MODER |=(1U&lt;&lt;13);
    /*PA7*/
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;14);
    GPIOA-&gt;MODER |=(1U&lt;&lt;15);
    /*Set PA9 as output pin*/
    GPIOA-&gt;MODER |=(1U&lt;&lt;18);
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;19);
    /*Set PA5,PA6,PA7 alternate function type to SPI1*/
    /*PA5*/
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;20);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;21);
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;22);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;23);
    /*PA6*/
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;24);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;25);
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;26);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;27);
    /*PA7*/
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;28);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;29);
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;30);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;31);
}</pre>			<p>Next, we have <a id="_idIndexMarker883"/>the function for configuring the SPI parameters:</p>
			<pre class="source-code">
<strong class="bold">void spi1_config(void)</strong>
{
    /*Enable clock access to SPI1 module*/
    RCC-&gt;APB2ENR |= SPI1EN;
    /*Set clock to fPCLK/4*/
    SPI1-&gt;CR1 |=(1U&lt;&lt;3);
    SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;4);
    SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;5);
    /*Set CPOL to 1 and CPHA to 1*/
    SPI1-&gt;CR1 |=(1U&lt;&lt;0);
    SPI1-&gt;CR1 |=(1U&lt;&lt;1);
    /*Enable full <strong class="bold">duplex</strong>*/
    SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;10);
    /*Set MSB first*/
    SPI1-&gt;CR1 &amp;= ~(1U&lt;&lt;7);
    /*Set mode to MASTER*/
    SPI1-&gt;CR1 |= (1U&lt;&lt;2);
    /*Set 8 bit data mode*/
    SPI1-&gt;CR1 &amp;= ~(1U&lt;&lt;11);
    /*Select software slave management by
     * setting SSM=1 and SSI=1*/
    SPI1-&gt;CR1 |= (1&lt;&lt;8);
    SPI1-&gt;CR1 |= (1&lt;&lt;9);
    /*Enable SPI module*/
    SPI1-&gt;CR1 |= (1&lt;&lt;6);
}
<strong class="bold">void spi1_transmit</strong>(uint8_t *data,uint32_t size)
{
    uint32_t i=0;
    uint8_t temp;
    <strong class="bold">while</strong>(i&lt;size)
    {
        /*Wait until TXE is set*/
        <strong class="bold">while</strong>(!(SPI1-&gt;SR &amp; (SR_TXE))){}
        /*Write the data to the data register*/
        SPI1-&gt;DR = data[i];
        i++;
    }
    /*Wait until TXE is set*/
    <strong class="bold">while</strong>(!(SPI1-&gt;SR &amp; (SR_TXE))){}
    /*Wait for BUSY flag to reset*/
    <strong class="bold">while</strong>((SPI1-&gt;SR &amp; (SR_BSY))){}
    /*Clear OVR flag*/
    temp = SPI1-&gt;DR;
    temp = SPI1-&gt;SR;
}</pre>			<p>Here is the function for receiving data:</p>
			<pre class="source-code">
<strong class="bold">void spi1_receive</strong>(uint8_t *data,uint32_t size)
{
    <strong class="bold">while</strong>(size)
    {
        /*Send dummy data*/
        SPI1-&gt;DR =0;
        /*Wait for RXNE flag to be set*/
        <strong class="bold">while</strong>(!(SPI1-&gt;SR &amp; (SR_RXNE))){}
        /*Read data from data register*/
        *data++ = (SPI1-&gt;DR);
        size--;
    }
}</pre>			<p>Finally, we have the functions for controlling the CS pin:</p>
			<pre class="source-code">
<strong class="bold">void cs_enable(void)</strong>
{
    GPIOA-&gt;ODR &amp;=~(1U&lt;&lt;9);
}</pre>			<p>And then, the function for deselecting the slave:</p>
			<pre class="source-code">
/*Pull high to disable*/
<strong class="bold">void cs_disable</strong>(<strong class="bold">void</strong>)
{
    GPIOA-&gt;ODR |=(1U&lt;&lt;9);
}</pre>			<p>Let’s walk <a id="_idIndexMarker884"/>through each part of the SPI initialization and communication code. We’ll start by looking at the defined macros and then dive into each function.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor355"/>Defined macros</h2>
			<p>Let’s break <a id="_idIndexMarker885"/>down the meaning of the macros and their functions:</p>
			<pre class="source-code">
#define SPI1EN      (1U&lt;&lt;12)
#define GPIOAEN     (1U&lt;&lt;0)
#define SR_TXE      (1U&lt;&lt;1)
#define SR_RXNE     (1U&lt;&lt;0)
#define SR_BSY      (1U&lt;&lt;7)</pre>			<p>Over here, we see the following:</p>
			<ul>
				<li><code>SPI1EN</code>: This is defined as <code>(1U&lt;&lt;12)</code>, which sets bit 12. It’s used to enable the clock for the SPI1 peripheral.</li>
				<li><code>GPIOAEN</code>: This is defined as <code>(1U&lt;&lt;0)</code>, which sets bit 0. This enables the clock for <code>GPIOA</code>.</li>
				<li><code>SR_TXE</code>: This is <a id="_idIndexMarker886"/>defined as <code>(1U&lt;&lt;1)</code>. This indicates that the transmit buffer is empty.</li>
				<li><code>SR_RXNE</code>: This is defined as <code>(1U&lt;&lt;0)</code>. This indicates that the receive buffer is not empty.</li>
				<li><code>SR_BSY</code>: This is defined as <code>(1U&lt;&lt;7)</code>. This indicates that the SPI interface is busy with a transfer.</li>
			</ul>
			<p>Let’s break down the initialization function.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor356"/>GPIO initialization for SPI</h2>
			<p>Let’s analyze the configuration of the SPI1 GPIO pins:</p>
			<pre class="source-code">
RCC-&gt;AHB1ENR |= GPIOAEN;</pre>			<p>This line <a id="_idIndexMarker887"/>enables the clock for <code>GPIOA</code> by setting the appropriate bit in the <code>AHB1</code> peripheral clock enable register:</p>
			<pre class="source-code">
/*PA5*/
GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;10);
GPIOA-&gt;MODER |=(1U&lt;&lt;11);
/*PA6*/
GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;12);
GPIOA-&gt;MODER |=(1U&lt;&lt;13);
/*PA7*/
GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;14);
GPIOA-&gt;MODER |=(1U&lt;&lt;15);</pre>			<p>These lines configure <code>PA5</code>, <code>PA6</code>, and <code>PA7</code> pins to alternate function modes, necessary for SPI:</p>
			<pre class="source-code">
GPIOA-&gt;MODER |= (1U&lt;&lt;18);
GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;19);</pre>			<p>This <a id="_idIndexMarker888"/>configures <code>PA9</code> as a general-purpose output pin, which will be used for SS:</p>
			<pre class="source-code">
/*PA5*/
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;20);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;21);
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;22);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;23);
/*PA6*/
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;24);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;25);
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;26);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;27);
/*PA7*/
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;28);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;29);
GPIOA-&gt;AFR[0] |=(1U&lt;&lt;30);
GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;31);</pre>			<p>These lines set the alternate function registers to configure <code>PA5</code>, <code>PA6</code>, and <code>PA7</code> for <code>SPI1</code>.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor357"/>SPI1 configuration</h2>
			<p>Next, we have the code for configuring the SPI parameters:</p>
			<pre class="source-code">
RCC-&gt;APB2ENR |= SPI1EN;</pre>			<p>This line <a id="_idIndexMarker889"/>enables the clock for <code>SPI1</code> by setting the appropriate bit in the <code>APB2</code> peripheral clock enable register:</p>
			<pre class="source-code">
SPI1-&gt;CR1 |=(1U&lt;&lt;3);
SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;4);
SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;5);</pre>			<p>These lines configure the SPI clock prescaler to set the baud rate by dividing the <code>APB2</code> peripheral clock by 4, as SPI1 is connected to the <code>APB2</code> bus. The baud rate is determined <a id="_idIndexMarker890"/>by the <code>001</code> results in the peripheral clock being divided by 4, which dictates the speed at which data is transferred over the SPI bus:</p>
			<pre class="source-code">
SPI1-&gt;CR1 |=(1U&lt;&lt;0);
SPI1-&gt;CR1 |=(1U&lt;&lt;1);</pre>			<p>These lines set the clock polarity and phase to ensure correct data sampling:</p>
			<pre class="source-code">
SPI1-&gt;CR1 &amp;=~(1U&lt;&lt;10);</pre>			<p>This line ensures that full-duplex mode is enabled for simultaneous transmit and receive:</p>
			<pre class="source-code">
SPI1-&gt;CR1 &amp;= ~(1U&lt;&lt;7);</pre>			<p>This line configures SPI to transmit the MSB first:</p>
			<pre class="source-code">
SPI1-&gt;CR1 |= (1U&lt;&lt;2);</pre>			<p>This line sets <code>SPI1</code> to master mode, making it the controller of the SPI bus:</p>
			<pre class="source-code">
SPI1-&gt;CR1 &amp;= ~(1U&lt;&lt;11);</pre>			<p>This line configures the SPI data frame size to <code>8</code> bits:</p>
			<pre class="source-code">
SPI1-&gt;CR1 |= (1&lt;&lt;8);
SPI1-&gt;CR1 |= (1&lt;&lt;9);</pre>			<p>These lines <a id="_idIndexMarker891"/>enable <code>SS</code> line.</p>
			<pre class="source-code">
SPI1-&gt;CR1 |= (1&lt;&lt;6);</pre>			<p>This line enables the SPI peripheral for operation:</p>
			<p>Let’s move on to the <code>spi1_transmit()</code> function.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor358"/>Transmitting data with SPI</h2>
			<p>This <a id="_idIndexMarker892"/>snippet deals with transmitting the data:</p>
			<pre class="source-code">
while (!(SPI1-&gt;SR &amp; (SR_TXE))) {}</pre>			<p>This loop waits until the transmit buffer is empty before sending the next byte:</p>
			<pre class="source-code">
SPI1-&gt;DR = data[i];</pre>			<p>This line sends the current byte of data:</p>
			<pre class="source-code">
while ((SPI1-&gt;SR &amp; (SR_BSY))) {}</pre>			<p>This ensures the SPI bus is not busy before continuing:</p>
			<pre class="source-code">
temp = SPI1-&gt;DR;
temp = SPI1-&gt;SR;</pre>			<p>These two lines play a crucial role in managing the SPI communication process. After the master transmits data through the SPI Data Register, the same register captures the data received from the slave. To ensure incoming data is properly processed, we read the Data Register, even if we don’t need the value. This read operation automatically clears the OVR flag. It’s also advisable to read the Status Register as part of this process.</p>
			<p>Next, we have the <code>spi1_receive()</code> function.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor359"/>SPI data reception</h2>
			<p>This deals with receiving the data:</p>
			<pre class="source-code">
SPI1-&gt;DR = 0;</pre>			<p>This line <a id="_idIndexMarker893"/>sends dummy data to generate clock pulses:</p>
			<pre class="source-code">
while (!(SPI1-&gt;SR &amp; (SR_RXNE))) {}</pre>			<p>This line waits until data is received:</p>
			<pre class="source-code">
*data++ = (SPI1-&gt;DR);</pre>			<p>This line reads the received data:</p>
			<p>The last functions are the <code>cs_enable()</code> and <code>cs_disable()</code> functions.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor360"/>CS management</h2>
			<p>This line <a id="_idIndexMarker894"/>pulls the SS line <a id="_idTextAnchor361"/>low to enable the slave device:</p>
			<pre class="source-code">
GPIOA-&gt;ODR &amp;= ~(1U &lt;&lt; 9);</pre>			<p>This line pulls the SS line high to disable the slave device:</p>
			<pre class="source-code">
GPIOA-&gt;ODR |= (1U &lt;&lt; 9);</pre>			<p>Our next task is to populate the <code>spi.h</code> file.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor362"/>The header file</h2>
			<p>Here <a id="_idIndexMarker895"/>is the code:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> SPI_H_
<strong class="bold">#define</strong> SPI_H_
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">void spi_gpio_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void spi1_config</strong>(<strong class="bold">void</strong>);
<strong class="bold">void spi1_transmit</strong>(uint8_t *data,uint32_t size);
<strong class="bold">void spi1_receive</strong>(uint8_t *data,uint32_t size);
<strong class="bold">void cs_enable</strong>(<strong class="bold">void</strong>);
<strong class="bold">void cs_disable</strong>(<strong class="bold">void</strong>);
<strong class="bold">#endif</strong></pre>			<p>Over here, we are <a id="_idIndexMarker896"/>simply exposing the functions to make them accessible in other files.</p>
			<p>To effectively <a id="_idIndexMarker897"/>test the SPI driver, we need a sui<a id="_idTextAnchor363"/>table slave device. In the next section, we’ll dive into the <strong class="bold">ADXL345 accelerometer</strong>, which we’ll use as our slave device to test the SPI driver.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor364"/>Getting to know the ADXL345 accelerometer</h2>
			<p><code>ADXL345</code> is a gem <a id="_idIndexMarker898"/>in the world of digital accelerometers, and it’s perfect for testing our SPI module. Let’s dive into what makes this device so special and ho<a id="_idTextAnchor365"/>w it fits into our embedded system projects.</p>
			<h3>What is ADXL345?</h3>
			<p>ADXL345 is <a id="_idIndexMarker899"/>a small, thin, ultralow <a id="_idIndexMarker900"/>power, <code>13</code>-bit) measurements with a selectable measurement range of <strong class="bold">±2 g</strong>, <strong class="bold">±4 g</strong>, <strong class="bold">±8 g</strong>, or <strong class="bold">±</strong><strong class="bold">16 g</strong>:</p>
			<div><div><img src="img/B21914_12_3.jpg" alt="Figure 12.3: The ADXL345" width="300" height="387"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: The ADXL345</p>
			<p>Let’s analyze its key features.</p>
			<h3>Key features of the ADXL345</h3>
			<p>Following is <a id="_idIndexMarker902"/>a list of the ADXL345’s features:</p>
			<ul>
				<li><strong class="bold">Ultralow power</strong>: The device consumes as little as 23 µA in measurement mode and just 0.1 µA in standby mode, making it ideal for battery-powered applications.</li>
				<li><strong class="bold">User-selectable resolution</strong>: We can choose a resolution from 10 to 13 bits, providing a scale factor of 4 mg/LSB across all g ranges.</li>
				<li><strong class="bold">Flexible interface</strong>: The ADXL345 supports both SPI (3- and 4-wire) and I2C digital interfaces, giving us flexibility in how you integrate it into your system.</li>
				<li><strong class="bold">Special sensing functions</strong>: It includes single tap, double tap, and free-fall detection, along with activity/inactivity monitoring. These functions can be individually mapped to two interrupt output pins, making it highly responsive to physical events.</li>
				<li><strong class="bold">Wide supply voltage range</strong>: It operates from 2.0 V to 3.6 V, accommodating various power configurations.</li>
				<li><strong class="bold">Robust performance</strong>: The ADXL345 can withstand a shock of up to 10,000 g, ensuring durability in rugged applications.</li>
			</ul>
			<p>Let’s see some of its common applications.</p>
			<h3>Applications</h3>
			<p>Given its <a id="_idIndexMarker903"/>robust feature set, the ADXL345 is well suited for a range of applications:</p>
			<ul>
				<li><strong class="bold">Industrial equipment</strong>: For machinery monitoring and fault detection</li>
				<li><strong class="bold">Aerospace equipment</strong>: In systems where reliability and precision are paramount</li>
				<li><strong class="bold">Consumer electronics</strong>: Examples are smartphones, gaming devices, and wearable technology</li>
				<li><strong class="bold">Health and sports</strong>: For tracking motion and activity in health monitoring devices</li>
			</ul>
			<p>Let’s take a closer look at its sensing function.</p>
			<h3>Sensing function</h3>
			<p>At its core, the ADXL345 measures acceleration along three axes: <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em>. The data is available <a id="_idIndexMarker904"/>in a 16-bit two's complement format and can be accessed via either the SPI or I2C interface.</p>
			<p>The following are its sensing functions:</p>
			<ul>
				<li><strong class="bold">Activity and inactivity monitoring</strong>: The accelerometer can detect movement or the absence thereof, making it great for sleep monitoring and fitness applications</li>
				<li><strong class="bold">Tap detection</strong>: It can recognize single and double taps in any direction, which is useful for gesture-based controls</li>
				<li><strong class="bold">Free-fall detection</strong>: The device can detect if it’s in free fall, which can be used in safety systems to trigger an alert or a response</li>
			</ul>
			<p><em class="italic">Figure 12</em><em class="italic">.4</em> shows the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> axes:</p>
			<div><div><img src="img/B21914_12_4.jpg" alt="Figure 12.4: The x, y, and z axes" width="648" height="608"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4: The x, y, and z axes</p>
			<p>The ADXL345 also offers various low-power modes to help manage power consumption intelligently. These modes allow the device to enter sleep or standby states based on our defined thresholds and activity levels.</p>
			<p>It also <a id="_idIndexMarker905"/>includes a 32-level <strong class="bold">FIFO buffer</strong>, which helps in storing data <a id="_idIndexMarker906"/>temporarily to reduce the load on the host processor. This buffer is especially useful in applications requiring high data throughput or when the processor is busy with other tasks. Lastly, its pinout is straightforward:</p>
			<ul>
				<li><strong class="bold">VDD I/O</strong>: Digital interface supply voltage</li>
				<li><strong class="bold">GND</strong>: Ground</li>
				<li><strong class="bold">CS</strong>: CS for SPI communication</li>
				<li><strong class="bold">INT1 and INT2</strong>: Interrupt output pins</li>
				<li><strong class="bold">SDA/SDI/SDIO</strong>: Serial data line for I2C or SPI input</li>
				<li><strong class="bold">SCL/SCLK</strong>: Serial clock line for I2C or SPI</li>
			</ul>
			<p>Before we dive into developing the driver for this slave device, let’s first explore some key concepts of acceleration measurement.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor366"/>Understanding key concepts – static acceleration of gravity, tilt-sensing, and dynamic acceleration</h2>
			<p>When working with accelerometers such as the ADXL345, it’s important to grasp some fundamental concepts that underpin their operation and applications. Let’s break down what static acceleration of gravity, tilt-sensing, and dynamic acceleration mean.</p>
			<h3>Static acceleration of gravity</h3>
			<p><strong class="bold">Static acceleration of gravity</strong> refers to the constant acceleration due to gravity that acts on <a id="_idIndexMarker907"/>an object at rest. This acceleration is always present and has a magnitude of approximately <strong class="bold">9.8 meters per second squared (m/s²)</strong> on the surface of the Earth.</p>
			<p>In the context of an accelerometer such as the ADXL345, static acceleration is used to determine the orientation of the device. When the accelerometer is at rest and positioned flat, it measures the static acceleration of gravity along the <em class="italic">z</em> axis, which helps to identify which direction is “down.” This capability is crucial for applications such as the following:</p>
			<ul>
				<li><strong class="bold">Orientation detection</strong>: Determining the device’s orientation relative to the Earth’s surface</li>
				<li><strong class="bold">Tilt-sensing</strong>: Measuring the tilt angle of the device by observing how gravity’s force changes across different axes</li>
			</ul>
			<p>The next important concept is tilt-sensing.</p>
			<h3>Tilt-sensing</h3>
			<p><strong class="bold">Tilt-sensing</strong> is the <a id="_idIndexMarker908"/>process of measuring the angle at which an object is tilted with respect to the force of gravity. This is achieved by analyzing the static acceleration readings from the accelerometer.</p>
			<p>Imagine holding a tablet. When you tilt it forward, backward, or sideways, the accelerometer inside detects changes in the static acceleration along its <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> axes. By comparing these changes, the device can calculate the tilt angle. Here’s how it works:</p>
			<ul>
				<li><strong class="bold">X-axis tilt</strong>: If the device is tilted along the <em class="italic">x</em> axis, the static acceleration detected on the <em class="italic">x</em> axis will increase or decrease depending on the direction of the tilt.</li>
				<li><strong class="bold">Y-axis tilt</strong>: Similarly, tilting along the <em class="italic">y</em> axis will cause variations in the static acceleration readings on the <em class="italic">y</em> axis.</li>
				<li><strong class="bold">Z-axis stability</strong>: The <em class="italic">z</em> axis usually detects the full force of gravity when the device is lying flat. Changes in tilt cause redistributions of this force among the <em class="italic">x</em> and <em class="italic">y</em> axes.</li>
			</ul>
			<p>Tilt-sensing is<a id="_idIndexMarker909"/> widely used in applications such as the following:</p>
			<ul>
				<li><strong class="bold">Screen orientation</strong>: Automatically adjusting the display from portrait to landscape mode</li>
				<li><strong class="bold">Gaming controllers</strong>: Detecting movements and tilts to enhance gameplay</li>
				<li><strong class="bold">Industrial equipment</strong>: Monitoring the tilt of machinery or vehicles for stability and safety</li>
			</ul>
			<p>The final key concept is dynamic acceleration.</p>
			<h3>Dynamic acceleration</h3>
			<p><strong class="bold">Dynamic acceleration</strong> refers to the acceleration that results from motion or external forces <a id="_idIndexMarker910"/>acting on the device. Unlike static acceleration, which is constant, dynamic acceleration varies based on how the device is moving.</p>
			<p>For instance, if you shake or move the accelerometer, it measures these changes as dynamic acceleration. This type of acceleration is crucial for the following:</p>
			<ul>
				<li><strong class="bold">Motion detection</strong>: Identifying when the device is moved, which can be used in fitness trackers to count steps</li>
				<li><strong class="bold">Shock or impact sensing</strong>: Detecting sudden impacts or vibrations, useful in crash detection systems or drop tests</li>
				<li><strong class="bold">Vibration monitoring</strong>: Measuring vibrations in industrial machinery to predict failures or maintenance needs</li>
			</ul>
			<p>Before wrapping up this section, let’s clarify one more concept we introduced earlier: “g.”</p>
			<p>When dealing with accelerometers such as the ADXL345, you often come across terms such as ±2 g, ±4 g, ±8 g, or ±16 g. These terms are crucial for understanding the measurement capabilities and limits of the device. Let’s break down what g means and how these ranges affect the performance and application of an accelerometer.</p>
			<h3>What is g?</h3>
			<p>The term <em class="italic">g</em> refers to <a id="_idIndexMarker911"/>the acceleration due to gravity at the Earth’s surface, which is approximately 9.8 <strong class="bold">meters per second squared</strong> (<strong class="bold">m/s²</strong>). It is used as a unit of measurement for acceleration. When we say an accelerometer can measure ±2 g, it means it can detect accelerations up to twice the force of gravity in either direction along an axis.</p>
			<p>With this clarified, we are now ready to develop the driver for the ADXL345 device.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor367"/>Developing the ADXL345 driver</h2>
			<p>Create a <a id="_idIndexMarker912"/>new file named <code>adxl345.c</code> in the <code>Src</code> folder and another file named <code>adxl345.h</code> in the <code>Inc</code> folder.</p>
			<h3>The header file</h3>
			<p>Pop<a id="_idTextAnchor368"/>ulate <a id="_idIndexMarker913"/>the <code>adxl345.h</code> file with this:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> ADXL345_H_
<strong class="bold">#define</strong> ADXL345_H_
#include "spi.h"
#include &lt;stdint.h&gt;
#define ADXL345_REG_DEVID                (0x00)
#define ADXL345_REG_DATA_FORMAT          (0x31)
#define ADXL345_REG_POWER_CTL            (0x2D)
#define ADXL345_REG_DATA_START           (0x32)
#define ADXL345_RANGE_4G                 (0x01)
#define ADXL345_RESET                    (0x00)
#define ADXL345_MEASURE_BIT              (0x08)
#define ADXL345_MULTI_BYTE_ENABLE        (0x40)
#define ADXL345_READ_OPERATION           (0x80)
void adxl_init (void);
void adxl_read(uint8_t address, uint8_t * rxdata);
<code>adxl345.h</code> file begins <a id="_idIndexMarker914"/>by including our SPI driver with <code>#include "spi.h"</code> and proceeds to define the necessary macros. Let’s break down the macros:</p>
			<ul>
				<li><code>ADXL345_REG_DEVID (0x00)</code>: This macro defines the register address for the device ID of the ADXL345</li>
				<li><code>ADXL345_REG_DATA_FORMAT (0x31)</code>: This macro defines the register address for setting the data format of the ADXL345</li>
				<li><code>ADXL345_REG_POWER_CTL (0x2D)</code>: This macro defines the register address for the power control settings of the ADXL345</li>
				<li><code>ADXL345_REG_DATA_START (0x32)</code>: This macro defines the starting register address for reading acceleration data from the ADXL345</li>
				<li><code>ADXL345_RANGE_4G (0x01)</code>: This macro defines the value to set the measurement range of the ADXL345 to ±4g</li>
				<li><code>ADXL345_RESET (0x00)</code>: This macro defines the reset value for certain registers</li>
				<li><code>ADXL345_MEASURE_BIT (0x08)</code>: This macro defines the bit value to enable measurement mode in the power control register</li>
				<li><code>ADXL345_MULTI_BYTE_ENABLE (0x40)</code>: This macro defines the bit to enable multi-byte operations</li>
				<li><code>ADXL345_READ_OPERATION (0x80)</code>: This macro defines the bit to specify a read operation</li>
			</ul>
			<p>Next, we populate the <code>adxl345.c</code> file:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "adxl345.h"
<strong class="bold">void adxl_read</strong>(uint8_t address, uint8_t * rxdata)
{
      /*Set read operation*/
      address |= ADXL345_READ_OPERATION;
      /*Enable multi-byte*/
      address |= ADXL345_MULTI_BYTE_ENABLE;
      /*Pull <strong class="bold">cs</strong> line low to enable slave*/
      cs_enable();
      /*Send address*/
      spi1_transmit(&amp;address,1);
      /*Read 6 bytes */
      spi1_receive(rxdata,6);
      /*Pull <strong class="bold">cs</strong> line high to disable slave*/
      cs_disable();
}
<strong class="bold">void adxl_write</strong> (uint8_t address, uint8_t value)
{
  uint8_t data[2];
  /*Enable multi-byte, place address into buffer*/
  data[0] = address|ADXL345_MULTI_BYTE_ENABLE;
  /*Place data into buffer*/
  data[1] = value;
  /*Pull <strong class="bold">cs</strong> line low to enable slave*/
  cs_enable();
  /*Transmit data and address*/
  spi1_transmit(data, 2);
  /*Pull <strong class="bold">cs</strong> line high to disable slave*/
  cs_disable();
}
<strong class="bold">void adxl_init</strong> (<strong class="bold">void</strong>)
{
    /*Enable SPI <strong class="bold">gpio</strong>*/
    spi_gpio_init();
    /*<strong class="bold">Config</strong> SPI*/
    spi1_config();
    /*Set data format range to +-4g*/
    adxl_write (ADXL345_REG_DATA_FORMAT, ADXL345_RANGE_4G);
    /*Reset all bits*/
    adxl_write (ADXL345_REG_POWER_CTL, ADXL345_RESET);
    /*Configure power control measure bit*/
    adxl_write (ADXL345_REG_POWER_CTL, ADXL345_MEASURE_BIT);
}</pre>			<p>Let’s analyze <a id="_idIndexMarker915"/>the functions line by line, starting with the <code>adxl_read()</code> function.</p>
			<h3>Function – adxl_read()</h3>
			<p>Let’s <a id="_idIndexMarker916"/>break down the read function:</p>
			<ul>
				<li><code>address |= ADXL345_READ_OPERATION;</code>: This line sets the MSB of the address to indicate a read operation</li>
				<li><code>address |= ADXL345_MULTI_BYTE_ENABLE;</code>: This sets the multi-byte bit to enable multi-byte operations</li>
				<li><code>cs_enable();</code>: This function pulls the CS line low, enabling communication with the ADXL345</li>
				<li><code>spi1_transmit(&amp;address, 1);</code>: This transmits the address (with read and multi-byte bits set) to the ADXL345</li>
				<li><code>spi1_receive(rxdata, 6);</code>: This line reads 6 bytes of data from the ADXL345 and stores it in the buffer pointed to by <code>rxdata</code></li>
				<li><code>cs_disable();</code>: This function <a id="_idIndexMarker917"/>pulls the CS line high, ending communication with the ADXL345</li>
			</ul>
			<p>Next, we have the <code>adxl_write()</code> function.</p>
			<h3>Function – adxl_write</h3>
			<p>Let’s go <a id="_idIndexMarker918"/>through each line of this function:</p>
			<ul>
				<li><code>data[0] = address | ADXL345_MULTI_BYTE_ENABLE;</code>: This sets the multi-byte bit and stores the modified address in the buffer</li>
				<li><code>data[1] = value;</code>: This stores the data to be written in the buffer</li>
				<li><code>cs_enable();</code>: This function pulls the CS line low, enabling communication with the ADXL345</li>
				<li><code>spi1_transmit(data, 2);</code>: This transmits the address and data to the ADXL345 in one transaction</li>
				<li><code>cs_disable();</code>: This function pulls the CS line high, ending communication with the ADXL345</li>
			</ul>
			<p>Finally, we have the <code>adxl_init()</code> function.</p>
			<h3>Function – adxl_init</h3>
			<p>Let’s <a id="_idIndexMarker919"/>analyze the initialization function:</p>
			<ul>
				<li><code>spi_gpio_init();</code>: This function initializes the GPIO pins needed for SPI communication</li>
				<li><code>spi1_config();</code>: This function configures the SPI settings (clock speed, mode, etc.)</li>
				<li><code>adxl_write(ADXL345_REG_DATA_FORMAT, ADXL345_RANGE_4G);</code>: This line writes to the data format register to set the measurement range of the ADXL345 to ±4g</li>
				<li><code>adxl_write(ADXL345_REG_POWER_CTL, ADXL345_RESET);</code>: This line writes <a id="_idIndexMarker920"/>to the power control register to reset all bits</li>
				<li><code>adxl_write(ADXL345_REG_POWER_CTL, ADXL345_MEASURE_BIT);</code>: This line write<a id="_idTextAnchor369"/>s to the power control register to set the measure bit, enabling measurement mode</li>
			</ul>
			<p>We are now ready to test the driver inside the <code>main.c</code> file. Update your <code>main.c</code> file as shown next:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">#include</strong> "adxl345.h"
//Variables for storing accelerometer data
int16_t accel_x, accel_y, accel_z;
<strong class="bold">double</strong> accel_x_g, accel_y_g, accel_z_g;
uint8_t data_buffer[6];
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    uart_init();
    // Initialize the ADXL345 accelerometer
    adxl_init();
    <strong class="bold">while</strong> (1)
    {
        // Read accelerometer data starting from the data start 
        // register
        adxl_read(ADXL345_REG_DATA_START, data_buffer);
        // Combine high and low bytes to form the accelerometer data
        accel_x = (int16_t)((data_buffer[1] &lt;&lt; 8) | data_buffer[0]);
        accel_y = (int16_t)((data_buffer[3] &lt;&lt; 8) | data_buffer[2]);
        accel_z = (int16_t)((data_buffer[5] &lt;&lt; 8) | data_buffer[4]);
        // Convert raw data to g values
        accel_x_g = accel_x * 0.0078;
        accel_y_g = accel_y * 0.0078;
        accel_z_g = accel_z * 0.0078;
        //Print values for debugging purposes
        <strong class="bold">printf</strong>("accel_x : %d accel_y : %d  accel_z : %d\n\
        r",accel_x,accel_y,accel_z);
    }
    <strong class="bold">return</strong> 0;
}</pre>			<p>Let’s <a id="_idIndexMarker921"/>break down the <code>main()</code> function:</p>
			<ul>
				<li><code>accel_x, accel_y, accel_z</code>: These are variables to store the raw accelerometer data for each axis.</li>
				<li><code>accel_x_g, accel_y_g, accel_z_g</code>: These are variables to store the converted accelerometer data in g units.</li>
				<li><code>data_buffer[6]</code>: This is a buffer to hold the raw data bytes read from the ADXL345.</li>
				<li><code>adxl_init()</code>: This initializes the ADXL345 accelerometer.</li>
				<li><code>adxl_read(ADXL345_REG_DATA_START, data_buffer);</code>: This line reads data from the ADXL345 starting at the specified register (<code>ADXL345_REG_DATA_START</code>). The data is stored in <code>data_buffer</code>.</li>
			</ul>
			<p>Finally, we have the lines for constructing the final 16-bit values:</p>
			<pre class="source-code">
accel_x = (int16_t)((data_buffer[1] &lt;&lt; 8) | data_buffer[0]);
accel_y = (int16_t)((data_buffer[3] &lt;&lt; 8) | data_buffer[2]);
accel_z = (int16_t)((data_buffer[5] &lt;&lt; 8) | data_buffer[4]);</pre>			<p>The data read from the ADXL345 is in 2 bytes (high and low) for each axis. These lines combine the bytes to form 16-bit values for each axis:</p>
			<pre class="source-code">
accel_x_g = accel_x * 0.0078;
accel_y_g = accel_y * 0.0078;
accel_z_g = accel_z * 0.0078;</pre>			<p>These lines convert the raw accelerometer values to g values:</p>
			<pre class="source-code">
<strong class="bold">printf</strong>("accel_x : %d accel_y : %d  accel_z : %d\n\r",accel_x,accel_y,accel_z);</pre>			<p>This line <a id="_idIndexMarker922"/>outputs the raw accelerometer data for debugging purposes:</p>
			<p>Now, let’s test the project. To test the project, compile the code and run it on your microcontroller. Open RealTerm or another serial terminal application and configure it with the appropriate port and baud rate to view the debug messages. Press the black pushbutton on the development board to reset the microcontroller. You should see the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> accelerometer values continuously being printed. Try moving the accelerometer to observe the values change significantly.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor370"/>Summary</h1>
			<p>In this chapter, we explored the SPI protocol, a widely used communication protocol in embedded systems for efficient data transfer between microcontrollers and peripherals. We began by understanding the basic principles of SPI, including its master-slave architecture, data transfer modes, and typical use cases, emphasizing its advantages such as full-duplex communication and high-speed operation.</p>
			<p>Next, we examined the SPI peripheral in STM32F4 microcontrollers, focusing on critical registers such as SPI Control Register 1 (<code>SPI_CR1</code>), SPI Status Register (<code>SPI_SR</code>), and SPI Data Register (<code>SPI_DR</code>). We detailed how to configure these registers to set up the SPI peripheral for communication, covering important aspects such as <strong class="bold">clock polarity</strong> (<strong class="bold">CPOL</strong>) and <strong class="bold">clock phase</strong> (<strong class="bold">CPHA</strong>), data frame size, and master/slave configuration.</p>
			<p>We then applied this theoretical knowledge by developing a bare-metal SPI driver. The development process included initializing the SPI peripheral, implementing data transmission and reception functions, and handling CS management. We also integrated the SPI driver with an ADXL345 accelerometer, using SPI to communicate with the sensor and retrieve acceleration data. Finally, we tested the driver by reading and displaying the accelerometer data in real time.</p>
			<p>In the next chapter, we will explore the final of the three most common communication protocols in embedded systems: I2C.</p>
		</div>
	</div>
</div>
</body></html>