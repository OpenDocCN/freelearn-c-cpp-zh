<html><head></head><body>
		<div id="_idContainer009">
			<h1 id="_idParaDest-58"><em class="italic"><a id="_idTextAnchor057"/>Chapter 2</em>: General STL Features</h1>
			<p>This chapter is a general potpourri of STL features and techniques. These are mostly new features introduced over the past few years, which may not yet be widely used. These are useful techniques that will improve the simplicity and readability of your code.</p>
			<p>In this chapter we will cover the following recipes:</p>
			<ul>
				<li>Use the new <strong class="source-inline">span</strong> class to make your C-arrays safer</li>
				<li>Use structured binding to return multiple values</li>
				<li>Initialize variables within <strong class="source-inline">if</strong> and <strong class="source-inline">switch</strong> statements</li>
				<li>Use template argument deduction for simplicity and clarity</li>
				<li>Use <strong class="source-inline">if constexpr</strong> to simplify compile-time decisions</li>
			</ul>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Technical requirements</h1>
			<p>You can find the code for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap02">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap02</a>.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Use the new span class to make your C-arrays safer</h1>
			<p>New for<a id="_idIndexMarker101"/> C++20, the <strong class="source-inline">std::span</strong> class is a simple wrapper that creates a view over a contiguous sequence of objects. The <strong class="source-inline">span</strong> doesn't own any of its own data, it refers to the data in the underlying structure. Think of it as <strong class="source-inline">string_view</strong> for C-arrays. The underlying structure may be a <em class="italic">C-array</em>, a <strong class="source-inline">vector</strong>, or an STL <strong class="source-inline">array</strong>.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>How to do it…</h2>
			<p>You can create a span from any compatible contiguous-storage structure. The most common use case will involve a C-array. For example, if you try to pass a C-array directly to a function, the array is demoted to a pointer and the function has no easy way to know the size of the array:</p>
			<p class="source-code">void parray(int * a);  // loses size information</p>
			<p>If you define your function with a <strong class="source-inline">span</strong> parameter, you can pass it a C-array and it will be promoted to <strong class="source-inline">span</strong>. Here's a template function that takes a <strong class="source-inline">span</strong> and prints out the size in elements and in bytes:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">void pspan(span&lt;T&gt; s) {</p>
			<p class="source-code">    cout &lt;&lt; format("number of elements: {}\n", s.size());</p>
			<p class="source-code">    cout &lt;&lt; format("size of span: {}\n", s.size_bytes());</p>
			<p class="source-code">    for(auto e : s) cout &lt;&lt; format("{} ", e);</p>
			<p class="source-code">    cout &lt;&lt; "\n";</p>
			<p class="source-code">}</p>
			<p>You can pass a <a id="_idIndexMarker102"/>C-array to this function and it's automatically promoted to <strong class="source-inline">span</strong>:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    int carray[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</p>
			<p class="source-code">    pspan&lt;int&gt;(carray);</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">number of elements: 10</p>
			<p class="source-code">number of bytes: 40</p>
			<p class="source-code">1 2 3 4 5 6 7 8 9 10 </p>
			<p>The purpose of <strong class="source-inline">span</strong> is to encapsulate the raw data to provide a measure of safety and utility, with a minimum of overhead.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>How it works…</h2>
			<p>The <strong class="source-inline">span</strong> class itself doesn't own any data. The data belongs to the underlying data structure. The <strong class="source-inline">span</strong> is essentially a view over the underlying data. It also provides some useful member functions.</p>
			<p>Defined in<a id="_idIndexMarker103"/> the <strong class="source-inline">&lt;span&gt;</strong> header, the <strong class="source-inline">span</strong> class looks something like:</p>
			<p class="source-code">template&lt;typename T, size_t Extent = std::dynamic_extent&gt;</p>
			<p class="source-code">class span {</p>
			<p class="source-code">    T * data;</p>
			<p class="source-code">    size_t count;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    ... </p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">Extent</strong> parameter is a constant of type <strong class="source-inline">constexpr size_t</strong>, which is computed at compile time. It's either the number of elements in the underlying data or the <strong class="source-inline">std:: dynamic_extent</strong> constant, which indicates that the size is variable. This allows <strong class="source-inline">span</strong> to use an underlying structure like a <strong class="source-inline">vector</strong>, which may not always be the same size.</p>
			<p>All <a id="_idIndexMarker104"/>member functions are <strong class="source-inline">constexpr</strong> and <strong class="source-inline">const</strong> qualified. Member functions include:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B18267_02_Table_01.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <strong class="source-inline">span</strong> class is but a simple wrapper that performs no bounds checking. So, if you try to access element <em class="italic">n</em>+1 in a <strong class="source-inline">span</strong> of <em class="italic">n</em> elements, the result is <em class="italic">undefined</em>, which is tech for, "Bad. Don't do that."</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Use structured binding to return multiple values</h1>
			<p><em class="italic">Structured binding</em> makes <a id="_idIndexMarker105"/>it easy to unpack the values of a<a id="_idIndexMarker106"/> structure into separate variables, improving the readability of your code.</p>
			<p>With structured binding you can directly assign the member values to variables like this:</p>
			<p class="source-code">things_pair&lt;int,int&gt; { 47, 9 };</p>
			<p class="source-code">auto [this, that] = things_pair;</p>
			<p class="source-code">cout &lt;&lt; format("{} {}\n", this, that);</p>
			<p>Output:</p>
			<p class="source-code">47 9</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>How to do it…</h2>
			<ul>
				<li><em class="italic">Structured binding</em> works with <strong class="source-inline">pair</strong>, <strong class="source-inline">tuple</strong>, <strong class="source-inline">array</strong>, and <strong class="source-inline">struct</strong>. Beginning with C++20, this includes bit-fields. This example uses a C-array: <p class="source-code">int nums[] { 1, 2, 3, 4, 5 };</p><p class="source-code"><strong class="bold">auto</strong> [ a, b, c, d, e ] = nums;</p><p class="source-code">cout &lt;&lt; format("{} {} {} {} {}\n", a, b, c, d, e);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1 2 3 4 5</strong></p>
			<p>Because the structured binding uses <em class="italic">automatic type deduction</em>, its type must be <strong class="source-inline">auto</strong>. The names of the individual variables are within the square brackets, <strong class="source-inline">[ a, b, c, d, e ]</strong>. </p>
			<p>In this example the <strong class="source-inline">int</strong> C-array <strong class="source-inline">nums</strong> holds five values. These five values are assigned to the variables (<strong class="source-inline">a</strong>, <strong class="source-inline">b</strong>, <strong class="source-inline">c</strong>, <strong class="source-inline">d</strong>, and <strong class="source-inline">e</strong>) using <em class="italic">structured binding</em>.</p>
			<ul>
				<li>This also <a id="_idIndexMarker107"/>works <a id="_idIndexMarker108"/>with an STL <strong class="source-inline">array</strong> object:<p class="source-code">array&lt;int,5&gt; nums { 1, 2, 3, 4, 5 };</p><p class="source-code">auto [ a, b, c, d, e ] = nums;</p><p class="source-code">cout &lt;&lt; format("{} {} {} {} {}\n", a, b, c, d, e);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1 2 3 4 5</strong></p>
			<ul>
				<li>Or you can<a id="_idIndexMarker109"/> use it <a id="_idIndexMarker110"/>with a <strong class="source-inline">tuple</strong>:<p class="source-code">tuple&lt;int, double, string&gt; nums{ 1, 2.7, "three" };</p><p class="source-code">auto [ a, b, c ] = nums;</p><p class="source-code">cout &lt;&lt; format("{} {} {}\n", a, b, c);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1 2.7 three</strong></p>
			<ul>
				<li>When you use it with a <strong class="source-inline">struct</strong> it will take the variables in the order they're defined:<p class="source-code">struct Things { int i{}; double d{}; string s{}; };</p><p class="source-code">Things nums{ 1, 2.7, "three" };</p><p class="source-code">auto [ a, b, c ] = nums;</p><p class="source-code">cout &lt;&lt; format("{} {} {}\n", a, b, c);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1 2.7 three</strong></p>
			<ul>
				<li>You can use a reference with a structured binding, which allows you to modify the values in the bound container, while avoiding duplication of the data:<p class="source-code">array&lt;int,5&gt; nums { 1, 2, 3, 4, 5 };</p><p class="source-code"><strong class="bold">auto&amp;</strong> [ a, b, c, d, e ] = nums;</p><p class="source-code">cout &lt;&lt; format("{} {}\n", <strong class="bold">nums[2], c</strong>);</p><p class="source-code"><strong class="bold">c = 47;</strong></p><p class="source-code">cout &lt;&lt; format("{} {}\n", <strong class="bold">nums[2], c</strong>);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">3 3</strong></p>
			<p class="source-code"><strong class="bold">47 47</strong></p>
			<p>Because the<a id="_idIndexMarker111"/> variables are bound as a <a id="_idIndexMarker112"/>reference, you can assign a value to <strong class="source-inline">c</strong> and it will change the value in the array as well (<strong class="source-inline">nums[2]</strong>).</p>
			<ul>
				<li>You can declare the array <strong class="source-inline">const</strong> to prevent values from being changed:<p class="source-code"><strong class="bold">const</strong> array&lt;int,5&gt; nums { 1, 2, 3, 4, 5 };</p><p class="source-code">auto&amp; [ a, b, c, d, e ] = nums;</p><p class="source-code">c = 47;    // this is now an error </p></li>
			</ul>
			<p>Or you can declare the binding <strong class="source-inline">const</strong> for the same effect, while allowing the array to be changed elsewhere and still avoid copying data:</p>
			<p class="source-code">array&lt;int,5&gt; nums { 1, 2, 3, 4, 5 };</p>
			<p class="source-code"><strong class="bold">const</strong> auto&amp; [ a, b, c, d, e ] = nums;</p>
			<p class="source-code">c = 47;    // this is also an error </p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>How it works…</h2>
			<p>Structured binding uses <em class="italic">automatic type deduction</em> to <a id="_idIndexMarker113"/>unpack the structure into your variables. It determines the type of each value independently, and assigns a corresponding type to each variable.</p>
			<ul>
				<li>Because structured binding uses automatic type deduction, you cannot specify a type for the binding. You must use <strong class="source-inline">auto</strong>. You should get a reasonable error message if you try to use a type for the binding:<p class="source-code">array&lt;int,5&gt; nums { 1, 2, 3, 4, 5 };</p><p class="source-code">int [ a, b, c, d, e ] = nums;</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">error: structured binding declaration cannot have type 'int'</strong></p>
			<p class="source-code"><strong class="bold">note: type must be cv-qualified 'auto' or reference to cv-qualified 'auto'</strong></p>
			<p>Above is the error from GCC when I try to use <strong class="source-inline">int</strong> with the structured binding declaration.</p>
			<ul>
				<li>It's common to <a id="_idIndexMarker114"/>use structured binding<a id="_idIndexMarker115"/> for a return type from a function:<p class="source-code">struct div_result {</p><p class="source-code">    long quo;</p><p class="source-code">    long rem;</p><p class="source-code">};</p><p class="source-code">div_result int_div(const long &amp; num, const long &amp; denom) {</p><p class="source-code">    struct div_result r{};</p><p class="source-code">    r.quo = num / denom;</p><p class="source-code">    r.rem = num % denom;</p><p class="source-code">    return r;</p><p class="source-code">}</p><p class="source-code">int main() {</p><p class="source-code">    <strong class="bold">auto [quo, rem]</strong> = int_div(47, 5);</p><p class="source-code">    cout &lt;&lt; format("quotient: {}, remainder {}\n",</p><p class="source-code">      quo, rem);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">quotient: 9, remainder 2</strong></p>
			<ul>
				<li>Because the <strong class="source-inline">map</strong> container <a id="_idIndexMarker116"/>classes return a<a id="_idIndexMarker117"/> pair for each element, it can be convenient to use structured binding to retrieve key/value pairs:<p class="source-code">map&lt;string, uint64_t&gt; inhabitants {</p><p class="source-code">    { "humans",   7000000000 },</p><p class="source-code">    { "pokemon", 17863376 },</p><p class="source-code">    { "klingons",   24246291 },</p><p class="source-code">    { "cats",    1086881528 }</p><p class="source-code">};</p><p class="source-code">// I like commas</p><p class="source-code">string make_commas(const uint64_t num) {</p><p class="source-code">    string s{ std::to_string(num) };</p><p class="source-code">    for(int l = s.length() - 3; l &gt; 0; l -= 3) {</p><p class="source-code">        s.insert(l, ",");</p><p class="source-code">    }</p><p class="source-code">    return s;</p><p class="source-code">}</p><p class="source-code">int main() {</p><p class="source-code">    for(const auto &amp; [creature, pop] : inhabitants) {</p><p class="source-code">        cout &lt;&lt; format("there are {} {}\n", </p><p class="source-code">            make_commas(pop), creature);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">there are 1,086,881,528 cats</strong></p>
			<p class="source-code"><strong class="bold">there are 7,000,000,000 humans</strong></p>
			<p class="source-code"><strong class="bold">there are 24,246,291 klingons</strong></p>
			<p class="source-code"><strong class="bold">there are 17,863,376 pokemon</strong></p>
			<p>Using structured<a id="_idIndexMarker118"/> binding to unpack structures <a id="_idIndexMarker119"/>should make your code clearer and easier to maintain.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Initialize variables within if and switch statements</h1>
			<p>Beginning <a id="_idIndexMarker120"/>with C++17, <strong class="source-inline">if</strong> and <strong class="source-inline">switch</strong> now have initialization <a id="_idIndexMarker121"/>syntax, much like <a id="_idIndexMarker122"/>the <strong class="source-inline">for</strong> loop has had since C99. This <a id="_idIndexMarker123"/>allows you to limit the scope of variables used within the condition.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>How to do it…</h2>
			<p>You may be accustomed to code like this:</p>
			<p class="source-code">const string artist{ "Jimi Hendrix" };</p>
			<p class="source-code">size_t pos{ artist.find("Jimi") };</p>
			<p class="source-code">if(pos != string::npos) {</p>
			<p class="source-code">    cout &lt;&lt; "found\n";</p>
			<p class="source-code">} else {</p>
			<p class="source-code">    cout &lt;&lt; "not found\n";</p>
			<p class="source-code">}</p>
			<p>This leaves the variable <strong class="source-inline">pos</strong> exposed outside the scope of the conditional statement, where it needs to be managed, or it can collide with other attempts to use the same symbol.</p>
			<p>Now you can <a id="_idIndexMarker124"/>put the initialization expression <a id="_idIndexMarker125"/>inside the <strong class="source-inline">if</strong> condition:</p>
			<p class="source-code">if(size_t pos{ artist.find("Jimi") }; pos != string::npos) {</p>
			<p class="source-code">    cout &lt;&lt; "found\n";</p>
			<p class="source-code">} else {</p>
			<p class="source-code">    cout &lt;&lt; "not found\n";</p>
			<p class="source-code">}</p>
			<p>Now the scope of the <strong class="source-inline">pos</strong> variable is confined to the scope of the conditional. This keeps your namespace clean and manageable.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>How it works…</h2>
			<p>The initializer <a id="_idIndexMarker126"/>expression can be used in either <strong class="source-inline">if</strong> or <strong class="source-inline">switch</strong> statements. Here<a id="_idIndexMarker127"/> are some examples of each.</p>
			<ul>
				<li>Use an initializer expression with an <strong class="source-inline">if</strong> statement:<p class="source-code">if(<strong class="bold">auto var{ init_value };</strong> condition) {</p><p class="source-code">    // var is visible </p><p class="source-code">} else {</p><p class="source-code">    // var is visible </p><p class="source-code">} </p><p class="source-code">// var is NOT visible </p></li>
			</ul>
			<p>The variable defined in the initializer expression is visible within the scope of the entire <strong class="source-inline">if</strong> statement, including the <strong class="source-inline">else</strong> clause. Once control flows out of the <strong class="source-inline">if</strong> statement<a id="_idIndexMarker128"/> scope, the variable will no longer be visible, and any<a id="_idIndexMarker129"/> relevant destructors will be called.</p>
			<ul>
				<li>Use an initializer expression with a <strong class="source-inline">switch</strong> statement:<p class="source-code">switch(<strong class="bold">auto var{ init_value };</strong> var) {</p><p class="source-code">case 1: ...</p><p class="source-code">case 2: ...</p><p class="source-code">case 3: ...</p><p class="source-code">...</p><p class="source-code">Default: ...</p><p class="source-code">}</p><p class="source-code">// var is NOT visible </p></li>
			</ul>
			<p>The <a id="_idIndexMarker130"/>variable defined in the initializer expression is visible within the scope of the entire <strong class="source-inline">switch</strong> statement, including <a id="_idIndexMarker131"/>all the <strong class="source-inline">case</strong> clauses and the <strong class="source-inline">default</strong> clause, if included. Once control flows out of the <strong class="source-inline">switch</strong> statement scope, the variable will no longer be visible, and any relevant destructors will be called.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>There's more…</h2>
			<p>One interesting use case is to limit the <a id="_idIndexMarker132"/>scope of a <strong class="source-inline">lock_guard</strong> that's locking a mutex. This becomes simple with an initializer expression:</p>
			<p class="source-code">if (<strong class="source-inline">lock_guard&lt;mutex&gt; lg{ my_mutex };</strong> condition) { </p>
			<p class="source-code">    // interesting things happen here </p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">lock_guard</strong> locks<a id="_idIndexMarker133"/> the mutex in its constructor and unlocks it in its destructor. Now the <strong class="source-inline">lock_guard</strong> will be automatically destroyed when it runs out of the scope of the <strong class="source-inline">if</strong> statement. In the past you would have had to delete it or enclose the whole <strong class="source-inline">if</strong> statement in an extra block of braces.</p>
			<p>Another use case could be using a legacy interface that uses output parameters, like this one from SQLite:</p>
			<p class="source-code">if(</p>
			<p class="source-code">    sqlite3_stmt** stmt, </p>
			<p class="source-code">    auto rc = sqlite3_prepare_v2(db, sql, -1, &amp;_stmt,</p>
			<p class="source-code">        nullptr);</p>
			<p class="source-code">    !rc) {</p>
			<p class="source-code">          // do SQL things</p>
			<p class="source-code">} else {  // handle the error </p>
			<p class="source-code">    // use the error code </p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>Here I can keep the statement handle and the error code localized to the scope of the <strong class="source-inline">if</strong> statement. Otherwise, I would need to manage those objects globally.</p>
			<p>Using initializer expressions will help keep your code tight and uncluttered, more compact, and easier to read. Refactoring and managing your code will also become easier.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Use template argument deduction for simplicity and clarity</h1>
			<p>Template argument deduction <a id="_idIndexMarker134"/>occurs when the <em class="italic">types</em> of the arguments to a template function, or class template constructor (beginning with C++17), are clear enough to be understood by the compiler without the use of template arguments. There are certain rules to this feature, but it's mostly intuitive.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>How to do it…</h2>
			<p>In general, template argument deduction happens automatically when you use a template with clearly compatible arguments. Let's consider some examples.</p>
			<ul>
				<li>In a function template, argument deduction usually looks something like this:<p class="source-code">template&lt;typename T&gt;</p><p class="source-code">const char * f(<strong class="bold">const T</strong> a) {</p><p class="source-code">    return typeid(T).name();</p><p class="source-code">}</p><p class="source-code">int main() {</p><p class="source-code">    cout &lt;&lt; format("T is {}\n", <strong class="bold">f(47)</strong>);</p><p class="source-code">    cout &lt;&lt; format("T is {}\n", <strong class="bold">f(47L)</strong>);</p><p class="source-code">    cout &lt;&lt; format("T is {}\n", <strong class="bold">f(47.0)</strong>);</p><p class="source-code">    cout &lt;&lt; format("T is {}\n", <strong class="bold">f("47")</strong>);</p><p class="source-code">    cout &lt;&lt; format("T is {}\n", <strong class="bold">f("47"s)</strong>);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">T is int</strong></p>
			<p class="source-code"><strong class="bold">T is long</strong></p>
			<p class="source-code"><strong class="bold">T is double</strong></p>
			<p class="source-code"><strong class="bold">T is char const *</strong></p>
			<p class="source-code"><strong class="bold">T is class std::basic_string&lt;char...</strong></p>
			<p>Because <a id="_idIndexMarker135"/>the types are easily discernable there is no reason to specify a template parameter like <strong class="source-inline">f&lt;int&gt;(47)</strong> in the function call. The compiler can deduce the <strong class="source-inline">&lt;int&gt;</strong> type from the argument.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The above output shows meaningful type names where most compilers will use shorthand, like <strong class="source-inline">i</strong> for <strong class="source-inline">int</strong> and <strong class="source-inline">PKc</strong> for <strong class="source-inline">const char *</strong>, and so on.</p>
			<ul>
				<li>This works just as well for multiple template parameters:<p class="source-code">template&lt;typename T1, typename T2&gt;</p><p class="source-code">string f(<strong class="bold">const T1 </strong>a, <strong class="bold">const T2</strong> b) {</p><p class="source-code">    return format("{} {}", typeid(T1).name(), </p><p class="source-code">        typeid(T2).name());</p><p class="source-code">}</p><p class="source-code">int main() {</p><p class="source-code">    cout &lt;&lt; format("T1 T2: {}\n", <strong class="bold">f(47, 47L)</strong>);</p><p class="source-code">    cout &lt;&lt; format("T1 T2: {}\n", <strong class="bold">f(47L, 47.0)</strong>);</p><p class="source-code">    cout &lt;&lt; format("T1 T2: {}\n", <strong class="bold">f(47.0, "47")</strong>);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">T1 T2: int long</strong></p>
			<p class="source-code"><strong class="bold">T1 T2: long double</strong></p>
			<p class="source-code"><strong class="bold">T1 T2: double char const *</strong></p>
			<p>Here the compiler is deducing types for both <strong class="source-inline">T1</strong> and <strong class="source-inline">T2</strong>.</p>
			<ul>
				<li>Notice that the <a id="_idIndexMarker136"/>types must be compatible with the template. For example, you cannot take a reference from a literal:<p class="source-code">template&lt;typename T&gt;</p><p class="source-code">const char * f(const T&amp; a) {</p><p class="source-code">    return typeid(T).name();</p><p class="source-code">}</p><p class="source-code">int main() {</p><p class="source-code">    int x{47};</p><p class="source-code">    f(47);  // this will not compile </p><p class="source-code">    f(x);   // but this will </p><p class="source-code">}</p></li>
				<li>Beginning with C++17 you can also use template parameter deduction with classes. So now this will work:<p class="source-code">pair p(47, 47.0);     // deduces to pair&lt;int, double&gt;</p><p class="source-code">tuple t(9, 17, 2.5);  // deduces to tuple&lt;int, int, double&gt;</p></li>
			</ul>
			<p>This eliminates the need for <strong class="source-inline">std::make_pair()</strong> and <strong class="source-inline">std::make_tuple()</strong> as you can now initialize these classes directly without the explicit <a id="_idIndexMarker137"/>template parameters. The <strong class="source-inline">std::make_*</strong> helper functions will remain available for backward compatibility.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>How it works…</h2>
			<p>Let's define a class so we can see how this works:</p>
			<p class="source-code">template&lt;typename T1, typename T2, typename T3&gt;</p>
			<p class="source-code">class Thing {</p>
			<p class="source-code">    T1 v1{};</p>
			<p class="source-code">    T2 v2{};</p>
			<p class="source-code">    T3 v3{};</p>
			<p class="source-code">public:</p>
			<p class="source-code">    explicit Thing(T1 p1, T2 p2, T3 p3)</p>
			<p class="source-code">    : v1{p1}, v2{p2}, v3{p3} {}</p>
			<p class="source-code">    string print() {</p>
			<p class="source-code">        return format("{}, {}, {}\n",</p>
			<p class="source-code">            typeid(v1).name(),</p>
			<p class="source-code">            typeid(v2).name(),</p>
			<p class="source-code">            typeid(v3).name()</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p class="source-code">};</p>
			<p>This is a template <a id="_idIndexMarker138"/>class with three types and three corresponding data members. It has a <strong class="source-inline">print()</strong> function, which returns a formatted string with the three type names.</p>
			<p>Without template parameter deduction, I would have to instantiate an object of this type like this:</p>
			<p class="source-code">Things&lt;int, double, string&gt; thing1{1, 47.0, "three" }</p>
			<p>Now I can do it like this:</p>
			<p class="source-code">Things thing1{1, 47.0, "three" }</p>
			<p>This is both<a id="_idIndexMarker139"/> simpler and less error prone.</p>
			<p>When I call the <strong class="source-inline">print()</strong> function on the <strong class="source-inline">thing1</strong> object, I get this result:</p>
			<p class="source-code">cout &lt;&lt; thing1.print();</p>
			<p>Output:</p>
			<p class="source-code">int, double, char const *</p>
			<p>Of course, your compiler may report something effectively similar.</p>
			<p>Before C++17, template parameter deduction didn't apply to classes, so you needed a helper function, which may have looked like this:</p>
			<p class="source-code">template&lt;typename T1, typename T2, typename T3&gt;</p>
			<p class="source-code">Things&lt;T1, T2, T3&gt; make_things(T1 p1, T2 p2, T3 p3) {</p>
			<p class="source-code">    return Things&lt;T1, T2, T3&gt;(p1, p2, p3);</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p class="source-code">auto thing1(make_things(1, 47.0, "three"));</p>
			<p class="source-code">cout &lt;&lt; thing1.print();</p>
			<p>Output:</p>
			<p class="source-code">int, double, char const *</p>
			<p>The STL includes a<a id="_idIndexMarker140"/> few of these helper functions, like <strong class="source-inline">make_pair()</strong> and <strong class="source-inline">make_tuple()</strong>, etc. These are now obsolescent, but will be maintained for compatibility with older code.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>There's more…</h2>
			<p>Consider the case of a constructor with a parameter pack:</p>
			<p class="source-code">template &lt;typename T&gt;</p>
			<p class="source-code">class Sum {</p>
			<p class="source-code">    T v{};</p>
			<p class="source-code">public:</p>
			<p class="source-code">    template &lt;typename... Ts&gt;</p>
			<p class="source-code">    Sum(Ts&amp;&amp; ... values) : v{ (values + ...) } {}</p>
			<p class="source-code">    const T&amp; value() const { return v; }</p>
			<p class="source-code">};</p>
			<p>Notice the <em class="italic">fold expression</em> in the constructor <strong class="source-inline">(values + ...)</strong>. This is a C++17 feature that applies an operator to all the members of a parameter pack. In this case, it initializes <strong class="source-inline">v</strong> to the sum of the parameter pack. </p>
			<p>The constructor for this class accepts an arbitrary number of parameters, where each parameter may be a different class. For example, I could call it like this:</p>
			<p class="source-code">Sum s1 { 1u, 2.0, 3, 4.0f };  // unsigned, double, int, </p>
			<p class="source-code">                              // float</p>
			<p class="source-code">Sum s2 { "abc"s, "def" };     // std::sring, c-string</p>
			<p>This, of course, doesn't compile. The template argument deduction fails to find a common type for all those different parameters. We get an error message to the effect of:</p>
			<p class="source-code">cannot deduce template arguments for 'Sum'</p>
			<p>We can fix <a id="_idIndexMarker141"/>this with a <em class="italic">template deduction guide</em>. A deduction guide<a id="_idIndexMarker142"/> is a helper pattern to assist the compiler with a complex deduction. Here's a guide for our constructor:</p>
			<p class="source-code">template &lt;typename... Ts&gt;</p>
			<p class="source-code">Sum(Ts&amp;&amp; ... ts) -&gt; Sum&lt;std::common_type_t&lt;Ts...&gt;&gt;;</p>
			<p>This tells the compiler to use the <strong class="source-inline">std::common_type_t</strong> trait, which attempts to find a common type for all the parameters in the pack. Now our argument deduction works and we can see what types it settled on:</p>
			<p class="source-code">Sum s1 { 1u, 2.0, 3, 4.0f };  // unsigned, double, int, </p>
			<p class="source-code">                              // float</p>
			<p class="source-code">Sum s2 { "abc"s, "def" };     // std::sring, c-string</p>
			<p class="source-code">auto v1 = s1.value();</p>
			<p class="source-code">auto v2 = s2.value();</p>
			<p class="source-code">cout &lt;&lt; format("s1 is {} {}, s2 is {} {}",</p>
			<p class="source-code">        typeid(v1).name(), v1, typeid(v2).name(), v2);</p>
			<p>Output:</p>
			<p class="source-code">s1 is double 10, s2 is class std::string abcdef</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Use if constexpr to simplify compile-time decisions</h1>
			<p>An <strong class="source-inline">if constexpr(</strong><em class="italic">condition</em><strong class="source-inline">)</strong> statement <a id="_idIndexMarker143"/>is used where code needs to be executed based on a compile-time condition. The <em class="italic">condition</em> may be any <strong class="source-inline">constexpr</strong> expression of type <strong class="source-inline">bool</strong>.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>How to do it…</h2>
			<p>Consider the <a id="_idIndexMarker144"/>case where you have a<a id="_idIndexMarker145"/> template function that needs to operate differently depending upon the type of the template parameter.</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">auto value_of(const T v) {</p>
			<p class="source-code">    <strong class="bold">if constexpr</strong> (std::is_pointer_v&lt;T&gt;) {</p>
			<p class="source-code">        return <strong class="bold">*v</strong>;  // dereference the pointer</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        return <strong class="bold">v</strong>;   // return the value</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    <strong class="bold">int</strong> x{47};</p>
			<p class="source-code">    <strong class="bold">int*</strong> y{&amp;x};</p>
			<p class="source-code">    cout &lt;&lt; format("value is {}\n", value_of(x));  // value</p>
			<p class="source-code">    cout &lt;&lt; format("value is {}\n", value_of(y));  </p>
			<p class="source-code">                                                // pointer</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">value is 47</p>
			<p class="source-code">value is 47</p>
			<p>The type of the<a id="_idIndexMarker146"/> template parameter <strong class="source-inline">T</strong> is <a id="_idIndexMarker147"/>available at compile time. The <strong class="source-inline">constexpr if</strong> statement allows the code to easily distinguish between a pointer and a value.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>How it works…</h2>
			<p>The <strong class="source-inline">constexpr if</strong> statement works like a normal <strong class="source-inline">if</strong> statement except it's evaluated at <em class="italic">compile time</em>. The <em class="italic">runtime code</em> will not contain any branch statements from a <strong class="source-inline">constexpr if</strong> statement. Consider our branch statement from above:</p>
			<p class="source-code">if <strong class="bold">constexpr</strong> (<strong class="bold">std::is_pointer_v&lt;T&gt;</strong>) {</p>
			<p class="source-code">    return *v;  // dereference the pointer</p>
			<p class="source-code">} else {</p>
			<p class="source-code">        return v;   // return the value</p>
			<p class="source-code">    }</p>
			<p>The <a id="_idIndexMarker148"/>condition <strong class="source-inline">is_pointer_v&lt;T&gt;</strong> tests a<a id="_idIndexMarker149"/> template parameter, which is not available at runtime. The <strong class="source-inline">constexpr</strong> keyword tells the compiler that this <strong class="source-inline">if</strong> statement needs to evaluate at compile time, while the template parameter <strong class="source-inline">&lt;T&gt;</strong> is available.</p>
			<p>This should make a lot of meta programming situations much easier. The <strong class="source-inline">if constexpr</strong> statement is available in C++17 and later.</p>
		</div>
	</body></html>