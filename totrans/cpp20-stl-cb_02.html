<html><head></head><body>
		<div><h1 id="_idParaDest-58"><em class="italic"><a id="_idTextAnchor057"/>Chapter 2</em>: General STL Features</h1>
			<p>This chapter is a general potpourri of STL features and techniques. These are mostly new features introduced over the past few years, which may not yet be widely used. These are useful techniques that will improve the simplicity and readability of your code.</p>
			<p>In this chapter we will cover the following recipes:</p>
			<ul>
				<li>Use the new <code>span</code> class to make your C-arrays safer</li>
				<li>Use structured binding to return multiple values</li>
				<li>Initialize variables within <code>if</code> and <code>switch</code> statements</li>
				<li>Use template argument deduction for simplicity and clarity</li>
				<li>Use <code>if constexpr</code> to simplify compile-time decisions</li>
			</ul>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Technical requirements</h1>
			<p>You can find the code for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap02">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap02</a>.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Use the new span class to make your C-arrays safer</h1>
			<p>New for<a id="_idIndexMarker101"/> C++20, the <code>std::span</code> class is a simple wrapper that creates a view over a contiguous sequence of objects. The <code>span</code> doesn't own any of its own data, it refers to the data in the underlying structure. Think of it as <code>string_view</code> for C-arrays. The underlying structure may be a <em class="italic">C-array</em>, a <code>vector</code>, or an STL <code>array</code>.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>How to do it…</h2>
			<p>You can create a span from any compatible contiguous-storage structure. The most common use case will involve a C-array. For example, if you try to pass a C-array directly to a function, the array is demoted to a pointer and the function has no easy way to know the size of the array:</p>
			<pre>void parray(int * a);  // loses size information</pre>
			<p>If you define your function with a <code>span</code> parameter, you can pass it a C-array and it will be promoted to <code>span</code>. Here's a template function that takes a <code>span</code> and prints out the size in elements and in bytes:</p>
			<pre>template&lt;typename T&gt;
void pspan(span&lt;T&gt; s) {
    cout &lt;&lt; format("number of elements: {}\n", s.size());
    cout &lt;&lt; format("size of span: {}\n", s.size_bytes());
    for(auto e : s) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; "\n";
}</pre>
			<p>You can pass a <a id="_idIndexMarker102"/>C-array to this function and it's automatically promoted to <code>span</code>:</p>
			<pre>int main() {
    int carray[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    pspan&lt;int&gt;(carray);
}</pre>
			<p>Output:</p>
			<pre>number of elements: 10
number of bytes: 40
1 2 3 4 5 6 7 8 9 10 </pre>
			<p>The purpose of <code>span</code> is to encapsulate the raw data to provide a measure of safety and utility, with a minimum of overhead.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>How it works…</h2>
			<p>The <code>span</code> class itself doesn't own any data. The data belongs to the underlying data structure. The <code>span</code> is essentially a view over the underlying data. It also provides some useful member functions.</p>
			<p>Defined in<a id="_idIndexMarker103"/> the <code>&lt;span&gt;</code> header, the <code>span</code> class looks something like:</p>
			<pre>template&lt;typename T, size_t Extent = std::dynamic_extent&gt;
class span {
    T * data;
    size_t count;
public:
    ... 
};</pre>
			<p>The <code>Extent</code> parameter is a constant of type <code>constexpr size_t</code>, which is computed at compile time. It's either the number of elements in the underlying data or the <code>std:: dynamic_extent</code> constant, which indicates that the size is variable. This allows <code>span</code> to use an underlying structure like a <code>vector</code>, which may not always be the same size.</p>
			<p>All <a id="_idIndexMarker104"/>member functions are <code>constexpr</code> and <code>const</code> qualified. Member functions include:</p>
			<div><div><img src="img/B18267_02_Table_01.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <code>span</code> class is but a simple wrapper that performs no bounds checking. So, if you try to access element <em class="italic">n</em>+1 in a <code>span</code> of <em class="italic">n</em> elements, the result is <em class="italic">undefined</em>, which is tech for, "Bad. Don't do that."</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Use structured binding to return multiple values</h1>
			<p><em class="italic">Structured binding</em> makes <a id="_idIndexMarker105"/>it easy to unpack the values of a<a id="_idIndexMarker106"/> structure into separate variables, improving the readability of your code.</p>
			<p>With structured binding you can directly assign the member values to variables like this:</p>
			<pre>things_pair&lt;int,int&gt; { 47, 9 };
auto [this, that] = things_pair;
cout &lt;&lt; format("{} {}\n", this, that);</pre>
			<p>Output:</p>
			<pre>47 9</pre>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>How to do it…</h2>
			<ul>
				<li><em class="italic">Structured binding</em> works with <code>pair</code>, <code>tuple</code>, <code>array</code>, and <code>struct</code>. Beginning with C++20, this includes bit-fields. This example uses a C-array: <pre>int nums[] { 1, 2, 3, 4, 5 };
<strong class="bold">auto</strong> [ a, b, c, d, e ] = nums;
cout &lt;&lt; format("{} {} {} {} {}\n", a, b, c, d, e);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">1 2 3 4 5</strong></pre>
			<p>Because the structured binding uses <em class="italic">automatic type deduction</em>, its type must be <code>auto</code>. The names of the individual variables are within the square brackets, <code>[ a, b, c, d, e ]</code>. </p>
			<p>In this example the <code>int</code> C-array <code>nums</code> holds five values. These five values are assigned to the variables (<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, and <code>e</code>) using <em class="italic">structured binding</em>.</p>
			<ul>
				<li>This also <a id="_idIndexMarker107"/>works <a id="_idIndexMarker108"/>with an STL <code>array</code> object:<pre>array&lt;int,5&gt; nums { 1, 2, 3, 4, 5 };
auto [ a, b, c, d, e ] = nums;
cout &lt;&lt; format("{} {} {} {} {}\n", a, b, c, d, e);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">1 2 3 4 5</strong></pre>
			<ul>
				<li>Or you can<a id="_idIndexMarker109"/> use it <a id="_idIndexMarker110"/>with a <code>tuple</code>:<pre>tuple&lt;int, double, string&gt; nums{ 1, 2.7, "three" };
auto [ a, b, c ] = nums;
cout &lt;&lt; format("{} {} {}\n", a, b, c);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">1 2.7 three</strong></pre>
			<ul>
				<li>When you use it with a <code>struct</code> it will take the variables in the order they're defined:<pre>struct Things { int i{}; double d{}; string s{}; };
Things nums{ 1, 2.7, "three" };
auto [ a, b, c ] = nums;
cout &lt;&lt; format("{} {} {}\n", a, b, c);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">1 2.7 three</strong></pre>
			<ul>
				<li>You can use a reference with a structured binding, which allows you to modify the values in the bound container, while avoiding duplication of the data:<pre>array&lt;int,5&gt; nums { 1, 2, 3, 4, 5 };
<strong class="bold">auto&amp;</strong> [ a, b, c, d, e ] = nums;
cout &lt;&lt; format("{} {}\n", <strong class="bold">nums[2], c</strong>);
<strong class="bold">c = 47;</strong>
cout &lt;&lt; format("{} {}\n", <strong class="bold">nums[2], c</strong>);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">3 3</strong>
<strong class="bold">47 47</strong></pre>
			<p>Because the<a id="_idIndexMarker111"/> variables are bound as a <a id="_idIndexMarker112"/>reference, you can assign a value to <code>c</code> and it will change the value in the array as well (<code>nums[2]</code>).</p>
			<ul>
				<li>You can declare the array <code>const</code> to prevent values from being changed:<pre><strong class="bold">const</strong> array&lt;int,5&gt; nums { 1, 2, 3, 4, 5 };
auto&amp; [ a, b, c, d, e ] = nums;
c = 47;    // this is now an error </pre></li>
			</ul>
			<p>Or you can declare the binding <code>const</code> for the same effect, while allowing the array to be changed elsewhere and still avoid copying data:</p>
			<pre>array&lt;int,5&gt; nums { 1, 2, 3, 4, 5 };
<strong class="bold">const</strong> auto&amp; [ a, b, c, d, e ] = nums;
c = 47;    // this is also an error </pre>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>How it works…</h2>
			<p>Structured binding uses <em class="italic">automatic type deduction</em> to <a id="_idIndexMarker113"/>unpack the structure into your variables. It determines the type of each value independently, and assigns a corresponding type to each variable.</p>
			<ul>
				<li>Because structured binding uses automatic type deduction, you cannot specify a type for the binding. You must use <code>auto</code>. You should get a reasonable error message if you try to use a type for the binding:<pre>array&lt;int,5&gt; nums { 1, 2, 3, 4, 5 };
int [ a, b, c, d, e ] = nums;</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">error: structured binding declaration cannot have type 'int'</strong>
<strong class="bold">note: type must be cv-qualified 'auto' or reference to cv-qualified 'auto'</strong></pre>
			<p>Above is the error from GCC when I try to use <code>int</code> with the structured binding declaration.</p>
			<ul>
				<li>It's common to <a id="_idIndexMarker114"/>use structured binding<a id="_idIndexMarker115"/> for a return type from a function:<pre>struct div_result {
    long quo;
    long rem;
};
div_result int_div(const long &amp; num, const long &amp; denom) {
    struct div_result r{};
    r.quo = num / denom;
    r.rem = num % denom;
    return r;
}
int main() {
    <strong class="bold">auto [quo, rem]</strong> = int_div(47, 5);
    cout &lt;&lt; format("quotient: {}, remainder {}\n",
      quo, rem);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">quotient: 9, remainder 2</strong></pre>
			<ul>
				<li>Because the <code>map</code> container <a id="_idIndexMarker116"/>classes return a<a id="_idIndexMarker117"/> pair for each element, it can be convenient to use structured binding to retrieve key/value pairs:<pre>map&lt;string, uint64_t&gt; inhabitants {
    { "humans",   7000000000 },
    { "pokemon", 17863376 },
    { "klingons",   24246291 },
    { "cats",    1086881528 }
};
// I like commas
string make_commas(const uint64_t num) {
    string s{ std::to_string(num) };
    for(int l = s.length() - 3; l &gt; 0; l -= 3) {
        s.insert(l, ",");
    }
    return s;
}
int main() {
    for(const auto &amp; [creature, pop] : inhabitants) {
        cout &lt;&lt; format("there are {} {}\n", 
            make_commas(pop), creature);
    }
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">there are 1,086,881,528 cats</strong>
<strong class="bold">there are 7,000,000,000 humans</strong>
<strong class="bold">there are 24,246,291 klingons</strong>
<strong class="bold">there are 17,863,376 pokemon</strong></pre>
			<p>Using structured<a id="_idIndexMarker118"/> binding to unpack structures <a id="_idIndexMarker119"/>should make your code clearer and easier to maintain.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Initialize variables within if and switch statements</h1>
			<p>Beginning <a id="_idIndexMarker120"/>with C++17, <code>if</code> and <code>switch</code> now have initialization <a id="_idIndexMarker121"/>syntax, much like <a id="_idIndexMarker122"/>the <code>for</code> loop has had since C99. This <a id="_idIndexMarker123"/>allows you to limit the scope of variables used within the condition.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>How to do it…</h2>
			<p>You may be accustomed to code like this:</p>
			<pre>const string artist{ "Jimi Hendrix" };
size_t pos{ artist.find("Jimi") };
if(pos != string::npos) {
    cout &lt;&lt; "found\n";
} else {
    cout &lt;&lt; "not found\n";
}</pre>
			<p>This leaves the variable <code>pos</code> exposed outside the scope of the conditional statement, where it needs to be managed, or it can collide with other attempts to use the same symbol.</p>
			<p>Now you can <a id="_idIndexMarker124"/>put the initialization expression <a id="_idIndexMarker125"/>inside the <code>if</code> condition:</p>
			<pre>if(size_t pos{ artist.find("Jimi") }; pos != string::npos) {
    cout &lt;&lt; "found\n";
} else {
    cout &lt;&lt; "not found\n";
}</pre>
			<p>Now the scope of the <code>pos</code> variable is confined to the scope of the conditional. This keeps your namespace clean and manageable.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>How it works…</h2>
			<p>The initializer <a id="_idIndexMarker126"/>expression can be used in either <code>if</code> or <code>switch</code> statements. Here<a id="_idIndexMarker127"/> are some examples of each.</p>
			<ul>
				<li>Use an initializer expression with an <code>if</code> statement:<pre>if(<strong class="bold">auto var{ init_value };</strong> condition) {
    // var is visible 
} else {
    // var is visible 
} 
// var is NOT visible </pre></li>
			</ul>
			<p>The variable defined in the initializer expression is visible within the scope of the entire <code>if</code> statement, including the <code>else</code> clause. Once control flows out of the <code>if</code> statement<a id="_idIndexMarker128"/> scope, the variable will no longer be visible, and any<a id="_idIndexMarker129"/> relevant destructors will be called.</p>
			<ul>
				<li>Use an initializer expression with a <code>switch</code> statement:<pre>switch(<strong class="bold">auto var{ init_value };</strong> var) {
case 1: ...
case 2: ...
case 3: ...
...
Default: ...
}
// var is NOT visible </pre></li>
			</ul>
			<p>The <a id="_idIndexMarker130"/>variable defined in the initializer expression is visible within the scope of the entire <code>switch</code> statement, including <a id="_idIndexMarker131"/>all the <code>case</code> clauses and the <code>default</code> clause, if included. Once control flows out of the <code>switch</code> statement scope, the variable will no longer be visible, and any relevant destructors will be called.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>There's more…</h2>
			<p>One interesting use case is to limit the <a id="_idIndexMarker132"/>scope of a <code>lock_guard</code> that's locking a mutex. This becomes simple with an initializer expression:</p>
			<pre>if (<code>lock_guard&lt;mutex&gt; lg{ my_mutex };</code> condition) { 
    // interesting things happen here 
}</pre>
			<p>The <code>lock_guard</code> locks<a id="_idIndexMarker133"/> the mutex in its constructor and unlocks it in its destructor. Now the <code>lock_guard</code> will be automatically destroyed when it runs out of the scope of the <code>if</code> statement. In the past you would have had to delete it or enclose the whole <code>if</code> statement in an extra block of braces.</p>
			<p>Another use case could be using a legacy interface that uses output parameters, like this one from SQLite:</p>
			<pre>if(
    sqlite3_stmt** stmt, 
    auto rc = sqlite3_prepare_v2(db, sql, -1, &amp;_stmt,
        nullptr);
    !rc) {
          // do SQL things
} else {  // handle the error 
    // use the error code 
    return 0;
}</pre>
			<p>Here I can keep the statement handle and the error code localized to the scope of the <code>if</code> statement. Otherwise, I would need to manage those objects globally.</p>
			<p>Using initializer expressions will help keep your code tight and uncluttered, more compact, and easier to read. Refactoring and managing your code will also become easier.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Use template argument deduction for simplicity and clarity</h1>
			<p>Template argument deduction <a id="_idIndexMarker134"/>occurs when the <em class="italic">types</em> of the arguments to a template function, or class template constructor (beginning with C++17), are clear enough to be understood by the compiler without the use of template arguments. There are certain rules to this feature, but it's mostly intuitive.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>How to do it…</h2>
			<p>In general, template argument deduction happens automatically when you use a template with clearly compatible arguments. Let's consider some examples.</p>
			<ul>
				<li>In a function template, argument deduction usually looks something like this:<pre>template&lt;typename T&gt;
const char * f(<strong class="bold">const T</strong> a) {
    return typeid(T).name();
}
int main() {
    cout &lt;&lt; format("T is {}\n", <strong class="bold">f(47)</strong>);
    cout &lt;&lt; format("T is {}\n", <strong class="bold">f(47L)</strong>);
    cout &lt;&lt; format("T is {}\n", <strong class="bold">f(47.0)</strong>);
    cout &lt;&lt; format("T is {}\n", <strong class="bold">f("47")</strong>);
    cout &lt;&lt; format("T is {}\n", <strong class="bold">f("47"s)</strong>);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">T is int</strong>
<strong class="bold">T is long</strong>
<strong class="bold">T is double</strong>
<strong class="bold">T is char const *</strong>
<strong class="bold">T is class std::basic_string&lt;char...</strong></pre>
			<p>Because <a id="_idIndexMarker135"/>the types are easily discernable there is no reason to specify a template parameter like <code>f&lt;int&gt;(47)</code> in the function call. The compiler can deduce the <code>&lt;int&gt;</code> type from the argument.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The above output shows meaningful type names where most compilers will use shorthand, like <code>i</code> for <code>int</code> and <code>PKc</code> for <code>const char *</code>, and so on.</p>
			<ul>
				<li>This works just as well for multiple template parameters:<pre>template&lt;typename T1, typename T2&gt;
string f(<strong class="bold">const T1 </strong>a, <strong class="bold">const T2</strong> b) {
    return format("{} {}", typeid(T1).name(), 
        typeid(T2).name());
}
int main() {
    cout &lt;&lt; format("T1 T2: {}\n", <strong class="bold">f(47, 47L)</strong>);
    cout &lt;&lt; format("T1 T2: {}\n", <strong class="bold">f(47L, 47.0)</strong>);
    cout &lt;&lt; format("T1 T2: {}\n", <strong class="bold">f(47.0, "47")</strong>);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">T1 T2: int long</strong>
<strong class="bold">T1 T2: long double</strong>
<strong class="bold">T1 T2: double char const *</strong></pre>
			<p>Here the compiler is deducing types for both <code>T1</code> and <code>T2</code>.</p>
			<ul>
				<li>Notice that the <a id="_idIndexMarker136"/>types must be compatible with the template. For example, you cannot take a reference from a literal:<pre>template&lt;typename T&gt;
const char * f(const T&amp; a) {
    return typeid(T).name();
}
int main() {
    int x{47};
    f(47);  // this will not compile 
    f(x);   // but this will 
}</pre></li>
				<li>Beginning with C++17 you can also use template parameter deduction with classes. So now this will work:<pre>pair p(47, 47.0);     // deduces to pair&lt;int, double&gt;
tuple t(9, 17, 2.5);  // deduces to tuple&lt;int, int, double&gt;</pre></li>
			</ul>
			<p>This eliminates the need for <code>std::make_pair()</code> and <code>std::make_tuple()</code> as you can now initialize these classes directly without the explicit <a id="_idIndexMarker137"/>template parameters. The <code>std::make_*</code> helper functions will remain available for backward compatibility.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>How it works…</h2>
			<p>Let's define a class so we can see how this works:</p>
			<pre>template&lt;typename T1, typename T2, typename T3&gt;
class Thing {
    T1 v1{};
    T2 v2{};
    T3 v3{};
public:
    explicit Thing(T1 p1, T2 p2, T3 p3)
    : v1{p1}, v2{p2}, v3{p3} {}
    string print() {
        return format("{}, {}, {}\n",
            typeid(v1).name(),
            typeid(v2).name(),
            typeid(v3).name()
        );
    }
};</pre>
			<p>This is a template <a id="_idIndexMarker138"/>class with three types and three corresponding data members. It has a <code>print()</code> function, which returns a formatted string with the three type names.</p>
			<p>Without template parameter deduction, I would have to instantiate an object of this type like this:</p>
			<pre>Things&lt;int, double, string&gt; thing1{1, 47.0, "three" }</pre>
			<p>Now I can do it like this:</p>
			<pre>Things thing1{1, 47.0, "three" }</pre>
			<p>This is both<a id="_idIndexMarker139"/> simpler and less error prone.</p>
			<p>When I call the <code>print()</code> function on the <code>thing1</code> object, I get this result:</p>
			<pre>cout &lt;&lt; thing1.print();</pre>
			<p>Output:</p>
			<pre>int, double, char const *</pre>
			<p>Of course, your compiler may report something effectively similar.</p>
			<p>Before C++17, template parameter deduction didn't apply to classes, so you needed a helper function, which may have looked like this:</p>
			<pre>template&lt;typename T1, typename T2, typename T3&gt;
Things&lt;T1, T2, T3&gt; make_things(T1 p1, T2 p2, T3 p3) {
    return Things&lt;T1, T2, T3&gt;(p1, p2, p3);
}
...
auto thing1(make_things(1, 47.0, "three"));
cout &lt;&lt; thing1.print();</pre>
			<p>Output:</p>
			<pre>int, double, char const *</pre>
			<p>The STL includes a<a id="_idIndexMarker140"/> few of these helper functions, like <code>make_pair()</code> and <code>make_tuple()</code>, etc. These are now obsolescent, but will be maintained for compatibility with older code.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>There's more…</h2>
			<p>Consider the case of a constructor with a parameter pack:</p>
			<pre>template &lt;typename T&gt;
class Sum {
    T v{};
public:
    template &lt;typename... Ts&gt;
    Sum(Ts&amp;&amp; ... values) : v{ (values + ...) } {}
    const T&amp; value() const { return v; }
};</pre>
			<p>Notice the <em class="italic">fold expression</em> in the constructor <code>(values + ...)</code>. This is a C++17 feature that applies an operator to all the members of a parameter pack. In this case, it initializes <code>v</code> to the sum of the parameter pack. </p>
			<p>The constructor for this class accepts an arbitrary number of parameters, where each parameter may be a different class. For example, I could call it like this:</p>
			<pre>Sum s1 { 1u, 2.0, 3, 4.0f };  // unsigned, double, int, 
                              // float
Sum s2 { "abc"s, "def" };     // std::sring, c-string</pre>
			<p>This, of course, doesn't compile. The template argument deduction fails to find a common type for all those different parameters. We get an error message to the effect of:</p>
			<pre>cannot deduce template arguments for 'Sum'</pre>
			<p>We can fix <a id="_idIndexMarker141"/>this with a <em class="italic">template deduction guide</em>. A deduction guide<a id="_idIndexMarker142"/> is a helper pattern to assist the compiler with a complex deduction. Here's a guide for our constructor:</p>
			<pre>template &lt;typename... Ts&gt;
Sum(Ts&amp;&amp; ... ts) -&gt; Sum&lt;std::common_type_t&lt;Ts...&gt;&gt;;</pre>
			<p>This tells the compiler to use the <code>std::common_type_t</code> trait, which attempts to find a common type for all the parameters in the pack. Now our argument deduction works and we can see what types it settled on:</p>
			<pre>Sum s1 { 1u, 2.0, 3, 4.0f };  // unsigned, double, int, 
                              // float
Sum s2 { "abc"s, "def" };     // std::sring, c-string
auto v1 = s1.value();
auto v2 = s2.value();
cout &lt;&lt; format("s1 is {} {}, s2 is {} {}",
        typeid(v1).name(), v1, typeid(v2).name(), v2);</pre>
			<p>Output:</p>
			<pre>s1 is double 10, s2 is class std::string abcdef</pre>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Use if constexpr to simplify compile-time decisions</h1>
			<p>An <code>if constexpr(</code><em class="italic">condition</em><code>)</code> statement <a id="_idIndexMarker143"/>is used where code needs to be executed based on a compile-time condition. The <em class="italic">condition</em> may be any <code>constexpr</code> expression of type <code>bool</code>.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>How to do it…</h2>
			<p>Consider the <a id="_idIndexMarker144"/>case where you have a<a id="_idIndexMarker145"/> template function that needs to operate differently depending upon the type of the template parameter.</p>
			<pre>template&lt;typename T&gt;
auto value_of(const T v) {
    <strong class="bold">if constexpr</strong> (std::is_pointer_v&lt;T&gt;) {
        return <strong class="bold">*v</strong>;  // dereference the pointer
    } else {
        return <strong class="bold">v</strong>;   // return the value
    }
}
int main() {
    <strong class="bold">int</strong> x{47};
    <strong class="bold">int*</strong> y{&amp;x};
    cout &lt;&lt; format("value is {}\n", value_of(x));  // value
    cout &lt;&lt; format("value is {}\n", value_of(y));  
                                                // pointer
    return 0;
}</pre>
			<p>Output:</p>
			<pre>value is 47
value is 47</pre>
			<p>The type of the<a id="_idIndexMarker146"/> template parameter <code>T</code> is <a id="_idIndexMarker147"/>available at compile time. The <code>constexpr if</code> statement allows the code to easily distinguish between a pointer and a value.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>How it works…</h2>
			<p>The <code>constexpr if</code> statement works like a normal <code>if</code> statement except it's evaluated at <em class="italic">compile time</em>. The <em class="italic">runtime code</em> will not contain any branch statements from a <code>constexpr if</code> statement. Consider our branch statement from above:</p>
			<pre>if <strong class="bold">constexpr</strong> (<strong class="bold">std::is_pointer_v&lt;T&gt;</strong>) {
    return *v;  // dereference the pointer
} else {
        return v;   // return the value
    }</pre>
			<p>The <a id="_idIndexMarker148"/>condition <code>is_pointer_v&lt;T&gt;</code> tests a<a id="_idIndexMarker149"/> template parameter, which is not available at runtime. The <code>constexpr</code> keyword tells the compiler that this <code>if</code> statement needs to evaluate at compile time, while the template parameter <code>&lt;T&gt;</code> is available.</p>
			<p>This should make a lot of meta programming situations much easier. The <code>if constexpr</code> statement is available in C++17 and later.</p>
		</div>
	</body></html>