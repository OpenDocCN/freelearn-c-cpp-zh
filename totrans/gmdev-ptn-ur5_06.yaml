- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clean Communication – Interface and Event Observer Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore two design patterns that allow us to improve
    how actors communicate with each other. Utilizing the interface and event observer
    patterns to allow us to build better, cleaner communication solutions, reducing
    memory and processing cost of communication. To explore these, we will expand
    on the RTS game by implementing a health component that can be added to any actor.
    We will start by looking at interfaces in C++, following the concepts of the interface
    design pattern, and then explore the event observer pattern, with an exploration
    of Event Dispatchers in Blueprint and the implementation of event delegates in
    C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing communication across classes in UE5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing event delegate communication across UE5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will bring together the isolated systems we have built in
    previous chapters. Presuming you have followed along, you should be able to tie
    it all together in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to jump straight in at this point, you can download the `chapter6`
    branch from GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter06](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter06)
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing communication across classes in UE5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are a class that facilitates communication between different classes,
    without either class being aware of the other’s type. An interface class holds
    a set of common functions that can be implemented on any class through polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: To abstract this, let’s think about a ridiculous situation where you have a
    stack of pages, and you are asked to verify that it is indeed a copy of *War and
    Peace* that is just missing the cover. The only way to be truly sure is to compare
    each word on every page with a verified copy. This is time-consuming and along
    the lines of what Unreal Engine does when casting a class to another type.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t exactly what the engine does. There are efficiencies built in that
    speed this process up, ensuring that it is not the entire class that is checked,
    but the point still remains that casting can be needless.
  prefs: []
  type: TYPE_NORMAL
- en: If we dig deeper into this hypothetical, knowing why you were asked to verify
    the book’s nature can make a big difference. If it was to verify the book’s integrity,
    then there is no way around it, but if the request was just to see whether a certain
    chapter existed, then we don’t need to do all that much work. Instead, we just
    need to look at the contents page, skip to the requested chapter, and read from
    there. This is what an interface does; it’s like the contents page of a book.
    The book promises that the required chapter will be in the area signposted by
    the contents page.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most-used solutions to build cleaner methods of communication between
    two actors is to implement Blueprint interfaces, which remove the need to cast
    to an actor’s specific class, allowing you to use an actor reference instead.
    Let’s take a deeper look at Blueprint interfaces before we move on to interfaces
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve previously made use of a **Blueprint interface** in [*Chapter 2*](B18297_02.xhtml#_idTextAnchor031)
    while improving the cascading cast chain problem, at which point we created a
    Blueprint interface, set up a function definition, and used it as a callable event
    on the various weapon Blueprints. The event was then called from the character
    Blueprint, allowing it to call the event on an attached weapon (a child actor
    component) without needing to cast the reference to a specific class, improving
    the efficiency of the system as well as reducing the memory impact.
  prefs: []
  type: TYPE_NORMAL
- en: So, from [*Chapter 2*](B18297_02.xhtml#_idTextAnchor031), we already know how
    to create a Blueprint interface, create functions within the interface, and call
    them as events, but let’s look at a few of the features of a Blueprint interface
    that we haven’t encountered yet.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore this using a new interface. Go ahead and create a new Blueprint
    interface asset, and call it `BI_Test`, as this is only a temporary class for
    exploration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Before we add any functions, let’s take a look at the various settings by clicking
    on **Class Settings** from the top menu, which will change the details panel to
    show a range of variables associated with the Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The Blueprint interface Class Settings showing in the Details
    panel](img/Figure_06.01_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The Blueprint interface Class Settings showing in the Details panel
  prefs: []
  type: TYPE_NORMAL
- en: The two most beneficial settings when building systems are **Blueprint Display
    Name** and **Blueprint Description**, as both provide improvements to the user
    experience when working with Blueprint Interfaces. Without these being set, Unreal
    will display only the asset name and provide no description, which, while okay
    for a solo developer in the moment, is less helpful later in development or when
    working with other people.
  prefs: []
  type: TYPE_NORMAL
- en: In order to see the settings working for yourself, we suggest creating and using
    a test Blueprint class, `BP_Test`. This can then be deleted once you are confident
    you understand the settings.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how we set these up and what effect they have on the user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint Display Name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Blueprint Display Name** setting provides a string input to allow you
    to define how the interface appears in the **Class Settings** of a Blueprint class
    when the interface has been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.2 – Class Settings of a Blueprint \uFEFFclass with an implement\
    \ interface with and without a Blueprint Display Name](img/Figure_06.02_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Class Settings of a Blueprint class with an implement interface
    with and without a Blueprint Display Name
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.2* shows the comparison between the class settings of a Blueprint
    class for the end user when implementing an interface with or without a `BI_Test`,
    in the left image, does not have a `implemented interfaces` list when the `BI_Test
    Blueprint` interface has been selected from the **Add** dropdown.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The Blueprint Options rollout of BI_Test with the Blueprint
    Display Name set.](img/Figure_06.03_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The Blueprint Options rollout of BI_Test with the Blueprint Display
    Name set.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us, as systems designers, to maintain core naming conventions whilst
    ensuring that it is always clear what interface has been used in a format suitable
    for designers and other team members.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Blueprint Description** setting provides a string input, allowing you
    to define the mouseover hint when choosing an interface to implement, from the
    **Add** drop-down menu in the class settings of a Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The class settings’ Add dropdown when selecting an interface
    to implement, with a Blueprint description](img/Figure_06.04_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The class settings’ Add dropdown when selecting an interface to
    implement, with a Blueprint description
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.4* shows a comparison between the `BI_Test`, on the left-hand side
    of *Figure 6**.4*, does not have a Blueprint description. On the right-hand side,
    the Blueprint description has been set to `BI_Test` in the **Add** dropdown.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The Blueprint Options rollout of BI_Test with the Blueprint
    Description set](img/Figure_06.05_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The Blueprint Options rollout of BI_Test with the Blueprint Description
    set
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to make it clear, when selecting an interface, what it should
    be used for. The messages can include specifics such as `Required on all classes
    required to interact with doors` or more general messages, such as `Adds functions
    for shooting weapons`. The key here is to make sure the description helps other
    users identify what the interface provides.
  prefs: []
  type: TYPE_NORMAL
- en: Interface events versus functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When adding functions to a Blueprint interface *functions* list, it can result
    in either a function or an event when implemented into a Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `BI_Test` and `BP_Test` classes, we can explore the differences in
    a safe space. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by adding two functions using the `ExampleEvent` and `ExampleFunction`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `ExampleFunction` from the *functions* list, and add an output variable
    to the **Outputs** list by clicking the **+** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new variable `BoolOutput`, and set the type to **Boolean**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will have created both an event, and a function for use in a Blueprint.
    Once you add an output variable, the function will behave as a Blueprint function,
    and without any outputs, it will act as an event.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – An interface function and interface event in a Blueprint class](img/Figure_06.06_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – An interface function and interface event in a Blueprint class
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how the icon is different for a function (a gray icon) and an event (a
    yellow icon). This isn’t the only difference; adding logic to a function works
    differently to an event. Double-clicking on the event will result in an event
    node being added to the **Event Graph**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – An interface event when added to the Event Graph](img/Figure_06.07_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – An interface event when added to the Event Graph
  prefs: []
  type: TYPE_NORMAL
- en: Double-clicking on the function will result in a new tab opening with the function
    graph, including a **Return Node**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – An interface function with Return Node](img/Figure_06.08_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – An interface function with Return Node
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling an interface function or event, they will appear slightly different
    in the Blueprint graph. The main differences are the icon and the inclusion of
    output exec pins (the white outlined arrows on the right-hand side of the node):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – A comparison of interface event and interface Function nodes
    in a Blueprint graph](img/Figure_06.09_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – A comparison of interface event and interface Function nodes in
    a Blueprint graph
  prefs: []
  type: TYPE_NORMAL
- en: There are two other possible visual results for Blueprint nodes from interface
    functions; these are compact nodes that occur when a Blueprint interface function
    has a **Compact** **Node Title**.
  prefs: []
  type: TYPE_NORMAL
- en: To test these out, create two new functions in the `BI_Test` Blueprint interface;
    call these `ExampleCompactedEvent` and `ExampleCompactedFunction`, adding a Boolean
    variable to the output list as before. This time, however, set the Compact Node
    title of each function. For now, duplicate the function names with spaces between
    the words.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.10 – Compacted node examples of an interface event and interface\
    \ \uFEFFfunction on a Blueprint graph](img/Figure_06.10_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Compacted node examples of an interface event and interface function
    on a Blueprint graph
  prefs: []
  type: TYPE_NORMAL
- en: Compact nodes, when placed, appear as shown in *Figure 6**.10*. Compact nodes
    don’t have titles or pin names; these are not commonly used when working in Blueprint
    but are available if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, things get a little weird. The original core of Unreal is closer to
    Objective C than C++, and it shows the most when dealing with interfaces. It is
    advised that interfaces should be made from the editor, as there is so little
    that we need to add to the file from the template that typing it all out from
    scratch is a waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the editor, open the section of your content for C++ classes. Right-click
    and add a new C++ class. When selecting what parent to inherit from, scroll to
    the bottom of the common classes and choose the **Unreal Interface**. This will
    create a new header file, like the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: Unreal interface template project specific elements replaced with tokens
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the template, there are two classes in the same header file.
    The top class is created with your chosen class name, prefixed with a *U*. This
    inherits from the `UInterface` class and allows your class to become part of the
    Unreal interface system, working with functions such as `UKismetSystemLibrary::DoesImplementInterface`.
    The second class extends your module and has a similar name, except it starts
    with an *I* instead. This is the class you should add public functions to and
    multi-inherit from.
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling a function from an interface, it is assumed that the reference
    held is not for the correct type of class and, instead, is most likely an `AActor*`.
    If this is not the case, then the interface provides no benefit, and the communication
    strategy should be rethought. Unreal provides a few ways of calling functions
    via interfaces. The two main methods are casting to the interface as a type and
    calling the instance of the function, or statically calling the function. Casting
    to the interface type is exactly as it sounds and would involve something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `Cast` returns the casted pointer and a boolean value for the
    `if` statement. This works because an `if` on a pointer in Unreal will automatically
    check whether the pointer is not `nullptr`. However, it does still use a cast,
    no matter how small it may be. It is faster to use a static function call such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this gets to the function call much faster and with less temporary
    variables declared. The trade-off is the security of the call. In this method,
    we assume that `actorRef` implements the interface that we call the function from.
    This assumption means that if the class in question doesn’t implement the needed
    interface we will get a logic error. The solution is to either design in a way
    that avoids this situation or to check for the interface without casting to it,
    using the aforementioned `DoesImplementInterface` function in `UKismetSystemLibrary`.
  prefs: []
  type: TYPE_NORMAL
- en: So, with these general concepts in mind, let’s look at creating our own interface
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Building an example interface communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement something like the preceding example where actors can be flammable,
    we can start with an interface called `IFlammable` that will need a public virtual
    function called `Ignite`. This would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Iflammable.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement this in other classes, you simply need to use polymorphism and
    override the interface functions. The following example shows a tree actor multi-inheriting
    from the interface to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: Excerpt from possible example flammable interface usage Tree.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On the calling side, if we had a flaming torch, we could add the following
    code to the collision handler for a collider around the flame particle:'
  prefs: []
  type: TYPE_NORMAL
- en: Excerpt from possible flammable interface usage
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code will let the torch ignite anything that is flammable and ignore everything
    that is not, without causing any errors or needing to do any unnecessary casting.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces, both in Blueprint and C++, offer us key benefits in keeping communication
    clean and efficient, allowing us to bundle up function names for use on implementing
    classes. Now that we’ve explored the benefits and the process to create both types
    of interface, we can look at another anonymous communication method – events.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing event delegate communication across UE5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other form of anonymous communication is the event delegate. Delegates are
    essentially function pointers that allow us to change the flow of logic dynamically
    at runtime. When invoked, they allow a signal to be sent to potentially several
    other parts of a program, without the sender knowing where the signal has gone.
    Using these as part of an event-driven approach is called an event delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Event delegates can be compared to a radio station. The delegate exists as the
    station, transmitting a signal into the air when it is told to. Then, there are
    radios that can choose to subscribe to the station, receiving the signal. This
    forms a one-to-many relationship, with one-way communication. The radios cannot
    send messages back to the station, and the station does not know how many radios
    are tuned in.
  prefs: []
  type: TYPE_NORMAL
- en: Like when we explored interfaces, let’s begin with the Blueprint implementation
    before moving on to the more complex C++ approach.
  prefs: []
  type: TYPE_NORMAL
- en: Event delegates in Blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Blueprint, delegates are made simple with one variant exposed. These are
    called Event Dispatchers. They do, however, function in the expected way.
  prefs: []
  type: TYPE_NORMAL
- en: Event Dispatchers need to be created in the class that will do the broadcasting
    (the radio station as such). We do this by clicking the **+** symbol in the **EVENT
    DISPATCHERS** dropdown of the **My** **Blueprint** tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – The Event Dispatchers rollout within the My Blueprint tab](img/Figure_06.11_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – The Event Dispatchers rollout within the My Blueprint tab
  prefs: []
  type: TYPE_NORMAL
- en: An Event Dispatcher can have a series of inputs like any event in Blueprint.
    These are added at the top of the **Details** tab. You can also use the **Copy
    signature from**dropdown to select an existing event in the current Blueprint.
    This will duplicate all of the inputs from that event in the Event Dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.12 – Event Dispatcher variables and the Copy \uFEFFsignature\uFEFF\
    \ from dropdown](img/Figure_06.12_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Event Dispatcher variables and the Copy signature from dropdown
  prefs: []
  type: TYPE_NORMAL
- en: A Blueprint can respond to its own dispatcher in the same way that any listening
    delegate can respond. The dispatcher needs to be bound to an event, which then
    performs the desired response.
  prefs: []
  type: TYPE_NORMAL
- en: This is why, if you drag and drop the dispatcher from the Event Dispatchers
    list, onto the Blueprint graph, you will be presented with a popup containing
    **Call**, **Bind**, **Unbind**, **Unbind all**, **Event**, and **Assign**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – The Event Dispatcher popup when dragged onto the Blueprint
    graph](img/Figure_06.13_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – The Event Dispatcher popup when dragged onto the Blueprint graph
  prefs: []
  type: TYPE_NORMAL
- en: These options are available wherever you choose to respond to a dispatcher (with
    the exception of an event). However, you will typically access them via the normal
    popup to create Blueprint nodes when dragging out from an object, which holds
    the dispatcher as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – The Blueprint context popup when searching for an Event Dispatcher
    by name, after dragging from a reference to a class that holds the Event Dispatcher](img/Figure_06.14_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – The Blueprint context popup when searching for an Event Dispatcher
    by name, after dragging from a reference to a class that holds the Event Dispatcher
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore each of the options we are presented with from these popups so
    that you know when and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Call
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Call** option activates the Event Dispatcher, sending the message to any
    subscribed delegates that are listening for the event. This is typically used
    on the Blueprint that has the event, but can be called from a separate Blueprint
    that has a direct reference to the actor with the dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – A call dispatcher node with two variable inputs (Float and
    Bool)](img/Figure_06.15_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – A call dispatcher node with two variable inputs (Float and Bool)
  prefs: []
  type: TYPE_NORMAL
- en: The **Bind** option is used to identify which event should be run when the dispatcher
    is called; when used, the associated event is added to the list of events associated
    with the dispatcher. In Blueprint, the red line between the **Bind Event to**
    node and the **Event** node indicates which event it is to be bound to.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.16 – A bind event node connected to a custom event \uFEFFthat will\
    \ be run when the Event Dispatcher is called](img/Figure_06.16_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – A bind event node connected to a custom event that will be run
    when the Event Dispatcher is called
  prefs: []
  type: TYPE_NORMAL
- en: This can be replaced by using a **Create Event** node, which can create a function
    or event with a matching signature (the same variables) or point toward an existing
    event. These are often used to try to keep the Blueprint graph tidy but are required
    to link to a function, as opposed to an event.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17–A bind event node connected to a Create Event node](img/Figure_06.17_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17–A bind event node connected to a Create Event node
  prefs: []
  type: TYPE_NORMAL
- en: Unbind and Unbind all
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Unbind** node does the opposite of the bind node. When using **Unbind**,
    the event is removed from the list of events associated with the Event Dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: The **Unbind all** option does the same, but instead of just removing the linked
    event, it removes all events, nullifying the dispatcher from communicating with
    anything until another event is associated using a bind event node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – The Unbind Event node, connected to a custom event, and an
    Unbind all Events node](img/Figure_06.18_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – The Unbind Event node, connected to a custom event, and an Unbind
    all Events node
  prefs: []
  type: TYPE_NORMAL
- en: The **Bind** and **Unbind** nodes allow us to dynamically link and unlink different
    events or functions to an Event Dispatcher, allowing us full control over what
    responds to a dispatcher at any point in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Event and Assign
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Event** and **Assign** options exist to help you create the nodes required
    to respond to an Event Dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: The **Event** option creates a **Custom Event** node with a matching signature,
    ready for you to connect to a bind event node later.
  prefs: []
  type: TYPE_NORMAL
- en: The **Assign** option creates both the Bind Event node and the matching custom
    event node, which can save a little bit of time when creating Blueprint logic.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a grasp of the Blueprint implementation of events, let’s move
    on to exploring the C++ implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Event delegates in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++, event delegates are a little more complicated, but with that comes
    more control. For starters, there are a few different properties you can give
    each delegate before making events out of it. Let’s take a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DYNAMIC`: This delegate can be serialized into the editor for easy Blueprint
    binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MULTICAST`: This delegate can have multiple listeners at once and removes
    the ability to have a return value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPARSE`: This delegate will not take up 1 byte in memory until it is subscribed
    to (this does make it slower to use, but it is more efficient for delegates that
    are rarely bound, such as a marketplace tool)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After deciding how the delegate should behave, you need to declare it as a
    new type. This is described by the following pattern in all caps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DECLARE_<properties>_DELEGATE_<parameter amount>(<TypeName>, <arg1 type>,
    <arg1` `name>… );`'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FExampleSignature, float, number,`
    `AActor*, actorRef);`'
  prefs: []
  type: TYPE_NORMAL
- en: This delegate will be serialized into the editor, with possibly multiple bound
    functions. Each bound function will have two arguments of type `float` and `AActor*`.
    This is the closest in behavior to a Blueprint Event Dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another type of delegate called an event. This is a version of
    a multicast delegate, where the first argument is the owning type, only that type
    can have events as members, and only the defining object can broadcast the events.
    With this extra security, you can expose events as public without fear that a
    different class will broadcast the event. However, with that comes extra design
    challenges to make your systems work in a clean manner.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, all event delegates used will be dynamic multicast to avoid
    confusion. This is not necessarily the best strategy, but it is a good starting
    point to then modify and restrict behavior later as needed.
  prefs: []
  type: TYPE_NORMAL
- en: That is how to define a new delegate type and create a new instance of a delegate
    from the type. To make delegates do something, you also need to know how to bind
    functions to them and fire them. This will change, depending on what properties
    were given to the event in it’s declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working our way through the different properties that a delegate has, we can
    see that non-dynamic delegates have eight different functions that can bind listening
    functions to them for each single and multicast. It is recommended that you use
    the `BindUObject` function for single-cast delegates and the `AddUObject` function
    for multicast delegates. These both take a reference `UObject*` as a first argument
    and a function address as the second, in the style: `&ClassName::FunctionName`.'
  prefs: []
  type: TYPE_NORMAL
- en: For dynamic delegates, there is less choice; single-cast dynamic delegates should
    use the `BindDynamic` function, and for multicast, it is advised you use the `AddUniqueDynamic`
    function, both with the same arguments as the non-dynamic delegates mentioned
    previously. The `AddDynamic()` function is ok to use with multicast dynamic delegates
    if you know the instance of the function has not already been bound to this delegate,
    otherwise it can be bound multiple times to the same event dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to call delegates if they are single-cast, you should use the `ExecuteIfBound()`
    member function on the delegate, passing through arguments as necessary. For any
    multicast delegates, use the `Broadcast` member function. We will use a lot of
    multicast dynamic delegates when prototyping, as they offer the greatest flexibility
    to hook more listeners in as needed, leading us to make heavy use of the `Broadcast`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: With the core concepts of delegates in C++ covered, let’s move on to creating
    our own event delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Building a useful delegate tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s now look at building a useful class you can drop into any project. We
    will build on top of the damage system already present inside Unreal Engine. This
    utilizes a combination of an interface and the polymorphic nature of the engine,
    allowing you to deal damage to any actor and respond to damage from any actor.
    As an extension, we will look at making a Health Component that can sit on any
    actor, bind itself into this damage system automatically, and provide a couple
    of useful endpoints for any gameplay system to run with.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we need a new C++ class, so head to your C++ folder in the editor
    and make a new class based on **Actor Component**. Actor components are components
    for logic, as they have no associated rendering or transform within the world.
  prefs: []
  type: TYPE_NORMAL
- en: Useful tip
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Rider 2022 or later, then a right-click on your module base
    folder will give you the option to **Add an Unreal Class**. In the popup, you
    can select an actor component, and it will function the same way but without the
    need for the engine to be running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to think about is what delegate definitions we will need. The
    obvious one is for when the component has run out of health and needs to let the
    owning actor know that it has died. This could probably pass through a reference
    to the controller that instigated the chain so that, eventually, the game mode
    can attribute points to the correct controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next useful piece of information to pass out to the component would be
    a signal whenever damage is dealt. There are a lot of options for what data to
    pass through. For instance, if the target is more of a *Call of Duty*-style game,
    you probably want to know what direction the damage was received from to feed
    that back to the player via some form of UI. In this instance, we will pass through
    information about the new and maximum health values, along with the change that
    just happened. This will let us update UI health bars and possibly spawn some
    damage numbers into the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then look at the header definitions. The only items that need to be
    public are the constructor and one of each delegate type declared previously.
    In the protected section, we need some float variables to track the current and
    maximum health. These are marked as protected so that the reflection specified
    in the `UPROPERTY` tag will work with the editor. Along with these, we’ll use
    a `BeginPlay` override to set up some automatic behavior. Lastly, we’ll add a
    handler function to the private section. This will be used to hook into the damage
    interface system already present inside the actor this component is attached to.
    With that all written out, the class definition should look a little like this:'
  prefs: []
  type: TYPE_NORMAL
- en: HealthComponent.h class definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After generating the definitions for these functions, we can add a default
    value for `maxHealth` into the constructor of maybe `100.f`, but this line isn’t
    too important. The `BeginPlay` override needs to bind our private `DamageTaken`
    function to the `OnTakeAnyDamage` event of the owning actor it is attached to,
    as well as setting the initial value for `_CurrentHealth`:'
  prefs: []
  type: TYPE_NORMAL
- en: HealthComponent.cpp Constructor and BeginPlay
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the logic for how damage is taken and how the events are fired will all
    go into the `DamageTaken` function. Note the use of `FMath::Min` to make sure
    the damage received never goes beyond the amount of health remaining. This could
    be easily altered to allow for *Doom*-style forgiveness mechanics, where the player
    cannot be taken from >1% health to 0% in one hit and can only die from 1% health.
    Alternatively, it could be removed to allow for overkill calculations if that
    matters for gameplay:'
  prefs: []
  type: TYPE_NORMAL
- en: HealthComponent.cpp DamageTaken function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To make use of this component, you can now go to any actor and add this component
    to its hierarchy. It will automatically bind itself, and we have built in two
    events that can be bound to Blueprint and C++ functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the example project, add the health component to the enemy unit **Blueprint
    Editor**. Create a listener for the **OnHealthDead** event by selecting the new
    component in the **Hierarchy** panel and clicking the plus button next to the
    event in the **Details** > **Events** panel.
  prefs: []
  type: TYPE_NORMAL
- en: Link up the Blueprint functions in the red comment block marked **Handle Unit
    Death** as shown in *Figure 6**.19*, and you will see that because the player
    has been built with the damage system in mind, you can now move about and destroy
    enemy units.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19  – The fully linked up event](img/Figure_06.19_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – The fully linked up event
  prefs: []
  type: TYPE_NORMAL
- en: This functional example shows how event delegates can be used to communicate
    anonymously, thereby removing the need for object references everywhere. Using
    this communication method effectively helps to reduce the coupling of code bases,
    making them easier to maintain over time as more are added.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the two main methods of cleaning up communication in a code
    base. We have covered functional examples of how to use both interfaces and event
    delegates within our C++ setup, as well as the technical setup, using the `U`
    and `I` prefixes of an interface properly, and what each of the characteristics
    of a delegate mean. Now that the functional understanding is sorted, the next
    step should be to practice with these tools to get a better understanding of how
    they affect the code base. We will do this in the next chapter by looking at how
    we deploy both interfaces and event delegates with function calls, achieving a
    perfectly decoupled system where communication is as anonymous as possible. This
    naturally creates modular code design, allowing for much easier cohesion within
    teams.
  prefs: []
  type: TYPE_NORMAL
