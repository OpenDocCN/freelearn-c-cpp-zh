- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Clean Communication – Interface and Event Observer Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁通信 – 接口和事件观察者模式
- en: In this chapter, we will explore two design patterns that allow us to improve
    how actors communicate with each other. Utilizing the interface and event observer
    patterns to allow us to build better, cleaner communication solutions, reducing
    memory and processing cost of communication. To explore these, we will expand
    on the RTS game by implementing a health component that can be added to any actor.
    We will start by looking at interfaces in C++, following the concepts of the interface
    design pattern, and then explore the event observer pattern, with an exploration
    of Event Dispatchers in Blueprint and the implementation of event delegates in
    C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两种设计模式，这些模式使我们能够改进演员之间如何相互通信。利用接口和事件观察者模式，我们可以构建更好、更干净的通信解决方案，从而降低通信的内存和处理成本。为了探索这些模式，我们将通过实现一个可以添加到任何演员的健康组件来扩展RTS游戏。我们将从查看C++中的接口开始，遵循接口设计模式的概念，然后探索事件观察者模式，包括在蓝图中的事件调度器和C++中的事件委托实现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Interfacing communication across classes in UE5
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UE5中跨类进行通信接口
- en: Implementing event delegate communication across UE5
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UE5中实现事件委托通信
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will bring together the isolated systems we have built in
    previous chapters. Presuming you have followed along, you should be able to tie
    it all together in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将汇集我们在前几章中构建的孤立系统。假设你一直跟随着，你应该能够在本章中将它们全部联系起来。
- en: If you want to jump straight in at this point, you can download the `chapter6`
    branch from GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter06](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter06)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要直接进入这个阶段，你可以从GitHub下载`chapter6`分支，网址为[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter06](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter06)
- en: Interfacing communication across classes in UE5
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在UE5中跨类进行通信接口
- en: Interfaces are a class that facilitates communication between different classes,
    without either class being aware of the other’s type. An interface class holds
    a set of common functions that can be implemented on any class through polymorphism.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一种促进不同类之间通信的类，而无需任何类知道另一个类的类型。接口类包含一组可以在任何类上通过多态实现的通用函数。
- en: To abstract this, let’s think about a ridiculous situation where you have a
    stack of pages, and you are asked to verify that it is indeed a copy of *War and
    Peace* that is just missing the cover. The only way to be truly sure is to compare
    each word on every page with a verified copy. This is time-consuming and along
    the lines of what Unreal Engine does when casting a class to another type.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了抽象化这一点，让我们考虑一个荒谬的情况，你有一摞页面，有人要求你验证它确实是一份缺少封面的*《战争与和平》*副本。真正确信的唯一方法是将每一页上的每个单词与经过验证的副本进行比较。这是耗时且与虚幻引擎在将类强制转换为其他类型时所做的类似。
- en: Important note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This isn’t exactly what the engine does. There are efficiencies built in that
    speed this process up, ensuring that it is not the entire class that is checked,
    but the point still remains that casting can be needless.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是引擎所做的。其中内置了一些效率，可以加快这个过程，确保不是整个类被检查，但这个观点仍然成立，即强制转换可能是多余的。
- en: If we dig deeper into this hypothetical, knowing why you were asked to verify
    the book’s nature can make a big difference. If it was to verify the book’s integrity,
    then there is no way around it, but if the request was just to see whether a certain
    chapter existed, then we don’t need to do all that much work. Instead, we just
    need to look at the contents page, skip to the requested chapter, and read from
    there. This is what an interface does; it’s like the contents page of a book.
    The book promises that the required chapter will be in the area signposted by
    the contents page.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们深入这个假设，了解为什么要求你验证书籍的性质可以有很大差别。如果是为了验证书籍的完整性，那么就没有其他办法了，但如果请求只是为了看看是否有特定的章节，那么我们就不需要做那么多工作。我们只需查看目录页，跳到请求的章节，然后从那里开始阅读。这就是接口的作用；它就像一本书的目录页。书籍承诺所需的章节将出现在目录页标记的区域。
- en: One of the most-used solutions to build cleaner methods of communication between
    two actors is to implement Blueprint interfaces, which remove the need to cast
    to an actor’s specific class, allowing you to use an actor reference instead.
    Let’s take a deeper look at Blueprint interfaces before we move on to interfaces
    in C++.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建两个参与者之间更清洁的通信方法的最常用解决方案之一是实施蓝图接口，这消除了将类型强制转换为参与者特定类的需求，允许你使用参与者引用代替。在我们继续探讨
    C++ 中的接口之前，让我们先深入了解一下蓝图接口。
- en: Blueprint interfaces
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝图接口
- en: We’ve previously made use of a **Blueprint interface** in [*Chapter 2*](B18297_02.xhtml#_idTextAnchor031)
    while improving the cascading cast chain problem, at which point we created a
    Blueprint interface, set up a function definition, and used it as a callable event
    on the various weapon Blueprints. The event was then called from the character
    Blueprint, allowing it to call the event on an attached weapon (a child actor
    component) without needing to cast the reference to a specific class, improving
    the efficiency of the system as well as reducing the memory impact.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在改善级联强制转换链问题时，在[*第 2 章*](B18297_02.xhtml#_idTextAnchor031)中已经使用了一个**蓝图接口**，在那个时刻我们创建了一个蓝图接口，设置了一个函数定义，并将其用作各种武器蓝图的可调用事件。然后，从角色蓝图调用该事件，允许它调用附加武器（子参与者组件）的事件，而不需要将引用强制转换为特定类，这提高了系统的效率，同时也减少了内存影响。
- en: So, from [*Chapter 2*](B18297_02.xhtml#_idTextAnchor031), we already know how
    to create a Blueprint interface, create functions within the interface, and call
    them as events, but let’s look at a few of the features of a Blueprint interface
    that we haven’t encountered yet.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从[*第 2 章*](B18297_02.xhtml#_idTextAnchor031)中，我们已经知道如何创建蓝图接口，在接口内创建函数，并将它们作为事件调用，但让我们看看一些我们尚未遇到的蓝图接口的特性。
- en: Let’s explore this using a new interface. Go ahead and create a new Blueprint
    interface asset, and call it `BI_Test`, as this is only a temporary class for
    exploration purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个新的接口来探索这个问题。请创建一个新的蓝图接口资产，并将其命名为 `BI_Test`，因为这个类只是为了探索目的而临时创建的。
- en: Before we add any functions, let’s take a look at the various settings by clicking
    on **Class Settings** from the top menu, which will change the details panel to
    show a range of variables associated with the Blueprint class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加任何函数之前，让我们通过点击顶部菜单中的**类设置**来查看各种设置，这将更改详细信息面板以显示与蓝图类相关的一系列变量。
- en: '![Figure 6.1 – The Blueprint interface Class Settings showing in the Details
    panel](img/Figure_06.01_B18297.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 蓝图接口类设置在详细信息面板中显示](img/Figure_06.01_B18297.jpg)'
- en: Figure 6.1 – The Blueprint interface Class Settings showing in the Details panel
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 蓝图接口类设置在详细信息面板中显示
- en: The two most beneficial settings when building systems are **Blueprint Display
    Name** and **Blueprint Description**, as both provide improvements to the user
    experience when working with Blueprint Interfaces. Without these being set, Unreal
    will display only the asset name and provide no description, which, while okay
    for a solo developer in the moment, is less helpful later in development or when
    working with other people.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建系统时，最有益的设置是**蓝图显示名称**和**蓝图描述**，因为两者都提供了在使用蓝图接口时的用户体验改进。如果没有设置这些，Unreal 将仅显示资产名称，并提供无描述信息，这对于当前的单人开发者来说可能没问题，但在开发后期或与他人合作时则不太有帮助。
- en: In order to see the settings working for yourself, we suggest creating and using
    a test Blueprint class, `BP_Test`. This can then be deleted once you are confident
    you understand the settings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了亲自看到设置的效果，我们建议创建并使用一个测试蓝图类，`BP_Test`。一旦你确信你理解了设置，就可以将其删除。
- en: Let’s take a look at how we set these up and what effect they have on the user
    experience.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何设置这些，以及它们对用户体验有何影响。
- en: Blueprint Display Name
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝图显示名称
- en: The **Blueprint Display Name** setting provides a string input to allow you
    to define how the interface appears in the **Class Settings** of a Blueprint class
    when the interface has been implemented.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝图显示名称**设置提供了一个字符串输入，允许你定义当接口实现时，在蓝图类的**类设置**中接口如何显示。'
- en: "![Figure 6.2 – Class Settings of a Blueprint \uFEFFclass with an implement\
    \ interface with and without a Blueprint Display Name](img/Figure_06.02_B18297.jpg)"
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 具有和没有蓝图显示名称的蓝图类实现接口的类设置](img/Figure_06.02_B18297.jpg)'
- en: Figure 6.2 – Class Settings of a Blueprint class with an implement interface
    with and without a Blueprint Display Name
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 具有和没有蓝图显示名称的蓝图类实现接口的类设置
- en: '*Figure 6**.2* shows the comparison between the class settings of a Blueprint
    class for the end user when implementing an interface with or without a `BI_Test`,
    in the left image, does not have a `implemented interfaces` list when the `BI_Test
    Blueprint` interface has been selected from the **Add** dropdown.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.2* 展示了当在左侧图像中实现接口时，带有或没有 `BI_Test` 的蓝图类设置之间的比较。当从 **添加** 下拉菜单中选择 `BI_Test
    蓝图` 接口时，没有 `已实现接口` 列表。'
- en: '![Figure 6.3 – The Blueprint Options rollout of BI_Test with the Blueprint
    Display Name set.](img/Figure_06.03_B18297.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 设置了蓝图显示名称的 BI_Test 的蓝图选项展开视图。](img/Figure_06.03_B18297.jpg)'
- en: Figure 6.3 – The Blueprint Options rollout of BI_Test with the Blueprint Display
    Name set.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 设置了蓝图显示名称的 BI_Test 的蓝图选项展开视图。
- en: This allows us, as systems designers, to maintain core naming conventions whilst
    ensuring that it is always clear what interface has been used in a format suitable
    for designers and other team members.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们作为系统设计师，在保持核心命名约定的同时，确保接口的格式对设计师和其他团队成员始终清晰可见。
- en: Blueprint Description
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝图描述
- en: The **Blueprint Description** setting provides a string input, allowing you
    to define the mouseover hint when choosing an interface to implement, from the
    **Add** drop-down menu in the class settings of a Blueprint class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝图描述** 设置提供了一个字符串输入，允许您在从蓝图类的类设置中的 **添加** 下拉菜单选择要实现的接口时定义鼠标悬停提示。'
- en: '![Figure 6.4 – The class settings’ Add dropdown when selecting an interface
    to implement, with a Blueprint description](img/Figure_06.04_B18297.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 选择要实现的接口时，类设置中的添加下拉菜单，带有蓝图描述](img/Figure_06.04_B18297.jpg)'
- en: Figure 6.4 – The class settings’ Add dropdown when selecting an interface to
    implement, with a Blueprint description
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 选择要实现的接口时，类设置中的添加下拉菜单，带有蓝图描述
- en: '*Figure 6**.4* shows a comparison between the `BI_Test`, on the left-hand side
    of *Figure 6**.4*, does not have a Blueprint description. On the right-hand side,
    the Blueprint description has been set to `BI_Test` in the **Add** dropdown.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.4* 展示了在 *图 6.4* 的左侧，`BI_Test` 没有蓝图描述。在右侧，蓝图描述已设置为 `BI_Test`，在 **添加** 下拉菜单中。'
- en: '![Figure 6.5 – The Blueprint Options rollout of BI_Test with the Blueprint
    Description set](img/Figure_06.05_B18297.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 设置了蓝图描述的 BI_Test 的蓝图选项展开视图](img/Figure_06.05_B18297.jpg)'
- en: Figure 6.5 – The Blueprint Options rollout of BI_Test with the Blueprint Description
    set
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 设置了蓝图描述的 BI_Test 的蓝图选项展开视图
- en: This allows us to make it clear, when selecting an interface, what it should
    be used for. The messages can include specifics such as `Required on all classes
    required to interact with doors` or more general messages, such as `Adds functions
    for shooting weapons`. The key here is to make sure the description helps other
    users identify what the interface provides.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在选择接口时，我们可以清楚地知道它应该用于什么。消息可以包括具体信息，例如 `Required on all classes required to
    interact with doors` 或更一般的消息，例如 `Adds functions for shooting weapons`。关键是要确保描述有助于其他用户识别接口提供的内容。
- en: Interface events versus functions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口事件与函数
- en: When adding functions to a Blueprint interface *functions* list, it can result
    in either a function or an event when implemented into a Blueprint class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当向蓝图接口的 *functions* 列表中添加函数时，将其实现到蓝图类中时可能会产生一个函数或一个事件。
- en: 'Using the `BI_Test` and `BP_Test` classes, we can explore the differences in
    a safe space. Let’s begin:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `BI_Test` 和 `BP_Test` 类，我们可以在一个安全的空间中探索它们之间的差异。让我们开始：
- en: Let’s start by adding two functions using the `ExampleEvent` and `ExampleFunction`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从使用 `ExampleEvent` 和 `ExampleFunction` 添加两个函数开始。
- en: Select `ExampleFunction` from the *functions* list, and add an output variable
    to the **Outputs** list by clicking the **+** icon.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *函数* 列表中选择 `ExampleFunction`，并通过点击 **+** 图标将输出变量添加到 **输出** 列表中。
- en: Name the new variable `BoolOutput`, and set the type to **Boolean**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新变量命名为 `BoolOutput`，并将类型设置为 **布尔型**。
- en: This will have created both an event, and a function for use in a Blueprint.
    Once you add an output variable, the function will behave as a Blueprint function,
    and without any outputs, it will act as an event.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个事件和一个用于蓝图的功能。一旦添加了输出变量，该函数将作为蓝图函数运行，如果没有输出，它将作为事件运行。
- en: '![Figure 6.6 – An interface function and interface event in a Blueprint class](img/Figure_06.06_B18297.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 蓝图类中的一个接口函数和接口事件](img/Figure_06.06_B18297.jpg)'
- en: Figure 6.6 – An interface function and interface event in a Blueprint class
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 蓝图类中的接口函数和接口事件
- en: 'Note how the icon is different for a function (a gray icon) and an event (a
    yellow icon). This isn’t the only difference; adding logic to a function works
    differently to an event. Double-clicking on the event will result in an event
    node being added to the **Event Graph**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数（灰色图标）和事件（黄色图标）的图标是不同的。这还不是唯一的区别；向函数添加逻辑的方式与事件不同。双击事件将在**事件图**中添加一个事件节点：
- en: '![Figure 6.7 – An interface event when added to the Event Graph](img/Figure_06.07_B18297.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 接口事件添加到事件图时的情况](img/Figure_06.07_B18297.jpg)'
- en: Figure 6.7 – An interface event when added to the Event Graph
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 接口事件添加到事件图时的情况
- en: Double-clicking on the function will result in a new tab opening with the function
    graph, including a **Return Node**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 双击函数将在新标签页中打开函数图，包括一个**返回节点**。
- en: '![Figure 6.8 – An interface function with Return Node](img/Figure_06.08_B18297.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 带有返回节点的接口函数](img/Figure_06.08_B18297.jpg)'
- en: Figure 6.8 – An interface function with Return Node
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 带有返回节点的接口函数
- en: 'When calling an interface function or event, they will appear slightly different
    in the Blueprint graph. The main differences are the icon and the inclusion of
    output exec pins (the white outlined arrows on the right-hand side of the node):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用接口函数或事件时，它们在蓝图图中会略有不同。主要区别是图标和包含输出执行引脚（节点右侧的白色轮廓箭头）：
- en: '![Figure 6.9 – A comparison of interface event and interface Function nodes
    in a Blueprint graph](img/Figure_06.09_B18297.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 蓝图图中接口事件和接口功能节点的比较](img/Figure_06.09_B18297.jpg)'
- en: Figure 6.9 – A comparison of interface event and interface Function nodes in
    a Blueprint graph
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 蓝图图中接口事件和接口功能节点的比较
- en: There are two other possible visual results for Blueprint nodes from interface
    functions; these are compact nodes that occur when a Blueprint interface function
    has a **Compact** **Node Title**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从接口函数生成的蓝图节点还有两种可能的视觉结果；这些是在蓝图接口函数具有**紧凑****节点标题**时出现的紧凑节点。
- en: To test these out, create two new functions in the `BI_Test` Blueprint interface;
    call these `ExampleCompactedEvent` and `ExampleCompactedFunction`, adding a Boolean
    variable to the output list as before. This time, however, set the Compact Node
    title of each function. For now, duplicate the function names with spaces between
    the words.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这些，请在 `BI_Test` 蓝图接口中创建两个新函数；将这些函数命名为 `ExampleCompactedEvent` 和 `ExampleCompactedFunction`，在输出列表中添加一个布尔变量，就像之前一样。然而，这次，设置每个函数的紧凑节点标题。目前，请将函数名称重复一遍，并在单词之间留空格。
- en: "![Figure 6.10 – Compacted node examples of an interface event and interface\
    \ \uFEFFfunction on a Blueprint graph](img/Figure_06.10_B18297.jpg)"
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 蓝图图中接口事件和接口功能的紧凑节点示例](img/Figure_06.10_B18297.jpg)'
- en: Figure 6.10 – Compacted node examples of an interface event and interface function
    on a Blueprint graph
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 蓝图图中接口事件和接口功能的紧凑节点示例
- en: Compact nodes, when placed, appear as shown in *Figure 6**.10*. Compact nodes
    don’t have titles or pin names; these are not commonly used when working in Blueprint
    but are available if desired.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑节点放置时，如图 *图 6*.10* 所示。紧凑节点没有标题或引脚名称；在 Blueprint 中工作时不常用，但如果需要则可用。
- en: Interfaces in C++
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 中的接口
- en: In C++, things get a little weird. The original core of Unreal is closer to
    Objective C than C++, and it shows the most when dealing with interfaces. It is
    advised that interfaces should be made from the editor, as there is so little
    that we need to add to the file from the template that typing it all out from
    scratch is a waste of time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，事情变得有点奇怪。Unreal 的原始核心更接近 Objective C 而不是 C++，这在处理接口时表现得最为明显。建议从编辑器创建接口，因为从模板中添加到文件中的内容很少，从头开始全部输入是浪费时间。
- en: 'In the editor, open the section of your content for C++ classes. Right-click
    and add a new C++ class. When selecting what parent to inherit from, scroll to
    the bottom of the common classes and choose the **Unreal Interface**. This will
    create a new header file, like the following template:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中，打开您的 C++ 类内容部分。右键单击并添加一个新的 C++ 类。在选择要继承的父类时，滚动到底部的常用类并选择**Unreal 接口**。这将创建一个新的头文件，如下面的模板所示：
- en: Unreal interface template project specific elements replaced with tokens
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal 接口模板项目特定元素被替换为占位符
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the template, there are two classes in the same header file.
    The top class is created with your chosen class name, prefixed with a *U*. This
    inherits from the `UInterface` class and allows your class to become part of the
    Unreal interface system, working with functions such as `UKismetSystemLibrary::DoesImplementInterface`.
    The second class extends your module and has a similar name, except it starts
    with an *I* instead. This is the class you should add public functions to and
    multi-inherit from.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在模板中看到的，同一个头文件中有两个类。顶部的类使用您选择的类名创建，前面加一个 *U*。这个类从 `UInterface` 类继承，允许您的类成为
    Unreal 接口系统的一部分，与 `UKismetSystemLibrary::DoesImplementInterface` 等函数一起工作。第二个类扩展了您的模块，具有类似的名字，但以一个
    *I* 开头。这是您应该添加公共函数并从中多继承的类。
- en: 'When calling a function from an interface, it is assumed that the reference
    held is not for the correct type of class and, instead, is most likely an `AActor*`.
    If this is not the case, then the interface provides no benefit, and the communication
    strategy should be rethought. Unreal provides a few ways of calling functions
    via interfaces. The two main methods are casting to the interface as a type and
    calling the instance of the function, or statically calling the function. Casting
    to the interface type is exactly as it sounds and would involve something like
    this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当从一个接口调用函数时，假设持有的引用不是正确的类类型，而是最可能是一个 `AActor*`。如果不是这种情况，那么接口就没有任何好处，应该重新思考通信策略。Unreal
    提供了一些通过接口调用函数的方法。两种主要方法是将接口作为类型进行转换并调用函数实例，或者静态调用函数。将接口类型进行转换正好如其名，会涉及以下内容：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note how the `Cast` returns the casted pointer and a boolean value for the
    `if` statement. This works because an `if` on a pointer in Unreal will automatically
    check whether the pointer is not `nullptr`. However, it does still use a cast,
    no matter how small it may be. It is faster to use a static function call such
    as the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Cast` 返回转换后的指针和布尔值，用于 `if` 语句。这是因为 Unreal 中的指针 `if` 会自动检查指针是否不是 `nullptr`。然而，它仍然使用了一个转换，无论转换多小。使用以下静态函数调用会更快：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this gets to the function call much faster and with less temporary
    variables declared. The trade-off is the security of the call. In this method,
    we assume that `actorRef` implements the interface that we call the function from.
    This assumption means that if the class in question doesn’t implement the needed
    interface we will get a logic error. The solution is to either design in a way
    that avoids this situation or to check for the interface without casting to it,
    using the aforementioned `DoesImplementInterface` function in `UKismetSystemLibrary`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这可以更快地到达函数调用，并且声明了更少的临时变量。这种方法的权衡是调用的安全性。在此方法中，我们假设 `actorRef` 实现了我们从其调用函数的接口。这种假设意味着如果相关的类没有实现所需的接口，我们将得到一个逻辑错误。解决方案是设计一种避免这种情况的方法，或者在不进行转换的情况下检查接口，使用
    `UKismetSystemLibrary` 中的上述 `DoesImplementInterface` 函数。
- en: So, with these general concepts in mind, let’s look at creating our own interface
    in C++.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，带着这些一般概念，让我们看看如何在 C++ 中创建我们自己的接口。
- en: Building an example interface communication
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建示例接口通信
- en: 'To implement something like the preceding example where actors can be flammable,
    we can start with an interface called `IFlammable` that will need a public virtual
    function called `Ignite`. This would look like the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现类似于前面示例中的功能，其中演员可以是可燃的，我们可以从一个名为 `IFlammable` 的接口开始，该接口需要一个名为 `Ignite` 的公共虚拟函数。这看起来如下所示：
- en: Iflammable.h
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: IFlammable.h
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To implement this in other classes, you simply need to use polymorphism and
    override the interface functions. The following example shows a tree actor multi-inheriting
    from the interface to implement it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要在其他类中实现这一点，您只需使用多态并覆盖接口函数。以下示例显示了一个树演员从接口多继承以实现它：
- en: Excerpt from possible example flammable interface usage Tree.h
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从可能的示例可燃接口使用 Tree.h 中摘录
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On the calling side, if we had a flaming torch, we could add the following
    code to the collision handler for a collider around the flame particle:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用端，如果我们有一个火焰火炬，我们可以在火焰粒子的碰撞处理器中添加以下代码：
- en: Excerpt from possible flammable interface usage
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从可能的可燃接口使用中摘录
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code will let the torch ignite anything that is flammable and ignore everything
    that is not, without causing any errors or needing to do any unnecessary casting.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将使火炬点燃任何可燃物，而忽略不可燃物，不会引起任何错误或需要执行任何不必要的转换。
- en: Interfaces, both in Blueprint and C++, offer us key benefits in keeping communication
    clean and efficient, allowing us to bundle up function names for use on implementing
    classes. Now that we’ve explored the benefits and the process to create both types
    of interface, we can look at another anonymous communication method – events.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Implementing event delegate communication across UE5
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other form of anonymous communication is the event delegate. Delegates are
    essentially function pointers that allow us to change the flow of logic dynamically
    at runtime. When invoked, they allow a signal to be sent to potentially several
    other parts of a program, without the sender knowing where the signal has gone.
    Using these as part of an event-driven approach is called an event delegate.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Event delegates can be compared to a radio station. The delegate exists as the
    station, transmitting a signal into the air when it is told to. Then, there are
    radios that can choose to subscribe to the station, receiving the signal. This
    forms a one-to-many relationship, with one-way communication. The radios cannot
    send messages back to the station, and the station does not know how many radios
    are tuned in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Like when we explored interfaces, let’s begin with the Blueprint implementation
    before moving on to the more complex C++ approach.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Event delegates in Blueprint
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Blueprint, delegates are made simple with one variant exposed. These are
    called Event Dispatchers. They do, however, function in the expected way.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Event Dispatchers need to be created in the class that will do the broadcasting
    (the radio station as such). We do this by clicking the **+** symbol in the **EVENT
    DISPATCHERS** dropdown of the **My** **Blueprint** tab.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – The Event Dispatchers rollout within the My Blueprint tab](img/Figure_06.11_B18297.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – The Event Dispatchers rollout within the My Blueprint tab
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: An Event Dispatcher can have a series of inputs like any event in Blueprint.
    These are added at the top of the **Details** tab. You can also use the **Copy
    signature from**dropdown to select an existing event in the current Blueprint.
    This will duplicate all of the inputs from that event in the Event Dispatcher.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.12 – Event Dispatcher variables and the Copy \uFEFFsignature\uFEFF\
    \ from dropdown](img/Figure_06.12_B18297.jpg)"
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Event Dispatcher variables and the Copy signature from dropdown
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: A Blueprint can respond to its own dispatcher in the same way that any listening
    delegate can respond. The dispatcher needs to be bound to an event, which then
    performs the desired response.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This is why, if you drag and drop the dispatcher from the Event Dispatchers
    list, onto the Blueprint graph, you will be presented with a popup containing
    **Call**, **Bind**, **Unbind**, **Unbind all**, **Event**, and **Assign**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – The Event Dispatcher popup when dragged onto the Blueprint
    graph](img/Figure_06.13_B18297.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – The Event Dispatcher popup when dragged onto the Blueprint graph
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 – 将事件调度器拖动到蓝图图上时的事件调度器弹出窗口
- en: These options are available wherever you choose to respond to a dispatcher (with
    the exception of an event). However, you will typically access them via the normal
    popup to create Blueprint nodes when dragging out from an object, which holds
    the dispatcher as a reference.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项在您选择响应调度器的地方都可用（除了事件）。然而，您通常会通过正常弹出窗口访问它们，当从持有调度器的对象拖动时创建蓝图节点。
- en: '![Figure 6.14 – The Blueprint context popup when searching for an Event Dispatcher
    by name, after dragging from a reference to a class that holds the Event Dispatcher](img/Figure_06.14_B18297.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14 – 通过名称搜索事件调度器的蓝图上下文弹出窗口，在从包含事件调度器的类引用拖动后](img/Figure_06.14_B18297.jpg)'
- en: Figure 6.14 – The Blueprint context popup when searching for an Event Dispatcher
    by name, after dragging from a reference to a class that holds the Event Dispatcher
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 通过名称搜索事件调度器的蓝图上下文弹出窗口，在从包含事件调度器的类引用拖动后
- en: Let’s explore each of the options we are presented with from these popups so
    that you know when and how to use them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些弹出窗口中提供的每个选项，以便您知道何时以及如何使用它们。
- en: Call
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用
- en: The **Call** option activates the Event Dispatcher, sending the message to any
    subscribed delegates that are listening for the event. This is typically used
    on the Blueprint that has the event, but can be called from a separate Blueprint
    that has a direct reference to the actor with the dispatcher.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用**选项激活事件调度器，将消息发送到任何订阅的委托，这些委托正在监听该事件。这通常用于具有事件的蓝图上，但也可以从具有对具有调度器的演员的直接引用的单独蓝图中调用。'
- en: '![Figure 6.15 – A call dispatcher node with two variable inputs (Float and
    Bool)](img/Figure_06.15_B18297.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15 – 一个具有两个变量输入（浮点数和布尔值）的调用调度器节点](img/Figure_06.15_B18297.jpg)'
- en: Figure 6.15 – A call dispatcher node with two variable inputs (Float and Bool)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 一个具有两个变量输入（浮点数和布尔值）的调用调度器节点
- en: The **Bind** option is used to identify which event should be run when the dispatcher
    is called; when used, the associated event is added to the list of events associated
    with the dispatcher. In Blueprint, the red line between the **Bind Event to**
    node and the **Event** node indicates which event it is to be bound to.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**绑定**选项用于确定在调用调度器时应运行哪个事件；当使用时，相关事件被添加到与调度器相关联的事件列表中。在蓝图上，**绑定事件到**节点和**事件**节点之间的红色线条表示要绑定到哪个事件。'
- en: "![Figure 6.16 – A bind event node connected to a custom event \uFEFFthat will\
    \ be run when the Event Dispatcher is called](img/Figure_06.16_B18297.jpg)"
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16 – 一个绑定事件节点连接到一个自定义事件，该事件将在调用事件调度器时运行](img/Figure_06.16_B18297.jpg)'
- en: Figure 6.16 – A bind event node connected to a custom event that will be run
    when the Event Dispatcher is called
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 一个绑定事件节点连接到一个自定义事件，该事件将在调用事件调度器时运行
- en: This can be replaced by using a **Create Event** node, which can create a function
    or event with a matching signature (the same variables) or point toward an existing
    event. These are often used to try to keep the Blueprint graph tidy but are required
    to link to a function, as opposed to an event.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用**创建事件**节点来替换，该节点可以创建具有匹配签名（相同的变量）的函数或事件，或指向现有事件。这些通常用于尝试保持蓝图图整洁，但需要链接到函数，而不是事件。
- en: '![Figure 6.17–A bind event node connected to a Create Event node](img/Figure_06.17_B18297.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17–一个绑定事件节点连接到一个创建事件节点](img/Figure_06.17_B18297.jpg)'
- en: Figure 6.17–A bind event node connected to a Create Event node
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17–一个绑定事件节点连接到一个创建事件节点
- en: Unbind and Unbind all
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解除绑定和解除所有绑定
- en: The **Unbind** node does the opposite of the bind node. When using **Unbind**,
    the event is removed from the list of events associated with the Event Dispatcher.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**解除绑定**节点与绑定节点相反。当使用**解除绑定**时，事件将从与事件调度器相关联的事件列表中移除。'
- en: The **Unbind all** option does the same, but instead of just removing the linked
    event, it removes all events, nullifying the dispatcher from communicating with
    anything until another event is associated using a bind event node.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**解除所有**选项做的是同样的事情，但不是仅仅移除链接的事件，而是移除所有事件，使调度器无法与任何东西通信，直到使用绑定事件节点关联另一个事件。 '
- en: '![Figure 6.18 – The Unbind Event node, connected to a custom event, and an
    Unbind all Events node](img/Figure_06.18_B18297.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18 – 解除绑定事件节点，连接到自定义事件，以及解除所有事件节点](img/Figure_06.18_B18297.jpg)'
- en: Figure 6.18 – The Unbind Event node, connected to a custom event, and an Unbind
    all Events node
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 解除绑定事件节点，连接到自定义事件，以及解除所有事件节点
- en: The **Bind** and **Unbind** nodes allow us to dynamically link and unlink different
    events or functions to an Event Dispatcher, allowing us full control over what
    responds to a dispatcher at any point in the game.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**绑定**和**解绑**节点允许我们动态地将不同的事件或函数链接到事件分发器，使我们能够完全控制在任何游戏时刻响应分发器的对象。'
- en: Event and Assign
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件和分配
- en: The **Event** and **Assign** options exist to help you create the nodes required
    to respond to an Event Dispatcher.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**和**分配**选项存在是为了帮助你创建响应事件分发器所需的节点。'
- en: The **Event** option creates a **Custom Event** node with a matching signature,
    ready for you to connect to a bind event node later.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**选项创建了一个具有匹配签名的**自定义事件**节点，以便你稍后将其连接到绑定事件节点。'
- en: The **Assign** option creates both the Bind Event node and the matching custom
    event node, which can save a little bit of time when creating Blueprint logic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**分配**选项会创建绑定事件节点和匹配的自定义事件节点，这在创建蓝图逻辑时可以节省一点时间。'
- en: Now that we have a grasp of the Blueprint implementation of events, let’s move
    on to exploring the C++ implementation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了蓝图事件实现的实现，接下来让我们探索C++的实现。
- en: Event delegates in C++
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的事件代表
- en: 'In C++, event delegates are a little more complicated, but with that comes
    more control. For starters, there are a few different properties you can give
    each delegate before making events out of it. Let’s take a look at them:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，事件代表稍微复杂一些，但这也带来了更多的控制。首先，在将事件从代表中创建出来之前，你可以给每个代表赋予一些不同的属性。让我们来看看它们：
- en: '`DYNAMIC`: This delegate can be serialized into the editor for easy Blueprint
    binding'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DYNAMIC`: 这个代表可以被序列化到编辑器中，以便于蓝图绑定'
- en: '`MULTICAST`: This delegate can have multiple listeners at once and removes
    the ability to have a return value'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MULTICAST`: 这个代表可以同时拥有多个监听器，并移除了返回值的能力'
- en: '`SPARSE`: This delegate will not take up 1 byte in memory until it is subscribed
    to (this does make it slower to use, but it is more efficient for delegates that
    are rarely bound, such as a marketplace tool)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPARSE`: 这个代表在订阅之前不会占用内存中的1个字节（这确实会使使用速度变慢，但对于很少绑定的事件（如市场工具）来说，效率更高）'
- en: 'After deciding how the delegate should behave, you need to declare it as a
    new type. This is described by the following pattern in all caps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定代表应该如何表现之后，你需要将其声明为一个新类型。这通过以下大写模式进行描述：
- en: '`DECLARE_<properties>_DELEGATE_<parameter amount>(<TypeName>, <arg1 type>,
    <arg1` `name>… );`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`DECLARE_<属性>_DELEGATE_<参数数量>(<类型名>, <arg1类型>, <arg1名称>… );`'
- en: 'An example of this could be as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以举例说明如下：
- en: '`DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FExampleSignature, float, number,`
    `AActor*, actorRef);`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FExampleSignature, float, number,
    AActor*, actorRef);`'
- en: This delegate will be serialized into the editor, with possibly multiple bound
    functions. Each bound function will have two arguments of type `float` and `AActor*`.
    This is the closest in behavior to a Blueprint Event Dispatcher.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代表将被序列化到编辑器中，可能包含多个绑定的函数。每个绑定的函数将有两个`float`类型的参数和`AActor*`类型的参数。这在行为上与蓝图事件分发器最为接近。
- en: There is also another type of delegate called an event. This is a version of
    a multicast delegate, where the first argument is the owning type, only that type
    can have events as members, and only the defining object can broadcast the events.
    With this extra security, you can expose events as public without fear that a
    different class will broadcast the event. However, with that comes extra design
    challenges to make your systems work in a clean manner.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种称为事件的代表类型。这是多播代表的版本，其中第一个参数是拥有类型，只有该类型可以作为成员拥有事件，并且只有定义对象可以广播事件。有了这种额外的安全性，你可以将事件公开而不必担心其他类会广播该事件。然而，这也带来了额外的设计挑战，以使你的系统以整洁的方式工作。
- en: Important note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: From this point on, all event delegates used will be dynamic multicast to avoid
    confusion. This is not necessarily the best strategy, but it is a good starting
    point to then modify and restrict behavior later as needed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有使用的事件代表都将使用动态多播，以避免混淆。这不一定是最优策略，但这是一个很好的起点，以便随后根据需要修改和限制行为。
- en: That is how to define a new delegate type and create a new instance of a delegate
    from the type. To make delegates do something, you also need to know how to bind
    functions to them and fire them. This will change, depending on what properties
    were given to the event in it’s declaration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何定义一个新的代表类型并从该类型创建一个新的代表实例。为了使代表执行某些操作，你还需要知道如何将函数绑定到它们并触发它们。这会根据在声明中赋予事件的属性而有所不同。
- en: 'Working our way through the different properties that a delegate has, we can
    see that non-dynamic delegates have eight different functions that can bind listening
    functions to them for each single and multicast. It is recommended that you use
    the `BindUObject` function for single-cast delegates and the `AddUObject` function
    for multicast delegates. These both take a reference `UObject*` as a first argument
    and a function address as the second, in the style: `&ClassName::FunctionName`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解代表者具有的不同属性，我们可以看到非动态代表者有八个不同的函数，可以将监听函数绑定到每个单播和多播上。建议您使用`BindUObject`函数为单播代表者，使用`AddUObject`函数为多播代表者。这两个函数都接受一个引用`UObject*`作为第一个参数和一个函数地址作为第二个参数，格式为：`&ClassName::FunctionName`。
- en: For dynamic delegates, there is less choice; single-cast dynamic delegates should
    use the `BindDynamic` function, and for multicast, it is advised you use the `AddUniqueDynamic`
    function, both with the same arguments as the non-dynamic delegates mentioned
    previously. The `AddDynamic()` function is ok to use with multicast dynamic delegates
    if you know the instance of the function has not already been bound to this delegate,
    otherwise it can be bound multiple times to the same event dispatcher.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态代表者，选择较少；单播动态代表者应使用`BindDynamic`函数，对于多播，建议您使用`AddUniqueDynamic`函数，这两个函数与之前提到的非动态代表者具有相同的参数。如果知道函数实例尚未绑定到该代表者，则可以使用`AddDynamic()`函数与多播动态代表者一起使用，否则它可能会被多次绑定到同一个事件分发器。
- en: Finally, to call delegates if they are single-cast, you should use the `ExecuteIfBound()`
    member function on the delegate, passing through arguments as necessary. For any
    multicast delegates, use the `Broadcast` member function. We will use a lot of
    multicast dynamic delegates when prototyping, as they offer the greatest flexibility
    to hook more listeners in as needed, leading us to make heavy use of the `Broadcast`
    function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果代表者是单播的，您应该使用代表者上的`ExecuteIfBound()`成员函数来调用它们，并根据需要传递参数。对于任何多播代表者，使用`Broadcast`成员函数。在原型设计时，我们将大量使用多播动态代表者，因为它们提供了最大的灵活性，可以根据需要钩入更多的监听器，这导致我们大量使用`Broadcast`函数。
- en: With the core concepts of delegates in C++ covered, let’s move on to creating
    our own event delegate.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了C++中代表者的核心概念后，让我们继续创建我们自己的事件代表者。
- en: Building a useful delegate tool
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建有用的代表者工具
- en: Let’s now look at building a useful class you can drop into any project. We
    will build on top of the damage system already present inside Unreal Engine. This
    utilizes a combination of an interface and the polymorphic nature of the engine,
    allowing you to deal damage to any actor and respond to damage from any actor.
    As an extension, we will look at making a Health Component that can sit on any
    actor, bind itself into this damage system automatically, and provide a couple
    of useful endpoints for any gameplay system to run with.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构建一个可以放入任何项目的有用类。我们将在Unreal Engine中现有的伤害系统中构建。这利用了接口和引擎的多态性，允许您对任何演员造成伤害，并从任何演员那里接收伤害。作为一个扩展，我们将探讨制作一个可以放在任何演员上的健康组件，它可以自动将自己绑定到这个伤害系统中，并为任何游戏系统提供一些有用的端点。
- en: To start with, we need a new C++ class, so head to your C++ folder in the editor
    and make a new class based on **Actor Component**. Actor components are components
    for logic, as they have no associated rendering or transform within the world.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个新的C++类，所以请转到编辑器中的C++文件夹，并基于**演员组件**创建一个新的类。演员组件是用于逻辑的组件，因为它们在世界上没有关联的渲染或变换。
- en: Useful tip
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有用提示
- en: If you are using Rider 2022 or later, then a right-click on your module base
    folder will give you the option to **Add an Unreal Class**. In the popup, you
    can select an actor component, and it will function the same way but without the
    need for the engine to be running.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Rider 2022或更高版本，那么在您的模块基础文件夹上右键单击将为您提供**添加 Unreal 类**的选项。在弹出窗口中，您可以选择一个演员组件，它将以相同的方式工作，但不需要引擎运行。
- en: 'The first thing to think about is what delegate definitions we will need. The
    obvious one is for when the component has run out of health and needs to let the
    owning actor know that it has died. This could probably pass through a reference
    to the controller that instigated the chain so that, eventually, the game mode
    can attribute points to the correct controller:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是我们需要哪些代表者定义。显然的一个是当组件耗尽健康时，需要让拥有该组件的演员知道它已经死亡。这可能需要传递一个引用到引发链的控制器，这样最终游戏模式就可以将分数分配给正确的控制器：
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next useful piece of information to pass out to the component would be
    a signal whenever damage is dealt. There are a lot of options for what data to
    pass through. For instance, if the target is more of a *Call of Duty*-style game,
    you probably want to know what direction the damage was received from to feed
    that back to the player via some form of UI. In this instance, we will pass through
    information about the new and maximum health values, along with the change that
    just happened. This will let us update UI health bars and possibly spawn some
    damage numbers into the world:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 需要传递给组件的下一个有用的信息是每次造成伤害时发出的信号。有很多选项可以选择传递的数据。例如，如果目标是更偏向于《使命召唤》风格的游戏，你可能想知道伤害来自哪个方向，以便通过某种形式的UI将信息反馈给玩家。在这种情况下，我们将传递有关新和最大生命值以及刚刚发生的变化的信息。这将使我们能够更新UI生命条，并可能在世界中生成一些伤害数字：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then look at the header definitions. The only items that need to be
    public are the constructor and one of each delegate type declared previously.
    In the protected section, we need some float variables to track the current and
    maximum health. These are marked as protected so that the reflection specified
    in the `UPROPERTY` tag will work with the editor. Along with these, we’ll use
    a `BeginPlay` override to set up some automatic behavior. Lastly, we’ll add a
    handler function to the private section. This will be used to hook into the damage
    interface system already present inside the actor this component is attached to.
    With that all written out, the class definition should look a little like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看头文件定义。需要公开的只有构造函数以及之前声明的每种委托类型中的一个。在受保护部分，我们需要一些浮点变量来跟踪当前和最大生命值。这些变量被标记为受保护，以便在`UPROPERTY`标签指定的反射能够与编辑器一起工作。除此之外，我们还将使用`BeginPlay`重写来设置一些自动行为。最后，我们将在私有部分添加一个处理函数。这将用于将此组件附加到的actor中已经存在的伤害接口系统挂钩。所有这些写出来后，类定义应该看起来像这样：
- en: HealthComponent.h class definition
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: HealthComponent.h 类定义
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After generating the definitions for these functions, we can add a default
    value for `maxHealth` into the constructor of maybe `100.f`, but this line isn’t
    too important. The `BeginPlay` override needs to bind our private `DamageTaken`
    function to the `OnTakeAnyDamage` event of the owning actor it is attached to,
    as well as setting the initial value for `_CurrentHealth`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成这些函数的定义之后，我们可以在构造函数中为`maxHealth`添加一个默认值，比如`100.f`，但这行代码并不是很重要。`BeginPlay`重写需要将我们的私有`DamageTaken`函数绑定到所附加actor的`OnTakeAnyDamage`事件，以及设置`_CurrentHealth`的初始值：
- en: HealthComponent.cpp Constructor and BeginPlay
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: HealthComponent.cpp 构造函数和BeginPlay
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, the logic for how damage is taken and how the events are fired will all
    go into the `DamageTaken` function. Note the use of `FMath::Min` to make sure
    the damage received never goes beyond the amount of health remaining. This could
    be easily altered to allow for *Doom*-style forgiveness mechanics, where the player
    cannot be taken from >1% health to 0% in one hit and can only die from 1% health.
    Alternatively, it could be removed to allow for overkill calculations if that
    matters for gameplay:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，关于如何承受伤害以及如何触发事件的逻辑都将放入`DamageTaken`函数中。注意使用`FMath::Min`确保收到的伤害永远不会超过剩余的生命值。这可以轻松修改为允许类似《毁灭战士》风格的宽恕机制，其中玩家不能在一次攻击中从>1%的生命值降到0%，只能从1%的生命值死亡。或者，如果这对游戏玩法很重要，可以将其删除以允许过载计算：
- en: HealthComponent.cpp DamageTaken function
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: HealthComponent.cpp DamageTaken函数
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To make use of this component, you can now go to any actor and add this component
    to its hierarchy. It will automatically bind itself, and we have built in two
    events that can be bound to Blueprint and C++ functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此组件，你现在可以前往任何actor并添加此组件到其层次结构中。它将自动绑定自身，并且我们已经内置了两个可以绑定到蓝图和C++函数的事件。
- en: In the example project, add the health component to the enemy unit **Blueprint
    Editor**. Create a listener for the **OnHealthDead** event by selecting the new
    component in the **Hierarchy** panel and clicking the plus button next to the
    event in the **Details** > **Events** panel.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例项目中，将健康组件添加到敌方单位的**蓝图编辑器**中。通过在**层次结构**面板中选择新组件，并在**详情** > **事件**面板中点击事件旁边的加号按钮来创建**OnHealthDead**事件的监听器。
- en: Link up the Blueprint functions in the red comment block marked **Handle Unit
    Death** as shown in *Figure 6**.19*, and you will see that because the player
    has been built with the damage system in mind, you can now move about and destroy
    enemy units.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将红色注释块中标记为**处理单元死亡**的蓝图函数链接起来，如图*6.19*所示，你会看到，由于玩家是在考虑到伤害系统的情况下构建的，你现在可以四处移动并摧毁敌方单位。
- en: '![Figure 6.19  – The fully linked up event](img/Figure_06.19_B18297.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图6.19 – 完全链接的事件](img/Figure_06.19_B18297.jpg)'
- en: Figure 6.19 – The fully linked up event
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – 完全链接的事件
- en: This functional example shows how event delegates can be used to communicate
    anonymously, thereby removing the need for object references everywhere. Using
    this communication method effectively helps to reduce the coupling of code bases,
    making them easier to maintain over time as more are added.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能示例展示了如何使用事件委托来匿名通信，从而消除了在所有地方都需要对象引用的需求。有效地使用这种通信方法有助于减少代码库的耦合，使得随着时间的推移，随着更多内容的添加，它们更容易维护。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covers the two main methods of cleaning up communication in a code
    base. We have covered functional examples of how to use both interfaces and event
    delegates within our C++ setup, as well as the technical setup, using the `U`
    and `I` prefixes of an interface properly, and what each of the characteristics
    of a delegate mean. Now that the functional understanding is sorted, the next
    step should be to practice with these tools to get a better understanding of how
    they affect the code base. We will do this in the next chapter by looking at how
    we deploy both interfaces and event delegates with function calls, achieving a
    perfectly decoupled system where communication is as anonymous as possible. This
    naturally creates modular code design, allowing for much easier cohesion within
    teams.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在代码库中清理通信的两种主要方法。我们已经介绍了如何在我们的C++设置中使用接口和事件委托的功能示例，以及技术设置，正确使用接口的`U`和`I`前缀，以及每个委托特性的含义。现在功能理解已经整理好，下一步应该是通过使用这些工具来更好地理解它们如何影响代码库进行实践。我们将在下一章通过查看我们如何通过函数调用部署接口和事件委托，实现一个尽可能匿名的完美解耦系统，其中通信尽可能匿名。这自然地创造了模块化代码设计，使得团队内部更容易实现协同。
