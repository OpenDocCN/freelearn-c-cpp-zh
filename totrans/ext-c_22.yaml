- en: Chapter 22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It doesn't really matter which programming language you are using or what type
    of application you are developing, it is always important to thoroughly test it
    before delivering it to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests is not a new thing and as of today, you can find hundreds or even
    thousands of tests in almost every software project. Nowadays writing tests for
    software is a must and delivering a piece of code or feature without having it
    tested properly is strongly discouraged. That's why we have a dedicated chapter
    to talk about testing software written in C, and various libraries that exist
    today for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is not the only topic in this chapter, however. We will also be discussing
    the debugging tools and techniques that can be used to troubleshoot a C program.
    Testing and debugging have complimented one another from the start, and whenever
    a test fails, a series of investigations are followed and debugging the target
    code is a common follow-up action.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we won't go through the philosophy of testing and we assume
    that testing is good. Instead, we will give you a short introduction about the
    basic terminology and the guidelines that a developer should follow in order to
    write testable code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has two sections. In the first section, we talk about testing and
    the existing libraries that can be used in modern C development. The second section
    of this chapter is going to talk about debugging, starting with a discussion about
    various categories of bugs. Memory issues, concurrency issues, and performance
    issues are the most common cases in which further debugging seems to be necessary
    in order to establish a successful investigation.
  prefs: []
  type: TYPE_NORMAL
- en: We will also cover the most used debugging tools available for C (and C++).
    The final goal of this chapter is to let you know about the testing and debugging
    utilities available for C and give you some basic background knowledge about them.
  prefs: []
  type: TYPE_NORMAL
- en: The first section introduces you to the basic terminology of software testing
    in general. It is not specific to C, and the ideas and concepts can be applied
    to other programming languages and technologies as well.
  prefs: []
  type: TYPE_NORMAL
- en: Software testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software testing is a big and important subject in computer programming, and
    it has its own specific terminology and many concepts. In this section, we are
    going to give you a very basic introduction to software testing. Our purpose is
    to define some terms that we are going to use in the first half of this chapter.
    Therefore, you should be aware that this is not a thorough chapter about testing
    and further study is strongly encouraged.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to testing software, the first question that comes to mind is,
    what are we testing, and what is this testing about? In general, we test an aspect
    of a software system. This aspect can be *functional* or *non-functional*. In
    other words, the aspect may be related to a certain functionality of the system,
    or it can be related to a certain variable of a system when performing a functionality.
    Next, we give some examples.
  prefs: []
  type: TYPE_NORMAL
- en: '*Functional testing* is about testing a defined functionality requested as
    part of the *functional requirements*. These tests provide a certain input to
    a *software element* such as a *function*, a *module*, a *component*, or a *software
    system*, and expect a certain output from them. Only if the expected output is
    seen as part of a test is that test considered as *passed*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Non-functional testing* is about the *quality level* to which a software element,
    such as a function, a module, a component, or a software system as a whole, completes
    a specific functionality. These tests are usually supposed to *measure* various
    *variables* like *memory usage*, *time to completion*, *lock contention*, and
    *level of security*, and assess how well that element has done its job. A test
    is passed only when the measured variables are within the expected ranges. The
    *expectations* for these variables are derived from the *non-functional requirements*
    defined for the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from functional and non-functional testing, we can have different *levels*
    of testing. These levels are designed in a way to cover some orthogonal aspects.
    Some of these aspects are size of the tested element, the actor of the test, and
    the extent of the functionalities that should be tested.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, regarding the size of the element, these levels are defined from
    the smallest possible piece of functionality, which we know as a function (or
    a method), up to the biggest possible piece of functionality that it is exposed
    from a software system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we are going to introduce these levels in a deeper
    sense
  prefs: []
  type: TYPE_NORMAL
- en: Testing levels
  prefs: []
  type: TYPE_NORMAL
- en: 'For every software system, the following levels of testing can be considered
    and planned. These are not the only existing testing levels and you can find more
    of them in other references:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regression testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *unit testing*, we test a *unit* of functionality. This unit can be a function
    that performs a certain job, or a group of functions together to satisfy a need,
    or a class that has a final goal to perform a certain functionality, or even a
    component that has a specific task to do. A *component* is a part of a software
    system that has a well-defined set of functionalities and, together with other
    components, joins and becomes the whole software system.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of having components as units, we call the testing process *component
    testing*. Both functional and non-functional testing can be done at the level
    of units. When testing a unit, that unit should become isolated from its surrounding
    units, and for this to happen, the surrounding environment should be simulated
    in some way. This level would be the only level that we cover as part of this
    chapter and we provide real code to demonstrate how unit testing and component
    testing can be done in C.
  prefs: []
  type: TYPE_NORMAL
- en: When the units join together, they form a component. In component testing, a
    component is tested alone in isolation. But when we group some of these components,
    we need a different level of testing that checks the functionality or the variables
    for that specific group of components. This level is *integration testing*. As
    the name implies, the tests in this level check if the integration of some of
    the components works well and they together still satisfy the defined requirements
    for the system.
  prefs: []
  type: TYPE_NORMAL
- en: At a different level, we test the functionality of the whole system. This will
    contain a complete set of all components fully integrated. This way, we test if
    the exposed system functionalities and system variables are in accordance with
    the requirements defined for the software system.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a different level, we evaluate a software system to check if it is in accordance
    with the business requirements defined for that system from the *stakeholder*
    or *end user* point of view. This level is called *acceptance testing*. While
    both system testing and acceptance testing is about the whole software system,
    they are actually quite different. To name a few differences:'
  prefs: []
  type: TYPE_NORMAL
- en: System testing is done by developers and testers, but acceptance testing is usually
    done by the end user or the stakeholder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System testing is about checking both functional and non-functional requirements,
    but acceptance testing is only about functional requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In system testing, we usually use a prepared small set of data as the input,
    but in acceptance testing, the actual real-time data is fed to the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A great link that explains all the differences can be found [at https://www.javatpoint.com/acceptance-tes](https://www.javatpoint.com/acceptance-testing)ting.
  prefs: []
  type: TYPE_NORMAL
- en: When a change is introduced to a software system, it is required to check if
    the current functional and non-functional tests are still in a good shape. This
    is done at a different level known as *regression testing*. The purpose of regression
    testing is to confirm that there is no *regression* after introducing a change.
    As part of regression testing, all the functional and non-functional tests found
    as unit tests, integration tests, and end-to-end (system) tests are run again
    to see if any of them fail following a change.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced various levels of testing. For the rest of this
    chapter, we are going to discuss unit testing. In the upcoming section, we start
    talking about it by giving a C example and trying to write test cases for it.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained in the previous section, as part of unit testing, we test isolated
    units and a unit can be as small as a function or as big as a component. In C,
    it can be a function or a whole component written in C. The same discussion can
    be applied to C++ as well, but there we can have other units like classes.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing about unit testing is that units should be tested in
    isolation. For example, if the target function depends on the output of another
    function, we need to find a way to test the target function in isolation. We are
    going to explain this using a real example.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example 22.1* prints the factorials of even numbers less than 10, but not
    in the usual way. The code is well-organized in one header and two source files.
    The example is about two functions; one of them generates the even numbers less
    than 10 and the other function receives a function pointer and uses it as a source
    for reading an integer number, and finally calculates its factorial.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code box contains the header file containing the function declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-1 [ExtremeC_examples_chapter22_1.h]: The header file of example
    22.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the function `calc_factorial` accepts a function pointer that
    returns an integer. It will use the function pointer in order to read an integer
    and calculate its factorial. The following code is the definition of the preceding
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-2 [ExtremeC_examples_chapter22_1.c]: The definitions of the functions
    used in example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `next_even_number` function has an internal static variable that acts as
    a feed for the caller function. Note that it never exceeds 8 and after that, it
    goes back to 0\. Therefore, you can simply call this function as many times as
    you like, and you never get a number greater than 8 and lower than zero. The following
    code box contains the content of the source file that contains the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-3 [ExtremeC_examples_chapter22_1_main.c]: The main function of
    example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you see, the `main` function calls the `calc_function` 12 times and prints
    the returned factorials. In order to run the preceding example, you need to compile
    both source files first and then link their corresponding relocatable object files
    together. The following shell box contains the required commands to build and
    run the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 22-1: Building and running example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: In order to write tests for the preceding functions, we need to give a bit of
    introduction first. As you can see, we have two functions (not including the `main`
    function) in the example. Therefore, there are two different units, in this case
    functions, that should be tested separately and in isolation from each other;
    one is the `next_even_number` function and the other one is the `calc_factorial`
    function. But as it is clear in the main function, the `calc_factorial` function
    depends on the `next_even_number` function and one might think that this dependency
    is going to make the isolation of the `calc_factorial` function much harder than
    we anticipated. But this is not true.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the `calc_factorial` function does not depend on the `next_even_number`
    function at all. It only depends on the *signature* of `next_even_number` and
    not its definition. Therefore, it is possible to replace `next_even_number` with
    a function that follows the same signature, but always returns a fixed integer.
    In other words, we can provide a simplified version of `next_even_number` that
    is intended to be used only in the *test cases*.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is a test case? As you know, there are various scenarios to test a
    specific unit. The simplest example is to provide various inputs to a certain
    unit and *expect* a predetermined output. In the preceding example, we can provide
    `0` as the input for the `calc_factorial` function and wait for `1` as its output.
    We can also provide `-1` and wait for `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Every one of these scenarios can be a test case. Therefore, regarding a single
    unit, we can have multiple test cases addressing all different corner cases of
    that unit. A collection of test cases is called a *test suite*. All the test cases
    found in a test suite are not necessarily related to the same unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a test suite for the `next_even_number` function. Since
    `next_even_number` can be easily tested in isolation, there is no need for extra
    work. Following are the test cases written for the `next_even_number` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-4 [ExtremeC_examples_chapter22_1 __next_even_number__tests.c]:
    The test cases written for the next_even_number function'
  prefs: []
  type: TYPE_NORMAL
- en: As you see, we have defined two test cases in the preceding test suite. Note
    that I have used my own convention to give names to the above test cases; however,
    there is no standard regarding this. The whole purpose of naming test cases is
    to realize what a test case does from its name and more important than that, to
    find it easily in the code when the test case fails or needs to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: I used the capital `TESTCASE` as a prefix to function names to make them distinguished
    from other ordinary functions. The names of the functions also try to describe
    the test case and the concern it is addressing.
  prefs: []
  type: TYPE_NORMAL
- en: Both test cases have `assert` at the end. This is the thing that all test case
    functions do when evaluating the expectations. If the condition inside the parentheses
    of `assert` is not true, the *test runner*, a program that is running the tests,
    quits and an error message is printed. More than that, the test runner returns
    a non-zero *exit code* that indicates one or more of the test cases have failed.
    The test runner program must return 0 when all tests have been successful.
  prefs: []
  type: TYPE_NORMAL
- en: It would be nice to go through the test cases on your own and try to understand
    how they evaluate our expectations by calling the `next_even_number` function
    in the preceding two scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to write test cases for the `calc_factorial` function. Writing
    test cases for the `calc_factorial` function needs a *stub function* as its feed
    that returns the test input. We explain what stubs are shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are three test cases that are only testing the `calc_factorial` unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-5 [ExtremeC_examples_chapter22_1 __calc_factorial__tests.c]: The
    test cases written for the calc_factorial function'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have defined three test cases for the `calc_factorial` function.
    Note the `feed_stub` function. It follows the same contract that `next_even_number`
    is following, as can be seen in *Code Box 22-2*, but it has a very simple definition.
    It just returns a value stored in the static variable `input_value`. This variable
    can be set by the test cases before calling the `calc_facorial` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the preceding stub function, we could isolate `calc_factorial` and test
    it individually. The same approach is valid for object-oriented programming languages
    like C++ or Java, but there we define *stub classes* and *stub objects*.
  prefs: []
  type: TYPE_NORMAL
- en: In C, a *stub* is a function definition that conforms to a function declaration
    that the target unit would use as part of its logic, and more importantly, the
    stub doesn't have a complex logic and it just returns a value that is going to
    be used just by the test case.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, a stub can still be a function definition that conforms to a function
    declaration, or a class that implements an interface. In other object-oriented
    languages where you cannot have standalone functions, for instance Java, a stub
    can only be a class that implements an interface. Then, a stub object is an object
    from such stub classes. Note that in all cases, a stub should have a simple definition
    that is only usable in tests, and not in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to be able to run the test cases. As we said previously, we
    need a test runner to run tests. Therefore, we need a specific source file with
    a `main` function that only runs the test cases one after another. The following
    code box contains the code of the test runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-6 [ExtremeC_examples_chapter22_1 _tests.c]: The test runner used
    in example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'The above code returns `0` only if all the test cases within the `main` functions
    are executed successfully. For building the test runner, we need to run the following
    commands. Note the `-g` option that adds debugging symbols to the final test runner
    executable. Performing a *debug build* is the most common way to build tests since
    if a test case fails, we immediately need the precise *stack trace* and further
    debugging information to proceed with investigation. More than that, the `assert`
    statements are usually removed from *release builds*, but we need to have them
    in the test runner executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 22-2: Building and running the test runner of example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding shell box shows that all the tests have been passed. You can also
    check the exit code of the test runner process by using the `echo $?` command
    and see that it has returned zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, by applying a simple change in one of the functions, we can fail the tests.
    Let''s see what happens when we change `calc_factorial` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-7: Changing the calc_factorial function to fail the tests'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding change, shown in bold font, the test cases about the `0`
    and negative inputs still pass, but the last test case, which is about the calculation
    of the factorial of `5`, fails. We are going to build the test runner again and
    the following is the output of the execution on a macOS machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 22-3: Building and running the test runner after changing the calc_factorial
    function'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `Assertion failed` appears in the output and the exit code is
    `134`. This exit code is usually used and reported by the systems running the
    tests periodically, such as *Jenkins*, to check if the tests have been run successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule of thumb, whenever you have a unit that should be tested in isolation,
    you need to find a way to provide its dependencies as some kind of input. Therefore,
    the unit itself should be written in a way that makes it *testable*. Not all code
    is testable, and testability is not limited to unit testing, and this is very
    important to be aware of. This link provides good information on how to write
    t[estable code: https://blog.gurock.com/highly-](https://blog.gurock.com/highly-testable-code/)testable-code/.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify the above discussion, suppose that we have written the `calc_factorial`
    function like below to use the `next_even_number` function directly instead of
    using a function pointer. Note that in the following code box, the function doesn''t
    receive a function pointer argument and it calls the `next_even_number` function
    directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-8: Changing the calc_factorial function''s signature to not accept
    a function pointer'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is less testable. There is no way to test `calc_factorial`
    without having the `next_even_number` called – that is, without employing some
    hacks to change the definition behind the symbol `next_even_number` as part of
    the final executable, as we do in *example 22.2*.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, both versions of `calc_factorial` do the same thing, but the definition
    in *Code Box 22-2* is more testable because we could test it in isolation. Writing
    testable code is not easy, and you should always think carefully in order to implement
    code and have it be testable.
  prefs: []
  type: TYPE_NORMAL
- en: Writing testable code usually demands more work. There are various opinions
    about the overhead percentage of writing testable code but it is certain that
    writing tests brings some extra cost in terms of time and effort. But this extra
    cost surely has great benefits. Without having tests for a unit, you will lose
    track of it as time goes by and more changes are introduced to the unit.
  prefs: []
  type: TYPE_NORMAL
- en: Test doubles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, while writing test cases, we introduced stub functions.
    There are a few other terms about the objects that try to mimic a unit''s dependencies.
    These objects are called *test doubles*. Next, we are going to introduce two other
    test doubles: *mock* and *fake* functions. First, let''s briefly explain again
    what stub functions are.'
  prefs: []
  type: TYPE_NORMAL
- en: Note two things in this short section. Firstly, there are never-ending debates
    on the definition of these test doubles, and we try to give a proper definition
    that matches our usage in this chapter. Secondly, we keep our discussion only
    relevant to C, so there is no object and everything we have is a function.
  prefs: []
  type: TYPE_NORMAL
- en: When a unit is dependent on another function, it simply depends on the signature
    of that function, therefore that function can be replaced by a new one. This new
    function, based on some properties that it might have, can be called a stub, a
    mock, or a fake function. These functions are just written to satisfy the test
    requirements and they cannot be used in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'We explained a stub to be a function that is very simple, usually just returning
    a constant value. As you saw in *example 22.1*, it was indirectly returning a
    value just set by the running test case. In the following link, you can read more
    about the test doubles that we are talking about and a f[ew more of them: https://en.wikipedia.org](https://en.wikipedia.org/wiki/Test_double)/wiki/Test_double.
    If you open the link, a stub is defined as something that provides an *indirect
    input* to the testing code. If you accept this definition, the `feed_stub` function
    seen in *Code Box 22-5* is a stub function.'
  prefs: []
  type: TYPE_NORMAL
- en: Mock functions, or generally mock objects as part of object-oriented languages,
    can be manipulated by specifying the output for a certain input. This way, you
    set whatever should be returned from a mock function for a certain input before
    running the test logic and during the logic it will act as you have set beforehand.
    Mock objects in general can have expectations as well and they perform the required
    assertions accordingly. As stated in the preceding link, for mock objects, we
    set expectations before running the test. We are going to give a C example of
    mock functions as part of the component testing section.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a fake function can be used to give a very simplified functionality
    for a real and maybe complex functionality as part of the running test. For example,
    instead of using a real filesystem, one may use some simplified in-memory storage.
    In component testing, for instance, other components that have complex functionalities
    can be replaced by fake implementations in the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Before ending this section, I want to talk about *code coverage*. In theory,
    all units should have corresponding test suites and each test suite should contain
    all test cases that go through all possible branches of code. As we said, this
    is in theory, but in practice you usually have test units only for a percentage
    of units. Often, you don't have test cases that cover all possible branches of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The proportion of units that have proper test cases is called code coverage
    or *test coverage*. The higher the proportion, the better placed you are for getting
    notified about unwanted modifications. These unwanted modifications are not usually
    introduced by bad developers. In fact, these breaking changes are usually introduced
    while someone is working on a piece of code for fixing a bug or implementing a
    new feature.
  prefs: []
  type: TYPE_NORMAL
- en: Having covered test doubles, we talk about component testing in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Component testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained in the previous section, units can be defined as a single function,
    a group of functions, or a whole component. Therefore, component testing is a
    special type of unit testing. In this section, we want to define a hypothetical
    component as part of *example 22.1* and put the two functions found in the example
    into this component. Note that a component usually results in an executable or
    a library. We can suppose that our hypothetical component would result in a library
    that contains the two functions.
  prefs: []
  type: TYPE_NORMAL
- en: As we said before, we have to be able to test the functionality of a component.
    In this section, we still want to write test cases but the difference between
    the tests written in this section and the previous section is to do with the units
    that should be isolated. In the previous section, we had functions that should
    have been isolated, but in this section, we have a component, compromising of
    two functions working hand in hand, that needs to be isolated. So, the functions
    must be tested when they are working together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can find the test cases we have written for the component defined
    as part of *example 22.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-9 [ExtremeC_examples_chapter22_1_component_tests.c]: Some component
    tests written for our hypothetical component as part of example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: As you see, we have written two test cases. Like we said before, in our hypothetical
    component, the functions `calc_factorial` and `next_even_number` must work together,
    and as you see, we have passed `next_even_number` as the feed to `calc_factorial`.
    The preceding test cases, and other similar test cases, should guarantee that
    the component is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: It requires a lot of effort to prepare a basis for writing test cases. Therefore,
    it is very common to use a testing library for this purpose. These libraries prepare
    the playground for the test cases; they initialize every test case, run the test
    case, and finally tear down the test case. In the upcoming section, we are going
    to talk about two of the testing libraries available for C.
  prefs: []
  type: TYPE_NORMAL
- en: Testing libraries for C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to demonstrate two of the well-known libraries
    used to write tests for C programs. For unit testing in C, we use libraries that
    are written in C or C++. That's because we can integrate them easily and use the
    units directly from a C or C++ testing environment. In this section, our focus
    is on unit testing and component testing in C.
  prefs: []
  type: TYPE_NORMAL
- en: For integration testing, we are free to choose other programming languages.
    Generally, the integration and system testing are much more complex, and we therefore
    need to use some testing automation frameworks in order to write tests easier
    and run them without too much hassle. Using a **domain-specific language** (**DSL**)
    is part of this automation, in order to write test scenarios more easily and make
    test execution much simpler. Many languages can be used for this purpose, but
    scripting languages like Unix shell, Python, JavaScript, and Ruby are among the
    most favorite ones. Some other programming languages like Java are also used heavily
    in test automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of some well-known unit testing frameworks which can
    be used to write unit tests for C programs. This list below can be found at the
    following link: http://check.sourceforge.net/doc/check_html/check_2.html#SEC3:'
  prefs: []
  type: TYPE_NORMAL
- en: Check (from the author of the preceding link)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AceUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Autounit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CppUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CuTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: embUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MinUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMocka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following sections, we will introduce two popular testing frameworks:
    *CMocka*, which is written in C, and *Google Test*, which is written in C++. We
    won''t explore all features of these frameworks, but this is just to give you
    an initial feeling about a unit testing framework. Further study is highly encouraged
    in this domain.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to write unit tests for *example 22.1* using
    CMocka.
  prefs: []
  type: TYPE_NORMAL
- en: CMocka
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first great thing about CMocka is that it is written purely in C, and it
    only depends on the C standard library – not on any other libraries. So, you can
    use a C compiler to compile the tests, and this gives you the confidence that
    the test environment is very close to the actual production environment. CMocka
    is available on many platforms like macOS, Linux, and even Microsoft Windows.
  prefs: []
  type: TYPE_NORMAL
- en: CMocka is the *de facto* framework for unit testing in C. It supports *test
    fixtures*. Test fixtures may allow you to initialize and clear the testing environment
    before and after each test case. CMocka also supports *function mocking*, which
    is very useful when trying to mock any C function. As a reminder, a mock function
    can be configured to return a certain value when a certain input is provided.
    We will give an example of mocking the `rand` standard function used in *example
    22.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code box contains the same test cases that we saw for *example
    22.1* but written in CMocka this time. We have put all test cases in just one
    file, which has its own `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-10 [ExtremeC_examples_chapter22_1_cmocka_tests.c]: CMocka test
    cases for example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: In CMocka, every test case should return `void` and receive a `void**` argument.
    The pointer argument will be used to receive a piece of information, called a
    `state`, which is specific to a test case. In the `main` function, we create a
    list of test cases, and then finally we call the `cmocka_run_group_tests` function
    to run all the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to test case functions, you see two new functions: `setup` and
    `tear_down`. As we said before, these functions are called test fixtures. Test
    fixtures are called before and after every test case and their responsibility
    is to set up and tear down the test case. The fixture `setup` is called before
    every test case and the fixture `tear_down` is called after every test case. Note
    that the names are optional, and they could be named anything, but we use `setup`
    and `tear_down` for clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important difference between the test cases we wrote before and the
    test cases written using CMocka is the use of different assertion functions. This
    is one of the advantages of using a unit testing framework. There are a wide range
    of assertion functions as part of a testing library that can give you more information
    about their failure, rather than the standard `assert` function, which terminates
    the program immediately and without giving much information. As you can see, we
    have used `assert_int_equal` in the preceding code, which checks the equality
    of two integers.
  prefs: []
  type: TYPE_NORMAL
- en: In order to compile the preceding program, you need to have CMocka installed
    first. On a Debian-based Linux system, it is enough to run `sudo apt-get install
    libcmocka-dev`, and on macOS systems, it is enough to install it by using the
    command `brew install cmocka`. There will be a lot of help available online that
    can help you get through the installation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'After having CMocka installed, you can use the following commands to build
    the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 22-4: Building and running CMocka unit tests written for example
    22.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we had to use `-lcmocka` in order to link the preceding program
    with the installed CMocka library. The output shows the test case names and the
    number of passed tests. Next, we change one of the test cases to make it fail.
    We just modify the first assertion in the `next_even_number__even_numbers_should_be_returned`
    test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-11: Changing one of the CMocka test cases in example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, build the tests and run them again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 22-5: Building and running CMocka unit tests after modifying one
    of them'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, you see that one of the test cases has been failed
    and the reason is shown as an error in the middle of the logs. It shows an integer
    equality assertion failure. As we have explained before, using `assert_int_equal`
    instead of using an ordinary `assert` call allows CMocka to print a helpful message
    in the execution log instead of just terminating the program.
  prefs: []
  type: TYPE_NORMAL
- en: Our next example is about using CMocka's function mocking feature. CMocka allows
    you to mock a function and this way, you can instrument the function to return
    a specific result when a certain input is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, *example 22.2*, we want to demonstrate how to use the
    mocking feature. In this example, the standard function `rand` is used to generate
    random numbers. There is also a function, named `random_boolean`, that returns
    a Boolean based on the oddity of the number returned from the `rand` function.
    Before showing CMocka''s mocking feature, we want to show how to create a stub
    for the `rand` function. You see that this example is different from *example
    22.1*. Next, you can see the declaration of the `random_boolean` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-12 [ExtremeC_examples_chapter22_2.h]: The header file of example
    22.2'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the following code box contains the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-13 [ExtremeC_examples_chapter22_2.c]: The definition of the random_boolean
    function in example 22.2'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we cannot let `random_boolean` use the actual `rand` definition
    in the tests because, as its name implies, it generates random numbers and we
    cannot have a random element in our tests. Tests are about checking expectations
    and the expectations, and the provided inputs, must be predictable. More than
    that, the definition of the `rand` function is part of the C standard library,
    for instance *glibc* in Linux, and using a stub function for it won't be easy
    like what we did in *example 22.1*.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we could send a function pointer to the stub definition
    very easily. But in this example, we are using the `rand` function directly. We
    cannot change the definition of `random_boolean`, and we have to come up with
    another trick to use the stub function for `rand`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use a different definition for the `rand` function, one of the easiest
    ways in C is to play with *symbols* in the final object file. In the *symbol table*
    of the resulting object file, there is an entry for `rand` which refers to its
    actual definition in the C standard library. If we change this entry to refer
    to a different definition of the `rand` function in our testing binaries, we can
    easily substitute the definition of `rand` with our stub one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code box, you can see how we have defined the stub function
    and the tests together. This would be very similar to what we did for *example
    22.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-14 [ExtremeC_examples_chapter22_2_cmocka_tests_with_stub.c]: Writing
    CMocka test cases using a stub function'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the preceding code is mostly following the same pattern that
    we saw as part of the CMocka tests written for *example 22.1* in *Code Box 22-10*.
    Let''s build the preceding file and run the tests. What we expect is to have all
    tests failed because, no matter how you define the stub function, the `random_boolean`
    is picking the `rand` from the C standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 22-6: Building and running CMocka unit tests for example 22.2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time do the trick and change the definition behind the `rand` symbol
    defined as part of the `ex22_2_cmocka_tests_with_stub.out` executable file. Note
    that the following commands are only applicable to Linux systems. We do it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 22-7: Building and running CMocka unit tests for example 22.2 after
    wrapping the rand symbol'
  prefs: []
  type: TYPE_NORMAL
- en: As you see in the output, the standard `rand` function is not being called anymore
    and instead, the stub function returns what we have told it to return. The main
    trick that makes the function `__wrap_rand` be called instead of standard `rand`
    function lies in using the option `-Wl`,`--wrap=rand` in the `gcc` link command.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this option is only available for the `ld` program in Linux and you
    have to use other tricks like *inter-positioning* to call a different function
    in macOS or other systems using a linker other than the GNU linker.
  prefs: []
  type: TYPE_NORMAL
- en: The option `--wrap=rand` tells the linker to update the entry for the symbol
    `rand` in the final executable's symbol table, which is going to refer to the
    definition of the `__wrap_rand` function. Note that this is not a custom name
    and you have to name the stub function like that. The function `__wrap_rand` is
    said to be a *wrapper function*. After updating the symbol table, any call to
    the `rand` function results in calling the `__wrap_func` function. This can be
    verified by looking at the symbol table of the final test binary.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from updating the `rand` symbol in the symbol table, the linker also creates
    another entry. The new entry has the symbol `__real_rand`, which refers to the
    actual definition of the standard `rand` function. Therefore, if we needed to
    run the standard `rand`, we still can use the function name `__real_rand`. This
    is a great usage of the symbol table and the symbols in it, in order to call a
    wrapper function, despite the fact that some people don't like it and they prefer
    to preload a shared object that wraps the actual `rand` function. Whichever method
    you use, you need to finally redirect the calls to the `rand` symbol to another
    stub function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding mechanism would be the basis to demonstrate how function mocking
    works in CMocka. Instead of having a global variable `next_random_num`, as seen
    in *Code Box 22-14*, we can use a mocked function to return the specified value.
    Next, you can see the same CMocka tests but using a mocked function to read the
    test inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-15 [ExtremeC_examples_chapter22_2_cmocka_tests_with_mock.c]: Writing
    CMocka test cases using a mock function'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how the wrapper function `__wrap_rand` is called, we can explain
    the mocking part. Mocking functionality is provided by the pair of functions `will_return`
    and `mock_type`. First, `will_return` should be called, which specifies the value
    that the mock function should return. Then, when the mock function, in this case
    `__wrap_rand`, is called, the function `mock_type` returns the specified value.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we define `10` to be returned from `__wrap_rand` by using `will_return(__wrap_rand,
    10)`, and then the value `10` is returned when the function `mock_type` is called
    inside `__wrap_rand`. Note that every `will_return` must pair with a `mock_type`
    call; otherwise, the test fails. Therefore, if `__wrap_rand` is not called because
    of any reason, the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: As the last note in this section, the output of the preceding code would be
    the same as we saw in Shell Boxes *22-6* and *22-7*. In addition, the same commands,
    of course for the source file `ExtremeC_examples_chapter22_2_cmocka_tests_with_mock.c`,
    must be used to build the code and run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we showed how we can use the CMocka library to write test cases,
    perform assertions, and write mock functions. In the next section, we talk about
    Google Test, another testing framework that can be used to unit test C programs.
  prefs: []
  type: TYPE_NORMAL
- en: Google Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google Test is a C++ testing framework that can be used for unit testing both
    C and C++ programs. Despite being developed in C++, it can be used for testing
    C code. Some consider this as a bad practice, because the test environment is
    not set up using the same compiler and linker that you are going to use for setting
    up the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before being able to use Google Test for writing test cases for *example 22.1*,
    we need to modify the header file in *example 22.1* a bit. The following is the
    new header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-16 [ExtremeC_examples_chapter22_1.h]: The modified header file
    as part of example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have put the declarations in the `extern C { ... }` block.
    We do that only if the macro `_cplusplus` is defined. The preceding change simply
    means that when the compiler is C++, we want to have the symbols *unmangled* in
    the resulting object files, otherwise we will get link errors when the linker
    tries to find definitions for *mangled symbols*. If you don't know about C++ *name
    mangling*, please refer to the last section in *Chapter 2*, *Compilation and Linking*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s continue and write the test cases using Google Test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-17 [ExtremeC_examples_chapter22_1_gtests.cpp]: The test cases written
    using Google Test for example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: The test cases are defined using the `TEST(...)` macro. This is an example of
    how well macros can be used to form a DSL. There are also other macros like `TEST_F(...)`
    and `TEST_P(...)`, which are C++ specific. The first argument passed to the macro
    is the test's class name (Google Test is written for object-oriented C++), which
    can be thought of as the test suite that contains a number of test cases. The
    second argument is the name of the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Note the `ASSERT_EQ` macro, which is used to assert the equality of objects,
    not just integers. There are a great number of expectation checker macros in Google
    Test, which makes it a complete unit testing framework. The final part is the
    `main` function, which runs all the defined tests. Note that the above code should
    be compiled using a C++11-compliant compiler like `g++` and `clang++`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands build the preceding code. Note using the `g++` compiler
    and the option `-std=c++11` which is passed to it. It indicates that C++11 should
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 22-8: Building and running Google Test unit tests for example 22.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'The above output shows a similar output to the CMocka output. It indicates
    that five test cases have been passed. Let''s change the same test case as we
    did for CMocka to break the test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 22-18: Changing one of the test cases written in Google Test'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build the tests again and run them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 22-9: Building and running Google Test unit tests for example 22.1
    after modifying one of the test cases'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see and exactly like CMocka, Google Test also prints out where the
    tests are broken and shows a helpful report. As a final note on Google Test, it
    supports test fixtures but not in the same way that CMocka supports. Test fixtures
    should be defined in a *test class*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: For having mock objects and the mocking functionality, the *Google Mock* (or
    *gmock*) library can be used, but we don't cover it in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through two of the most well-known unit testing libraries
    for C. In the next part of the chapter, we dive into the topic of debugging, which
    is of course a necessary skill for every programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations in which one test or a group of tests fail. Also, there
    are times when you find a bug. In both of these situations, there is a bug, and
    you need to find the root cause and fix it. This involves many sessions of debugging
    and going through the source code to search for the cause of the bug and planning
    the required fixes. But what does it mean to *debug* a piece of software?
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a popularly held belief that the term "debug" originates from the days
    when computers were so large that real bugs (such as moths) could get caught in
    the system''s machinery and lead to malfunctions. Therefore, some people, officially
    called *debuggers*, were sent into the hardware room to remove the bugs from the
    equipment. See this link for more information: https://en.wikipedia.org/wiki/Debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging is an investigative task to find the root cause of an observed bug
    by looking inside and/or outside of a program. When running a program, you usually
    look at it as a black box. When something is wrong with the results or something
    interrupts the execution, however, you need to have a deeper look inside and see
    how the issue is produced. This means that you have to observe the program as
    a white box in which everything can be seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s basically why we can have two different builds for a program: *release*
    and *build*. In release builds, the focus is on the execution and the functionality,
    and the program is mostly seen as a black box, but in debug builds, we can trace
    all the events happening and see the inside of the program as a white box. Debug
    builds are generally useful for development and test environments, but release
    builds are targeted at deployment and production environments.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a debug build, all of the products of a software project, or
    a limited set of them, need to contain *debugging* symbols, which enable a developer
    to track and see the *stack trace* and the execution flow of the program. Usually,
    a release product (executable or libraries) is not suitable for debugging purposes
    because it is not transparent enough to let an observer examine the internals
    of a program. In *Chapter 4*, *Process Memory Structure*, and *Chapter 5*, *Stack
    and Heap*, we discussed how we can build C sources for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: For debugging a program, we mainly use debuggers. Debuggers are standalone programs
    that attach to the target process in order to control or monitor it. While debuggers
    are our main tools for our investigation when working on an issue, other debugging
    tools can also be used to study the memory, concurrent execution flows, or the
    performance of a program. We will talk about these tools in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: A great portion of bugs are *reproducible*, but there are bugs that cannot be
    reproduced or observed in debugging sessions; this is mostly because of the *observer
    effect*. It says, when you want to look at the internals of a program, you alter
    the way it works, and it might prevent some bugs from happening. These sorts of
    issues are disastrous, and they are usually very hard to fix because you cannot
    use your debugging tools to investigate the root cause of the problem!
  prefs: []
  type: TYPE_NORMAL
- en: Some threading bugs in high-performance environments can be categorized in this
    group.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we are going to talk about different categories of
    bugs. Then, we introduce the tools that we use in modern C/C++ development in
    order to investigate bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Bug categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There can be thousands of bugs reported in a piece of software throughout the
    years that it is in use by a customer. But if you look at the types of these bugs,
    they are not many. Next, you can see a list of bug categories that we think are
    important and require special skills to deal with. For sure, this list is not
    complete and there can be other types of bugs that we are missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logical bugs**: In order to investigate these bugs, you need to know the
    code and the execution flow of the code. To see the actual execution flow of a program,
    a debugger should be attached to a running process. Only then, the execution flow
    can be *traced* and analyzed. *Execution logs* can also be used when debugging
    a program, especially when debugging symbols are not available in the final binaries
    or a debugger cannot be used to attach to an actual running instance of the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory bugs**: These bugs are memory related. They occur usually because
    of dangling pointers, buffer overflows, double frees, and so on. These bugs should
    be investigated using a *memory profiler*, which acts as a debugging tool for
    observing and monitoring memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency bugs**: Multi-processing and multithreading programs have always
    been the birthplace of some of the hardest-to-solve bugs found in the software
    industry. You need special tools like *thread sanitizers* in order to detect particularly
    difficult issues such as race conditions and data races.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance bugs**: New developments may result in *performance degradation*
    or performance bugs. These bugs should be investigated using further and more
    focused testing and even debugging. Execution logs, which contain annotated historical
    data for the previous executions, can be useful in order to find the exact change
    or changes that have initiated the degradation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we are going to talk about various tools introduced
    in the preceding list.
  prefs: []
  type: TYPE_NORMAL
- en: Debuggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have talked about debuggers, especially `gdb`, in *Chapter 4*, *Process
    Memory Structure*, and we used it to see inside a process''s memory. In this section,
    we are going to give debuggers a second look and describe their role in daily
    software development. The following is a list of common features provided by most
    modern debuggers:'
  prefs: []
  type: TYPE_NORMAL
- en: A debugger is a program, and like all other programs, it runs as a process.
    The debugger process can attach to another process given the target process ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A debugger can control the execution of the instructions in the target process
    after a successful attachment; therefore, the user is able to pause and continue
    the flow of the execution in the target process, using an interactive debugging
    session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debuggers can see inside the protected memory of a process. They can also modify
    the contents, therefore a developer can run the same group of instructions while
    the memory content is being changed deliberately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all of the known debuggers, if the debugging symbols are provided while
    compiling the sources to relocatable object files, can trace back the instructions
    to the source code. In other words, when you pause on an instruction, you can
    go to its corresponding line of code in the source file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the debugging symbols are not provided in the target object file, the debugger
    can show the disassembly code of a target instruction, which can still be useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some debuggers are language-specific, but most of them are not. **Java Virtual
    Machine** (**JVM**) languages such as Java, Scala, and Groovy have to use JVM
    debuggers in order to see and control the internals of a JVM instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreted languages like Python have also their own debuggers, which can be
    used to pause and control a script. While the low-level debuggers like `gdb` are
    still usable for JVM or scripting languages, they try to debug the JVM or interpreter
    processes instead of the executing Java bytecode or Python script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A list of the debuggers can be found on Wikipedia as part of the following
    link: https://en.wikipedia.org/wiki/List_of_debuggers. From this list, the following
    debuggers are eye-catching:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Debugger** (**adb**): The default Unix debugger. It has different
    implementations based on the actual Unix implementation. It has been the default
    debugger on Solaris Unix.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**GNU Debugger** (**gdb**): The GNU version of the Unix debugger, which is
    the default debugger on many Unix-like operating systems including Linux.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**LLDB**: A debugger mainly designed for debugging object files produced by
    LLVM compilers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Python Debugger**: Used in Python to debug Python script.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Java Platform Debugger Architecture** (**JPDA**): This one is not a debugger,
    but it is an API designed for debugging programs running inside a JVM instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**OllyDbg**: A debugger and disassembler used in Microsoft Windows for debugging
    GUI applications.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Microsoft Visual Studio Debugger**: The main debugger used by Microsoft Visual
    Studio.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to `gdb`, one can use `cgdb`. The `cgdb` program shows a terminal
    code editor next to the `gdb` interactive shell that allows you to move between
    the code lines easier.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed debuggers as the main tools for investigating
    an issue. In the next section, we will be talking about memory profilers, which
    are vital for investigating memory-related bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Memory checkers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes when you encounter a memory-related bug or a crash, a debugger alone
    cannot help much. You need another tool that can detect the memory corruptions
    and invalid read or writes to the memory cells. The tool you need is a *memory
    checker* or a *memory profiler*. It could be part of a debugger, but it is usually
    provided as a separate program and the way it detects memory misbehaviors is different
    from a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'We usually can expect the following features from a memory checker:'
  prefs: []
  type: TYPE_NORMAL
- en: Reporting the total amount of allocated memory, freed memory, used static memory,
    Heap allocations, Stack allocations, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-leak detection, which can be considered as the most important feature
    that a memory checker provides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection of invalid memory read/write operations like out-of-bound access regarding
    buffers and arrays, writes to an already freed memory region, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection of a *double free* issue. It happens when a program tries to free
    an already freed memory region.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have seen memory checkers like *Memcheck* (one of the Valgrind's
    tools) in some of the chapters, particularly *Chapter 5*, *Stack and Heap*. We
    have also discussed the different types of memory checkers and memory profilers
    in chapter 5\. Here, we want to explain them again, and give more details about
    each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory checkers all do the same thing, but the underlying technique they use
    to monitor memory operations can be different. Therefore, we group them based
    on the technique they use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compile-time overriding**: For using a memory checker employing this technique,
    you need to make some, usually slight, changes to your source code like including
    a header file from the memory checker library. Then, you need to compile your
    binaries again. Sometimes, it is necessary to link the binaries against the libraries
    provided by the memory checker. The advantage is that the performance drop of
    the executing binary is less than the other techniques, but the disadvantage is
    that you need to recompile your binaries. **LLVM AddressSanitizer** (**ASan**),
    Memwatch, Dmalloc, and Mtrace are memory profilers using this technique.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link-time overriding**: This group of memory checkers is like the previous
    group of memory checkers, but the difference is that you don''t need to change
    your source code. Instead, you only have to link the resulting binaries with the
    provided libraries from the memory checker and no change is made to the source
    code. The *heap checker* utility in *gperftools* can be used as a link-time memory
    checker.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Runtime interception**: A memory checker using this technique sits between
    the program and the OS and tries to intercept and track all memory-related operations
    and report whenever a misbehavior or invalid access is seen. It also can give
    leak reports based on the total allocations and freed memory blocks. The main
    advantage of using this technique is that you don''t need to recompile or relink
    your program in order to use the memory checker. The big disadvantage is the significant
    overhead it introduces to the execution of the program. Also, the memory footprint
    would be much higher than when running the program without the memory checker.
    This is definitely not an ideal environment to debug high-performance and embedded
    programs. The Memcheck tool in Valgrind can be used as a runtime interceptor memory
    checker. These memory profilers should be used with a debug build of the code
    base.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Preloading libraries**: Some memory checkers use *inter-positioning* in order
    to wrap standard memory functions. Therefore, by preloading the memory checker''s
    shared libraries using the `LD_PRELOAD` environment variable, the program can
    use the wrapper functions and the memory checker can intercept the calls to underlying
    standard memory functions. The *heap checker* utility in *gperftools* can be used
    like this.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usually, it is not enough to use a specific tool for all memory issues because
    each of them has its own advantages and disadvantages, which make that tool specific
    to a certain context.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through the available memory profilers and categorized
    them based on the technique they use to record memory allocations and deallocations.
    In the next section, we are going to talk about thread sanitizers.
  prefs: []
  type: TYPE_NORMAL
- en: Thread debuggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Thread sanitizers* or *thread debuggers* are programs that are used to debug
    multithreading programs to find concurrency-related issues while the program is
    running. Some of the issues they can find are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Data races, and the exact places in different threads where the read/write operations
    have caused the data race
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Misusing the threading API, especially POSIX threading API in POSIX-compliant
    systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible deadlocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock ordering issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both thread debuggers and memory checkers can detect issues as *false positives*.
    In other words, they may find and report some issues but after being investigated,
    it becomes clear that they are not issues. This really depends on the technique
    these libraries use for tracking the events, and making a final decision about
    that event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following list, you can find a number of well-known available thread
    debuggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Helgrind** (**from Valgrind**): It is another tool inside Valgrind mainly
    used for thread debugging. DRD is also another thread debugger as part of the
    Valgri[nd toolkit. The list of features and differenc](http://valgrind.org/docs/manual/hg-manual.html)es
    ca[n be seen in these links: http://valgrind.org/d](http://valgrind.org/docs/manual/drd-manual.html)ocs/manual/hg-manual.html
    and http://valgrind.org/docs/manual/drd-manual.html. Like all other tools from
    Valgrind, using Helgrind doesn''t need you to modify your source. For running
    Helgrind, you need to run the command `valgrind --tool=helgrind [path-to-executable]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intel Inspector**: This successor to *Intel Thread Checker* performs an analysis
    of threading errors and memory issues. Therefore, it is a thread debugger as well
    as a memory checker. It is not free like Valgrind, and proper licenses must be
    purchased in order to use the tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LLVM ThreadSanitizer** (**TSan**): This is part of the LLVM toolkit, and
    it comes with LLVM AddressSanitizer, described in the previous section. Some slight
    compile-time modifications are needed in order to use the debugger and the code
    base should be recompiled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we discussed thread debuggers and we introduced some of the
    available thread debuggers in order to debug threading issues. In the next section,
    we provide the programs and toolkits that are used to tune the performance of
    a program.
  prefs: []
  type: TYPE_NORMAL
- en: Performance profilers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes the results of a group of non-functional tests indicate a degradation
    in performance. There are specialized tools for investigating the cause of the
    degradation. In this section, we are going to have a quick look at the tools which
    can be used to analyze performance and find performance bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: 'These performance debuggers usually offer a subset of the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Gather statistics about every single function call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a *function call graph* used to trace function calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gather memory-related statistics for each function call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gather lock contention statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gather memory allocation/deallocation statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache analysis, giving cache usage statistics and showing parts of the code
    that are not cache-friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gather statistics about threading and synchronization events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a list of the most well-known programs and toolkits that can
    be used for performance profiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Google Performance Tools** (**gperftools**): This is actually a performant
    `malloc` implementation, but as it says on its home page, it provides some performance
    analytics tools like *heap checker*, which was introduced in the previous sections
    as a memory profiler. It should be linked with the final binary in order to be
    usable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callgrind** (**as part of Valgrind**): Mainly gathers statistics about the
    function calls and the caller/callee relationship between two functions. There
    is no need to change the source code or link the final binaries and it can be
    used on the fly, with a debug build, of course.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intel VTune**: This is a performance profiling suite from Intel that is a complete
    set of all the features given in the preceding list. Proper licenses must be purchased
    in order to use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter was about unit testing and debugging C programs. As a summary,
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We talked about testing, and why it is important to us as software engineers
    and development teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also discussed the different levels of testing like unit testing, integration
    testing, and system testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional and non-functional testing were also covered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regression testing was explained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMocka and Google Test, as two well-known testing libraries for C, were explored
    and some examples were given.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We talked about debugging and various types of bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed debuggers, memory profilers, thread debuggers, and performance
    debuggers which can help us to have a more successful investigation while working
    on a bug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter is about the *build systems* available for C projects. We will
    discuss what a build system is and what features it can bring in, which will eventually
    help us to automate the process of building a huge C project.
  prefs: []
  type: TYPE_NORMAL
