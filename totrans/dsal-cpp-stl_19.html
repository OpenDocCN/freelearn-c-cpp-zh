<html><head></head><body>
		<div><h1 id="_idParaDest-679" class="chapter-number"><a id="_idTextAnchor679"/>19</h1>
			<h1 id="_idParaDest-680"><a id="_idTextAnchor680"/>Exception Safety</h1>
			<p>This chapter will guide you through the complexities of exception safety. It demystifies the levels of exception safety, distinguishing between basic and strong guarantees, underscoring their significance, and offering proven strategies to achieve them. Mastering these advanced topics allows you to create more resilient, efficient, and adaptable C++ applications and data structures.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Basic exception safety</li>
				<li>Strong exception safety</li>
				<li>The effect of <code>noexcept</code> on STL containers</li>
			</ul>
			<h1 id="_idParaDest-681"><a id="_idTextAnchor681"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub:</p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>
			<h1 id="_idParaDest-682"><a id="_idTextAnchor682"/>Basic exception safety</h1>
			<p><strong class="bold">Basic exception safety</strong>, colloquially<a id="_idIndexMarker1040"/> termed the <em class="italic">guarantee</em>, pledges that your program won’t leak resources when an exception occurs and its invariants are preserved. Simply put, the software won’t devolve into chaos. When unforeseen exceptions occur, the operation might fail, but your application continues functioning, and no data gets mangled.</p>
			<p>Two real-world examples of unforeseen exceptions that can be effectively managed without causing resource leaks or data corruption include the following:</p>
			<ul>
				<li><strong class="bold">File operation failure during data processing</strong>: Consider an application that processes large data files. During this process, the application might encounter an unexpected exception, such as a failure to read a portion of the file due to disk I/O errors. In this case, basic exception safety ensures the application does not leak resources (such as file handles or memory allocated for data processing). It maintains the integrity of any data structures involved. The application<a id="_idIndexMarker1041"/> might not complete the intended file processing. Still, it will handle the exception gracefully, freeing up any resources and leaving the application in a stable state to continue functioning.</li>
				<li><strong class="bold">Network communication interruption in a client-server application</strong>: In a client-server application, an unforeseen exception might occur if the network connection is suddenly lost during a critical data exchange. Basic exception safety in this scenario ensures that the application does not end up with partial or corrupted data states. The system might fail to complete the current operation (such as updating a record or retrieving data), but it will effectively manage resources such as network sockets and memory buffers. The application will catch the exception, clean up resources, and ensure its core functionality remains intact and ready for subsequent operations.</li>
			</ul>
			<h2 id="_idParaDest-683"><a id="_idTextAnchor683"/>The pivotal role of program invariants in the STL</h2>
			<p>Imagine<a id="_idIndexMarker1042"/> you’re crafting a sophisticated application, and at its heart lies the C++ <code>std::vector</code>, <code>std::map</code>, or any other, operates under specific invariants. A <code>std::vector</code> container, for instance, guarantees contiguous memory. If any operation disrupts these invariants, the results can range from performance penalties to insidious bugs.</p>
			<p>To ensure basic exception safety with the STL, you need to ascertain that operations on these containers either succeed or, if they throw an exception, leave the container in its original state without violating its invariants. For instance, if a <code>push_back</code> operation on <code>std::vector</code> throws an exception, the vector should remain untouched.</p>
			<p>Let’s look at an example of how we could use basic exception safety when pushing data into <code>std::vector</code>:</p>
			<pre class="source-code">
// Adds an element to the vector, ensuring basic exception
// safety
void safePushBack(std::vector&lt;int&gt; &amp;vec, int value) {
  try {
    // Attempt to add value to the vector
    vec.push_back(value);
  } catch (const std::exception &amp;e) {
    // Handle any exception thrown by push_back
    std::cerr &lt;&lt; "Exception caught: " &lt;&lt; e.what() &lt;&lt; "\n";
    // No additional action needed, vec is already in its
    // original state
  }
}</pre>			<p>In this example, if <a id="_idIndexMarker1043"/>an exception occurs (i.e., due to <code>bad_alloc</code> if the system runs out of memory), the <code>catch</code> block handles it. Importantly, if <code>push_back</code> throws an exception, it guarantees that the state of the vector (<code>vec</code>) remains unchanged, thus preserving the container’s invariants.</p>
			<h2 id="_idParaDest-684"><a id="_idTextAnchor684"/>Resource integrity – the guardian of robust software</h2>
			<p>An <a id="_idIndexMarker1044"/>exception thrown during a memory allocation or other resource-intensive tasks can spell disaster if not managed correctly. The STL, however, offers tools that, when used aptly, ensure that resources remain intact, even when exceptions loom.</p>
			<p>STL containers such as <code>std::vector</code> and <code>std::string</code> handle their memory. If an exception arises during an operation, the container ensures no memory leaks occur. Moreover, the<a id="_idIndexMarker1045"/> idiom <strong class="bold">Resource Acquisition Is Initialization</strong> (<strong class="bold">RAII</strong>), a hallmark of C++ design, assures that resources are acquired upon object creation and released when they go out of scope. The RAII principle is a sentinel against resource leaks, particularly during <a id="_idIndexMarker1046"/>exceptions.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">RAII, is a programming idiom used in C++ to manage resource allocation and deallocation. In RAII, resources (such as memory, file handles, and network connections) are acquired and released by objects. When an object is created (initialized), it acquires a resource, and when the object is destroyed (its lifetime ends), it releases the resource. This ensures automatic and exception-safe resource management, preventing resource leaks and ensuring clean resource release even in the face of exceptions. RAII is a fundamental concept in C++ for effective resource management.</p>
			<h2 id="_idParaDest-685"><a id="_idTextAnchor685"/>Harnessing the STL for basic exception safety</h2>
			<p>With the <a id="_idIndexMarker1047"/>STL at your disposal and knowledge of its intricacies, achieving basic exception safety becomes less daunting. Consider the following best practices:</p>
			<ul>
				<li><strong class="bold">Leveraging the copy-and-swap idiom</strong>: When modifying STL containers, a common technique to ensure exception safety is to create a copy of the container, perform the operations on the copy, and then swap the contents with the original. If an exception arises, the original remains unaffected.</li>
				<li><code>std::shared_ptr </code>and <code>std::unique_ptr</code> not only manage memory but also guarantee no leaks during exceptions.</li>
				<li><strong class="bold">Guarded operations</strong>: Before any irreversible operation on an STL container, always ensure that any operation that can throw an exception has already been executed.</li>
				<li><strong class="bold">Staying informed with STL documentation</strong>: Familiarize yourself with the exception guarantees of STL functions and methods. Awareness of what exceptions a particular STL function might throw aids in crafting resilient software.</li>
			</ul>
			<p>Embracing basic exception safety with the STL sets the stage for more resilient, reliable, and robust software. With this foundational understanding, you’re equipped to tackle the intricacies of STL, ensuring <a id="_idIndexMarker1048"/>that even when the unexpected occurs, your software stands unyielding. But this is just the beginning, as the next level, strong exception safety, beckons, offering even more robust guarantees and strategies to wield the STL with finesse.</p>
			<h1 id="_idParaDest-686"><a id="_idTextAnchor686"/>Strong exception safety</h1>
			<p>As you immerse <a id="_idIndexMarker1049"/>yourself further into the intricate world of C++ and the STL, you’ll encounter the term <em class="italic">strong exception safety</em>. This is not just fancy jargon but also the gold standard in the STL’s exception handling. It guarantees developers an assurance like no other – operations will either complete successfully or revert to their previous state without any side effects. It’s like having a safety net that ensures, come what may, your application’s integrity remains unscathed.</p>
			<h2 id="_idParaDest-687"><a id="_idTextAnchor687"/>Navigating STL containers with strong guarantees</h2>
			<p>Remember those <a id="_idIndexMarker1050"/>dynamic days spent with <code>std::vector</code>, <code>std::map</code>, and other STL containers? Now, think of adding elements, resizing, or even modifying them. When these operations succeed, it is business as usual. But if they falter and throw an exception, strong exception safety guarantees that the container remains as it was, untouched and unaltered.</p>
			<p>Achieving this with STL containers, fortunately, doesn’t demand Herculean efforts. Many STL container operations naturally provide strong exception safety. But when they don’t, techniques such as the <em class="italic">copy-and-swap</em> idiom rescue them. By operating on a copy and swapping the contents with the original only when sure of success, you can guarantee no changes to the original container if an exception is thrown.</p>
			<h2 id="_idParaDest-688"><a id="_idTextAnchor688"/>Crafting custom STL containers with strong guarantees</h2>
			<p>When<a id="_idIndexMarker1051"/> venturing into the territory of creating custom STL containers, the responsibility to ensure strong exception safety rests squarely on your shoulders. Key strategies to achieve this include the following practices:</p>
			<ul>
				<li><strong class="bold">Localized commit points</strong>: By delaying any changes that affect the container’s state until the very last moment and ensuring that these changes are exception-free once started, you solidify a strong guarantee.</li>
				<li><strong class="bold">RAII to the forefront</strong>: Harnessing the might of RAII, especially with resource management, is pivotal. This ensures that resources are appropriately managed and cleaned up if there are exceptions, leaving the container unchanged.</li>
				<li><strong class="bold">Immutable operations</strong>: Whenever possible, design operations that don’t modify the container until they’re sure of success.</li>
			</ul>
			<p>To illustrate<a id="_idIndexMarker1052"/> the concept of creating custom STL containers with strong guarantees, let’s consider the example of a custom container that manages a dynamic array. The code will demonstrate localized commit points, the RAII idiom, and immutable operations to provide strong exception safety.</p>
			<p>First, we are going to create<a id="_idIndexMarker1053"/> the <code>CustomArray</code> class. The <code>CustomArray</code> class is a template class designed to manage dynamic arrays of a specified data type, <code>T</code>. It provides essential functionalities for creating, copying, moving, and managing dynamic arrays with a strong exception guarantee. The class uses RAII principles and leverages <code>std::unique_ptr</code> for resource management, ensuring efficient and safe memory handling. It supports both copy and move semantics, making it suitable for use in various scenarios, such as dynamic array manipulation and container reallocation. Let’s walk through this in sections.</p>
			<p>We will break this example up into several sections to discuss here. For the full code example, please refer to the GitHub repository. First, we will look at the constructors:</p>
			<pre class="source-code">
template &lt;typename T&gt; class CustomArray {
public:
  explicit CustomArray(size_t size)
      : size(size), data(std::make_unique&lt;T[]&gt;(size)) {
    // Initialize with default values, assuming T can be
    // default constructed safely std::fill provides strong
    // guarantee
    std::fill(data.get(), data.get() + size, T());
  }
  // Copy constructor
  CustomArray(const CustomArray &amp;other)
      : size(other.size),
        data(std::make_unique&lt;T[]&gt;(other.size)) {
    safeCopy(data.get(), other.data.get(), size);
  }
  // Move constructor - noexcept for strong guarantee
  // during container reallocation
  CustomArray(CustomArray &amp;&amp;other) noexcept
      : size(other.size), data(std::move(other.data)) {
    other.size = 0;
  }
  void safeCopy(T *destination, T *source, size_t size) {
    // std::copy provides strong guarantee
    std::copy(source, source + size, destination);
  }</pre>			<p>We <a id="_idIndexMarker1054"/>provided three constructors for our class:</p>
			<ul>
				<li><code>explicit CustomArray(size_t size)</code>: This is the primary constructor of the <code>CustomArray</code> class. It allows you to create an instance of the class by specifying the desired size for the dynamic array. It initializes the <code>size</code> member variable with the provided size and allocates memory for the dynamic array, using <code>std::make_unique</code>. It also initializes the elements of the array with default values (assuming that type <code>T</code> can be safely default-constructed), using <code>std::fill</code>. This <a id="_idIndexMarker1055"/>constructor is marked as <code>explicit</code>, meaning it cannot be used for implicit type conversions.</li>
				<li><code>CustomArray(const CustomArray &amp;other)</code>: This is the copy constructor of the <code>CustomArray</code> class. It allows you to create a new <code>CustomArray</code> object that is a copy of an existing <code>CustomArray</code> object, <code>other</code>. It initializes the <code>size</code> member with the size of <code>other</code>, allocates memory for the dynamic array, and then uses the <code>safeCopy</code> function to perform a deep copy of the data from <code>other</code> to the new object. This constructor is used when you want to create a new copy of an existing object.</li>
				<li><code>CustomArray(CustomArray &amp;&amp;other)noexcept</code>: This is the move constructor of the <code>CustomArray</code> class. It enables you to efficiently transfer ownership of the data from one <code>CustomArray</code> object (typically <code>rvalue</code>) to another. It transfers the ownership of the dynamically allocated array from <code>other</code> to the current object using <code>std::move</code>, updates the <code>size</code> member, and sets <code>size</code> of <code>other</code> to zero to indicate that it no longer owns the data. This constructor is marked <code>noexcept</code> to ensure a strong guarantee during container reallocation, meaning it won’t throw exceptions. It’s used when you want <a id="_idIndexMarker1056"/>to move the contents of one object into another, typically for optimization purposes.</li>
			</ul>
			<p>Next, let’s look at the assignment operator overloads:</p>
			<pre class="source-code">
  // Copy assignment operator
  CustomArray &amp;operator=(const CustomArray &amp;other) {
    if (this != &amp;other) {
      std::unique_ptr&lt;T[]&gt; newData(
          std::make_unique&lt;T[]&gt;(other.size));
      safeCopy(newData.get(), other.data.get(),
               other.size);
      size = other.size;
      data = std::move(
          newData); // Commit point, only change state here
    }
    return *this;
  }
  // Move assignment operator - noexcept for strong
  // guarantee during container reallocation
  CustomArray &amp;operator=(CustomArray &amp;&amp;other) noexcept {
    if (this != &amp;other) {
      data = std::move(other.data);
      size = other.size;
      other.size = 0;
    }
    return *this;
  }</pre>			<p>Here, we<a id="_idIndexMarker1057"/> provided two overloads of the assignment operator. These two member functions are assignment operators for the <code>CustomArray</code> class:</p>
			<ul>
				<li><code>CustomArray &amp;operator=(const CustomArray &amp;other)</code>: This is the copy assignment operator. It allows you to assign the contents of one <code>CustomArray</code> object to another of the same type. It performs a deep copy of the data from <code>other</code> to the current object, ensuring that both objects have independent copies of the data. It also updates the <code>size</code> member and transfers ownership of the new data using <code>std::move</code>. The operator returns a reference to the current object, allowing for chaining assignments.</li>
				<li><code>CustomArray &amp;operator=(CustomArray &amp;&amp;other) noexcept</code>: This is<a id="_idIndexMarker1058"/> the move assignment operator. It allows you to efficiently transfer ownership of the data from one <code>CustomArray</code> object (typically <code>rvalue</code>) to another. It moves <code>std::unique_ptr</code> containing the data from <code>other</code> to the current object, updates the <code>size</code> member, and sets <code>size</code> of <code>other</code> to zero to indicate that it no longer owns the data. This operator is marked <code>noexcept</code> to ensure a strong guarantee during container reallocation, meaning it won’t throw exceptions. Like the copy assignment operator, it returns a reference to the current object:</li>
			</ul>
			<pre class="source-code">
int main() {
  try {
    // CustomArray managing an array of 5 integers
    CustomArray&lt;int&gt; arr(5);
    // ... Use the array
  } catch (const std::exception &amp;e) {
    std::cerr &lt;&lt; "An exception occurred: " &lt;&lt; e.what()
              &lt;&lt; '\n';
    // CustomArray destructor will clean up resources if an
    // exception occurs
  }
  return 0;
}</pre>			<p>To summarize this example, the <code>CustomArray</code> class demonstrates the following principles:</p>
			<ul>
				<li><code>data</code>) is only changed at commit points, such as at the end of the copy assignment operator, after the success of all operations that could potentially throw an exception.</li>
				<li><code>std::unique_ptr</code> manages the dynamic array, ensuring that memory is automatically deallocated when the <code>CustomArray</code> object goes out of scope or an exception occurs.</li>
				<li><strong class="bold">Immutable operations</strong>: Operations that could throw exceptions, such as memory allocation and copying, are performed on temporary objects. The container’s state is modified only when these operations are guaranteed to have succeeded.</li>
			</ul>
			<p>This example<a id="_idIndexMarker1059"/> follows C++ and STL best practices and uses modern C++ features, ensuring a custom container that respects strong exception safety guarantees.</p>
			<h2 id="_idParaDest-689"><a id="_idTextAnchor689"/>Infusing exception safety into custom STL algorithms</h2>
			<p>Algorithms <a id="_idIndexMarker1060"/>dance in harmony with data. In the STL, ensuring that custom algorithms provide strong exception safety guarantees can be the difference between an efficient application and one riddled with unpredictable behaviors.</p>
			<p>To ensure this, you should keep the following in mind:</p>
			<ul>
				<li><strong class="bold">Operate on copies</strong>: Wherever feasible, operate on a copy of the data, ensuring the original remains unmodified if exceptions are thrown.</li>
				<li><strong class="bold">Atomic operations</strong>: Design algorithms where operations, once started, are completed successfully or can be rolled back without side effects.</li>
			</ul>
			<h2 id="_idParaDest-690"><a id="_idTextAnchor690"/>Exception safety is the path to robust applications</h2>
			<p>Strong exception safety is<a id="_idIndexMarker1061"/> more than just a tenet – it is a commitment to the reliability and robustness of your application. When wielding the STL, its containers, and its algorithms or venturing into creating your own, this guarantee stands as a bulwark against unforeseen exceptions and unpredictable behaviors.</p>
			<p>By ensuring that operations either see through to their successful completion or restore the original state, strong exception safety not only elevates the reliability of applications but also imbues developers with confidence that their software can weather the storms of exceptions, leaving the integrity of their data and resources intact.</p>
			<p>With this, we wrap up our exploration of exception safety in the STL. As we explored basic and strong guarantees, the hope is that you’re now equipped with the knowledge and tools to craft resilient and dependable C++ applications. And remember that in the dynamic world of software development, it is not just about preventing exceptions but also ensuring we’re prepared when they arise. Next, we will examine the use of <code>noexcept</code> on STL operations.</p>
			<h1 id="_idParaDest-691"><a id="_idTextAnchor691"/>The effect of noexcept on STL operations</h1>
			<p>The C++ STL gives <a id="_idIndexMarker1062"/>a rich assortment of data structures and algorithms that greatly simplify programming in C++. Exception safety is a critical aspect of robust C++ programming, and the <code>noexcept</code> specifier plays a pivotal role in achieving it. This section elucidates the impact of noexcept on STL operations and how its correct application can enhance the reliability and performance of STL-based code.</p>
			<h2 id="_idParaDest-692"><a id="_idTextAnchor692"/>An introduction to noexcept</h2>
			<p>Introduced<a id="_idIndexMarker1063"/> in C++11, <code>noexcept</code> is a specifier that can be added to function declarations to indicate that the function is not expected to throw exceptions. When a function is declared with <code>noexcept</code>, it enables specific optimizations and guarantees that make exception handling more predictable. For instance, when an exception is thrown from a <code>noexcept</code> function, the program calls <code>std::terminate</code>, as the function violated its contract of not throwing exceptions. Hence, <code>noexcept</code> is a commitment that a function promises to uphold.</p>
			<h2 id="_idParaDest-693"><a id="_idTextAnchor693"/>Application to STL data types</h2>
			<p>Using <code>noexcept</code> with <a id="_idIndexMarker1064"/>STL data types primarily affects the move operations – move constructors and move assignment operators. These operations are fundamental to the performance of STL containers, since they allow the transfer of resources from one object to another without costly deep copies. When these operations are <code>noexcept</code>, STL containers can safely perform optimizations, such as reallocating buffers more efficiently during resizing operations.</p>
			<p>Consider a scenario with <code>std::vector</code>, an STL container that dynamically resizes itself as elements are added. Suppose the vector holds objects of a type whose move constructor is <code>noexcept</code>. In that case, the vector can reallocate its internal array by moving the objects to the new array without the overhead of handling potential exceptions. If the move constructor is not <code>noexcept</code>, the vector must use the copy constructor instead, which is less efficient and might throw exceptions, leading to a potential partial state and loss of strong exception safety.</p>
			<h2 id="_idParaDest-694"><a id="_idTextAnchor694"/>Application to STL algorithms</h2>
			<p>The <a id="_idIndexMarker1065"/>impact of <code>noexcept</code> extends beyond data types to algorithms. STL algorithms can offer stronger guarantees and perform better when working with functions that are <code>noexcept</code>. For example, <code>std::sort</code> can execute more efficiently if its comparison function does not throw exceptions. The algorithm can optimize its implementation, knowing that it does not need to account for the complications that arise from exception handling.</p>
			<p>Let’s take the <code>std::for_each</code> algorithm, which applies a function to a range of elements. If the used function is marked as <code>noexcept</code>, <code>std::for_each</code> can operate with the understanding that exceptions will not interrupt the iteration. This can lead to better inlining and reduced overhead, as the compiler does not need to generate additional code to handle exceptions.</p>
			<p>Consider the following example:</p>
			<pre class="source-code">
std::vector&lt;int&gt; data{1, 2, 3, 4, 5};
std::for_each(data.begin(), data.end(), [](int&amp; value) noexcept {
    value *= 2;
});</pre>			<p>In this example, the lambda function passed to <code>std::for_each</code> is declared <code>noexcept</code>. This<a id="_idIndexMarker1066"/> informs the compiler and the algorithm that the function is guaranteed not to throw any exceptions, allowing potential performance optimizations.</p>
			<p>The <code>noexcept</code> specifier is a powerful tool for C++ developers, providing performance optimizations and semantic guarantees about exception safety. When applied judiciously to STL operations, <code>noexcept</code> enables STL containers and algorithms to operate more efficiently and reliably. Understanding and using <code>noexcept</code> appropriately is essential for intermediate-level C++ developers looking to write high-quality, exception-safe code with STL.</p>
			<h1 id="_idParaDest-695"><a id="_idTextAnchor695"/>Summary</h1>
			<p>In this chapter, we looked to understand the crucial concept of exception safety with the STL. We explored the different levels of exception safety, namely basic and strong guarantees, and outlined strategies to ensure that your programs are resilient to exceptions. We learned how to maintain program invariants and resource integrity through detailed discussions, mainly focusing on RAII principles and guarded operations to prevent resource leaks and maintain container states during exceptions.</p>
			<p>Understanding exception safety is indispensable for writing robust C++ applications. It ensures that, even in the face of errors, your software’s integrity remains intact, preventing resource leaks and preserving the validity of data structures. This knowledge is the backbone of reliable and maintainable code, as it allows us to uphold strong guarantees that our applications will behave predictably under exceptional conditions.</p>
			<p>In the next chapter, titled <em class="italic">Thread Safety and Concurrency with the STL</em>, we will build upon the foundation of exception safety to tackle the intricacies of concurrent programming in C++.</p>
		</div>
	</body></html>