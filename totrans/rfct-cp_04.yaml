- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identifying Ideal Candidates for Rewriting – Patterns and Anti-Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring is a crucial technique in software development that involves making
    changes to existing code to improve its structure, readability, and maintainability
    without altering its behavior. It is vital for several reasons.
  prefs: []
  type: TYPE_NORMAL
- en: It helps to eliminate technical debt and enhance the overall quality of the
    code base. Developers can achieve this by removing redundant or duplicate code,
    simplifying complex code, and improving code readability, resulting in more maintainable
    and robust software.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring facilitates future development. By restructuring code to be more
    modular, developers can reuse existing code more effectively, saving time and
    effort in future development. This makes code more flexible and adaptable to change,
    making it easier to add new features, fix bugs, and optimize performance.
  prefs: []
  type: TYPE_NORMAL
- en: Well-structured and maintainable code makes it easier for multiple developers
    to collaborate effectively on a project. Refactoring helps to standardize code
    practices, reduce complexity, and improve documentation, making it easier for
    developers to understand and contribute to a code base.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, refactoring reduces costs associated with software development in
    the long term. By improving code quality and maintainability, refactoring can
    help to reduce the time and effort required for bug fixes, updates, and other
    maintenance tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on identifying good candidates for refactoring
    in C++ projects. However, identifying the right code segments for refactoring
    can be challenging, especially in large and complex systems. Therefore, it is
    essential to understand the factors that make code segments ideal candidates for
    refactoring. In this chapter, we will explore these factors and provide guidelines
    for identifying good candidates for refactoring in C++. We will also discuss common
    refactoring techniques and tools that can be used to improve the quality of C++
    code.
  prefs: []
  type: TYPE_NORMAL
- en: What kind of code is worth rewriting?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Determining whether a piece of code is worth rewriting depends on several factors,
    including the code’s maintainability, readability, performance, scalability, and
    adherence to best practices. Let’s look at some situations where code may be worth
    rewriting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Smelly code** is often an indication that code needs to be rewritten. These
    are signs of poor design or implementation, such as long methods, large classes,
    duplicated code, or poor naming conventions. Addressing these code smells can
    improve the overall quality of the code base and make it easier to maintain in
    the long run.'
  prefs: []
  type: TYPE_NORMAL
- en: Code that exhibits low cohesion or high coupling might be worth rewriting. Low
    cohesion means that the elements within a module or class are not closely related,
    and the module or class has too many responsibilities. High coupling refers to
    a high degree of dependency between modules or classes, making the code harder
    to maintain and modify. Refactoring such code can lead to a more modular and easier-to-understand
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we discussed the importance of SOLID principles; code
    that violates them can also be worth rewriting.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to rewrite code is if it relies on outdated technologies, libraries,
    or programming practices. Such code can become increasingly difficult to maintain
    over time and may not take advantage of newer, more efficient methods or tools.
    Updating the code to use current technologies and practices can improve its performance,
    security, and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if the code has performance or scalability issues, it may be worth rewriting.
    This can involve optimizing algorithms, data structures, or resource management
    to ensure that the code runs more efficiently and can handle larger workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Smelly code and its basic characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Smelly code**, also known as **code smells**, refers to the symptoms in a
    code base that suggest underlying design or implementation issues. These symptoms
    are not necessarily bugs but are indicators of potential problems that can make
    the code harder to understand, maintain, and modify. Code smells are often the
    result of poor coding practices or the accumulation of technical debt over time.
    Although code smells might not directly affect the functionality of a program,
    they can significantly impact the overall code quality, leading to an increased
    risk of bugs and a decrease in developer productivity.'
  prefs: []
  type: TYPE_NORMAL
- en: One aspect of addressing smelly code involves identifying and applying appropriate
    design patterns. Design patterns are reusable solutions to common problems that
    arise in software design. They provide a proven framework for solving specific
    problems, allowing developers to build on the collective wisdom and experience
    of other developers. By applying these patterns, it is possible to refactor smelly
    code into a more structured, modular, and maintainable form. Let’s take a look
    at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern allows us to define a family of algorithms, encapsulate
    each one in a separate class, and make them interchangeable at runtime. The strategy
    pattern is useful for refactoring code that has multiple branches or conditions
    performing similar tasks with slightly different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example of an application that saves data using different
    storage strategies, such as saving to disk or a remote storage service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this class, the `save_data` method checks the storage type on each call
    and uses a `switch`-`case` block to decide which saving method to use. This approach
    works, but it has some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: The `DataSaver` class is responsible for handling all the different storage
    types, making it harder to maintain and extend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new storage types requires modifying the `DataSaver` class and the `StorageType`
    enumeration, increasing the risk of introducing bugs or breaking existing functionality.
    For example, if for some reason the wrong enum type is provided, the code aborts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is less modular and flexible compared to the strategy pattern, where
    behaviors are encapsulated in separate classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By implementing the strategy pattern, we can address these drawbacks and create
    a more maintainable, flexible, and extensible design for the `DataSaver` class.
    First, define an interface called `SaveStrategy` that represents the saving behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement concrete `SaveStrategy` classes for each storage type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a `DataSaver` class that uses the strategy pattern to delegate
    its saving behavior to the appropriate `SaveStrategy` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here’s an example of how to use the `DataSaver` class with different
    saving strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `DataSaver` class uses the strategy pattern to delegate
    its saving behavior to different `SaveStrategy` implementations, allowing it to
    easily switch between saving to disk and saving to remote storage. This design
    makes the code more modular, maintainable, and flexible, allowing new storage
    strategies to be added with minimal changes to the existing code. Additionally,
    the new version of the code does not need to terminate or throw an exception on
    the wrong save strategy type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have file parser implementations for two formats, CSV and JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `CsvParser` and `JsonParser` classes have separate implementations
    of the `parse_file` method that contain duplicate code for opening, reading, and
    closing the file. The format-specific parsing logic is implemented in the `process_line`
    and `post_process` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this design works, it has some drawbacks: the shared parsing steps are
    duplicated in both classes, making it harder to maintain and update the code,
    and adding support for new file formats requires creating new classes with similar
    code structures, which can lead to even more code duplication.'
  prefs: []
  type: TYPE_NORMAL
- en: By implementing the template method pattern, you can address these drawbacks
    and create a more maintainable, extensible, and reusable design for the file parsers.
    The `FileParser` base class handles the common parsing steps, while the derived
    classes implement the format-specific parsing logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous example, let’s start with creating an abstract base class.
    `FileParser` represents the general file parsing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `FileParser` class has a `parse_file` method that handles the common steps
    of opening a file, reading its content line by line, and closing the file. The
    format-specific parsing logic is implemented by the pure virtual `process_line`
    and `post_process` methods, which will be overridden by the derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create derived classes for different file formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `CsvParser` and `JsonParser` classes inherit from `FileParser`
    and implement the format-specific parsing logic in the `process_line` and `post_process`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to use the file parsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By implementing the template method pattern, the `FileParser` class provides
    a reusable template for handling the common steps of file parsing while allowing
    derived classes to implement format-specific parsing logic. This design makes
    it easy to add support for new file formats without modifying the base `FileParser`
    class, leading to a more maintainable and extensible code base. It is important
    to note that usually, the complicated part of implementing this design pattern
    is to recognize the common logic between the classes. Often the implementation
    requires some sort of unification of the common logic.
  prefs: []
  type: TYPE_NORMAL
- en: Another helpful pattern to look at is the observer pattern. The previous chapter
    mentions its technical implementation details (raw, shared, or weak pointer implementation).
    However, in this chapter, I would like to cover its usage from a design perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern defines a one-to-many dependency between objects, allowing
    multiple observers to be notified when the state of the subject changes. This
    pattern can be beneficial when refactoring code that involves event handling or
    updates to multiple dependent components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a car system where an `Engine` class holds the car’s current speed
    and RPM (revolutions per minute). There are several elements that need to know
    about these values, such as `Dashboard` and `Controller`. The dashboard displays
    the latest update from the engine and `Controller` adjusts the car’s behavior
    based on the speed and RPM. The straightforward way to implement this is to have
    the `Engine` class directly call `update` methods on each display element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has a couple of issues:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Engine` class is tightly coupled with `Dashboard` and `Controller`, making
    it difficult to add or remove other components that might be interested in the
    car’s speed and RPM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Engine` class is responsible for updating the display elements directly,
    which complicates the code and makes it less flexible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can refactor the code using the observer pattern to decouple the `Engine`
    from the display elements. The `Engine` class will become a subject, and `Dashboard`
    and `Controller` will become observers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet demonstrates the usage of the new class hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `Dashboard` and `Controller` are registered as observers to
    the `Engine` subject. When the engine’s speed and RPM change, `set_measurements`
    is called, triggering `notify_observers`, which in turn calls the `update` method
    on each registered observer. This allows the `Dashboard` and `Controller` to receive
    the updated speed and RPM values.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `Dashboard` is unregistered as an observer. When the engine’s speed and
    RPM are updated again, only the `Controller` receives the updated values.
  prefs: []
  type: TYPE_NORMAL
- en: With this setup, adding or removing observers is as simple as calling `register_observer`
    or `remove_observer` on the `Engine`, and there is no need to modify the `Engine`
    class when adding new types of observers. The `Engine` class is now decoupled
    from the specific observer classes, making the system more flexible and easier
    to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Another great pattern is the state machine. It is not a classic pattern but
    probably the most powerful one. State machines, also known as **Finite State Machines**
    (**FSMs**), are mathematical models of computation. They’re used to represent
    and control execution flow in both hardware and software designs. A state machine
    has a finite number of states, and at any given time, it’s in one of these states.
    It transitions from one state to another in response to external inputs or predefined
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of hardware, state machines are frequently used in the design of
    digital systems, serving as the control logic for everything from tiny microcontrollers
    to massive **central processing units** (**CPUs**). They govern the sequence of
    operations, ensuring that actions happen in the correct order and that the system
    responds appropriately to different inputs or conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In software, state machines are equally useful, particularly in systems where
    the program flow is influenced by a series of states and transitions between those
    states. Applications range from simple button debouncing in embedded systems to
    complex game character behavior or communication protocol management.
  prefs: []
  type: TYPE_NORMAL
- en: State machines are ideal for situations where a system has a well-defined set
    of states that it cycles through, and where the transitions between states are
    triggered by specific events or conditions. They’re particularly useful in situations
    where the system’s behavior is not just a function of the current inputs, but
    also of the system’s history. State machines encapsulate this history in the form
    of the current state, making it explicit and manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Using a state machine can have numerous benefits. They can simplify complex
    conditional logic, making it easier to understand, debug, and maintain. They also
    make it easy to add new states or transitions without disturbing existing code,
    enhancing modularity and flexibility. Furthermore, they make the system’s behavior
    explicit and predictable, reducing the risk of unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a real-world scenario of a distributed computing system where
    a job is submitted to be processed. This job goes through various states, such
    as `Submitted`, `Queued`, `Running`, `Completed`, and `Failed`. We will model
    this using the `Boost.Statechart` library. `Boost.Statechart` is a C++ library
    that provides a framework for building state machines. It is part of the Boost
    libraries collection. This library facilitates the development of hierarchical
    state machines, allowing you to model complex systems with intricate states and
    transitions. It aims to make it easier to write well-structured, modular, and
    maintainable code when dealing with complex state logic. `Boost.Statechart` provides
    both compile-time and runtime checks to help ensure the correctness of the state
    machine’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include the necessary header files and set up some namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define our events: `JobSubmitted`, `JobQueued`, `JobRunning`, `JobCompleted`,
    and `JobFailed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define our states, each state is a class that inherits from `sc::simple_state`.
    We will have five states: `Submitted`, `Queued`, `Running`, `Completed`, and `Failed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we define our state machine, `Job`, which starts in the `Submitted`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In a `main` function, we can create an instance of our `Job` state machine
    and process some events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This simple example shows how state machines can be used to model a process
    with multiple states and transitions. We used events to trigger transitions between
    states. Another approach is to use state reactions, where a state can decide when
    to transition based on the conditions or the data it has.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be achieved using custom reactions in `Boost.Statechart`. A custom
    reaction is a member function that’s called when an event is processed. It can
    decide what to do: ignore the event, consume the event without transitioning,
    or transition to a new state.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s modify the `Job` state machine to make it decide when to transition from
    `Running` to `Completed` or `Failed` based on the completion status of the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will define a new event, `EventJobUpdate`, which will carry the completion
    status of the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `Running` state, we will define a custom reaction for this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `Running` state will decide when to transition to `Completed` or `Failed`
    based on the `is_complete` field of the `EventJobUpdate` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` function, we can now process the `EventJobUpdate` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we process `EventJobUpdate` with `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This shows how a state can decide when to transition based on the conditions
    or the data it has.
  prefs: []
  type: TYPE_NORMAL
- en: Logic implemented as a state machine can be easily extended by adding new states
    and transition rules between them. However, at some point state machines may include
    too many states (let’s say, more than seven). Often it is a symptom of smelly
    code. It means that the state machine is overloaded with too many states implementing
    several state machines. For example, our distributed system can be implemented
    as a state machine itself. The system could have its own states, such as `Idle`,
    `ProcessingJobs`, and `SystemFailure`. The `ProcessingJobs` state will further
    contain the `Job` state machine as a sub-state machine. The `System` state machine
    can communicate with the `Job` sub-state machine by processing events. When the
    `System` transitions to the `ProcessingJobs` state, it can process an `EventJobSubmitted`
    event to start the `Job` sub-state machine. When the `Job` transitions to the
    `Completed` or `Failed` state, it can process an `EventJobFinished` event to notify
    the `System`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the `EventJobFinished` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `Completed` and `Failed` states of the `Job` state machine, we
    process the `EventJobFinished` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ProcessingJobs` state of the `System` state machine, we define a custom
    reaction for the `EventJobFinished` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, we can create an instance of our `System` state machine
    and start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This shows how the `System` state machine interacts with the `Job` sub-state
    machine. The `System` starts the `Job` when it transitions to the `ProcessingJobs`
    state, and the `Job` notifies the `System` when it’s finished. This allows the
    `System` to manage the life cycle of the `Job` and react to its state changes.
  prefs: []
  type: TYPE_NORMAL
- en: This can make your state machines more flexible and dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: In general, state machines are a powerful tool for managing complex behavior
    robustly and understandably. Despite their utility, state machines are not always
    the first choice for structuring code, perhaps due to the perceived complexity
    or lack of familiarity. However, when dealing with a system characterized by a
    complex web of conditional logic, considering a state machine can be a wise move.
    It’s a powerful tool that can bring clarity and robustness to your software design,
    making it an essential part of the refactoring toolkit in C++ or any other language.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to design patterns, anti-patterns are common solutions to problems
    that turn out to be counterproductive or harmful in the long run. Recognizing
    and avoiding anti-patterns is crucial in addressing smelly code, as applying them
    can exacerbate existing issues and introduce new ones. Some examples of anti-patterns
    include Singleton, God Object, Copy-Paste Programming, Premature Optimization,
    and Spaghetti Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Singleton is known to violate dependency inversion and open/closed principles.
    It creates a global instance, which can lead to hidden dependencies between classes
    and make the code hard to understand and maintain. It violates the dependency
    inversion principle, as it encourages high-level modules to depend on low-level
    modules instead of depending on abstractions. Additionally, the singleton pattern
    often makes it difficult to replace the singleton instance with a different implementation,
    for example, when extending the class or during testing. This violates the open/closed
    principle, as it requires modifying the code to change or extend the behavior.
    In the following code sample, we have a singleton class, `Database`, used by the
    `OrderManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea of having the database connection represented as a singleton is quite
    logical: the application allows having a single database connection per application
    instance, and the database is used everywhere in the code. The usage of singleton
    hides the fact that `OrderManager` depends on `Database`, which makes the code
    less obvious and predictable. The usage of singleton makes it almost impossible
    to test the business logic of `OrderManager` via unit tests without running a
    real instance of the database aside.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem can be solved by creating an instance of `Database` somewhere at
    the beginning of the `main` function and passing it to all the classes that need
    a database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that despite the fact that `Database` is not a singleton anymore (that
    is, its constructor is public), it still cannot be copied. Technically, this allows
    developers to create new instances ad hoc, which is not a desired behavior. In
    my experience, it can be easily avoided by knowledge sharing within the team and
    enforced by code review. Those developers who think it is not enough can keep
    `Database` unchanged but make sure that `get_instance` is called only once and
    passed by reference since then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If a code smell involves a class with too many responsibilities, applying the
    god object anti-pattern would be inappropriate, as it would only make the class
    more convoluted and difficult to maintain. In general, god class is a violation
    of the single responsibility principle on steroids. For example, let’s take a
    look at the following class, `EcommerceSystem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `ECommerceSystem` class takes on multiple responsibilities
    such as product management, cart management, order management, and persistence
    (saving and loading data from a file). This class is difficult to maintain, understand,
    and modify.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach would be to break down the `ECommerceSystem` into smaller,
    more focused classes, each handling a specific responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ProductManager` class manages products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CartManager` class manages the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OrderManager` class manages orders and related tasks (e.g., processing
    payments and sending confirmation emails)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PersistenceManager` class handles saving and loading data from files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These classes can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Eventually, the `ECommerce` class that owns the new classes and provides proxy
    methods to their functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: By dividing the responsibilities among multiple smaller classes, the code becomes
    more modular, easier to maintain, and better suited to real-life applications.
    Small changes in the internal business logic of one of the subclasses will not
    necessitate updates to the `ECommerce` class. In C++ it might be even more important
    due to the notorious compilation time issues. It is easier to test these classes
    separately, or completely replace the implementation of one of them, for example,
    to save the data not to the disk but to remote storage.
  prefs: []
  type: TYPE_NORMAL
- en: The pitfalls of magic numbers – a case study on data chunking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider the following C++ function, `send`, which aims to send a block
    of data in chunks to some destination. Here’s how the function looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: What does the code do?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `send` function takes a pointer to a `std::uint8_t` array (`data`) and its
    size (`size`). It then proceeds to send this data in chunks to the `do_send` function,
    which is responsible for the actual sending process. The chunks have a maximum
    size of 256 bytes each, as defined within the `send` function.
  prefs: []
  type: TYPE_NORMAL
- en: Why is the magic number problematic?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number 256 is directly embedded into the code, and there’s no explanation
    for what it represents. This is a classic example of a **magic number**. Anyone
    reading this code would have to guess why 256 was chosen. Is it a hardware limit?
    A protocol constraint? A performance tuning parameter?
  prefs: []
  type: TYPE_NORMAL
- en: The constexpr solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One way to improve the clarity of this code is to replace the magic number
    with a named `constexpr` variable. For instance, the code could be rewritten like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Advantages of using constexpr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replacing the magic number with `MAX_DATA_TO_SEND` makes it easier to understand
    why this limit exists. Furthermore, if you have another function, such as `read`,
    which also needs to read data in chunks of 256 bytes, using the `constexpr` variable
    ensures consistency. If ever the chunk size needs to be changed, you only have
    to update it in one place, thereby reducing the risk of bugs and inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with smelly code, it is essential to understand the underlying
    causes of the smells and to apply the correct patterns or avoid anti-patterns
    to refactor the code effectively. For instance, if a code smell involves duplicated
    code, one should avoid Copy-Paste Programming and instead apply patterns like
    the Template Method or Strategy pattern to promote code reuse and reduce duplication.
    Similarly, if a code smell involves tightly coupled modules or classes, you should
    apply patterns such as Adapter or the Dependency Inversion Principle to reduce
    coupling and improve modularity.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that refactoring smelly code should be an iterative
    and incremental process. Developers should continuously review and evaluate their
    code base for smells, making small, focused changes that gradually improve the
    code’s quality and maintainability. This approach allows better risk management,
    as it minimizes the chances of introducing new bugs or issues during the refactoring
    process. The best way to achieve that is unit tests. They help verify that the
    refactored code still meets its original requirements and behaves as expected,
    even after modifications to its internal structure or organization. By having
    a strong set of tests in place before starting the refactoring process, developers
    can have confidence that their changes will not negatively impact the application’s
    behavior. This allows them to focus on improving the code’s design, readability,
    and maintainability without worrying about unintentionally breaking the functionality.
    We will explore unit tests in [*Chapter 13*](B19606_13.xhtml#_idTextAnchor260).
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, smelly code is a term that describes symptoms in a codebase that
    indicate potential design or implementation issues. Addressing smelly code involves
    recognizing and applying appropriate design patterns, as well as avoiding anti-patterns
    that can be detrimental to code quality. By understanding the underlying causes
    of code smells and using patterns and anti-patterns effectively, developers can
    refactor their code base to be more maintainable, readable, and resilient to future
    changes. Continuous evaluation and incremental refactoring are key to keeping
    code smells at bay and ensuring a high-quality, efficient codebase that can adapt
    to evolving requirements and demands.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring legacy C++ code is a significant undertaking that has the potential
    to breathe new life into an aging code base. Often, legacy code is written in
    old dialects of C++, such as C++98 or C++03, which do not take advantage of the
    new language features and standard library improvements introduced in C++11, C++14,
    C++17, and C++20.
  prefs: []
  type: TYPE_NORMAL
- en: One common area for modernization is memory management. Legacy C++ code often
    uses raw pointers for managing dynamic memory, leading to potential issues with
    memory leaks and null pointer dereferencing. Such code can be refactored to use
    smart pointers, such as `std::unique_ptr` and `std::shared_ptr`, which automatically
    manage the lifetime of the objects they point to, reducing the risk of memory
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Another modernization opportunity lies in adopting the range-based `for` loops
    introduced in C++11\. Older loops with explicit iterators or index variables can
    be replaced with cleaner and more intuitive range-based loops. This not only makes
    the code easier to read but also reduces the potential for off-by-one and iterator
    invalidation errors.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in previous chapters, legacy C++ code bases often make heavy use
    of raw arrays and C-style strings. Such code can be refactored to use `std::array`,
    `std::vector`, and `std::string`, which are safer, more flexible, and provide
    useful member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, modern C++ has made significant strides in improving concurrency support
    with the introduction of `std::thread`, `std::async`, and `std::future` in C++11,
    followed by further enhancements in subsequent standards. Legacy code that uses
    platform-specific threading or older concurrency libraries could benefit from
    refactoring to use these modern, portable concurrency tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an example of legacy code that uses `pthread` to create a
    new thread. This thread will perform a simple calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can refactor this code using `std::async` from C++11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the refactored version, we use `std::async` to start a new task and `std::future::get`
    to obtain the result. The calculate function directly returns the result as an
    `int`, which is much simpler and safer than allocating memory in the `pthread`
    version. There are a few things to note. The call to `std::future::get` blocks
    the execution until the async is done. Additionally, the example uses `std::launch::async`,
    which ensures that the task is launched in a separate thread. The C++ 11 standard
    allows the implementations to decide what is the default policy: a separate thread
    or a deferred execution. At the time of writing, Microsoft Visual C++, GCC, and
    Clang run the task in a separate thread by default. The only difference is that
    while GCC and Clang create a new thread per task, Microsoft Visual C++ reuses
    threads from an internal thread pool. The error handling is also simpler, as any
    exception thrown by the calculate function will be caught by `std::future::get`.'
  prefs: []
  type: TYPE_NORMAL
- en: Often legacy code uses object-oriented wrappers around `pthread` and other platform-specific
    APIs. Replacing them with the standard C++ implementation can decrease the amount
    of code that the developers have to support and make code more portable. However,
    multi-threading is a complex topic, so if the existing code has some rich thread-related
    logic, it is important to make sure that it stays intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in algorithms provided with modern C++ can improve legacy code readability
    and maintenance. Often, developers need to check whether an array contains a certain
    value. Pre-C++11 language allowed doing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With C++11, we can use `std::any_of`, a new algorithm that checks if any element
    in a range satisfies a predicate. This allows us to write the code more concisely
    and expressively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this refactored version, we use a lambda function as the predicate for `std::any_of`.
    This makes the code more concise and the intention clearer. Algorithms such as
    [PRE41] and `` std::none_of` `` allows to clearly express similar checks
  prefs: []
  type: TYPE_NORMAL
- en: Remember, refactoring should be done incrementally, with each change tested
    thoroughly to ensure it doesn’t introduce new bugs or regressions. It can be a
    time-consuming process, but the benefits in terms of improved code quality, maintainability,
    and performance can be substantial.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored some of the key design patterns that can be
    instrumental in refactoring legacy C++ code, including the strategy pattern, template
    method pattern, and observer pattern. These patterns, when applied judiciously,
    can significantly improve the structure of your code, making it more flexible,
    maintainable, and resilient to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’ve provided practical, real-world examples to illustrate the use of
    these patterns, this is by no means an exhaustive treatment. Design patterns are
    a vast and deep subject, with many more patterns and variations to explore. For
    a more comprehensive understanding of design patterns, I strongly recommend you
    delve into the seminal work *Design Patterns: Elements of Reusable Object-Oriented
    Software* by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, often
    referred to as the *Gang of* *Four* book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, to keep abreast of the most recent developments and emerging best
    practices, consider resources such as *Hands-On Design Patterns with C++: Solve
    common C++ problems with modern design patterns and build robust applications*
    by Fedor G. Pikus, and *C++ Concurrency in Action* by Anthony Williams. These
    works will provide you with a broader perspective and deeper understanding of
    the powerful role design patterns play in crafting high-quality C++ software.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the goal of refactoring and applying design patterns is not just to
    write code that works, but to write code that is clean, easy to understand, easy
    to modify, and easy to maintain in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we’ll be delving deeper into the world of C++, focusing
    specifically on naming conventions, their importance in writing clean and maintainable
    code, and best practices established by the community.
  prefs: []
  type: TYPE_NORMAL
