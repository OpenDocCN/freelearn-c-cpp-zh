- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Identifying Ideal Candidates for Rewriting – Patterns and Anti-Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定重构的理想候选者 - 模式和反模式
- en: Refactoring is a crucial technique in software development that involves making
    changes to existing code to improve its structure, readability, and maintainability
    without altering its behavior. It is vital for several reasons.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是软件开发中的一个关键技术，它涉及对现有代码进行更改以改进其结构、可读性和可维护性，而不改变其行为。它对于几个原因至关重要。
- en: It helps to eliminate technical debt and enhance the overall quality of the
    code base. Developers can achieve this by removing redundant or duplicate code,
    simplifying complex code, and improving code readability, resulting in more maintainable
    and robust software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 它有助于消除技术债务并提高代码库的整体质量。开发者可以通过删除冗余或重复的代码、简化复杂的代码和改进代码可读性来实现这一点，从而产生更易于维护和健壮的软件。
- en: Refactoring facilitates future development. By restructuring code to be more
    modular, developers can reuse existing code more effectively, saving time and
    effort in future development. This makes code more flexible and adaptable to change,
    making it easier to add new features, fix bugs, and optimize performance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 重构促进了未来的开发。通过重构代码以使其更模块化，开发者可以更有效地重用现有代码，节省未来开发的时间和精力。这使得代码更具灵活性和适应性，更容易添加新功能、修复错误和优化性能。
- en: Well-structured and maintainable code makes it easier for multiple developers
    to collaborate effectively on a project. Refactoring helps to standardize code
    practices, reduce complexity, and improve documentation, making it easier for
    developers to understand and contribute to a code base.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 结构良好且易于维护的代码使得多个开发者能够更有效地在项目上进行协作。重构有助于标准化代码实践，减少复杂性，并改进文档，使开发者更容易理解和贡献代码库。
- en: Eventually, refactoring reduces costs associated with software development in
    the long term. By improving code quality and maintainability, refactoring can
    help to reduce the time and effort required for bug fixes, updates, and other
    maintenance tasks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，重构可以降低长期软件开发相关的成本。通过提高代码质量和可维护性，重构可以帮助减少修复错误、更新和其他维护任务所需的时间和精力。
- en: In this chapter, we will focus on identifying good candidates for refactoring
    in C++ projects. However, identifying the right code segments for refactoring
    can be challenging, especially in large and complex systems. Therefore, it is
    essential to understand the factors that make code segments ideal candidates for
    refactoring. In this chapter, we will explore these factors and provide guidelines
    for identifying good candidates for refactoring in C++. We will also discuss common
    refactoring techniques and tools that can be used to improve the quality of C++
    code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于在C++项目中识别重构的良好候选者。然而，在大型和复杂的系统中，确定适合重构的正确代码段可能具有挑战性。因此，了解使代码段成为重构理想候选者的因素至关重要。在本章中，我们将探讨这些因素，并提供在C++中识别重构良好候选者的指南。我们还将讨论可以用来提高C++代码质量的常见重构技术和工具。
- en: What kind of code is worth rewriting?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哪种代码值得重写？
- en: Determining whether a piece of code is worth rewriting depends on several factors,
    including the code’s maintainability, readability, performance, scalability, and
    adherence to best practices. Let’s look at some situations where code may be worth
    rewriting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 确定是否值得重写的代码取决于几个因素，包括代码的可维护性、可读性、性能、可扩展性和遵循最佳实践的程度。让我们看看代码可能值得重写的一些情况。
- en: '**Smelly code** is often an indication that code needs to be rewritten. These
    are signs of poor design or implementation, such as long methods, large classes,
    duplicated code, or poor naming conventions. Addressing these code smells can
    improve the overall quality of the code base and make it easier to maintain in
    the long run.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**有问题的代码**通常是代码需要重写的迹象。这些是设计或实现不佳的迹象，例如方法过长、类过大、代码重复或命名约定不佳。解决这些代码问题可以改善代码库的整体质量，并使其长期维护更容易。'
- en: Code that exhibits low cohesion or high coupling might be worth rewriting. Low
    cohesion means that the elements within a module or class are not closely related,
    and the module or class has too many responsibilities. High coupling refers to
    a high degree of dependency between modules or classes, making the code harder
    to maintain and modify. Refactoring such code can lead to a more modular and easier-to-understand
    architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表现出低内聚或高耦合的代码可能值得重写。低内聚意味着模块或类内的元素之间没有紧密关联，并且模块或类有太多的职责。高耦合指的是模块或类之间的高度依赖性，使得代码更难以维护和修改。重构此类代码可以导致更模块化和易于理解的架构。
- en: In the previous chapters, we discussed the importance of SOLID principles; code
    that violates them can also be worth rewriting.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了SOLID原则的重要性；违反这些原则的代码也值得重写。
- en: Another reason to rewrite code is if it relies on outdated technologies, libraries,
    or programming practices. Such code can become increasingly difficult to maintain
    over time and may not take advantage of newer, more efficient methods or tools.
    Updating the code to use current technologies and practices can improve its performance,
    security, and maintainability.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重写代码的原因是如果它依赖于过时的技术、库或编程实践。随着时间的推移，此类代码可能越来越难以维护，并且可能无法利用更新、更有效的方法或工具。将代码更新为使用当前技术和实践可以提高其性能、安全性和可维护性。
- en: Lastly, if the code has performance or scalability issues, it may be worth rewriting.
    This can involve optimizing algorithms, data structures, or resource management
    to ensure that the code runs more efficiently and can handle larger workloads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果代码存在性能或可扩展性问题，可能值得重写。这可能涉及优化算法、数据结构或资源管理，以确保代码运行得更高效，并能处理更大的工作负载。
- en: Smelly code and its basic characteristics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码恶臭及其基本特征
- en: '**Smelly code**, also known as **code smells**, refers to the symptoms in a
    code base that suggest underlying design or implementation issues. These symptoms
    are not necessarily bugs but are indicators of potential problems that can make
    the code harder to understand, maintain, and modify. Code smells are often the
    result of poor coding practices or the accumulation of technical debt over time.
    Although code smells might not directly affect the functionality of a program,
    they can significantly impact the overall code quality, leading to an increased
    risk of bugs and a decrease in developer productivity.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**有问题的代码**，也称为**代码恶臭**，指的是代码库中表明潜在设计或实现问题的症状。这些症状并不一定是错误，但它们是潜在问题的指示，这些问题可能会使代码更难以理解、维护和修改。代码恶臭往往是由于糟糕的编码实践或随着时间的推移技术债务的积累造成的。尽管代码恶臭可能不会直接影响程序的功能，但它们可以显著影响代码的整体质量，导致错误风险增加和开发者生产率下降。'
- en: One aspect of addressing smelly code involves identifying and applying appropriate
    design patterns. Design patterns are reusable solutions to common problems that
    arise in software design. They provide a proven framework for solving specific
    problems, allowing developers to build on the collective wisdom and experience
    of other developers. By applying these patterns, it is possible to refactor smelly
    code into a more structured, modular, and maintainable form. Let’s take a look
    at a few examples.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 解决代码恶臭的一个方面是识别并应用适当的设计模式。设计模式是解决软件设计中常见问题的可重用解决方案。它们为解决特定问题提供了一个经过验证的框架，使开发者能够建立在其他开发者的集体智慧和经验之上。通过应用这些模式，可以将恶臭代码重构为更结构化、模块化和易于维护的形式。让我们看看一些例子。
- en: The strategy pattern allows us to define a family of algorithms, encapsulate
    each one in a separate class, and make them interchangeable at runtime. The strategy
    pattern is useful for refactoring code that has multiple branches or conditions
    performing similar tasks with slightly different implementations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式允许我们定义一组算法，将每个算法封装在单独的类中，并在运行时使它们可互换。策略模式对于重构具有多个分支或执行类似任务但实现略有不同的条件的代码非常有用。
- en: 'Let’s consider an example of an application that saves data using different
    storage strategies, such as saving to disk or a remote storage service:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个使用不同存储策略保存数据的应用程序的例子，例如保存到磁盘或远程存储服务：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this class, the `save_data` method checks the storage type on each call
    and uses a `switch`-`case` block to decide which saving method to use. This approach
    works, but it has some drawbacks:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程中，`save_data`方法在每次调用时都会检查存储类型，并使用`switch-case`块来决定使用哪种保存方法。这种方法可行，但有一些缺点：
- en: The `DataSaver` class is responsible for handling all the different storage
    types, making it harder to maintain and extend.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataSaver`类负责处理所有不同的存储类型，这使得维护和扩展更困难。'
- en: Adding new storage types requires modifying the `DataSaver` class and the `StorageType`
    enumeration, increasing the risk of introducing bugs or breaking existing functionality.
    For example, if for some reason the wrong enum type is provided, the code aborts.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的存储类型需要修改`DataSaver`类和`StorageType`枚举，增加了引入错误或破坏现有功能的风险。例如，如果由于某种原因提供了错误的枚举类型，代码将终止。
- en: The code is less modular and flexible compared to the strategy pattern, where
    behaviors are encapsulated in separate classes.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与将行为封装在单独类中的策略模式相比，代码的模块化和灵活性较低。
- en: 'By implementing the strategy pattern, we can address these drawbacks and create
    a more maintainable, flexible, and extensible design for the `DataSaver` class.
    First, define an interface called `SaveStrategy` that represents the saving behavior:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现策略模式，我们可以解决这些缺点，并为`DataSaver`类创建一个更易于维护、灵活和可扩展的设计。首先，定义一个名为`SaveStrategy`的接口，它代表保存行为：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, implement concrete `SaveStrategy` classes for each storage type:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为每种存储类型实现具体的`SaveStrategy`类：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, create a `DataSaver` class that uses the strategy pattern to delegate
    its saving behavior to the appropriate `SaveStrategy` implementation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个使用策略模式将保存行为委托给适当的`SaveStrategy`实现的`DataSaver`类：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, here’s an example of how to use the `DataSaver` class with different
    saving strategies:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是一个如何使用`DataSaver`类和不同的保存策略的示例：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the `DataSaver` class uses the strategy pattern to delegate
    its saving behavior to different `SaveStrategy` implementations, allowing it to
    easily switch between saving to disk and saving to remote storage. This design
    makes the code more modular, maintainable, and flexible, allowing new storage
    strategies to be added with minimal changes to the existing code. Additionally,
    the new version of the code does not need to terminate or throw an exception on
    the wrong save strategy type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`DataSaver`类使用策略模式将它的保存行为委托给不同的`SaveStrategy`实现，这使得它能够轻松地在保存到磁盘和保存到远程存储之间切换。这种设计使代码更加模块化、可维护和灵活，允许以最小的现有代码更改添加新的存储策略。此外，新版本的代码不需要在错误的保存策略类型上终止或抛出异常。
- en: 'Let’s assume we have file parser implementations for two formats, CSV and JSON:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个格式的文件解析实现，CSV和JSON：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the `CsvParser` and `JsonParser` classes have separate implementations
    of the `parse_file` method that contain duplicate code for opening, reading, and
    closing the file. The format-specific parsing logic is implemented in the `process_line`
    and `post_process` methods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`CsvParser`和`JsonParser`类有`parse_file`方法的独立实现，其中包含打开、读取和关闭文件的重复代码。特定格式的解析逻辑在`process_line`和`post_process`方法中实现。
- en: 'While this design works, it has some drawbacks: the shared parsing steps are
    duplicated in both classes, making it harder to maintain and update the code,
    and adding support for new file formats requires creating new classes with similar
    code structures, which can lead to even more code duplication.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种设计可行，但它有一些缺点：共享的解析步骤在两个类中都重复，这使得维护和更新代码更困难，并且添加对新文件格式的支持需要创建具有类似代码结构的新的类，这可能导致更多的代码重复。
- en: By implementing the template method pattern, you can address these drawbacks
    and create a more maintainable, extensible, and reusable design for the file parsers.
    The `FileParser` base class handles the common parsing steps, while the derived
    classes implement the format-specific parsing logic.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现模板方法模式，你可以解决这些缺点，并为文件解析器创建一个更易于维护、可扩展和可重用的设计。`FileParser`基类处理常见的解析步骤，而派生类实现特定格式的解析逻辑。
- en: 'As in the previous example, let’s start with creating an abstract base class.
    `FileParser` represents the general file parsing process:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，让我们从创建一个抽象基类开始。`FileParser`代表通用的文件解析过程：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `FileParser` class has a `parse_file` method that handles the common steps
    of opening a file, reading its content line by line, and closing the file. The
    format-specific parsing logic is implemented by the pure virtual `process_line`
    and `post_process` methods, which will be overridden by the derived classes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileParser`类有一个`parse_file`方法，它处理打开文件、逐行读取其内容以及关闭文件的常见步骤。特定格式的解析逻辑通过纯虚函数`process_line`和`post_process`方法实现，这些方法将由派生类覆盖。'
- en: 'Now, create derived classes for different file formats:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为不同的文件格式创建派生类：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the `CsvParser` and `JsonParser` classes inherit from `FileParser`
    and implement the format-specific parsing logic in the `process_line` and `post_process`
    methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`CsvParser`和`JsonParser`类从`FileParser`继承，并在`process_line`和`post_process`方法中实现特定格式的解析逻辑。
- en: 'Here’s an example of how to use the file parsers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用文件解析器的示例：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By implementing the template method pattern, the `FileParser` class provides
    a reusable template for handling the common steps of file parsing while allowing
    derived classes to implement format-specific parsing logic. This design makes
    it easy to add support for new file formats without modifying the base `FileParser`
    class, leading to a more maintainable and extensible code base. It is important
    to note that usually, the complicated part of implementing this design pattern
    is to recognize the common logic between the classes. Often the implementation
    requires some sort of unification of the common logic.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现模板方法模式，`FileParser`类提供了一个处理文件解析常见步骤的可重用模板，同时允许派生类实现特定格式的解析逻辑。这种设计使得在不修改基类`FileParser`的情况下添加对新文件格式的支持变得容易，从而使得代码库更加易于维护和扩展。重要的是要注意，通常实现这种设计模式的复杂部分是识别类之间的共同逻辑。通常，实现需要某种形式的共同逻辑的统一。
- en: Another helpful pattern to look at is the observer pattern. The previous chapter
    mentions its technical implementation details (raw, shared, or weak pointer implementation).
    However, in this chapter, I would like to cover its usage from a design perspective.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得关注的模式是观察者模式。前一章提到了其技术实现细节（原始、共享或弱指针实现）。然而，在这一章中，我想从设计角度介绍其用法。
- en: The observer pattern defines a one-to-many dependency between objects, allowing
    multiple observers to be notified when the state of the subject changes. This
    pattern can be beneficial when refactoring code that involves event handling or
    updates to multiple dependent components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式定义了对象之间的一对多依赖关系，允许在主题状态发生变化时通知多个观察者。当重构涉及事件处理或多个依赖组件更新的代码时，这种模式可能是有益的。
- en: 'Consider a car system where an `Engine` class holds the car’s current speed
    and RPM (revolutions per minute). There are several elements that need to know
    about these values, such as `Dashboard` and `Controller`. The dashboard displays
    the latest update from the engine and `Controller` adjusts the car’s behavior
    based on the speed and RPM. The straightforward way to implement this is to have
    the `Engine` class directly call `update` methods on each display element:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个汽车系统，其中`Engine`类包含汽车当前的速度和每分钟转速（RPM）。有几个元素需要了解这些值，例如`Dashboard`和`Controller`。仪表盘显示来自发动机的最新更新，而`Controller`根据速度和转速调整汽车的行为。实现这一点的直接方法是让`Engine`类直接在每个显示元素上调用`update`方法：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code has a couple of issues:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有几个问题：
- en: The `Engine` class is tightly coupled with `Dashboard` and `Controller`, making
    it difficult to add or remove other components that might be interested in the
    car’s speed and RPM.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine`类与`Dashboard`和`Controller`紧密耦合，这使得添加或删除可能对汽车速度和转速感兴趣的其它组件变得困难。'
- en: The `Engine` class is responsible for updating the display elements directly,
    which complicates the code and makes it less flexible.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine`类直接负责更新显示元素，这使代码变得复杂，并降低了其灵活性。'
- en: 'We can refactor the code using the observer pattern to decouple the `Engine`
    from the display elements. The `Engine` class will become a subject, and `Dashboard`
    and `Controller` will become observers:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用观察者模式重构代码，将`Engine`与显示元素解耦。`Engine`类将成为主题，而`Dashboard`和`Controller`将成为观察者：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following snippet demonstrates the usage of the new class hierarchy:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了新类层次结构的用法：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, `Dashboard` and `Controller` are registered as observers to
    the `Engine` subject. When the engine’s speed and RPM change, `set_measurements`
    is called, triggering `notify_observers`, which in turn calls the `update` method
    on each registered observer. This allows the `Dashboard` and `Controller` to receive
    the updated speed and RPM values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Dashboard`和`Controller`被注册为`Engine`主题的观察者。当发动机的速度和转速发生变化时，会调用`set_measurements`，触发`notify_observers`，进而调用每个注册观察者的`update`方法。这使得`Dashboard`和`Controller`能够接收到更新的速度和转速值。
- en: Then, `Dashboard` is unregistered as an observer. When the engine’s speed and
    RPM are updated again, only the `Controller` receives the updated values.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`仪表盘`被取消注册为观察者。当引擎的速度和RPM再次更新时，只有`控制器`会接收到更新的值。
- en: With this setup, adding or removing observers is as simple as calling `register_observer`
    or `remove_observer` on the `Engine`, and there is no need to modify the `Engine`
    class when adding new types of observers. The `Engine` class is now decoupled
    from the specific observer classes, making the system more flexible and easier
    to maintain.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置下，添加或删除观察者就像在`Engine`上调用`register_observer`或`remove_observer`一样简单，并且无需在添加新的观察者类型时修改`Engine`类。现在，`Engine`类与特定的观察者类解耦，使系统更加灵活且易于维护。
- en: Another great pattern is the state machine. It is not a classic pattern but
    probably the most powerful one. State machines, also known as **Finite State Machines**
    (**FSMs**), are mathematical models of computation. They’re used to represent
    and control execution flow in both hardware and software designs. A state machine
    has a finite number of states, and at any given time, it’s in one of these states.
    It transitions from one state to another in response to external inputs or predefined
    conditions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个伟大的模式是状态机。它不是一个经典模式，但可能是最强大的一种。状态机，也称为**有限状态机**（**FSMs**），是计算数学模型。它们用于表示和控制硬件和软件设计中的执行流程。状态机具有有限数量的状态，在任何给定时间，它都处于这些状态之一。它根据外部输入或预定义条件从一个状态转换到另一个状态。
- en: In the realm of hardware, state machines are frequently used in the design of
    digital systems, serving as the control logic for everything from tiny microcontrollers
    to massive **central processing units** (**CPUs**). They govern the sequence of
    operations, ensuring that actions happen in the correct order and that the system
    responds appropriately to different inputs or conditions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件领域，状态机经常用于数字系统的设计，作为从小型微控制器到大型**中央处理器**（**CPUs**）的控制逻辑。它们控制操作序列，确保动作按正确的顺序发生，并且系统能够适当地响应不同的输入或条件。
- en: In software, state machines are equally useful, particularly in systems where
    the program flow is influenced by a series of states and transitions between those
    states. Applications range from simple button debouncing in embedded systems to
    complex game character behavior or communication protocol management.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，状态机同样有用，尤其是在程序流程受一系列状态及其之间转换影响的系统中。应用范围从嵌入式系统中的简单按钮消抖到复杂的游戏角色行为或通信协议管理。
- en: State machines are ideal for situations where a system has a well-defined set
    of states that it cycles through, and where the transitions between states are
    triggered by specific events or conditions. They’re particularly useful in situations
    where the system’s behavior is not just a function of the current inputs, but
    also of the system’s history. State machines encapsulate this history in the form
    of the current state, making it explicit and manageable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机非常适合那些系统有一个明确的状态集合，并且这些状态通过特定的事件或条件循环切换的情况。它们在系统的行为不仅取决于当前输入，还取决于系统历史的情况下特别有用。状态机通过当前状态的形式封装了这一历史，使其明确且易于管理。
- en: Using a state machine can have numerous benefits. They can simplify complex
    conditional logic, making it easier to understand, debug, and maintain. They also
    make it easy to add new states or transitions without disturbing existing code,
    enhancing modularity and flexibility. Furthermore, they make the system’s behavior
    explicit and predictable, reducing the risk of unexpected behavior.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态机可以带来许多好处。它们可以简化复杂的条件逻辑，使其更容易理解、调试和维护。它们还使得在不干扰现有代码的情况下添加新状态或转换变得容易，增强了模块化和灵活性。此外，它们使系统的行为明确且可预测，降低了意外行为的风险。
- en: Let’s consider a real-world scenario of a distributed computing system where
    a job is submitted to be processed. This job goes through various states, such
    as `Submitted`, `Queued`, `Running`, `Completed`, and `Failed`. We will model
    this using the `Boost.Statechart` library. `Boost.Statechart` is a C++ library
    that provides a framework for building state machines. It is part of the Boost
    libraries collection. This library facilitates the development of hierarchical
    state machines, allowing you to model complex systems with intricate states and
    transitions. It aims to make it easier to write well-structured, modular, and
    maintainable code when dealing with complex state logic. `Boost.Statechart` provides
    both compile-time and runtime checks to help ensure the correctness of the state
    machine’s behavior.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个分布式计算系统的真实场景，其中一项工作被提交以进行处理。这项工作会经历各种状态，如 `Submitted`、`Queued`、`Running`、`Completed`
    和 `Failed`。我们将使用 `Boost.Statechart` 库来模拟这个过程。`Boost.Statechart` 是一个 C++ 库，它提供了一个构建状态机的框架。它是
    Boost 库集合的一部分。这个库简化了分层状态机的开发，允许你使用复杂的状态和转换来模拟复杂系统。它的目标是使处理复杂状态逻辑时编写结构良好、模块化和可维护的代码变得更加容易。`Boost.Statechart`
    提供了编译时和运行时检查，以帮助确保状态机行为的正确性。
- en: 'First, we include the necessary header files and set up some namespaces:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含必要的头文件并设置一些命名空间：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we define our events: `JobSubmitted`, `JobQueued`, `JobRunning`, `JobCompleted`,
    and `JobFailed`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的事件：`JobSubmitted`、`JobQueued`、`JobRunning`、`JobCompleted` 和 `JobFailed`：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we define our states, each state is a class that inherits from `sc::simple_state`.
    We will have five states: `Submitted`, `Queued`, `Running`, `Completed`, and `Failed`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的状态，每个状态都是一个继承自 `sc::simple_state` 的类。我们将有五个状态：`Submitted`、`Queued`、`Running`、`Completed`
    和 `Failed`：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, we define our state machine, `Job`, which starts in the `Submitted`
    state.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义我们的状态机，`Job`，它从 `Submitted` 状态开始。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In a `main` function, we can create an instance of our `Job` state machine
    and process some events:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 `main` 函数中，我们可以创建我们的 `Job` 状态机实例并处理一些事件：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will output the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This simple example shows how state machines can be used to model a process
    with multiple states and transitions. We used events to trigger transitions between
    states. Another approach is to use state reactions, where a state can decide when
    to transition based on the conditions or the data it has.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子展示了如何使用状态机来模拟具有多个状态和转换的过程。我们使用事件来触发状态之间的转换。另一种方法是使用状态反应，其中状态可以根据其拥有的条件或数据来决定何时进行转换。
- en: 'This can be achieved using custom reactions in `Boost.Statechart`. A custom
    reaction is a member function that’s called when an event is processed. It can
    decide what to do: ignore the event, consume the event without transitioning,
    or transition to a new state.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在 `Boost.Statechart` 中使用自定义反应来实现。自定义反应是一个在处理事件时被调用的成员函数。它可以决定要做什么：忽略事件、消费事件而不进行转换，或者转换到新状态。
- en: Let’s modify the `Job` state machine to make it decide when to transition from
    `Running` to `Completed` or `Failed` based on the completion status of the job.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `Job` 状态机，使其能够根据工作的完成状态来决定何时从 `Running` 转换到 `Completed` 或 `Failed`。
- en: 'First, we will define a new event, `EventJobUpdate`, which will carry the completion
    status of the job:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个新的事件，`EventJobUpdate`，它将携带工作的完成状态：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, in the `Running` state, we will define a custom reaction for this event:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Running` 状态中，我们将为这个事件定义一个自定义反应：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, the `Running` state will decide when to transition to `Completed` or `Failed`
    based on the `is_complete` field of the `EventJobUpdate` event.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Running` 状态将根据 `EventJobUpdate` 事件的 `is_complete` 字段来决定何时转换到 `Completed`
    或 `Failed`。
- en: 'In the `main` function, we can now process the `EventJobUpdate` event:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们现在可以处理 `EventJobUpdate` 事件：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will output the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we process `EventJobUpdate` with `false`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用 `false` 处理 `EventJobUpdate`：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It will output the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出以下内容：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This shows how a state can decide when to transition based on the conditions
    or the data it has.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了状态如何根据其拥有的条件或数据来决定何时进行转换。
- en: Logic implemented as a state machine can be easily extended by adding new states
    and transition rules between them. However, at some point state machines may include
    too many states (let’s say, more than seven). Often it is a symptom of smelly
    code. It means that the state machine is overloaded with too many states implementing
    several state machines. For example, our distributed system can be implemented
    as a state machine itself. The system could have its own states, such as `Idle`,
    `ProcessingJobs`, and `SystemFailure`. The `ProcessingJobs` state will further
    contain the `Job` state machine as a sub-state machine. The `System` state machine
    can communicate with the `Job` sub-state machine by processing events. When the
    `System` transitions to the `ProcessingJobs` state, it can process an `EventJobSubmitted`
    event to start the `Job` sub-state machine. When the `Job` transitions to the
    `Completed` or `Failed` state, it can process an `EventJobFinished` event to notify
    the `System`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为状态机实现的逻辑可以通过添加新的状态和它们之间的转换规则来轻松扩展。然而，在某个时刻，状态机可能包含太多的状态（比如说，超过七个）。这通常是一个代码有问题的症状。这意味着状态机被太多的状态所压垮，这些状态实现了多个状态机。例如，我们的分布式系统本身可以作为一个状态机来实现。系统可以有自己的状态，例如`Idle`（空闲）、`ProcessingJobs`（处理作业）和`SystemFailure`（系统故障）。`ProcessingJobs`状态将进一步包含`Job`状态机作为子状态机。`System`状态机可以通过处理事件与`Job`子状态机通信。当`System`转换到`ProcessingJobs`状态时，它可以处理一个`EventJobSubmitted`事件来启动`Job`子状态机。当`Job`转换到`Completed`或`Failed`状态时，它可以处理一个`EventJobFinished`事件来通知`System`。
- en: 'First, we define the `EventJobFinished` event:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了`EventJobFinished`事件：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, in the `Completed` and `Failed` states of the `Job` state machine, we
    process the `EventJobFinished` event:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Job`状态机的`Completed`和`Failed`状态中，我们处理`EventJobFinished`事件：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `ProcessingJobs` state of the `System` state machine, we define a custom
    reaction for the `EventJobFinished` event:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`System`状态机的`ProcessingJobs`状态中，我们为`EventJobFinished`事件定义了一个自定义反应：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `main` function, we can create an instance of our `System` state machine
    and start it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们可以创建我们的`System`状态机的一个实例并启动它：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will output the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This shows how the `System` state machine interacts with the `Job` sub-state
    machine. The `System` starts the `Job` when it transitions to the `ProcessingJobs`
    state, and the `Job` notifies the `System` when it’s finished. This allows the
    `System` to manage the life cycle of the `Job` and react to its state changes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了`System`状态机如何与`Job`子状态机交互。当`System`转换到`ProcessingJobs`状态时，它会启动`Job`，而当`Job`完成时，它会通知`System`。这允许`System`管理`Job`的生命周期并对它的状态变化做出反应。
- en: This can make your state machines more flexible and dynamic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使你的状态机更加灵活和动态。
- en: In general, state machines are a powerful tool for managing complex behavior
    robustly and understandably. Despite their utility, state machines are not always
    the first choice for structuring code, perhaps due to the perceived complexity
    or lack of familiarity. However, when dealing with a system characterized by a
    complex web of conditional logic, considering a state machine can be a wise move.
    It’s a powerful tool that can bring clarity and robustness to your software design,
    making it an essential part of the refactoring toolkit in C++ or any other language.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，状态机是管理复杂行为的一种强大工具，既稳健又易于理解。尽管它们很有用，但状态机并不总是代码结构的首选，可能是因为它们被认为很复杂或缺乏熟悉度。然而，当处理一个以复杂条件逻辑为特征的系统时，考虑使用状态机可能是一个明智的选择。这是一个强大的工具，可以为你的软件设计带来清晰性和稳健性，使其成为C++或其他任何语言重构工具包的一个基本组成部分。
- en: Anti-patterns
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反模式
- en: In contrast to design patterns, anti-patterns are common solutions to problems
    that turn out to be counterproductive or harmful in the long run. Recognizing
    and avoiding anti-patterns is crucial in addressing smelly code, as applying them
    can exacerbate existing issues and introduce new ones. Some examples of anti-patterns
    include Singleton, God Object, Copy-Paste Programming, Premature Optimization,
    and Spaghetti Code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与设计模式不同，反模式是长期来看可能产生反效果或有害的常见解决方案。识别和避免反模式对于解决代码问题至关重要，因为应用它们可能会加剧现有问题并引入新的问题。一些反模式的例子包括Singleton（单例）、God
    Object（上帝对象）、Copy-Paste Programming（复制粘贴编程）、Premature Optimization（过早优化）和Spaghetti
    Code（意大利面代码）。
- en: 'Singleton is known to violate dependency inversion and open/closed principles.
    It creates a global instance, which can lead to hidden dependencies between classes
    and make the code hard to understand and maintain. It violates the dependency
    inversion principle, as it encourages high-level modules to depend on low-level
    modules instead of depending on abstractions. Additionally, the singleton pattern
    often makes it difficult to replace the singleton instance with a different implementation,
    for example, when extending the class or during testing. This violates the open/closed
    principle, as it requires modifying the code to change or extend the behavior.
    In the following code sample, we have a singleton class, `Database`, used by the
    `OrderManager` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式众所周知违反了依赖倒置和开闭原则。它创建了一个全局实例，这可能导致类之间的隐藏依赖，使得代码难以理解和维护。它违反了依赖倒置原则，因为它鼓励高层模块依赖于低层模块而不是依赖于抽象。此外，单例模式通常使得在扩展类或进行测试时难以用不同的实现替换单例实例。这违反了开闭原则，因为它要求修改代码以改变或扩展行为。在以下代码示例中，我们有一个单例类
    `Database`，它被 `OrderManager` 类使用：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The idea of having the database connection represented as a singleton is quite
    logical: the application allows having a single database connection per application
    instance, and the database is used everywhere in the code. The usage of singleton
    hides the fact that `OrderManager` depends on `Database`, which makes the code
    less obvious and predictable. The usage of singleton makes it almost impossible
    to test the business logic of `OrderManager` via unit tests without running a
    real instance of the database aside.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库连接表示为单例的想法是非常合理的：应用程序允许每个应用程序实例只有一个数据库连接，数据库在代码的各个地方都被使用。单例的使用隐藏了 `OrderManager`
    依赖于 `Database` 的这一事实，这使得代码不那么直观和可预测。单例的使用几乎使得通过单元测试测试 `OrderManager` 的业务逻辑变得不可能，除非运行一个真实的数据库实例。
- en: 'The problem can be solved by creating an instance of `Database` somewhere at
    the beginning of the `main` function and passing it to all the classes that need
    a database connection:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 `main` 函数的开始处创建一个 `Database` 实例并将其传递给所有需要数据库连接的类来解决这个问题：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that despite the fact that `Database` is not a singleton anymore (that
    is, its constructor is public), it still cannot be copied. Technically, this allows
    developers to create new instances ad hoc, which is not a desired behavior. In
    my experience, it can be easily avoided by knowledge sharing within the team and
    enforced by code review. Those developers who think it is not enough can keep
    `Database` unchanged but make sure that `get_instance` is called only once and
    passed by reference since then:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `Database` 已不再是单例（即其构造函数是公开的），但它仍然不能被复制。技术上，这允许开发者创建新的实例，但这并不是期望的行为。根据我的经验，可以通过团队内的知识共享和代码审查来轻松避免这种情况。那些认为这还不够的开发者可以保持
    `Database` 不变，但确保 `get_instance` 只被调用一次，并且从那时起通过引用传递：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If a code smell involves a class with too many responsibilities, applying the
    god object anti-pattern would be inappropriate, as it would only make the class
    more convoluted and difficult to maintain. In general, god class is a violation
    of the single responsibility principle on steroids. For example, let’s take a
    look at the following class, `EcommerceSystem`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个代码问题涉及一个具有太多责任的类，应用上帝对象反模式是不合适的，因为这只会使类更加复杂和难以维护。一般来说，上帝类是对单一责任原则的过度违反。例如，让我们看看以下类，`EcommerceSystem`：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, the `ECommerceSystem` class takes on multiple responsibilities
    such as product management, cart management, order management, and persistence
    (saving and loading data from a file). This class is difficult to maintain, understand,
    and modify.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ECommerceSystem` 类承担了多个责任，如产品管理、购物车管理、订单管理和持久化（从文件中保存和加载数据）。这个类难以维护、理解和修改。
- en: 'A better approach would be to break down the `ECommerceSystem` into smaller,
    more focused classes, each handling a specific responsibility:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是将 `ECommerceSystem` 分解成更小、更专注的类，每个类处理特定的责任：
- en: The `ProductManager` class manages products
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductManager` 类管理产品'
- en: The `CartManager` class manages the cart
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CartManager` 类管理购物车'
- en: The `OrderManager` class manages orders and related tasks (e.g., processing
    payments and sending confirmation emails)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderManager` 类管理订单和相关任务（例如，处理支付和发送确认电子邮件）'
- en: The `PersistenceManager` class handles saving and loading data from files
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistenceManager`类负责从文件中保存和加载数据'
- en: 'These classes can be implemented as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类可以按以下方式实现：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Eventually, the `ECommerce` class that owns the new classes and provides proxy
    methods to their functionality:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，拥有新类并提供其功能代理方法的`ECommerce`类：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By dividing the responsibilities among multiple smaller classes, the code becomes
    more modular, easier to maintain, and better suited to real-life applications.
    Small changes in the internal business logic of one of the subclasses will not
    necessitate updates to the `ECommerce` class. In C++ it might be even more important
    due to the notorious compilation time issues. It is easier to test these classes
    separately, or completely replace the implementation of one of them, for example,
    to save the data not to the disk but to remote storage.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将责任分配给多个较小的类，代码变得更加模块化，更容易维护，更适合实际应用。对其中一个子类内部业务逻辑的微小更改不需要更新`ECommerce`类。在C++中，由于臭名昭著的编译时间问题，这可能更为重要。单独测试这些类或完全替换其中一个类的实现（例如，将数据保存到远程存储而不是磁盘）更容易。
- en: The pitfalls of magic numbers – a case study on data chunking
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 魔法数字的陷阱——关于数据分块的一个案例研究
- en: 'Let’s consider the following C++ function, `send`, which aims to send a block
    of data in chunks to some destination. Here’s how the function looks:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下C++函数`send`，该函数旨在将数据块发送到某个目的地。以下是函数的外观：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What does the code do?
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码做了什么？
- en: The `send` function takes a pointer to a `std::uint8_t` array (`data`) and its
    size (`size`). It then proceeds to send this data in chunks to the `do_send` function,
    which is responsible for the actual sending process. The chunks have a maximum
    size of 256 bytes each, as defined within the `send` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`函数接受一个指向`std::uint8_t`数组的指针（`data`）及其大小（`size`）。然后它继续将此数据以块的形式发送到`do_send`函数，该函数负责实际发送过程。每个块的最大大小为256字节，如`send`函数中定义的那样。'
- en: Why is the magic number problematic?
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么魔法数字有问题？
- en: The number 256 is directly embedded into the code, and there’s no explanation
    for what it represents. This is a classic example of a **magic number**. Anyone
    reading this code would have to guess why 256 was chosen. Is it a hardware limit?
    A protocol constraint? A performance tuning parameter?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 数字256直接嵌入到代码中，没有解释它代表什么。这是一个经典的**魔法数字**例子。任何阅读此代码的人都会猜测为什么选择256。是硬件限制？协议约束？性能调整参数？
- en: The constexpr solution
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`constexpr`解决方案'
- en: 'One way to improve the clarity of this code is to replace the magic number
    with a named `constexpr` variable. For instance, the code could be rewritten like
    this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 提高此代码清晰度的一种方法是将魔法数字替换为命名的`constexpr`变量。例如，代码可以重写如下：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Advantages of using constexpr
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`constexpr`的优点
- en: Replacing the magic number with `MAX_DATA_TO_SEND` makes it easier to understand
    why this limit exists. Furthermore, if you have another function, such as `read`,
    which also needs to read data in chunks of 256 bytes, using the `constexpr` variable
    ensures consistency. If ever the chunk size needs to be changed, you only have
    to update it in one place, thereby reducing the risk of bugs and inconsistencies.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将魔法数字替换为`MAX_DATA_TO_SEND`使得理解这个限制的原因更加容易。此外，如果你有另一个函数，比如`read`，它也需要以256字节的块读取数据，使用`constexpr`变量可以确保一致性。如果块的大小需要更改，你只需在一个地方更新它，从而降低错误和不一致的风险。
- en: When dealing with smelly code, it is essential to understand the underlying
    causes of the smells and to apply the correct patterns or avoid anti-patterns
    to refactor the code effectively. For instance, if a code smell involves duplicated
    code, one should avoid Copy-Paste Programming and instead apply patterns like
    the Template Method or Strategy pattern to promote code reuse and reduce duplication.
    Similarly, if a code smell involves tightly coupled modules or classes, you should
    apply patterns such as Adapter or the Dependency Inversion Principle to reduce
    coupling and improve modularity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理糟糕的代码时，理解这些问题的根本原因并应用正确的模式或避免反模式以有效地重构代码是至关重要的。例如，如果一个代码问题涉及重复的代码，应避免复制粘贴编程，而是应用模板方法或策略模式等模式以促进代码重用并减少重复。同样，如果一个代码问题涉及紧密耦合的模块或类，应应用适配器或依赖倒置原则等模式以减少耦合并提高模块化。
- en: It is important to remember that refactoring smelly code should be an iterative
    and incremental process. Developers should continuously review and evaluate their
    code base for smells, making small, focused changes that gradually improve the
    code’s quality and maintainability. This approach allows better risk management,
    as it minimizes the chances of introducing new bugs or issues during the refactoring
    process. The best way to achieve that is unit tests. They help verify that the
    refactored code still meets its original requirements and behaves as expected,
    even after modifications to its internal structure or organization. By having
    a strong set of tests in place before starting the refactoring process, developers
    can have confidence that their changes will not negatively impact the application’s
    behavior. This allows them to focus on improving the code’s design, readability,
    and maintainability without worrying about unintentionally breaking the functionality.
    We will explore unit tests in [*Chapter 13*](B19606_13.xhtml#_idTextAnchor260).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，重构代码异味应该是一个迭代和逐步的过程。开发者应持续审查和评估他们的代码库中的异味，进行小而专注的更改，这些更改会逐渐提高代码的质量和可维护性。这种方法可以更好地进行风险管理，因为它最小化了在重构过程中引入新错误或问题的可能性。实现这一点的最佳方式是单元测试。它们有助于验证重构后的代码仍然满足其原始要求，并在修改其内部结构或组织后仍然按预期运行。在开始重构过程之前，拥有强大的测试集可以让开发者有信心他们的更改不会对应用程序的行为产生负面影响。这使他们能够专注于改进代码的设计、可读性和可维护性，而无需担心无意中破坏功能。我们将在[*第13章*](B19606_13.xhtml#_idTextAnchor260)中探讨单元测试。
- en: In conclusion, smelly code is a term that describes symptoms in a codebase that
    indicate potential design or implementation issues. Addressing smelly code involves
    recognizing and applying appropriate design patterns, as well as avoiding anti-patterns
    that can be detrimental to code quality. By understanding the underlying causes
    of code smells and using patterns and anti-patterns effectively, developers can
    refactor their code base to be more maintainable, readable, and resilient to future
    changes. Continuous evaluation and incremental refactoring are key to keeping
    code smells at bay and ensuring a high-quality, efficient codebase that can adapt
    to evolving requirements and demands.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，“代码异味”这个术语描述的是代码库中表明潜在设计或实现问题的症状。解决代码异味涉及识别和应用适当的设计模式，以及避免可能损害代码质量的反模式。通过理解代码异味的根本原因，并有效地使用模式和反模式，开发者可以将代码库重构得更加易于维护、可读，并能适应未来的变化。持续评估和逐步重构是防止代码异味并确保高质量、高效代码库能够适应不断变化的需求和需求的关键。
- en: Legacy code
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧代码
- en: Refactoring legacy C++ code is a significant undertaking that has the potential
    to breathe new life into an aging code base. Often, legacy code is written in
    old dialects of C++, such as C++98 or C++03, which do not take advantage of the
    new language features and standard library improvements introduced in C++11, C++14,
    C++17, and C++20.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重构旧版C++代码是一项重大的任务，它有可能为老化的代码库注入新的活力。通常，旧代码是用C++98或C++03等旧的C++方言编写的，这些方言没有利用C++11、C++14、C++17和C++20引入的新语言特性和标准库改进。
- en: One common area for modernization is memory management. Legacy C++ code often
    uses raw pointers for managing dynamic memory, leading to potential issues with
    memory leaks and null pointer dereferencing. Such code can be refactored to use
    smart pointers, such as `std::unique_ptr` and `std::shared_ptr`, which automatically
    manage the lifetime of the objects they point to, reducing the risk of memory
    leaks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现代化中的一个常见领域是内存管理。传统的C++代码通常使用原始指针来管理动态内存，这可能导致内存泄漏和空指针解引用等潜在问题。此类代码可以被重构为使用智能指针，例如`std::unique_ptr`和`std::shared_ptr`，这些智能指针会自动管理它们所指向的对象的生命周期，从而降低内存泄漏的风险。
- en: Another modernization opportunity lies in adopting the range-based `for` loops
    introduced in C++11\. Older loops with explicit iterators or index variables can
    be replaced with cleaner and more intuitive range-based loops. This not only makes
    the code easier to read but also reduces the potential for off-by-one and iterator
    invalidation errors.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个现代化机会在于采用C++11中引入的基于范围的`for`循环。可以使用更简洁、更直观的基于范围的循环来替换旧的显式迭代器或索引变量的循环。这不仅使代码更容易阅读，还减少了出现偏移量错误和迭代器无效化错误的可能性。
- en: As mentioned in previous chapters, legacy C++ code bases often make heavy use
    of raw arrays and C-style strings. Such code can be refactored to use `std::array`,
    `std::vector`, and `std::string`, which are safer, more flexible, and provide
    useful member functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，遗留的C++代码库通常大量使用原始数组和C风格字符串。此类代码可以重构为使用`std::array`、`std::vector`和`std::string`，这些更安全、更灵活，并提供有用的成员函数。
- en: Lastly, modern C++ has made significant strides in improving concurrency support
    with the introduction of `std::thread`, `std::async`, and `std::future` in C++11,
    followed by further enhancements in subsequent standards. Legacy code that uses
    platform-specific threading or older concurrency libraries could benefit from
    refactoring to use these modern, portable concurrency tools.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现代C++通过引入C++11中的`std::thread`、`std::async`和`std::future`以及随后的标准中的进一步增强，在提高并发支持方面取得了重大进展。使用特定平台线程或较旧并发库的遗留代码可以从重构以使用这些现代、可移植的并发工具中受益。
- en: 'Let’s start with an example of legacy code that uses `pthread` to create a
    new thread. This thread will perform a simple calculation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`pthread`创建新线程的遗留代码示例开始。此线程将执行一个简单的计算：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we can refactor this code using `std::async` from C++11:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用C++11中的`std::async`重构此代码：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the refactored version, we use `std::async` to start a new task and `std::future::get`
    to obtain the result. The calculate function directly returns the result as an
    `int`, which is much simpler and safer than allocating memory in the `pthread`
    version. There are a few things to note. The call to `std::future::get` blocks
    the execution until the async is done. Additionally, the example uses `std::launch::async`,
    which ensures that the task is launched in a separate thread. The C++ 11 standard
    allows the implementations to decide what is the default policy: a separate thread
    or a deferred execution. At the time of writing, Microsoft Visual C++, GCC, and
    Clang run the task in a separate thread by default. The only difference is that
    while GCC and Clang create a new thread per task, Microsoft Visual C++ reuses
    threads from an internal thread pool. The error handling is also simpler, as any
    exception thrown by the calculate function will be caught by `std::future::get`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构版本中，我们使用`std::async`启动一个新任务，并使用`std::future::get`获取结果。计算函数直接返回一个`int`类型的结果，这比在`pthread`版本中分配内存要简单和安全得多。有几个需要注意的事项。对`std::future::get`的调用会阻塞执行，直到异步操作完成。此外，示例使用`std::launch::async`，这确保任务在单独的线程中启动。C++11标准允许实现决定默认策略：单独的线程或延迟执行。在撰写本文时，Microsoft
    Visual C++、GCC和Clang默认在单独的线程中运行任务。唯一的区别是，虽然GCC和Clang为每个任务创建一个新的线程，但Microsoft Visual
    C++会重用内部线程池中的线程。错误处理也更简单，因为计算函数抛出的任何异常都将被`std::future::get`捕获。
- en: Often legacy code uses object-oriented wrappers around `pthread` and other platform-specific
    APIs. Replacing them with the standard C++ implementation can decrease the amount
    of code that the developers have to support and make code more portable. However,
    multi-threading is a complex topic, so if the existing code has some rich thread-related
    logic, it is important to make sure that it stays intact.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，遗留代码使用围绕`pthread`和其他平台特定API的对象封装。用标准C++实现替换它们可以减少开发者需要支持的代码量，并使代码更具可移植性。然而，多线程是一个复杂的话题，所以如果现有代码有一些丰富的线程相关逻辑，确保它保持完整是很重要的。
- en: 'The built-in algorithms provided with modern C++ can improve legacy code readability
    and maintenance. Often, developers need to check whether an array contains a certain
    value. Pre-C++11 language allowed doing something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++提供的内置算法可以提高遗留代码的可读性和可维护性。通常，开发者需要检查数组是否包含某个特定值。C++11之前的语言允许这样做：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With C++11, we can use `std::any_of`, a new algorithm that checks if any element
    in a range satisfies a predicate. This allows us to write the code more concisely
    and expressively:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++11，我们可以使用`std::any_of`，这是一种新算法，用于检查范围中的任何元素是否满足谓词。这允许我们编写更简洁、更具表现力的代码：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this refactored version, we use a lambda function as the predicate for `std::any_of`.
    This makes the code more concise and the intention clearer. Algorithms such as
    [PRE41] and `` std::none_of` `` allows to clearly express similar checks
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构版本中，我们使用lambda函数作为`std::any_of`的谓词。这使得代码更简洁，意图更清晰。算法如[PRE41]和`std::none_of`允许清晰地表达类似的检查
- en: Remember, refactoring should be done incrementally, with each change tested
    thoroughly to ensure it doesn’t introduce new bugs or regressions. It can be a
    time-consuming process, but the benefits in terms of improved code quality, maintainability,
    and performance can be substantial.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，重构应该逐步进行，每次更改都要彻底测试，以确保不会引入新的错误或回归。这可能是一个耗时的过程，但就提高代码质量、可维护性和性能而言，其好处可能是巨大的。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve explored some of the key design patterns that can be
    instrumental in refactoring legacy C++ code, including the strategy pattern, template
    method pattern, and observer pattern. These patterns, when applied judiciously,
    can significantly improve the structure of your code, making it more flexible,
    maintainable, and resilient to change.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了可以在重构遗留C++代码中发挥关键作用的一些关键设计模式，包括策略模式、模板方法模式和观察者模式。当谨慎应用时，这些模式可以显著改善代码的结构，使其更加灵活、可维护和适应变化。
- en: 'While we’ve provided practical, real-world examples to illustrate the use of
    these patterns, this is by no means an exhaustive treatment. Design patterns are
    a vast and deep subject, with many more patterns and variations to explore. For
    a more comprehensive understanding of design patterns, I strongly recommend you
    delve into the seminal work *Design Patterns: Elements of Reusable Object-Oriented
    Software* by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, often
    referred to as the *Gang of* *Four* book.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经提供了实用的、现实世界的例子来展示这些模式的使用，但这绝对不是一种详尽无遗的处理方式。设计模式是一个庞大而深奥的主题，还有许多更多的模式和变体需要探索。为了更全面地理解设计模式，我强烈推荐您深入研究Erich
    Gamma、Richard Helm、Ralph Johnson和John Vlissides所著的奠基性作品《设计模式：可复用面向对象软件元素》，这本书通常被称为*四人帮*书。
- en: 'In addition, to keep abreast of the most recent developments and emerging best
    practices, consider resources such as *Hands-On Design Patterns with C++: Solve
    common C++ problems with modern design patterns and build robust applications*
    by Fedor G. Pikus, and *C++ Concurrency in Action* by Anthony Williams. These
    works will provide you with a broader perspective and deeper understanding of
    the powerful role design patterns play in crafting high-quality C++ software.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了跟上最新的发展和新兴的最佳实践，可以考虑像Fedor G. Pikus所著的《动手学设计模式：使用现代设计模式解决常见的C++问题并构建健壮的应用程序》和Anthony
    Williams所著的《C++并发实战》这样的资源。这些作品将为您提供更广阔的视角和更深入的理解，了解设计模式在构建高质量C++软件中扮演的强大角色。
- en: Remember, the goal of refactoring and applying design patterns is not just to
    write code that works, but to write code that is clean, easy to understand, easy
    to modify, and easy to maintain in the long run.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，重构和应用设计模式的目标不仅仅是编写出能工作的代码，而是编写出干净、易于理解、易于修改和长期易于维护的代码。
- en: In the upcoming chapter, we’ll be delving deeper into the world of C++, focusing
    specifically on naming conventions, their importance in writing clean and maintainable
    code, and best practices established by the community.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地探讨C++的世界，特别是关注命名约定、它们在编写干净和可维护的代码中的重要性以及社区建立的最佳实践。
