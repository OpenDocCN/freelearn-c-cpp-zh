["```cpp\nif ((p.x > .15 * GetSystemMetrics(SM_CXSCREEN)) && \n    (p.x < .42 * GetSystemMetrics(SM_CXSCREEN)) && \n    (p.y > .58 * GetSystemMetrics(SM_CYSCREEN)) && \n    (p.y < .70 * GetSystemMetrics(SM_CYSCREEN))) \n  { \n    if (mousedown) \n    { \n      mGameState = TCodeRex::LOAD; \n      mGameLevel = L0; \n    } \n  } \n\n```", "```cpp\ncase TCodeRex::LOAD: \n{ \nStopGameMusic(); \nStopMenuMusic(); \nswitch (mGameLevel) \n{ \ncase TCodeRex::L0: \n{ \n  grafx.LoadScreen(mLoading); \n  mLoading = true; \n  if (ObjectMgr->LoadLevel(\".\\\\Levels\\\\Level_00.txt\")) \n  { \n    mPlayer1->SetPhysics().setPosition( \n    (Physics::real)ObjectMgr->PlayerX, \n    (Physics::real)ObjectMgr->PlayerY, 0.0f); \n\n    grafx.GetCamera().Move( \n      ObjectMgr->PlayerX - 500, \n      ObjectMgr->PlayerY - 500); \n\n    ObjectMgr->AddToList(mPlayer1); \n    mPlayer1->SetHealth(100); \n    mBGTexture = grafx.GetTextureMgr().GetTile(49); \n    mplaying = true; \n    mGameState = TCodeRex::PLAY; \n  } \n    else \n      mGameState = TCodeRex::MENU; \n    break; \n}//end case TCODEREX::LOAD \n\n```", "```cpp\nif(levelCounter == 81) \n  ShowCongratsScreen(); \n\n```", "```cpp\nM5Object* pObj                = new M5Object(AT_Player); \nGfxComponent* pGfxComp        = new GfxComponent; \nPlayerInputComponent* pInput  = new PlayerInputComponent; \nClampComponent* pClamp        = new ClampComponent; \npObj->AddComponent(pGfxComp); \npObj->AddComponent(pInput); \npObj->AddComponent(pClamp ); \n//Set position, rotation, scale here \n//... \nM5ObjectManager::AddObject(pObj); \n\n```", "```cpp\nM5Object* M5ObjectManager::CreateObject(M5ArcheTypes type) \n{ \n  switch(type) \n  { \n  case AT_Player:  \n    // Create player object \n    M5Object* pPlayer             = new M5Object(AT_Player); \n\n// Create the components we'd like to use \nGfxComponent* pGfx            = new GfxComponent; \nPlayerInputComponent* pInput  = new PlayerInputComponent; \nClampComponent* pClamp        = new ClampComponent; \n\n// Attach them to our player \npObj->AddComponent(pGfx); \npObj->AddComponent(pInput); \npObj->AddComponent(pClamp); \n\n   //Add this object to the M5ObjectManager \n   AddObject(pPlayer); \n   return pPlayer; \n  break; \ncase AT_Bullet: \n  //...More Code here \n\n```", "```cpp\nvoid StageManager::Update() \n{ \n  Level1 level1; \n  level1.StartGame(); \n  while(nothingChanged) \n    level1.PlayGame() \n  level1.EndGame(); \n} \n\n```", "```cpp\nvoid StageManager::Update() \n{ \n  switch(currentStage) \n  { \n  case LEVEL1: \n  { \n    SpaceShooterLevel1 level1; \n    level1.StartLevel(); \n    while(currentStage == nextStage) \n      level1.PlayLevel() \n    level1.EndLevel(); \n    break; \n  } \n  case LEVEL2: \n  { \n    SpaceShooterLevel2 level2; \n    level2.StartGame(); \n    while(currentStage == nextStage) \n      level2.PlayLevel() \n    level2.EndLevel(); \n    break; \n  } \n  case MAIN_MENU: \n  { \n    SpaceShooterMainMenu mainMenu; \n    mainMenu.OpenMenu(); \n    while(currentStage == nextStage) \n      mainMenu.Show() \n    mainMenu.CloseMenu(); \n    break; \n  } \n}//end switch \n}//end Update \n\n```", "```cpp\n//Stage.h \nclass Stage \n{ \npublic: \n  virtual ~Stage(void) {}//Empty virtual destructor \n  virtual void Init(void)     = 0; \n  virtual void Update(void)   = 0; \n  virtual void Shutdown(void) = 0;  \n}; \n\n//StageManager.cpp \nvoid StageManager::Update() \n{ \n  //We will talk about how to get the current stage soon \n  Stage* pStage = GetCurrentStage(); \n\n  //Once we have the correct Stage we can run our code \n  pStage->Init(); \n\n  while(currentStage == nextStage) \n    pStage->Update(); \n\n  pStage->Shutdown(); \n} \n\n//Example of a derived class \n//MainMenu.h \nclass MainMenu : public Stage \n{ \npublic: \n  virtual ~MainMenu(void); \n  virtual void Init(void); \n  virtual void Update(void); \n  virtual void Shutdown(void); \nprivate: \n  //Specific MainMenu data and functions here... \n}; \n\n```", "```cpp\n//StageManager.cpp \nvoid StageManager::Update() \n{ \nStage* pStage = m_stageFactory->Build(); \n\npStage->Init(); \n\n  while(currentStage == nextStage) \n    pStage->Update(); \n\npStage->Shutdown(); \nm_StageFactory->Destroy(pStage);//stage must be destroyed \n} \n\n```", "```cpp\n//MakeStage.cpp \nStage* MakeStage(StageType type) \n{ \n  switch(type) \n  { \n    case ST_Level1: \n      return new Level1; \n    case ST_LEVEL2: \n      return new Level2; \n    case ST_MainMenu: \n      return new MainMenu; \n    default: \n      //Throw exception or assert \n  } \n} \n\n```", "```cpp\nvoid StageManager::Update() \n{ \n  Stage* pStage = MakeStage(currentStage); \n\n  pStage->Init(); \n\n  while(currentStage == nextStage) \n    pStage->Update(); \n\npStage->Shutdown(); \nDestroyStage(pStage);//Clean up the stage when done \n} \n\n```", "```cpp\nclass M5Stage \n{ \npublic: \n  virtual ~M5Stage(void) {} //Empty virtual destructor \n  virtual void Load(void)       = 0; \n  virtual void Init(void)       = 0; \n  virtual void Update(float dt) = 0; \n  virtual void Shutdown(void)   = 0; \n  virtual void Unload(void)     = 0; \n}; \n\n```", "```cpp\nclass M5StageBuilder \n{ \npublic: \n  virtual ~M5StageBuilder() {} //Empty virtual destructor \n  virtual M5Stage* Build(void) = 0; \n}; \n\n```", "```cpp\n//SplashStageBuilder.h \nclass SplashStageBuilder: public M5StageBuilder \n{ \npublic: \n  virtual M5Stage* Build(void); \n}; \n\n//SplashStageBuilder.cpp \nM5Stage* SplashStageBuilder::Build(void) \n{ \nreturn new SplashStage; \n} \n\n//MainMenuStageBuilder.h \nclass MainMenuStageBuilder: public M5StageBuilder \n{ \npublic: \n  virtual M5Stage* Build(void); \n}; \n\n// MainMenuStageBuilder.cpp \nM5Stage* MainMenuStageBuilder::Build(void) \n{ \nreturn new MainMenuStage; \n} \n\n```", "```cpp\n//M5StageBuilder.h \ntemplate <typename T> \nclass M5StageTBuilder : public M5StageBuilder \n{ \npublic: \n  virtual M5Stage* Build(void); \n}; \n\ntemplate <typename T> \nM5Stage* M5StageTBuilder<T>::Build(void) \n{ \n  return new T(); \n} \n\n```", "```cpp\n//SomeFile.cpp \n#include \"M5StageBuilder.h\" \n#include \"MainMenuStage.h\" \n\nvoid SomeFunction(void) \n{ \n  //Creating the class needs the type \n  M5Builder* pBuilder = new M5StageTBuilder< SplashStage >(); \n\n  //But using the Build function doesn't need the type \n  M5Stage* pStage = pBuilder->Build(); \n} \n\n```", "```cpp\nclass M5StageFactory \n{ \npublic: \n~M5StageFactory(void); \nvoid     AddBuilder(M5StageTypes name, M5StageBuilder* builder); \nvoid     RemoveBuilder(M5StageTypes type); \nvoid     ClearBuilders(void); \nM5Stage* Build(M5StageTypes name); \nprivate: \n  typedef std::unordered_map<M5StageTypes,\n     M5StageBuilder*> BuilderMap; \n  typedef BuilderMap::iterator MapItor; \n\n  BuilderMap m_builderMap; \n}; \n\n```", "```cpp\ntypedef std::unordered_map<M5StageTypes, M5StageBuilder*> BuilderMap; \n\n```", "```cpp\ntypedef BuilderMap::iterator MapItor; \n\n```", "```cpp\nBuilderMap m_builderMap; \n\n```", "```cpp\nM5Stage* M5StageFactory::Build(M5StageTypes type) \n{ \n  ArcheTypeItor itor = m_builderMap.find(type); \nif (itor == m_builderMap.end()) \n  return nullptr; \nelse \n  return itor->second->Build(); \n} \n\n```", "```cpp\nbool M5StageFactory::AddBuilder(M5StageTypes name, \n   M5StageBuilder* pBuilder) \n{ \nstd::pair<MapItor, bool> itor = m_builderMap.insert(\n   std::make_pair(name, pBuilder)); \n\nreturn itor.second; \n} \n\n```", "```cpp\nvoid M5StageFactory::RemoveBuilder(M5StageTypes name) \n{ \n  BuilderMap::iterator itor = m_builderMap.find(name); \n\nif (itor == m_builderMap.end()) \n  return; \n\n  //First delete the builder \n  delete itor->second; \n  itor->second = 0;//See the note below \n\n  //then erase the element \n  m_builderMap.erase(itor); \n} \n\n```", "```cpp\nvoid M5StageFactory::ClearBuilders(void) \n{ \n  MapItor itor = m_builderMap.begin(); \n  MapItor end  = m_builderMap.end(); \n\n  //Make sure to delete all builder pointers first \n  while (itor != end) \n  { \n    delete itor->second; \n    itor->second = 0; \n    ++itor; \n  } \n\n  //Then clear the hash table \n  m_builderMap.clear(); \n} \n\n```", "```cpp\nM5StageFactory::~M5StageFactory(void) \n{ \n  ClearBuilders(); \n} \n\n```", "```cpp\nclass M5StageManager \n{ \npublic: \n  //Lots of other stuff here... \n  static void AddStage(M5StageTypes type, M5StageBuilder* \n     builder); \nstatic void RemoveStage(M5StageTypes type); \nstatic void ClearStages(void); \n\nprivate: \n  //Lots of other stuff here \n  static M5StageFactory s_stageFactory; \n}; \n\n```", "```cpp\nvoid M5StageManager::Update(void) \n{ \n  float frameTime = 0.0f; \n  /*Get the Current stage*/ \n M5Stage* pCurrentStage = s_stageFactory.Build(s_currStage); \n\n  /*Call the initialize function*/ \n  pStage->Init(); \n\n  /*Keep going until the stage has changed or we are quitting. */ \n  while ((s_currStage == s_nextStage) && \n       !s_isQuitting                && \n       !s_isRestarting) \n  { \n    /*Our main game loop*/ \n    s_timer.StartFrame();/*Save the start time of the frame*/ \n    M5Input::Reset(frameTime); \n    M5App::ProcessMessages(); \n\n    pStage->Update(frameTime); \n\n    M5ObjectManager::Update(frameTime); \n    M5Gfx::Update(); \n    frameTime = s_timer.EndFrame();/*Get the total frame time*/ \n  } \n\n  /*Make sure to Shut down the stage*/ \n  pStage->Shutdown(); \n\n  ChangeStage(); \n} \n\n```", "```cpp\n//Component Factory \nclass M5ComponentFactory \n{ \npublic: \n  ~M5ComponentFactory(void); \n  void AddBuilder(M5ComponentTypes type, \n                   M5ComponentBuilder* builder); \n  void RemoveBuilder(M5ComponentTypes type); \n  M5Component* Build(M5ComponentTypes type); \n  void ClearBuilders(void); \nprivate: \n  typedef std::unordered_map<M5ComponentTypes, \n                              M5ComponentBuilder*> BuilderMap; \n  typedef BuilderMap::iterator MapItor; \n  BuilderMap m_builderMap; \n}; \n\n//Object Factory \nclass M5ObjectFactory \n{ \npublic: \n  ~ M5ObjectFactory (void); \n  void AddBuilder(M5ArcheTypes type, \n     M5ObjectBuilder* builder); \n  void RemoveBuilder(M5ArcheTypes type); \n  M5Object* Build(M5ArcheTypes type); \n  void ClearBuilders(void); \nprivate: \n  typedef std::unordered_map< M5ArcheTypes, \n     M5ObjectBuilder *> BuilderMap; \n  typedef BuilderMap::iterator MapItor; \n  BuilderMap m_builderMap; \n}; \n\n```", "```cpp\n//M5Factory.h \ntemplate<typename EnumType, \n         typename BuilderType, \n         typename ReturnType> \nclass M5Factory \n{ \npublic: \n  ~M5Factory(void); \n  void AddBuilder(EnumType type, BuilderType* pBuilder); \n  void RemoveBuilder(EnumType type); \n  ReturnType* Build(EnumType type); \n  void ClearBuilders(void); \nprivate: \n  typedef std::unordered_map<EnumType, BuilderType*> BuilderMap; \n  typedef typename BuilderMap::iterator MapItor; \n  BuilderMap m_builderMap; \n}; \n\n```", "```cpp\ntypedef typename BuilderMap::iterator MapItor; \n\n```", "```cpp\n//M5Factory.h \ntemplate<typename EnumType, \n         typename BuilderType, \n         typename ReturnType> \nReturnType* M5Factory<EnumType, \n                      BuilderType, \n                      ReturnType>::Build(EnumType type) \n{ \nMapItor itor = m_builderMap.find(type); \nM5DEBUG_ASSERT(itor != m_builderMap.end(), \n  \"Trying to use a Builder that doesn't exist\"); \n  return itor->second->Build(); \n} \n\n```", "```cpp\nclass M5StageManager \n{ \npublic: \n  //Same as before \nprivate: \n//static M5StageFactory s_stageFactory; //Our Old Code \nstatic M5Factory<M5StageTypes, \n                 M5StageBuilder, \n                 M5Stage> s_stageFactory;//Our new code \n\n}; \n\n```", "```cpp\nclass M5ObjectManager \n{ \npublic: \n  //See M5ObjectManager.h for details \nprivate: \n  static M5Factory<M5ComponentTypes, \n                    M5ComponentBuilder, \n                    M5Component> s_componentFactory; \nstatic M5Factory<M5ArcheTypes, \n                    M5ObjectBuilder, \n                    M5Object> s_ObjectFactory; \n}; \n\n```", "```cpp\n#include \"M5StageManager.h\" \n#include \"M5StageTypes.h\" \n#include \"M5StageBuilder.h\" \n#include \"GamePlayStage.h\" //Example Stage \n#include \"SplashStage.h\"   //Example Stage \n\nvoid RegisterStages(void) \n{ \nM5StageManager::AddStage(ST_GamePlayStage, \n   new M5StageTBuilder< GamePlayStage >() ); \nM5StageManager::AddStage(ST_SplashStage, \n   new M5StageTBuilder< SplashStage >() ); \n} \n\n```"]