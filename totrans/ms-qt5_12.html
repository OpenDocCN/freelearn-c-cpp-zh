<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. You Shall (Not) Pass with QTest</h1></div></div></div><p>In the previous chapter, we created a drum machine software with some serialization feature. In this chapter, we will write the unit tests for this application. To achieve this goal, we will use Qt Test, a dedicated test module for Qt applications.</p><p>The example project is a test application using CLI commands to execute and generate a test report. We will cover different types of tests including datasets, GUI, signals, and benchmarking.</p><p>This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Qt Test framework</li><li class="listitem">Project layout for unit tests</li><li class="listitem">Personalize your test execution</li><li class="listitem">Write tests with datasets</li><li class="listitem">Benchmark your code</li><li class="listitem">Simulating GUI events</li><li class="listitem">Perform signal introspection with the <code class="literal">QSignalSpy</code> class</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec108"/>Discovering Qt Test</h1></div></div></div><p>The Qt framework provides Qt Test, a complete API to create your unit tests in C++. A test executes the code of your application and performs verification on it. Usually, a test compares a variable with an expected value. If the variable does not match the specific value, the test fails. If you wish to go further, you can benchmark your code and get the time/CPU tick/events required by your code. Clicking over and over on a GUI to test it can quickly become boring. Qt Test offers you the possibility to simulate keyboard entries and mouse events on your widgets to completely check your software.</p><p>In our case, we want to create a unit test program named <code class="literal">drum-machine-test</code>. This console application will check the code of our famous drum machine from the previous chapter. Create a <code class="literal">subdirs</code> project called <code class="literal">ch12-drum-machine-test</code> with the following topology:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">drum-machine</code>:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">drum-machine.pro</code></li></ul></div></li><li class="listitem"><code class="literal">drum-machine-test</code>:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">drum-machine-test.pro</code></li></ul></div></li><li class="listitem"><code class="literal">ch12-drum-machine-test.pro</code></li><li class="listitem"><code class="literal">drum-machine-src.pri</code></li></ul></div><p>The <code class="literal">drum-machine</code> and <code class="literal">drum-machine-test</code> projects share the same source code. So all common files are put in a project include file: <code class="literal">drum-machine-src.pri</code>. Here is the updated <code class="literal">drum-machine.pro</code>:</p><pre class="programlisting">QT += core gui multimedia widgets &#13;
CONFIG += c++14 &#13;
 &#13;
TARGET = drum-machine &#13;
TEMPLATE = app &#13;
 &#13;
include(../drum-machine-src.pri) &#13;
 &#13;
SOURCES += main.cpp &#13;
</pre><p>As you can see, we only perform a refactoring task; the project drum-machine is not affected by the drum-machine-test application. You can now create the <code class="literal">drum-machine-test.pro</code> file like this:</p><pre class="programlisting">QT += core gui multimedia widgets testlib &#13;
CONFIG += c++14 console &#13;
 &#13;
TARGET = drum-machine-test &#13;
TEMPLATE = app &#13;
 &#13;
include(../drum-machine-src.pri) &#13;
 &#13;
DRUM_MACHINE_PATH = ../drum-machine &#13;
INCLUDEPATH += $$DRUM_MACHINE_PATH &#13;
DEPENDPATH += $$DRUM_MACHINE_PATH &#13;
 &#13;
SOURCES += main.cpp &#13;
</pre><p>The first thing to notice is that we need to enable the <code class="literal">testlib</code> module. Then even if we are creating a console application, we want to perform a test on the GUI so the modules (<code class="literal">gui</code>, <code class="literal">multimedia</code>, and <code class="literal">widgets</code>) used by the primary application are also required here. Finally, we include the project include file with all application files (sources, headers, forms, and resources). The <code class="literal">drum-machine-test</code> application will also contain new source files, so we must correctly set the <code class="literal">INCLUDEPATH</code> and <code class="literal">DEPENDPATH</code> variables to the source files folder.</p><p>Qt Test is easy to use and relies on some simple assumptions:</p><div><ul class="itemizedlist"><li class="listitem">A test case is a <code class="literal">QObject</code> class</li><li class="listitem">A private slot is a test function</li><li class="listitem">A test case can contain several test functions</li></ul></div><p>Notice that the private slots with the following names are not test functions, but special functions automatically called to initialize and clean up your test:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">initTestCase()</code>: This function is called before the first test function</li><li class="listitem"><code class="literal">init()</code>: This function is called before each test function</li><li class="listitem"><code class="literal">cleanup()</code>: This function is called after each test function</li><li class="listitem"><code class="literal">cleanupTestCase()</code>: This function is called after the last test function</li></ul></div><p>Alright, we are ready to write our first test case in the <code class="literal">drum-machine-test</code> application. The serialization of the <code class="literal">drum-machine</code> object is an important part. A bad modification on the save feature can easily break the load feature. It can produce no errors at compile time, but it can lead to an unusable application. That is why tests are important. The first thing is to validate the serialization/deserialization process. Create a new C++ class, <code class="literal">DummySerializable</code>. Here is the header file:</p><pre class="programlisting">#include "Serializable.h" &#13;
 &#13;
class DummySerializable : public Serializable &#13;
{ &#13;
public: &#13;
    DummySerializable(); &#13;
 &#13;
    QVariant toVariant() const override; &#13;
    void fromVariant(const QVariant&amp; variant) override; &#13;
 &#13;
    int myInt = 0; &#13;
    double myDouble = 0.0; &#13;
    QString myString = ""; &#13;
    bool myBool = false; &#13;
}; &#13;
</pre><p>It is a simple class implementing our <code class="literal">Serializable</code> interface created in <a class="link" title="Chapter 11.  Having Fun with Serialization" href="part0104.xhtml#aid-335QG1">Chapter 11</a>, <em>Having Fun with Serialization</em>. This class will be helpful to validate the lower layer in our serialization process. As you can see, the class contains some variables with various types to ensure a complete functioning serialization. Let's see the file, 
<code class="literal">DummySerializable.cpp</code>:</p><pre class="programlisting">#include "DummySerializable.h" &#13;
 &#13;
DummySerializable::DummySerializable() : &#13;
    Serializable() &#13;
{ &#13;
} &#13;
 &#13;
QVariant DummySerializable::toVariant() const &#13;
{ &#13;
    QVariantMap map; &#13;
    map.insert("myInt", myInt); &#13;
    map.insert("myDouble", myDouble); &#13;
    map.insert("myString", myString); &#13;
    map.insert("myBool", myBool); &#13;
    return map; &#13;
} &#13;
 &#13;
void DummySerializable::fromVariant(const QVariant&amp; variant) &#13;
{ &#13;
    QVariantMap map = variant.toMap(); &#13;
    myInt = map.value("myInt").toInt(); &#13;
    myDouble = map.value("myDouble").toDouble(); &#13;
    myString = map.value("myString").toString(); &#13;
    myBool = map.value("myBool").toBool(); &#13;
} &#13;
</pre><p>No surprise here; we perform our operation with a <code class="literal">QVariantMap</code>, as already performed in the previous chapter. Our dummy class is ready; create a new C++ class, <code class="literal">TestJsonSerializer</code>, with the following header:</p><pre class="programlisting">#include &lt;QtTest/QTest&gt; &#13;
 &#13;
#include "JsonSerializer.h" &#13;
 &#13;
class TestJsonSerializer : public QObject &#13;
{ &#13;
    Q_OBJECT &#13;
 &#13;
public: &#13;
    TestJsonSerializer(QObject* parent = nullptr); &#13;
 &#13;
private slots: &#13;
    void cleanup(); &#13;
    void saveDummy(); &#13;
    void loadDummy(); &#13;
 &#13;
private: &#13;
    QString loadFileContent(); &#13;
 &#13;
private: &#13;
    JsonSerializer mSerializer; &#13;
}; &#13;
</pre><p>Here we are, our first test case! This test case performs verifications on our class, <code class="literal">JsonSerializer</code>. You can see two test functions, <code class="literal">saveDummy()</code> and <code class="literal">loadDummy()</code>. The <code class="literal">cleanup()</code> slot is the special Qt Test slot that we covered earlier, which is executed after each test function. We can now write the implementation in <code class="literal">TestJsonSerializer.cpp</code>:</p><pre class="programlisting">#include "DummySerializable.h" &#13;
 &#13;
const QString FILENAME = "test.json"; &#13;
const QString DUMMY_FILE_CONTENT = "{\n    "myBool": true,\n    "myDouble": 5.2,\n    "myInt": 1,\n    "myString": "hello"\n}\n"; &#13;
 &#13;
TestJsonSerializer::TestJsonSerializer(QObject* parent) : &#13;
    QObject(parent), &#13;
    mSerializer() &#13;
{ &#13;
} &#13;
</pre><p>Two constants are created here:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">FILENAME</code>: This is the filename used to test the save and load the data</li><li class="listitem"><code class="literal">DUMMY_FILE_CONTENT</code>: This is the referential file content used by the test functions, <code class="literal">saveDummy()</code> and <code class="literal">loadDummy()</code></li></ul></div><p>Let's implement the test function, <code class="literal">saveDummy()</code>:</p><pre class="programlisting">void TestJsonSerializer::saveDummy() &#13;
{ &#13;
    DummySerializable dummy; &#13;
    dummy.myInt = 1; &#13;
    dummy.myDouble = 5.2; &#13;
    dummy.myString = "hello"; &#13;
    dummy.myBool = true; &#13;
 &#13;
    mSerializer.save(dummy, FILENAME); &#13;
 &#13;
    QString data = loadFileContent(); &#13;
    QVERIFY(data == DUMMY_FILE_CONTENT); &#13;
} &#13;
</pre><p>The first step is to instantiate a <code class="literal">DummySerializable</code> class with some fixed values. So, we call the function to test, <code class="literal">JsonSerializer::save()</code>, that will serialize our dummy object in the <code class="literal">test.json</code> file. Then, we call a helper function, <code class="literal">loadFileContent()</code>, to get the text contained in the <code class="literal">test.json</code> file. Finally, we use a Qt Test macro, <code class="literal">QVERIFY()</code>, to perform the verification that the text saved by the JSON serializer is the same as the expected value in <code class="literal">DUMMY_FILE_CONTENT</code>. If <code class="literal">data</code> equals the correct value, the test function succeeds. Here is the log output:</p><pre class="programlisting">PASS   : TestJsonSerializer::saveDummy() &#13;
</pre><p>If the data is different than the expected value, the test fails and an error is displayed in the console log:</p><pre class="programlisting">FAIL!  : TestJsonSerializer::saveDummy()  &#13;
'data == DUMMY_FILE_CONTENT' returned FALSE. () &#13;
Loc: [../../ch12-drum-machine-test/drum-machine-test/TestJsonSerializer.cpp(31)] &#13;
</pre><p>Let's briefly see the helper function, <code class="literal">loadFileContent()</code>:</p><pre class="programlisting">QString TestJsonSerializer::loadFileContent() &#13;
{ &#13;
    QFile file(FILENAME); &#13;
    file.open(QFile::ReadOnly); &#13;
    QString content = file.readAll(); &#13;
    file.close(); &#13;
    return content; &#13;
} &#13;
</pre><p>No big deal here. We open the file, <code class="literal">test.json</code>, read all the text content, and return the corresponding <code class="literal">QString</code>.</p><p>The macro, <code class="literal">QVERIFY()</code>, is great to check a Boolean value, but Qt Test provides a better macro when you want to compare data to an expected value. Let's discover <code class="literal">QCOMPARE()</code> with the test function, <code class="literal">loadDummy()</code>:</p><pre class="programlisting">void TestJsonSerializer::loadDummy() &#13;
{ &#13;
    QFile file(FILENAME); &#13;
    file.open(QFile::WriteOnly | QIODevice::Text); &#13;
    QTextStream out(&amp;file); &#13;
    out &lt;&lt; DUMMY_FILE_CONTENT; &#13;
    file.close(); &#13;
 &#13;
    DummySerializable dummy; &#13;
    mSerializer.load(dummy, FILENAME); &#13;
 &#13;
    QCOMPARE(dummy.myInt, 1); &#13;
    QCOMPARE(dummy.myDouble, 5.2); &#13;
    QCOMPARE(dummy.myString, QString("hello")); &#13;
    QCOMPARE(dummy.myBool, true); &#13;
} &#13;
</pre><p>The first part creates a <code class="literal">test.json</code> file, with a referential content. Then we create an empty <code class="literal">DymmySerializable</code> and call the function to test <code class="literal">Serializable::load()</code>. Finally, we use the Qt Test macro, <code class="literal">QCOMPARE()</code>. The syntax is simple:</p><pre class="programlisting">QCOMPARE(actual_value, expected_value); &#13;
</pre><p>We can now test each field of the dummy loaded from JSON. The test function, <code class="literal">loadDummmy()</code>, will only succeed if all <code class="literal">QCOMPARE()</code> calls succeed. An error with a <code class="literal">QCOMPARE()</code> is much more detailed:</p><pre class="programlisting">FAIL!  : TestJsonSerializer::loadDummy() Compared values are not the same &#13;
   Actual   (dummy.myInt): 0 &#13;
   Expected (1)          : 1 &#13;
Loc: [../../ch12-drum-machine-test/drum-machine-test/TestJsonSerializer.cpp(45)] &#13;
</pre><p>Each time a test function is executed, the special <code class="literal">cleanup()</code> slot is called. Let's update your file, <code class="literal">TestJsonSerializable.cpp</code>, like this:</p><pre class="programlisting">void TestJsonSerializer::cleanup() &#13;
{ &#13;
    QFile(FILENAME).remove(); &#13;
} &#13;
</pre><p>This is a simple security that will remove the <code class="literal">test.json</code> file after each test function and prevent the save and load tests from colliding.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec109"/>Executing your tests</h1></div></div></div><p>We wrote a test case, <code class="literal">TestJsonSerializer</code>, with some test functions. We need a <code class="literal">main()</code> function in our <code class="literal">drum-machine-test</code> application. We will explore three possibilities:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">QTEST_MAIN()</code> function</li><li class="listitem">Write our own simple <code class="literal">main()</code> function</li><li class="listitem">Write our own enhanced <code class="literal">main()</code> supporting multiple test classes</li></ul></div><p>The <code class="literal">QTest</code> module provides an interesting macro, <code class="literal">QTEST_MAIN()</code>. This macro generates a complete <code class="literal">main()</code> function for your application. This generated method runs all the test functions of your test case. To use it, add the following snippet at the end of the <code class="literal">TestJsonSerializer.cpp</code> file:</p><pre class="programlisting">QTEST_MAIN(TestJsonSerializer) &#13;
</pre><p>Moreover, if you declare and implement your test class only in the <code class="literal">.cpp</code> file (without a header file), you need to include the generated moc file after the <code class="literal">QTEST_MAIN</code> macro:</p><pre class="programlisting">QTEST_MAIN(TestJsonSerializer) &#13;
#include "testjsonserializer" &#13;
</pre><p>If you use the <code class="literal">QTEST_MAIN()</code> macro, do not forget to remove the existing <code class="literal">main.cpp</code>. Otherwise, you will have two <code class="literal">main()</code> functions and a compilation error will happen.</p><p>You can now try to run your drum-machine-test application and look at the application output. You should see something similar to this:</p><pre class="programlisting">
<strong>$ ./drum-machine-test</strong>
<strong>********* Start testing of TestJsonSerializer *********</strong>
<strong>Config: Using QtTest library 5.7.0, Qt 5.7.0 (x86_64-little_endian-lp64 shared (dynamic) release build; by GCC 4.9.1 20140922 (Red Hat 4.9.1-10))</strong>
<strong>PASS   : TestJsonSerializer::initTestCase()</strong>
<strong>PASS   : TestJsonSerializer::saveDummy()</strong>
<strong>PASS   : TestJsonSerializer::loadDummy()</strong>
<strong>PASS   : TestJsonSerializer::cleanupTestCase()</strong>
<strong>Totals: 4 passed, 0 failed, 0 skipped, 0 blacklisted, 1ms</strong>
<strong>********* Finished testing of TestJsonSerializer *********</strong>
</pre><p>Our test functions, <code class="literal">saveDummy()</code> and <code class="literal">loadDummy()</code>, are executed in the declaration order. Both succeed with the <code class="literal">PASS</code> status. The generated test application handles some options. Commonly, you can display the help menu executing this command:</p><pre class="programlisting">
<strong>$ ./drum-machine-test -help</strong>
</pre><p>Let's see some cool features. We can execute only one function with the name. The following command only executes the <code class="literal">saveDummy</code> test function:</p><pre class="programlisting">
<strong>$ ./drum-machine-test saveDummy</strong>
</pre><p>You can also execute several test functions separating their names with a space.</p><p>The QTest application provides log detail options:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">-silent</code> for silent. Only displays fatal errors and summary messages.</li><li class="listitem"><code class="literal">-v1</code> for verbose. Shows the test function entered information.</li><li class="listitem"><code class="literal">-v2</code> for extended verbose. Shows each <code class="literal">QCOMPARE()</code> and <code class="literal">QVERIFY()</code>.</li><li class="listitem"><code class="literal">-vs</code> for verbose signal. Shows the emitted signal and the connected slot.</li></ul></div><p>For example, we can display details of the execution of <code class="literal">loadDummy</code> with the following command:</p><pre class="programlisting">
<strong>$ ./drum-machine-test -v2 loadDummy</strong>
<strong>********* Start testing of TestJsonSerializer *********</strong>
<strong>Config: Using QtTest library 5.7.0, Qt 5.7.0 (x86_64-little_endian-lp64 shared (dynamic) release build; by GCC 4.9.1 20140922 (Red Hat 4.9.1-10))</strong>
<strong>INFO   : TestJsonSerializer::initTestCase() entering</strong>
<strong>PASS   : TestJsonSerializer::initTestCase()</strong>
<strong>INFO   : TestJsonSerializer::loadDummy() entering</strong>
<strong>INFO   : TestJsonSerializer::loadDummy() QCOMPARE(dummy.myInt, 1)</strong>
<strong>   Loc: [../../ch12-drum-machine-test/drum-machine-test/TestJsonSerializer.cpp(45)]</strong>
<strong>INFO   : TestJsonSerializer::loadDummy() QCOMPARE(dummy.myDouble, 5.2)</strong>
<strong>   Loc: [../../ch12-drum-machine-test/drum-machine-test/TestJsonSerializer.cpp(46)]</strong>
<strong>INFO   : TestJsonSerializer::loadDummy() QCOMPARE(dummy.myString, QString("hello"))</strong>
<strong>   Loc: [../../ch12-drum-machine-test/drum-machine-test/TestJsonSerializer.cpp(47)]</strong>
<strong>INFO   : TestJsonSerializer::loadDummy() QCOMPARE(dummy.myBool, true)</strong>
<strong>   Loc: [../../ch12-drum-machine-test/drum-machine-test/TestJsonSerializer.cpp(48)]</strong>
<strong>PASS   : TestJsonSerializer::loadDummy()</strong>
<strong>INFO   : TestJsonSerializer::cleanupTestCase() entering</strong>
<strong>PASS   : TestJsonSerializer::cleanupTestCase()</strong>
<strong>Totals: 3 passed, 0 failed, 0 skipped, 0 blacklisted, 1ms</strong>
<strong>********* Finished testing of TestJsonSerializer *********</strong>
</pre><p>Another great feature is the logging output format. You can create a test report file with various formats <code class="literal">(.txt</code>, <code class="literal">.xml</code>, <code class="literal">.csv</code>, and so on). The syntax requires a filename and a file format separated by a comma:</p><pre class="programlisting">
<strong>$ ./drum-machine-test -o &lt;filename&gt;,&lt;format&gt;</strong>
</pre><p>In the following example, we create an XML report named <code class="literal">test-report.xml</code>:</p><pre class="programlisting">
<strong>$ ./drum-machine-test -o test-report.xml,xml</strong>
</pre><p>Notice that some log level affects only the plain text output. Moreover, the CSV format can be used only with the test macro <code class="literal">QBENCHMARK</code>, which is covered later in this chapter.</p><p>If you want to customize the generated test application, you can write the <code class="literal">main()</code> function. Remove the <code class="literal">QTEST_MAIN</code> macro in <code class="literal">TestJsonSerializer.cpp</code>. Then create a <code class="literal">main.cpp</code> like this:</p><pre class="programlisting">#include "TestJsonSerializer.h" &#13;
 &#13;
int main(int argc, char *argv[]) &#13;
{ &#13;
    TestJsonSerializer test; &#13;
    QStringList arguments = QCoreApplication::arguments(); &#13;
    return QTest::qExec(&amp;test, arguments); &#13;
} &#13;
</pre><p>In this case, we are using the static function, <code class="literal">QTest::qExec()</code>, to start a <code class="literal">TestJsonSerializer</code> test. Do not forget to provide the command-line arguments to enjoy the QTest CLI options.</p><p>If you wrote your test functions in different test classes, you would have created one application by a test class. If you keep one test class by test application you can even use the <code class="literal">QTEST_MAIN</code> macro to generate the main functions.</p><p>Sometimes you want to create only one test application to handle all your test classes. In this case, you have multiple test classes in the same application, so you cannot use the <code class="literal">QTEST_MAIN</code> macro because you do not want to generate several main functions for each test class.</p><p>Let's see a simple way to call all your test classes in a unique application:</p><pre class="programlisting">int main(int argc, char *argv[]) &#13;
{ &#13;
    int status = 0; &#13;
    TestFoo testFoo; &#13;
    TestBar testBar; &#13;
    status |= QTest::qExec(&amp;testFoo); &#13;
    status |= QTest::qExec(&amp;testBar); &#13;
    return status; &#13;
} &#13;
</pre><p>In this simple custom <code class="literal">main()</code> function, we are executing the <code class="literal">TestFoo</code> and <code class="literal">TestBar</code> tests. But we are losing the CLI options. Indeed, executing the <code class="literal">QTest::qExec()</code> function with command-line arguments more than once will lead to errors and bad behaviors. For example, if you want to execute only one specific test function from <code class="literal">TestBar</code>. The execution of <code class="literal">TestFoo</code> will not find the test function, display an error message, and stop the application.</p><p>Here is a workaround to handle several test classes in a unique application. We will create a new CLI option, <code class="literal">-select</code>, to our test application. This option allows you to select a specific test class to execute. Here is a syntax example:</p><pre class="programlisting">
<strong>$ ./drum-machine-test -select foo fooTestFunction</strong>
</pre><p>The <code class="literal">-select</code> option, if used, must be at the beginning of the command followed by the test class name (<code class="literal">foo</code> in this example). Then, we can optionally add Qt Test options. To achieve this goal, we will create an enhanced <code class="literal">main()</code> function that parses the new <code class="literal">select</code> option and execute the corresponding test class.</p><p>We will create our enhanced <code class="literal">main()</code> function together:</p><pre class="programlisting">QApplication app(argc, argv); &#13;
QStringList arguments = QCoreApplication::arguments(); &#13;
 &#13;
map&lt;QString, unique_ptr&lt;QObject&gt;&gt; tests; &#13;
tests.emplace("jsonserializer", &#13;
    make_unique&lt;TestJsonSerializer&gt;()); &#13;
tests.emplace("foo", make_unique&lt;TestFoo&gt;()); &#13;
tests.emplace("bar", make_unique&lt;TestBar&gt;()); &#13;
</pre><p>The <code class="literal">QApplication</code> will be required later by our other GUI test cases. We retrieve the command line arguments for later use. The <code class="literal">std::map</code> template named <code class="literal">tests</code> contains the smart pointers of the test classes and a <code class="literal">QString</code> label is used as a key. Notice that we are using the <code class="literal">map::emplace()</code> function that does not copy the source to the map, but creates it in place. Using the <code class="literal">map::insert()</code> function leads to an error due to the illegal copy of a smart pointer. Another syntax that could be used with a <code class="literal">std::map</code> template and a <code class="literal">make_unique</code> is:</p><pre class="programlisting">tests["bar"] = make_unique&lt;TestBar&gt;(); &#13;
</pre><p>We can now parse the command line arguments:</p><pre class="programlisting">if (arguments.size() &gt;= 3 &amp;&amp; arguments[1] == "-select") { &#13;
    QString testName = arguments[2]; &#13;
    auto iter = tests.begin(); &#13;
    while(iter != tests.end()) { &#13;
        if (iter-&gt;first != testName) { &#13;
            iter = tests.erase(iter); &#13;
        } else { &#13;
            ++iter; &#13;
        } &#13;
    } &#13;
    arguments.removeOne("-select"); &#13;
    arguments.removeOne(testName); &#13;
} &#13;
</pre><p>If the <code class="literal">-select</code> option is used, this snippet performs two important tasks:</p><div><ul class="itemizedlist"><li class="listitem">Removes from the map <code class="literal">tests</code>, the test classes that do not match the test name</li><li class="listitem">Removes the arguments from the <code class="literal">-select</code> option and the <code class="literal">testName</code> variable to provide cleaned arguments to the <code class="literal">QTest::qExec()</code> function</li></ul></div><p>We can now add the final step to execute the test classes:</p><pre class="programlisting">int status = 0; &#13;
for(auto&amp; test : tests) { &#13;
    status |= QTest::qExec(test.second.get(), arguments); &#13;
} &#13;
 &#13;
return status; &#13;
</pre><p>Without the <code class="literal">-select</code> option, all the test classes will be performed. If we use the <code class="literal">-select</code> option with a test class name, only this one will be executed.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec110"/>Writing factorized tests with datasets</h1></div></div></div><p>We will now turn our attention to testing the <code class="literal">Track</code> class. We will focus specifically on the different states a <code class="literal">Track</code> class can have: <code class="literal">STOPPED</code>, <code class="literal">PLAYING</code>, and <code class="literal">RECORDING</code>. For each one of these states, we want to make sure that adding <code class="literal">SoundEvents</code> works only if we are in the proper state (<code class="literal">RECORDING</code>).</p><p>To do so, we could write the following test functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">testAddSoundEvent()</code>: This function puts the <code class="literal">Track</code> in the <code class="literal">STOPPED</code> state, calls <code class="literal">track.addSoundEvent(0)</code>, and checks <code class="literal">track.soundEvents().size == 0</code></li><li class="listitem"><code class="literal">testAddSoundEvent()</code>: This function puts the <code class="literal">Track</code> in the <code class="literal">PLAYING</code> state, calls <code class="literal">track.addSoundEvent(0),</code> and checks <code class="literal">track.soundEvents().size == 0</code></li><li class="listitem"><code class="literal">testAddSoundEvent()</code>: This function puts the <code class="literal">Track</code> in the <code class="literal">RECORDING</code> state, calls <code class="literal">track.addSoundEvent(0)</code>, and checks <code class="literal">track.soundEvents().size == 1</code></li></ul></div><p>As you can see, the logic is the same, we simply change the inputs and the desired outputs. To factorize this, Qt Test provides another module: datasets.</p><p>A dataset can be seen as a two-dimensional table where each row is a test, and the columns are the inputs and expected outputs. For our <code class="literal">Track</code> state test, it would look like this:</p><div><img src="img/image00445.jpeg" alt="Writing factorized tests with datasets"/></div><p style="clear:both; height: 1em;"> </p><p>With this approach, you write a single <code class="literal">addSoundEvent()</code> test function and Qt Test takes care of iterating over this table and comparing the result. Right now, it seems like magic. Let's implement it!</p><p>Create a new C++ class named <code class="literal">TestTrack</code>, following the same pattern used for the <code class="literal">TestJsonSerializer</code> class (inherits <code class="literal">QObject</code>, includes <code class="literal">QTest</code>). Update <code class="literal">TestTrack.h</code> like so:</p><pre class="programlisting">class TestTrack : public QObject &#13;
{ &#13;
    Q_OBJECT &#13;
public: &#13;
    explicit TestTrack(QObject *parent = 0); &#13;
 &#13;
private slots: &#13;
    void addSoundEvent_data(); &#13;
    void addSoundEvent(); &#13;
}; &#13;
</pre><p>Here we added two functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">addSoundEvent_data()</code>: This is the function that fills the dataset for the real test</li><li class="listitem"><code class="literal">addSoundEvent()</code>: This is the function that executes the test</li></ul></div><p>As you can see, the function that fills the dataset for a given <code class="literal">xxx()</code> function must be named <code class="literal">xxx_data()</code>. Let's see the implementation of <code class="literal">addSoundEvent_data()</code>:</p><pre class="programlisting">void TestTrack::addSoundEvent_data() &#13;
{ &#13;
    QTest::addColumn&lt;int&gt;("trackState"); &#13;
    QTest::addColumn&lt;int&gt;("soundEventCount"); &#13;
 &#13;
    QTest::newRow("STOPPED")  &#13;
                &lt;&lt; static_cast&lt;int&gt;(Track::State::STOPPED)  &#13;
                &lt;&lt; 0; &#13;
    QTest::newRow("PLAYING")  &#13;
                &lt;&lt; static_cast&lt;int&gt;(Track::State::PLAYING)  &#13;
                &lt;&lt; 0; &#13;
    QTest::newRow("RECORDING")  &#13;
                &lt;&lt; static_cast&lt;int&gt;(Track::State::RECORDING)  &#13;
                &lt;&lt; 1; &#13;
} &#13;
</pre><p>As you can see, a dataset is constructed like a table. We start by defining the structure of the table with the <code class="literal">trackState</code> and <code class="literal">soundEventCount</code> columns. Note that <code class="literal">QTest::addColumn</code> relies on templating to know the type of the variable (<code class="literal">int</code> in both cases).</p><p>After that, a row is appended to the table with the <code class="literal">QTest::newRow()</code> function, with the name of the test passed as a parameter. The <code class="literal">QTest::newRow</code> syntax supports the <code class="literal">&lt;&lt;</code> operator, making it very easy to pack all the data for a given row.</p><p>Note that each row added to the dataset corresponds to an execution of the <code class="literal">addSoundEvent()</code> function in which the data of the row will be available.</p><p>We can now turn our attention to <code class="literal">addSoundEvent()</code>:</p><pre class="programlisting">void TestTrack::addSoundEvent() &#13;
{ &#13;
    QFETCH(int, trackState); &#13;
    QFETCH(int, soundEventCount); &#13;
 &#13;
    Track track; &#13;
    switch (static_cast&lt;Track::State&gt;(trackState)) { &#13;
        case Track::State::STOPPED: &#13;
            track.stop(); &#13;
            break; &#13;
        case Track::State::PLAYING: &#13;
            track.play(); &#13;
            break; &#13;
        case Track::State::RECORDING: &#13;
            track.record(); &#13;
            break; &#13;
        default: &#13;
            break; &#13;
    } &#13;
 &#13;
    track.addSoundEvent(0); &#13;
    track.stop(); &#13;
 &#13;
    QCOMPARE(track.soundEvents().size(),  &#13;
             static_cast&lt;size_t&gt;(soundEventCount)); &#13;
} &#13;
</pre><p>Because <code class="literal">addSoundEvent()</code> is executed by QTest and is fed with the dataset data, we can safely access the current row of the dataset like we would do with a cursor on a database. The <code class="literal">QFETCH(int, trackState)</code> is a helpful macro that does two things:</p><div><ul class="itemizedlist"><li class="listitem">Declares an <code class="literal">int</code> variable named <code class="literal">trackState</code></li><li class="listitem">Fetches the current column index data of the dataset and stores its content in <code class="literal">trackState</code></li></ul></div><p>The same principle is applied to <code class="literal">soundEventCount</code>. Now that we have our desired track state and the expected sound events count, we can proceed to the real test:</p><div><ol class="orderedlist arabic"><li class="listitem">Put the track in the proper state according to <code class="literal">trackState</code>. Remember that the <code class="literal">Track::setState()</code> function is private, because the <code class="literal">Track</code> keyword handles the <code class="literal">trackState</code> variable alone, based on the caller instruction (<code class="literal">stop()</code>, <code class="literal">play()</code>, <code class="literal">record()</code>).</li><li class="listitem">Try to add a <code class="literal">SoundEvent</code> to track.</li><li class="listitem">Stop the track.</li><li class="listitem">Compare the number of <code class="literal">SoundEvents</code> in track to what is expected in <code class="literal">soundEventCount</code>.</li></ol><div></div><p>Do not forget to add the <code class="literal">TestTrack</code> class in <code class="literal">main.cpp</code>:</p><pre class="programlisting">#include "TestJsonSerializer.h" &#13;
#include "TestTrack.h" &#13;
 &#13;
... &#13;
 &#13;
int main(int argc, char *argv[]) &#13;
{ &#13;
    ... &#13;
    map&lt;QString, unique_ptr&lt;QObject&gt;&gt; tests; &#13;
    tests.emplace("jsonserializer",  &#13;
                  make_unique&lt;TestJsonSerializer&gt;()); &#13;
    tests.emplace("track",  &#13;
                  make_unique&lt;TestTrack&gt;()); &#13;
    ... &#13;
} &#13;
</pre><p>You can now run the tests and see the three tests of <code class="literal">addSoundEvent()</code> output their result in the console:</p><pre class="programlisting">
<strong>PASS   : TestTrack::addSoundEvent(STOPPED)</strong>
<strong>PASS   : TestTrack::addSoundEvent(PLAYING)</strong>
<strong>PASS   : TestTrack::addSoundEvent(RECORDING)</strong>
</pre><p>Datasets make the writing of tests less dull, by factorizing variations of data for a single test.</p><p>You can also run a single test for a specific entry of a dataset using the command line:</p><pre class="programlisting">
<strong>$ ./drum-machine-test &lt;testfunction&gt;:&lt;dataset entry&gt;</strong>
</pre><p>Let's say we want to execute the test function <code class="literal">addSoundEvent()</code> from <code class="literal">TestTrack</code> with only the <code class="literal">RECORDING</code> state. Here is the command line to run:</p><pre class="programlisting">
<strong>$ ./drum-machine-test -select track addSoundEvent:RECORDING</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec111"/>Benchmarking your code</h1></div></div></div><p>Qt Test also provides a very easy to use semantic to benchmark the execution speed of your code. To see it in action, we will benchmark the time it takes to save a <code class="literal">Track</code> in the JSON format. Depending on the track length (the number of <code class="literal">SoundEvents</code>), the serialization should take more or less time.</p><p>Of course, it is more interesting to benchmark this feature with different track lengths and see if the time saving is linear. Datasets come to the rescue! It is not only useful to run the same function with expected inputs and outputs, but also to run the same function with different parameters.</p><p>We will start by creating the dataset function in <code class="literal">TestJsonSerializer</code>:</p><pre class="programlisting">class TestJsonSerializer : public QObject &#13;
{ &#13;
    ... &#13;
 &#13;
private slots: &#13;
    void cleanup(); &#13;
    void saveDummy(); &#13;
    void loadDummy(); &#13;
 &#13;
    void saveTrack_data(); &#13;
    ... &#13;
}; &#13;
 &#13;
void TestJsonSerializer::saveTrack_data() &#13;
{ &#13;
    QTest::addColumn&lt;int&gt;("soundEventCount"); &#13;
 &#13;
    QTest::newRow("1") &lt;&lt; 1; &#13;
    QTest::newRow("100") &lt;&lt; 100; &#13;
    QTest::newRow("1000") &lt;&lt; 1000; &#13;
} &#13;
</pre><p>The <code class="literal">saveTrack_data()</code> function simply stores the number of <code class="literal">SoundEvent</code> to be added to a <code class="literal">Track</code> class before it is saved. The <code class="literal">"1"</code>, <code class="literal">"100",</code> and <code class="literal">"1000"</code> strings are here to have a clear label in the test execution output. These strings will be displayed in each execution of <code class="literal">saveTrack()</code>. Feel free to tweak these numbers!</p><p>Now for the real test with the benchmark call:</p><pre class="programlisting">class TestJsonSerializer : public QObject &#13;
{ &#13;
    ... &#13;
    void saveTrack_data(); &#13;
    void saveTrack(); &#13;
    ... &#13;
}; &#13;
 &#13;
void TestJsonSerializer::saveTrack() &#13;
{ &#13;
    QFETCH(int, soundEventCount); &#13;
    Track track; &#13;
    track.record(); &#13;
    for (int i = 0; i &lt; soundEventCount; ++i) { &#13;
        track.addSoundEvent(i % 4); &#13;
    } &#13;
    track.stop(); &#13;
 &#13;
    QBENCHMARK { &#13;
        mSerializer.save(track, FILENAME); &#13;
    } &#13;
} &#13;
</pre><p>The <code class="literal">saveTrack()</code> function starts by fetching the <code class="literal">soundEventCount</code> column from its dataset. After that, it adds the correct number of <code class="literal">soundEvent</code> (with the proper <code class="literal">record()</code> state!) and finally benchmarks the serialization in the JSON format.</p><p>You can see that the benchmark itself is simply a macro that looks like this:</p><pre class="programlisting">QBENCHMARK { &#13;
    // instructions to benchmark &#13;
} &#13;
</pre><p>The instructions enclosed in the <code class="literal">QBENCHMARK</code> macro will be measured automatically. If you execute the test with the updated <code class="literal">TestJsonSerializer</code> class, you should see an output similar to this:</p><pre class="programlisting">PASS   : TestJsonSerializer::saveTrack(1) &#13;
RESULT : TestJsonSerializer::saveTrack():"1": &#13;
     0.041 msecs per iteration (total: 84, iterations: 2048) &#13;
PASS   : TestJsonSerializer::saveTrack(100) &#13;
RESULT : TestJsonSerializer::saveTrack():"100": &#13;
     0.23 msecs per iteration (total: 59, iterations: 256) &#13;
PASS   : TestJsonSerializer::saveTrack(1000) &#13;
RESULT : TestJsonSerializer::saveTrack():"1000": &#13;
     2.0 msecs per iteration (total: 66, iterations: 32) &#13;
</pre><p>As you can see, the <code class="literal">QBENCHMARK</code> macro makes Qt Test output very interesting data. To save a <code class="literal">Track</code> class with a single <code class="literal">SoundEvent</code>, it took 0.041 milliseconds. Qt Test repeated this test 2048 times and it took a total of 84 milliseconds.</p><p>The power of the <code class="literal">QBENCHMARK</code> macro starts to be visible in the following test. Here, the <code class="literal">saveTrack()</code> function tried to save a <code class="literal">Track</code> class with 100 <code class="literal">SoundEvents</code>. It took 0.23 milliseconds to do it and it repeated the instruction 256 times. This shows you that the Qt Test benchmark automatically adjusts the number of iterations based on the average time a single iteration takes.</p><p>The <code class="literal">QBENCHMARK</code> macro has this behavior because a metric tends to be more accurate if it is repeated multiple times (to avoid possible external noise).</p><div><h3 class="title"><a id="tip52"/>Tip</h3><p>If you want your test to be benchmarked without multiple iterations, use <code class="literal">QBENCHMARK_ONCE</code>.</p></div><p>If you execute the test using the command line, you can provide additional metrics to <code class="literal">QBENCHMARK</code>. Here is the table recapitulating the available options:</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><strong>Name</strong></p>
</td><td>
<p><strong>Command-line argument</strong></p>
</td><td>
<p><strong>Availability</strong></p>
</td></tr><tr><td>
<p>Walltime</p>
</td><td>
<p>(default)</p>
</td><td>
<p>All platforms</p>
</td></tr><tr><td>
<p>CPU tick counter</p>
</td><td>
<p><code class="literal">-tickcounter</code></p>
</td><td>
<p>Windows, OS X, Linux, many UNIX-like systems.</p>
</td></tr><tr><td>
<p>Event Counter</p>
</td><td>
<p><code class="literal">-eventcounter</code></p>
</td><td>
<p>All platforms</p>
</td></tr><tr><td>
<p>Valgrind Callgrind</p>
</td><td>
<p><code class="literal">-callgrind</code></p>
</td><td>
<p>Linux (if installed)</p>
</td></tr><tr><td>
<p>Linux Perf</p>
</td><td>
<p><code class="literal">-perf</code></p>
</td><td>
<p>Linux</p>
</td></tr></tbody></table></div><p>Each one of these options will replace the selected backend used to measure the execution time of the benchmarked code. For example, if you run <code class="literal">drum-machine-test</code> with the <code class="literal">-tickcounter</code> argument:</p><pre class="programlisting">
<strong>$ ./drum-machine-test -tickcounter</strong>
<strong>...</strong>
<strong>RESULT : TestJsonSerializer::saveTrack():"1":</strong>
<strong>     88,062 CPU cycles per iteration (total: 88,062, iterations: 1)</strong>
<strong>PASS   : TestJsonSerializer::saveTrack(100)</strong>
<strong>RESULT : TestJsonSerializer::saveTrack():"100":</strong>
<strong>     868,706 CPU cycles per iteration (total: 868,706, iterations: 1)</strong>
<strong>PASS   : TestJsonSerializer::saveTrack(1000)</strong>
<strong>RESULT : TestJsonSerializer::saveTrack():"1000":</strong>
<strong>     7,839,871 CPU cycles per iteration (total: 7,839,871, iterations: 1)</strong>
<strong>...</strong>
</pre><p>You can see that the wall time, measured in milliseconds, has been replaced by the number of CPU cycles completed for each iteration.</p><p>Another interesting option is <code class="literal">-eventcounter</code>, which measures the numbers that were received by the event loop before they are sent to their corresponding target. This could be an interesting way of checking that your code emits the proper number of signals.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec112"/>Testing your GUI</h1></div></div></div><p>It is now time to see how you can test your GUI using the Qt Test API. The <code class="literal">QTest</code> class offers several functions to simulate keys and mouse events.</p><p>To demonstrate it, we will stay with the notion of testing a <code class="literal">Track</code> state, but on an upper level. Rather than testing the <code class="literal">Track</code> state itself, we will check that the UI state of the <code class="literal">drum-machine</code> application is properly updated when the <code class="literal">Track</code> state is changed. Namely, the control buttons (play, stop, record) should be in a specific state when a recording is started.</p><p>Start by creating a <code class="literal">TestGui</code> class in the <code class="literal">drum-machine-test</code> project. Do not forget to add the <code class="literal">TestGui</code> class in the <code class="literal">tests</code> map of <code class="literal">main.cpp</code>. As usual, make it inherit <code class="literal">QObject</code> and update <code class="literal">TestGui.h</code> like so:</p><pre class="programlisting">#include &lt;QTest&gt; &#13;
 &#13;
#include "MainWindow.h" &#13;
 &#13;
class TestGui : public QObject &#13;
{ &#13;
    Q_OBJECT &#13;
public: &#13;
    TestGui(QObject* parent = 0); &#13;
 &#13;
private: &#13;
    MainWindow mMainWindow; &#13;
}; &#13;
</pre><p>In this header, we have a member, <code class="literal">mMainWindow</code>, which is an instance of the <code class="literal">MainWindow</code> keyword from the <code class="literal">drum-machine</code> project. Throughout the tests of <code class="literal">TestGui</code>, a single <code class="literal">MainWindow</code> will be used, in which we will inject events and check how it reacts.</p><p>Let's switch to the <code class="literal">TestGui</code> constructor:</p><pre class="programlisting">#include &lt;QtTest/QtTest&gt; &#13;
 &#13;
TestGui::TestGui(QObject* parent) : &#13;
    QObject(parent), &#13;
    mMainWindow() &#13;
{ &#13;
    QTestEventLoop::instance().enterLoop(1); &#13;
} &#13;
</pre><p>The constructor initializes the <code class="literal">mMainWindow</code> variable. Notice that <code class="literal">mMainWindow</code> is never shown (using <code class="literal">mMainWindow.show()</code>). We do not need to display it, we solely want to test its states.</p><p>Here, we use a rather obscure function call (<code class="literal">QTestEventLoop</code> is not documented at all) to force the event loop to be started after 1 second.</p><p>The reason why we have to do this lies in the <code class="literal">QSoundEffect</code> class. The <code class="literal">QSoundEffect</code> class is initialized when the <code class="literal">QSoundEffect::setSource()</code> function is called (in <code class="literal">MainWindow</code>, this is done at the initialization of the <code class="literal">SoundEffectWidgets</code>). If we omit the explicit <code class="literal">enterLoop()</code> call, the <code class="literal">drum-machine-test</code> execution will crash with a segmentation fault.</p><p>It seems that the event loop has to be explicitly entered to let the <code class="literal">QSoundEffect</code> class properly complete its initialization. We found this undocumented workaround by studying the Qt unit tests of the <code class="literal">QSoundEffect</code> class.</p><p>Now for the real GUI test! To test the control buttons, update <code class="literal">TestGui</code>:</p><pre class="programlisting">// In TestGui.h &#13;
class TestGui : public QObject &#13;
{ &#13;
    ... &#13;
private slots: &#13;
    void controlButtonState(); &#13;
    ... &#13;
}; &#13;
 &#13;
// In TestGui.cpp &#13;
#include &lt;QtTest/QtTest&gt; &#13;
#include &lt;QPushButton&gt; &#13;
... &#13;
void TestGui::controlButtonState() &#13;
{ &#13;
    QPushButton* stopButton =  &#13;
        mMainWindow.findChild&lt;QPushButton*&gt;("stopButton"); &#13;
    QPushButton* playButton =  &#13;
        mMainWindow.findChild&lt;QPushButton*&gt;("playButton"); &#13;
    QPushButton* recordButton =  &#13;
        mMainWindow.findChild&lt;QPushButton*&gt;("recordButton"); &#13;
 &#13;
    QTest::mouseClick(recordButton, Qt::LeftButton); &#13;
 &#13;
    QCOMPARE(stopButton-&gt;isEnabled(), true); &#13;
    QCOMPARE(playButton-&gt;isEnabled(), false); &#13;
    QCOMPARE(recordButton-&gt;isEnabled(), false); &#13;
} &#13;
</pre><p>In the <code class="literal">controlButtonState()</code> function, we start by retrieving our buttons by using the handy <code class="literal">mMainWindow.findChild()</code> function. This function is available in <code class="literal">QObject</code>, and the passed name corresponds to the <code class="literal">objectName</code> variable we used for each button in Qt Designer when we created <code class="literal">MainWindow.ui</code>.</p><p>Once we retrieve all the buttons, we inject a mouse click event using the <code class="literal">QTest::mouseClick()</code> function. It takes a <code class="literal">QWidget*</code> parameter as a target and the button that should be clicked. You can even pass keyboard modifiers (control, shift, and so on) and a possible click delay in milliseconds.</p><p>Once the <code class="literal">recordButton</code> has been clicked, we test the states of all the control buttons to make sure that they are in the desired enabled state.</p><div><h3 class="title"><a id="note53"/>Note</h3><p>This function can be easily extended to test all the states (<code class="literal">PLAYING</code>, <code class="literal">STOPPED</code>, <code class="literal">RECORDING</code>) with a dataset where the input is the desired state and the outputs are the expected buttons states.</p></div><p>The <code class="literal">QTest</code> class offers many useful functions to inject events, including:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">keyEvent()</code>: This function is used to simulate a key event</li><li class="listitem"><code class="literal">keyPress()</code>: This function is used to simulate a key press event</li><li class="listitem"><code class="literal">keyRelease()</code>: This function is used to simulate a key release event</li><li class="listitem"><code class="literal">mouseClick()</code>: This function is used to simulate a key click event</li><li class="listitem"><code class="literal">mouseDClick()</code>: This function is used to simulate a mouse double click event</li><li class="listitem"><code class="literal">mouseMove()</code>: This function is used to simulate a mouse move event</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec113"/>Spying on your application with QSignalSpy</h1></div></div></div><p>The last part we will cover in the Qt Test framework is the ability to spy on signals with <code class="literal">QSignalSpy</code>. This class allows you to do introspection of the emitted signal of any <code class="literal">QObject</code>.</p><p>Let's see it in action with <code class="literal">SoundEffectWidget</code>. We will test that when the <code class="literal">SoundEffectWidget::play()</code> function is called, the <code class="literal">soundPlayed</code> signal is emitted with the correct <code class="literal">soundId</code> parameter.</p><p>Here is the <code class="literal">playSound()</code> function of <code class="literal">TestGui</code>:</p><pre class="programlisting">#include &lt;QTest&gt; &#13;
 &#13;
#include "MainWindow.h" &#13;
 &#13;
// In TestGui.h &#13;
class TestGui : public QObject &#13;
{ &#13;
    ... &#13;
    void controlButtonState(); &#13;
    void playSound(); &#13;
    ... &#13;
}; &#13;
 &#13;
// In TestGui.cpp &#13;
#include &lt;QPushButton&gt; &#13;
#include &lt;QtTest/QtTest&gt; &#13;
#include "SoundEffectWidget.h" &#13;
... &#13;
void TestGui::playSound() &#13;
{ &#13;
    SoundEffectWidget widget; &#13;
    QSignalSpy spy(&amp;widget, &amp;SoundEffectWidget::soundPlayed); &#13;
    widget.setId(2); &#13;
    widget.play(); &#13;
 &#13;
    QCOMPARE(spy.count(), 1); &#13;
    QList&lt;QVariant&gt; arguments = spy.takeFirst(); &#13;
    QCOMPARE(arguments.at(0).toInt(), 2); &#13;
} &#13;
</pre><p>We start by initializing a <code class="literal">SoundEffectWidget</code> widget and a <code class="literal">QSignalSpy</code> class. The <code class="literal">spy</code> class's constructor takes the pointer to the object to spy and the pointer to the member function of the signal to be watched. Here, we want to check the <code class="literal">SoundEffectWidget::soundPlayed()</code> signal.</p><p>Right after, <code class="literal">widget</code> is configured with an arbitrary <code class="literal">soundId</code> (<code class="literal">2</code>) and <code class="literal">widget.play()</code> is called. This is where it gets interesting:<code class="literal">spy</code> stores the signal's emitted parameters in a <code class="literal">QVariantList</code>. Each time <code class="literal">soundPlayed()</code> is emitted, a new <code class="literal">QVariantList</code> is created in <code class="literal">spy</code>, which contains the emitted parameters.</p><p>The first step is to check that the signal is emitted only once, by comparing <code class="literal">spy.count()</code> to <code class="literal">1</code>. Just after that, we store the parameters of this signal in <code class="literal">arguments</code> and check that it has the value <code class="literal">2</code>, the initial <code class="literal">soundId</code> that <code class="literal">widget</code> was configured with.</p><p>As you can see, <code class="literal">QSignalSpy</code> is simple to use; you can create as many as you need for each signal you want to spy on.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec114"/>Summary</h1></div></div></div><p>The Qt Test module gracefully helps us to easily create a test application. You learned to organize your project with a standalone test application. You are able to compare and verify a specific value in your simple tests. For your complex tests, you could use the datasets. You implemented a simple benchmark, recording the time or the CPU ticks required to execute a function. You have simulated GUI events and spy Qt signals to ensure that your application works well.</p><p>Your application is created and your unit tests indicates a PASS status. In the next chapter, we will learn how to deploy your application.</p></div></body></html>