<html><head></head><body>
<div><h1 class="chapterNumber">7</h1>
<h1 class="chapterTitle" id="_idParaDest-112">Strengthening Firmware – Practical C++ Error Handling Methods</h1>
<p class="normal">To ensure the proper functioning of firmware, we must handle errors from vendor-specific code, libraries that we are using in a project, and our own code. Error codes are standard error-handling mechanisms in C, and they are also used in C++. However, C++ provides us with other tools, most notably exceptions that are often avoided in embedded projects due to the large binary footprint and non-determinism. Still, we will discuss exceptions in C++ in this chapter to show their benefits in the error-handling process.</p>
<p class="normal">Besides exceptions, C++ offers more options for error handling that will also be discussed in this chapter. The goal of this chapter is to understand potential issues with error codes and see how to mitigate them in C++.</p>
<p class="normal">In this chapter, we’re going to cover the following main topics: </p>
<ul>
<li class="bulletList">Error codes and asserts</li>
<li class="bulletList">Exceptions</li>
<li class="bulletList"><code class="inlineCode">std:: optional</code> and <code class="inlineCode">std::expected</code></li>
</ul>
<h1 class="heading-1" id="_idParaDest-113">Technical requirements</h1>
<p class="normal">To get the most out of this chapter, I strongly recommend using Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) as you read through the examples. Select GCC as your compiler and target x86 architecture. This will allow you to see standard output (stdio) results and better observe the code’s behavior. As we are using modern C++ features make sure to select C++23 standard, by adding <code class="inlineCode">-std=c++23</code> in compiler options box. </p>
<p class="normal">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly. The examples are available at GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter07">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter07</a>).</p>
<h1 class="heading-1" id="_idParaDest-114">Error codes and asserts</h1>
<p class="normal"><strong class="keyWord">Error codes</strong> are a common way of reporting and handling errors in C. They are also still used in C++. A function that <a id="_idIndexMarker379"/>fails reports an error through enumerated codes that are checked by a caller and handled appropriately. Let us analyze how error codes work from both the caller and the callee perspective.</p>
<p class="normal">A function that returns an error must have a list of errors that are exposed to callers. This list is maintained through a software life cycle, and it can be subject to changes. Enumerated error codes can be added, removed, or modified. A caller must be aware of the error codes that the callee is returning, and it needs to handle them. Or, if it doesn’t know how to handle an error, it should propagate it further within a call stack.</p>
<p class="normal">Let’s observe a simple example of a function that returns an error and analyze the implications this has for the code using this function:</p>
<pre class="programlisting code"><code class="hljs-code">enum class error {
    Ok,
    Error1,
    Error2,
    Unknown
};
error h() {
    return error::Error1;
}
error g() {
    auto err = h();
    if(err!=error::Ok) {
        if(err == error::Error1) {
       // handle error directly
        }
        else if(err == error::Error2) {
            // propagate this error
return err;
        }
        else {
            // unknown error
return error::Unknown;
        }
    }
    return error::Ok;
}
void f() {
    auto err = g();
    if(err==error::Ok) {
        printf("Succes\r\n");
    }
    else {
        // handle errors
    }
}
</code></pre>
<p class="normal">In the <a id="_idIndexMarker380"/>preceding example, the <code class="inlineCode">h</code> function returns an error of <code class="inlineCode">enum class error</code>. The <code class="inlineCode">g</code> function calls the <code class="inlineCode">h</code> function and executes the following steps:</p>
<ol>
<li class="numberedList" value="1">Checks if <code class="inlineCode">h</code> returned an error that is different from <code class="inlineCode">error::Ok</code>. This indicates that the <code class="inlineCode">h</code> function didn’t perform its task and there is an error that should be handled.</li>
<li class="numberedList">If <code class="inlineCode">h</code> returned an error, checks whether it is <code class="inlineCode">error::Error1</code>. In this case, <code class="inlineCode">g</code> knows how to handle this error and it handles it.</li>
<li class="numberedList">If <code class="inlineCode">h</code> returned <code class="inlineCode">error::Error2</code>, <code class="inlineCode">g</code> is not capable of handling it, and it forwards it up the call stack.</li>
<li class="numberedList">Returns <code class="inlineCode">error::Ok</code> to indicate up the call stack that everything went fine.</li>
</ol>
<p class="normal">Function <code class="inlineCode">g</code> is called by <code class="inlineCode">f</code>, and <code class="inlineCode">f</code> also needs to be aware of errors defined in <code class="inlineCode">enum class error</code>. It should handle them or pass them up the stack.</p>
<p class="normal">Error codes rely on design contracts. The caller must check if the callee returned an error, and if it did, it needs to handle it or pass it up the call stack. Now, we can identify several potential problems with this simple approach:</p>
<ul>
<li class="bulletList">We cannot enforce error handling by a caller. It can just discard the return value.</li>
<li class="bulletList">The caller can forget to handle some of the error cases.</li>
<li class="bulletList">The caller can forget to pass the error up the call stack.</li>
</ul>
<p class="normal">These are serious design flaws that put an extra burden on code development. There is no escape hatch in case we forget to handle an error somewhere. The program stays in an unknown state and this potentially leads to unwanted behavior.</p>
<p class="normal">We can address the first concern using the <code class="inlineCode">nodiscard</code> attribute. It can be used with a function declaration or enumeration declaration. In our case, we can use it with an <code class="inlineCode">enum class</code> <code class="inlineCode">error</code> declaration as follows:</p>
<pre class="programlisting code"><code class="hljs-code">enum class [[nodiscard]] error {
    Ok,
    Error1,
    Error2,
    Unknown
};
</code></pre>
<p class="normal">When a function <a id="_idIndexMarker381"/>returning the <code class="inlineCode">enum class</code> error is called, and the return value is discarded, the compiler is encouraged to raise a warning. If we call the <code class="inlineCode">g</code> or <code class="inlineCode">h</code> function from our example, GCC will raise a warning similar to this one:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;source&gt;:48:6: warning: ignoring returned value of type 'error', declared with attribute 'nodiscard' [-Wunused-result]
</code></pre>
<p class="normal">If we set up the compiler to treat all warnings as errors, this would break the compilation process and force us to use the return value in code. Even though the <code class="inlineCode">nodiscard</code> attribute is useful and should be used for similar use cases, it is not a complete solution to our problem. It will enforce usage of the return value, but the caller may still fail to check the error code for all possible cases and address it properly.</p>
<p class="normal">Almost every application has some types of errors that are unrecoverable and the only thing it makes sense to do is to log them, display them to a user (if possible), and terminate the program, as there is no sense in proceeding with such a program state. For these types of errors, we can use a global error handler, as they are too important to be left open in the wild and potentially not handled by a caller.</p>
<h2 class="heading-2" id="_idParaDest-115">Global error handlers</h2>
<p class="normal"><strong class="keyWord">Global error handlers</strong> can be implemented as free functions. They are used system-wide to address errors <a id="_idIndexMarker382"/>that are unrecoverable and when it is necessary to stop the execution of firmware due to the severity of an error.</p>
<p class="normal">Let’s take a look at an example of firmware using an accelerometer. If there are any issues in I<sup class="superscript">2</sup>C communication with the accelerometer, it doesn’t make sense to proceed further with code execution – the firmware will display a message to the user and terminate:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
#include &lt;cstdlib&gt;
int i2c_read(uint8_t *data, size_t len) {
    return 0;
}
namespace error {
    struct i2c_failed{};
    struct spi_failed{};
    void handler(i2c_failed err) {
        printf("I2C error!\r\n");
        exit(1);
    }
    void handler(spi_failed err) {
        printf("SPI error!\r\n");
        exit(1);
    }
};
class accelerometer {
public:
    struct data {
        int16_t x;
        int16_t y;
        int16_t z;
    };
    data get_data() {
        uint8_t buff[6];
        if(i2c_read(buff, 6) != 6) {
            error::handler(error::i2c_failed{});
        }
        return data{};
    }
};
int main () {
    accelerometer accel;
    auto data = accel.get_data();
    return 0;
}
</code></pre>
<p class="normal">In the <a id="_idIndexMarker383"/>preceding example, we have an <code class="inlineCode">accelerometer</code> class with the <code class="inlineCode">get_data</code> method, which uses the <code class="inlineCode">i2c_read</code> function from the vendor-specific HAL in C (let us pretend this is the case).</p>
<p class="normal">The <code class="inlineCode">i2c_read</code> function returns the number of read bytes. In our example, the return value is stubbed to <code class="inlineCode">0</code> so we can simulate the erroneous behavior of the accelerometer (or the I<sup class="superscript">2</sup>C bus). In case <code class="inlineCode">i2c_read</code> returns a number different from the requested number of bytes, <code class="inlineCode">get_data</code> will call <code class="inlineCode">error::handler</code>.</p>
<p class="normal">We implemented an error handler using a tag-dispatching mechanism. We are overloading the <code class="inlineCode">error::handler</code> function with so-called tags, or empty types. In our example, we have two tags, <code class="inlineCode">i2c_failed</code> and <code class="inlineCode">spi_failed</code>, and two overloaded error handlers. Tag dispatching has a couple <a id="_idIndexMarker384"/>of advantages over defining error codes with <code class="inlineCode">enum</code>:</p>
<ul>
<li class="bulletList">We need to overload error handlers for every tag that is used in code. Error handlers are implemented individually for every error type. This adds to the readability of code.</li>
<li class="bulletList">In case we make a call to an error handler that is not overloaded, the compilation will fail, forcing us to implement it.</li>
</ul>
<p class="normal">In our example, the error handler will print a message using the <code class="inlineCode">printf</code> function and make a call to the <code class="inlineCode">exit</code> function, effectively terminating the program. In real-world situations, how we handle errors depends on the application. For example, for a medical device, if critical operations become unsafe after an error, we would first attempt to recover from the error. </p>
<p class="normal">If recovery failed, the system would enter a critical error state, alert medical personnel, and gracefully terminate the treatment operation.</p>
<p class="normal">An error on the I<sup class="superscript">2</sup>C bus or, more generally, failed communication with external devices must be handled appropriately through robust error-handling mechanisms.</p>
<p class="normal">On the other hand, there are conditions that indicate programming mistakes – situations that should never occur if the code is correct. These include violations of preconditions, such as input parameters being out of expected boundaries due to logic errors in the code. Proceeding under such circumstances could lead to undefined behavior or system instability. To detect these programming errors during development, we use asserts.</p>
<h2 class="heading-2" id="_idParaDest-116">Asserts</h2>
<p class="normal">Asserts are primarily used during development to detect programming mistakes by verifying that certain <a id="_idIndexMarker385"/>conditions hold true at specific points in the code. They help identify logical errors and incorrect assumptions by halting execution when an unexpected condition occurs. A macro assert is defined in <code class="inlineCode">&lt;cassert&gt;</code> in the standard library. It is used to check a logical expression, and in case the logical expression is false, it prints diagnostic information and calls <code class="inlineCode">std::abort</code>, effectively terminating the program.</p>
<p class="normal">To better understand asserts, and how to use them, let us take a look at the following code example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cassert&gt;
#include &lt;cstdint&gt;
enum class option : std::uint8_t {
    Option1 = 0,
    Option2,
    Option3,
    Last
};
option uint8_to_option(uint8_t num) {
    assert(num &lt; static_cast&lt;uint8_t&gt;(option::Last));
    return static_cast&lt;option&gt;(num);
}
int main() {
    const option opt = uint8_to_option(3);
    return 0;
}
</code></pre>
<p class="normal">In the preceding example, we have defined the <code class="inlineCode">option</code> enum class with <code class="inlineCode">uint8_t</code> as an underlying type. We will use it to allow users to select an option over a network interface and we want to <a id="_idIndexMarker386"/>make sure that the conversion from <code class="inlineCode">uint8_t</code> to the <code class="inlineCode">option</code> enum is always correct. The <code class="inlineCode">uint8_to_option</code> function will assert if the received <code class="inlineCode">uint8_t</code> argument is not smaller than <code class="inlineCode">option::Last</code>. </p>
<p class="normal">In the example, we called <code class="inlineCode">uint8_to_option</code> with argument <code class="inlineCode">3</code>, which is not smaller than <code class="inlineCode">option::Last</code>, meaning that the assert macro will print the following diagnostic information and make a call to <code class="inlineCode">std::abort</code> to terminate the program:</p>
<pre class="programlisting con"><code class="hljs-con">assertion "num &lt; static_cast&lt;uint8_t&gt;(option::Last)" failed: file "/home/amar/projects/Cpp-in-Embedded Systems/Chapter07/error_handling/app/src/main.cpp", line 21, function: option uint8_to_option(uint8_t)
</code></pre>
<p class="normal">Now, this is quite a lengthy debug statement. Let’s take a look at the <code class="inlineCode">assert</code> macro definition:</p>
<pre class="programlisting code"><code class="hljs-code">#define assert(expr)                             \
     (static_cast &lt;bool&gt; (expr)                  \
      ? void (0)                                 \
      : __assert_fail (#expr, 
__ASSERT_FILE,            \
                       __ASSERT_LINE,            \
                       __ASSERT_FUNCTION))
</code></pre>
<p class="normal">We see that the expression is cast to a <code class="inlineCode">bool</code> type and that the ternary operator does nothing if the expression is true, or it makes a call to the <code class="inlineCode">__assert_fail</code> function if the expression is false. The <code class="inlineCode">assert</code> macro passes the expression as a string literal, the filename as a string literal, the line number, and also a function name as a string literal. All these string literals must be stored in the binary, taking up precious memory.</p>
<p class="normal">Asserts can <a id="_idIndexMarker387"/>be disabled by defining the <code class="inlineCode">NDEBUG</code> macro before including <code class="inlineCode">&lt;cassert&gt;</code> as in the following lines:</p>
<pre class="programlisting code"><code class="hljs-code">#define NDEBUG
#include &lt;cassert&gt;
</code></pre>
<p class="normal">We can also define <code class="inlineCode">NDEBUG</code> using the build system. The <code class="inlineCode">assert</code> macro will do nothing if <code class="inlineCode">NDEBUG</code> is defined before <code class="inlineCode">&lt;cassert&gt;</code> is included. This option is left to be used in case we want to disable asserts, as they are most commonly used in debug builds, and disabled in production builds. They should be disabled before the safety-critical software validation.</p>
<p class="normal">The <code class="inlineCode">assert</code> macro, as implemented in the standard library, is not suitable for embedded systems as it includes the filename, function name, and <code class="inlineCode">assert</code> expression as string literals, which end up stored in the flash of the embedded target. Moreover, asserts are mostly intended to be used during debugging, and they are often disabled in production builds. Still, there is a benefit of asserts enabled in production builds, as they can provide valuable insights for postmortem debugging if they are implemented to log data when the expression is evaluated as <code class="inlineCode">false</code>.</p>
<p class="normal">We will examine an alternative approach to logging information using asserts. As we have already concluded, the default assert macro implementation is not well suited for embedded targets, even though it contains useful information for debugging: filename, function name, and line number. Instead of a lengthy string describing an exact location of the assert macro line in our code, we can simply log a program counter and use the map file and <code class="inlineCode">addr2line</code> tool to convert the address to the exact line. We can see a simple macro definition and a helper function to implement this in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">void log_pc_and_halt(std::uint32_t pc) {
    printf("Assert at 0x%08lX\r\n", pc);
    while(true) {}
}
#define light_assert(expr)         \
        (static_cast&lt;bool&gt; (expr)  \
        ? void (0)                 \
        : log_pc_and_halt(hal::get_pc())    \
        )
</code></pre>
<p class="normal">We have defined a macro named <code class="inlineCode">light_assert</code> that, instead of <code class="inlineCode">__assert_failed</code>, calling <code class="inlineCode">log_pc_and_halt</code>. It is passing the return value from <code class="inlineCode">hal::get_pc</code> as an argument to <code class="inlineCode">log_pc_and_halt</code>. To see this code in action, you can take a look at the example in the <code class="inlineCode">Chapter07/error_handling</code> project.</p>
<p class="normal">The project for this chapter is configured so that you can configure it to use different main C++ files and <a id="_idIndexMarker388"/>configure which one is going to be used with CMake. Let us start our Docker container using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ docker start dev_env
$ docker exec -it dev_env /bin/bash
</code></pre>
<p class="normal">This should get us in the Docker terminal. Run <code class="inlineCode">ls –l</code> to make sure that the <code class="inlineCode">Cpp-in-Embedded-Systems</code> repo is cloned. If not, clone it using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">$ git clone https://github.com/PacktPublishing/Cpp-in-Embedded-Systems.git
</code></pre>
<p class="normal">Start Visual Studio Code, attach it to the running container, and open <code class="inlineCode">Chapter07/error_handling project</code> as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a> and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cd Chapter07/error_handling
$ cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_assert.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">The preceding commands will build the firmware using the <code class="inlineCode">app/src/main_assert.cpp</code> file and run it in Renode simulator. You should see similar output to this in the terminal:</p>
<pre class="programlisting con"><code class="hljs-con">14:11:06.6293 [INFO] usart2: [host: 0.31s (+0.31s)|virt: 0s (+0s)] Assert example
14:11:06.6455 [INFO] usart2: [host: 0.32s (+15.87ms)|virt: 0.11ms (+0.11ms)] Assert at 0x08000F74
</code></pre>
<p class="normal">As we can see, the assert evaluated expression to false and printed out the <code class="inlineCode">0x08000F74</code> program counter value. We can convert this value to the line from a source file using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">$ arm-none-eabi-addr2line --exe bare.elf 0x08000F74
</code></pre>
<p class="normal">This will result in the following output:</p>
<pre class="programlisting con"><code class="hljs-con">/workspace/Cpp-in-Embedded-Systems/Chapter07/error_handling/app/src/main_assert.cpp:30 (discriminator 1)
</code></pre>
<p class="normal">As you can see, we are <a id="_idIndexMarker389"/>able to get the exact line of the source of the assert using this approach and by logging just 4 bytes of data (address). In this implementation, <code class="inlineCode">log_pc_and_halt</code> just print the address. In production implementations, we can store the address in non-volatile memory and use it for postmortem debugging.</p>
<p class="normal">The <code class="inlineCode">hal::get_pc()</code> function is <a id="_idIndexMarker390"/>declared with an <code class="inlineCode">inline</code> specifier. We use <code class="inlineCode">inline</code> as a hint to the compiler to insert instructions from a function directly to a call site, that is, not to make a function call. The compiler doesn’t necessarily need to comply with our intentions, and that can be observed by building this example using the <code class="inlineCode">O0</code> optimization level.</p>
<div><p class="normal"> Exercise for you!</p>
<p class="normal">As an exercise, edit <code class="inlineCode">CMAKE_C_FLAGS_DEBUG</code> and <code class="inlineCode">CMAKE_CXX_FLAGS_DEBUG</code> in <code class="inlineCode">CMakeLists.txt</code>, and instead of <code class="inlineCode">Og</code>, use <code class="inlineCode">O0</code>. Build and run the program and run the <code class="inlineCode">addr2line</code> utility on the output. To mitigate this concern, you can define a macro to be used instead of the <code class="inlineCode">hal::get_pc()</code> function.</p>
</div>
<p class="normal">We use asserts to catch programming errors – situations that should never occur if the code is correct. They are often employed to validate internal assumptions and invariants within critical functions. The primary purpose of asserts is for debugging; they help developers find and fix bugs during the development phase. However, as we’ve seen, customized asserts can also provide valuable insights into production builds for postmortem analysis. While asserts are useful for detecting programming mistakes during development, they are not a substitute for proper error handling in production code. Error codes can be cumbersome because they require manual propagation of errors up the call stack. C++ offers exceptions as a solution to these problems, providing a structured way to handle errors without cluttering the code with error-checking logic.</p>
<p class="normal">Next, we will go over C++ exceptions to better understand the benefits they offer from the error-handling aspect.</p>
<h1 class="heading-1" id="_idParaDest-117">Exceptions</h1>
<p class="normal">Exceptions in C++ are <a id="_idIndexMarker391"/>error-handling mechanisms that are based on the principle of throwing and catching objects of an arbitrary type. All exceptions that are thrown from the standard library derive from the <code class="inlineCode">std::exception</code> class defined in the <code class="inlineCode">&lt;exception&gt;</code> header. We put code that may throw an exception in the <code class="inlineCode">try</code> block, and we define the type of exception we want to catch in the <code class="inlineCode">catch</code> clause, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">    std::array&lt;int, 4&gt; arr;
    try {
      arr.at(5) = 6;
    }
    catch(std::out_of_range &amp;e) {
      printf("Array out of range!\r\n");
    }
</code></pre>
<p class="normal">In the preceding example, we have defined <code class="inlineCode">std::array arr</code>, an array of integers with four members. In the <code class="inlineCode">try</code> block, we are trying to access an element with index <code class="inlineCode">5</code>, which is clearly out of the defined range, and the <code class="inlineCode">at</code> method will throw the <code class="inlineCode">std::out_of_range</code> exception. In order to <a id="_idIndexMarker392"/>run this example, go to the <code class="inlineCode">Chapter07/error_handling</code> folder, make sure that the <code class="inlineCode">build</code> folder is deleted, and run the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ mkdir build &amp;&amp; cd build
$ cmake .. -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_exceptions.cpp
$ make –j4
$ make run_in_renode
</code></pre>
<p class="normal">You should see <code class="inlineCode">Array out of range!</code> printed in the terminal.</p>
<p class="normal">Now, while building the example, you may have noticed that the size of the binary is a whooping 88 KB. What happened?</p>
<p class="normal">In order to enable exceptions, besides using the <code class="inlineCode">-fexceptions</code> compiler flag, we also had to disable the nano specs that we used in previous examples. Nano specs define the usage of the C standard <code class="inlineCode">newlib-nano</code> library and size-optimized <code class="inlineCode">libstdc++</code> and <code class="inlineCode">libsupc++</code> libraries. These are built without exception support and if we use them, any attempt at throwing exceptions will result in <code class="inlineCode">std::abort</code> being called instead. By disabling nano specs, we are using an unoptimized C++ standard library, which results in the 88 KB binary size. A size-optimized standard C++ library can be built from sources with enabled exceptions, which would help reduce the binary footprint.</p>
<p class="normal">If an exception is not caught, <code class="inlineCode">std::terminate_handler</code> will be called. We can replace the default handler using the <code class="inlineCode">std::set_terminate</code> function as in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">    std::set_terminate([]() {
        printf("My terminate handler!\r\n");
        while(true){}
    });
</code></pre>
<p class="normal">In the preceding example, we provided a lambda as a terminate handler. As an exercise, try to access the array from the previous example with an index that is out of range, but out of a <code class="inlineCode">try</code> block. This should trigger the terminate handler and make a call to the lambda we passed to the <code class="inlineCode">std::set_terminate</code> function.</p>
<p class="normal">Exceptions are <a id="_idIndexMarker393"/>propagated up the call stack. Let us go through the following example to demonstrate exception propagation:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;class T, std::size_t N&gt; struct ring_buffer {
  std::array&lt;T, N&gt; arr;
  std::size_t write_idx = 0;
  void push(T t) {
    arr.at(write_idx++) = t;
  }
};
int main()
{
    ring_buffer&lt;int, 4&gt; rb;
    try {
      for(int i = 0; i &lt; 6; i++) {
        rb.push(i);
      }
    }
    catch(std::out_of_range &amp;e) {
      printf("Ring buffer out of range!\r\n");
    }
    return 0;
}
</code></pre>
<p class="normal">The preceding example is based on a ring buffer from previous chapters that uses <code class="inlineCode">std::array</code> as an underlying container. In the <code class="inlineCode">push</code> method, it doesn’t check the write index, meaning that the array’s <code class="inlineCode">at</code> method will throw an exception if we call the <code class="inlineCode">push</code> method more than <code class="inlineCode">N</code> times. An exception is thrown in the <code class="inlineCode">push</code> method, where there is no <code class="inlineCode">try-catch</code> block, and it gets caught only in the <code class="inlineCode">main</code> function in the <code class="inlineCode">catch</code> block.</p>
<p class="normal">You can run the preceding example in the Renode simulator using the following instructions. Start Visual Studio Code, attach it to the running container, open <code class="inlineCode">Chapter07/error_handling project</code> as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cd Chapter07/error_handling
$ cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_exceptions.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Exception propagation is useful for the type of errors that we don’t want to propagate between the software layers manually using error codes. However, the problem with exceptions is that they are not visible from function declarations as is the case with error codes. We need to <a id="_idIndexMarker394"/>rely on good documentation to know which function throws an error and where those errors are handled.</p>
<p class="normal">There is a saying that exceptions are used for exceptional errors that are very rare. But what are exceptional errors? That depends on the library, application, and use case. It is hard to generalize. A failed read to the accelerometer may be a recoverable error that is solved by resetting it. We can throw an exception on a failed I<sup class="superscript">2</sup>C bus communication, and the upper layer that catches this error may decide to try resetting the accelerometer.</p>
<p class="normal">Failing to control boost voltage regulator output by DAC may also be recoverable, but we may want to terminate the program as we are implementing a medical device and that may be the best action possible to prevent any damage to a user. In this case, we want to react as fast as possible and exception propagation and stack unwinding are probably not desirable so we will rely on a global handler or asserts instead.</p>
<p class="normal">Exceptions come with a price, both in flash and RAM memory consumption, and the execution time can’t always be guaranteed, which is a problem if we are working with hard real-time systems. But they also solve the problem of error propagation and enforce error handling. If there is not a <code class="inlineCode">catch</code> clause for a specific type, <code class="inlineCode">std::terminate_handler</code> will be called, and the program will not continue with the execution.</p>
<p class="normal">Error codes and exceptions can co-exist, and they often do. Embedded C++ projects often use C libraries, or legacy C++ code, which often uses error codes. We can benefit from exceptions by using them for very rare errors, adding additional robustness to our firmware. Still, the decision of whether to use them is influenced by available memory resources and the type of project we are working on.</p>
<p class="normal">Next, we will cover the C++ <code class="inlineCode">std::optional</code> and <code class="inlineCode">std::expected</code> template classes, which are used as return types from functions.</p>
<h1 class="heading-1" id="_idParaDest-118">std:: optional and std::expected</h1>
<p class="normal">C++17 introduced <code class="inlineCode">std::optional</code>, a template <a id="_idIndexMarker395"/>class that either has a value or <a id="_idIndexMarker396"/>has nothing. This is useful for situations where a function may or may not return a value. To better understand it, let’s go through the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;optional&gt;
struct sensor {
    struct data {
        int x;
        int y;
    };
    static inline bool ret_val = true;
    static std::optional&lt;data&gt; get_data() {
        ret_val = !ret_val;
        if(ret_val) {
            return data{4, 5};
        }
        else {
            return std::nullopt;
        }
    }
};
int main()
{
    const auto get_data_from_main = [] () {
        auto result = sensor::get_data();
        if(result) {
            printf("x = %d, y = %d\r\n", (*result).x, (*result).y);
        }
        else {
            printf("No data!\r\n");
        }
    };
    get_data_from_main();
    get_data_from_main();
    return 0;
}
</code></pre>
<p class="normal">In the <a id="_idIndexMarker397"/>preceding example, we have a <code class="inlineCode">sensor</code> struct with the <code class="inlineCode">get_data</code> method, which <a id="_idIndexMarker398"/>returns a value if some conditions are met. Otherwise, it doesn’t return it. The sensor is not in an erroneous state, it just doesn’t have data ready yet. For this, we are using <code class="inlineCode">std::optional&lt;data&gt;</code> to declare that the sensor may or may not return the <code class="inlineCode">data</code> struct. We used the <code class="inlineCode">ret_val</code> bool to simulate data being ready at every second call of the <code class="inlineCode">get_data</code> function.</p>
<p class="normal">In the main, we created the <code class="inlineCode">get_data_from_main</code> lambda, which makes a call to the sensor’s <code class="inlineCode">get_data</code>. The <code class="inlineCode">std::optional&lt;data&gt;</code> return value is converted to a bool in the <code class="inlineCode">if</code> statement. If it is <a id="_idIndexMarker399"/>converted to <code class="inlineCode">true</code>, it means it holds data, else it holds nothing. We <a id="_idIndexMarker400"/>access the <code class="inlineCode">data</code> type by dereferencing the <code class="inlineCode">result</code> object.</p>
<p class="normal">C++ 23 introduced <code class="inlineCode">std::expected&lt;T, E&gt;</code>, a template class that either holds an expected object of class <code class="inlineCode">T</code> or an unexpected object of class <code class="inlineCode">E</code>. To understand this better, let us go through the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;expected&gt;
struct ble_light_bulb {
    enum class error {
        disconnected,
        timeout
    };
    struct config {
        int r;
        int g;
        int b;
    };
    bool ret_val;
    std::expected&lt;config, error&gt; get_config() {
        ret_val = !ret_val;
        if(ret_val) {
            return config {10, 20, 30};
        }
        else {
            return std::unexpected(error::timeout);
        }
    }
};
int main()
{  
    ble_light_bulb bulb;
    const auto get_config_from_main = [&amp;bulb]() {
        auto result = bulb.get_config();
        if(result.has_value()) {
            auto conf = result.value();
            printf("Config r %d, g %d, b %d\r\n", conf.r, conf.g, conf.b);
        } else {
            auto err = result.error();
            using bulb_error = ble_light_bulb::error;
            if(err == bulb_error::disconnected) {
                printf("The bulb is disconnected!\r\n");
            }
            else if(err == bulb_error::timeout) {
                printf("Timeout!\r\n");
            }
        }
    };
    get_config_from_main();
    get_config_from_main();
    return 0;
}
</code></pre>
<p class="normal">In the preceding <a id="_idIndexMarker401"/>example, we have a <code class="inlineCode">ble_light_bulb</code> struct, a BLE (Bluetooth Low Energy) light bulb, with the <code class="inlineCode">get_config</code> method, which reads some config data over <a id="_idIndexMarker402"/>the BLE connection from the bulb. This method returns <code class="inlineCode">config</code>, or an <code class="inlineCode">error</code>. In <code class="inlineCode">main</code>, we defined the <code class="inlineCode">get_config_from_main</code> lambda, which calls <code class="inlineCode">get_config</code> on the <code class="inlineCode">ble_light_bulb</code> object. We use the <code class="inlineCode">has_value</code> method on the expected returned object to check if it holds an expected value. We use <code class="inlineCode">value</code> methods to access the expected value or the <code class="inlineCode">error</code> method to access the <code class="inlineCode">error</code> object.</p>
<p class="normal">You can run the preceding example in the Renode simulator using the following instructions. Start Visual Studio Code, attach it to the running container, open <code class="inlineCode">Chapter07/error_handling project</code> as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cd Chapter07/error_handling
$ cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_expected.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<h1 class="heading-1" id="_idParaDest-119">Summary</h1>
<p class="normal">In this chapter, we analyzed different error-handling strategies in C++. We went through error codes, global handlers, asserts, exceptions, <code class="inlineCode">std::optional</code>, and <code class="inlineCode">std::expected</code>. We learned the pros and cons of each and in which situations it makes sense to apply them.</p>
<p class="normal">In the next chapter, we will cover templates in more detail.</p>
<h1 class="heading-1" id="_idParaDest-120">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/embeddedsystems">https://packt.link/embeddedsystems</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_code_Discord.png"/></p>
</div>
</body></html>