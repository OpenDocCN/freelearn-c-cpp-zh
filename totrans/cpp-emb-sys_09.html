<html><head></head><body>
<div id="_idContainer052">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 class="chapterTitle" id="_idParaDest-112"><span class="koboSpan" id="kobo.2.1">Strengthening Firmware – Practical C++ Error Handling Methods</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">To ensure the proper functioning of firmware, we must handle errors from vendor-specific code, libraries that we are using in a project, and our own code. </span><span class="koboSpan" id="kobo.3.2">Error codes are standard error-handling mechanisms in C, and they are also used in C++. </span><span class="koboSpan" id="kobo.3.3">However, C++ provides us with other tools, most notably exceptions that are often avoided in embedded projects due to the large binary footprint and non-determinism. </span><span class="koboSpan" id="kobo.3.4">Still, we will discuss exceptions in C++ in this chapter to show their benefits in the error-handling process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">Besides exceptions, C++ offers more options for error handling that will also be discussed in this chapter. </span><span class="koboSpan" id="kobo.4.2">The goal of this chapter is to understand potential issues with error codes and see how to mitigate them in C++.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">In this chapter, we’re going to cover the following main topics: </span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Error codes and asserts</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Exceptions</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.8.1">std:: optional</span></code><span class="koboSpan" id="kobo.9.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.10.1">std::expected</span></code></li>
</ul>
<h1 class="heading-1" id="_idParaDest-113"><span class="koboSpan" id="kobo.11.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.12.1">To get the most out of this chapter, I strongly recommend using Compiler Explorer (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.13.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.14.1">) as you read through the examples. </span><span class="koboSpan" id="kobo.14.2">Select GCC as your compiler and target x86 architecture. </span><span class="koboSpan" id="kobo.14.3">This will allow you to see standard output (stdio) results and better observe the code’s behavior. </span><span class="koboSpan" id="kobo.14.4">As we are using modern C++ features make sure to select C++23 standard, by adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.15.1">-std=c++23</span></code><span class="koboSpan" id="kobo.16.1"> in compiler options box. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.17.1">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly. </span><span class="koboSpan" id="kobo.17.2">The examples are available at GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter07"><span class="url"><span class="koboSpan" id="kobo.18.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter07</span></span></a><span class="koboSpan" id="kobo.19.1">).</span></p>
<h1 class="heading-1" id="_idParaDest-114"><span class="koboSpan" id="kobo.20.1">Error codes and asserts</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.21.1">Error codes</span></strong><span class="koboSpan" id="kobo.22.1"> are a common way of reporting and handling errors in C. </span><span class="koboSpan" id="kobo.22.2">They are also still used in C++. </span><span class="koboSpan" id="kobo.22.3">A function that </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.23.1">fails reports an error through enumerated codes that are checked by a caller and handled appropriately. </span><span class="koboSpan" id="kobo.23.2">Let us analyze how error codes work from both the caller and the callee perspective.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.24.1">A function that returns an error must have a list of errors that are exposed to callers. </span><span class="koboSpan" id="kobo.24.2">This list is maintained through a software life cycle, and it can be subject to changes. </span><span class="koboSpan" id="kobo.24.3">Enumerated error codes can be added, removed, or modified. </span><span class="koboSpan" id="kobo.24.4">A caller must be aware of the error codes that the callee is returning, and it needs to handle them. </span><span class="koboSpan" id="kobo.24.5">Or, if it doesn’t know how to handle an error, it should propagate it further within a call stack.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.25.1">Let’s observe a simple example of a function that returns an error and analyze the implications this has for the code using this function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.26.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.27.1">error</span></span><span class="koboSpan" id="kobo.28.1"> {
    Ok,
    Error1,
    Error2,
    Unknown
};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.29.1">error </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.30.1">h</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.31.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.32.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.33.1">return</span></span><span class="koboSpan" id="kobo.34.1"> error::Error1;
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.35.1">error </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.36.1">g</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.37.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.38.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.39.1">auto</span></span><span class="koboSpan" id="kobo.40.1"> err = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.41.1">h</span></span><span class="koboSpan" id="kobo.42.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.43.1">if</span></span><span class="koboSpan" id="kobo.44.1">(err!=error::Ok) {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.45.1">if</span></span><span class="koboSpan" id="kobo.46.1">(err == error::Error1) {
       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.47.1">// handle error directly</span></span><span class="koboSpan" id="kobo.48.1">
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.49.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.50.1">if</span></span><span class="koboSpan" id="kobo.51.1">(err == error::Error2) {
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.52.1">// propagate this error</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.53.1">return</span></span><span class="koboSpan" id="kobo.54.1"> err;
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.55.1">else</span></span><span class="koboSpan" id="kobo.56.1"> {
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.57.1">// unknown error</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.58.1">return</span></span><span class="koboSpan" id="kobo.59.1"> error::Unknown;
        }
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.60.1">return</span></span><span class="koboSpan" id="kobo.61.1"> error::Ok;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.62.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.63.1">f</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.64.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.65.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.66.1">auto</span></span><span class="koboSpan" id="kobo.67.1"> err = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.68.1">g</span></span><span class="koboSpan" id="kobo.69.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.70.1">if</span></span><span class="koboSpan" id="kobo.71.1">(err==error::Ok) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.72.1">printf</span></span><span class="koboSpan" id="kobo.73.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.74.1">"Succes\r\n"</span></span><span class="koboSpan" id="kobo.75.1">);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.76.1">else</span></span><span class="koboSpan" id="kobo.77.1"> {
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.78.1">// handle errors</span></span><span class="koboSpan" id="kobo.79.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.80.1">In the </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.81.1">preceding example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">h</span></code><span class="koboSpan" id="kobo.83.1"> function returns an error of </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">enum class error</span></code><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.86.1">g</span></code><span class="koboSpan" id="kobo.87.1"> function calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">h</span></code><span class="koboSpan" id="kobo.89.1"> function and executes the following steps:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.90.1">Checks if </span><code class="inlineCode"><span class="koboSpan" id="kobo.91.1">h</span></code><span class="koboSpan" id="kobo.92.1"> returned an error that is different from </span><code class="inlineCode"><span class="koboSpan" id="kobo.93.1">error::Ok</span></code><span class="koboSpan" id="kobo.94.1">. </span><span class="koboSpan" id="kobo.94.2">This indicates that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.95.1">h</span></code><span class="koboSpan" id="kobo.96.1"> function didn’t perform its task and there is an error that should be handled.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.97.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">h</span></code><span class="koboSpan" id="kobo.99.1"> returned an error, checks whether it is </span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">error::Error1</span></code><span class="koboSpan" id="kobo.101.1">. </span><span class="koboSpan" id="kobo.101.2">In this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">g</span></code><span class="koboSpan" id="kobo.103.1"> knows how to handle this error and it handles it.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.104.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">h</span></code><span class="koboSpan" id="kobo.106.1"> returned </span><code class="inlineCode"><span class="koboSpan" id="kobo.107.1">error::Error2</span></code><span class="koboSpan" id="kobo.108.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.109.1">g</span></code><span class="koboSpan" id="kobo.110.1"> is not capable of handling it, and it forwards it up the call stack.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.111.1">Returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.112.1">error::Ok</span></code><span class="koboSpan" id="kobo.113.1"> to indicate up the call stack that everything went fine.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.114.1">Function </span><code class="inlineCode"><span class="koboSpan" id="kobo.115.1">g</span></code><span class="koboSpan" id="kobo.116.1"> is called by </span><code class="inlineCode"><span class="koboSpan" id="kobo.117.1">f</span></code><span class="koboSpan" id="kobo.118.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.119.1">f</span></code><span class="koboSpan" id="kobo.120.1"> also needs to be aware of errors defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">enum class error</span></code><span class="koboSpan" id="kobo.122.1">. </span><span class="koboSpan" id="kobo.122.2">It should handle them or pass them up the stack.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.123.1">Error codes rely on design contracts. </span><span class="koboSpan" id="kobo.123.2">The caller must check if the callee returned an error, and if it did, it needs to handle it or pass it up the call stack. </span><span class="koboSpan" id="kobo.123.3">Now, we can identify several potential problems with this simple approach:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.124.1">We cannot enforce error handling by a caller. </span><span class="koboSpan" id="kobo.124.2">It can just discard the return value.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.125.1">The caller can forget to handle some of the error cases.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.126.1">The caller can forget to pass the error up the call stack.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.127.1">These are serious design flaws that put an extra burden on code development. </span><span class="koboSpan" id="kobo.127.2">There is no escape hatch in case we forget to handle an error somewhere. </span><span class="koboSpan" id="kobo.127.3">The program stays in an unknown state and this potentially leads to unwanted behavior.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.128.1">We can address the first concern using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">nodiscard</span></code><span class="koboSpan" id="kobo.130.1"> attribute. </span><span class="koboSpan" id="kobo.130.2">It can be used with a function declaration or enumeration declaration. </span><span class="koboSpan" id="kobo.130.3">In our case, we can use it with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">enum class</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.132.1">error</span></code><span class="koboSpan" id="kobo.133.1"> declaration as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.134.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.135.1">class</span></span><span class="koboSpan" id="kobo.136.1"> [[nodiscard]] error {
    Ok,
    Error1,
    Error2,
    Unknown
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.137.1">When a function </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.138.1">returning the </span><code class="inlineCode"><span class="koboSpan" id="kobo.139.1">enum class</span></code><span class="koboSpan" id="kobo.140.1"> error is called, and the return value is discarded, the compiler is encouraged to raise a warning. </span><span class="koboSpan" id="kobo.140.2">If we call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.141.1">g</span></code><span class="koboSpan" id="kobo.142.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.143.1">h</span></code><span class="koboSpan" id="kobo.144.1"> function from our example, GCC will raise a warning similar to this one:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.145.1">&lt;source&gt;:48:6: warning: ignoring returned value of type 'error', declared with attribute 'nodiscard' [-Wunused-result]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.146.1">If we set up the compiler to treat all warnings as errors, this would break the compilation process and force us to use the return value in code. </span><span class="koboSpan" id="kobo.146.2">Even though the </span><code class="inlineCode"><span class="koboSpan" id="kobo.147.1">nodiscard</span></code><span class="koboSpan" id="kobo.148.1"> attribute is useful and should be used for similar use cases, it is not a complete solution to our problem. </span><span class="koboSpan" id="kobo.148.2">It will enforce usage of the return value, but the caller may still fail to check the error code for all possible cases and address it properly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.149.1">Almost every application has some types of errors that are unrecoverable and the only thing it makes sense to do is to log them, display them to a user (if possible), and terminate the program, as there is no sense in proceeding with such a program state. </span><span class="koboSpan" id="kobo.149.2">For these types of errors, we can use a global error handler, as they are too important to be left open in the wild and potentially not handled by a caller.</span></p>
<h2 class="heading-2" id="_idParaDest-115"><span class="koboSpan" id="kobo.150.1">Global error handlers</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.151.1">Global error handlers</span></strong><span class="koboSpan" id="kobo.152.1"> can be implemented as free functions. </span><span class="koboSpan" id="kobo.152.2">They are used system-wide to address errors </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.153.1">that are unrecoverable and when it is necessary to stop the execution of firmware due to the severity of an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.154.1">Let’s take a look at an example of firmware using an accelerometer. </span><span class="koboSpan" id="kobo.154.2">If there are any issues in I</span><sup class="superscript"><span class="koboSpan" id="kobo.155.1">2</span></sup><span class="koboSpan" id="kobo.156.1">C communication with the accelerometer, it doesn’t make sense to proceed further with code execution – the firmware will display a message to the user and terminate:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.157.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.158.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.159.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.160.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.161.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.162.1">&lt;cstdint&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.163.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.164.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.165.1">&lt;cstdlib&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.166.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.167.1">i2c_read</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.168.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.169.1">uint8_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.170.1"> *data, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.171.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.172.1"> len)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.173.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.174.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.175.1">0</span></span><span class="koboSpan" id="kobo.176.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.177.1">namespace</span></span><span class="koboSpan" id="kobo.178.1"> error {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.179.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.180.1">i2c_failed</span></span><span class="koboSpan" id="kobo.181.1">{};
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.182.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.183.1">spi_failed</span></span><span class="koboSpan" id="kobo.184.1">{};
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.185.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.186.1">handler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.187.1">(i2c_failed err)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.188.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.189.1">printf</span></span><span class="koboSpan" id="kobo.190.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.191.1">"I2C error!\r\n"</span></span><span class="koboSpan" id="kobo.192.1">);
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.193.1">exit</span></span><span class="koboSpan" id="kobo.194.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.195.1">1</span></span><span class="koboSpan" id="kobo.196.1">);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.197.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.198.1">handler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.199.1">(spi_failed err)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.200.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.201.1">printf</span></span><span class="koboSpan" id="kobo.202.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.203.1">"SPI error!\r\n"</span></span><span class="koboSpan" id="kobo.204.1">);
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.205.1">exit</span></span><span class="koboSpan" id="kobo.206.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.207.1">1</span></span><span class="koboSpan" id="kobo.208.1">);
    }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.209.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.210.1">accelerometer</span></span><span class="koboSpan" id="kobo.211.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.212.1">public</span></span><span class="koboSpan" id="kobo.213.1">:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.214.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.215.1">data</span></span><span class="koboSpan" id="kobo.216.1"> {
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.217.1">int16_t</span></span><span class="koboSpan" id="kobo.218.1"> x;
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.219.1">int16_t</span></span><span class="koboSpan" id="kobo.220.1"> y;
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.221.1">int16_t</span></span><span class="koboSpan" id="kobo.222.1"> z;
    };
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.223.1">data </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.224.1">get_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.225.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.226.1">{
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.227.1">uint8_t</span></span><span class="koboSpan" id="kobo.228.1"> buff[</span><span class="hljs-number"><span class="koboSpan" id="kobo.229.1">6</span></span><span class="koboSpan" id="kobo.230.1">];
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.231.1">if</span></span><span class="koboSpan" id="kobo.232.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.233.1">i2c_read</span></span><span class="koboSpan" id="kobo.234.1">(buff, </span><span class="hljs-number"><span class="koboSpan" id="kobo.235.1">6</span></span><span class="koboSpan" id="kobo.236.1">) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.237.1">6</span></span><span class="koboSpan" id="kobo.238.1">) {
            error::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.239.1">handler</span></span><span class="koboSpan" id="kobo.240.1">(error::i2c_failed{});
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.241.1">return</span></span><span class="koboSpan" id="kobo.242.1"> data{};
    }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.243.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.244.1">main</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.245.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.246.1">{
    accelerometer accel;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.247.1">auto</span></span><span class="koboSpan" id="kobo.248.1"> data = accel.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.249.1">get_data</span></span><span class="koboSpan" id="kobo.250.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.251.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.252.1">0</span></span><span class="koboSpan" id="kobo.253.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.254.1">In the </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.255.1">preceding example, we have an </span><code class="inlineCode"><span class="koboSpan" id="kobo.256.1">accelerometer</span></code><span class="koboSpan" id="kobo.257.1"> class with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">get_data</span></code><span class="koboSpan" id="kobo.259.1"> method, which uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">i2c_read</span></code><span class="koboSpan" id="kobo.261.1"> function from the vendor-specific HAL in C (let us pretend this is the case).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.262.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">i2c_read</span></code><span class="koboSpan" id="kobo.264.1"> function returns the number of read bytes. </span><span class="koboSpan" id="kobo.264.2">In our example, the return value is stubbed to </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">0</span></code><span class="koboSpan" id="kobo.266.1"> so we can simulate the erroneous behavior of the accelerometer (or the I</span><sup class="superscript"><span class="koboSpan" id="kobo.267.1">2</span></sup><span class="koboSpan" id="kobo.268.1">C bus). </span><span class="koboSpan" id="kobo.268.2">In case </span><code class="inlineCode"><span class="koboSpan" id="kobo.269.1">i2c_read</span></code><span class="koboSpan" id="kobo.270.1"> returns a number different from the requested number of bytes, </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">get_data</span></code><span class="koboSpan" id="kobo.272.1"> will call </span><code class="inlineCode"><span class="koboSpan" id="kobo.273.1">error::handler</span></code><span class="koboSpan" id="kobo.274.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.275.1">We implemented an error handler using a tag-dispatching mechanism. </span><span class="koboSpan" id="kobo.275.2">We are overloading the </span><code class="inlineCode"><span class="koboSpan" id="kobo.276.1">error::handler</span></code><span class="koboSpan" id="kobo.277.1"> function with so-called tags, or empty types. </span><span class="koboSpan" id="kobo.277.2">In our example, we have two tags, </span><code class="inlineCode"><span class="koboSpan" id="kobo.278.1">i2c_failed</span></code><span class="koboSpan" id="kobo.279.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.280.1">spi_failed</span></code><span class="koboSpan" id="kobo.281.1">, and two overloaded error handlers. </span><span class="koboSpan" id="kobo.281.2">Tag dispatching has a couple </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.282.1">of advantages over defining error codes with </span><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">enum</span></code><span class="koboSpan" id="kobo.284.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.285.1">We need to overload error handlers for every tag that is used in code. </span><span class="koboSpan" id="kobo.285.2">Error handlers are implemented individually for every error type. </span><span class="koboSpan" id="kobo.285.3">This adds to the readability of code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.286.1">In case we make a call to an error handler that is not overloaded, the compilation will fail, forcing us to implement it.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.287.1">In our example, the error handler will print a message using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">printf</span></code><span class="koboSpan" id="kobo.289.1"> function and make a call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">exit</span></code><span class="koboSpan" id="kobo.291.1"> function, effectively terminating the program. </span><span class="koboSpan" id="kobo.291.2">In real-world situations, how we handle errors depends on the application. </span><span class="koboSpan" id="kobo.291.3">For example, for a medical device, if critical operations become unsafe after an error, we would first attempt to recover from the error. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.292.1">If recovery failed, the system would enter a critical error state, alert medical personnel, and gracefully terminate the treatment operation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.293.1">An error on the I</span><sup class="superscript"><span class="koboSpan" id="kobo.294.1">2</span></sup><span class="koboSpan" id="kobo.295.1">C bus or, more generally, failed communication with external devices must be handled appropriately through robust error-handling mechanisms.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.296.1">On the other hand, there are conditions that indicate programming mistakes – situations that should never occur if the code is correct. </span><span class="koboSpan" id="kobo.296.2">These include violations of preconditions, such as input parameters being out of expected boundaries due to logic errors in the code. </span><span class="koboSpan" id="kobo.296.3">Proceeding under such circumstances could lead to undefined behavior or system instability. </span><span class="koboSpan" id="kobo.296.4">To detect these programming errors during development, we use asserts.</span></p>
<h2 class="heading-2" id="_idParaDest-116"><span class="koboSpan" id="kobo.297.1">Asserts</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.298.1">Asserts are primarily used during development to detect programming mistakes by verifying that certain </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.299.1">conditions hold true at specific points in the code. </span><span class="koboSpan" id="kobo.299.2">They help identify logical errors and incorrect assumptions by halting execution when an unexpected condition occurs. </span><span class="koboSpan" id="kobo.299.3">A macro assert is defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">&lt;cassert&gt;</span></code><span class="koboSpan" id="kobo.301.1"> in the standard library. </span><span class="koboSpan" id="kobo.301.2">It is used to check a logical expression, and in case the logical expression is false, it prints diagnostic information and calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">std::abort</span></code><span class="koboSpan" id="kobo.303.1">, effectively terminating the program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.304.1">To better understand asserts, and how to use them, let us take a look at the following code example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.305.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.306.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.307.1">&lt;cassert&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.308.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.309.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.310.1">&lt;cstdint&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.311.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.312.1">option</span></span><span class="koboSpan" id="kobo.313.1"> : std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.314.1">uint8_t</span></span><span class="koboSpan" id="kobo.315.1"> {
    Option1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.316.1">0</span></span><span class="koboSpan" id="kobo.317.1">,
    Option2,
    Option3,
    Last
};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.318.1">option </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.319.1">uint8_to_option</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.320.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.321.1">uint8_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.322.1"> num)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.323.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.324.1">assert</span></span><span class="koboSpan" id="kobo.325.1">(num &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.326.1">static_cast</span></span><span class="koboSpan" id="kobo.327.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.328.1">uint8_t</span></span><span class="koboSpan" id="kobo.329.1">&gt;(option::Last));
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.330.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.331.1">static_cast</span></span><span class="koboSpan" id="kobo.332.1">&lt;option&gt;(num);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.333.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.334.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.335.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.336.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.337.1">const</span></span><span class="koboSpan" id="kobo.338.1"> option opt = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.339.1">uint8_to_option</span></span><span class="koboSpan" id="kobo.340.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.341.1">3</span></span><span class="koboSpan" id="kobo.342.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.343.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.344.1">0</span></span><span class="koboSpan" id="kobo.345.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.346.1">In the preceding example, we have defined the </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">option</span></code><span class="koboSpan" id="kobo.348.1"> enum class with </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">uint8_t</span></code><span class="koboSpan" id="kobo.350.1"> as an underlying type. </span><span class="koboSpan" id="kobo.350.2">We will use it to allow users to select an option over a network interface and we want to </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.351.1">make sure that the conversion from </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">uint8_t</span></code><span class="koboSpan" id="kobo.353.1"> to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">option</span></code><span class="koboSpan" id="kobo.355.1"> enum is always correct. </span><span class="koboSpan" id="kobo.355.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">uint8_to_option</span></code><span class="koboSpan" id="kobo.357.1"> function will assert if the received </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">uint8_t</span></code><span class="koboSpan" id="kobo.359.1"> argument is not smaller than </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">option::Last</span></code><span class="koboSpan" id="kobo.361.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.362.1">In the example, we called </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">uint8_to_option</span></code><span class="koboSpan" id="kobo.364.1"> with argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">3</span></code><span class="koboSpan" id="kobo.366.1">, which is not smaller than </span><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">option::Last</span></code><span class="koboSpan" id="kobo.368.1">, meaning that the assert macro will print the following diagnostic information and make a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">std::abort</span></code><span class="koboSpan" id="kobo.370.1"> to terminate the program:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.371.1">assertion "num &lt; static_cast&lt;uint8_t&gt;(option::Last)" failed: file "/home/amar/projects/Cpp-in-Embedded Systems/Chapter07/error_handling/app/src/main.cpp", line 21, function: option uint8_to_option(uint8_t)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.372.1">Now, this is quite a lengthy debug statement. </span><span class="koboSpan" id="kobo.372.2">Let’s take a look at the </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">assert</span></code><span class="koboSpan" id="kobo.374.1"> macro definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.375.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.376.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.377.1"> assert(expr)                             \</span></span><span class="koboSpan" id="kobo.378.1">
     (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.379.1">static_cast</span></span><span class="koboSpan" id="kobo.380.1"> &lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.381.1">bool</span></span><span class="koboSpan" id="kobo.382.1">&gt; (expr)                  \
      ? </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.383.1">void</span></span><span class="koboSpan" id="kobo.384.1"> (</span><span class="hljs-number"><span class="koboSpan" id="kobo.385.1">0</span></span><span class="koboSpan" id="kobo.386.1">)                                 \
      : __assert_fail (</span><span class="hljs-meta"><span class="koboSpan" id="kobo.387.1">#expr, </span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.388.1">__ASSERT_FILE,            \</span></span><span class="koboSpan" id="kobo.389.1">
                       __ASSERT_LINE,            \
                       __ASSERT_FUNCTION))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.390.1">We see that the expression is cast to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.391.1">bool</span></code><span class="koboSpan" id="kobo.392.1"> type and that the ternary operator does nothing if the expression is true, or it makes a call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.393.1">__assert_fail</span></code><span class="koboSpan" id="kobo.394.1"> function if the expression is false. </span><span class="koboSpan" id="kobo.394.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">assert</span></code><span class="koboSpan" id="kobo.396.1"> macro passes the expression as a string literal, the filename as a string literal, the line number, and also a function name as a string literal. </span><span class="koboSpan" id="kobo.396.2">All these string literals must be stored in the binary, taking up precious memory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.397.1">Asserts can </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.398.1">be disabled by defining the </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">NDEBUG</span></code><span class="koboSpan" id="kobo.400.1"> macro before including </span><code class="inlineCode"><span class="koboSpan" id="kobo.401.1">&lt;cassert&gt;</span></code><span class="koboSpan" id="kobo.402.1"> as in the following lines:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.403.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.404.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.405.1"> NDEBUG</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.406.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.407.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.408.1">&lt;cassert&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.409.1">We can also define </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">NDEBUG</span></code><span class="koboSpan" id="kobo.411.1"> using the build system. </span><span class="koboSpan" id="kobo.411.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.412.1">assert</span></code><span class="koboSpan" id="kobo.413.1"> macro will do nothing if </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">NDEBUG</span></code><span class="koboSpan" id="kobo.415.1"> is defined before </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">&lt;cassert&gt;</span></code><span class="koboSpan" id="kobo.417.1"> is included. </span><span class="koboSpan" id="kobo.417.2">This option is left to be used in case we want to disable asserts, as they are most commonly used in debug builds, and disabled in production builds. </span><span class="koboSpan" id="kobo.417.3">They should be disabled before the safety-critical software validation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.418.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.419.1">assert</span></code><span class="koboSpan" id="kobo.420.1"> macro, as implemented in the standard library, is not suitable for embedded systems as it includes the filename, function name, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.421.1">assert</span></code><span class="koboSpan" id="kobo.422.1"> expression as string literals, which end up stored in the flash of the embedded target. </span><span class="koboSpan" id="kobo.422.2">Moreover, asserts are mostly intended to be used during debugging, and they are often disabled in production builds. </span><span class="koboSpan" id="kobo.422.3">Still, there is a benefit of asserts enabled in production builds, as they can provide valuable insights for postmortem debugging if they are implemented to log data when the expression is evaluated as </span><code class="inlineCode"><span class="koboSpan" id="kobo.423.1">false</span></code><span class="koboSpan" id="kobo.424.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.425.1">We will examine an alternative approach to logging information using asserts. </span><span class="koboSpan" id="kobo.425.2">As we have already concluded, the default assert macro implementation is not well suited for embedded targets, even though it contains useful information for debugging: filename, function name, and line number. </span><span class="koboSpan" id="kobo.425.3">Instead of a lengthy string describing an exact location of the assert macro line in our code, we can simply log a program counter and use the map file and </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">addr2line</span></code><span class="koboSpan" id="kobo.427.1"> tool to convert the address to the exact line. </span><span class="koboSpan" id="kobo.427.2">We can see a simple macro definition and a helper function to implement this in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.428.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.429.1">log_pc_and_halt</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.430.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.431.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.432.1"> pc)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.433.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.434.1">printf</span></span><span class="koboSpan" id="kobo.435.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.436.1">"Assert at 0x%08lX\r\n"</span></span><span class="koboSpan" id="kobo.437.1">, pc);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.438.1">while</span></span><span class="koboSpan" id="kobo.439.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.440.1">true</span></span><span class="koboSpan" id="kobo.441.1">) {}
}
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.442.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.443.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.444.1"> light_assert(expr)         \</span></span><span class="koboSpan" id="kobo.445.1">
        (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.446.1">static_cast</span></span><span class="koboSpan" id="kobo.447.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.448.1">bool</span></span><span class="koboSpan" id="kobo.449.1">&gt; (expr)  \
        ? </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.450.1">void</span></span><span class="koboSpan" id="kobo.451.1"> (</span><span class="hljs-number"><span class="koboSpan" id="kobo.452.1">0</span></span><span class="koboSpan" id="kobo.453.1">)                 \
        : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.454.1">log_pc_and_halt</span></span><span class="koboSpan" id="kobo.455.1">(hal::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.456.1">get_pc</span></span><span class="koboSpan" id="kobo.457.1">())    \
        )
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.458.1">We have defined a macro named </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">light_assert</span></code><span class="koboSpan" id="kobo.460.1"> that, instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.461.1">__assert_failed</span></code><span class="koboSpan" id="kobo.462.1">, calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.463.1">log_pc_and_halt</span></code><span class="koboSpan" id="kobo.464.1">. </span><span class="koboSpan" id="kobo.464.2">It is passing the return value from </span><code class="inlineCode"><span class="koboSpan" id="kobo.465.1">hal::get_pc</span></code><span class="koboSpan" id="kobo.466.1"> as an argument to </span><code class="inlineCode"><span class="koboSpan" id="kobo.467.1">log_pc_and_halt</span></code><span class="koboSpan" id="kobo.468.1">. </span><span class="koboSpan" id="kobo.468.2">To see this code in action, you can take a look at the example in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.469.1">Chapter07/error_handling</span></code><span class="koboSpan" id="kobo.470.1"> project.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.471.1">The project for this chapter is configured so that you can configure it to use different main C++ files and </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.472.1">configure which one is going to be used with CMake. </span><span class="koboSpan" id="kobo.472.2">Let us start our Docker container using the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.473.1">$ docker start dev_env
$ docker exec -it dev_env /bin/bash
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.474.1">This should get us in the Docker terminal. </span><span class="koboSpan" id="kobo.474.2">Run </span><code class="inlineCode"><span class="koboSpan" id="kobo.475.1">ls –l</span></code><span class="koboSpan" id="kobo.476.1"> to make sure that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">Cpp-in-Embedded-Systems</span></code><span class="koboSpan" id="kobo.478.1"> repo is cloned. </span><span class="koboSpan" id="kobo.478.2">If not, clone it using the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.479.1">$ git clone https://github.com/PacktPublishing/Cpp-in-Embedded-Systems.git
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.480.1">Start Visual Studio Code, attach it to the running container, and open </span><code class="inlineCode"><span class="koboSpan" id="kobo.481.1">Chapter07/error_handling project</span></code><span class="koboSpan" id="kobo.482.1"> as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.483.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.484.1"> and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.485.1">$ cd Chapter07/error_handling
$ cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_assert.cpp
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.486.1">The preceding commands will build the firmware using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">app/src/main_assert.cpp</span></code><span class="koboSpan" id="kobo.488.1"> file and run it in Renode simulator. </span><span class="koboSpan" id="kobo.488.2">You should see similar output to this in the terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.489.1">14:11:06.6293 [INFO] usart2: [host: 0.31s (+0.31s)|virt: 0s (+0s)] Assert example
14:11:06.6455 [INFO] usart2: [host: 0.32s (+15.87ms)|virt: 0.11ms (+0.11ms)] Assert at 0x08000F74
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.490.1">As we can see, the assert evaluated expression to false and printed out the </span><code class="inlineCode"><span class="koboSpan" id="kobo.491.1">0x08000F74</span></code><span class="koboSpan" id="kobo.492.1"> program counter value. </span><span class="koboSpan" id="kobo.492.2">We can convert this value to the line from a source file using the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.493.1">$ arm-none-eabi-addr2line --exe bare.elf 0x08000F74
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.494.1">This will result in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.495.1">/workspace/Cpp-in-Embedded-Systems/Chapter07/error_handling/app/src/main_assert.cpp:30 (discriminator 1)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.496.1">As you can see, we are </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.497.1">able to get the exact line of the source of the assert using this approach and by logging just 4 bytes of data (address). </span><span class="koboSpan" id="kobo.497.2">In this implementation, </span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">log_pc_and_halt</span></code><span class="koboSpan" id="kobo.499.1"> just print the address. </span><span class="koboSpan" id="kobo.499.2">In production implementations, we can store the address in non-volatile memory and use it for postmortem debugging.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.500.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.501.1">hal::get_pc()</span></code><span class="koboSpan" id="kobo.502.1"> function is </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.503.1">declared with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">inline</span></code><span class="koboSpan" id="kobo.505.1"> specifier. </span><span class="koboSpan" id="kobo.505.2">We use </span><code class="inlineCode"><span class="koboSpan" id="kobo.506.1">inline</span></code><span class="koboSpan" id="kobo.507.1"> as a hint to the compiler to insert instructions from a function directly to a call site, that is, not to make a function call. </span><span class="koboSpan" id="kobo.507.2">The compiler doesn’t necessarily need to comply with our intentions, and that can be observed by building this example using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">O0</span></code><span class="koboSpan" id="kobo.509.1"> optimization level.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.510.1"> Exercise for you!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.511.1">As an exercise, edit </span><code class="inlineCode"><span class="koboSpan" id="kobo.512.1">CMAKE_C_FLAGS_DEBUG</span></code><span class="koboSpan" id="kobo.513.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.514.1">CMAKE_CXX_FLAGS_DEBUG</span></code><span class="koboSpan" id="kobo.515.1"> in </span><code class="inlineCode"><span class="koboSpan" id="kobo.516.1">CMakeLists.txt</span></code><span class="koboSpan" id="kobo.517.1">, and instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.518.1">Og</span></code><span class="koboSpan" id="kobo.519.1">, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.520.1">O0</span></code><span class="koboSpan" id="kobo.521.1">. </span><span class="koboSpan" id="kobo.521.2">Build and run the program and run the </span><code class="inlineCode"><span class="koboSpan" id="kobo.522.1">addr2line</span></code><span class="koboSpan" id="kobo.523.1"> utility on the output. </span><span class="koboSpan" id="kobo.523.2">To mitigate this concern, you can define a macro to be used instead of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.524.1">hal::get_pc()</span></code><span class="koboSpan" id="kobo.525.1"> function.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.526.1">We use asserts to catch programming errors – situations that should never occur if the code is correct. </span><span class="koboSpan" id="kobo.526.2">They are often employed to validate internal assumptions and invariants within critical functions. </span><span class="koboSpan" id="kobo.526.3">The primary purpose of asserts is for debugging; they help developers find and fix bugs during the development phase. </span><span class="koboSpan" id="kobo.526.4">However, as we’ve seen, customized asserts can also provide valuable insights into production builds for postmortem analysis. </span><span class="koboSpan" id="kobo.526.5">While asserts are useful for detecting programming mistakes during development, they are not a substitute for proper error handling in production code. </span><span class="koboSpan" id="kobo.526.6">Error codes can be cumbersome because they require manual propagation of errors up the call stack. </span><span class="koboSpan" id="kobo.526.7">C++ offers exceptions as a solution to these problems, providing a structured way to handle errors without cluttering the code with error-checking logic.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.527.1">Next, we will go over C++ exceptions to better understand the benefits they offer from the error-handling aspect.</span></p>
<h1 class="heading-1" id="_idParaDest-117"><span class="koboSpan" id="kobo.528.1">Exceptions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.529.1">Exceptions in C++ are </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.530.1">error-handling mechanisms that are based on the principle of throwing and catching objects of an arbitrary type. </span><span class="koboSpan" id="kobo.530.2">All exceptions that are thrown from the standard library derive from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">std::exception</span></code><span class="koboSpan" id="kobo.532.1"> class defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">&lt;exception&gt;</span></code><span class="koboSpan" id="kobo.534.1"> header. </span><span class="koboSpan" id="kobo.534.2">We put code that may throw an exception in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.535.1">try</span></code><span class="koboSpan" id="kobo.536.1"> block, and we define the type of exception we want to catch in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">catch</span></code><span class="koboSpan" id="kobo.538.1"> clause, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.539.1">    std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.540.1">int</span></span><span class="koboSpan" id="kobo.541.1">, 4&gt; arr;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.542.1">try</span></span><span class="koboSpan" id="kobo.543.1"> {
      arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.544.1">at</span></span><span class="koboSpan" id="kobo.545.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.546.1">5</span></span><span class="koboSpan" id="kobo.547.1">) = </span><span class="hljs-number"><span class="koboSpan" id="kobo.548.1">6</span></span><span class="koboSpan" id="kobo.549.1">;
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.550.1">catch</span></span><span class="koboSpan" id="kobo.551.1">(std::out_of_range &amp;e) {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.552.1">printf</span></span><span class="koboSpan" id="kobo.553.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.554.1">"Array out of range!\r\n"</span></span><span class="koboSpan" id="kobo.555.1">);
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.556.1">In the preceding example, we have defined </span><code class="inlineCode"><span class="koboSpan" id="kobo.557.1">std::array arr</span></code><span class="koboSpan" id="kobo.558.1">, an array of integers with four members. </span><span class="koboSpan" id="kobo.558.2">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.559.1">try</span></code><span class="koboSpan" id="kobo.560.1"> block, we are trying to access an element with index </span><code class="inlineCode"><span class="koboSpan" id="kobo.561.1">5</span></code><span class="koboSpan" id="kobo.562.1">, which is clearly out of the defined range, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.563.1">at</span></code><span class="koboSpan" id="kobo.564.1"> method will throw the </span><code class="inlineCode"><span class="koboSpan" id="kobo.565.1">std::out_of_range</span></code><span class="koboSpan" id="kobo.566.1"> exception. </span><span class="koboSpan" id="kobo.566.2">In order to </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.567.1">run this example, go to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.568.1">Chapter07/error_handling</span></code><span class="koboSpan" id="kobo.569.1"> folder, make sure that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.570.1">build</span></code><span class="koboSpan" id="kobo.571.1"> folder is deleted, and run the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.572.1">$ mkdir build &amp;&amp; cd build
$ cmake .. </span><span class="koboSpan" id="kobo.572.2">-DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_exceptions.cpp
$ make –j4
$ make run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.573.1">You should see </span><code class="inlineCode"><span class="koboSpan" id="kobo.574.1">Array out of range!</span></code><span class="koboSpan" id="kobo.575.1"> printed in the terminal.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.576.1">Now, while building the example, you may have noticed that the size of the binary is a whooping 88 KB. </span><span class="koboSpan" id="kobo.576.2">What happened?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.577.1">In order to enable exceptions, besides using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.578.1">-fexceptions</span></code><span class="koboSpan" id="kobo.579.1"> compiler flag, we also had to disable the nano specs that we used in previous examples. </span><span class="koboSpan" id="kobo.579.2">Nano specs define the usage of the C standard </span><code class="inlineCode"><span class="koboSpan" id="kobo.580.1">newlib-nano</span></code><span class="koboSpan" id="kobo.581.1"> library and size-optimized </span><code class="inlineCode"><span class="koboSpan" id="kobo.582.1">libstdc++</span></code><span class="koboSpan" id="kobo.583.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.584.1">libsupc++</span></code><span class="koboSpan" id="kobo.585.1"> libraries. </span><span class="koboSpan" id="kobo.585.2">These are built without exception support and if we use them, any attempt at throwing exceptions will result in </span><code class="inlineCode"><span class="koboSpan" id="kobo.586.1">std::abort</span></code><span class="koboSpan" id="kobo.587.1"> being called instead. </span><span class="koboSpan" id="kobo.587.2">By disabling nano specs, we are using an unoptimized C++ standard library, which results in the 88 KB binary size. </span><span class="koboSpan" id="kobo.587.3">A size-optimized standard C++ library can be built from sources with enabled exceptions, which would help reduce the binary footprint.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.588.1">If an exception is not caught, </span><code class="inlineCode"><span class="koboSpan" id="kobo.589.1">std::terminate_handler</span></code><span class="koboSpan" id="kobo.590.1"> will be called. </span><span class="koboSpan" id="kobo.590.2">We can replace the default handler using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.591.1">std::set_terminate</span></code><span class="koboSpan" id="kobo.592.1"> function as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.593.1">    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.594.1">set_terminate</span></span><span class="koboSpan" id="kobo.595.1">([]() {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.596.1">printf</span></span><span class="koboSpan" id="kobo.597.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.598.1">"My terminate handler!\r\n"</span></span><span class="koboSpan" id="kobo.599.1">);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.600.1">while</span></span><span class="koboSpan" id="kobo.601.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.602.1">true</span></span><span class="koboSpan" id="kobo.603.1">){}
    });
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.604.1">In the preceding example, we provided a lambda as a terminate handler. </span><span class="koboSpan" id="kobo.604.2">As an exercise, try to access the array from the previous example with an index that is out of range, but out of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.605.1">try</span></code><span class="koboSpan" id="kobo.606.1"> block. </span><span class="koboSpan" id="kobo.606.2">This should trigger the terminate handler and make a call to the lambda we passed to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.607.1">std::set_terminate</span></code><span class="koboSpan" id="kobo.608.1"> function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.609.1">Exceptions are </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.610.1">propagated up the call stack. </span><span class="koboSpan" id="kobo.610.2">Let us go through the following example to demonstrate exception propagation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.611.1">template</span></span><span class="koboSpan" id="kobo.612.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.613.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.614.1">T</span></span><span class="koboSpan" id="kobo.615.1">, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.616.1">size_t</span></span><span class="koboSpan" id="kobo.617.1"> N&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.618.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.619.1">ring_buffer</span></span><span class="koboSpan" id="kobo.620.1"> {
  std::array&lt;T, N&gt; arr;
  std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.621.1">size_t</span></span><span class="koboSpan" id="kobo.622.1"> write_idx = </span><span class="hljs-number"><span class="koboSpan" id="kobo.623.1">0</span></span><span class="koboSpan" id="kobo.624.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.625.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.626.1">push</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.627.1">(T t)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.628.1">{
    arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.629.1">at</span></span><span class="koboSpan" id="kobo.630.1">(write_idx++) = t;
  }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.631.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.632.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.633.1">()</span></span><span class="koboSpan" id="kobo.634.1">
{
    ring_buffer&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.635.1">int</span></span><span class="koboSpan" id="kobo.636.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.637.1">4</span></span><span class="koboSpan" id="kobo.638.1">&gt; rb;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.639.1">try</span></span><span class="koboSpan" id="kobo.640.1"> {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.641.1">for</span></span><span class="koboSpan" id="kobo.642.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.643.1">int</span></span><span class="koboSpan" id="kobo.644.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.645.1">0</span></span><span class="koboSpan" id="kobo.646.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.647.1">6</span></span><span class="koboSpan" id="kobo.648.1">; i++) {
        rb.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.649.1">push</span></span><span class="koboSpan" id="kobo.650.1">(i);
      }
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.651.1">catch</span></span><span class="koboSpan" id="kobo.652.1">(std::out_of_range &amp;e) {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.653.1">printf</span></span><span class="koboSpan" id="kobo.654.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.655.1">"Ring buffer out of range!\r\n"</span></span><span class="koboSpan" id="kobo.656.1">);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.657.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.658.1">0</span></span><span class="koboSpan" id="kobo.659.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.660.1">The preceding example is based on a ring buffer from previous chapters that uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.661.1">std::array</span></code><span class="koboSpan" id="kobo.662.1"> as an underlying container. </span><span class="koboSpan" id="kobo.662.2">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.663.1">push</span></code><span class="koboSpan" id="kobo.664.1"> method, it doesn’t check the write index, meaning that the array’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.665.1">at</span></code><span class="koboSpan" id="kobo.666.1"> method will throw an exception if we call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.667.1">push</span></code><span class="koboSpan" id="kobo.668.1"> method more than </span><code class="inlineCode"><span class="koboSpan" id="kobo.669.1">N</span></code><span class="koboSpan" id="kobo.670.1"> times. </span><span class="koboSpan" id="kobo.670.2">An exception is thrown in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.671.1">push</span></code><span class="koboSpan" id="kobo.672.1"> method, where there is no </span><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">try-catch</span></code><span class="koboSpan" id="kobo.674.1"> block, and it gets caught only in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">main</span></code><span class="koboSpan" id="kobo.676.1"> function in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.677.1">catch</span></code><span class="koboSpan" id="kobo.678.1"> block.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.679.1">You can run the preceding example in the Renode simulator using the following instructions. </span><span class="koboSpan" id="kobo.679.2">Start Visual Studio Code, attach it to the running container, open </span><code class="inlineCode"><span class="koboSpan" id="kobo.680.1">Chapter07/error_handling project</span></code><span class="koboSpan" id="kobo.681.1"> as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.682.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.683.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.684.1">$ cd Chapter07/error_handling
$ cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_exceptions.cpp
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.685.1">Exception propagation is useful for the type of errors that we don’t want to propagate between the software layers manually using error codes. </span><span class="koboSpan" id="kobo.685.2">However, the problem with exceptions is that they are not visible from function declarations as is the case with error codes. </span><span class="koboSpan" id="kobo.685.3">We need to </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.686.1">rely on good documentation to know which function throws an error and where those errors are handled.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.687.1">There is a saying that exceptions are used for exceptional errors that are very rare. </span><span class="koboSpan" id="kobo.687.2">But what are exceptional errors? </span><span class="koboSpan" id="kobo.687.3">That depends on the library, application, and use case. </span><span class="koboSpan" id="kobo.687.4">It is hard to generalize. </span><span class="koboSpan" id="kobo.687.5">A failed read to the accelerometer may be a recoverable error that is solved by resetting it. </span><span class="koboSpan" id="kobo.687.6">We can throw an exception on a failed I</span><sup class="superscript"><span class="koboSpan" id="kobo.688.1">2</span></sup><span class="koboSpan" id="kobo.689.1">C bus communication, and the upper layer that catches this error may decide to try resetting the accelerometer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.690.1">Failing to control boost voltage regulator output by DAC may also be recoverable, but we may want to terminate the program as we are implementing a medical device and that may be the best action possible to prevent any damage to a user. </span><span class="koboSpan" id="kobo.690.2">In this case, we want to react as fast as possible and exception propagation and stack unwinding are probably not desirable so we will rely on a global handler or asserts instead.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.691.1">Exceptions come with a price, both in flash and RAM memory consumption, and the execution time can’t always be guaranteed, which is a problem if we are working with hard real-time systems. </span><span class="koboSpan" id="kobo.691.2">But they also solve the problem of error propagation and enforce error handling. </span><span class="koboSpan" id="kobo.691.3">If there is not a </span><code class="inlineCode"><span class="koboSpan" id="kobo.692.1">catch</span></code><span class="koboSpan" id="kobo.693.1"> clause for a specific type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.694.1">std::terminate_handler</span></code><span class="koboSpan" id="kobo.695.1"> will be called, and the program will not continue with the execution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.696.1">Error codes and exceptions can co-exist, and they often do. </span><span class="koboSpan" id="kobo.696.2">Embedded C++ projects often use C libraries, or legacy C++ code, which often uses error codes. </span><span class="koboSpan" id="kobo.696.3">We can benefit from exceptions by using them for very rare errors, adding additional robustness to our firmware. </span><span class="koboSpan" id="kobo.696.4">Still, the decision of whether to use them is influenced by available memory resources and the type of project we are working on.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.697.1">Next, we will cover the C++ </span><code class="inlineCode"><span class="koboSpan" id="kobo.698.1">std::optional</span></code><span class="koboSpan" id="kobo.699.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">std::expected</span></code><span class="koboSpan" id="kobo.701.1"> template classes, which are used as return types from functions.</span></p>
<h1 class="heading-1" id="_idParaDest-118"><span class="koboSpan" id="kobo.702.1">std:: optional and std::expected</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.703.1">C++17 introduced </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">std::optional</span></code><span class="koboSpan" id="kobo.705.1">, a template </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.706.1">class that either has a value or </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.707.1">has nothing. </span><span class="koboSpan" id="kobo.707.2">This is useful for situations where a function may or may not return a value. </span><span class="koboSpan" id="kobo.707.3">To better understand it, let’s go through the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.708.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.709.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.710.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.711.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.712.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.713.1">&lt;optional&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.714.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.715.1">sensor</span></span><span class="koboSpan" id="kobo.716.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.717.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.718.1">data</span></span><span class="koboSpan" id="kobo.719.1"> {
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.720.1">int</span></span><span class="koboSpan" id="kobo.721.1"> x;
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.722.1">int</span></span><span class="koboSpan" id="kobo.723.1"> y;
    };
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.724.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.725.1">inline</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.726.1">bool</span></span><span class="koboSpan" id="kobo.727.1"> ret_val = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.728.1">true</span></span><span class="koboSpan" id="kobo.729.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.730.1">static</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.731.1"> std::optional&lt;data&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.732.1">get_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.733.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.734.1">{
        ret_val = !ret_val;
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.735.1">if</span></span><span class="koboSpan" id="kobo.736.1">(ret_val) {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.737.1">return</span></span><span class="koboSpan" id="kobo.738.1"> data{</span><span class="hljs-number"><span class="koboSpan" id="kobo.739.1">4</span></span><span class="koboSpan" id="kobo.740.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.741.1">5</span></span><span class="koboSpan" id="kobo.742.1">};
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.743.1">else</span></span><span class="koboSpan" id="kobo.744.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.745.1">return</span></span><span class="koboSpan" id="kobo.746.1"> std::</span><span class="hljs-literal"><span class="koboSpan" id="kobo.747.1">nullopt</span></span><span class="koboSpan" id="kobo.748.1">;
        }
    }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.749.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.750.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.751.1">()</span></span><span class="koboSpan" id="kobo.752.1">
{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.753.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.754.1">auto</span></span><span class="koboSpan" id="kobo.755.1"> get_data_from_main = [] () {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.756.1">auto</span></span><span class="koboSpan" id="kobo.757.1"> result = sensor::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.758.1">get_data</span></span><span class="koboSpan" id="kobo.759.1">();
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.760.1">if</span></span><span class="koboSpan" id="kobo.761.1">(result) {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.762.1">printf</span></span><span class="koboSpan" id="kobo.763.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.764.1">"x = %d, y = %d\r\n"</span></span><span class="koboSpan" id="kobo.765.1">, (*result).x, (*result).y);
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.766.1">else</span></span><span class="koboSpan" id="kobo.767.1"> {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.768.1">printf</span></span><span class="koboSpan" id="kobo.769.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.770.1">"No data!\r\n"</span></span><span class="koboSpan" id="kobo.771.1">);
        }
    };
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.772.1">get_data_from_main</span></span><span class="koboSpan" id="kobo.773.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.774.1">get_data_from_main</span></span><span class="koboSpan" id="kobo.775.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.776.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.777.1">0</span></span><span class="koboSpan" id="kobo.778.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.779.1">In the </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.780.1">preceding example, we have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.781.1">sensor</span></code><span class="koboSpan" id="kobo.782.1"> struct with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.783.1">get_data</span></code><span class="koboSpan" id="kobo.784.1"> method, which </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.785.1">returns a value if some conditions are met. </span><span class="koboSpan" id="kobo.785.2">Otherwise, it doesn’t return it. </span><span class="koboSpan" id="kobo.785.3">The sensor is not in an erroneous state, it just doesn’t have data ready yet. </span><span class="koboSpan" id="kobo.785.4">For this, we are using </span><code class="inlineCode"><span class="koboSpan" id="kobo.786.1">std::optional&lt;data&gt;</span></code><span class="koboSpan" id="kobo.787.1"> to declare that the sensor may or may not return the </span><code class="inlineCode"><span class="koboSpan" id="kobo.788.1">data</span></code><span class="koboSpan" id="kobo.789.1"> struct. </span><span class="koboSpan" id="kobo.789.2">We used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.790.1">ret_val</span></code><span class="koboSpan" id="kobo.791.1"> bool to simulate data being ready at every second call of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.792.1">get_data</span></code><span class="koboSpan" id="kobo.793.1"> function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.794.1">In the main, we created the </span><code class="inlineCode"><span class="koboSpan" id="kobo.795.1">get_data_from_main</span></code><span class="koboSpan" id="kobo.796.1"> lambda, which makes a call to the sensor’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.797.1">get_data</span></code><span class="koboSpan" id="kobo.798.1">. </span><span class="koboSpan" id="kobo.798.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.799.1">std::optional&lt;data&gt;</span></code><span class="koboSpan" id="kobo.800.1"> return value is converted to a bool in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.801.1">if</span></code><span class="koboSpan" id="kobo.802.1"> statement. </span><span class="koboSpan" id="kobo.802.2">If it is </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.803.1">converted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.804.1">true</span></code><span class="koboSpan" id="kobo.805.1">, it means it holds data, else it holds nothing. </span><span class="koboSpan" id="kobo.805.2">We </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.806.1">access the </span><code class="inlineCode"><span class="koboSpan" id="kobo.807.1">data</span></code><span class="koboSpan" id="kobo.808.1"> type by dereferencing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.809.1">result</span></code><span class="koboSpan" id="kobo.810.1"> object.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.811.1">C++ 23 introduced </span><code class="inlineCode"><span class="koboSpan" id="kobo.812.1">std::expected&lt;T, E&gt;</span></code><span class="koboSpan" id="kobo.813.1">, a template class that either holds an expected object of class </span><code class="inlineCode"><span class="koboSpan" id="kobo.814.1">T</span></code><span class="koboSpan" id="kobo.815.1"> or an unexpected object of class </span><code class="inlineCode"><span class="koboSpan" id="kobo.816.1">E</span></code><span class="koboSpan" id="kobo.817.1">. </span><span class="koboSpan" id="kobo.817.2">To understand this better, let us go through the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.818.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.819.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.820.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.821.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.822.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.823.1">&lt;expected&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.824.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.825.1">ble_light_bulb</span></span><span class="koboSpan" id="kobo.826.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.827.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.828.1">error</span></span><span class="koboSpan" id="kobo.829.1"> {
        disconnected,
        timeout
    };
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.830.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.831.1">config</span></span><span class="koboSpan" id="kobo.832.1"> {
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.833.1">int</span></span><span class="koboSpan" id="kobo.834.1"> r;
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.835.1">int</span></span><span class="koboSpan" id="kobo.836.1"> g;
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.837.1">int</span></span><span class="koboSpan" id="kobo.838.1"> b;
    };
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.839.1">bool</span></span><span class="koboSpan" id="kobo.840.1"> ret_val;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.841.1">std::expected&lt;config, error&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.842.1">get_config</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.843.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.844.1">{
        ret_val = !ret_val;
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.845.1">if</span></span><span class="koboSpan" id="kobo.846.1">(ret_val) {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.847.1">return</span></span><span class="koboSpan" id="kobo.848.1"> config {</span><span class="hljs-number"><span class="koboSpan" id="kobo.849.1">10</span></span><span class="koboSpan" id="kobo.850.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.851.1">20</span></span><span class="koboSpan" id="kobo.852.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.853.1">30</span></span><span class="koboSpan" id="kobo.854.1">};
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.855.1">else</span></span><span class="koboSpan" id="kobo.856.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.857.1">return</span></span><span class="koboSpan" id="kobo.858.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.859.1">unexpected</span></span><span class="koboSpan" id="kobo.860.1">(error::timeout);
        }
    }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.861.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.862.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.863.1">()</span></span><span class="koboSpan" id="kobo.864.1">
{  
    ble_light_bulb bulb;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.865.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.866.1">auto</span></span><span class="koboSpan" id="kobo.867.1"> get_config_from_main = [&amp;bulb]() {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.868.1">auto</span></span><span class="koboSpan" id="kobo.869.1"> result = bulb.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.870.1">get_config</span></span><span class="koboSpan" id="kobo.871.1">();
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.872.1">if</span></span><span class="koboSpan" id="kobo.873.1">(result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.874.1">has_value</span></span><span class="koboSpan" id="kobo.875.1">()) {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.876.1">auto</span></span><span class="koboSpan" id="kobo.877.1"> conf = result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.878.1">value</span></span><span class="koboSpan" id="kobo.879.1">();
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.880.1">printf</span></span><span class="koboSpan" id="kobo.881.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.882.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.883.1">Config r %d, g %d, b %d\r\n"</span></span><span class="koboSpan" id="kobo.884.1">, conf.r, conf.g, conf.b);
        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.885.1">else</span></span><span class="koboSpan" id="kobo.886.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.887.1">auto</span></span><span class="koboSpan" id="kobo.888.1"> err = result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.889.1">error</span></span><span class="koboSpan" id="kobo.890.1">();
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.891.1">using</span></span><span class="koboSpan" id="kobo.892.1"> bulb_error = ble_light_bulb::error;
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.893.1">if</span></span><span class="koboSpan" id="kobo.894.1">(err == bulb_error::disconnected) {
                </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.895.1">printf</span></span><span class="koboSpan" id="kobo.896.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.897.1">"The bulb is disconnected!\r\n"</span></span><span class="koboSpan" id="kobo.898.1">);
            }
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.899.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.900.1">if</span></span><span class="koboSpan" id="kobo.901.1">(err == bulb_error::timeout) {
                </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.902.1">printf</span></span><span class="koboSpan" id="kobo.903.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.904.1">"Timeout!\r\n"</span></span><span class="koboSpan" id="kobo.905.1">);
            }
        }
    };
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.906.1">get_config_from_main</span></span><span class="koboSpan" id="kobo.907.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.908.1">get_config_from_main</span></span><span class="koboSpan" id="kobo.909.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.910.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.911.1">0</span></span><span class="koboSpan" id="kobo.912.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.913.1">In the preceding </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.914.1">example, we have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.915.1">ble_light_bulb</span></code><span class="koboSpan" id="kobo.916.1"> struct, a BLE (Bluetooth Low Energy) light bulb, with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">get_config</span></code><span class="koboSpan" id="kobo.918.1"> method, which reads some config data over </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.919.1">the BLE connection from the bulb. </span><span class="koboSpan" id="kobo.919.2">This method returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">config</span></code><span class="koboSpan" id="kobo.921.1">, or an </span><code class="inlineCode"><span class="koboSpan" id="kobo.922.1">error</span></code><span class="koboSpan" id="kobo.923.1">. </span><span class="koboSpan" id="kobo.923.2">In </span><code class="inlineCode"><span class="koboSpan" id="kobo.924.1">main</span></code><span class="koboSpan" id="kobo.925.1">, we defined the </span><code class="inlineCode"><span class="koboSpan" id="kobo.926.1">get_config_from_main</span></code><span class="koboSpan" id="kobo.927.1"> lambda, which calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.928.1">get_config</span></code><span class="koboSpan" id="kobo.929.1"> on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">ble_light_bulb</span></code><span class="koboSpan" id="kobo.931.1"> object. </span><span class="koboSpan" id="kobo.931.2">We use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.932.1">has_value</span></code><span class="koboSpan" id="kobo.933.1"> method on the expected returned object to check if it holds an expected value. </span><span class="koboSpan" id="kobo.933.2">We use </span><code class="inlineCode"><span class="koboSpan" id="kobo.934.1">value</span></code><span class="koboSpan" id="kobo.935.1"> methods to access the expected value or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.936.1">error</span></code><span class="koboSpan" id="kobo.937.1"> method to access the </span><code class="inlineCode"><span class="koboSpan" id="kobo.938.1">error</span></code><span class="koboSpan" id="kobo.939.1"> object.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.940.1">You can run the preceding example in the Renode simulator using the following instructions. </span><span class="koboSpan" id="kobo.940.2">Start Visual Studio Code, attach it to the running container, open </span><code class="inlineCode"><span class="koboSpan" id="kobo.941.1">Chapter07/error_handling project</span></code><span class="koboSpan" id="kobo.942.1"> as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.943.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.944.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.945.1">$ cd Chapter07/error_handling
$ cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_expected.cpp
$ cmake --build build --target run_in_renode
</span></code></pre>
<h1 class="heading-1" id="_idParaDest-119"><span class="koboSpan" id="kobo.946.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.947.1">In this chapter, we analyzed different error-handling strategies in C++. </span><span class="koboSpan" id="kobo.947.2">We went through error codes, global handlers, asserts, exceptions, </span><code class="inlineCode"><span class="koboSpan" id="kobo.948.1">std::optional</span></code><span class="koboSpan" id="kobo.949.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.950.1">std::expected</span></code><span class="koboSpan" id="kobo.951.1">. </span><span class="koboSpan" id="kobo.951.2">We learned the pros and cons of each and in which situations it makes sense to apply them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.952.1">In the next chapter, we will cover templates in more detail.</span></p>
<h1 class="heading-1" id="_idParaDest-120"><span class="koboSpan" id="kobo.953.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.954.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="https://packt.link/embeddedsystems"><span class="url"><span class="koboSpan" id="kobo.955.1">https://packt.link/embeddedsystems</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.956.1"><img alt="" role="presentation" src="../Images/QR_code_Discord.png"/></span></p>
</div>
</body></html>