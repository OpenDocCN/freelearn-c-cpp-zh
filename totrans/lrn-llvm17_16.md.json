["```cpp\n\nCCIfType<[i32],\n         CCAssignToReg<[R2, R3, R4, R5, R6, R7, R8, R9]>>,\n```", "```cpp\n\nCCAssignToStack<4, 4>\n```", "```cpp\n\n    def CC_M88k : CallingConv<[\n      CCIfType<[i8, i16], CCPromoteToType<i32>>,\n      CCIfType<[i32,f32],\n            CCAssignToReg<[R2, R3, R4, R5, R6, R7, R8, R9]>>,\n      CCAssignToStack<4, 4>\n    ]>;\n    ```", "```cpp\n\n    def RetCC_M88k : CallingConv<[\n      CCIfType<[i32], CCAssignToReg<[R2]>>\n    ]>;\n    ```", "```cpp\n\n    def CSR_M88k :\n        CalleeSavedRegs<(add R1, R30,\n                             (sequence \"R%d\", 25,  14))>;\n    ```", "```cpp\n\ndefine i32 @f1(i32 %a, i32 %b) {\n  %res = and i32 %a, %b\n  ret i32 %res\n}\n```", "```cpp\n\n    M88kTargetLowering::M88kTargetLowering(\n        const TargetMachine &TM, const M88kSubtarget &STI)\n        : TargetLowering(TM), Subtarget(STI) {\n    ```", "```cpp\n\n      addRegisterClass(MVT::i32, &M88k::GPRRegClass);\n    ```", "```cpp\n\n    computeRegisterProperties(Subtarget.getRegisterInfo());\n    ```", "```cpp\n\n      setStackPointerRegisterToSaveRestore(M88k::R31);\n    ```", "```cpp\n\n      setBooleanContents(ZeroOrOneBooleanContent);\n    ```", "```cpp\n\n      setMinFunctionAlignment(Align(4));\n      setPrefFunctionAlignment(Align(4));\n    ```", "```cpp\n\n      setOperationAction(ISD::AND, MVT::i32, Legal);\n      setOperationAction(ISD::OR, MVT::i32, Legal);\n      setOperationAction(ISD::XOR, MVT::i32, Legal);\n    ```", "```cpp\n\n      setOperationAction(ISD::CTPOP, MVT::i32, Expand);\n    }\n    ```", "```cpp\n\nlet isCommutable = 1 in\n  def ANDrr : F_LR<0b01000, Func, /*comp=*/0b0, \"and\",\n                   [(set i32:$rd,\n                       (and GPROpnd:$rs1, GPROpnd:$rs2))]>;\n```", "```cpp\n\n    #include \"M88kGenCallingConv.inc\"\n    ```", "```cpp\n\n    SDValue M88kTargetLowering::LowerFormalArguments(\n        SDValue Chain, CallingConv::ID CallConv,\n        bool IsVarArg,\n        const SmallVectorImpl<ISD::InputArg> &Ins,\n        const SDLoc &DL, SelectionDAG &DAG,\n        SmallVectorImpl<SDValue> &InVals) const {\n    ```", "```cpp\n\n      MachineFunction &MF = DAG.getMachineFunction();\n      MachineRegisterInfo &MRI = MF.getRegInfo();\n    ```", "```cpp\n\n      SmallVector<CCValAssign, 16> ArgLocs;\n      CCState CCInfo(CallConv, IsVarArg, MF, ArgLocs,\n                     *DAG.getContext());\n      CCInfo.AnalyzeFormalArguments(Ins, CC_M88k);\n    ```", "```cpp\n\n      for (unsigned I = 0, E = ArgLocs.size(); I != E; ++I) {\n        SDValue ArgValue;\n        CCValAssign &VA = ArgLocs[I];\n        EVT LocVT = VA.getLocVT();\n    ```", "```cpp\n\n        if (VA.isRegLoc()) {\n          const TargetRegisterClass *RC;\n          switch (LocVT.getSimpleVT().SimpleTy) {\n          default:\n            llvm_unreachable(\"Unexpected argument type\");\n          case MVT::i32:\n            RC = &M88k::GPRRegClass;\n            break;\n          }\n    ```", "```cpp\n\n          Register VReg = MRI.createVirtualRegister(RC);\n          MRI.addLiveIn(VA.getLocReg(), VReg);\n          ArgValue =\n              DAG.getCopyFromReg(Chain, DL, VReg, LocVT);\n    ```", "```cpp\n\n          if (VA.getLocInfo() == CCValAssign::SExt)\n            ArgValue = DAG.getNode(\n                ISD::AssertSext, DL, LocVT, ArgValue,\n                DAG.getValueType(VA.getValVT()));\n          else if (VA.getLocInfo() == CCValAssign::ZExt)\n            ArgValue = DAG.getNode(\n                ISD::AssertZext, DL, LocVT, ArgValue,\n                DAG.getValueType(VA.getValVT()));\n          if (VA.getLocInfo() != CCValAssign::Full)\n            ArgValue = DAG.getNode(ISD::TRUNCATE, DL,\n                                   VA.getValVT(), ArgValue);\n    ```", "```cpp\n\n          InVals.push_back(ArgValue);\n        }\n    ```", "```cpp\n\n        } else {\n          llvm_unreachable(\"Not implemented\");\n        }\n      }\n    ```", "```cpp\n\n      assert(!IsVarArg && \"Not implemented\");\n    ```", "```cpp\n\n      return Chain;\n    }\n    ```", "```cpp\n\ndef retglue : SDNode<\"M88kISD::RET_GLUE\", SDTNone,\n                 [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;\n```", "```cpp\n\nlet isReturn = 1, isTerminator = 1, isBarrier = 1,\n    AsmString = \"RET\" in\n  def RET : Pseudo<(outs), (ins), [(retglue)]>;\n```", "```cpp\n\n    SDValue M88kTargetLowering::LowerReturn(\n        SDValue Chain, CallingConv::ID CallConv,\n        bool IsVarArg,\n        const SmallVectorImpl<ISD::OutputArg> &Outs,\n        const SmallVectorImpl<SDValue> &OutVals,\n        const SDLoc &DL, SelectionDAG &DAG) const {\n    ```", "```cpp\n\n      SmallVector<CCValAssign, 16> RetLocs;\n      CCState RetCCInfo(CallConv, IsVarArg,\n                        DAG.getMachineFunction(), RetLocs,\n                        *DAG.getContext());\n      RetCCInfo.AnalyzeReturn(Outs, RetCC_M88k);\n    ```", "```cpp\n\n      SDValue Glue;\n      SmallVector<SDValue, 4> RetOps(1, Chain);\n      for (unsigned I = 0, E = RetLocs.size(); I != E; ++I) {\n        CCValAssign &VA = RetLocs[I];\n    ```", "```cpp\n\n        Register Reg = VA.getLocReg();\n        Chain = DAG.getCopyToReg(Chain, DL, Reg, OutVals[I],\n                                 Glue);\n        Glue = Chain.getValue(1);\n        RetOps.push_back(\n            DAG.getRegister(Reg, VA.getLocVT()));\n      }\n    ```", "```cpp\n\n      RetOps[0] = Chain;\n      if (Glue.getNode())\n        RetOps.push_back(Glue);\n    ```", "```cpp\n\n      return DAG.getNode(M88kISD::RET_GLUE, DL, MVT::Other,\n                         RetOps);\n    }\n    ```", "```cpp\n\n    #define DEBUG_TYPE \"m88k-isel\"\n    #define PASS_NAME\n                \"M88k DAG->DAG Pattern Instruction Selection\"\n    ```", "```cpp\n\n    class M88kDAGToDAGISel : public SelectionDAGISel {\n    public:\n      static char ID;\n      M88kDAGToDAGISel(M88kTargetMachine &TM,\n                       CodeGenOpt::Level OptLevel)\n          : SelectionDAGISel(ID, TM, OptLevel) {}\n      void Select(SDNode *Node) override;\n    #include \"M88kGenDAGISel.inc\"\n    };\n    } // end anonymous namespace\n    ```", "```cpp\n\n    char M88kDAGToDAGISel::ID = 0;\n    INITIALIZE_PASS(M88kDAGToDAGISel, DEBUG_TYPE, PASS_NAME,\n                    false, false)\n    FunctionPass *\n    llvm::createM88kISelDag(M88kTargetMachine &TM,\n                            CodeGenOpt::Level OptLevel) {\n      return new M88kDAGToDAGISel(TM, OptLevel);\n    }\n    ```", "```cpp\n\n    void M88kDAGToDAGISel::Select(SDNode *Node) {\n      SelectCode(Node);\n    }\n    ```", "```cpp\n\n    #define GET_REGINFO_HEADER\n    #include \"M88kGenRegisterInfo.inc\"\n    ```", "```cpp\n\n    namespace llvm {\n    struct M88kRegisterInfo : public M88kGenRegisterInfo {\n      M88kRegisterInfo();\n      const MCPhysReg *getCalleeSavedRegs(\n          const MachineFunction *MF) const override;\n      BitVector getReservedRegs(\n          const MachineFunction &MF) const override;\n      bool eliminateFrameIndex(\n          MachineBasicBlock::iterator II, int SPAdj,\n          unsigned FIOperandNum,\n          RegScavenger *RS = nullptr) const override;\n      Register getFrameRegister(\n          const MachineFunction &MF) const override;\n    };\n    } // end namespace llvm\n    ```", "```cpp\n\n    #define GET_REGINFO_TARGET_DESC\n    #include \"M88kGenRegisterInfo.inc\"\n    ```", "```cpp\n\n    M88kRegisterInfo::M88kRegisterInfo()\n        : M88kGenRegisterInfo(M88k::R1) {}\n    ```", "```cpp\n\n    const MCPhysReg *M88kRegisterInfo::getCalleeSavedRegs(\n        const MachineFunction *MF) const {\n      return CSR_M88k_SaveList;\n    }\n    ```", "```cpp\n\n    BitVector M88kRegisterInfo::getReservedRegs(\n        const MachineFunction &MF) const {\n      BitVector Reserved(getNumRegs());\n      Reserved.set(M88k::R0);\n      Reserved.set(M88k::R28);\n      Reserved.set(M88k::R29);\n      Reserved.set(M88k::R31);\n      return Reserved;\n    }\n    ```", "```cpp\n\n    Register M88kRegisterInfo::getFrameRegister(\n        const MachineFunction &MF) const {\n      return M88k::R30;\n    }\n    ```", "```cpp\n\n    bool M88kRegisterInfo::eliminateFrameIndex(\n        MachineBasicBlock::iterator MI, int SPAdj,\n        unsigned FIOperandNum, RegScavenger *RS) const {\n      return false;\n    }\n    ```", "```cpp\n\n    #define GET_INSTRINFO_HEADER\n    #include \"M88kGenInstrInfo.inc\"\n    ```", "```cpp\n\n    namespace llvm {\n    class M88kInstrInfo : public M88kGenInstrInfo {\n      const M88kRegisterInfo RI;\n      [[maybe_unused]] M88kSubtarget &STI;\n      virtual void anchor();\n    public:\n      explicit M88kInstrInfo(M88kSubtarget &STI);\n      const M88kRegisterInfo &getRegisterInfo() const {\n        return RI;\n      }\n      bool\n      expandPostRAPseudo(MachineInstr &MI) const override;\n    } // end namespace llvm\n    ```", "```cpp\n\n    #define GET_INSTRINFO_CTOR_DTOR\n    #define GET_INSTRMAP_INFO\n    #include \"M88kGenInstrInfo.inc\"\n    ```", "```cpp\n\n    void M88kInstrInfo::anchor() {}\n    ```", "```cpp\n\n    bool M88kInstrInfo::expandPostRAPseudo(\n        MachineInstr &MI) const {\n      MachineBasicBlock &MBB = *MI.getParent();\n      switch (MI.getOpcode()) {\n      default:\n        return false;\n      case M88k::RET: {\n        MachineInstrBuilder MIB =\n            BuildMI(MBB, &MI, MI.getDebugLoc(),\n                    get(M88k::JMP))\n                .addReg(M88k::R1, RegState::Undef);\n        for (auto &MO : MI.operands()) {\n          if (MO.isImplicit())\n            MIB.add(MO);\n        }\n        break;\n      }\n      }\n      MBB.erase(MI);\n      return true;\n    }\n    ```", "```cpp\n\nnamespace llvm {\nclass M88kFrameLowering : public TargetFrameLowering {\npublic:\n  M88kFrameLowering();\n  void\n  emitPrologue(MachineFunction &MF,\n               MachineBasicBlock &MBB) const override;\n  void\n  emitEpilogue(MachineFunction &MF,\n               MachineBasicBlock &MBB) const override;\n  bool hasFP(const MachineFunction &MF) const override;\n};\n}\n```", "```cpp\n\nM88kFrameLowering::M88kFrameLowering()\n    : TargetFrameLowering(\n          TargetFrameLowering::StackGrowsDown, Align(8),\n          0, Align(8), false /* StackRealignable */) {}\nvoid M88kFrameLowering::emitPrologue(\n    MachineFunction &MF, MachineBasicBlock &MBB) const {}\nvoid M88kFrameLowering::emitEpilogue(\n    MachineFunction &MF, MachineBasicBlock &MBB) const {}\nbool M88kFrameLowering::hasFP(\n    const MachineFunction &MF) const { return false; }\n```", "```cpp\n\n    namespace {\n    class M88kAsmPrinter : public AsmPrinter {\n    public:\n      explicit M88kAsmPrinter(\n          TargetMachine &TM,\n          std::unique_ptr<MCStreamer> Streamer)\n          : AsmPrinter(TM, std::move(Streamer)) {}\n      StringRef getPassName() const override {\n        return \"M88k Assembly Printer\";\n      }\n      void emitInstruction(const MachineInstr *MI) override;\n    };\n    } // end of anonymous namespace\n    ```", "```cpp\n\n    extern \"C\" LLVM_EXTERNAL_VISIBILITY void\n    LLVMInitializeM88kAsmPrinter() {\n      RegisterAsmPrinter<M88kAsmPrinter> X(\n          getTheM88kTarget());\n    }\n    ```", "```cpp\n\n    void M88kAsmPrinter::emitInstruction(\n        const MachineInstr *MI) {\n      MCInst LoweredMI;\n      M88kMCInstLower Lower(MF->getContext(), *this);\n      Lower.lower(MI, LoweredMI);\n      EmitToStreamer(*OutStreamer, LoweredMI);\n    }\n    ```", "```cpp\n\nclass LLVM_LIBRARY_VISIBILITY M88kMCInstLower {\npublic:\n  void lower(const MachineInstr *MI, MCInst &OutMI) const;\n  MCOperand lowerOperand(const MachineOperand &MO) const;\n};\n```", "```cpp\n\n    MCOperand M88kMCInstLower::lowerOperand(\n        const MachineOperand &MO) const {\n      switch (MO.getType()) {\n      case MachineOperand::MO_Register:\n        return MCOperand::createReg(MO.getReg());\n      case MachineOperand::MO_Immediate:\n        return MCOperand::createImm(MO.getImm());\n      default:\n        llvm_unreachable(\"Operand type not handled\");\n      }\n    }\n    ```", "```cpp\n\n    void M88kMCInstLower::lower(const MachineInstr *MI,\n                                MCInst &OutMI) const {\n      OutMI.setOpcode(MI->getOpcode());\n      for (auto &MO : MI->operands()) {\n        if (!MO.isReg() || !MO.isImplicit())\n          OutMI.addOperand(lowerOperand(MO));\n      }\n    }\n    ```", "```cpp\n\n    #define GET_SUBTARGETINFO_HEADER\n    #include \"M88kGenSubtargetInfo.inc\"\n    ```", "```cpp\n\n    namespace llvm {\n    class StringRef;\n    class TargetMachine;\n    class M88kSubtarget : public M88kGenSubtargetInfo {\n      virtual void anchor();\n      Triple TargetTriple;\n      M88kInstrInfo InstrInfo;\n      M88kTargetLowering TLInfo;\n      M88kFrameLowering FrameLowering;\n    ```", "```cpp\n\n    public:\n      M88kSubtarget(const Triple &TT,\n                    const std::string &CPU,\n                    const std::string &FS,\n                    const TargetMachine &TM);\n    ```", "```cpp\n\n    #define GET_SUBTARGETINFO_MACRO(ATTRIBUTE, DEFAULT,    \\\n                                    GETTER)                \\\n      bool GETTER() const { return ATTRIBUTE; }\n    #include \"M88kGenSubtargetInfo.inc\"\n    ```", "```cpp\n\n      void ParseSubtargetFeatures(StringRef CPU,\n                                  StringRef TuneCPU,\n                                  StringRef FS);\n    ```", "```cpp\n\n      const TargetFrameLowering *\n      getFrameLowering() const override {\n        return &FrameLowering;\n      }\n      const M88kInstrInfo *getInstrInfo() const override {\n        return &InstrInfo;\n      }\n      const M88kTargetLowering *\n      getTargetLowering() const override {\n        return &TLInfo;\n      }\n    ```", "```cpp\n\n      const M88kRegisterInfo *\n      getRegisterInfo() const override {\n        return &InstrInfo.getRegisterInfo();\n      }\n    };\n    } // end namespace llvm\n    ```", "```cpp\n\n    #define GET_SUBTARGETINFO_TARGET_DESC\n    #define GET_SUBTARGETINFO_CTOR\n    #include \"M88kGenSubtargetInfo.inc\"\n    ```", "```cpp\n\n    void M88kSubtarget::anchor() {}\n    ```", "```cpp\n\n    M88kSubtarget::M88kSubtarget(const Triple &TT,\n                                 const std::string &CPU,\n                                 const std::string &FS,\n                                 const TargetMachine &TM)\n        : M88kGenSubtargetInfo(TT, CPU, /*TuneCPU*/ CPU, FS),\n          TargetTriple(TT), InstrInfo(*this),\n          TLInfo(TM, *this), FrameLowering() {}\n    ```", "```cpp\n\n    namespace llvm {\n    class M88kTargetMachine : public LLVMTargetMachine {\n      std::unique_ptr<TargetLoweringObjectFile> TLOF;\n      mutable StringMap<std::unique_ptr<M88kSubtarget>>\n          SubtargetMap;\n    ```", "```cpp\n\n    public:\n      M88kTargetMachine(const Target &T, const Triple &TT,\n                        StringRef CPU, StringRef FS,\n                        const TargetOptions &Options,\n                        std::optional<Reloc::Model> RM,\n                        std::optional<CodeModel::Model> CM,\n                        CodeGenOpt::Level OL, bool JIT);\n    ```", "```cpp\n\n      ~M88kTargetMachine() override;\n      const M88kSubtarget *\n      getSubtargetImpl(const Function &) const override;\n      TargetPassConfig *\n      createPassConfig(PassManagerBase &PM) override;\n      TargetLoweringObjectFile *\n      getObjFileLowering() const override {\n        return TLOF.get();\n      }\n    };\n    } // end namespace llvm\n    ```", "```cpp\n\n    extern \"C\" LLVM_EXTERNAL_VISIBILITY void\n    LLVMInitializeM88kTarget() {\n      RegisterTargetMachine<M88kTargetMachine> X(\n          getTheM88kTarget());\n      auto &PR = *PassRegistry::getPassRegistry();\n      initializeM88kDAGToDAGISelPass(PR);\n    }\n    ```", "```cpp\n\n    namespace {\n    std::string computeDataLayout(const Triple &TT,\n                                  StringRef CPU,\n                                  StringRef FS) {\n      std::string Ret;\n      Ret += \"E\";\n      Ret += DataLayout::getManglingComponent(TT);\n      Ret += \"-p:32:32:32\";\n      Ret += \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\";\n      Ret += \"-f32:32:32-f64:64:64\";\n      Ret += \"-a:8:16\";\n      Ret += \"-n32\";\n      return Ret;\n    }\n    } // namespace\n    ```", "```cpp\n\n    M88kTargetMachine::M88kTargetMachine(\n        const Target &T, const Triple &TT, StringRef CPU,\n        StringRef FS, const TargetOptions &Options,\n        std::optional<Reloc::Model> RM,\n        std::optional<CodeModel::Model> CM,\n        CodeGenOpt::Level OL, bool JIT)\n        : LLVMTargetMachine(\n              T, computeDataLayout(TT, CPU, FS), TT, CPU,\n              FS, Options, !RM ? Reloc::Static : *RM,\n              getEffectiveCodeModel(CM, CodeModel::Medium),\n              OL),\n          TLOF(std::make_unique<\n               TargetLoweringObjectFileELF>()) {\n      initAsmInfo();\n    }\n    M88kTargetMachine::~M88kTargetMachine() {}\n    ```", "```cpp\n\n    const M88kSubtarget *\n    M88kTargetMachine::getSubtargetImpl(\n        const Function &F) const {\n      Attribute CPUAttr = F.getFnAttribute(\"target-cpu\");\n      Attribute FSAttr =\n          F.getFnAttribute(\"target-features\");\n      std::string CPU =\n          !CPUAttr.hasAttribute(Attribute::None)\n              ? CPUAttr.getValueAsString().str()\n              : TargetCPU;\n      std::string FS = !FSAttr.hasAttribute(Attribute::None)\n                           ? FSAttr.getValueAsString().str()\n                           : TargetFS;\n      auto &I = SubtargetMap[CPU + FS];\n      if (!I) {\n        resetTargetOptions(F);\n        I = std::make_unique<M88kSubtarget>(TargetTriple,\n                                            CPU, FS, *this);\n      }\n      return I.get();\n    }\n    ```", "```cpp\n\n    namespace {\n    class M88kPassConfig : public TargetPassConfig {\n    public:\n      M88kPassConfig(M88kTargetMachine &TM,\n                     PassManagerBase &PM)\n          : TargetPassConfig(TM, PM) {}\n      bool addInstSelector() override;\n    };\n    } // namespace\n    ```", "```cpp\n\n    TargetPassConfig *M88kTargetMachine::createPassConfig(\n        PassManagerBase &PM) {\n      return new M88kPassConfig(*this, PM);\n    }\n    ```", "```cpp\n\n    bool M88kPassConfig::addInstSelector() {\n      addPass(createM88kISelDag(getTM<M88kTargetMachine>(),\n                                getOptLevel()));\n      return false;\n    }\n    ```", "```cpp\n\ndefine i32 @f1(i32 %a, i32 %b) {\n  %res = and i32 %a, %b\n  ret i32 %res\n}\n```", "```cpp\n\n$ llc -mtriple m88k-openbsd < and.ll\n        .text\n        .file   \"<stdin>\"\n        .globl  f1                              | -- Begin function f1\n        .align  2\n        .type   f1,@function\nf1:                                     | @f1\n| %bb.0:\n        and %r2, %r2, %r3\n        jmp %r1\n.Lfunc_end0:\n        .size   f1, .Lfunc_end0-f1\n                                        | -- End function\n        .section        \".note.GNU-stack\",\"\",@progbits\n```", "```cpp\n\nclass M88kCallLowering : public CallLowering {\npublic:\n  M88kCallLowering(const M88kTargetLowering &TLI);\n  bool\n  lowerReturn(MachineIRBuilder &MIRBuilder,\n              const Value *Val,\n              ArrayRef<Register> VRegs,\n              FunctionLoweringInfo &FLI,\n              Register SwiftErrorVReg) const override;\n  bool lowerFormalArguments(\n      MachineIRBuilder &MIRBuilder, const Function &F,\n      ArrayRef<ArrayRef<Register>> VRegs,\n      FunctionLoweringInfo &FLI) const override;\n  bool enableBigEndian() const override { return true; }\n};\n```", "```cpp\n\nnamespace {\nstruct FormalArgHandler\n    : public CallLowering::IncomingValueHandler {\n  FormalArgHandler(MachineIRBuilder &MIRBuilder,\n                   MachineRegisterInfo &MRI)\n      : CallLowering::IncomingValueHandler(MIRBuilder,\n                                           MRI) {}\n  void assignValueToReg(Register ValVReg,\n                        Register PhysReg,\n                        CCValAssign VA) override;\n  void assignValueToAddress(Register ValVReg,\n                            Register Addr, LLT MemTy,\n                            MachinePointerInfo &MPO,\n                            CCValAssign &VA) override{};\n  Register\n  getStackAddress(uint64_t Size, int64_t Offset,\n                  MachinePointerInfo &MPO,\n                  ISD::ArgFlagsTy Flags) override {\n    return Register();\n  };\n};\n} // namespace\n```", "```cpp\n\nvoid FormalArgHandler::assignValueToReg(\n    Register ValVReg, Register PhysReg,\n    CCValAssign VA) {\n  MIRBuilder.getMRI()->addLiveIn(PhysReg);\n  MIRBuilder.getMBB().addLiveIn(PhysReg);\n  CallLowering::IncomingValueHandler::assignValueToReg(\n      ValVReg, PhysReg, VA);\n}\n```", "```cpp\n\n    bool M88kCallLowering::lowerFormalArguments(\n        MachineIRBuilder &MIRBuilder, const Function &F,\n        ArrayRef<ArrayRef<Register>> VRegs,\n        FunctionLoweringInfo &FLI) const {\n      MachineFunction &MF = MIRBuilder.getMF();\n      MachineRegisterInfo &MRI = MF.getRegInfo();\n      const auto &DL = F.getParent()->getDataLayout();\n      SmallVector<ArgInfo, 8> SplitArgs;\n      for (const auto &[I, Arg] :\n           llvm::enumerate(F.args())) {\n        ArgInfo OrigArg{VRegs[I], Arg.getType(),\n                        static_cast<unsigned>(I)};\n        setArgFlags(OrigArg,\n                    I + AttributeList::FirstArgIndex, DL,\n                    F);\n        splitToValueTypes(OrigArg, SplitArgs, DL,\n                          F.getCallingConv());\n      }\n    ```", "```cpp\n\n      IncomingValueAssigner ArgAssigner(CC_M88k);\n      FormalArgHandler ArgHandler(MIRBuilder, MRI);\n      return determineAndHandleAssignments(\n          ArgHandler, ArgAssigner, SplitArgs, MIRBuilder,\n          F.getCallingConv(), F.isVarArg());\n    }\n    ```", "```cpp\n\n  getActionDefinitionsBuilder({G_AND, G_OR, G_XOR})\n      .legalFor({S32})\n      .clampScalar(0, S32, S32);\n```", "```cpp\n\ndef GRRegBank : RegisterBank<\"GRRB\", [GPR, GPR64]>;\n```", "```cpp\n\nRegisterBankInfo::PartialMapping\n    M88kGenRegisterBankInfo::PartMappings[]{\n        {0, 32, M88k::GRRegBank},\n        {0, 64, M88k::GRRegBank},\n    };\n```", "```cpp\n\nenum PartialMappingIdx { PMI_GR32 = 0, PMI_GR64, };\n```", "```cpp\n\nRegisterBankInfo::ValueMapping\n    M88kGenRegisterBankInfo::ValMappings[]{\n        {nullptr, 0},\n        {&M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},\n        {&M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},\n        {&M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},\n        {&M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},\n        {&M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},\n        {&M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},\n    };\n```", "```cpp\n\nconst RegisterBankInfo::ValueMapping *\nM88kGenRegisterBankInfo::getValueMapping(\n    PartialMappingIdx RBIdx) {\n  return &ValMappings[1 + 3*RBIdx];\n}\n```", "```cpp\n\nconst RegisterBankInfo::InstructionMapping &\nM88kRegisterBankInfo::getInstrMapping(\n    const MachineInstr &MI) const {\n  const ValueMapping *OperandsMapping = nullptr;\n  switch (MI.getOpcode()) {\n  case TargetOpcode::G_AND:\n  case TargetOpcode::G_OR:\n  case TargetOpcode::G_XOR:\n    OperandsMapping = getValueMapping(PMI_GR32);\n    break;\n  default:\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n    MI.dump();\n#endif\n    return getInvalidInstructionMapping();\n  }\n  return getInstructionMapping(DefaultMappingID, /*Cost=*/1,\n                               OperandsMapping,\n                               MI.getNumOperands());\n}\n```", "```cpp\n\nbool M88kInstructionSelector::select(MachineInstr &I) {\n  if (selectImpl(I, *CoverageInfo))\n    return true;\n  return false;\n}\n```", "```cpp\n\n$ llc -mtriple m88k-openbsd -global-isel < and.ll\n```", "```cpp\n\n$ llc -mtriple m88k-openbsd -global-isel < and.ll \\\n  -stop-after=legalizer\n```"]