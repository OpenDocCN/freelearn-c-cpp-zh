- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Getting Started with Ray Tracing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光线追踪入门
- en: In this chapter, we are introducing ray tracing into our rendering pipeline.
    Thanks to the addition of hardware support for ray tracing in modern GPUs, it’s
    now possible to integrate ray tracing techniques into real-time rendering.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将光线追踪引入我们的渲染管道。得益于现代GPU中光线追踪硬件支持的添加，现在可以将光线追踪技术集成到实时渲染中。
- en: Ray tracing requires a different setup compared to the traditional rendering
    pipeline, which is why we are dedicating a whole chapter to setting up a ray tracing
    pipeline. We are going to cover in detail how to set up a shader binding table
    to tell the API which shaders to invoke when an intersection test for a given
    ray succeeds or fails.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统渲染管道相比，光线追踪需要不同的设置，因此我们专门用一整章来设置光线追踪管道。我们将详细介绍如何设置着色器绑定表，以便API知道在给定光线交点测试成功或失败时调用哪些着色器。
- en: Next, we are going to explain how to create the **Bottom Level Acceleration
    Structure** (**BLAS**) and **Top Level Acceleration Structure** (**TLAS**). These
    **Acceleration Structures** (**AS**) are needed to speed up scene ray traversal
    and ensure that ray tracing can be performed at an interactive rate.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解释如何创建**底部级加速结构**（**BLAS**）和**顶部级加速结构**（**TLAS**）。这些**加速结构**（**AS**）用于加速场景光线遍历并确保光线追踪可以以交互式速率进行。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to ray tracing in Vulkan
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vulkan中光线追踪简介
- en: Building the BLAS and TLAS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建BLAS和TLAS
- en: Defining and creating a ray tracing pipeline
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和创建光线追踪管道
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter12](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter12).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下URL找到：[https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter12](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter12)。
- en: Introduction to ray tracing in Vulkan
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vulkan中光线追踪简介
- en: Ray tracing support in hardware was first introduced in 2018 with the NVidia
    RTX series. Originally, ray tracing support in Vulkan was only available through
    an NVidia extension, but later, the functionality was ratified through a Khronos
    extension to allow multiple vendors to support the ray tracing API in Vulkan.
    We are dedicating a full chapter just to the setup of a ray tracing pipeline,
    as it requires new constructs that are specific to ray tracing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件中的光线追踪支持首次于2018年随NVIDIA RTX系列推出。最初，Vulkan中的光线追踪支持仅通过NVIDIA扩展提供，但后来，该功能通过Khronos扩展得到认可，允许多个供应商支持Vulkan中的光线追踪API。我们专门用一整章来介绍光线追踪管道的设置，因为它需要针对光线追踪的新构造。
- en: The first departure from the traditional rendering pipeline is the need to organize
    our scene into Acceleration Structures. These structures are needed to speed up
    scene traversal, as they allow us to skip entire meshes that the ray has no chance
    to intersect with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统渲染管道的第一个不同之处在于需要将我们的场景组织成加速结构。这些结构用于加速场景遍历，因为它们允许我们跳过整个网格，而光线没有机会与之相交。
- en: These Acceleration Structures are usually implemented as a **Bounded Volume
    Hierarchy** (**BVH**). A BVH subdivides the scene and individual meshes into bounding
    boxes and then organizes them into a tree. Leaf nodes of this tree are the only
    nodes containing geometry data, while parent nodes define the position and extent
    of the volume that encompasses the children.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些加速结构通常实现为**边界体积层次结构**（**BVH**）。BVH将场景和单个网格划分为边界框，然后将其组织成树状结构。树的叶节点是唯一包含几何数据的节点，而父节点定义了包含子节点的体积的位置和范围。
- en: 'A simple scene and its BVH representation is illustrated by the following image:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了简单场景及其BVH表示：
- en: '![Figure 12.1 – A scene example on the left and its BVH representation on the
    right (source: Wikipedia)](img/B18395_12_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 左侧的场景示例及其右侧的BVH表示（来源：维基百科）](img/B18395_12_01.jpg)'
- en: 'Figure 12.1 – A scene example on the left and its BVH representation on the
    right (source: Wikipedia)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 左侧的场景示例及其右侧的BVH表示（来源：维基百科）
- en: The Vulkan API makes a further distinction between a TLAS and BLAS. A BLAS contains
    individual mesh definitions. These can then be grouped into a TLAS, where multiple
    instances of the same mesh can be placed in the scene by defining their transform
    matrices.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'This organization is pictured in the following figure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Each BLAS can be added multiple times to a TLAS with different
    shading and transform details (source: Vulkan spec)](img/B18395_12_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2 – Each BLAS can be added multiple times to a TLAS with different
    shading and transform details (source: Vulkan spec)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our Acceleration Structures, we can turn our attention
    to the ray tracing pipeline. The major change introduced with ray tracing pipelines
    is the ability to call other shaders within a shader. This is achieved by defining
    shader binding tables. Each slot in these tables defines one of the following
    shader types:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Ray generation**: In a traditional ray tracing pipeline, this is the entry
    point from which rays are generated. As we will see in later chapters, rays can
    also be spawned from fragments and compute shaders.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intersection**: This shader allows the application to implement custom geometry
    primitives. In Vulkan, we can only define triangles and **Axis-Aligned Bounding**
    **Boxes** (**AABB**).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Any-hit**: This is executed after an intersection shader is triggered. Its
    main use is to determine whether the hit should be processed further or ignored.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closest hit**: This shader is triggered the first time a ray hits a primitive.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Miss**: This shader is triggered if the ray doesn’t hit any primitive.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callable**: These are shaders that can be called from within an existing
    shader.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flow is summarized in the following figure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – The shader flow of a ray tracing pipeline (source: Vulkan spec)](img/B18395_12_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3 – The shader flow of a ray tracing pipeline (source: Vulkan spec)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have provided an overview of how ray tracing is implemented
    in the Vulkan API. In the next section, we are going to have a better look at
    how to create Acceleration Structures.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Building the BLAS and TLAS
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, ray tracing pipelines require geometry
    to be organized into Acceleration Structures to speed up the ray traversal of
    the scene. In this section, we are going to explain how to accomplish this in
    Vulkan.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a list of `VkAccelerationStructureGeometryKHR` when parsing
    our scene. For each mesh, this data structure is defined as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each geometry structure can define three types of entries: triangles, AABBs,
    and instances. We are going to use triangles here, as that’s how our meshes are
    defined. We are going to use instances later when defining the TLAS.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how the `triangles` structure is used:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Geometry data is defined as it normally would be for traditional draws: we
    need to provide a vertex and index buffer, a vertex stride, and a vertex format.
    The primitive count is defined in the next structure.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 几何数据定义方式与传统绘制相同：我们需要提供一个顶点和索引缓冲区、顶点步长和顶点格式。原始计数在下一个结构中定义。
- en: 'Finally, we also need to fill a `VkAccelerationStructureBuildRangeInfoKHR`
    structure to store the primitive definition for our mesh:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要填充一个 `VkAccelerationStructureBuildRangeInfoKHR` 结构来存储我们的网格的原始定义：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have the details for our meshes, we can start building the BLAS.
    This is a two-step process. First, we need to query how much memory our AS requires.
    We do so by defining a `VkAccelerationStructureBuildGeometryInfoKHR` structure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了网格的详细信息，我们可以开始构建 BLAS。这是一个两步过程。首先，我们需要查询我们的 AS 需要多少内存。我们通过定义一个 `VkAccelerationStructureBuildGeometryInfoKHR`
    结构来实现：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These flags tell the Vulkan API that this BLAS could be updated or compacted
    in the future:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志告诉 Vulkan API，这个 BLAS 在未来可能会被更新或压缩：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When querying the size of the AS, we need to provide a list with the maximum
    number of primitives for each geometry entry:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询 AS 的大小时，我们需要提供一个列表，其中包含每个几何条目中原始数的最大数量：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are now ready to query the size of our AS:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好查询我们的 AS 的大小：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When building an AS, we need to provide two buffers: one for the actual AS
    data, and one for a scratch buffer that is used in the building process. The two
    buffers are created as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 AS 时，我们需要提供两个缓冲区：一个用于实际的 AS 数据，另一个用于构建过程中使用的临时缓冲区。这两个缓冲区的创建方式如下：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is similar to the code for creating buffers that we have used many times
    before, but there are two key differences that we want to highlight:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前多次使用的创建缓冲区代码类似，但有两大关键区别我们要强调：
- en: The AS buffer needs to be created with the `VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR`
    usage flag
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AS 缓冲区需要使用 `VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR` 使用标志来创建
- en: The scratch buffer needs to be created with `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR`.
    The ray tracing extension also requires the `VK_KHR_buffer_device_address` extension.
    This allows us to query the GPU virtual address for a given buffer, but it has
    to be created with this usage flag.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要使用 `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR` 来创建临时缓冲区。光线追踪扩展还要求 `VK_KHR_buffer_device_address`
    扩展。这允许我们查询给定缓冲区的 GPU 虚拟地址，但它必须使用此使用标志创建。
- en: 'Now we have everything we need to create our BLAS. First, we retrieve a handle
    for our AS:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建我们的 BLAS 所需的一切。首先，我们检索我们的 AS 的句柄：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, `scene->blas` is only a handle. To build our acceleration, we
    populate the remaining fields of our `VkAccelerationStructureBuildGeometryInfoKHR`
    structure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`scene->blas` 仍然只是一个句柄。为了构建我们的加速结构，我们需要填充我们的 `VkAccelerationStructureBuildGeometryInfoKHR`
    结构的剩余字段：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we record the command to build the AS:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们记录构建 AS 的命令：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we submit this command immediately. This is required because it’s
    not possible to build a BLAS and TLAS on the same submission, as the TLAS depends
    on a fully constructed BLAS.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们立即提交了这个命令。这是必需的，因为无法在同一提交中构建 BLAS 和 TLAS，因为 TLAS 依赖于完全构建的 BLAS。
- en: 'The next and final step it to build the TLAS. The process is similar to the
    one we just described for the BLAS and we are going to highlight the differences.
    The TLAS is defined by specifying instances to multiple BLASes, where each BLAS
    can have its own transform. This is very similar to traditional instancing: we
    define our geometry once and it can be rendered multiple times by simply changing
    its transform.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步和最后一步是构建 TLAS。过程与之前描述的 BLAS 类似，我们将强调其中的区别。TLAS 通过指定多个 BLAS 的实例来定义，其中每个 BLAS
    可以有自己的转换。这与传统的实例化非常相似：我们定义一次几何形状，可以通过简单地改变其转换来多次渲染。
- en: 'We start by defining a `VkAccelerationStructureInstanceKHR` structure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个 `VkAccelerationStructureInstanceKHR` 结构：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As mentioned previously, we provide a BLAS reference and its transform. We
    then need to create a buffer to hold this data:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们提供了一个 BLAS 引用及其转换。然后我们需要创建一个缓冲区来存储这些数据：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice the `VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR`
    usage flag, which is required for buffers that are going to be used during the
    AS build.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR` 使用标志，这是将要用于
    AS 构建期间的缓冲区所必需的。
- en: 'Next, we define a `VkAccelerationStructureGeometryKHR` structure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个 `VkAccelerationStructureGeometryKHR` 结构：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have defined the structure of our TLAS, we need to query its size.
    We won’t repeat the full code, but here are the differences in the `VkAccelerationStructureBuildGeometryInfoKHR`
    structure compared to when creating a BLAS:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的TLAS结构，我们需要查询它的大小。我们不会重复完整的代码，但这里是在创建BLAS时与`VkAccelerationStructureBuildGeometryInfoKHR`结构相比的差异：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After creating the data and scratch buffer for the TLAS, we are ready to get
    the TLAS handle:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建TLAS的数据和临时缓冲区之后，我们就可以获取TLAS句柄了：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we can build our TLAS:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以构建我们的TLAS：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As before, we submit this command immediately so that the TLAS is ready when
    we start rendering. While it’s not possible to build BLAS and TLAS in the same
    submission, it is possible to create multiple BLAS and TLAS in parallel.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们立即提交此命令，以便在开始渲染时TLAS已准备好。虽然无法在同一提交中构建BLAS和TLAS，但可以并行创建多个BLAS和TLAS。
- en: Our Acceleration Structures are now ready to be used for ray tracing!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将加速结构用于光线追踪了！
- en: In this section, we have detailed the steps required to create BLASes and TLASes.
    We started by recording the triangle primitives for our geometry. We then used
    this data to create a BLAS instance, which was then used as part of a TLAS.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们详细介绍了创建BLAS和TLAS所需的步骤。我们首先记录了我们的几何体的三角形原语。然后我们使用这些数据创建了一个BLAS实例，该实例随后被用作TLAS的一部分。
- en: In the next section, we are going to define a ray tracing pipeline that makes
    use of these Acceleration Structures.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将定义一个利用这些加速结构的射线追踪管线。
- en: Defining and creating a ray tracing pipeline
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和创建光线追踪管线
- en: Now that we have defined our Acceleration Structures, we can turn our attention
    to ray tracing pipelines. As we mentioned previously, ray tracing shaders work
    differently compared to traditional graphics and compute shaders. Ray tracing
    shaders are setup to call other shaders according to the shader binding table
    setup.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的加速结构，我们可以将注意力转向光线追踪管线。正如我们之前提到的，光线追踪着色器与传统图形和计算着色器的工作方式不同。光线追踪着色器被设置为根据着色器绑定表设置调用其他着色器。
- en: 'If you are familiar with C++, you can think of this setup as a simple form
    of polymorphism: the interface of a ray tracing pipeline is always the same, but
    we can dynamically override which shaders (methods) get called at runtime. We
    don’t have to define all the entry points though.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉C++，你可以将此设置视为一种简单的多态形式：射线追踪管线的接口始终相同，但我们可以在运行时动态地覆盖哪些着色器（方法）被调用。我们不需要定义所有入口点。
- en: In this example, for instance, we are going to define only a ray generation,
    the closest hit, and the miss shader. We are ignoring any-hit and intersection
    shaders for now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，例如，我们只定义了光线生成、最近击中和丢失着色器。我们现在忽略任何击中和交点着色器。
- en: 'As the name implies, the shader binding table can be represented in table form.
    This is the binding table we are going to build in our example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，着色器绑定表可以以表格形式表示。这是我们将在示例中构建的绑定表：
- en: '![](img/B18395_12_Table_01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18395_12_Table_01.jpg)'
- en: The order in the table is important, as that’s the order used by the driver
    to tell the GPU which shader to invoke according to the stage that has been triggered.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的顺序很重要，因为这是驱动程序用来告诉GPU根据已触发的阶段调用哪个着色器的顺序。
- en: 'Before we start building our pipeline, let’s have a look at three example shaders
    we are going to use. We start with the ray generation shader, which is responsible
    for spawning the rays to traverse our scene. First, we have to enable the GLSL
    extension for ray tracing:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建管线之前，让我们看看我们将要使用的三个示例着色器。我们首先从光线生成着色器开始，它负责生成光线以遍历我们的场景。首先，我们必须启用用于光线追踪的GLSL扩展：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we have to define a variable that is going to be populated by other shaders:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义一个将被其他着色器填充的变量：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then define a uniform variable that will contain a reference to our AS:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来定义一个统一变量，它将包含对我们的AS的引用：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we define the parameters for our ray generation call:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了我们的光线生成调用参数：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`sbt_offset` is the offset into our shader binding table, which can be used
    in case multiple shaders of the same type are defined within a shader binding
    table. In our case, this will be `0`, as we only have one entry for each shader.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbt_offset` 是着色器绑定表中的偏移量，在着色器绑定表中定义了多个同类型的着色器时可以使用。在我们的例子中，这将是一个`0`，因为我们为每个着色器只有一个条目。'
- en: '`sbt_stride` is the size of each entry in the binding table. This value has
    to be queried for each device by passing a `VkPhysicalDeviceRayTracingPipelinePropertiesKHR`
    structure to `vkGetPhysicalDeviceProperties2`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '`miss_index` is used to compute the index of the miss shader. This can be used
    if multiple miss shaders are present within a binding table. It will be `0` in
    our use case.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `out_image_index` is the index of the image in our bindless image array
    to which we are going to write.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined the inputs and outputs of our ray generation shader,
    we can invoke the function to trace rays into the scene!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first parameter is the TLAS we want to traverse. Since this is a parameter
    to the `traceRayEXT` function, we could cast rays into multiple Acceleration Structures
    in the same shader.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`rayFlags` is a bit mask that determines which geometry is going to trigger
    a callback to our shaders. In this case, we are only interested in geometry that
    has the opaque flag.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '`cullMask` is used to match only the entries in the AS that have the same mask
    value defined. This allows us to define a single AS that can be used for multiple
    purposes.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the payload determines the location index of the ray tracing payload
    we have defined here. This allows us to invoke `traceRayEXT` multiple times, with
    each invocation using a different payload variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'The other fields are self-explanatory or have been explained previously. Next,
    we are going to have a better look at how ray directions are computed:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ray tracing shaders are very similar to compute shaders, and, like compute shaders,
    each invocation has an ID. For a ray tracing shader this is defined in the `gl_LaunchIDEXT`
    variable. Likewise, `gl_LaunchSizeEXT` defines the total invocation size. This
    is akin to the workgroup size for compute shaders.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we have one invocation per pixel in the image. We compute `x`
    and `y` in **normalized device coordinates** (**NDCs**) as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that we have to invert `y`, as otherwise, our final image will be upside-down.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we compute our world space direction by multiplying the coordinates
    by the `inverse_view_projection` matrix:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once `traceRayEXT` returns, the payload variable will contain the value computed
    through the other shaders. The final step of the ray generation is to save the
    color for this pixel:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We are now going to have a look at an example of a closest hit shader:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The main difference from the ray generation shader is that the payload is now
    defined with the `rayPayloadInEXT` qualifier. It’s also important that the location
    matches the one defined in the ray generation shader.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The miss shader is identical, except we use a different color to distinguish
    between the two.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our shader code, we can start building our pipeline.
    Compiling ray tracing shader modules works in the same way as other shaders. The
    main difference is the shader type. For ray tracing, these enumerations have been
    added:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_RAYGEN_BIT_KHR`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_ANY_HIT_BIT_KHR`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_MISS_BIT_KHR`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_INTERSECTION_BIT_KHR`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_CALLABLE_BIT_KHR`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a ray tracing pipeline, we have to populate a new `VkRayTracingShaderGroupCreateInfoKHR`
    structure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we are defining a general shader, which can be a generation,
    miss, or callable shader. In our case, we are defining our ray generation shader.
    As you can see, it’s also possible to define other shaders within the same group
    entry. We have decided to have individual entries for each shader type as it allows
    us more flexibility in building our shader binding table.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Other shader types are defined similarly, and we are not going to repeat them
    here. As a quick example, here is how we define a closest hit shader:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have our shader groups defined, we can create our pipeline object:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice the `maxPipelineRayRecursionDepth` field. It determines the maximum number
    of call stacks in case we have a recursive call to the `rayTraceEXT` function.
    This is needed by the compiler to determine how much memory could be used by this
    pipeline at runtime.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: We have omitted the `pLibraryInfo` and `pLibraryInterface` fields, as we are
    not using them. Multiple ray tracing pipelines can be combined to create a larger
    program, similar to how you link multiple objects in C++. This can help reduce
    compile times for ray tracing pipelines, as individual components need to be compiled
    only once.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to create our shader binding table. We start by computing
    the size required for our table:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We simply multiply the handle size by the number of entries in our table.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we call `vkGetRayTracingShaderGroupHandlesKHR` to get the handles of
    the groups in the ray tracing pipeline:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once we have the shader group handles, we can combine them to create individual
    tables for each shader type. They are stored in separate buffers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We only have one entry per table, so we simply copy each group handle into its
    buffer. Notice that the buffer has to be created with the `VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR`
    usage flag.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes our ray tracing pipeline creation. All that’s left is to actually
    use it to generate an image! This is accomplished by the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We define `VkStridedDeviceAddressRegionKHR` for each shader binding table. We
    use the table buffers we previously created. Notice that we still need to define
    a table for callable shaders, even if we are not using them. The `width`, `height`,
    and `depth` parameters determine the invocation size of our ray tracing shader.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have illustrated how to create and use a ray tracing pipeline.
    We started by defining the organization of our shader binding table. Next, we
    looked at a basic ray generation and closest hit shader. We then showed how to
    create a ray tracing pipeline object and how to retrieve shader group handles.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: These handles were then used to populate the buffers of our shader binding tables.
    Finally, we demonstrated how to combine all these components to invoke our ray
    tracing pipeline.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have provided the details on how to use ray tracing in
    Vulkan. We started by explaining two fundamental concepts:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**Acceleration** **Structures**: These are needed to speed up scene traversal.
    This is essential to achieve real-time results.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shader binding tables**: Ray tracing pipelines can invoke multiple shaders,
    and these tables are used to tell the API which shaders to use for which stage.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we provided the implementation details to create TLASes
    and BLASes. We first record the list of geometries that compose our mesh. Next,
    we use this list to create a BLAS. Each BLAS can then be instanced multiple times
    within a TLAS, as each BLAS instance defines its own transform. With this data,
    we can then create our TLAS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the third and final section, we explained how to create a ray tracing pipeline.
    We started with the creation of individual shader types. Next, we demonstrated
    how to combine these individual shaders into a ray tracing pipeline and how to
    generate a shader binding table from a given pipeline.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have shown how to write a simple ray generation shader used in combination
    with a closest hit shader and a miss shader. Finally, we demonstrate how to combine
    all these pieces to trace rays in our scene.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to leverage all the knowledge from this chapter
    to implement ray-traced shadows!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, we have only provided the most relevant details on how to use the
    Vulkan API. We recommend you read the Vulkan specification for more details. Here
    is the list of the most relevant sections:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#pipelines-ray-tracing](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#pipelines-ray-tracing)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#interfaces-raypipeline](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#interfaces-raypipeline)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#acceleration-structure](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#acceleration-structure)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#ray-tracing](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#ray-tracing)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This website provides more details on Acceleration Structures: [https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-acceleration-structure/introduction](https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-acceleration-structure/introduction).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of resources online about real-time ray tracing. It’s still
    a novel field and subject to ongoing research. A good starting point is provided
    by these two freely available books:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在线关于实时光线追踪的资源非常丰富。这仍然是一个新兴领域，并且正在持续研究中。以下这两本免费书籍提供了良好的起点：
- en: '[http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml](http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml](http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml)'
- en: '[http://www.realtimerendering.com/raytracinggems/rtg2/index.xhtml](http://www.realtimerendering.com/raytracinggems/rtg2/index.xhtml)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.realtimerendering.com/raytracinggems/rtg2/index.xhtml](http://www.realtimerendering.com/raytracinggems/rtg2/index.xhtml)'
