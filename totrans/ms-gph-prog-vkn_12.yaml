- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Ray Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are introducing ray tracing into our rendering pipeline.
    Thanks to the addition of hardware support for ray tracing in modern GPUs, it’s
    now possible to integrate ray tracing techniques into real-time rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Ray tracing requires a different setup compared to the traditional rendering
    pipeline, which is why we are dedicating a whole chapter to setting up a ray tracing
    pipeline. We are going to cover in detail how to set up a shader binding table
    to tell the API which shaders to invoke when an intersection test for a given
    ray succeeds or fails.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to explain how to create the **Bottom Level Acceleration
    Structure** (**BLAS**) and **Top Level Acceleration Structure** (**TLAS**). These
    **Acceleration Structures** (**AS**) are needed to speed up scene ray traversal
    and ensure that ray tracing can be performed at an interactive rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ray tracing in Vulkan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the BLAS and TLAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and creating a ray tracing pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter12](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ray tracing in Vulkan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ray tracing support in hardware was first introduced in 2018 with the NVidia
    RTX series. Originally, ray tracing support in Vulkan was only available through
    an NVidia extension, but later, the functionality was ratified through a Khronos
    extension to allow multiple vendors to support the ray tracing API in Vulkan.
    We are dedicating a full chapter just to the setup of a ray tracing pipeline,
    as it requires new constructs that are specific to ray tracing.
  prefs: []
  type: TYPE_NORMAL
- en: The first departure from the traditional rendering pipeline is the need to organize
    our scene into Acceleration Structures. These structures are needed to speed up
    scene traversal, as they allow us to skip entire meshes that the ray has no chance
    to intersect with.
  prefs: []
  type: TYPE_NORMAL
- en: These Acceleration Structures are usually implemented as a **Bounded Volume
    Hierarchy** (**BVH**). A BVH subdivides the scene and individual meshes into bounding
    boxes and then organizes them into a tree. Leaf nodes of this tree are the only
    nodes containing geometry data, while parent nodes define the position and extent
    of the volume that encompasses the children.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple scene and its BVH representation is illustrated by the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – A scene example on the left and its BVH representation on the
    right (source: Wikipedia)](img/B18395_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1 – A scene example on the left and its BVH representation on the
    right (source: Wikipedia)'
  prefs: []
  type: TYPE_NORMAL
- en: The Vulkan API makes a further distinction between a TLAS and BLAS. A BLAS contains
    individual mesh definitions. These can then be grouped into a TLAS, where multiple
    instances of the same mesh can be placed in the scene by defining their transform
    matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This organization is pictured in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Each BLAS can be added multiple times to a TLAS with different
    shading and transform details (source: Vulkan spec)](img/B18395_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2 – Each BLAS can be added multiple times to a TLAS with different
    shading and transform details (source: Vulkan spec)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our Acceleration Structures, we can turn our attention
    to the ray tracing pipeline. The major change introduced with ray tracing pipelines
    is the ability to call other shaders within a shader. This is achieved by defining
    shader binding tables. Each slot in these tables defines one of the following
    shader types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ray generation**: In a traditional ray tracing pipeline, this is the entry
    point from which rays are generated. As we will see in later chapters, rays can
    also be spawned from fragments and compute shaders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intersection**: This shader allows the application to implement custom geometry
    primitives. In Vulkan, we can only define triangles and **Axis-Aligned Bounding**
    **Boxes** (**AABB**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Any-hit**: This is executed after an intersection shader is triggered. Its
    main use is to determine whether the hit should be processed further or ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closest hit**: This shader is triggered the first time a ray hits a primitive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Miss**: This shader is triggered if the ray doesn’t hit any primitive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callable**: These are shaders that can be called from within an existing
    shader.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flow is summarized in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – The shader flow of a ray tracing pipeline (source: Vulkan spec)](img/B18395_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3 – The shader flow of a ray tracing pipeline (source: Vulkan spec)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have provided an overview of how ray tracing is implemented
    in the Vulkan API. In the next section, we are going to have a better look at
    how to create Acceleration Structures.
  prefs: []
  type: TYPE_NORMAL
- en: Building the BLAS and TLAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, ray tracing pipelines require geometry
    to be organized into Acceleration Structures to speed up the ray traversal of
    the scene. In this section, we are going to explain how to accomplish this in
    Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a list of `VkAccelerationStructureGeometryKHR` when parsing
    our scene. For each mesh, this data structure is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each geometry structure can define three types of entries: triangles, AABBs,
    and instances. We are going to use triangles here, as that’s how our meshes are
    defined. We are going to use instances later when defining the TLAS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how the `triangles` structure is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Geometry data is defined as it normally would be for traditional draws: we
    need to provide a vertex and index buffer, a vertex stride, and a vertex format.
    The primitive count is defined in the next structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also need to fill a `VkAccelerationStructureBuildRangeInfoKHR`
    structure to store the primitive definition for our mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the details for our meshes, we can start building the BLAS.
    This is a two-step process. First, we need to query how much memory our AS requires.
    We do so by defining a `VkAccelerationStructureBuildGeometryInfoKHR` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These flags tell the Vulkan API that this BLAS could be updated or compacted
    in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When querying the size of the AS, we need to provide a list with the maximum
    number of primitives for each geometry entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to query the size of our AS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When building an AS, we need to provide two buffers: one for the actual AS
    data, and one for a scratch buffer that is used in the building process. The two
    buffers are created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to the code for creating buffers that we have used many times
    before, but there are two key differences that we want to highlight:'
  prefs: []
  type: TYPE_NORMAL
- en: The AS buffer needs to be created with the `VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR`
    usage flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scratch buffer needs to be created with `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR`.
    The ray tracing extension also requires the `VK_KHR_buffer_device_address` extension.
    This allows us to query the GPU virtual address for a given buffer, but it has
    to be created with this usage flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we have everything we need to create our BLAS. First, we retrieve a handle
    for our AS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, `scene->blas` is only a handle. To build our acceleration, we
    populate the remaining fields of our `VkAccelerationStructureBuildGeometryInfoKHR`
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we record the command to build the AS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we submit this command immediately. This is required because it’s
    not possible to build a BLAS and TLAS on the same submission, as the TLAS depends
    on a fully constructed BLAS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next and final step it to build the TLAS. The process is similar to the
    one we just described for the BLAS and we are going to highlight the differences.
    The TLAS is defined by specifying instances to multiple BLASes, where each BLAS
    can have its own transform. This is very similar to traditional instancing: we
    define our geometry once and it can be rendered multiple times by simply changing
    its transform.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining a `VkAccelerationStructureInstanceKHR` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned previously, we provide a BLAS reference and its transform. We
    then need to create a buffer to hold this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR`
    usage flag, which is required for buffers that are going to be used during the
    AS build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define a `VkAccelerationStructureGeometryKHR` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have defined the structure of our TLAS, we need to query its size.
    We won’t repeat the full code, but here are the differences in the `VkAccelerationStructureBuildGeometryInfoKHR`
    structure compared to when creating a BLAS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the data and scratch buffer for the TLAS, we are ready to get
    the TLAS handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can build our TLAS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As before, we submit this command immediately so that the TLAS is ready when
    we start rendering. While it’s not possible to build BLAS and TLAS in the same
    submission, it is possible to create multiple BLAS and TLAS in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Our Acceleration Structures are now ready to be used for ray tracing!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have detailed the steps required to create BLASes and TLASes.
    We started by recording the triangle primitives for our geometry. We then used
    this data to create a BLAS instance, which was then used as part of a TLAS.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to define a ray tracing pipeline that makes
    use of these Acceleration Structures.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and creating a ray tracing pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have defined our Acceleration Structures, we can turn our attention
    to ray tracing pipelines. As we mentioned previously, ray tracing shaders work
    differently compared to traditional graphics and compute shaders. Ray tracing
    shaders are setup to call other shaders according to the shader binding table
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with C++, you can think of this setup as a simple form
    of polymorphism: the interface of a ray tracing pipeline is always the same, but
    we can dynamically override which shaders (methods) get called at runtime. We
    don’t have to define all the entry points though.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, for instance, we are going to define only a ray generation,
    the closest hit, and the miss shader. We are ignoring any-hit and intersection
    shaders for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name implies, the shader binding table can be represented in table form.
    This is the binding table we are going to build in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18395_12_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The order in the table is important, as that’s the order used by the driver
    to tell the GPU which shader to invoke according to the stage that has been triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start building our pipeline, let’s have a look at three example shaders
    we are going to use. We start with the ray generation shader, which is responsible
    for spawning the rays to traverse our scene. First, we have to enable the GLSL
    extension for ray tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to define a variable that is going to be populated by other shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a uniform variable that will contain a reference to our AS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the parameters for our ray generation call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`sbt_offset` is the offset into our shader binding table, which can be used
    in case multiple shaders of the same type are defined within a shader binding
    table. In our case, this will be `0`, as we only have one entry for each shader.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sbt_stride` is the size of each entry in the binding table. This value has
    to be queried for each device by passing a `VkPhysicalDeviceRayTracingPipelinePropertiesKHR`
    structure to `vkGetPhysicalDeviceProperties2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`miss_index` is used to compute the index of the miss shader. This can be used
    if multiple miss shaders are present within a binding table. It will be `0` in
    our use case.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `out_image_index` is the index of the image in our bindless image array
    to which we are going to write.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined the inputs and outputs of our ray generation shader,
    we can invoke the function to trace rays into the scene!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the TLAS we want to traverse. Since this is a parameter
    to the `traceRayEXT` function, we could cast rays into multiple Acceleration Structures
    in the same shader.
  prefs: []
  type: TYPE_NORMAL
- en: '`rayFlags` is a bit mask that determines which geometry is going to trigger
    a callback to our shaders. In this case, we are only interested in geometry that
    has the opaque flag.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cullMask` is used to match only the entries in the AS that have the same mask
    value defined. This allows us to define a single AS that can be used for multiple
    purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the payload determines the location index of the ray tracing payload
    we have defined here. This allows us to invoke `traceRayEXT` multiple times, with
    each invocation using a different payload variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other fields are self-explanatory or have been explained previously. Next,
    we are going to have a better look at how ray directions are computed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Ray tracing shaders are very similar to compute shaders, and, like compute shaders,
    each invocation has an ID. For a ray tracing shader this is defined in the `gl_LaunchIDEXT`
    variable. Likewise, `gl_LaunchSizeEXT` defines the total invocation size. This
    is akin to the workgroup size for compute shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we have one invocation per pixel in the image. We compute `x`
    and `y` in **normalized device coordinates** (**NDCs**) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have to invert `y`, as otherwise, our final image will be upside-down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we compute our world space direction by multiplying the coordinates
    by the `inverse_view_projection` matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `traceRayEXT` returns, the payload variable will contain the value computed
    through the other shaders. The final step of the ray generation is to save the
    color for this pixel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to have a look at an example of a closest hit shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The main difference from the ray generation shader is that the payload is now
    defined with the `rayPayloadInEXT` qualifier. It’s also important that the location
    matches the one defined in the ray generation shader.
  prefs: []
  type: TYPE_NORMAL
- en: The miss shader is identical, except we use a different color to distinguish
    between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our shader code, we can start building our pipeline.
    Compiling ray tracing shader modules works in the same way as other shaders. The
    main difference is the shader type. For ray tracing, these enumerations have been
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_RAYGEN_BIT_KHR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_ANY_HIT_BIT_KHR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_MISS_BIT_KHR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_INTERSECTION_BIT_KHR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHADER_STAGE_CALLABLE_BIT_KHR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a ray tracing pipeline, we have to populate a new `VkRayTracingShaderGroupCreateInfoKHR`
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are defining a general shader, which can be a generation,
    miss, or callable shader. In our case, we are defining our ray generation shader.
    As you can see, it’s also possible to define other shaders within the same group
    entry. We have decided to have individual entries for each shader type as it allows
    us more flexibility in building our shader binding table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other shader types are defined similarly, and we are not going to repeat them
    here. As a quick example, here is how we define a closest hit shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our shader groups defined, we can create our pipeline object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `maxPipelineRayRecursionDepth` field. It determines the maximum number
    of call stacks in case we have a recursive call to the `rayTraceEXT` function.
    This is needed by the compiler to determine how much memory could be used by this
    pipeline at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We have omitted the `pLibraryInfo` and `pLibraryInterface` fields, as we are
    not using them. Multiple ray tracing pipelines can be combined to create a larger
    program, similar to how you link multiple objects in C++. This can help reduce
    compile times for ray tracing pipelines, as individual components need to be compiled
    only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to create our shader binding table. We start by computing
    the size required for our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We simply multiply the handle size by the number of entries in our table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we call `vkGetRayTracingShaderGroupHandlesKHR` to get the handles of
    the groups in the ray tracing pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the shader group handles, we can combine them to create individual
    tables for each shader type. They are stored in separate buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We only have one entry per table, so we simply copy each group handle into its
    buffer. Notice that the buffer has to be created with the `VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR`
    usage flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes our ray tracing pipeline creation. All that’s left is to actually
    use it to generate an image! This is accomplished by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We define `VkStridedDeviceAddressRegionKHR` for each shader binding table. We
    use the table buffers we previously created. Notice that we still need to define
    a table for callable shaders, even if we are not using them. The `width`, `height`,
    and `depth` parameters determine the invocation size of our ray tracing shader.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have illustrated how to create and use a ray tracing pipeline.
    We started by defining the organization of our shader binding table. Next, we
    looked at a basic ray generation and closest hit shader. We then showed how to
    create a ray tracing pipeline object and how to retrieve shader group handles.
  prefs: []
  type: TYPE_NORMAL
- en: These handles were then used to populate the buffers of our shader binding tables.
    Finally, we demonstrated how to combine all these components to invoke our ray
    tracing pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have provided the details on how to use ray tracing in
    Vulkan. We started by explaining two fundamental concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Acceleration** **Structures**: These are needed to speed up scene traversal.
    This is essential to achieve real-time results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shader binding tables**: Ray tracing pipelines can invoke multiple shaders,
    and these tables are used to tell the API which shaders to use for which stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we provided the implementation details to create TLASes
    and BLASes. We first record the list of geometries that compose our mesh. Next,
    we use this list to create a BLAS. Each BLAS can then be instanced multiple times
    within a TLAS, as each BLAS instance defines its own transform. With this data,
    we can then create our TLAS.
  prefs: []
  type: TYPE_NORMAL
- en: In the third and final section, we explained how to create a ray tracing pipeline.
    We started with the creation of individual shader types. Next, we demonstrated
    how to combine these individual shaders into a ray tracing pipeline and how to
    generate a shader binding table from a given pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have shown how to write a simple ray generation shader used in combination
    with a closest hit shader and a miss shader. Finally, we demonstrate how to combine
    all these pieces to trace rays in our scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to leverage all the knowledge from this chapter
    to implement ray-traced shadows!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, we have only provided the most relevant details on how to use the
    Vulkan API. We recommend you read the Vulkan specification for more details. Here
    is the list of the most relevant sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#pipelines-ray-tracing](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#pipelines-ray-tracing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#interfaces-raypipeline](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#interfaces-raypipeline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#acceleration-structure](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#acceleration-structure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#ray-tracing](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#ray-tracing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This website provides more details on Acceleration Structures: [https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-acceleration-structure/introduction](https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-acceleration-structure/introduction).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of resources online about real-time ray tracing. It’s still
    a novel field and subject to ongoing research. A good starting point is provided
    by these two freely available books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml](http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.realtimerendering.com/raytracinggems/rtg2/index.xhtml](http://www.realtimerendering.com/raytracinggems/rtg2/index.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
