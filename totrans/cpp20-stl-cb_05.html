<html><head></head><body>
		<div id="_idContainer029">
			<h1 id="_idParaDest-156"><em class="italic"><a id="_idTextAnchor155"/>Chapter 5</em>: Lambda Expressions</h1>
			<p>The C++11 standard introduced the <em class="italic">lambda expression</em> (sometimes called the <em class="italic">lambda function</em>, or just <em class="italic">lambda</em>). This feature allows an anonymous function to be used in the context of an expression. Lambdas may be used in function calls, containers, variables, and other expression contexts. It may sound innocuous, but it's remarkably useful.</p>
			<p>Let's start with a brief review of lambda expressions.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/>Lambda expressions</h1>
			<p>A lambda is <a id="_idIndexMarker421"/>essentially an anonymous function as a literal expression:</p>
			<p class="source-code">auto la = []{ return "Hello\n"; };</p>
			<p>The variable <strong class="source-inline">la</strong> may now be used as if it were a function:</p>
			<p class="source-code">cout &lt;&lt; la();</p>
			<p>It can be passed to another function:</p>
			<p class="source-code">f(la);</p>
			<p>It can be passed to another lambda:</p>
			<p class="source-code">const auto la = []{ return "Hello\n"; };</p>
			<p class="source-code">const auto lb = [](auto a){ return a(); };</p>
			<p class="source-code">cout &lt;&lt; lb(la);</p>
			<p>Output:</p>
			<p class="source-code">Hello</p>
			<p>Or it can be passed anonymously (as a literal):</p>
			<p class="source-code">const auto lb = [](auto a){ return a(); };</p>
			<p class="source-code">cout &lt;&lt; lb([]{ return "Hello\n"; });</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Closures</h2>
			<p>The term <em class="italic">closure</em> is often <a id="_idIndexMarker422"/>applied to any anonymous function. Strictly speaking, a closure is a function that allows the use of symbols outside its own lexical scope.</p>
			<p>You may have noticed the square brackets in the definition of a lambda:</p>
			<p class="source-code">auto la = <strong class="bold">[]</strong>{ return "Hello\n"; };</p>
			<p>The square brackets are used to specify a list of <em class="italic">captures</em>. Captures are outside variables that are <a id="_idIndexMarker423"/>accessible from within the scope of the lambda body. If I try to use an outside variable without listing it as a capture, I'll get a compilation error:</p>
			<p class="source-code">const char * <strong class="bold">greeting</strong>{ "Hello\n" };</p>
			<p class="source-code">const auto la = []{ return <strong class="bold">greeting</strong>; };</p>
			<p class="source-code">cout &lt;&lt; la();</p>
			<p>When I try to compile this with GCC, I get the following error:</p>
			<p class="source-code">In lambda function:</p>
			<p class="source-code">error: 'greeting' is not captured</p>
			<p>This is because the body of the lambda has its own lexical scope and the <strong class="source-inline">greeting</strong> variable is outside of that scope.</p>
			<p>I can specify the <strong class="source-inline">greeting</strong> variable in a capture. This allows the variable into the scope of the lambda:</p>
			<p class="source-code">const char * <strong class="bold">greeting</strong>{ "Hello\n" };</p>
			<p class="source-code">const auto la = [<strong class="bold">greeting</strong>]{ return <strong class="bold">greeting</strong>; };</p>
			<p class="source-code">cout &lt;&lt; la();</p>
			<p>Now it compiles and runs as expected:</p>
			<p class="source-code">$ ./working</p>
			<p class="source-code">Hello</p>
			<p>This ability to capture variables outside its own scope is what makes a lambda a <em class="italic">closure</em>. People use the term in <a id="_idIndexMarker424"/>different ways, and that's fine, so long as we can understand each other. Still, it's good to know what the term means.</p>
			<p>Lambda expressions allow us to write good, clean generic code. They allow the use of <em class="italic">functional programming</em> patterns, where <a id="_idIndexMarker425"/>we can use lambdas as functional parameters to algorithms and even other lambdas.</p>
			<p>In this chapter, we will cover the use of lambdas with the STL, in the following recipes:</p>
			<ul>
				<li>Use lambdas for scoped reusable code</li>
				<li>Use lambdas as predicates with the algorithm library</li>
				<li>Use <strong class="source-inline">std::function</strong> as a polymorphic wrapper</li>
				<li>Concatenate lambdas with recursion</li>
				<li>Combine predicates with logical conjunction</li>
				<li>Call multiple lambdas with the same input</li>
				<li>Use mapped lambdas for a jump table</li>
			</ul>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Technical requirements</h1>
			<p>You can find the code for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap05">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap05</a>.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Use lambdas for scoped reusable code</h1>
			<p>Lambda expressions can be defined and stored for later use. They can be passed as parameters, stored <a id="_idIndexMarker426"/>in data structures, and called in different contexts with different parameters. They are as flexible as functions, but with the mobility of data.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>How to do it…</h2>
			<p>Let's start with a simple program that we'll use to test various configurations of lambda expressions:</p>
			<ul>
				<li>We'll first define a <strong class="source-inline">main()</strong> function and use it to experiment with lambdas:<p class="source-code">int main() {</p><p class="source-code">    ... // code goes here</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">main()</strong> function, we'll declare a couple of lambdas. The basic definition of a lambda requires a pair of square brackets and a block of code in curly brackets:<p class="source-code">auto one = [](){ return "one"; };</p><p class="source-code">auto two = []{ return "two"; };</p></li>
			</ul>
			<p>Notice that the first example <strong class="source-inline">one</strong> includes parentheses after the square brackets, and the second example <strong class="source-inline">two</strong> does not. The empty parameter parentheses <a id="_idIndexMarker427"/>are commonly included, but are not always required. The return type is inferred by the compiler.</p>
			<ul>
				<li>I can call these functions with <strong class="source-inline">cout</strong>, or with <strong class="source-inline">format</strong>, or in any context that will take a C-string:<p class="source-code">cout &lt;&lt; one() &lt;&lt; '\n';</p><p class="source-code">cout &lt;&lt; format("{}\n", two());</p></li>
				<li>In many cases, the compiler can determine the return type from <em class="italic">automatic type deduction</em>. Otherwise, you can specify the return type with the <strong class="source-inline">-&gt;</strong> operator:<p class="source-code">auto one = []() <strong class="bold">-&gt; const char *</strong> { return "one"; };</p><p class="source-code">auto two = []() <strong class="bold">-&gt; auto</strong> { return "two"; };</p></li>
			</ul>
			<p>Lambdas use the <em class="italic">trailing return type</em> syntax. This consists of the <strong class="source-inline">-&gt;</strong> operator followed by the type specification. If the return type is not specified, it is considered <strong class="source-inline">auto</strong>. If you use a trailing return type, <em class="italic">the parameter parentheses are required</em>.</p>
			<ul>
				<li>Let's define a lambda to print out the values from our other lambdas:<p class="source-code">auto p = [](auto v) { cout &lt;&lt; v() &lt;&lt; '\n'; };</p></li>
			</ul>
			<p>The <strong class="source-inline">p()</strong> lambda expects a lambda (or function) as its parameter <strong class="source-inline">v</strong>, and calls it in its function body.</p>
			<p>The <strong class="source-inline">auto</strong> type parameter makes this lambda an <em class="italic">abbreviated template</em>. Before C++20, this was the only way to template a lambda. Beginning with C++20, you may specify <a id="_idIndexMarker428"/>template parameters (without the <strong class="source-inline">template</strong> keyword) after the capture brackets. This is the equivalent with template parameters:</p>
			<p class="source-code">auto p = []&lt;template T&gt;(T v) { cout &lt;&lt; v() &lt;&lt; '\n'; };</p>
			<p>The abbreviated <strong class="source-inline">auto</strong> version is simpler and more common. It works well for most purposes.</p>
			<ul>
				<li>Now we can pass an anonymous lambda in the function call:<p class="source-code">p([]{ return "lambda call lambda"; });</p></li>
			</ul>
			<p>The output is:</p>
			<p class="source-code"><strong class="bold">lambda call lambda</strong></p>
			<ul>
				<li>If we need to pass parameters to an anonymous lambda, we can put them in parentheses after the lambda expression:<p class="source-code">&lt;&lt; [](auto l, auto r){ return l + r; }(47, 73)</p><p class="source-code">    &lt;&lt; '\n';</p></li>
			</ul>
			<p>The function parameters, <strong class="source-inline">47</strong> and <strong class="source-inline">73</strong>, are passed to the anonymous lambda in the parentheses after the function body.</p>
			<ul>
				<li>You can access variables from the outside scope of the lambda by including them as <em class="italic">captures</em> in the square brackets:<p class="source-code">int num{1};</p><p class="source-code">p([num]{ return num; });</p></li>
				<li>Or you can capture them by reference:<p class="source-code">int num{0};</p><p class="source-code">auto inc = [&amp;num]{ num++; };</p><p class="source-code">for (size_t i{0}; i &lt; 5; ++i) {</p><p class="source-code">    inc();</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; num &lt;&lt; '\n';</p></li>
			</ul>
			<p>The output is as follows:</p>
			<p class="source-code"><strong class="bold">5</strong></p>
			<p>This allows you to modify a captured variable.</p>
			<ul>
				<li>You can <a id="_idIndexMarker429"/>also define a local capture variable that maintains its state:<p class="source-code">auto counter = [<strong class="bold">n = 0</strong>]() <strong class="bold">mutable</strong> { return <strong class="bold">++n</strong>; };</p><p class="source-code">for (size_t i{0}; i &lt; 5; ++i) {</p><p class="source-code">    cout &lt;&lt; format("{}, ", counter());</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1, 2, 3, 4, 5,</strong></p>
			<p>The <strong class="source-inline">mutable</strong> specifier allows the lambda to modify its captures. Lambdas default to <strong class="source-inline">const</strong>-qualified.</p>
			<p>As with the trailing return type, any <em class="italic">specifier</em> requires the parameter parentheses.</p>
			<ul>
				<li>The lambda supports two types of <em class="italic">default capture</em>:<p class="source-code">int a = 47;</p><p class="source-code">int b = 73;</p><p class="source-code">auto l1 = []{ return a + b; };</p></li>
			</ul>
			<p>If I try to compile this code, I get an error that includes:</p>
			<p class="source-code">note: the lambda has no capture-default</p>
			<p>One type of default capture is indicated by an equal sign:</p>
			<p class="source-code">auto l1 = [<strong class="bold">=</strong>]{ return a + b; };</p>
			<p>This will capture all the symbols in the lambda's scope. The equal sign performs <em class="italic">capture by copy</em>. It will capture a copy of the objects as if they were copied with an assignment operator.</p>
			<p>The other default capture uses an ampersand for <em class="italic">capture by reference</em>:</p>
			<p class="source-code">auto l1 = [<strong class="bold">&amp;</strong>]{ return a + b; };</p>
			<p>This is a default capture that captures by reference.</p>
			<p>The default captures only use symbols when they are referenced, so they're not as messy as they may look. That said, I recommend explicit captures where possible as they generally improve readability.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>How it works…</h2>
			<p>The syntax of <a id="_idIndexMarker430"/>a lambda expression is as follows: </p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B18267_05_01.jpg" alt="Figure 5.1 – Syntax of the lambda expression&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Syntax of the lambda expression</p>
			<p>The only required parts of a lambda expression are the capture list and the body, which may be empty:</p>
			<p class="source-code">[]{}</p>
			<p>This is the <a id="_idIndexMarker431"/>minimal lambda expression. It captures nothing and does nothing.</p>
			<p>Let's consider each of the parts.</p>
			<h3>Capture-list</h3>
			<p>The <em class="italic">capture-list</em> specifies <a id="_idIndexMarker432"/>what we capture, if anything. It cannot be omitted, but it may be empty. We can use <strong class="source-inline">[=]</strong> to capture all variables <em class="italic">by copy</em> or <strong class="source-inline">[&amp;]</strong> to capture all variables <em class="italic">by reference</em>, within the scope of the lambda.</p>
			<p>You may capture individual variables by listing them in the brackets:</p>
			<p class="source-code">[a, b]{ return a + b; }</p>
			<p>The specified captures default to copy. You may capture by reference with the reference operator:</p>
			<p class="source-code">[&amp;a, &amp;b]{ return a + b; }</p>
			<p>When you capture by reference, you may modify the referenced variable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You cannot capture object members directly. You may capture <strong class="source-inline">this</strong> or <strong class="source-inline">*this</strong> to dereference class members. </p>
			<h3>Parameters</h3>
			<p>As with a function, parameters <a id="_idIndexMarker433"/>are specified in parentheses:</p>
			<p class="source-code">[]<strong class="bold">(int a, int b)</strong>{ return a + b };</p>
			<p>If there are no parameters, specifiers, or trailing return type, the parentheses are optional. A specifier or trailing return type makes the parentheses required:</p>
			<p class="source-code">[]<strong class="bold">() -&gt; int</strong> { return 47 + 73 };</p>
			<h3>The mutable modifier (optional)</h3>
			<p>A lambda expression defaults to <strong class="source-inline">const</strong>-qualified unless you specify the <strong class="source-inline">mutable</strong> modifier. This allows <a id="_idIndexMarker434"/>it to be used in <strong class="source-inline">const</strong> context, but it also means that it cannot modify any of its captured-by-copy variables. For example:</p>
			<p class="source-code">[a]{ return ++a; };</p>
			<p>This will fail to compile with an error message like this:</p>
			<p class="source-code">In lambda function:</p>
			<p class="source-code">error: increment of read-only variable 'a'</p>
			<p>With the <strong class="source-inline">mutable</strong> modifier, the lambda is no longer <strong class="source-inline">const</strong>-qualified and the captured variable may be changed:</p>
			<p class="source-code">[a]() mutable { return ++a; };</p>
			<h3>The constexpr specifier (optional)</h3>
			<p>You may use <strong class="source-inline">constexpr</strong> to explicitly specify that you want your lambda to be considered a <em class="italic">constant expression</em>. This means that it may be evaluated at compile time. If the <a id="_idIndexMarker435"/>lambda meets the requirements, it may be considered <strong class="source-inline">constexpr</strong> even without the specifier.</p>
			<h3>The exception attribute (optional)</h3>
			<p>You can use <a id="_idIndexMarker436"/>the <strong class="source-inline">noexcept</strong> specifier to declare that your lambda does not throw any exceptions.</p>
			<h3>The trailing return type (optional)</h3>
			<p>By default, the lambda <a id="_idIndexMarker437"/>return type is deduced from the <strong class="source-inline">return</strong> statement, as if it were an <strong class="source-inline">auto</strong> return type. You may optionally specify a <em class="italic">trailing return type</em> with the <strong class="source-inline">-&gt;</strong> operator:</p>
			<p class="source-code">[](int a, int b) -&gt; long { return a + b; };</p>
			<p>The parameter parentheses are required if you use any of the optional specifiers or the trailing return type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Some compilers, including GCC, allow empty parameter parentheses to be omitted even when there's a specifier or trailing return type. This is not correct. According to the specification, the parameters, specifiers, and trailing return type are all part of the <em class="italic">lambda-declarator</em> and the parentheses are required when any part of it is included. This may change in a future version of C++.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Use lambdas as predicates with the algorithm library</h1>
			<p>Some functions in the <strong class="source-inline">algorithm</strong> library require the use of a <em class="italic">predicate</em> function. A predicate <a id="_idIndexMarker438"/>is a function (or functor or lambda) that <a id="_idIndexMarker439"/>tests a condition and returns a Boolean <strong class="source-inline">true</strong>/<strong class="source-inline">false</strong> response.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>How to do it…</h2>
			<p>For this recipe, we will experiment with the <strong class="source-inline">count_if()</strong> algorithm using different types of predicates:</p>
			<ul>
				<li>First, let's create a function for use as a predicate. A predicate takes a certain number of arguments and returns a <strong class="source-inline">bool</strong>. A predicate for <strong class="source-inline">count_if()</strong> takes one argument:<p class="source-code">bool is_div4(int i) {</p><p class="source-code">    return i % 4 == 0;</p><p class="source-code">}</p></li>
			</ul>
			<p>This predicate checks whether an <strong class="source-inline">int</strong> value is divisible by 4.</p>
			<ul>
				<li>In <strong class="source-inline">main()</strong>, we'll define a vector of <strong class="source-inline">int</strong> values, and use it to test our predicate function with <strong class="source-inline">count_if()</strong>:<p class="source-code">int main() {</p><p class="source-code">    const vector&lt;int&gt; v{ 1, 7, 4, 9, 4, 8, 12, 10, 20 };</p><p class="source-code">    int count = <strong class="bold">count_if</strong>(v.begin(), v.end(), <strong class="bold">is_div4</strong>);</p><p class="source-code">    cout &lt;&lt; format("numbers divisible by 4: {}\n", </p><p class="source-code">      count);</p><p class="source-code">}</p></li>
			</ul>
			<p>The output is as follows: </p>
			<p class="source-code"><strong class="bold">numbers divisible by 4: 5</strong></p>
			<p>(The 5 divisible numbers are: 4, 4, 8, 12, and 20.)</p>
			<p>The <strong class="source-inline">count_if()</strong> algorithm uses the predicate function to determine which elements <a id="_idIndexMarker440"/>of the sequence <a id="_idIndexMarker441"/>to count. It calls the predicate with each element as a parameter, and only counts the element if the predicate returns <strong class="source-inline">true</strong>.</p>
			<p>In this case, we used a function as a predicate.</p>
			<ul>
				<li>We could also use a <em class="italic">functor</em> as a predicate:<p class="source-code">struct is_div4 {</p><p class="source-code">    bool operator()(int i) {</p><p class="source-code">        return i % 4 == 0;</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>The only change here is that we need to use an <em class="italic">instance</em> of the class as the predicate:</p>
			<p class="source-code">int count = count_if(v.begin(), v.end(), <strong class="bold">is_div4()</strong>);</p>
			<p>The advantage of a functor is that it can carry context and access class and instance variables. This was the common way to use predicates before C++11 introduced lambda expressions.</p>
			<ul>
				<li>With a lambda expression, we have the best of both worlds: the simplicity of a function and the power of a functor. We can use a lambda as a variable:<p class="source-code">auto is_div4 = [](int i){ return i % 4 == 0; };</p><p class="source-code">int count = count_if(v.begin(), v.end(), <strong class="bold">is_div4</strong>);</p></li>
			</ul>
			<p>Or we can use an anonymous lambda:</p>
			<p class="source-code">int count = count_if(v.begin(), v.end(), </p>
			<p class="source-code">    [](int i){ return i % 4 == 0; });</p>
			<ul>
				<li>We can take advantage of the lambda capture by wrapping the lambda in a function, and using that function context to produce the same lambda with different parameters:<p class="source-code">auto is_div_by(int <strong class="bold">divisor</strong>) {</p><p class="source-code">    return [<strong class="bold">divisor</strong>](int i){ return i % <strong class="bold">divisor</strong> == 0; };</p><p class="source-code">}</p></li>
			</ul>
			<p>This function returns a predicate lambda with the divisor from the capture context.</p>
			<p>We can then use that predicate with <strong class="source-inline">count_if()</strong>:</p>
			<p class="source-code">for( int i : { 3, 4, 5 } ) {</p>
			<p class="source-code">    auto <strong class="bold">pred</strong> = is_div_by(<strong class="bold">i</strong>);</p>
			<p class="source-code">    int count = count_if(v.begin(), v.end(), <strong class="bold">pred</strong>);</p>
			<p class="source-code">    cout &lt;&lt; format("numbers divisible by {}: {}\n", i,</p>
			<p class="source-code">      count);</p>
			<p class="source-code">}</p>
			<p>Each <a id="_idIndexMarker442"/>call to <strong class="source-inline">is_div_by()</strong> returns <a id="_idIndexMarker443"/>a predicate with a different divisor from <strong class="source-inline">i</strong>. Now we get this output:</p>
			<p class="source-code"><strong class="bold">numbers divisible by 3: 2</strong></p>
			<p class="source-code"><strong class="bold">numbers divisible by 4: 5</strong></p>
			<p class="source-code"><strong class="bold">numbers divisible by 5: 2</strong></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>How it works…</h2>
			<p>The type of a function pointer is represented as a pointer followed by the function call <strong class="source-inline">()</strong> operator:</p>
			<p class="source-code">void (*)()</p>
			<p>You can declare a function pointer and initialize it with the name of an existing function:</p>
			<p class="source-code">void (*fp)() = func;</p>
			<p>Once declared, a function pointer may be dereferenced and used as if it were the function itself:</p>
			<p class="source-code">func();  // do the func thing</p>
			<p>A lambda expression has the same type as a function pointer:</p>
			<p class="source-code">void (*fp)() = []{ cout &lt;&lt; "foo\n"; };</p>
			<p>This <a id="_idIndexMarker444"/>means that wherever you use a <a id="_idIndexMarker445"/>function pointer with a certain signature, you may also use a lambda with the same signature. This allows function pointers, functors, and lambdas to work interchangeably:</p>
			<p class="source-code">bool (*fp)(int) = is_div4;</p>
			<p class="source-code">bool (*fp)(int) = [](int i){ return i % 4 == 0; };</p>
			<p>Because of this interchangeability, an algorithm such as <strong class="source-inline">count_if()</strong> accepts a function, functor, or lambda where it expects a predicate with a particular function signature.</p>
			<p>This applies to any algorithm that uses a predicate.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor165"/>Use std::function as a polymorphic wrapper</h1>
			<p>The class <a id="_idIndexMarker446"/>template <strong class="source-inline">std::function</strong> is a <a id="_idIndexMarker447"/>thin polymorphic wrapper for functions. It can store, copy, and invoke any function, lambda expression, or other function objects. It can be useful in places where you would like to store a reference to a function or lambda. Using <strong class="source-inline">std::function</strong> allows you to store functions and lambdas with different signatures in the same container, and it maintains the context of lambda captures.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>How to do it…</h2>
			<p>This recipe uses the <strong class="source-inline">std::function</strong> class to store different specializations of a lambda in a <strong class="source-inline">vector</strong>:</p>
			<ul>
				<li>This recipe is contained in the <strong class="source-inline">main()</strong> function, where we start by declaring three containers of different types:<p class="source-code">int main() {</p><p class="source-code">    deque&lt;int&gt; d;</p><p class="source-code">    list&lt;int&gt; l;</p><p class="source-code">    vector&lt;int&gt; v;</p></li>
			</ul>
			<p>These <a id="_idIndexMarker448"/>containers, <strong class="source-inline">deque</strong>, <strong class="source-inline">list</strong>, and <strong class="source-inline">vector</strong>, will <a id="_idIndexMarker449"/>be referenced by a <em class="italic">template</em> lambda.</p>
			<ul>
				<li>We'll declare a simple <strong class="source-inline">print_c</strong> lambda function for printing out the containers:<p class="source-code">auto print_c = [](auto&amp; c) {</p><p class="source-code">    for(auto i : c) cout &lt;&lt; format("{} ", i);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">};</p></li>
				<li>Now we declare a lambda that returns an <em class="italic">anonymous</em> lambda:<p class="source-code">auto push_c = [](auto&amp; <strong class="bold">container</strong>) {</p><p class="source-code">    return <strong class="bold">[&amp;container]</strong>(auto value) {</p><p class="source-code">        container.push_back(value);</p><p class="source-code">    };</p><p class="source-code">};</p></li>
			</ul>
			<p>The <strong class="source-inline">push_c</strong> lambda takes a reference to a container, which is <em class="italic">captured</em> by the anonymous lambda. The anonymous lambda calls the <strong class="source-inline">push_back()</strong> member on the captured container. The return value from <strong class="source-inline">push_c</strong> is the anonymous lambda.</p>
			<ul>
				<li>Now we declare a <strong class="source-inline">vector</strong> of <strong class="source-inline">std::function</strong> elements, and populate it with three instances of <strong class="source-inline">push_c()</strong>:<p class="source-code">const vector&lt;std::function&lt;void(int)&gt;&gt; </p><p class="source-code">    consumers { push_c(<strong class="bold">d</strong>), push_c(<strong class="bold">l</strong>), push_c(<strong class="bold">v</strong>) };</p></li>
			</ul>
			<p>Each of the <a id="_idIndexMarker450"/>elements in the initializer list <a id="_idIndexMarker451"/>is a function call to the <strong class="source-inline">push_c</strong> lambda. <strong class="source-inline">push_c</strong> returns an instance of the anonymous lambda, which gets stored in the <strong class="source-inline">vector</strong> via the <strong class="source-inline">function</strong> wrapper. The <strong class="source-inline">push_c</strong> lambda is called with the three containers, <strong class="source-inline">d</strong>, <strong class="source-inline">l</strong>, and <strong class="source-inline">v</strong>. The containers are passed as <em class="italic">captures</em> with the anonymous lambda.</p>
			<ul>
				<li>Now we loop through the <strong class="source-inline">consumers</strong> vector, and call each of the lambda elements 10 times, populating the three containers with integers 0–9 in each container:<p class="source-code">for(auto &amp;consume : consumers) {</p><p class="source-code">    for (int i{0}; i &lt; 10; ++i) {</p><p class="source-code">        consume(i);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now our three containers, the <strong class="source-inline">deque</strong>, <strong class="source-inline">list</strong>, and <strong class="source-inline">vector</strong>, should all be populated with integers. Let's print them out:<p class="source-code">print_c(d);</p><p class="source-code">print_c(l);</p><p class="source-code">print_c(v);</p></li>
			</ul>
			<p>Our output should be:</p>
			<p class="source-code"><strong class="bold">0 1 2 3 4 5 6 7 8 9</strong></p>
			<p class="source-code"><strong class="bold">0 1 2 3 4 5 6 7 8 9</strong></p>
			<p class="source-code"><strong class="bold">0 1 2 3 4 5 6 7 8 9</strong></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>How it works…</h2>
			<p>Lambdas are often used with indirection and this recipe is a good example of such. For example, the <strong class="source-inline">push_c</strong> lambda returns an anonymous lambda:</p>
			<p class="source-code">auto push_c = [](auto&amp; container) {</p>
			<p class="source-code">    <strong class="bold">return</strong> [&amp;container](auto value) {</p>
			<p class="source-code">        container.push_back(value);</p>
			<p class="source-code">    };</p>
			<p class="source-code">};</p>
			<p>This anonymous lambda is the one that's stored in the <strong class="source-inline">vector</strong>:</p>
			<p class="source-code">const vector&lt;std::function&lt;void(int)&gt;&gt; </p>
			<p class="source-code">    consumers { push_c(d), push_c(l), push_c(v) };</p>
			<p>This is the <a id="_idIndexMarker452"/>definition of the <strong class="source-inline">consumers</strong> container. It is initialized with three elements, where each element is initialized <a id="_idIndexMarker453"/>with a call to <strong class="source-inline">push_c</strong>, which returns an anonymous lambda. It's the anonymous lambda that gets stored in the vector, not the <strong class="source-inline">push_c</strong> lambda.</p>
			<p>The <strong class="source-inline">vector</strong> definition uses the <strong class="source-inline">std::function</strong> class as the type of the elements. The <strong class="source-inline">function</strong> constructor takes any callable object and stores its reference as the <strong class="source-inline">function</strong> target:</p>
			<p class="source-code">template&lt; class F &gt;</p>
			<p class="source-code">function( F&amp;&amp; f );</p>
			<p>When its function call <strong class="source-inline">()</strong> operator is invoked, the <strong class="source-inline">function</strong> object calls the target function with the intended parameters:</p>
			<p class="source-code">for(auto <strong class="bold">&amp;c</strong> : consumers) {</p>
			<p class="source-code">    for (int i{0}; i &lt; 10; ++i) {</p>
			<p class="source-code">        <strong class="bold">c(i)</strong>;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This calls <a id="_idIndexMarker454"/>each <em class="italic">anonymous lambda</em>, as <a id="_idIndexMarker455"/>stored in the <strong class="source-inline">consumers</strong> container, 10 times, thus populating the <strong class="source-inline">d</strong>, <strong class="source-inline">l</strong>, and <strong class="source-inline">v</strong> containers.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>There's more…</h2>
			<p>The nature of the <strong class="source-inline">std::function</strong> class makes it useful for many purposes. You can think of it as a <a id="_idIndexMarker456"/>polymorphic function container. It can store a standalone function:</p>
			<p class="source-code">void hello() {</p>
			<p class="source-code">    cout &lt;&lt; "hello\n";</p>
			<p class="source-code">}</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    function&lt;void(void)&gt; h = hello;</p>
			<p class="source-code">    h();</p>
			<p class="source-code">}</p>
			<p>It can store a <a id="_idIndexMarker457"/>member function, using <strong class="source-inline">std::bind</strong> to bind function parameters:</p>
			<p class="source-code">struct hello {</p>
			<p class="source-code">    void greeting() const { cout &lt;&lt; "Hello Bob\n"; }</p>
			<p class="source-code">};</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    hello bob{};</p>
			<p class="source-code">    const function&lt;void(void)&gt; h = </p>
			<p class="source-code">        std::bind(&amp;hello::greeting, &amp;bob);</p>
			<p class="source-code">    h();</p>
			<p class="source-code">}</p>
			<p>Or it can store any executable object:</p>
			<p class="source-code">struct hello {</p>
			<p class="source-code">    void operator()() const { cout &lt;&lt; "Hello Bob\n"; }</p>
			<p class="source-code">};</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    const function&lt;void(void)&gt; h = hello();</p>
			<p class="source-code">    h();</p>
			<p class="source-code">}</p>
			<p>The output is as follows:</p>
			<p class="source-code">Hello Bob</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Concatenate lambdas with recursion</h1>
			<p>You can stack <a id="_idIndexMarker458"/>lambdas so that the output of one is the <a id="_idIndexMarker459"/>input of the next, using a simple recursive function. This creates a simple way to build one function upon another.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>How to do it…</h2>
			<p>This is a short and simple recipe that uses one recursive function to do most of the work:</p>
			<ul>
				<li>We'll start by defining the concatenation function <strong class="source-inline">concat()</strong>:<p class="source-code">template &lt;typename T, typename ...Ts&gt;</p><p class="source-code">auto concat(T t, Ts ...ts) {</p><p class="source-code">    if constexpr (sizeof...(ts) &gt; 0) {</p><p class="source-code">        return <strong class="bold">[&amp;](auto ...parameters) {</strong></p><p class="source-code"><strong class="bold">            return t(concat(ts...)(parameters...)); </strong></p><p class="source-code"><strong class="bold">        };</strong></p><p class="source-code">    } else  {</p><p class="source-code">        return t;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>This function returns an anonymous lambda, which in turn calls the function again, until the parameter pack is exhausted.</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we create a couple of lambdas and call the <strong class="source-inline">concat()</strong> function with them:<p class="source-code">int main() {</p><p class="source-code">    auto twice = [](auto i) { return i * 2; };</p><p class="source-code">    auto thrice = [](auto i) { return i * 3; };</p><p class="source-code">    auto combined = <strong class="bold">concat(thrice, twice, </strong></p><p class="source-code"><strong class="bold">      std::plus&lt;int&gt;{});</strong></p><p class="source-code">    std::cout &lt;&lt; format("{}\n", combined(2, 3));</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">concat()</strong> function is called with three parameters: two lambdas, and the <strong class="source-inline">std::plus()</strong> function.</p>
			<p>As the <a id="_idIndexMarker460"/>recursion unravels, the functions are <a id="_idIndexMarker461"/>called right-to-left, starting with <strong class="source-inline">plus()</strong>. The <strong class="source-inline">plus()</strong> function takes two arguments and returns the sum. The return value from <strong class="source-inline">plus()</strong> is passed to <strong class="source-inline">twice()</strong>, and its return value is passed to <strong class="source-inline">thrice()</strong>. The result is then printed to the console with <strong class="source-inline">format()</strong>:</p>
			<p class="source-code">30</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>How it works…</h2>
			<p>The <strong class="source-inline">concat()</strong> function is simple, but may be confusing due to the <em class="italic">recursion</em> and the <em class="italic">indirection</em> of the returned lambda:</p>
			<p class="source-code">template &lt;typename T, typename ...Ts&gt;</p>
			<p class="source-code">auto concat(T t, Ts ...ts) {</p>
			<p class="source-code">    if constexpr (<strong class="bold">sizeof</strong>...(ts) &gt; 0) {</p>
			<p class="source-code">        <strong class="bold">return</strong> [&amp;](auto ...parameters) {</p>
			<p class="source-code">            <strong class="bold">return</strong> t(concat(ts...)(parameters...)); </p>
			<p class="source-code">        };</p>
			<p class="source-code">    } else  {</p>
			<p class="source-code">        return t;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">concat()</strong> function is called with a parameter pack. With ellipses, the <strong class="source-inline">sizeof...</strong> operator <a id="_idIndexMarker462"/>returns the number of elements <a id="_idIndexMarker463"/>in the parameter pack. This is used to test for the end of the recursion.</p>
			<p>The <strong class="source-inline">concat()</strong> function returns a lambda. The lambda recursively calls the <strong class="source-inline">concat()</strong> function. Because the first argument of <strong class="source-inline">concat()</strong> is not part of the parameter pack, each recursive call peels off the first element of the pack.</p>
			<p>The outer <strong class="source-inline">return</strong> statement returns the lambda. The inner <strong class="source-inline">return</strong> is from the lambda. The lambda calls the function that was passed to <strong class="source-inline">concat()</strong> and returns its value.</p>
			<p>Feel free to take this apart and study it. There's value in this technique.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Combine predicates with logical conjunction</h1>
			<p>This example <a id="_idIndexMarker464"/>wraps a lambda in a function to <a id="_idIndexMarker465"/>create a custom conjunction for use with an algorithm predicate.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor173"/>How to do it…</h2>
			<p>The <strong class="source-inline">copy_if()</strong> algorithm requires a predicate that takes one parameter. In this recipe, we will create a predicate lambda from three other lambdas:</p>
			<ul>
				<li>First, we'll write the <strong class="source-inline">combine()</strong> function. This function returns a lambda for use with the <strong class="source-inline">copy_if()</strong> algorithm:<p class="source-code">template &lt;typename F, typename A, typename B&gt;</p><p class="source-code">auto combine(F binary_func, A a, B b) {</p><p class="source-code">    return [=](auto param) {</p><p class="source-code">        return binary_func(a(param), b(param));</p><p class="source-code">    };</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">combine()</strong> function takes three function parameters – a binary conjunction and two predicates – and returns a lambda that calls the conjunction with the two predicates.</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we create the lambdas for use with <strong class="source-inline">combine()</strong>:<p class="source-code">int main() {</p><p class="source-code">    auto <strong class="bold">begins_with</strong> = [](const string &amp;s){</p><p class="source-code">        return s.find("a") == 0;</p><p class="source-code">    };</p><p class="source-code">    auto <strong class="bold">ends_with</strong> = [](const string &amp;s){</p><p class="source-code">        return s.rfind("b") == s.length() - 1;</p><p class="source-code">    };</p><p class="source-code">    auto <strong class="bold">bool_and</strong> = [](const auto&amp; l, const auto&amp; r){</p><p class="source-code">        return l &amp;&amp; r;</p><p class="source-code">    };</p></li>
			</ul>
			<p>The <strong class="source-inline">begins_with</strong> and <strong class="source-inline">ends_with</strong> lambdas are simple filter predicates to find strings that begin with <strong class="source-inline">'a'</strong> and end with <strong class="source-inline">'b'</strong>, respectively. The <strong class="source-inline">bool_and</strong> lambda is the conjunction.</p>
			<ul>
				<li>Now we <a id="_idIndexMarker466"/>can call the <strong class="source-inline">copy_if</strong> algorithm <a id="_idIndexMarker467"/>with <strong class="source-inline">combine()</strong>:<p class="source-code">std::copy_if(istream_iterator&lt;string&gt;{cin}, {},</p><p class="source-code">             ostream_iterator&lt;string&gt;{cout, " "},</p><p class="source-code">             <strong class="bold">combine</strong>(bool_and, begins_with, </p><p class="source-code"><strong class="bold">               </strong>ends_with));</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>The <strong class="source-inline">combine()</strong> function returns a lambda that combines the two predicates with the conjunction.</p>
			<p>The output looks like the following:</p>
			<p class="source-code"><strong class="bold">$ echo aabb bbaa foo bar abazb | ./conjunction</strong></p>
			<p class="source-code"><strong class="bold">aabb abazb</strong></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor174"/>How it works…</h2>
			<p>The <strong class="source-inline">std::copy_if()</strong> algorithm requires a predicate function that takes one parameter, but our conjunction requires two parameters, each of which require one parameter. We resolve this with a function that returns a lambda specifically for this context:</p>
			<p class="source-code">template &lt;typename F, typename A, typename B&gt;</p>
			<p class="source-code">auto combine(F <strong class="bold">binary_func</strong>, A <strong class="bold">a</strong>, B <strong class="bold">b</strong>) {</p>
			<p class="source-code">    return [=](auto <strong class="bold">param</strong>) {</p>
			<p class="source-code">        return binary_func(a(<strong class="bold">param</strong>), b(<strong class="bold">param</strong>));</p>
			<p class="source-code">    };</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">combine()</strong> function creates a lambda from three parameters, each of which is a function. The <a id="_idIndexMarker468"/>returned lambda takes the one <a id="_idIndexMarker469"/>parameter that's required of the predicate function. Now we can call <strong class="source-inline">copy_if()</strong> with the <strong class="source-inline">combine()</strong> function:</p>
			<p class="source-code">std::copy_if(istream_iterator&lt;string&gt;{cin}, {},</p>
			<p class="source-code">             ostream_iterator&lt;string&gt;{cout, " "},</p>
			<p class="source-code">             <strong class="bold">combine(bool_and, begins_with, ends_with)</strong>);</p>
			<p>This passes the combined lambda to the algorithm so it can operate within that context.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>Call multiple lambdas with the same input</h1>
			<p>You can easily create <a id="_idIndexMarker470"/>multiple instances of a lambda with different capture values by wrapping the lambda in a function. This allows you to call different versions of a lambda with the same input.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor176"/>How to do it…</h2>
			<p>This is a simple example of a lambda that wraps a value in different types of braces:</p>
			<ul>
				<li>We'll start by creating the wrapper function <strong class="source-inline">braces()</strong>:<p class="source-code">auto braces (const char a, const char b) {</p><p class="source-code">    return [a, b](const char v) {</p><p class="source-code">        cout &lt;&lt; format("{}{}{} ", a, v, b);</p><p class="source-code">    };</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">braces()</strong> function wraps a lambda that returns a three-value string, where the first and last values are characters passed to the lambda as captures, and the middle value is passed as a parameter.</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we use <strong class="source-inline">braces()</strong> to create four lambdas, using four different sets of braces:<p class="source-code">auto a = braces('(', ')');</p><p class="source-code">auto b = braces('[', ']');</p><p class="source-code">auto c = braces('{', '}');</p><p class="source-code">auto d = braces('|', '|');</p></li>
				<li>Now we can call our lambdas from a simple <strong class="source-inline">for()</strong> loop:<p class="source-code">for( int i : { 1, 2, 3, 4, 5 } ) {</p><p class="source-code">    for( <strong class="bold">auto x</strong> : { a, b, c, d } ) <strong class="bold">x(i)</strong>;</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>This is two nested <strong class="source-inline">for()</strong> loops. The outer loop simply counts from 1 to 5, passing <a id="_idIndexMarker471"/>an integer to the inner loop. The inner loop calls the lambdas with the braces.</p>
			<p>Both loops use an <em class="italic">initializer list</em> as the container in a range-based <strong class="source-inline">for()</strong> loop. This is a convenient technique for looping through a small set of values. </p>
			<ul>
				<li>The output from our program looks like this:<p class="source-code"><strong class="bold">(1) [1] {1} |1|</strong></p><p class="source-code"><strong class="bold">(2) [2] {2} |2|</strong></p><p class="source-code"><strong class="bold">(3) [3] {3} |3|</strong></p><p class="source-code"><strong class="bold">(4) [4] {4} |4|</strong></p><p class="source-code"><strong class="bold">(5) [5] {5} |5|</strong></p></li>
			</ul>
			<p>The output shows each of the integers, in each combination of braces.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>How it works…</h2>
			<p>This is a simple example of how to use a wrapper for a lambda. The <strong class="source-inline">braces()</strong> function constructs a lambda using the braces passed to it:</p>
			<p class="source-code">auto braces (const char <strong class="bold">a</strong>, const char <strong class="bold">b</strong>) {</p>
			<p class="source-code">    return <strong class="bold">[a, b]</strong>(const auto v) {</p>
			<p class="source-code">        cout &lt;&lt; format("{}{}{} ", <strong class="bold">a</strong>, v, <strong class="bold">b</strong>);</p>
			<p class="source-code">    };</p>
			<p class="source-code">}</p>
			<p>By passing the <strong class="source-inline">braces()</strong> function parameters to the lambda, it can return a lambda with that <a id="_idIndexMarker472"/>context. So, each of the assignments in the main function carries those parameters with it:</p>
			<p class="source-code">auto a = braces(<strong class="bold">'('</strong>, <strong class="bold">')'</strong>);</p>
			<p class="source-code">auto b = braces(<strong class="bold">'['</strong>, <strong class="bold">']'</strong>);</p>
			<p class="source-code">auto c = braces(<strong class="bold">'{'</strong>, <strong class="bold">'}'</strong>);</p>
			<p class="source-code">auto d = braces(<strong class="bold">'|'</strong>, <strong class="bold">'|'</strong>);</p>
			<p>When these lambdas are called with a digit, they will return a string with that digit in the corresponding braces.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor178"/>Use mapped lambdas for a jump table</h1>
			<p>A jump table is a <a id="_idIndexMarker473"/>useful pattern when you want to select an action <a id="_idIndexMarker474"/>from a user or other input. Jump tables are often implemented in <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> or <strong class="source-inline">switch</strong> structures. In this recipe, we'll build a concise jump table using only an STL <strong class="source-inline">map</strong> and anonymous lambdas.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>How to do it…</h2>
			<p>It's easy to build a simple jump table from a <strong class="source-inline">map</strong> and lambdas. The <strong class="source-inline">map</strong> provides simple indexed navigation and the lambda can be stored as payload. Here's how to do it:</p>
			<ul>
				<li>First, we'll create a simple <strong class="source-inline">prompt()</strong> function to get input from the console:<p class="source-code">const char prompt(<strong class="bold">const char * p</strong>) {</p><p class="source-code">    std::string <strong class="bold">r</strong>;</p><p class="source-code">    cout &lt;&lt; format("{} &gt; ", p);</p><p class="source-code">    <strong class="bold">std::getline</strong>(cin, <strong class="bold">r</strong>, '\n');</p><p class="source-code">    if(r.size() &lt; 1) return '\0';</p><p class="source-code">    if(r.size() &gt; 1) {</p><p class="source-code">        cout &lt;&lt; "Response too long\n";</p><p class="source-code">        return '\0';</p><p class="source-code">    }</p><p class="source-code">    return toupper(r[0]);</p><p class="source-code">}</p></li>
			</ul>
			<p>The C-string parameter is used as a prompt. <strong class="source-inline">std::getline()</strong> is called to get input from <a id="_idIndexMarker475"/>the user. The response is stored in <strong class="source-inline">r</strong>, checked <a id="_idIndexMarker476"/>for length, then if it's one character in length, it's converted to uppercase and returned.</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we declare and initialize a <strong class="source-inline">map</strong> of lambdas:<p class="source-code">using <strong class="bold">jumpfunc</strong> = <strong class="bold">void(*)()</strong>;</p><p class="source-code">map&lt;const char, <strong class="bold">jumpfunc</strong>&gt; jumpmap {</p><p class="source-code">    { 'A', []{ cout &lt;&lt; "func A\n"; } },</p><p class="source-code">    { 'B', []{ cout &lt;&lt; "func B\n"; } },</p><p class="source-code">    { 'C', []{ cout &lt;&lt; "func C\n"; } },</p><p class="source-code">    { 'D', []{ cout &lt;&lt; "func D\n"; } },</p><p class="source-code">    { 'X', []{ cout &lt;&lt; "Bye!\n"; } }</p><p class="source-code">};</p></li>
			</ul>
			<p>The <strong class="source-inline">map</strong> container is loaded with anonymous lambdas for the jump table. These lambdas could easily call other functions or perform simple tasks.</p>
			<p>The <strong class="source-inline">using</strong> alias is for convenience. We're using the function pointer type <strong class="source-inline">void(*)()</strong> for the lambda payload. If you prefer, you could use <strong class="source-inline">std::function()</strong> if you need more flexibility or if you just find it more readable. It has very little overhead:</p>
			<p class="source-code">using jumpfunc = std::function&lt;void()&gt;;</p>
			<ul>
				<li>Now we can prompt for user input and select an action from the <strong class="source-inline">map</strong>:<p class="source-code">char select{};</p><p class="source-code">while(select != 'X') {</p><p class="source-code">    if((select = <strong class="bold">prompt("select A/B/C/D/X")</strong>)) {</p><p class="source-code">        auto it = <strong class="bold">jumpmap.find(select)</strong>;</p><p class="source-code">        if(it != jumpmap.end()) <strong class="bold">it-&gt;second()</strong>;</p><p class="source-code">        else cout &lt;&lt; "Invalid response\n";</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>This is how <a id="_idIndexMarker477"/>we use the <strong class="source-inline">map</strong>-based jump <a id="_idIndexMarker478"/>table. We loop until <strong class="source-inline">'X'</strong> is selected for exit. We call <strong class="source-inline">prompt()</strong> with a prompt string, call <strong class="source-inline">find()</strong> on the <strong class="source-inline">map</strong> object, then call the lambda with <strong class="source-inline">it-&gt;second()</strong>.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>How it works…</h2>
			<p>The <strong class="source-inline">map</strong> container makes an excellent jump table. It's concise and easy to navigate:</p>
			<p class="source-code">using jumpfunc = void(*)();</p>
			<p class="source-code">map&lt;const char, jumpfunc&gt; jumpmap {</p>
			<p class="source-code">    { 'A', []{ cout &lt;&lt; "func A\n"; } },</p>
			<p class="source-code">    { 'B', []{ cout &lt;&lt; "func B\n"; } },</p>
			<p class="source-code">    { 'C', []{ cout &lt;&lt; "func C\n"; } },</p>
			<p class="source-code">    { 'D', []{ cout &lt;&lt; "func D\n"; } },</p>
			<p class="source-code">    { 'X', []{ cout &lt;&lt; "Bye!\n"; } }</p>
			<p class="source-code">};</p>
			<p>Anonymous <a id="_idIndexMarker479"/>lambdas are stored as payload in <a id="_idIndexMarker480"/>the <strong class="source-inline">map</strong> container. The keys are the character responses from the menu of actions.</p>
			<p>You can test the validity of a key and select a lambda in one action:</p>
			<p class="source-code">auto it = jumpmap.find(select);</p>
			<p class="source-code">if(it != jumpmap.end()) it-&gt;second();</p>
			<p class="source-code">else cout &lt;&lt; "Invalid response\n";</p>
			<p>This is a simple, elegant solution, where we would have otherwise used awkward branching code.</p>
		</div>
	</body></html>