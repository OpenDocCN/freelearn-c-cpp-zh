<html><head></head><body>
		<div><h1 id="_idParaDest-156"><em class="italic"><a id="_idTextAnchor155"/>Chapter 5</em>: Lambda Expressions</h1>
			<p>The C++11 standard introduced the <em class="italic">lambda expression</em> (sometimes called the <em class="italic">lambda function</em>, or just <em class="italic">lambda</em>). This feature allows an anonymous function to be used in the context of an expression. Lambdas may be used in function calls, containers, variables, and other expression contexts. It may sound innocuous, but it's remarkably useful.</p>
			<p>Let's start with a brief review of lambda expressions.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/>Lambda expressions</h1>
			<p>A lambda is <a id="_idIndexMarker421"/>essentially an anonymous function as a literal expression:</p>
			<pre>auto la = []{ return "Hello\n"; };</pre>
			<p>The variable <code>la</code> may now be used as if it were a function:</p>
			<pre>cout &lt;&lt; la();</pre>
			<p>It can be passed to another function:</p>
			<pre>f(la);</pre>
			<p>It can be passed to another lambda:</p>
			<pre>const auto la = []{ return "Hello\n"; };
const auto lb = [](auto a){ return a(); };
cout &lt;&lt; lb(la);</pre>
			<p>Output:</p>
			<pre>Hello</pre>
			<p>Or it can be passed anonymously (as a literal):</p>
			<pre>const auto lb = [](auto a){ return a(); };
cout &lt;&lt; lb([]{ return "Hello\n"; });</pre>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Closures</h2>
			<p>The term <em class="italic">closure</em> is often <a id="_idIndexMarker422"/>applied to any anonymous function. Strictly speaking, a closure is a function that allows the use of symbols outside its own lexical scope.</p>
			<p>You may have noticed the square brackets in the definition of a lambda:</p>
			<pre>auto la = <strong class="bold">[]</strong>{ return "Hello\n"; };</pre>
			<p>The square brackets are used to specify a list of <em class="italic">captures</em>. Captures are outside variables that are <a id="_idIndexMarker423"/>accessible from within the scope of the lambda body. If I try to use an outside variable without listing it as a capture, I'll get a compilation error:</p>
			<pre>const char * <strong class="bold">greeting</strong>{ "Hello\n" };
const auto la = []{ return <strong class="bold">greeting</strong>; };
cout &lt;&lt; la();</pre>
			<p>When I try to compile this with GCC, I get the following error:</p>
			<pre>In lambda function:
error: 'greeting' is not captured</pre>
			<p>This is because the body of the lambda has its own lexical scope and the <code>greeting</code> variable is outside of that scope.</p>
			<p>I can specify the <code>greeting</code> variable in a capture. This allows the variable into the scope of the lambda:</p>
			<pre>const char * <strong class="bold">greeting</strong>{ "Hello\n" };
const auto la = [<strong class="bold">greeting</strong>]{ return <strong class="bold">greeting</strong>; };
cout &lt;&lt; la();</pre>
			<p>Now it compiles and runs as expected:</p>
			<pre>$ ./working
Hello</pre>
			<p>This ability to capture variables outside its own scope is what makes a lambda a <em class="italic">closure</em>. People use the term in <a id="_idIndexMarker424"/>different ways, and that's fine, so long as we can understand each other. Still, it's good to know what the term means.</p>
			<p>Lambda expressions allow us to write good, clean generic code. They allow the use of <em class="italic">functional programming</em> patterns, where <a id="_idIndexMarker425"/>we can use lambdas as functional parameters to algorithms and even other lambdas.</p>
			<p>In this chapter, we will cover the use of lambdas with the STL, in the following recipes:</p>
			<ul>
				<li>Use lambdas for scoped reusable code</li>
				<li>Use lambdas as predicates with the algorithm library</li>
				<li>Use <code>std::function</code> as a polymorphic wrapper</li>
				<li>Concatenate lambdas with recursion</li>
				<li>Combine predicates with logical conjunction</li>
				<li>Call multiple lambdas with the same input</li>
				<li>Use mapped lambdas for a jump table</li>
			</ul>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Technical requirements</h1>
			<p>You can find the code for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap05">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap05</a>.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Use lambdas for scoped reusable code</h1>
			<p>Lambda expressions can be defined and stored for later use. They can be passed as parameters, stored <a id="_idIndexMarker426"/>in data structures, and called in different contexts with different parameters. They are as flexible as functions, but with the mobility of data.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>How to do it…</h2>
			<p>Let's start with a simple program that we'll use to test various configurations of lambda expressions:</p>
			<ul>
				<li>We'll first define a <code>main()</code> function and use it to experiment with lambdas:<pre>int main() {
    ... // code goes here
}</pre></li>
				<li>Inside the <code>main()</code> function, we'll declare a couple of lambdas. The basic definition of a lambda requires a pair of square brackets and a block of code in curly brackets:<pre>auto one = [](){ return "one"; };
auto two = []{ return "two"; };</pre></li>
			</ul>
			<p>Notice that the first example <code>one</code> includes parentheses after the square brackets, and the second example <code>two</code> does not. The empty parameter parentheses <a id="_idIndexMarker427"/>are commonly included, but are not always required. The return type is inferred by the compiler.</p>
			<ul>
				<li>I can call these functions with <code>cout</code>, or with <code>format</code>, or in any context that will take a C-string:<pre>cout &lt;&lt; one() &lt;&lt; '\n';
cout &lt;&lt; format("{}\n", two());</pre></li>
				<li>In many cases, the compiler can determine the return type from <em class="italic">automatic type deduction</em>. Otherwise, you can specify the return type with the <code>-&gt;</code> operator:<pre>auto one = []() <strong class="bold">-&gt; const char *</strong> { return "one"; };
auto two = []() <strong class="bold">-&gt; auto</strong> { return "two"; };</pre></li>
			</ul>
			<p>Lambdas use the <em class="italic">trailing return type</em> syntax. This consists of the <code>-&gt;</code> operator followed by the type specification. If the return type is not specified, it is considered <code>auto</code>. If you use a trailing return type, <em class="italic">the parameter parentheses are required</em>.</p>
			<ul>
				<li>Let's define a lambda to print out the values from our other lambdas:<pre>auto p = [](auto v) { cout &lt;&lt; v() &lt;&lt; '\n'; };</pre></li>
			</ul>
			<p>The <code>p()</code> lambda expects a lambda (or function) as its parameter <code>v</code>, and calls it in its function body.</p>
			<p>The <code>auto</code> type parameter makes this lambda an <em class="italic">abbreviated template</em>. Before C++20, this was the only way to template a lambda. Beginning with C++20, you may specify <a id="_idIndexMarker428"/>template parameters (without the <code>template</code> keyword) after the capture brackets. This is the equivalent with template parameters:</p>
			<pre>auto p = []&lt;template T&gt;(T v) { cout &lt;&lt; v() &lt;&lt; '\n'; };</pre>
			<p>The abbreviated <code>auto</code> version is simpler and more common. It works well for most purposes.</p>
			<ul>
				<li>Now we can pass an anonymous lambda in the function call:<pre>p([]{ return "lambda call lambda"; });</pre></li>
			</ul>
			<p>The output is:</p>
			<pre><strong class="bold">lambda call lambda</strong></pre>
			<ul>
				<li>If we need to pass parameters to an anonymous lambda, we can put them in parentheses after the lambda expression:<pre>&lt;&lt; [](auto l, auto r){ return l + r; }(47, 73)
    &lt;&lt; '\n';</pre></li>
			</ul>
			<p>The function parameters, <code>47</code> and <code>73</code>, are passed to the anonymous lambda in the parentheses after the function body.</p>
			<ul>
				<li>You can access variables from the outside scope of the lambda by including them as <em class="italic">captures</em> in the square brackets:<pre>int num{1};
p([num]{ return num; });</pre></li>
				<li>Or you can capture them by reference:<pre>int num{0};
auto inc = [&amp;num]{ num++; };
for (size_t i{0}; i &lt; 5; ++i) {
    inc();
}
cout &lt;&lt; num &lt;&lt; '\n';</pre></li>
			</ul>
			<p>The output is as follows:</p>
			<pre><strong class="bold">5</strong></pre>
			<p>This allows you to modify a captured variable.</p>
			<ul>
				<li>You can <a id="_idIndexMarker429"/>also define a local capture variable that maintains its state:<pre>auto counter = [<strong class="bold">n = 0</strong>]() <strong class="bold">mutable</strong> { return <strong class="bold">++n</strong>; };
for (size_t i{0}; i &lt; 5; ++i) {
    cout &lt;&lt; format("{}, ", counter());
}
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">1, 2, 3, 4, 5,</strong></pre>
			<p>The <code>mutable</code> specifier allows the lambda to modify its captures. Lambdas default to <code>const</code>-qualified.</p>
			<p>As with the trailing return type, any <em class="italic">specifier</em> requires the parameter parentheses.</p>
			<ul>
				<li>The lambda supports two types of <em class="italic">default capture</em>:<pre>int a = 47;
int b = 73;
auto l1 = []{ return a + b; };</pre></li>
			</ul>
			<p>If I try to compile this code, I get an error that includes:</p>
			<pre>note: the lambda has no capture-default</pre>
			<p>One type of default capture is indicated by an equal sign:</p>
			<pre>auto l1 = [<strong class="bold">=</strong>]{ return a + b; };</pre>
			<p>This will capture all the symbols in the lambda's scope. The equal sign performs <em class="italic">capture by copy</em>. It will capture a copy of the objects as if they were copied with an assignment operator.</p>
			<p>The other default capture uses an ampersand for <em class="italic">capture by reference</em>:</p>
			<pre>auto l1 = [<strong class="bold">&amp;</strong>]{ return a + b; };</pre>
			<p>This is a default capture that captures by reference.</p>
			<p>The default captures only use symbols when they are referenced, so they're not as messy as they may look. That said, I recommend explicit captures where possible as they generally improve readability.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>How it works…</h2>
			<p>The syntax of <a id="_idIndexMarker430"/>a lambda expression is as follows: </p>
			<div><div><img src="img/B18267_05_01.jpg" alt="Figure 5.1 – Syntax of the lambda expression&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Syntax of the lambda expression</p>
			<p>The only required parts of a lambda expression are the capture list and the body, which may be empty:</p>
			<pre>[]{}</pre>
			<p>This is the <a id="_idIndexMarker431"/>minimal lambda expression. It captures nothing and does nothing.</p>
			<p>Let's consider each of the parts.</p>
			<h3>Capture-list</h3>
			<p>The <em class="italic">capture-list</em> specifies <a id="_idIndexMarker432"/>what we capture, if anything. It cannot be omitted, but it may be empty. We can use <code>[=]</code> to capture all variables <em class="italic">by copy</em> or <code>[&amp;]</code> to capture all variables <em class="italic">by reference</em>, within the scope of the lambda.</p>
			<p>You may capture individual variables by listing them in the brackets:</p>
			<pre>[a, b]{ return a + b; }</pre>
			<p>The specified captures default to copy. You may capture by reference with the reference operator:</p>
			<pre>[&amp;a, &amp;b]{ return a + b; }</pre>
			<p>When you capture by reference, you may modify the referenced variable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You cannot capture object members directly. You may capture <code>this</code> or <code>*this</code> to dereference class members. </p>
			<h3>Parameters</h3>
			<p>As with a function, parameters <a id="_idIndexMarker433"/>are specified in parentheses:</p>
			<pre>[]<strong class="bold">(int a, int b)</strong>{ return a + b };</pre>
			<p>If there are no parameters, specifiers, or trailing return type, the parentheses are optional. A specifier or trailing return type makes the parentheses required:</p>
			<pre>[]<strong class="bold">() -&gt; int</strong> { return 47 + 73 };</pre>
			<h3>The mutable modifier (optional)</h3>
			<p>A lambda expression defaults to <code>const</code>-qualified unless you specify the <code>mutable</code> modifier. This allows <a id="_idIndexMarker434"/>it to be used in <code>const</code> context, but it also means that it cannot modify any of its captured-by-copy variables. For example:</p>
			<pre>[a]{ return ++a; };</pre>
			<p>This will fail to compile with an error message like this:</p>
			<pre>In lambda function:
error: increment of read-only variable 'a'</pre>
			<p>With the <code>mutable</code> modifier, the lambda is no longer <code>const</code>-qualified and the captured variable may be changed:</p>
			<pre>[a]() mutable { return ++a; };</pre>
			<h3>The constexpr specifier (optional)</h3>
			<p>You may use <code>constexpr</code> to explicitly specify that you want your lambda to be considered a <em class="italic">constant expression</em>. This means that it may be evaluated at compile time. If the <a id="_idIndexMarker435"/>lambda meets the requirements, it may be considered <code>constexpr</code> even without the specifier.</p>
			<h3>The exception attribute (optional)</h3>
			<p>You can use <a id="_idIndexMarker436"/>the <code>noexcept</code> specifier to declare that your lambda does not throw any exceptions.</p>
			<h3>The trailing return type (optional)</h3>
			<p>By default, the lambda <a id="_idIndexMarker437"/>return type is deduced from the <code>return</code> statement, as if it were an <code>auto</code> return type. You may optionally specify a <em class="italic">trailing return type</em> with the <code>-&gt;</code> operator:</p>
			<pre>[](int a, int b) -&gt; long { return a + b; };</pre>
			<p>The parameter parentheses are required if you use any of the optional specifiers or the trailing return type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Some compilers, including GCC, allow empty parameter parentheses to be omitted even when there's a specifier or trailing return type. This is not correct. According to the specification, the parameters, specifiers, and trailing return type are all part of the <em class="italic">lambda-declarator</em> and the parentheses are required when any part of it is included. This may change in a future version of C++.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Use lambdas as predicates with the algorithm library</h1>
			<p>Some functions in the <code>algorithm</code> library require the use of a <em class="italic">predicate</em> function. A predicate <a id="_idIndexMarker438"/>is a function (or functor or lambda) that <a id="_idIndexMarker439"/>tests a condition and returns a Boolean <code>true</code>/<code>false</code> response.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>How to do it…</h2>
			<p>For this recipe, we will experiment with the <code>count_if()</code> algorithm using different types of predicates:</p>
			<ul>
				<li>First, let's create a function for use as a predicate. A predicate takes a certain number of arguments and returns a <code>bool</code>. A predicate for <code>count_if()</code> takes one argument:<pre>bool is_div4(int i) {
    return i % 4 == 0;
}</pre></li>
			</ul>
			<p>This predicate checks whether an <code>int</code> value is divisible by 4.</p>
			<ul>
				<li>In <code>main()</code>, we'll define a vector of <code>int</code> values, and use it to test our predicate function with <code>count_if()</code>:<pre>int main() {
    const vector&lt;int&gt; v{ 1, 7, 4, 9, 4, 8, 12, 10, 20 };
    int count = <strong class="bold">count_if</strong>(v.begin(), v.end(), <strong class="bold">is_div4</strong>);
    cout &lt;&lt; format("numbers divisible by 4: {}\n", 
      count);
}</pre></li>
			</ul>
			<p>The output is as follows: </p>
			<pre><strong class="bold">numbers divisible by 4: 5</strong></pre>
			<p>(The 5 divisible numbers are: 4, 4, 8, 12, and 20.)</p>
			<p>The <code>count_if()</code> algorithm uses the predicate function to determine which elements <a id="_idIndexMarker440"/>of the sequence <a id="_idIndexMarker441"/>to count. It calls the predicate with each element as a parameter, and only counts the element if the predicate returns <code>true</code>.</p>
			<p>In this case, we used a function as a predicate.</p>
			<ul>
				<li>We could also use a <em class="italic">functor</em> as a predicate:<pre>struct is_div4 {
    bool operator()(int i) {
        return i % 4 == 0;
    }
};</pre></li>
			</ul>
			<p>The only change here is that we need to use an <em class="italic">instance</em> of the class as the predicate:</p>
			<pre>int count = count_if(v.begin(), v.end(), <strong class="bold">is_div4()</strong>);</pre>
			<p>The advantage of a functor is that it can carry context and access class and instance variables. This was the common way to use predicates before C++11 introduced lambda expressions.</p>
			<ul>
				<li>With a lambda expression, we have the best of both worlds: the simplicity of a function and the power of a functor. We can use a lambda as a variable:<pre>auto is_div4 = [](int i){ return i % 4 == 0; };
int count = count_if(v.begin(), v.end(), <strong class="bold">is_div4</strong>);</pre></li>
			</ul>
			<p>Or we can use an anonymous lambda:</p>
			<pre>int count = count_if(v.begin(), v.end(), 
    [](int i){ return i % 4 == 0; });</pre>
			<ul>
				<li>We can take advantage of the lambda capture by wrapping the lambda in a function, and using that function context to produce the same lambda with different parameters:<pre>auto is_div_by(int <strong class="bold">divisor</strong>) {
    return [<strong class="bold">divisor</strong>](int i){ return i % <strong class="bold">divisor</strong> == 0; };
}</pre></li>
			</ul>
			<p>This function returns a predicate lambda with the divisor from the capture context.</p>
			<p>We can then use that predicate with <code>count_if()</code>:</p>
			<pre>for( int i : { 3, 4, 5 } ) {
    auto <strong class="bold">pred</strong> = is_div_by(<strong class="bold">i</strong>);
    int count = count_if(v.begin(), v.end(), <strong class="bold">pred</strong>);
    cout &lt;&lt; format("numbers divisible by {}: {}\n", i,
      count);
}</pre>
			<p>Each <a id="_idIndexMarker442"/>call to <code>is_div_by()</code> returns <a id="_idIndexMarker443"/>a predicate with a different divisor from <code>i</code>. Now we get this output:</p>
			<pre><strong class="bold">numbers divisible by 3: 2</strong>
<strong class="bold">numbers divisible by 4: 5</strong>
<strong class="bold">numbers divisible by 5: 2</strong></pre>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>How it works…</h2>
			<p>The type of a function pointer is represented as a pointer followed by the function call <code>()</code> operator:</p>
			<pre>void (*)()</pre>
			<p>You can declare a function pointer and initialize it with the name of an existing function:</p>
			<pre>void (*fp)() = func;</pre>
			<p>Once declared, a function pointer may be dereferenced and used as if it were the function itself:</p>
			<pre>func();  // do the func thing</pre>
			<p>A lambda expression has the same type as a function pointer:</p>
			<pre>void (*fp)() = []{ cout &lt;&lt; "foo\n"; };</pre>
			<p>This <a id="_idIndexMarker444"/>means that wherever you use a <a id="_idIndexMarker445"/>function pointer with a certain signature, you may also use a lambda with the same signature. This allows function pointers, functors, and lambdas to work interchangeably:</p>
			<pre>bool (*fp)(int) = is_div4;
bool (*fp)(int) = [](int i){ return i % 4 == 0; };</pre>
			<p>Because of this interchangeability, an algorithm such as <code>count_if()</code> accepts a function, functor, or lambda where it expects a predicate with a particular function signature.</p>
			<p>This applies to any algorithm that uses a predicate.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor165"/>Use std::function as a polymorphic wrapper</h1>
			<p>The class <a id="_idIndexMarker446"/>template <code>std::function</code> is a <a id="_idIndexMarker447"/>thin polymorphic wrapper for functions. It can store, copy, and invoke any function, lambda expression, or other function objects. It can be useful in places where you would like to store a reference to a function or lambda. Using <code>std::function</code> allows you to store functions and lambdas with different signatures in the same container, and it maintains the context of lambda captures.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>How to do it…</h2>
			<p>This recipe uses the <code>std::function</code> class to store different specializations of a lambda in a <code>vector</code>:</p>
			<ul>
				<li>This recipe is contained in the <code>main()</code> function, where we start by declaring three containers of different types:<pre>int main() {
    deque&lt;int&gt; d;
    list&lt;int&gt; l;
    vector&lt;int&gt; v;</pre></li>
			</ul>
			<p>These <a id="_idIndexMarker448"/>containers, <code>deque</code>, <code>list</code>, and <code>vector</code>, will <a id="_idIndexMarker449"/>be referenced by a <em class="italic">template</em> lambda.</p>
			<ul>
				<li>We'll declare a simple <code>print_c</code> lambda function for printing out the containers:<pre>auto print_c = [](auto&amp; c) {
    for(auto i : c) cout &lt;&lt; format("{} ", i);
    cout &lt;&lt; '\n';
};</pre></li>
				<li>Now we declare a lambda that returns an <em class="italic">anonymous</em> lambda:<pre>auto push_c = [](auto&amp; <strong class="bold">container</strong>) {
    return <strong class="bold">[&amp;container]</strong>(auto value) {
        container.push_back(value);
    };
};</pre></li>
			</ul>
			<p>The <code>push_c</code> lambda takes a reference to a container, which is <em class="italic">captured</em> by the anonymous lambda. The anonymous lambda calls the <code>push_back()</code> member on the captured container. The return value from <code>push_c</code> is the anonymous lambda.</p>
			<ul>
				<li>Now we declare a <code>vector</code> of <code>std::function</code> elements, and populate it with three instances of <code>push_c()</code>:<pre>const vector&lt;std::function&lt;void(int)&gt;&gt; 
    consumers { push_c(<strong class="bold">d</strong>), push_c(<strong class="bold">l</strong>), push_c(<strong class="bold">v</strong>) };</pre></li>
			</ul>
			<p>Each of the <a id="_idIndexMarker450"/>elements in the initializer list <a id="_idIndexMarker451"/>is a function call to the <code>push_c</code> lambda. <code>push_c</code> returns an instance of the anonymous lambda, which gets stored in the <code>vector</code> via the <code>function</code> wrapper. The <code>push_c</code> lambda is called with the three containers, <code>d</code>, <code>l</code>, and <code>v</code>. The containers are passed as <em class="italic">captures</em> with the anonymous lambda.</p>
			<ul>
				<li>Now we loop through the <code>consumers</code> vector, and call each of the lambda elements 10 times, populating the three containers with integers 0–9 in each container:<pre>for(auto &amp;consume : consumers) {
    for (int i{0}; i &lt; 10; ++i) {
        consume(i);
    }
}</pre></li>
				<li>Now our three containers, the <code>deque</code>, <code>list</code>, and <code>vector</code>, should all be populated with integers. Let's print them out:<pre>print_c(d);
print_c(l);
print_c(v);</pre></li>
			</ul>
			<p>Our output should be:</p>
			<pre><strong class="bold">0 1 2 3 4 5 6 7 8 9</strong>
<strong class="bold">0 1 2 3 4 5 6 7 8 9</strong>
<strong class="bold">0 1 2 3 4 5 6 7 8 9</strong></pre>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>How it works…</h2>
			<p>Lambdas are often used with indirection and this recipe is a good example of such. For example, the <code>push_c</code> lambda returns an anonymous lambda:</p>
			<pre>auto push_c = [](auto&amp; container) {
    <strong class="bold">return</strong> [&amp;container](auto value) {
        container.push_back(value);
    };
};</pre>
			<p>This anonymous lambda is the one that's stored in the <code>vector</code>:</p>
			<pre>const vector&lt;std::function&lt;void(int)&gt;&gt; 
    consumers { push_c(d), push_c(l), push_c(v) };</pre>
			<p>This is the <a id="_idIndexMarker452"/>definition of the <code>consumers</code> container. It is initialized with three elements, where each element is initialized <a id="_idIndexMarker453"/>with a call to <code>push_c</code>, which returns an anonymous lambda. It's the anonymous lambda that gets stored in the vector, not the <code>push_c</code> lambda.</p>
			<p>The <code>vector</code> definition uses the <code>std::function</code> class as the type of the elements. The <code>function</code> constructor takes any callable object and stores its reference as the <code>function</code> target:</p>
			<pre>template&lt; class F &gt;
function( F&amp;&amp; f );</pre>
			<p>When its function call <code>()</code> operator is invoked, the <code>function</code> object calls the target function with the intended parameters:</p>
			<pre>for(auto <strong class="bold">&amp;c</strong> : consumers) {
    for (int i{0}; i &lt; 10; ++i) {
        <strong class="bold">c(i)</strong>;
    }
}</pre>
			<p>This calls <a id="_idIndexMarker454"/>each <em class="italic">anonymous lambda</em>, as <a id="_idIndexMarker455"/>stored in the <code>consumers</code> container, 10 times, thus populating the <code>d</code>, <code>l</code>, and <code>v</code> containers.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>There's more…</h2>
			<p>The nature of the <code>std::function</code> class makes it useful for many purposes. You can think of it as a <a id="_idIndexMarker456"/>polymorphic function container. It can store a standalone function:</p>
			<pre>void hello() {
    cout &lt;&lt; "hello\n";
}
int main() {
    function&lt;void(void)&gt; h = hello;
    h();
}</pre>
			<p>It can store a <a id="_idIndexMarker457"/>member function, using <code>std::bind</code> to bind function parameters:</p>
			<pre>struct hello {
    void greeting() const { cout &lt;&lt; "Hello Bob\n"; }
};
int main() {
    hello bob{};
    const function&lt;void(void)&gt; h = 
        std::bind(&amp;hello::greeting, &amp;bob);
    h();
}</pre>
			<p>Or it can store any executable object:</p>
			<pre>struct hello {
    void operator()() const { cout &lt;&lt; "Hello Bob\n"; }
};
int main() {
    const function&lt;void(void)&gt; h = hello();
    h();
}</pre>
			<p>The output is as follows:</p>
			<pre>Hello Bob</pre>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Concatenate lambdas with recursion</h1>
			<p>You can stack <a id="_idIndexMarker458"/>lambdas so that the output of one is the <a id="_idIndexMarker459"/>input of the next, using a simple recursive function. This creates a simple way to build one function upon another.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>How to do it…</h2>
			<p>This is a short and simple recipe that uses one recursive function to do most of the work:</p>
			<ul>
				<li>We'll start by defining the concatenation function <code>concat()</code>:<pre>template &lt;typename T, typename ...Ts&gt;
auto concat(T t, Ts ...ts) {
    if constexpr (sizeof...(ts) &gt; 0) {
        return <strong class="bold">[&amp;](auto ...parameters) {</strong>
<strong class="bold">            return t(concat(ts...)(parameters...)); </strong>
<strong class="bold">        };</strong>
    } else  {
        return t;
    }
}</pre></li>
			</ul>
			<p>This function returns an anonymous lambda, which in turn calls the function again, until the parameter pack is exhausted.</p>
			<ul>
				<li>In the <code>main()</code> function, we create a couple of lambdas and call the <code>concat()</code> function with them:<pre>int main() {
    auto twice = [](auto i) { return i * 2; };
    auto thrice = [](auto i) { return i * 3; };
    auto combined = <strong class="bold">concat(thrice, twice, </strong>
<strong class="bold">      std::plus&lt;int&gt;{});</strong>
    std::cout &lt;&lt; format("{}\n", combined(2, 3));
}</pre></li>
			</ul>
			<p>The <code>concat()</code> function is called with three parameters: two lambdas, and the <code>std::plus()</code> function.</p>
			<p>As the <a id="_idIndexMarker460"/>recursion unravels, the functions are <a id="_idIndexMarker461"/>called right-to-left, starting with <code>plus()</code>. The <code>plus()</code> function takes two arguments and returns the sum. The return value from <code>plus()</code> is passed to <code>twice()</code>, and its return value is passed to <code>thrice()</code>. The result is then printed to the console with <code>format()</code>:</p>
			<pre>30</pre>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>How it works…</h2>
			<p>The <code>concat()</code> function is simple, but may be confusing due to the <em class="italic">recursion</em> and the <em class="italic">indirection</em> of the returned lambda:</p>
			<pre>template &lt;typename T, typename ...Ts&gt;
auto concat(T t, Ts ...ts) {
    if constexpr (<strong class="bold">sizeof</strong>...(ts) &gt; 0) {
        <strong class="bold">return</strong> [&amp;](auto ...parameters) {
            <strong class="bold">return</strong> t(concat(ts...)(parameters...)); 
        };
    } else  {
        return t;
    }
}</pre>
			<p>The <code>concat()</code> function is called with a parameter pack. With ellipses, the <code>sizeof...</code> operator <a id="_idIndexMarker462"/>returns the number of elements <a id="_idIndexMarker463"/>in the parameter pack. This is used to test for the end of the recursion.</p>
			<p>The <code>concat()</code> function returns a lambda. The lambda recursively calls the <code>concat()</code> function. Because the first argument of <code>concat()</code> is not part of the parameter pack, each recursive call peels off the first element of the pack.</p>
			<p>The outer <code>return</code> statement returns the lambda. The inner <code>return</code> is from the lambda. The lambda calls the function that was passed to <code>concat()</code> and returns its value.</p>
			<p>Feel free to take this apart and study it. There's value in this technique.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Combine predicates with logical conjunction</h1>
			<p>This example <a id="_idIndexMarker464"/>wraps a lambda in a function to <a id="_idIndexMarker465"/>create a custom conjunction for use with an algorithm predicate.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor173"/>How to do it…</h2>
			<p>The <code>copy_if()</code> algorithm requires a predicate that takes one parameter. In this recipe, we will create a predicate lambda from three other lambdas:</p>
			<ul>
				<li>First, we'll write the <code>combine()</code> function. This function returns a lambda for use with the <code>copy_if()</code> algorithm:<pre>template &lt;typename F, typename A, typename B&gt;
auto combine(F binary_func, A a, B b) {
    return [=](auto param) {
        return binary_func(a(param), b(param));
    };
}</pre></li>
			</ul>
			<p>The <code>combine()</code> function takes three function parameters – a binary conjunction and two predicates – and returns a lambda that calls the conjunction with the two predicates.</p>
			<ul>
				<li>In the <code>main()</code> function, we create the lambdas for use with <code>combine()</code>:<pre>int main() {
    auto <strong class="bold">begins_with</strong> = [](const string &amp;s){
        return s.find("a") == 0;
    };
    auto <strong class="bold">ends_with</strong> = [](const string &amp;s){
        return s.rfind("b") == s.length() - 1;
    };
    auto <strong class="bold">bool_and</strong> = [](const auto&amp; l, const auto&amp; r){
        return l &amp;&amp; r;
    };</pre></li>
			</ul>
			<p>The <code>begins_with</code> and <code>ends_with</code> lambdas are simple filter predicates to find strings that begin with <code>'a'</code> and end with <code>'b'</code>, respectively. The <code>bool_and</code> lambda is the conjunction.</p>
			<ul>
				<li>Now we <a id="_idIndexMarker466"/>can call the <code>copy_if</code> algorithm <a id="_idIndexMarker467"/>with <code>combine()</code>:<pre>std::copy_if(istream_iterator&lt;string&gt;{cin}, {},
             ostream_iterator&lt;string&gt;{cout, " "},
             <strong class="bold">combine</strong>(bool_and, begins_with, 
<strong class="bold">               </strong>ends_with));
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>The <code>combine()</code> function returns a lambda that combines the two predicates with the conjunction.</p>
			<p>The output looks like the following:</p>
			<pre><strong class="bold">$ echo aabb bbaa foo bar abazb | ./conjunction</strong>
<strong class="bold">aabb abazb</strong></pre>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor174"/>How it works…</h2>
			<p>The <code>std::copy_if()</code> algorithm requires a predicate function that takes one parameter, but our conjunction requires two parameters, each of which require one parameter. We resolve this with a function that returns a lambda specifically for this context:</p>
			<pre>template &lt;typename F, typename A, typename B&gt;
auto combine(F <strong class="bold">binary_func</strong>, A <strong class="bold">a</strong>, B <strong class="bold">b</strong>) {
    return [=](auto <strong class="bold">param</strong>) {
        return binary_func(a(<strong class="bold">param</strong>), b(<strong class="bold">param</strong>));
    };
}</pre>
			<p>The <code>combine()</code> function creates a lambda from three parameters, each of which is a function. The <a id="_idIndexMarker468"/>returned lambda takes the one <a id="_idIndexMarker469"/>parameter that's required of the predicate function. Now we can call <code>copy_if()</code> with the <code>combine()</code> function:</p>
			<pre>std::copy_if(istream_iterator&lt;string&gt;{cin}, {},
             ostream_iterator&lt;string&gt;{cout, " "},
             <strong class="bold">combine(bool_and, begins_with, ends_with)</strong>);</pre>
			<p>This passes the combined lambda to the algorithm so it can operate within that context.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>Call multiple lambdas with the same input</h1>
			<p>You can easily create <a id="_idIndexMarker470"/>multiple instances of a lambda with different capture values by wrapping the lambda in a function. This allows you to call different versions of a lambda with the same input.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor176"/>How to do it…</h2>
			<p>This is a simple example of a lambda that wraps a value in different types of braces:</p>
			<ul>
				<li>We'll start by creating the wrapper function <code>braces()</code>:<pre>auto braces (const char a, const char b) {
    return [a, b](const char v) {
        cout &lt;&lt; format("{}{}{} ", a, v, b);
    };
}</pre></li>
			</ul>
			<p>The <code>braces()</code> function wraps a lambda that returns a three-value string, where the first and last values are characters passed to the lambda as captures, and the middle value is passed as a parameter.</p>
			<ul>
				<li>In the <code>main()</code> function, we use <code>braces()</code> to create four lambdas, using four different sets of braces:<pre>auto a = braces('(', ')');
auto b = braces('[', ']');
auto c = braces('{', '}');
auto d = braces('|', '|');</pre></li>
				<li>Now we can call our lambdas from a simple <code>for()</code> loop:<pre>for( int i : { 1, 2, 3, 4, 5 } ) {
    for( <strong class="bold">auto x</strong> : { a, b, c, d } ) <strong class="bold">x(i)</strong>;
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>This is two nested <code>for()</code> loops. The outer loop simply counts from 1 to 5, passing <a id="_idIndexMarker471"/>an integer to the inner loop. The inner loop calls the lambdas with the braces.</p>
			<p>Both loops use an <em class="italic">initializer list</em> as the container in a range-based <code>for()</code> loop. This is a convenient technique for looping through a small set of values. </p>
			<ul>
				<li>The output from our program looks like this:<pre><strong class="bold">(1) [1] {1} |1|</strong>
<strong class="bold">(2) [2] {2} |2|</strong>
<strong class="bold">(3) [3] {3} |3|</strong>
<strong class="bold">(4) [4] {4} |4|</strong>
<strong class="bold">(5) [5] {5} |5|</strong></pre></li>
			</ul>
			<p>The output shows each of the integers, in each combination of braces.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>How it works…</h2>
			<p>This is a simple example of how to use a wrapper for a lambda. The <code>braces()</code> function constructs a lambda using the braces passed to it:</p>
			<pre>auto braces (const char <strong class="bold">a</strong>, const char <strong class="bold">b</strong>) {
    return <strong class="bold">[a, b]</strong>(const auto v) {
        cout &lt;&lt; format("{}{}{} ", <strong class="bold">a</strong>, v, <strong class="bold">b</strong>);
    };
}</pre>
			<p>By passing the <code>braces()</code> function parameters to the lambda, it can return a lambda with that <a id="_idIndexMarker472"/>context. So, each of the assignments in the main function carries those parameters with it:</p>
			<pre>auto a = braces(<strong class="bold">'('</strong>, <strong class="bold">')'</strong>);
auto b = braces(<strong class="bold">'['</strong>, <strong class="bold">']'</strong>);
auto c = braces(<strong class="bold">'{'</strong>, <strong class="bold">'}'</strong>);
auto d = braces(<strong class="bold">'|'</strong>, <strong class="bold">'|'</strong>);</pre>
			<p>When these lambdas are called with a digit, they will return a string with that digit in the corresponding braces.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor178"/>Use mapped lambdas for a jump table</h1>
			<p>A jump table is a <a id="_idIndexMarker473"/>useful pattern when you want to select an action <a id="_idIndexMarker474"/>from a user or other input. Jump tables are often implemented in <code>if</code>/<code>else</code> or <code>switch</code> structures. In this recipe, we'll build a concise jump table using only an STL <code>map</code> and anonymous lambdas.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>How to do it…</h2>
			<p>It's easy to build a simple jump table from a <code>map</code> and lambdas. The <code>map</code> provides simple indexed navigation and the lambda can be stored as payload. Here's how to do it:</p>
			<ul>
				<li>First, we'll create a simple <code>prompt()</code> function to get input from the console:<pre>const char prompt(<strong class="bold">const char * p</strong>) {
    std::string <strong class="bold">r</strong>;
    cout &lt;&lt; format("{} &gt; ", p);
    <strong class="bold">std::getline</strong>(cin, <strong class="bold">r</strong>, '\n');
    if(r.size() &lt; 1) return '\0';
    if(r.size() &gt; 1) {
        cout &lt;&lt; "Response too long\n";
        return '\0';
    }
    return toupper(r[0]);
}</pre></li>
			</ul>
			<p>The C-string parameter is used as a prompt. <code>std::getline()</code> is called to get input from <a id="_idIndexMarker475"/>the user. The response is stored in <code>r</code>, checked <a id="_idIndexMarker476"/>for length, then if it's one character in length, it's converted to uppercase and returned.</p>
			<ul>
				<li>In the <code>main()</code> function, we declare and initialize a <code>map</code> of lambdas:<pre>using <strong class="bold">jumpfunc</strong> = <strong class="bold">void(*)()</strong>;
map&lt;const char, <strong class="bold">jumpfunc</strong>&gt; jumpmap {
    { 'A', []{ cout &lt;&lt; "func A\n"; } },
    { 'B', []{ cout &lt;&lt; "func B\n"; } },
    { 'C', []{ cout &lt;&lt; "func C\n"; } },
    { 'D', []{ cout &lt;&lt; "func D\n"; } },
    { 'X', []{ cout &lt;&lt; "Bye!\n"; } }
};</pre></li>
			</ul>
			<p>The <code>map</code> container is loaded with anonymous lambdas for the jump table. These lambdas could easily call other functions or perform simple tasks.</p>
			<p>The <code>using</code> alias is for convenience. We're using the function pointer type <code>void(*)()</code> for the lambda payload. If you prefer, you could use <code>std::function()</code> if you need more flexibility or if you just find it more readable. It has very little overhead:</p>
			<pre>using jumpfunc = std::function&lt;void()&gt;;</pre>
			<ul>
				<li>Now we can prompt for user input and select an action from the <code>map</code>:<pre>char select{};
while(select != 'X') {
    if((select = <strong class="bold">prompt("select A/B/C/D/X")</strong>)) {
        auto it = <strong class="bold">jumpmap.find(select)</strong>;
        if(it != jumpmap.end()) <strong class="bold">it-&gt;second()</strong>;
        else cout &lt;&lt; "Invalid response\n";
    }
}</pre></li>
			</ul>
			<p>This is how <a id="_idIndexMarker477"/>we use the <code>map</code>-based jump <a id="_idIndexMarker478"/>table. We loop until <code>'X'</code> is selected for exit. We call <code>prompt()</code> with a prompt string, call <code>find()</code> on the <code>map</code> object, then call the lambda with <code>it-&gt;second()</code>.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>How it works…</h2>
			<p>The <code>map</code> container makes an excellent jump table. It's concise and easy to navigate:</p>
			<pre>using jumpfunc = void(*)();
map&lt;const char, jumpfunc&gt; jumpmap {
    { 'A', []{ cout &lt;&lt; "func A\n"; } },
    { 'B', []{ cout &lt;&lt; "func B\n"; } },
    { 'C', []{ cout &lt;&lt; "func C\n"; } },
    { 'D', []{ cout &lt;&lt; "func D\n"; } },
    { 'X', []{ cout &lt;&lt; "Bye!\n"; } }
};</pre>
			<p>Anonymous <a id="_idIndexMarker479"/>lambdas are stored as payload in <a id="_idIndexMarker480"/>the <code>map</code> container. The keys are the character responses from the menu of actions.</p>
			<p>You can test the validity of a key and select a lambda in one action:</p>
			<pre>auto it = jumpmap.find(select);
if(it != jumpmap.end()) it-&gt;second();
else cout &lt;&lt; "Invalid response\n";</pre>
			<p>This is a simple, elegant solution, where we would have otherwise used awkward branching code.</p>
		</div>
	</body></html>