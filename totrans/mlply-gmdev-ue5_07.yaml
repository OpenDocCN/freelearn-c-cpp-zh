- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Remote Procedure Calls (RPCs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a strong grip on the world of property replication, it’s time
    to introduce you to the way in which functions can be called across the network.
    In Unreal, this is achieved through **Remote Procedure Calls** (**RPCs**) – one
    of the most powerful features of the engine networking system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to execute functions through RPCs and understand
    how to run them on the server, on a client, or on all clients that have an instance
    of a particular object.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you will learn about the common requirements for properly calling
    these types of functions – in particular, I will explain the difference between
    a reliable and an unreliable function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will obviously apply this newfound, precious knowledge to the project
    you have developed so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the next sections, I will present the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what an RPC is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing RPCs over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a door system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided in this book’s
    companion project repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 06``End` link.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what an RPC is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **RPC** is a function that can be called locally but is executed on a different
    machine – for instance, a server computer may call a function on a client computer
    that will command it to spawn a visual effect or a sound somewhere in the level.
    Another useful application of an RPC is the ability to send messages bi-directionally
    between a server and a client over a network connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of RPCs available in Unreal Engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server**: The function will be called by an object on the client PC but executed
    only on the server version of that same object. The client must own the object
    calling the method (if you need to, please check [*Chapter 5*](B18203_05.xhtml#_idTextAnchor107),
    *Managing Actors in a Multiplayer Environment*, for a refresher about owning an
    Actor).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: The function will be called on the server by an object but executed
    only on the client version that owns the object calling it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetMulticast**: The function can be called on the server by an object and
    executed on the server and all client versions of the object calling it. It can
    also be called by a client but, in this case, it will only be executed locally
    (i.e., on the client calling it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order for a function to be properly executed as an RPC, it must be called
    by an Actor and the Actor must be replicated. Additionally, the function needs
    to be decorated with the `UFUNCTION()` macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function that will run just on the owning client will be declared in the
    `.h` file as in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the corresponding `.cpp` file of the previous header, you will need to implement
    this function with the `_Implementation` suffix. The autogenerated code for this
    class – located in the `.generated.h` file – will automatically include a call
    to the `_Implementation` method when necessary. For a refresher on the `.generated.h`
    file, please check [*Chapter 4*](B18203_04.xhtml#_idTextAnchor086), *Setting Up
    Your First* *Multiplayer Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at an example, let’s say your `.h` header file has a method declaration
    similar to the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to implement the following function in your `.``cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A method is not always guaranteed to be received by the recipient due to performance
    reasons; however, this behavior can be adjusted, as demonstrated in the following
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Reliability of an RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RPCs are unreliable by default – this means there is no guarantee that the function
    call will reach its destination. This is usually acceptable if the executed code
    is not so important, such as a visual effect spawned on a client or a random noise
    played near the character; if the message is not received, the effect will simply
    not spawn or the sound won’t be heard, but gameplay will not be affected.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, some cases where you want to enforce reliability and guarantee
    that a message will securely arrive at its destination – as an example, in this
    chapter, you will execute the sprint action from the server side (you don’t really
    want to lose that very important interaction with the player). To make sure that
    an RPC call is executed on the remote machine, you can utilize the `Reliable`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this point, a function that should be executed reliably on a
    client will be declared with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will guarantee that the method call will be received by the client and
    properly executed, without any risk of data loss over the network because of unreliability.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using reliable RPCs during the `Tick()` event and exercise caution when
    binding them to player input. This is because players can repeatedly press buttons
    very quickly, leading to an overflow of the queue for reliable RPCs.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to reliability, you may want a method to be validated in order to
    be executed – this is something I’m going to show you right now!
  prefs: []
  type: TYPE_NORMAL
- en: Validating RPCs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unreal Engine offers an additional feature that adds the ability to check that
    functions will execute without bad data or input – this is what **validation**
    is all about.
  prefs: []
  type: TYPE_NORMAL
- en: To declare that a method should be validated for an RPC call, you need to add
    the `WithValidation` specifier to the `UFUNCTION()` declaration statement and
    implement an additional function that will return a `bool` type and be named as
    the validated function, but with the `_Validate` suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, a method marked with validation will have a declaration in the
    `.h` file, similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `.cpp` file, you will need to implement two methods. The first
    one will be the regular function, and will look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one will be the actual validation function, and will look like the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `_Validate` function will return `true` if the code is validated, or `false`
    otherwise. If validation succeeds, the corresponding method will be executed;
    otherwise, it won’t.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I have introduced RPCs and how Unreal Engine copes with them.
    Bear with me – if you’re working in the networked games industry, mastering RPCs
    is key to keeping your job and growing your career!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a solid understanding of how an RPC should be implemented,
    it’s time to write some code – and we are going to start by hunting down that
    pesky little bug that is stopping our thief hero from sprinting freely (and correctly!)
    around the dungeon.
  prefs: []
  type: TYPE_NORMAL
- en: Executing RPCs over the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll do some practice with RPCs by fixing the issue we are
    experiencing with making the character sprint correctly. As you may remember,
    when the character is sprinting on the client, you will get “jumpy” behavior –
    the character seems to start running but it is immediately brought back to a walking
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: This happens because the sprint action is being executed on the player client,
    but it is not being executed on the server, which is the one that is in command;
    hence, the override from the server slows the character to its move speed on every
    update. This means that you are trying to move your character at a sprint speed
    but, as soon as the server replicates the movement on the client, it will bring
    the character back to moving speed.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t even want the client to control this kind of important interaction
    – remember that it is the server who is in command – so, get back to the project
    and start typing some code to fix this problem!
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function on the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make our character run, we simply have to execute the movement speed change
    on the server, instead of on the client. This will guarantee total control over
    the behavior and correct replication on all clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the `US_Character.h` file and do some code declarations.
    In the `protected` section, add these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These functions have the `Server` attribute, which, as explained in the previous
    section, will execute them on the server. We have also added the `Reliable` attribute
    because we don’t want to lose this RPC due to the default unreliability of the
    system. The `_Server` suffix is not mandatory and is written just for clarity
    (some people use a prefix, so it is up to your personal taste!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the `US_Character.cpp` file and implement the two functions by adding
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code is pretty straightforward as we are just executing the speed change
    inside these two new functions and, in just a moment, we are going to remove them
    from their previous positions (i.e., from the client calls).
  prefs: []
  type: TYPE_NORMAL
- en: Here, just notice the `_Implementation` suffix – this is mandatory as the `SprintStart_Server()`
    and `SprintEnd_Server()` functions will be auto-generated by Unreal in the `.generated.h`
    class file and will be responsible for calling the actual implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to change the `SprintStart()` and `SprintEnd()` functions, in order
    to call the corresponding server fuctions (i.e., `SprintStart_Server()` and `SprintEnd_Server()`).
    Find those two functions and remove all their content (i.e., the changes to `MaxWalkSpeed`)
    and then, in the `SprintStart()` function, add this simple line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `SprintEnd()` function, add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To make the sprint action fully operational, we need to take one final step.
    At the moment, if the character is running and levels up, the movement will revert
    to walking speed. This happens because, in the `UpdateCharacterStats()` function,
    we set the `MaxWalkSpeed` property to the new walk speed, even if the character
    is sprinting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s fix this by finding the `UpdateCharacterStats()` method and adding, at
    its very beginning, the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This block of code just checks whether the character is sprinting and stores
    the result in a local variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, find this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following command just after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As easy as it is, if the character was sprinting, we would just call the corresponding
    method on the server to update everything properly.
  prefs: []
  type: TYPE_NORMAL
- en: We’re almost done with the movement management, but there are still a few small
    things we need to work on. Don’t worry though, we’re working hard to get everything
    done by the end of [*Chapter 10*](B18203_10.xhtml#_idTextAnchor196), *Enhancing
    the Player Experience*. So sit tight and stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have started implementing a simple RPC in your Character
    class. In particular, you have sent a command from the client that owns the character
    to the server, in order to properly update the movement speed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll add some more fancy RPCs for your game. Specifically,
    you’ll develop a nifty door-opening system. Get ready to flex those programming
    skills!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a door system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll repeat some of the previously explained topics about
    RPCs but with a small tweak – you’ll be developing some Actor-to-Actor communication
    over the network. What’s more, it will be between a C++ class – your character
    – and a Blueprint Class, a door that should be opened.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this behavior, you will use a feature that you previously created
    in [*Chapter 4*](B18203_04.xhtml#_idTextAnchor086), *Setting Up Your First Multiplayer
    Environment* – the interact action. It may have slipped your mind with all the
    stuff you have developed so far, but fear not – it’s time to dust it off and put
    it to work once again.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Interactable interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create communication between your character and the door, you’ll use an **interface**.
    As you may already know, interfaces in C++ are a powerful tool for creating abstractions
    between different classes. They allow you to define a contract that all implementing
    classes must adhere to, thereby allowing you to create code that is more maintainable,
    extensible, and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, interfaces differ from traditional programming interfaces
    in that it is not mandatory to implement all functions. Instead, it is optional
    to implement them. What’s more, you can declare an interface in C++ and implement
    it in a Blueprint – and that’s exactly what you’ll be doing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening your development IDE and creating a file named `US_Interactable.h`.
    Then, add the following code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice something weird in the code you just added – there are two classes.
    In order to properly declare an Unreal Engine interface, you need to declare two
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A class with a `U` prefix and extending `UInterface`: This is not the actual
    interface but an empty class whose sole aim is to make the class visible in the
    Unreal Engine system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A class with an `I` prefix: This is the actual interface and will contain all
    the interface method definitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the U-prefixed class is decorated with the `UINTERFACE()` macro
    and the `Blueprintable` attribute will let you implement this interface from a
    Blueprint. Isn’t it cool?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we declare a couple of functions called `Interact()` and `CanInteract()`,
    respectively. The two of them can be called and implemented in a Blueprint (thanks
    to the `BlueprintCallable` and `BlueprintNativeEvent` attributes).
  prefs: []
  type: TYPE_NORMAL
- en: Even though we will not be implementing the second function (i.e., `CanInteract()`)
    in our door Blueprint, it is nice to have such a feature – for instance, to check
    whether the character can open a door with a key that can be found somewhere in
    the dungeon. As I told you before, interfaces in Unreal Engine do not force implementation
    for all method declarations.
  prefs: []
  type: TYPE_NORMAL
- en: So, you have created an interface to allow the character to... well, interact
    with something. It’s time to let the thief character perform this heroic action
    – something you are going to implement in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the interact action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are now ready to get back to the `US_Character.h` header class and add some
    code logic for the interact action. As we have already done for the character
    movement, we will need to execute this interaction from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, open the header file and look for this declaration in the `protected`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the corresponding server call just after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As for the sprint action, this call must be `Reliable` as we need to make sure
    that it will be executed properly, and no information will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last step, add the following line of code to the `private` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You will be using this property as a reference to the object that should be
    interacted with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the header has been properly updated, open `US_Character.cpp` and
    add the following includes at the start of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, look for the `Interact()` method that, up to now, has just been an empty
    shell. Inside the method, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This code performs a simple RPC to the corresponding server interaction implementation.
    As you obviously need to implement the server call, add it to your code, just
    after the `Interact()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The call is executed only if a reference to the `InteractableActor` is found.
  prefs: []
  type: TYPE_NORMAL
- en: If you come from an OOP background and are not familiar with the way interfaces
    work in Unreal, this call may seem pretty weird – we are performing the call to
    an Actor reference without any type checking! This is the way interfaces work
    in Unreal Engine; they are just messages that are sent to an object reference.
    If the object does not implement that interface, the call will simply be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we want the call to be executed to something that can be interacted
    with (i.e., that implements the `US_Interactable` interface). To achieve this,
    we are going to continuously check whether the character is pointing at anything
    that implements the interface and, if something is found, we will reference it
    in the `InteractableActor` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for the `Tick()` method in your `.cpp` class and start adding the following
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do here is to check whether the instance that is executing
    the trace has the authority to do so – this means only the server will perform
    the traces for all the characters, and it’s obviously done to avoid cheating from
    the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we perform a regular sphere trace to check whether the character is pointing
    at something. If you are not familiar with an Unreal Engine **trace**, it is a
    tool used to detect collisions and overlapping between objects. It is used for
    things such as line of sight, weapon fire, and even AI pathfinding. Traces can
    be configured using parameters such as collision channels, object type filtering,
    shapes, start/end points, and so on, which allows you to specify exactly what
    kind of collision should be detected and how it should interact with the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the inner workings of traces in Unreal Engine, you
    can check the official documentation, which can be found here: [https://docs.unrealengine.com/5.1/en-US/traces-with-raycasts-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/traces-with-raycasts-in-unreal-engine/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the trace, the result is stored in the `HitResult` variable, which we
    are going to use to check whether we have found an interactable Actor. To do so,
    add the next code just after the code you have just written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous check is the core of our interaction control – if the object that
    has been traced implements the `US_Interactable` interface, we store the reference
    and draw a magenta-colored debug sphere for testing purposes. If nothing is found,
    we just clean up the `InteractableActor` property from any previous reference.
  prefs: []
  type: TYPE_NORMAL
- en: To check that everything works as expected, you can open Unreal Engine Editor
    and, after compiling, you can play the game. The server should now draw a red
    sphere trace for each character and turn green when hitting something. We still
    don’t have anything to interact with, so you will not see the debug sphere.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, you will implement a door Blueprint that will react
    to the character interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the door Blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s now time to create something that can be interacted with, and we will
    do this by adding some doors to the dungeon. So, let’s open the `Blueprints` folder
    and complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Blueprint Class derived from **Actor**, name it **BP_WoodenDoor**,
    and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, check the **Replicates** attribute to enable replication
    for this Actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **StaticMesh** component and assign the door mesh to the **Static** **Mesh**
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Components** panel, select the **StaticMesh** component and, in the
    **Details** panel, check **Component Replicates** to enable replication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result should be similar to the one depicted in *Figure 7**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The wooden door Blueprint](img/Figure_07_01_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The wooden door Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the Event Graph and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a variable of type `DoorOpen`. In its **Details** panel, set the **Replication**
    property to **Replicated**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Class Settings** tab and, in the **Interfaces** category, add the
    **US_Interactable** interface. This will add the **Interfaces** section into the
    **My** **Blueprint** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Interfaces** section of the **My Blueprint** tab, open the **Interaction**
    category, right-click on the **Interact** method, and select **Implement Event**.
    This will add an **Event Interact** node on the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the outgoing pin of the event, add a **Branch** node and, in the **Condition**
    pin, add a getter node of the **DoorOpen** variable from the **Variables** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **False** pin of the **Branch** node to a **Setter** node for the
    **Door Open** variable and check this last node’s incoming value pin to set it
    to **True**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Event Graph created so far is shown in *Figure 7**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Door check](img/Figure_07_02_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Door check
  prefs: []
  type: TYPE_NORMAL
- en: The graph at the moment is quite simple; it’s just checking whether the door
    has already been opened and, if it is closed, marks it as open. You are going
    to complete the Blueprint by making the door mesh rotate in an opening animation.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the outgoing pin of the **Set Door Open** node to a **Timeline** node.
    Call this node **DoorOpening** and double-click on it to open its corresponding
    graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Float Track** and call it **RotationZ**. Add two keys to the track with
    the values **(0, 0)** and **(1, -****90)** respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The timeline window is shown in *Figure 7**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The door timeline window](img/Figure_07_03_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The door timeline window
  prefs: []
  type: TYPE_NORMAL
- en: Return to the main Event Graph and drag a reference of the **StaticMesh** component
    from the **Components** panel into the graph itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing pin of this reference to a **Set Relative** **Rotation**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **New Rotation** pin and select **Split Struct Pin** to expose
    the **New Rotation** **Z** value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Update** execution pin of the **Timeline** node to the incoming
    execution pin of the **Set Relative Rotation** node. Connect the **Rotation Z**
    pin with the **New Rotation Z** to complete the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This final part of the graph is depicted in *Figure 7**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The second part of the graph](img/Figure_07_04_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The second part of the graph
  prefs: []
  type: TYPE_NORMAL
- en: This part of the graph will just start a rotation animation on the *z* axis
    of the mesh, making it open when interacted with.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now give the thief hero a moment to shine and roam the dungeon, eagerly
    opening doors to seek out prisoners to liberate and treasures to unearth!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the interact action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your game level and drag an instance or two of the door Blueprint to start
    testing the game. Whenever the server-controlled sphere trace hits a door, you
    should be able to see a magenta-colored sphere, indicating that the object can
    be interacted with. Hitting the *I* key on the client will open the door and show
    the hidden treasures (or perils!) behind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result of the interaction check, along with the debug sphere, is
    displayed in *Figure 7**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The interaction check in action](img/Figure_07_05_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – The interaction check in action
  prefs: []
  type: TYPE_NORMAL
- en: So, the door system has finally been created and you are now free to put as
    many doors as you want inside the dungeon. As an additional exercise, you can
    create a Blueprint child class from **BP_WoodenDoor** and use the **door_gate**
    mesh to add some kind of variation to your level.
  prefs: []
  type: TYPE_NORMAL
- en: In this final section, you have implemented a Blueprint that allows the character
    to interact with other Actors in the game. Specifically, you have created a door
    system that can be opened through player interaction and will be synchronized
    over the network. This means that every connected player will see the correct
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to one of the most important and useful
    features of the Unreal Engine multiplayer environment, remote procedure calls,
    or RPCs. As you have seen, they allow you to execute functions from a server to
    a client and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you called requests from the client to the server, by improving
    the character sprint system and by adding interaction logic between the character
    and other Actors in the game (i.e., the dungeon doors). Rest assured that, by
    the end of the book, you will also have seen other use cases for RPCs as they
    are quite ubiquitous in multiplayer games.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter ends the second part of this book – starting from the next chapter,
    you’ll be working on implementing some AI logic over the network. Let’s spice
    things up by rounding up those pesky Lichlord minions and giving our character
    a challenge to step up to!
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:Improving Your Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the book, you will discover how to enhance your game’s appeal
    to players. This process begins with the creation of captivating opponents. Afterward,
    you will augment the capabilities of the player characters and add some non-player
    characters to interact with. Additionally, you will learn how to troubleshoot
    and debug networked systems within Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18203_08.xhtml#_idTextAnchor162), *Introducing AI into a Multiplayer
    Environment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18203_09.xhtml#_idTextAnchor174), *Extending AI Behaviors*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18203_10.xhtml#_idTextAnchor196), *Enhancing the Player Experience*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18203_11.xhtml#_idTextAnchor215), *Debugging a Multiplayer
    Game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
