- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Using Remote Procedure Calls (RPCs)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程过程调用（RPCs）
- en: Now that you have a strong grip on the world of property replication, it’s time
    to introduce you to the way in which functions can be called across the network.
    In Unreal, this is achieved through **Remote Procedure Calls** (**RPCs**) – one
    of the most powerful features of the engine networking system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对属性复制的世界有了牢固的把握，是时候向你介绍函数如何在网络上调用的方式了。在Unreal中，这是通过**远程过程调用**（**RPCs**）实现的——这是引擎网络系统中最强大的功能之一。
- en: In this chapter, you will learn how to execute functions through RPCs and understand
    how to run them on the server, on a client, or on all clients that have an instance
    of a particular object.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何通过RPC执行函数，并理解如何在服务器、客户端或所有具有特定对象实例的客户端上运行它们。
- en: Additionally, you will learn about the common requirements for properly calling
    these types of functions – in particular, I will explain the difference between
    a reliable and an unreliable function.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将了解正确调用这些类型函数的常见要求——特别是，我将解释可靠函数和不可靠函数之间的区别。
- en: Finally, you will obviously apply this newfound, precious knowledge to the project
    you have developed so far.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你显然会将这新获得、宝贵的知识应用到迄今为止你开发的项目中。
- en: 'So, in the next sections, I will present the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在接下来的几节中，我将介绍以下主题：
- en: Understanding what an RPC is
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解RPC是什么
- en: Executing RPCs over the network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上执行RPCs
- en: Implementing a door system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现门系统
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟进本章中介绍的主题，你应该已经完成了前面的章节，并理解了它们的内容。
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided in this book’s
    companion project repository:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你希望从本书的配套仓库开始，你可以下载本书配套项目仓库中提供的`.zip`项目文件：
- en: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)'
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 06``End` link.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击`Unreal Shadows –` `Chapter 06``End`链接下载与最后一章结尾一致的文件。
- en: Understanding what an RPC is
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解RPC是什么
- en: An **RPC** is a function that can be called locally but is executed on a different
    machine – for instance, a server computer may call a function on a client computer
    that will command it to spawn a visual effect or a sound somewhere in the level.
    Another useful application of an RPC is the ability to send messages bi-directionally
    between a server and a client over a network connection.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**RPC**是一个可以在本地调用但在不同机器上执行的函数——例如，服务器计算机可以调用客户端计算机上的函数，命令它在关卡中的某个地方生成视觉效果或声音。RPC的另一个有用应用是能够在服务器和客户端之间通过网络连接双向发送消息。'
- en: 'There are three types of RPCs available in Unreal Engine:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine中提供了三种类型的RPCs：
- en: '**Server**: The function will be called by an object on the client PC but executed
    only on the server version of that same object. The client must own the object
    calling the method (if you need to, please check [*Chapter 5*](B18203_05.xhtml#_idTextAnchor107),
    *Managing Actors in a Multiplayer Environment*, for a refresher about owning an
    Actor).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：该函数将由客户端PC上的对象调用，但仅在相同对象的服务器版本上执行。客户端必须拥有调用该方法的对象（如果你需要，请检查[*第五章*](B18203_05.xhtml#_idTextAnchor107)，*在多人环境中管理Actor*，以复习关于拥有Actor的内容）。'
- en: '**Client**: The function will be called on the server by an object but executed
    only on the client version that owns the object calling it.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：该函数将由对象在服务器上调用，但仅在调用该函数的对象所属的客户端版本上执行。'
- en: '**NetMulticast**: The function can be called on the server by an object and
    executed on the server and all client versions of the object calling it. It can
    also be called by a client but, in this case, it will only be executed locally
    (i.e., on the client calling it).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NetMulticast**：该函数可以由对象在服务器上调用并在服务器和调用该函数的对象的所有客户端版本上执行。它也可以由客户端调用，但在此情况下，它将仅在本地执行（即，在调用它的客户端上）。'
- en: In order for a function to be properly executed as an RPC, it must be called
    by an Actor and the Actor must be replicated. Additionally, the function needs
    to be decorated with the `UFUNCTION()` macro.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一个函数能够作为 RPC 正确执行，它必须由 Actor 调用，并且 Actor 必须是复制的。此外，该函数需要使用 `UFUNCTION()`
    宏进行装饰。
- en: 'A function that will run just on the owning client will be declared in the
    `.h` file as in the following piece of code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在拥有客户端上运行的功能将在 `.h` 文件中声明，如下代码片段所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the corresponding `.cpp` file of the previous header, you will need to implement
    this function with the `_Implementation` suffix. The autogenerated code for this
    class – located in the `.generated.h` file – will automatically include a call
    to the `_Implementation` method when necessary. For a refresher on the `.generated.h`
    file, please check [*Chapter 4*](B18203_04.xhtml#_idTextAnchor086), *Setting Up
    Your First* *Multiplayer Environment*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个头文件对应的 `.cpp` 文件中，你需要使用 `_Implementation` 后缀来实现这个函数。这个类的自动生成代码位于 `.generated.h`
    文件中，当需要时，它将自动包含对 `_Implementation` 方法的调用。关于 `.generated.h` 文件的更多信息，请参阅[*第4章*](B18203_04.xhtml#_idTextAnchor086)，*设置您的第一个*
    *多人游戏环境*。
- en: 'Looking at an example, let’s say your `.h` header file has a method declaration
    similar to the following piece of code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 看一个例子，假设你的 `.h` 头文件中的方法声明类似于以下代码片段：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will need to implement the following function in your `.``cpp` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的 `.cpp` 文件中实现以下函数：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A method is not always guaranteed to be received by the recipient due to performance
    reasons; however, this behavior can be adjusted, as demonstrated in the following
    subsection.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能原因，方法并不总是能保证被接收者接收到；然而，这种行为是可以调整的，如下小节所示。
- en: Reliability of an RPC
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RPC 的可靠性
- en: RPCs are unreliable by default – this means there is no guarantee that the function
    call will reach its destination. This is usually acceptable if the executed code
    is not so important, such as a visual effect spawned on a client or a random noise
    played near the character; if the message is not received, the effect will simply
    not spawn or the sound won’t be heard, but gameplay will not be affected.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 默认是不可靠的——这意味着无法保证函数调用能够到达目的地。如果执行代码不是那么重要，例如在客户端生成视觉效果或播放靠近角色的随机噪音，这通常是可接受的；如果消息没有收到，效果将不会生成或声音将不会被听到，但游戏玩法不会受到影响。
- en: There are, however, some cases where you want to enforce reliability and guarantee
    that a message will securely arrive at its destination – as an example, in this
    chapter, you will execute the sprint action from the server side (you don’t really
    want to lose that very important interaction with the player). To make sure that
    an RPC call is executed on the remote machine, you can utilize the `Reliable`
    keyword.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下，你希望强制执行可靠性并确保消息能够安全地到达目的地——例如，在本章中，你将从服务器端执行冲刺动作（你真的不希望失去与玩家的重要交互）。为了确保
    RPC 调用在远程机器上执行，你可以使用 `Reliable` 关键字。
- en: 'To illustrate this point, a function that should be executed reliably on a
    client will be declared with the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，一个应该在客户端可靠执行的功能将被以下代码声明：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will guarantee that the method call will be received by the client and
    properly executed, without any risk of data loss over the network because of unreliability.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将保证方法调用将被客户端接收并正确执行，不会因为网络不可靠而存在数据丢失的风险。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Avoid using reliable RPCs during the `Tick()` event and exercise caution when
    binding them to player input. This is because players can repeatedly press buttons
    very quickly, leading to an overflow of the queue for reliable RPCs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在 `Tick()` 事件中使用可靠的 RPC，并且在将它们绑定到玩家输入时要小心。这是因为玩家可以非常快速地重复按按钮，导致可靠 RPC 队列溢出。
- en: In addition to reliability, you may want a method to be validated in order to
    be executed – this is something I’m going to show you right now!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可靠性之外，你可能还希望有一个方法在执行前进行验证——这正是我现在要向你展示的！
- en: Validating RPCs
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 RPCs
- en: Unreal Engine offers an additional feature that adds the ability to check that
    functions will execute without bad data or input – this is what **validation**
    is all about.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 提供了一个额外的功能，它增加了检查函数是否会在没有坏数据或输入的情况下执行的能力——这就是**验证**的全部内容。
- en: To declare that a method should be validated for an RPC call, you need to add
    the `WithValidation` specifier to the `UFUNCTION()` declaration statement and
    implement an additional function that will return a `bool` type and be named as
    the validated function, but with the `_Validate` suffix.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个方法应该为RPC调用进行验证，你需要在`UFUNCTION()`声明语句中添加`WithValidation`指定符，并实现一个额外的函数，该函数将返回`bool`类型，并以验证函数的名称命名，但带有`_Validate`后缀。
- en: 'As an example, a method marked with validation will have a declaration in the
    `.h` file, similar to the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，带有验证的函数在`.h`文件中的声明将类似于以下代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, in the `.cpp` file, you will need to implement two methods. The first
    one will be the regular function, and will look like the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`.cpp`文件中，你需要实现两个方法。第一个将是常规函数，其代码如下：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second one will be the actual validation function, and will look like the
    following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个将是实际的验证函数，其代码如下：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `_Validate` function will return `true` if the code is validated, or `false`
    otherwise. If validation succeeds, the corresponding method will be executed;
    otherwise, it won’t.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`_Validate`函数将返回`true`如果代码已验证，否则返回`false`。如果验证成功，相应的函数将被执行；否则，它将不会执行。'
- en: In this section, I have introduced RPCs and how Unreal Engine copes with them.
    Bear with me – if you’re working in the networked games industry, mastering RPCs
    is key to keeping your job and growing your career!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我介绍了RPC以及虚幻引擎如何处理它们。请耐心等待——如果你在联网游戏行业工作，掌握RPC是保持你的工作和职业发展的关键！
- en: Now that you have a solid understanding of how an RPC should be implemented,
    it’s time to write some code – and we are going to start by hunting down that
    pesky little bug that is stopping our thief hero from sprinting freely (and correctly!)
    around the dungeon.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对如何实现RPC有了坚实的理解，是时候编写一些代码了——我们将从追踪那个讨厌的小虫子开始，它阻止我们的盗贼英雄在地下城中自由（且正确地）冲刺。
- en: Executing RPCs over the network
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上执行RPC
- en: In this section, you’ll do some practice with RPCs by fixing the issue we are
    experiencing with making the character sprint correctly. As you may remember,
    when the character is sprinting on the client, you will get “jumpy” behavior –
    the character seems to start running but it is immediately brought back to a walking
    speed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将通过修复角色正确冲刺的问题来练习使用RPC。如你所记，当角色在客户端冲刺时，你会得到“跳跃”的行为——角色似乎开始奔跑，但立即被恢复到步行速度。
- en: This happens because the sprint action is being executed on the player client,
    but it is not being executed on the server, which is the one that is in command;
    hence, the override from the server slows the character to its move speed on every
    update. This means that you are trying to move your character at a sprint speed
    but, as soon as the server replicates the movement on the client, it will bring
    the character back to moving speed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为冲刺动作是在玩家客户端上执行的，但并没有在服务器上执行，而服务器才是掌握控制权的一方；因此，来自服务器的覆盖操作会在每次更新时将角色移动速度减慢。这意味着你试图以冲刺速度移动你的角色，但一旦服务器在客户端复制了移动动作，它就会将角色速度恢复到正常移动速度。
- en: We don’t even want the client to control this kind of important interaction
    – remember that it is the server who is in command – so, get back to the project
    and start typing some code to fix this problem!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至不希望客户端控制这种重要交互——记住，服务器才是掌握控制权的一方——所以，回到项目中，开始编写一些代码来修复这个问题！
- en: Calling a function on the server
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器上调用函数
- en: To make our character run, we simply have to execute the movement speed change
    on the server, instead of on the client. This will guarantee total control over
    the behavior and correct replication on all clients.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要让我们的角色跑步，我们只需在服务器上执行移动速度的改变，而不是在客户端。这将确保对行为有完全的控制，并在所有客户端上正确复制。
- en: 'Let’s start by opening the `US_Character.h` file and do some code declarations.
    In the `protected` section, add these two methods:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`US_Character.h`文件并进行一些代码声明开始。在`protected`部分，添加以下两个方法：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These functions have the `Server` attribute, which, as explained in the previous
    section, will execute them on the server. We have also added the `Reliable` attribute
    because we don’t want to lose this RPC due to the default unreliability of the
    system. The `_Server` suffix is not mandatory and is written just for clarity
    (some people use a prefix, so it is up to your personal taste!).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数具有`Server`属性，正如前一小节所述，它将在服务器上执行它们。我们还添加了`Reliable`属性，因为我们不希望由于系统的默认不可靠性而丢失这个RPC。`_Server`后缀不是强制性的，只是为了清晰（有些人使用前缀，所以这取决于个人喜好！）。
- en: 'Now open the `US_Character.cpp` file and implement the two functions by adding
    the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`US_Character.cpp`文件，通过添加以下代码来实现这两个函数：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code is pretty straightforward as we are just executing the speed change
    inside these two new functions and, in just a moment, we are going to remove them
    from their previous positions (i.e., from the client calls).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单，因为我们只是在两个新函数中执行速度更改，并且很快，我们将从它们之前的位置（即客户端调用）中移除它们。
- en: Here, just notice the `_Implementation` suffix – this is mandatory as the `SprintStart_Server()`
    and `SprintEnd_Server()` functions will be auto-generated by Unreal in the `.generated.h`
    class file and will be responsible for calling the actual implementations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，请注意`_Implementation`后缀——这是强制性的，因为`SprintStart_Server()`和`SprintEnd_Server()`函数将由Unreal在`.generated.h`类文件中自动生成，并负责调用实际实现。
- en: 'We now need to change the `SprintStart()` and `SprintEnd()` functions, in order
    to call the corresponding server fuctions (i.e., `SprintStart_Server()` and `SprintEnd_Server()`).
    Find those two functions and remove all their content (i.e., the changes to `MaxWalkSpeed`)
    and then, in the `SprintStart()` function, add this simple line of code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要更改`SprintStart()`和`SprintEnd()`函数，以便调用相应的服务器函数（即`SprintStart_Server()`和`SprintEnd_Server()`）。找到这两个函数，删除它们的所有内容（即对`MaxWalkSpeed`的更改），然后在`SprintStart()`函数中添加以下简单代码行：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `SprintEnd()` function, add this line of code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SprintEnd()`函数中添加以下代码行：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To make the sprint action fully operational, we need to take one final step.
    At the moment, if the character is running and levels up, the movement will revert
    to walking speed. This happens because, in the `UpdateCharacterStats()` function,
    we set the `MaxWalkSpeed` property to the new walk speed, even if the character
    is sprinting.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使冲刺动作完全可用，我们需要采取最后一步。目前，如果角色正在奔跑并升级，移动速度将恢复到步行速度。这是因为，在`UpdateCharacterStats()`函数中，我们将`MaxWalkSpeed`属性设置为新的步行速度，即使角色正在冲刺。
- en: 'Let’s fix this by finding the `UpdateCharacterStats()` method and adding, at
    its very beginning, the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过找到`UpdateCharacterStats()`方法并在其开头添加以下代码来解决这个问题：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This block of code just checks whether the character is sprinting and stores
    the result in a local variable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是检查角色是否在冲刺，并将结果存储在局部变量中。
- en: 'Then, find this line of code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，找到以下代码行：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following command just after it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在它之后添加以下命令：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As easy as it is, if the character was sprinting, we would just call the corresponding
    method on the server to update everything properly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很简单，但如果角色正在冲刺，我们只需在服务器上调用相应的方法来正确更新一切。
- en: We’re almost done with the movement management, but there are still a few small
    things we need to work on. Don’t worry though, we’re working hard to get everything
    done by the end of [*Chapter 10*](B18203_10.xhtml#_idTextAnchor196), *Enhancing
    the Player Experience*. So sit tight and stay tuned!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了移动管理，但还有一些小事情需要我们处理。不过别担心，我们正在努力确保在[*第10章*](B18203_10.xhtml#_idTextAnchor196)，“增强玩家体验”结束前完成一切。所以请耐心等待，保持关注！
- en: In this section, you have started implementing a simple RPC in your Character
    class. In particular, you have sent a command from the client that owns the character
    to the server, in order to properly update the movement speed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经开始在你的角色类中实现简单的RPC。具体来说，你从拥有角色的客户端发送了一个命令到服务器，以便正确更新移动速度。
- en: In the next section, you’ll add some more fancy RPCs for your game. Specifically,
    you’ll develop a nifty door-opening system. Get ready to flex those programming
    skills!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将为你的游戏添加一些更复杂的RPC。特别是，你将开发一个巧妙的开门系统。准备好展示你的编程技能吧！
- en: Implementing a door system
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现门系统
- en: In this section, you’ll repeat some of the previously explained topics about
    RPCs but with a small tweak – you’ll be developing some Actor-to-Actor communication
    over the network. What’s more, it will be between a C++ class – your character
    – and a Blueprint Class, a door that should be opened.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将重复一些之前解释过的关于 RPC 的主题，但会有一个小调整——你将在网络上开发一些 Actor 到 Actor 的通信。更重要的是，它将在一个
    C++ 类——你的角色——和一个蓝图类——一个应该被打开的门——之间进行。
- en: To accomplish this behavior, you will use a feature that you previously created
    in [*Chapter 4*](B18203_04.xhtml#_idTextAnchor086), *Setting Up Your First Multiplayer
    Environment* – the interact action. It may have slipped your mind with all the
    stuff you have developed so far, but fear not – it’s time to dust it off and put
    it to work once again.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种行为，你将使用你在 [*第 4 章*](B18203_04.xhtml#_idTextAnchor086) 中创建的功能，即 *设置您的第一个多人游戏环境*——交互动作。由于你至今为止开发的所有内容，它可能已经从你的脑海中溜走了，但不用担心——现在是时候把它翻出来，再次投入使用。
- en: Creating the Interactable interface
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建交互式界面
- en: To create communication between your character and the door, you’ll use an **interface**.
    As you may already know, interfaces in C++ are a powerful tool for creating abstractions
    between different classes. They allow you to define a contract that all implementing
    classes must adhere to, thereby allowing you to create code that is more maintainable,
    extensible, and reusable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的角色和门之间建立通信，您将使用一个 **接口**。正如你可能已经知道的，C++ 中的接口是创建不同类之间抽象的强大工具。它们允许你定义一个所有实现类都必须遵守的合同，从而允许你创建更易于维护、扩展和重用的代码。
- en: In Unreal Engine, interfaces differ from traditional programming interfaces
    in that it is not mandatory to implement all functions. Instead, it is optional
    to implement them. What’s more, you can declare an interface in C++ and implement
    it in a Blueprint – and that’s exactly what you’ll be doing here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unreal Engine 中，接口与传统编程接口的不同之处在于，不是必须实现所有函数。相反，实现它们是可选的。更重要的是，你可以在 C++ 中声明一个接口，并在蓝图（Blueprint）中实现它——这正是你在这里要做的。
- en: 'Let’s start by opening your development IDE and creating a file named `US_Interactable.h`.
    Then, add the following code to the file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开您的开发 IDE 并创建一个名为 `US_Interactable.h` 的文件开始。然后，将以下代码添加到该文件中：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You may notice something weird in the code you just added – there are two classes.
    In order to properly declare an Unreal Engine interface, you need to declare two
    classes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到你刚刚添加的代码中有些奇怪的地方——有两个类。为了正确地声明 Unreal Engine 接口，你需要声明两个类：
- en: 'A class with a `U` prefix and extending `UInterface`: This is not the actual
    interface but an empty class whose sole aim is to make the class visible in the
    Unreal Engine system'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `U` 前缀的类并扩展 `UInterface`：这并不是实际的接口，而是一个空类，其唯一目的是使该类在 Unreal Engine 系统中可见
- en: 'A class with an `I` prefix: This is the actual interface and will contain all
    the interface method definitions'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `I` 前缀的类：这是实际的接口，将包含所有接口方法定义
- en: As you can see, the U-prefixed class is decorated with the `UINTERFACE()` macro
    and the `Blueprintable` attribute will let you implement this interface from a
    Blueprint. Isn’t it cool?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，带有 U 前缀的类被 `UINTERFACE()` 宏和 `Blueprintable` 属性装饰，这将允许你从蓝图（Blueprint）中实现此接口。这不是很酷吗？
- en: Finally, we declare a couple of functions called `Interact()` and `CanInteract()`,
    respectively. The two of them can be called and implemented in a Blueprint (thanks
    to the `BlueprintCallable` and `BlueprintNativeEvent` attributes).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明了两个函数，分别命名为 `Interact()` 和 `CanInteract()`。这两个函数可以在蓝图（Blueprint）中调用和实现（多亏了
    `BlueprintCallable` 和 `BlueprintNativeEvent` 属性）。
- en: Even though we will not be implementing the second function (i.e., `CanInteract()`)
    in our door Blueprint, it is nice to have such a feature – for instance, to check
    whether the character can open a door with a key that can be found somewhere in
    the dungeon. As I told you before, interfaces in Unreal Engine do not force implementation
    for all method declarations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会在我们的门蓝图（Blueprint）中实现第二个函数（即 `CanInteract()`），但拥有这样的功能是很好的——例如，检查角色是否可以使用在地下某个地方找到的钥匙打开门。正如我之前告诉你的，Unreal
    Engine 中的接口不会强制实现所有方法声明。
- en: So, you have created an interface to allow the character to... well, interact
    with something. It’s time to let the thief character perform this heroic action
    – something you are going to implement in the next subsection.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经创建了一个接口，允许角色与...好吧，与某物交互。现在是时候让盗贼角色执行这个英勇行为——你将在下一个子节中实现的行为。
- en: Implementing the interact action
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现交互动作
- en: You are now ready to get back to the `US_Character.h` header class and add some
    code logic for the interact action. As we have already done for the character
    movement, we will need to execute this interaction from the server.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好回到`US_Character.h`头文件类，并为交互动作添加一些代码逻辑。因为我们已经为角色移动做了，我们需要从服务器执行这个交互。
- en: 'To do so, open the header file and look for this declaration in the `protected`
    section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，打开头文件，并在`protected`部分查找以下声明：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the corresponding server call just after it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在它之后添加相应的服务器调用：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As for the sprint action, this call must be `Reliable` as we need to make sure
    that it will be executed properly, and no information will be lost.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 至于冲刺动作，这个调用必须是`Reliable`的，因为我们需要确保它将被正确执行，并且不会丢失任何信息。
- en: 'As a last step, add the following line of code to the `private` section:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，将以下代码行添加到`private`部分：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You will be using this property as a reference to the object that should be
    interacted with.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用这个属性作为与对象交互的引用。
- en: 'Now that the header has been properly updated, open `US_Character.cpp` and
    add the following includes at the start of the file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在头文件已经正确更新，打开`US_Character.cpp`文件，在文件开头添加以下包含语句：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, look for the `Interact()` method that, up to now, has just been an empty
    shell. Inside the method, add the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，查找到目前为止只是一个空壳的`Interact()`方法。在方法内部，添加以下代码：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code performs a simple RPC to the corresponding server interaction implementation.
    As you obviously need to implement the server call, add it to your code, just
    after the `Interact()` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行一个简单的RPC调用到相应的服务器交互实现。显然，你需要实现服务器调用，将其添加到你的代码中，紧随`Interact()`函数之后：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The call is executed only if a reference to the `InteractableActor` is found.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当找到`InteractableActor`的引用时，才会执行此调用。
- en: If you come from an OOP background and are not familiar with the way interfaces
    work in Unreal, this call may seem pretty weird – we are performing the call to
    an Actor reference without any type checking! This is the way interfaces work
    in Unreal Engine; they are just messages that are sent to an object reference.
    If the object does not implement that interface, the call will simply be lost.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自面向对象编程（OOP）背景，并且不熟悉Unreal中接口的工作方式，这个调用可能看起来相当奇怪——我们在没有类型检查的情况下对Actor引用执行调用！这是Unreal
    Engine中接口工作的方式；它们只是发送给对象引用的消息。如果对象没有实现该接口，调用将简单地丢失。
- en: Obviously, we want the call to be executed to something that can be interacted
    with (i.e., that implements the `US_Interactable` interface). To achieve this,
    we are going to continuously check whether the character is pointing at anything
    that implements the interface and, if something is found, we will reference it
    in the `InteractableActor` property.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们希望调用执行到可以与之交互的东西（即实现了`US_Interactable`接口的东西）。为了实现这一点，我们将持续检查角色是否指向实现了该接口的任何东西，如果找到，我们将在`InteractableActor`属性中引用它。
- en: 'Look for the `Tick()` method in your `.cpp` class and start adding the following
    piece of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`.cpp`类中查找`Tick()`方法，并开始添加以下代码片段：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing we do here is to check whether the instance that is executing
    the trace has the authority to do so – this means only the server will perform
    the traces for all the characters, and it’s obviously done to avoid cheating from
    the client side.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的第一件事是检查执行跟踪的实例是否有权这样做——这意味着只有服务器将为所有角色执行跟踪，这显然是为了避免客户端作弊。
- en: Then, we perform a regular sphere trace to check whether the character is pointing
    at something. If you are not familiar with an Unreal Engine **trace**, it is a
    tool used to detect collisions and overlapping between objects. It is used for
    things such as line of sight, weapon fire, and even AI pathfinding. Traces can
    be configured using parameters such as collision channels, object type filtering,
    shapes, start/end points, and so on, which allows you to specify exactly what
    kind of collision should be detected and how it should interact with the environment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行一个常规的球体跟踪来检查角色是否指向某个东西。如果你不熟悉Unreal Engine中的**跟踪**，它是一种用于检测对象之间碰撞和重叠的工具。它用于诸如视线、武器发射甚至AI路径查找等事物。跟踪可以通过诸如碰撞通道、对象类型过滤、形状、起点/终点等参数进行配置，这允许你指定应该检测哪种类型的碰撞以及它应该如何与环境交互。
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about the inner workings of traces in Unreal Engine, you
    can check the official documentation, which can be found here: [https://docs.unrealengine.com/5.1/en-US/traces-with-raycasts-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/traces-with-raycasts-in-unreal-engine/).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于虚幻引擎中追踪内部工作原理的信息，您可以查看官方文档，链接如下：[https://docs.unrealengine.com/5.1/en-US/traces-with-raycasts-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/traces-with-raycasts-in-unreal-engine/)。
- en: 'After the trace, the result is stored in the `HitResult` variable, which we
    are going to use to check whether we have found an interactable Actor. To do so,
    add the next code just after the code you have just written:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在追踪后，结果存储在`HitResult`变量中，我们将使用它来检查我们是否找到了可交互的Actor。为此，在您刚刚编写的代码之后添加以下代码：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous check is the core of our interaction control – if the object that
    has been traced implements the `US_Interactable` interface, we store the reference
    and draw a magenta-colored debug sphere for testing purposes. If nothing is found,
    we just clean up the `InteractableActor` property from any previous reference.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的检查是我们交互控制的核心 - 如果被追踪的对象实现了`US_Interactable`接口，我们存储引用并绘制一个洋红色调试球体以进行测试。如果没有找到任何东西，我们只需从任何以前的引用中清理`InteractableActor`属性。
- en: To check that everything works as expected, you can open Unreal Engine Editor
    and, after compiling, you can play the game. The server should now draw a red
    sphere trace for each character and turn green when hitting something. We still
    don’t have anything to interact with, so you will not see the debug sphere.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查一切是否按预期工作，您可以打开虚幻引擎编辑器，编译后，您可以玩游戏。现在服务器应该为每个角色绘制一个红色球体轨迹，当击中物体时变为绿色。我们还没有任何可以与之交互的东西，所以您不会看到调试球体。
- en: In the next subsection, you will implement a door Blueprint that will react
    to the character interaction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，您将实现一个对角色交互做出反应的门蓝图。
- en: Creating the door Blueprint
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建门蓝图
- en: 'It’s now time to create something that can be interacted with, and we will
    do this by adding some doors to the dungeon. So, let’s open the `Blueprints` folder
    and complete the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建可以与之交互的东西了，我们将通过添加一些门到地牢中来实现这一点。所以，让我们打开`Blueprints`文件夹并完成以下步骤：
- en: Create a new Blueprint Class derived from **Actor**, name it **BP_WoodenDoor**,
    and open it.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的从**Actor**派生的蓝图类，命名为**BP_WoodenDoor**，并打开它。
- en: In the **Details** panel, check the **Replicates** attribute to enable replication
    for this Actor.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**细节**面板中，勾选**复制**属性以启用此Actor的复制。
- en: Add a **StaticMesh** component and assign the door mesh to the **Static** **Mesh**
    property.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**静态网格**组件，并将门网格分配给**静态****网格**属性。
- en: In the **Components** panel, select the **StaticMesh** component and, in the
    **Details** panel, check **Component Replicates** to enable replication.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**组件**面板中，选择**静态网格**组件，然后在**细节**面板中，勾选**组件复制**以启用复制。
- en: 'The final result should be similar to the one depicted in *Figure 7**.1*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该类似于*图7.1*1*所示：
- en: '![Figure 7.1 – The wooden door Blueprint](img/Figure_07_01_B18203.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 木门蓝图](img/Figure_07_01_B18203.jpg)'
- en: Figure 7.1 – The wooden door Blueprint
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 木门蓝图
- en: 'Now, open the Event Graph and do the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开事件图，执行以下操作：
- en: Create a variable of type `DoorOpen`. In its **Details** panel, set the **Replication**
    property to **Replicated**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为`DoorOpen`的变量。在其**细节**面板中，将**复制**属性设置为**已复制**。
- en: Select the **Class Settings** tab and, in the **Interfaces** category, add the
    **US_Interactable** interface. This will add the **Interfaces** section into the
    **My** **Blueprint** window.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**类设置**选项卡，然后在**接口**类别中添加**US_Interactable**接口。这将向**我的****蓝图**窗口添加**接口**部分。
- en: In the **Interfaces** section of the **My Blueprint** tab, open the **Interaction**
    category, right-click on the **Interact** method, and select **Implement Event**.
    This will add an **Event Interact** node on the Event Graph.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**我的蓝图**标签页的**接口**部分，打开**交互**类别，右键单击**交互**方法，并选择**实现事件**。这将向事件图添加一个**事件交互**节点。
- en: From the outgoing pin of the event, add a **Branch** node and, in the **Condition**
    pin, add a getter node of the **DoorOpen** variable from the **Variables** section.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从事件的输出引脚添加一个**分支**节点，并在**条件**引脚中添加**DoorOpen**变量的获取节点，该变量位于**变量**部分。
- en: Connect the **False** pin of the **Branch** node to a **Setter** node for the
    **Door Open** variable and check this last node’s incoming value pin to set it
    to **True**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**分支**节点的**False**引脚连接到**Door Open**变量的**Setter**节点，并检查此最后一个节点的输入值引脚以将其设置为**True**。
- en: 'The Event Graph created so far is shown in *Figure 7**.2*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止创建的事件图在*图7.2*中显示：
- en: '![Figure 7.2 – Door check](img/Figure_07_02_B18203.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 门检查](img/Figure_07_02_B18203.jpg)'
- en: Figure 7.2 – Door check
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 门检查
- en: The graph at the moment is quite simple; it’s just checking whether the door
    has already been opened and, if it is closed, marks it as open. You are going
    to complete the Blueprint by making the door mesh rotate in an opening animation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的图表相当简单；它只是检查门是否已经打开，如果它是关闭的，则将其标记为打开。你将通过使门网格在开启动画中旋转来完成蓝图。
- en: Connect the outgoing pin of the **Set Door Open** node to a **Timeline** node.
    Call this node **DoorOpening** and double-click on it to open its corresponding
    graph.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Set Door Open**节点的输出引脚连接到**时间线**节点。将此节点命名为**DoorOpening**，并双击它以打开其相应的图表。
- en: Add a **Float Track** and call it **RotationZ**. Add two keys to the track with
    the values **(0, 0)** and **(1, -****90)** respectively.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**浮点轨迹**并将其命名为**RotationZ**。在轨迹上添加两个键，分别具有值**(0, 0)**和**(1, -90)**。
- en: 'The timeline window is shown in *Figure 7**.3*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线窗口在*图7.3*中显示：
- en: '![Figure 7.3 – The door timeline window](img/Figure_07_03_B18203.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 门时间线窗口](img/Figure_07_03_B18203.jpg)'
- en: Figure 7.3 – The door timeline window
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 门时间线窗口
- en: Return to the main Event Graph and drag a reference of the **StaticMesh** component
    from the **Components** panel into the graph itself.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回主事件图，并将**静态网格**组件的引用从**组件**面板拖动到图中本身。
- en: Connect the outgoing pin of this reference to a **Set Relative** **Rotation**
    node.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此引用的输出引脚连接到**设置相对旋转**节点。
- en: Right-click on the **New Rotation** pin and select **Split Struct Pin** to expose
    the **New Rotation** **Z** value.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**新旋转**引脚并选择**拆分结构引脚**以暴露**新旋转**的**Z**值。
- en: Connect the **Update** execution pin of the **Timeline** node to the incoming
    execution pin of the **Set Relative Rotation** node. Connect the **Rotation Z**
    pin with the **New Rotation Z** to complete the graph.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**时间线**节点的**更新**执行引脚连接到**设置相对旋转**节点的输入执行引脚。将**Rotation Z**引脚连接到**新旋转 Z**以完成图表。
- en: 'This final part of the graph is depicted in *Figure 7**.3*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的最后部分在*图7.3*中描述：
- en: '![Figure 7.4 – The second part of the graph](img/Figure_07_04_B18203.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 图表的第二部分](img/Figure_07_04_B18203.jpg)'
- en: Figure 7.4 – The second part of the graph
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 图表的第二部分
- en: This part of the graph will just start a rotation animation on the *z* axis
    of the mesh, making it open when interacted with.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的这一部分将仅在网格的*z*轴上启动旋转动画，使其在交互时打开。
- en: Let’s now give the thief hero a moment to shine and roam the dungeon, eagerly
    opening doors to seek out prisoners to liberate and treasures to unearth!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们给盗贼英雄一个展示的时刻，让他自由地在地牢中游荡，急切地打开门，寻找要解放的囚犯和要挖掘的宝藏！
- en: Testing the interact action
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试交互动作
- en: Open your game level and drag an instance or two of the door Blueprint to start
    testing the game. Whenever the server-controlled sphere trace hits a door, you
    should be able to see a magenta-colored sphere, indicating that the object can
    be interacted with. Hitting the *I* key on the client will open the door and show
    the hidden treasures (or perils!) behind.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的游戏关卡，并将门蓝图的一个或两个实例拖动到图中开始测试游戏。每当服务器控制的球体追踪击中门时，你应该能看到一个洋红色的球体，表示该对象可以交互。在客户端按下*I*键将打开门并显示隐藏的宝藏（或危险！）。
- en: 'The final result of the interaction check, along with the debug sphere, is
    displayed in *Figure 7**.4*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 交互检查的最终结果，连同调试球体，在*图7.4*中显示：
- en: '![Figure 7.5 – The interaction check in action](img/Figure_07_05_B18203.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 交互检查的实际操作](img/Figure_07_05_B18203.jpg)'
- en: Figure 7.5 – The interaction check in action
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 交互检查的实际操作
- en: So, the door system has finally been created and you are now free to put as
    many doors as you want inside the dungeon. As an additional exercise, you can
    create a Blueprint child class from **BP_WoodenDoor** and use the **door_gate**
    mesh to add some kind of variation to your level.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，门系统最终已经创建，你现在可以自由地在地牢中放置尽可能多的门。作为额外的练习，你可以从**BP_WoodenDoor**创建一个蓝图子类，并使用**door_gate**网格为你的关卡添加一些变化。
- en: In this final section, you have implemented a Blueprint that allows the character
    to interact with other Actors in the game. Specifically, you have created a door
    system that can be opened through player interaction and will be synchronized
    over the network. This means that every connected player will see the correct
    updates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，你已经实现了一个蓝图，允许角色与游戏中的其他Actors进行交互。具体来说，你创建了一个可以通过玩家交互打开的门系统，并且将在网络上进行同步。这意味着每个连接的玩家都将看到正确的更新。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you were introduced to one of the most important and useful
    features of the Unreal Engine multiplayer environment, remote procedure calls,
    or RPCs. As you have seen, they allow you to execute functions from a server to
    a client and vice versa.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你被介绍到了虚幻引擎多人环境中最重要且最有用的功能之一，远程过程调用，或称RPC。正如你所见，它们允许你从服务器执行函数到客户端，反之亦然。
- en: In this chapter, you called requests from the client to the server, by improving
    the character sprint system and by adding interaction logic between the character
    and other Actors in the game (i.e., the dungeon doors). Rest assured that, by
    the end of the book, you will also have seen other use cases for RPCs as they
    are quite ubiquitous in multiplayer games.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过改进角色冲刺系统和在角色与其他游戏中的Actors（例如，地牢门）之间添加交互逻辑，从客户端向服务器发起请求。请放心，到本书结束时，你也将看到RPC的其他用例，因为它们在多人游戏中非常普遍。
- en: This chapter ends the second part of this book – starting from the next chapter,
    you’ll be working on implementing some AI logic over the network. Let’s spice
    things up by rounding up those pesky Lichlord minions and giving our character
    a challenge to step up to!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书的第二部分——从下一章开始，你将开始在网络中实现一些AI逻辑。让我们通过总结那些讨厌的Lichlord小兵，并给我们的角色一个挑战来提升自己来增加一些趣味吧！
- en: Part 3:Improving Your Game
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：提升你的游戏
- en: In this part of the book, you will discover how to enhance your game’s appeal
    to players. This process begins with the creation of captivating opponents. Afterward,
    you will augment the capabilities of the player characters and add some non-player
    characters to interact with. Additionally, you will learn how to troubleshoot
    and debug networked systems within Unreal Engine.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，你将发现如何增强你的游戏对玩家的吸引力。这个过程从创建吸引人的对手开始。之后，你将增强玩家角色的能力，并添加一些非玩家角色进行交互。此外，你还将学习如何在虚幻引擎中调试和修复网络系统。
- en: 'This part includes the following chapters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 8*](B18203_08.xhtml#_idTextAnchor162), *Introducing AI into a Multiplayer
    Environment*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18203_08.xhtml#_idTextAnchor162)，*将AI引入多人环境*'
- en: '[*Chapter 9*](B18203_09.xhtml#_idTextAnchor174), *Extending AI Behaviors*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18203_09.xhtml#_idTextAnchor174)，*扩展AI行为*'
- en: '[*Chapter 10*](B18203_10.xhtml#_idTextAnchor196), *Enhancing the Player Experience*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18203_10.xhtml#_idTextAnchor196)，*增强玩家体验*'
- en: '[*Chapter 11*](B18203_11.xhtml#_idTextAnchor215), *Debugging a Multiplayer
    Game*'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18203_11.xhtml#_idTextAnchor215)，*调试多人游戏*'
