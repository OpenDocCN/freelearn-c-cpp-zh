<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-251"><a id="_idTextAnchor251"/>12</h1>
<h1 id="_idParaDest-252"><a id="_idTextAnchor252"/>Project #6 – Tracking and Notifying about Your Heart Rate</h1>
<p>This chapter is dedicated to smart healthcare and wearables. It shows how healthcare devices can be integrated with the <strong class="bold">Arduino IoT Cloud platform</strong> and offers an example of an interface between the Arduino IoT Cloud and a third-party service. The notification service sends notifications to recipients when the measured heart rate exceeds the defined heart rate threshold.</p>
<p>In this chapter, we will embark on a practical exploration of smart health and wearables by working with a <strong class="bold">heart rate sensor</strong> and Seeed Studio’s newest and very small development board in the <strong class="bold">XIAO series</strong>, based on <strong class="bold">ESP32</strong> with a lot of features. With the help of a sensor, a development board, and the Arduino IoT Cloud, we will build an IoT-enabled wearable healthcare solution. You will also learn how to set up webhooks for sending the latest heart rate values to Zapier. Finally, you will see how to set up Zaps in Zapier for email/mobile notifications on heart rate data.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Exploring IoT for smart health solutions</li>
<li>Knowing the hardware components – sensors and development boards</li>
<li>Understanding the project architecture</li>
<li>Setting up Things, network credentials, cloud variables, and code</li>
<li>Setting up a dashboard for web and mobile</li>
<li>Setting up the notification service</li>
</ul>
<h1 id="_idParaDest-253"><a id="_idTextAnchor253"/>Technical requirements</h1>
<p>The following hardware components are required to complete this chapter’s exercise:</p>
<ul>
<li>Seeed Studio XIAO ESP32C3</li>
<li>USB Type-C cable for the XIAO ESP32C3</li>
<li>Pulse sensor (find the complete details and store links in the <em class="italic">Knowing the hardware components – sensors and development </em><em class="italic">boards</em> section)</li>
<li>Male headers for the development board</li>
<li>Jumper cables</li>
</ul>
<p>For coding, we will use the <strong class="bold">Arduino Web Editor</strong>, which includes a large collection of development boards and sensor libraries, along with Arduino IoT Cloud for Thing and dashboard setup. To develop hardware and sensor designs, we need the <strong class="bold">Fritzing</strong> desktop software and the <strong class="bold">Arduino IDE</strong> desktop software for pulse-sensor calibration using the <strong class="bold">Serial Plotter</strong>, which is not available in the Arduino Web Editor.</p>
<p>We will also use <strong class="bold">Zapier</strong> to send alerts by email when our sensor detects a heart rate above our specified <strong class="bold">beats-per-minute</strong> (<strong class="bold">BPM</strong>) threshold. You can use a Free/trial account or buy a Zapier Professional plan according to the requirements of your project as Zapier Professional provides more features and functions compared to a Free account. The code used in this chapter is available from the book’s official GitHub repository at <a href="https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers">https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers</a>.</p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor254"/>Exploring IoT for smart health solutions</h1>
<p>The <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) is <a id="_idIndexMarker942"/>playing a significant role in providing smart healthcare solutions that can improve patient outcomes and reduce healthcare costs. IoT devices can collect real-time data, communicate with other devices, and generate insights that can help healthcare providers make better decisions.</p>
<p>Here are some examples of how IoT can be used in smart health solutions:</p>
<ul>
<li><strong class="bold">Remote patient monitoring</strong>: IoT devices<a id="_idIndexMarker943"/> can be used to monitor patients’ health in real time, even when they are not in the hospital. Wearable devices, sensors, and medical-grade IoT devices can collect data on vital signs, BPM rates, blood-glucose levels, and medication adherence. Healthcare providers can use this data to provide personalized care and prevent complications.</li>
<li><strong class="bold">Telemedicine</strong>: IoT devices<a id="_idIndexMarker944"/> can enable virtual consultations and remote medical services. Patients can communicate with their healthcare providers using video conferencing, and healthcare providers can remotely monitor patients’ health through IoT devices. This can improve access to healthcare services, reduce healthcare costs, and improve patient outcomes.</li>
<li><strong class="bold">Smart medication management</strong>: IoT <a id="_idIndexMarker945"/>devices can help patients manage their medications more effectively. IoT-enabled pill dispensers can remind patients when it’s time to take their medication and can track medication usage. Healthcare providers can use this data to provide personalized care and prevent medication errors.</li>
<li><strong class="bold">Predictive maintenance</strong>: IoT devices<a id="_idIndexMarker946"/> can be used to monitor medical equipment and predict when maintenance is required. This can help prevent equipment failures, reduce downtime, and improve patient outcomes.</li>
<li><strong class="bold">Smart hospital management</strong>: IoT devices <a id="_idIndexMarker947"/>can be used to manage hospital resources more efficiently. For example, IoT-enabled asset tracking systems can help healthcare providers locate medical equipment quickly, reducing waiting times for patients.</li>
</ul>
<p>In conclusion, IoT <a id="_idIndexMarker948"/>can enable smart health solutions that improve patient outcomes and reduce healthcare costs. Healthcare providers can use IoT data to provide personalized care and make more informed decisions. As IoT technology continues to evolve, we can expect to see even more innovative healthcare solutions in the future.</p>
<p>In this section, we have discussed IoT and smart healthcare and how IoT is beneficial to us in the development of smart healthcare products. Next, we will take a look at what types of hardware and sensors are required to carry out the exercise in this chapter.</p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor255"/>Knowing the hardware components – sensors and development boards</h1>
<p>The ESP32 series <a id="_idIndexMarker949"/>offers a wide array of development boards that vary in the sizes and pins offered. In this chapter, we are<a id="_idIndexMarker950"/> using Seeed Studio’s latest <a id="_idIndexMarker951"/>development board, the <strong class="bold">XIAO ESP32C3</strong>, as it’s <a id="_idIndexMarker952"/>very compact and smaller in size than other boards, cheaper in cost, and provides 5V along with 3.3V. <em class="italic">Figure 12</em><em class="italic">.1</em> shows a pin diagram of the XIAO ESP32C3 we will use:</p>
<div><div><img alt="Figure 12.1 – XIAO ESP32C3 pinout diagram" src="img/B19752_12_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – XIAO ESP32C3 pinout diagram</p>
<p>The XIAO ESP32C3 provides multiple pins for digital input/output. In previous ESP-series boards such as the ESP8266, we only had one analog pin, but we have four on this development board, which removes the biggest hurdle encountered when developing solutions using multiple analog pins. To get around this on previous ESP-series boards, we had to use <strong class="bold">ADS1115</strong>/<strong class="bold">ADS1015</strong> for extra <a id="_idIndexMarker953"/>analog pins, so this development board will save you some bucks with its four analog pins by default.</p>
<p>Besides these features, XIAO provides a built-in battery charge module and the board is optimized for power consumption, which make this board appropriate for developing wearable devices. For connectivity, both Wi-Fi and Bluetooth are available, including <strong class="bold">Bluetooth Low Energy</strong> (<strong class="bold">BLE</strong>) <strong class="bold">5 support</strong>, which<a id="_idIndexMarker954"/> is more specific to IoT use cases. For further details, please visit <a href="https://wiki.seeedstudio.com/XIAO_ESP32C3_Getting_Started/">https://wiki.seeedstudio.com/XIAO_ESP32C3_Getting_Started/</a>.</p>
<p>For our current project, we need one analog pin <a id="_idIndexMarker955"/>for the <strong class="bold">pulse sensor</strong>, and a5V pin for power. One of the good features of our chosen development board is that we have a 5V power pin, which is not available in most of the ESP32 series development boards.</p>
<p>We use the<a id="_idIndexMarker956"/> pulse sensor to measure the BPM but there is a variety of other pulse oximeters on the market for BPM and pulse measurement. The following pulse sensor (<em class="italic">Figure 12</em><em class="italic">.2</em>) is open source, cheaper, and easier to use than other sensors. You can also use Chinese-made pulse sensors but you will require controlled conditions while using these sensors.</p>
<div><div><img alt="Figure 12.2 – Pulse sensor and its pinout diagram" src="img/B19752_12_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Pulse sensor and its pinout diagram</p>
<p>The following is a list of official stores where you can buy the original pulse sensor:</p>
<ul>
<li><strong class="bold">SparkFun</strong>: <a href="https://www.sparkfun.com/products/11574">https://www.sparkfun.com/products/11574</a></li>
<li><strong class="bold">Adafruit</strong>: <a href="https://www.adafruit.com/product/1093">https://www.adafruit.com/product/1093</a></li>
<li><strong class="bold">Amazon </strong><strong class="bold">UK</strong>: <a href="https://www.amazon.co.uk/dp/B01CPP4QM0">https://www.amazon.co.uk/dp/B01CPP4QM0</a></li>
<li><strong class="bold">Amazon </strong><strong class="bold">USA</strong>: <a href="https://www.amazon.com/PulseSensor-com-Original-Pulse-Sensor-project/dp/B01CPP4QM0">https://www.amazon.com/PulseSensor-com-Original-Pulse-Sensor-project/dp/B01CPP4QM0</a></li>
</ul>
<p>The preceding figure shows the pinout layout of the pulse sensor. <em class="italic">Pin #1</em> is the GND pin, which connects to the onboard GND pin. <em class="italic">Pin #2</em>, VCC, works with both 3.3V and 5V. <em class="italic">Pin #3</em> connects to any analog pin on the board. I connect it to <em class="italic">Pin #A1</em> on the board. You can solder the male <a id="_idIndexMarker957"/>headers to the pulse sensor or directly solder the cables without any header pins.</p>
<p>Measuring a pulse is a very critical and difficult task, but we can benefit from <a href="http://pulsesensor.com">pulsesensor.com</a>, started by <strong class="bold">World Famous Electronics LLC</strong> as a crowd-funding project. On this site, you can find all the official details including specifications, how the sensor works, and development board code samples.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Chinese-made pulse sensors are good for DIY projects, but even sensors from official stores can’t be deployed in real-world use cases without professional calibration using a real-time <strong class="bold">electrocardiogram</strong> (<strong class="bold">ECG</strong>), BPM equipment, and a doctor’s verification.</p>
<p>In this section, we discussed the pulse sensor and where you can buy it, as well as examining its pinout diagram for better understanding. Next, we will examine the project architecture, covering how to connect the sensors to the XIAO ESP32C3.</p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor256"/>Understanding the project architecture</h1>
<p>In the<a id="_idIndexMarker958"/> preceding sections, we discussed the sensors and development board in detail. Now it’s time to get started on the recipe. In <a id="_idIndexMarker959"/>hardware development, before we start working <a id="_idIndexMarker960"/>with sensors and development boards, we need to develop the design concepts to get a better understanding of how things will be connected. There are many pieces of software available to design and develop design concepts for electronics projects, but we are going to use Fritzing.</p>
<p>In the following two subsections, we will cover schematics and project design, explaining how to connect the pins to the development board and soldering. Next, we will do some calibration of the <em class="italic">pulse sensor fetch-reading threshold</em>, as this is different for different development boards. This is very important to do before we send the data to the cloud.</p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor257"/>Schematics design and assembly</h2>
<p>The purpose<a id="_idIndexMarker961"/> of design is to get a clear understanding<a id="_idIndexMarker962"/> of how the sensors will be connected to the development board. A clear design helps engineers to develop<a id="_idIndexMarker963"/> a prototype<a id="_idIndexMarker964"/> on a <strong class="bold">breadboard</strong> or <strong class="bold">veroboard</strong>. Another major benefit of effective design is that Fritzing builds hardware schematics and PCB designs in the background according to your design, which can then be adjusted by designers according to the system requirements. <em class="italic">Figure 12</em><em class="italic">.3</em> shows the project schematic diagram demonstrating how to connect the pulse sensor to the XIAO ESP32C3:</p>
<div><div><img alt="Figure 12.3 – XIAO ESP32C and pulse sensor system design" src="img/B19752_12_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – XIAO ESP32C and pulse sensor system design</p>
<p>The design in the preceding figure provides an overview of how to connect the sensors to the development board. According to our design, we have 5V and GND from the development board to the pulse sensor. The pulse sensor is an analog sensor, so we connected its <em class="italic">Signal</em> pin to the <em class="italic">A1</em> pin of the development board.</p>
<div><div><img alt="Figure 12.4 – Final prototype" src="img/B19752_12_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Final prototype</p>
<p>After soldering the <a id="_idIndexMarker965"/>male headers to the pulse sensor<a id="_idIndexMarker966"/> and the XIAO ESP32C3, connect the pins according to the schematic. There is only one sensor, so no veroboard is required. <em class="italic">Figure 12</em><em class="italic">.4</em> shows the pulse sensor connected to the XIAO ESP32C3 without any breadboard or Veroboard, but rather, directly connected with jumper wires. Now, it’s time to calibrate the pulse sensor and get an appropriate threshold value by putting your fingertip on the sensor.</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor258"/>Sensor calibration</h2>
<p>For<a id="_idIndexMarker967"/> sensor calibration, we need the Serial Plotter <a id="_idIndexMarker968"/>to identify the pulse value threshold. Currently, the Arduino Web Editor does not support the Serial Plotter, so we are going to use the Arduino IDE. To work with the Arduino IDE, we need to install the <strong class="bold">Seeed Studio XIAO ESP32C3 series</strong> development board and the <a href="http://pulsesensor.com">pulsesensor.com</a> library.</p>
<p>To install the ESP32 series development board in the Arduino IDE, firstly, add the board’s definition file in the preferences:</p>
<ol>
<li>Navigate to <strong class="bold">File</strong> &gt; <strong class="bold">Preferences</strong>, and fill the <strong class="bold">Additional Boards Manager URLs</strong> field with the following URL: <a href="https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json">https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json</a>.</li>
<li>Then, navigate to <code>esp32</code> in the search box, select the latest version of <strong class="bold">**esp32**</strong>, and install it.</li>
<li>Finally, select the board by navigating to <strong class="bold">Tools</strong> &gt; <strong class="bold">Board</strong> &gt; <strong class="bold">ESP32 Arduino</strong> and selecting <strong class="bold">XIAO_ESP32C3</strong>. The list of boards is a little long and you will need to scroll to the bottom to find it.</li>
</ol>
<p>It’s time to install the pulse sensor library. Navigate to <code>pulsesensor playground</code> into the search bar. Only one library will <a id="_idIndexMarker969"/>be returned here – install it.</p>
<p>Now we <a id="_idIndexMarker970"/>are ready to proceed to the calibration step. Navigate to <strong class="bold">File</strong> &gt; <strong class="bold">Examples</strong> &gt; <strong class="bold">PulseSensor Playground</strong> &gt; <strong class="bold">Getting Started Project</strong>. Here, you will get the template code for calibration, to which we will make the following changes:</p>
<pre class="source-code">
//  Variables
int PulseSensorPurplePin = A1;        // Pulse Sensor PURPLE WIRE connected to ANALOG PIN 0
int LED = 10;   //  The on-board Arduino LED</pre> <p>Set the <code>PulseSensorPurplePin</code> variable to <code>A1</code>. Remember to never use a simple <code>1</code> as it will give you different values. Next, assign <code>10</code> to the <code>LED</code> variable. After these modifications, upload the code to the board. To monitor the recorded values in graph format, navigate to <strong class="bold">Tools</strong> &gt; <strong class="bold">Serial Plotter</strong>. <em class="italic">Figure 12</em><em class="italic">.5</em> shows the Serial Plotter presenting all the values in the form of a graph. The threshold values are marked by the red box.</p>
<div><div><img alt="Figure 12.5 – Pulse sensor raw-readings graph using the Serial Plotter" src="img/B19752_12_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Pulse sensor raw-readings graph using the Serial Plotter</p>
<p>Put a <a id="_idIndexMarker971"/>finger on the front side of the pulse sensor, which is marked with a white heart shape. Wait for some time for the readings to stabilize on the Serial Plotter. After a few seconds, you should see stable readings as shown in the<a id="_idIndexMarker972"/> preceding figure. Mark the lowest level as the threshold. In my case, I take <strong class="bold">3500</strong> as the threshold value to avoid noise.</p>
<p>After that, download the <code>PulseSensor_BPM_Alternative</code> code from the GitHub repository under <a href="B19752_12.xhtml#_idTextAnchor251"><em class="italic">Chapter 12</em></a>. This is some code modified by us that we’ll use to display the BPM. But before uploading the code to the board, modify the values as follows:</p>
<pre class="source-code">
const int PULSE_INPUT = A1;
const int PULSE_BLINK = 10;
const int PULSE_FADE = 5;
const int THRESHOLD = 3450;   // Adjust this number to avoid noise when idle</pre> <p>Assign <code>A1</code> to the <code>PULSE_INPUT</code> variable, <code>10</code> to <code>PULSE_BLINK</code>, and set the <code>THRESHOLD</code> value according to your stabilized reading taken from the Serial Plotter. As stated, I am using <code>3500</code> from my graph. Upload the code to the board and observe the BPM readings<a id="_idIndexMarker973"/> in the Serial Monitor. Place a finger on the top of the<a id="_idIndexMarker974"/> sensor and you will get different BPM readings. <em class="italic">Figure 12</em><em class="italic">.6</em> demonstrates what this should look like:</p>
<div><div><img alt="Figure 12.6 – BPM values in the Serial Monitor" src="img/B19752_12_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – BPM values in the Serial Monitor</p>
<p>The preceding figure shows random BPM values, and when we put a finger on the sensor, it detects <strong class="bold">96</strong> and <strong class="bold">100</strong> BPM. You can play with the sensor and verify the readings with any professional smartwatch. Next, we need to set up a Thing, some code, and a dashboard in the Arduino IoT Cloud to prepare our IoT project.</p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor259"/>Setting up a Thing, network credentials, cloud variables, and code</h1>
<p>After <a id="_idIndexMarker975"/>setting up the hardware, it’s time to set up a Thing in the Arduino IoT Cloud. For this project, we need one cloud variable to fetch BPM reading<a id="_idIndexMarker976"/> from the device. The network settings will be different from those of Arduino IoT development boards as we are using an ESP series board. <em class="italic">Figure 12</em><em class="italic">.7</em> shows the complete Thing details including cloud variables, device info, and network configurations:</p>
<div><div><img alt="Figure 12.7 – Tracking and notifying about your heart rate Thing setup" src="img/B19752_12_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Tracking and notifying about your heart rate Thing setup</p>
<p>Set up a new <code>Tracking and notifying about your heart rate</code>. Then, proceed to the following sections of this chapter, which will take us through the following steps to create the variables, associate the device, set up the network configuration, and finally, apply the code:</p>
<ol>
<li>Firstly, we need to set up one cloud variable for <strong class="bold">BPM</strong>. The complete details regarding cloud variables are available in the following <em class="italic">Cloud </em><em class="italic">variables</em> section.</li>
<li>After that, we <a id="_idIndexMarker977"/>need to associate the device with the Thing. In our current project, we are using the XIAO ESP32C3, so the wizard will be different from that for Arduino boards. The complete details are available in the <em class="italic">Device </em><em class="italic">association</em> section.</li>
<li>Next, we <a id="_idIndexMarker978"/>need to set up the network configuration for the device, but this time, we need to provide a security key for ESP-series boards to make the connection secure (whereas Arduino-compatible boards are configured by the Arduino IoT Cloud automatically during the device setup wizard).</li>
<li>Lastly, we will set up the webhook toward the end of the chapter, along with the notification service using Zapier.</li>
</ol>
<h2 id="_idParaDest-260"><a id="_idTextAnchor260"/>Cloud variables</h2>
<p>The following table<a id="_idIndexMarker979"/> outlines the properties that we need to use during cloud variable creation. For BPM, we could just use the <code>integer</code> data type, but thanks to the Arduino IoT Cloud extended group of variables, we can choose the specific <code>Heart rate</code> variable type. Next, make sure you use the same variable declaration as in the table; otherwise, you will need to modify the example code according to your own naming.</p>
<p>For <strong class="bold">Permission</strong>, while we do have a <strong class="bold">Read/Write</strong> option, I chose <strong class="bold">Read Only</strong> as we only want to receive data from the device, as opposed to dashboard modification, so <strong class="bold">Read Only</strong> mode will avoid issues in data consistency. <strong class="bold">Update Policy</strong> is set to <strong class="bold">On change</strong> as the device will send the data whenever there is any change detected in the BPM value:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-8">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">S#</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable Name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable Type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Declaration</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Permission</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Update Policy</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>1</p>
</td>
<td class="No-Table-Style">
<p>BPM</p>
</td>
<td class="No-Table-Style">
<p>Heart rate</p>
</td>
<td class="No-Table-Style">
<p><code>bPM</code></p>
</td>
<td class="No-Table-Style">
<p>Read Only</p>
</td>
<td class="No-Table-Style">
<p>On change</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.1 – Cloud variable for our Thing</p>
<p>In this section, we<a id="_idIndexMarker980"/> have created the cloud variable that receives the heart rate value in BPM from the sensor device. In the next section, we will associate the device with the Thing.</p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor261"/>Device association</h2>
<p>After variable <a id="_idIndexMarker981"/>creation, it’s time to add the device and associate it with the Thing. Before adding the device, connect the development board to the computer and open the <strong class="bold">Arduino Create Agent</strong> application. <em class="italic">Figure 12</em><em class="italic">.8</em> shows the device setup wizard where we have selected <strong class="bold">ESP32</strong> and then <strong class="bold">XIAO_ESP32C3</strong> from the dropdown:</p>
<div><div><img alt="Figure 12.8 – Device selection wizard" src="img/B19752_12_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Device selection wizard</p>
<ol>
<li>Click on the <strong class="bold">Select Device</strong> button under the <strong class="bold">Associated Devices</strong> section on the Thing page. A popup will appear showing all the devices that are already available. If you have already added your XIAO ESP32C3, select it. Otherwise, click on <strong class="bold">SET UP </strong><strong class="bold">NEW DEVICE</strong>.</li>
<li>Next, click<a id="_idIndexMarker982"/> on the <strong class="bold">Third Party device</strong> option. Select <strong class="bold">ESP32</strong> and <strong class="bold">XIAO_ESP32C3</strong> from the dropdown and click on the <strong class="bold">CONTINUE</strong> button.</li>
<li>Fill in the <strong class="bold">Device Name</strong> field and click on the <strong class="bold">Next</strong> button.</li>
<li>On the final wizard screen, the <strong class="bold">Device ID</strong> and <strong class="bold">Secret Key</strong> values will be displayed. Copy the <strong class="bold">Secret Key</strong> value to a safe place as it will be needed later during the network configuration.</li>
</ol>
<p>In this section, we associated the XIAO ESP32C3 device with the Thing. The device association process is somewhat different to adding the Arduino MKR1010 to a Thing. Next, let’s complete the network settings.</p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor262"/>Network</h2>
<p>After <a id="_idIndexMarker983"/>associating the device with the Thing, it is time to configure the Wi-Fi settings for device communication. Fill in the form shown in <em class="italic">Figure 12</em><em class="italic">.9</em> with your <strong class="bold">Wi-Fi Name</strong> and <strong class="bold">Password</strong> values. The last field here is the <strong class="bold">Secret Key</strong> field. Paste the secret key value in here that we received from the system during device creation.</p>
<div><div><img alt="Figure 12.9 – Network configuration for ﻿the Thing" src="img/B19752_12_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Network configuration for the Thing</p>
<p><em class="italic">Figure 12</em><em class="italic">.9</em> shows <a id="_idIndexMarker984"/>how it should look once you’ve entered all the relevant values. In the next subsection, we will cover the coding for the device.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor263"/>Coding</h2>
<p>The code<a id="_idIndexMarker985"/> for this chapter is available in the book’s official GitHub repository. Download the <code>Tracking_and_notifying_Your_Heart_Rate_mar31a</code> code from the repository and import it to the Arduino Web Editor.</p>
<p>You can download the code and add it to your Thing by navigating to the <strong class="bold">Sketch</strong> tab. We will not discuss the code at length as you will get the gist after reading the code yourself, but I will explain the main workflow with which we initialize all the variables and constants in the setup.</p>
<p>Remember<a id="_idIndexMarker986"/> to never use the <code>delay</code> method as it will create blocking in the <code>ArduinoCloud.update()</code> method. But before moving on to the code, we need to set the <code>PULSE_INPUT</code> variable to pin <code>A1</code>, <code>PULSE_BLINK</code> to digital pin <code>10</code> for the LED, and set <code>THRESHOLD</code> with your calibration value:</p>
<pre class="source-code">
const int PULSE_INPUT = A1;
const int PULSE_BLINK = 10;
const int PULSE_FADE = 5;
const int THRESHOLD = 3450; // Adjust this number to avoid noise when you will start getting values from sensor</pre> <p>After configuring the preceding variables with the appropriate values, it’s time to explore the loop method:</p>
<pre class="source-code">
  if (pulseSensor.sawNewSample()) {
    if (--samplesUntilReport == (byte) 0) {
      samplesUntilReport = SAMPLES_PER_SERIAL_SAMPLE;
      //pulseSensor.outputSample();
      if (pulseSensor.sawStartOfBeat()) {
          bPM=pulseSensor.getBeatsPerMinute();
           Serial.print(bPM);
           Serial.println(" bpm");
      }
    }
    /*******
      Here is a good place to add code that could take up
      to a millisecond or so to run.
    *******/
  }
  /******
     Don't add code here, because it could slow the sampling
     from the PulseSensor.
  ******/</pre> <p>In the loop <a id="_idIndexMarker987"/>method, the development board calls <code>pulseSensor.sawNewSample()</code> to fetch new samples if they exist. Other than that, it will not call any activity, which is why you will see a delay in readings returned if there is no change found by the system in the BPM data. If any change occurred in the sensor readings, then BPM readings will verify using the <code>pulseSensor.sawStartOfBeat()</code> method.</p>
<p>In the previous section where we created the cloud variable, recall the cloud variable declaration – our <code>pulseSensor.getBeatsPerMinute();</code> method assigns the sensor reading to that <code>thingProperties.h</code> file. So, when you assign the values to these constants, the <code>ArduinoCloud.update()</code> method in the loop will automatically send the data to the cloud. Finally, upload the code to the device and verify the readings returned using the Serial Monitor.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you used different <em class="italic">naming</em> in the variable declaration, then update the code according to your naming scheme. It would be better, however, if you followed the steps according to the book first and then change the cloud variable names later and modify your code respectively.</p>
<p class="callout">Never use the <code>delay</code> method, which will create a block for the <code>ArduinoCloud.update()</code> method, and don’t put code at the end of the loop method, as it will cause a delay in the pulse sensor readings.</p>
<p class="callout">The Arduino IoT Cloud only updates the value on the dashboard whenever the variable value is changed. For example, if the heart beat is <code>80</code> and after 5 minutes it’s still the same, then the Arduino IoT Cloud will not record the value, so don’t get confused if values do not appear to change on the graph. Another benefit of this feature is you will not get duplicated data when you export the content.</p>
<p>In this section, we<a id="_idIndexMarker988"/> discussed the code in depth and guided you through the code operation and how to set the threshold values. In the next section, we are going to set up the dashboard to visualize the BPM value in different formats for better understanding.</p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor264"/>Setting up a dashboard for web and mobile</h1>
<p>After uploading<a id="_idIndexMarker989"/> the code to the device, it’s now time to set up the dashboard for web and mobile to visualize the data with different widgets. The following figure demonstrates how this visualization might look:</p>
<div><div><img alt="Figure 12.10 – Thing dashboard" src="img/B19752_12_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – Thing dashboard</p>
<p>In the<a id="_idIndexMarker990"/> preceding figure, we have a BPM reading, and to visualize it, we have used two widgets, <strong class="bold">Value</strong> and <strong class="bold">Advanced Chart</strong>. The <strong class="bold">Value</strong> widget on the left of the screen shows the real-time <strong class="bold">BPM</strong> values, while the <strong class="bold">Advanced Chart</strong> widget illustrates the real-time readings as well as historical readings for proper analysis, just like an ECG machine display. Both widgets are attached to the BPM cloud variable.</p>
<p>The <strong class="bold">Advanced Chart </strong>widget is a new addition to the widgets on offer, and comes with a variety of features including different chart formats such as line, spline, spline/line area, and bar charts, with the option to customize the color of the plot. Another big feature is the ability to visualize multiple cloud variables on the same chart, which is not available in simpler chart widgets. We will use that feature in upcoming projects for a proper demonstration.</p>
<p>In this section, we briefly discussed some widgets and why these widgets are used in our dashboard. Next, we will set up the notification service using Zapier, which will send an email/SMS when the pulse is detected as going above or below our thresholds.</p>
<h1 id="_idParaDest-265"><a id="_idTextAnchor265"/>Setting up the notification service</h1>
<p>Multiple<a id="_idIndexMarker991"/> platforms provide <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>) infrastructure<a id="_idIndexMarker992"/> and operate as a bridge between a variety of applications to make interoperability easy. Platforms for this purpose<a id="_idIndexMarker993"/> include <strong class="bold">Zapier</strong>, <strong class="bold">IFTTT</strong>, and <strong class="bold">Integromat</strong>, and provide an interface to<a id="_idIndexMarker994"/> integrate <a id="_idIndexMarker995"/>other platforms into the Arduino IoT Cloud platform to fulfill the requirements instead of developing the required features from scratch.</p>
<p>So firstly, we need to understand why we need the Zapier automation platform. In our current project, we want to send notifications by email/SMS when a specific threshold is met, but the Arduino IoT Cloud only provides the data visualization, webhooks, and API functionalities. We have two options to solve this problem. Either we need to develop a custom solution to send notifications by email/SMS using Arduino webhooks and APIs, or we can use an automation platform such as Zapier or IFTTT, which will save time and reduce costs compared to the first option.</p>
<p>For this exercise, we will use Zapier, which will receive the data via <strong class="bold">Arduino webhooks</strong>. We<a id="_idIndexMarker996"/> will apply Zapier filters in Zaps to manage the threshold, and when the threshold is crossed, Zapier will send an email notification about BPM levels. A <em class="italic">Zap</em> is a term used in Zapier to describe an automated workflow that allows you to connect apps and services together, and each Zap can consist of multiple actions.</p>
<p>Before moving onto the main steps, first sign up to <a href="http://zapier.com">zapier.com</a> and use the trial version, as the Zapier webhooks we are going to use are only available under the <em class="italic">Professional plan</em>. The following screenshot demonstrates the trigger and two actions required to set up our notification functionality:</p>
<div><div><img alt="Figure 12.11 – Zapier complete notification Zap" src="img/B19752_12_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – Zapier complete notification Zap</p>
<p>The steps to create this, which we will work through for the remainder of this section, are as follows:</p>
<ol>
<li>Firstly, we need to set up<a id="_idIndexMarker997"/> the <strong class="bold">webhook trigger</strong>, which will provide a URL. This URL should be inserted into the <strong class="bold">Thing</strong> by clicking on <strong class="bold">Set Webhook</strong> on the Arduino IoT Cloud Thing page. This trigger will be responsible for receiving the data from the Arduino IoT Cloud.</li>
<li>In the second step, we apply the filter on the BPM value, which specifies that if the BPM is greater than 100 or less than 60, then proceed to the next action; otherwise, the BPM is normal and there is no need to send a notification.</li>
</ol>
<p>Finally, we<a id="_idIndexMarker998"/> will use the <strong class="bold">Email by Zapier</strong> or <strong class="bold">Gmail</strong> option to send the notification. We add multiple actions<a id="_idIndexMarker999"/> to the Zap. To keep things easy and manageable, we chose to use a simple email notification. Alternatively, you could <a id="_idIndexMarker1000"/>also use <strong class="bold">Twillo</strong> to send SMS notifications to recipients.</p>
<p>Previously, we have discussed the different triggers and actions step by step that are required for notifications to be triggered and sent. The following points will guide you through these steps in Zapier:</p>
<ol>
<li>The preceding screenshot gives a rough idea of how our setup looks in Zapier. To create a new Zap in Zapier, click the <strong class="bold">Create</strong> button and select <strong class="bold">New Zap</strong>, which will open a new page where you select the required triggers and actions.</li>
<li>Type <code>Webhook</code> in the search bar and select the <strong class="bold">Webhooks By Zapier</strong> option, which is available under the Professional plan. Click on <strong class="bold">Event</strong> and select <strong class="bold">Catch Hook</strong>, then click <strong class="bold">Continue</strong>. In the <strong class="bold">Trigger</strong> tab, just leave the empty <strong class="bold">Pick off a Child Key</strong> textbox as is and proceed to the next step by clicking on the <strong class="bold">Continue</strong> button.</li>
<li>In the <strong class="bold">Test</strong> tab, you will get the <strong class="bold">webhook URL</strong> – copy that and navigate to <strong class="bold">Thing</strong> in the Arduino IoT Cloud, then click on <strong class="bold">Set Webhook</strong>. Insert the URL into the window that pops up, then hit the <strong class="bold">Save</strong> button.</li>
</ol>
<p>Come back to Zapier and click the <strong class="bold">Test Trigger</strong> button to verify whether data is arriving or not. Before you can verify this, the device must be powered on and connected to the internet to send the values. This might not work on your first try; if not, try again and you should see the data arriving, which means you are receiving the data successfully from the Arduino Thing. <em class="italic">Figure 12</em><em class="italic">.12</em> shows a trigger test, demonstrating the values received from the Arduino IoT Cloud pulse monitoring Thing:</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 12.12 – Trigger test" src="img/B19752_12_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Trigger test</p>
<p>The preceding <a id="_idIndexMarker1001"/>screenshot shows Zapier successfully receiving the data from the Arduino IoT Cloud Thing. In the red box, we can see <strong class="bold">bPM</strong> and <strong class="bold">value</strong>. The <strong class="bold">value</strong> parameter will be used in the next action. Click the <strong class="bold">Continue</strong> button and a new <strong class="bold">Action</strong> popup will appear. Here, we need to configure the filter action where we will set the threshold for our BPM notification, as shown in <em class="italic">Figure 12</em><em class="italic">.13</em>:</p>
<div><div><img alt="Figure 12.13 – Filter action" src="img/B19752_12_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Filter action</p>
<p>Type <code>Filter</code> in the<a id="_idIndexMarker1002"/> search box and select <code>100</code> in the next input field. This sets the upper threshold value to 100 BPM. Next, click <code>60</code> in the next field. Lastly, click on <strong class="bold">Continue</strong>.</p>
<p>Our filter is ready; now, our email notification action is required to finish the setup. We have two options to send email notifications: either <code>Email</code> in the search box and click on <strong class="bold">Email by Zapier</strong>. Click on <strong class="bold">Event</strong> and select <strong class="bold">Send Outbound Email</strong>. In the next window, set all the parameters for the email receiver, subject, and body, as shown in the following screenshot:</p>
<div><div><img alt="Figure 12.14 – Email notification settings" src="img/B19752_12_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – Email notification settings</p>
<p>Only three <a id="_idIndexMarker1003"/>fields are mandatory here – insert the recipient email in the <strong class="bold">To</strong> field, write a relevant entry for the <strong class="bold">Subject</strong> field, and insert a message in the <strong class="bold">Body</strong> area. It’s up to you whether you fill the other fields or leave them blank. If you observe the preceding screenshot, you may notice I added <strong class="bold">Values Value</strong> to both the <strong class="bold">Subject</strong> and <strong class="bold">Body</strong> fields, which will display the values that triggered the notification in the email. Click the <strong class="bold">Continue</strong> button at the bottom of the page and test the action – if you receive the email with the BPM values, then publish the Zap and you are good to go.</p>
<p>In this section, we set up the notification services for our pulse monitor using Zapier. We created a Zap that consists of three steps. Firstly, we set up the webhook responsible for receiving the data. The second step deals with the threshold, and the third and final step handles sending the email notification.</p>
<h1 id="_idParaDest-266"><a id="_idTextAnchor266"/>What next?</h1>
<p>There are many more options available to explore, but these are left to you to work on, using different health sensors and development boards to do some more experiments and learn from them. In the current chapter, we only used one sensor that provided only one parameter, but there are many sensors on the market that provide a wide variety of functionalities including the monitoring of blood sugar, blood oxygen, blood pressure, body temperature, and more.</p>
<p>Try the following sensors to enhance your practical knowledge and compare this selection with other sensors in terms of features, ranges, and cost:</p>
<ul>
<li>LilyPad temperature sensor (<a href="https://www.sparkfun.com/products/8777">https://www.sparkfun.com/products/8777</a>)</li>
<li>High-sensitivity pulse oximeter and heart-rate sensor for wearables (<a href="https://www.seeedstudio.com/MAXREFDES117-HEART-RATE-AND-PULSE-OXIMETRY-MONITOR-p-2762.html?queryID=51de6141574a711bbe455cb4894ce3fb&amp;objectID=411&amp;indexName=bazaar_retailer_products">https://www.seeedstudio.com/MAXREFDES117-HEART-RATE-AND-PULSE-OXIMETRY-MONITOR-p-2762.html?queryID=51de6141574a711bbe455cb4894ce3fb&amp;objectID=411&amp;index Name=bazaar_retailer_products</a>)</li>
<li>Fall detection module (<a href="https://www.seeedstudio.com/24GHz-mmWave-Radar-Sensor-Fall-Detection-Module-p-5268.html">https://www.seeedstudio.com/24GHz-mmWave-Radar-Sensor-Fall-Detection-Module-p-5268.html</a>)</li>
<li>Open source Arduino blood glucose meter shield</li>
<li>MIKROE series health sensors</li>
</ul>
<h1 id="_idParaDest-267"><a id="_idTextAnchor267"/>Summary</h1>
<p>In this chapter, we explored how to develop a low-cost wearable smart heart-rate monitoring system using the XIAO ESP32C3 and a pulse sensor. One important thing to note was the necessity of calibrating medical sensors before using them in the field. We set up a Thing, which included cloud variable creation, device association, network configuration, and coding for our development board. Later, we created a dashboard to visualize our sensor readings with different widgets to display both current readings and historical data with the help of graphs. Finally, we used Zapier to set up an email notification service based on thresholds using webhooks and saw how to employ webhooks to integrate third-party services with the Arduino IoT Cloud.</p>
<p>In the next chapter, we will learn about scripting in the Arduino IoT Cloud with the <strong class="bold">Arduino Cloud CLI</strong> (<strong class="bold">CCLI</strong>). This is a command-line tool that provides access to Arduino IoT Cloud services via terminal commands. We will use the Arduino IoT Cloud CLI to automate bulk operations, including bulk device creation, which will help us to minimize the time required for operations and maintenance.</p>
</div>
</body></html>