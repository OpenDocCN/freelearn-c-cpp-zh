- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Adding Tests to a Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向项目中添加测试
- en: In this chapter, we’re going to add a major new ability to the test library.
    The new ability will let you check conditions within a test to make sure everything
    is going as planned. Sometimes, these checks are called an *assert*, and sometimes,
    they are called an *expect*. Whatever they are called, they let you confirm that
    the values you get back from the code being tested match expectations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向测试库添加一个主要的新功能。这个新功能将允许你在测试中检查条件，以确保一切按计划进行。有时，这些检查被称为*断言*，有时被称为*期望*。无论它们被称为什么，它们都让你确认从被测试的代码中获取的值与期望相符。
- en: For this book and the test library that we’re creating, I’m going to call these
    checks confirmations. Each confirmation will be called a *confirm*. The reason
    for this is that assert is already being used in C++, and it can be confusing
    to use the same name. Additionally, expect is a common term within other test
    libraries, which is not by itself a reason to avoid using the same term. I actually
    like the term expect. But expect has another common behavior that we don’t want.
    Many other testing libraries will let a test continue even if an expect fails.
    I don’t really like this behavior. Once something has gone wrong, I think it’s
    time to end that test. Other tests can still run. But we shouldn’t continue running
    a test once something doesn’t match what we expect.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书和我们在创建的测试库，我将把这些检查称为确认。每个确认将被称为*确认*。这样做的原因是断言已经在C++中使用，使用相同的名称可能会造成混淆。此外，期望在其他测试库中是一个常用术语，这本身并不是避免使用相同术语的理由。我实际上喜欢期望这个术语。但期望还有一个我们不想看到的常见行为。许多其他测试库允许测试在期望失败的情况下继续进行。我真的不喜欢这种行为。一旦出现问题，我认为是时候结束那个测试了。其他测试仍然可以运行。但我们不应该继续运行一个一旦与我们的期望不符就停止的测试。
- en: So far, you can use the test library to write multiple tests, run them, and
    see the results. The result of each test is to either pass or fail. You can even
    expect certain failures and treat them as passing. And there’s a third result
    that will likely not be needed outside of the test library itself and that is
    a missed failure. You can read all about these abilities in the first three chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以使用测试库编写多个测试，运行它们，并查看结果。每个测试的结果要么是通过，要么是失败。你甚至可以期望某些失败，并将它们视为通过。还有一个第三种结果，可能不需要在测试库本身之外使用，那就是错过失败。你可以在前三章中了解所有这些功能。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: How to detect whether a test passes or fails
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测测试是通过还是失败
- en: Enhancing the testing library to support confirmations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强测试库以支持确认
- en: Should error cases be tested, too?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否应该测试错误情况？
- en: There’s a reason we’ve waited until this chapter to add confirms. We’re following
    a TDD approach to the design of the test library itself. That means we let the
    tests drive the design. This is an agile approach to software design. We think
    about what is the most valuable or necessary feature or capability to add next,
    what the end use of that feature will be, write the minimum amount of code needed
    to get it working, and then enhance the design by adding more.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以等到本章才添加确认，是有原因的。我们正在遵循对测试库本身设计的TDD（测试驱动开发）方法。这意味着我们让测试驱动设计。这是一种敏捷的软件开发方法。我们考虑下一个最宝贵或最必要的功能或能力是什么，该功能的最终用途是什么，然后编写最少的代码来实现它，并通过添加更多功能来增强设计。
- en: Until now, there was no point in adding confirms. We needed to get the essential
    functionality working first, which would let tests be created and run before we
    could think about what to do inside the tests. Maybe we could have added confirms
    before the exception handling. But I choose to work on exception handling before
    confirms. Exceptions seem more closely related to the essential declaration and
    running of the tests than confirms and, therefore, are more valuable than confirms.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，添加确认并没有意义。我们需要首先让基本功能工作，这样我们就可以在考虑测试内部要做什么之前创建和运行测试。也许我们可以在异常处理之前添加确认。但我选择在确认之前先处理异常。异常似乎与测试的基本声明和运行更紧密相关，因此比确认更有价值。
- en: Additionally, you’ll also see that we’ll be using exceptions to enable confirmations.
    This is another reason why the basic ability to handle exceptions came before
    confirms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还会看到我们将使用异常来启用确认。这也是为什么处理异常的基本能力在确认之前的原因。
- en: Now we can turn our attention to the tests with confirms. Again, we’re going
    to do the minimum amount of work needed to get the confirms functional and useful.
    We’ll continue adding more abilities to confirms in the next chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将注意力转向带有确认的测试。同样，我们将做最少的努力来使确认功能化和有用。我们将在下一章继续添加更多到确认的能力。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the code in this chapter uses standard C++, which builds on any modern
    C++ 17, or later, compiler and standard library. The code is based on and continues
    from the previous chapters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都使用标准 C++，它基于任何现代 C++ 17 或更高版本的编译器和标准库。代码基于前几章并继续发展。
- en: 'You can find all of the code for this chapter at the following GitHub repository:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下 GitHub 仓库中找到本章的所有代码：
- en: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
- en: How to detect whether a test passes or fails
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何检测测试是否通过或失败
- en: In this chapter, the tests we’ll be creating are different enough from the creation
    tests that they should have their own file. When writing your own tests, you’ll
    want to organize them into multiple files, too.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建的测试与创建测试不同，因此它们应该有自己的文件。在编写自己的测试时，您也会希望将它们组织到多个文件中。
- en: 'Let’s create a new file called `Confirm.cpp` and place it inside the `tests`
    folder. With the new file, the project structure will look like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `Confirm.cpp` 的新文件，并将其放置在 `tests` 文件夹内。有了这个新文件，项目结构将如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, add a single test to the new file so that it looks like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向新文件添加一个单独的测试，使其看起来像这样：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We already have an empty test in `Creation.cpp`, which looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `Creation.cpp` 中有一个空测试，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only real difference between these two tests is the name. Do we really need
    another test that does the exact same thing but with a different name? I could
    argue on either side of a debate about adding code that does the same thing but
    with a different name. Some people might see this and think it is pure code duplication.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试之间唯一的真正区别是名称。我们真的需要另一个执行相同操作但名称不同的测试吗？我可以在关于添加具有不同名称但执行相同操作代码的辩论的任何一边进行争论。有些人可能会看到这一点，认为这是纯粹的代码重复。
- en: To me, the difference comes down to *intent*. Yes, both tests happen to be the
    same right now. But who knows whether one or both will be modified later? And
    if that ever happens, will we be able to remember that a test was serving multiple
    purposes?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，区别在于 *意图*。是的，这两个测试现在碰巧是相同的。但谁知道将来是否会对其中一个或两个进行修改？如果发生这种情况，我们能否记得测试正在服务于多个目的？
- en: I strongly urge you to write each test as if it is the only thing standing between
    your code and the bugs that the test is designed to prevent. Or maybe the test
    is exercising a specific usage to make sure that nothing breaks later during a
    design change. Having two identical tests is okay as long as they are testing
    different things. It’s the goal that should be unique.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您将每个测试都写成似乎它是您代码和测试旨在防止的错误之间的唯一障碍。或者，也许测试正在执行特定的用法以确保在设计更改后不会出现任何问题。只要它们测试不同的事情，有两个相同的测试是可以接受的。目标是应该独特的。
- en: In this case, the original test just ensures that a test can be created in its
    most basic form. The new test is specifically making sure that an empty test will
    pass. These are two different tests that just happen to require the same test
    method body to accomplish their goals.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，原始测试只是确保可以以最基本的形式创建测试。新的测试专门确保空测试可以通过。这两个测试只是碰巧需要相同的测试方法体来实现目标。
- en: 'Now that we have a new file in the project with a new test, let’s build and
    make sure everything works as expected. And it fails. The reason for the build
    failure is the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在项目中添加了一个新文件和一个新测试，让我们构建并确保一切按预期工作。但它失败了。构建失败的原因如下：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Everything compiles okay, but the project fails to link into the final runnable
    executable. We have five linker errors. One of the linker errors says the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编译没有问题，但项目无法链接到最终的可执行文件。我们有五个链接器错误。其中一个链接器错误如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I have only listed one of the linker errors because they are all similar. The
    problem is that we now have two declarations of `Test3`. One declaration comes
    from each file, `Creation.cpp` and `Confirm.cpp`; that is because the `TEST` macro
    declares the `Test` class with a unique number based on the line number where
    the `TEST` macro appears in the source file. Both files happen to use the `TEST`
    macro on line 3, so they each declare a class called `Test3`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我只列出了一个链接器错误，因为它们都是相似的。问题是现在有两个`Test3`的声明。一个声明来自每个文件，`Creation.cpp`和`Confirm.cpp`；这是因为`TEST`宏根据`TEST`宏在源文件中出现的行号声明了一个具有唯一数字的`Test`类。两个文件恰好都在第3行使用了`TEST`宏，因此它们各自声明了一个名为`Test3`的类。
- en: The solution for this is to use an *unnamed namespace* in the macros when declaring
    the class. This will still create two classes such as `Test3`, but each will be
    in a namespace that does not extend outside of the `.cpp` file in which it is
    declared. This means that the test classes can continue to be based on the line
    number, which is guaranteed to be unique within each `.cpp` file and will now
    no longer conflict with any other tests that happen to be declared on the same
    line number in a different `.cpp` file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是，在宏中声明类时使用一个**未命名的命名空间**。这样仍然会创建两个类，例如`Test3`，但每个类都将位于一个不扩展到声明它的`.cpp`文件之外的命名空间中。这意味着测试类可以继续基于行号，行号在每`.cpp`文件中都是唯一的，并且现在将不再与在另一个`.cpp`文件中声明在相同行号的任何其他测试冲突。
- en: 'All we need to do is modify the `TEST` and `TEST_EX` macros to add an unnamed
    namespace around just the class declaration inside of each macro. We don’t need
    to extend the namespace to the end of the macro because the macros go on to declare
    the beginning of the `run` method. Luckily, the `run` method declaration does
    not need to be inside the namespace. Otherwise, we would have to figure out how
    to end the namespace with the closing curly brace after the `run` method has been
    fully defined. As it is, we can end the namespace after the class declaration.
    The `TEST` macro looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是修改`TEST`和`TEST_EX`宏，在每个宏中仅将未命名的命名空间添加到类声明周围。我们不需要将命名空间扩展到宏的末尾，因为宏继续声明`run`方法的开始。幸运的是，`run`方法的声明不需要在命名空间内。否则，我们不得不在`run`方法完全定义后，通过关闭花括号来确定如何结束命名空间。实际上，我们可以在类声明后结束命名空间。`TEST`宏看起来像这样：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And the `TEST_EX` macro needs a similar unnamed namespace as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEST_EX`宏也需要一个类似的未命名的命名空间，如下所示：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that the project builds again, running it will show the new test. Depending
    on what order your linker built the final executable, you might find the new test
    runs before or after the previous tests. Here is a portion of the results when
    I ran the test project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目可以再次构建，运行它将显示新的测试。根据你的链接器构建最终可执行文件的顺序，你可能发现新的测试在之前的测试之前或之后运行。以下是我运行测试项目时的一部分结果：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The other five tests and the summary are not shown. The previous chapter ended
    with six tests, and we just added one more bringing the total to seven tests.
    The important part is that the new test runs and passes. Now we can think about
    what a confirm will look like. And what does it mean to confirm something?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其他五个测试和总结没有显示。前一章以六个测试结束，我们刚刚添加了一个，总数达到了七个测试。重要的是，新的测试运行并通过了。现在我们可以考虑确认将是什么样子。确认某件事意味着什么呢？
- en: When running a test, you want to not just verify that the test completes but
    that it completes correctly. And it also helps to check along the way to make
    sure everything is running as expected. You can do this by comparing the values
    you get from the code being tested to make sure they match the expected values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，你不仅想要验证测试是否完成，还要验证它是否正确完成。在过程中检查以确保一切按预期运行也有帮助。你可以通过比较从被测试的代码中获得的值来确保它们与你自己计算出的预期值相匹配。
- en: Let’s say that you have a function that adds two numbers and returns a result.
    You can call this function with known values and compare the returned sum with
    an expected sum that you calculate yourself. You confirm that the calculated sum
    matches the expected sum. If the values match, then the confirm passes. But if
    the values don’t match, then the confirm fails, which should cause the test to
    fail, too.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个函数，它将两个数字相加并返回一个结果。你可以用已知的值调用这个函数，并将返回的和与你自己计算出的预期和进行比较。你确认计算出的和与预期和相匹配。如果值匹配，则确认通过。但如果值不匹配，则确认失败，这应该导致测试也失败。
- en: A test can have multiple confirms and each will be checked to make sure they
    pass. The moment one confirm fails, there’s no point in continuing the test because
    it has already failed. Some TDD purists will claim that a test should only have
    a single confirmation. I think there’s a good compromise between only having a
    single confirm versus writing epic tests that try to verify everything.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试可以有多个确认，并且每个都会被检查以确保它们通过。一旦一个确认失败，就没有继续测试的意义，因为它已经失败了。一些TDD纯粹主义者会声称测试应该只有一个确认。我认为在只有一个确认和编写试图验证一切的史诗级测试之间有一个很好的折衷方案。
- en: 'A popular style of writing tests with multiple confirmations is to keep track
    of how many confirms pass by letting a test continue even if a confirm fails.
    There is a benefit to this style because the developer can sometimes fix multiple
    problems with a single run of the tests. We’re not taking this approach because
    I think the benefit is rarely achieved in practice. Some people might argue this,
    but hear me out. Once something is proven to not meet your expectations, the most
    likely result is a chain reaction of further failures. I have rarely seen a well-designed
    test fail one confirmation and then somehow recover to pass unrelated confirmations.
    If the test behaves like this, then it normally is testing unrelated issues and
    should be broken into multiple tests. The practice we’re going to be following
    is this: when a confirm fails, then the test itself has failed. Other tests might
    proceed just fine. But the test with a failed confirm has already failed, and
    there is no point in continuing to see whether maybe some part of the test might
    still be okay.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个确认来编写测试的一种流行风格是跟踪通过确认的数量，即使确认失败，测试也会继续。这种风格有一个好处，因为开发者有时可以通过一次测试运行来解决多个问题。我们不采取这种方法，因为我认为在实践中很少能实现这种好处。有些人可能会争论这一点，但请听我说。一旦某件事被证明不符合你的预期，最可能的结果是进一步失败的连锁反应。我很少看到设计良好的测试在一次确认失败后，又
    somehow 恢复通过相关的确认。如果测试表现出这种行为，那么它通常是在测试不相关的问题，应该被拆分成多个测试。我们将遵循的实践是：当一个确认失败时，测试本身就已经失败。其他测试可能进行得很好。但带有失败确认的测试已经失败了，继续查看是否测试的某个部分可能仍然正常是没有意义的。
- en: When writing tests, just like when writing regular code, it’s good to avoid
    duplication. In other words, if you find yourself testing the same things by checking
    values that have already been checked in other tests, then it’s time to think
    about the goal of each test. Write one test that covers some basic functionality
    that will be used many times. Then, in other tests that make use of that same
    functionality, you can assume it has already been tested and works, so there is
    no need to verify it again with extra confirms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写测试时，就像编写常规代码一样，避免重复是好的。换句话说，如果你发现自己通过检查其他测试中已经检查过的值来测试相同的事情，那么是时候考虑每个测试的目标了。编写一个测试，覆盖一些将被多次使用的基功能。然后，在其他使用相同功能的测试中，你可以假设它已经被测试并且工作正常，因此没有必要再次通过额外的确认来验证它。
- en: Some code will probably make all of this clearer. First, let’s think about how
    to verify an expected result without a confirm. This is a time when we can’t just
    write the code for what a confirm will look like because we don’t know yet what
    we want it to do. A little exploration is in order. The next section will turn
    the exploration we’ll do here into actual confirms.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码可能会使这一切更加清晰。首先，让我们思考在没有确认的情况下如何验证预期的结果。这是一个我们无法直接编写确认将呈现的代码，因为我们还不知道我们希望它做什么的时候。需要进行一点探索。下一节将把在这里进行的探索转化为实际的确认。
- en: For a moment, let’s pretend that we have a real TDD project that we’re working
    on. We’ll keep things simple and say that we need some way to determine whether
    a school grade is passing or not. Even this simple example could become complicated
    if there were different guidelines for passing homework versus quizzes or tests.
    If that were the case, there might be a whole class hierarchy involved. We just
    have a simple need to determine whether a score from 0 to 100 is a passing grade
    or not.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时假设我们有一个真实的TDD项目正在工作。我们将保持事情简单，并说我们需要一种方法来确定学校成绩是否及格。即使这个简单的例子，如果对于通过家庭作业、测验或测试有不同的及格标准，也可能变得复杂。如果是那样的话，可能涉及到整个类层次结构。我们只是需要一种简单的方法来确定0到100分的分数是否是及格分数。
- en: Now that we have our scenario, what would a simple test look like? We don’t
    have any code to support the grading requirement. It’s just a general idea of
    what we want. So, we expect the build to fail if we try running right after creating
    a test. This is how you can use TDD to come up with a design.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的场景，一个简单的测试看起来会是什么样子？我们没有代码来支持评分要求。这只是我们想要的一般想法。因此，如果我们尝试在创建测试后立即运行，我们预期构建会失败。这就是你可以使用TDD来构思设计的方法。
- en: 'For now, we’ll put this code inside `Confirm.cpp`. If we were really building
    a test project for a school grading application, then there might be a test file
    called `Grades.cpp`. Because we’re just exploring, we’ll use the test file we
    already have, called `Confirm.cpp`, and create a test like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将这段代码放在`Confirm.cpp`内部。如果我们真的在为一个学校评分应用程序构建测试项目，那么可能有一个名为`Grades.cpp`的测试文件。因为我们只是在探索，我们将使用我们已有的测试文件，即`Confirm.cpp`，并创建一个这样的测试：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first thing is to think about the usage. If you had a function called `isPassingGrade`
    that accepted a score and returned a bool result, would that meet your requirements
    and be easy to use? It seems easy enough. It will do whatever it needs inside
    to tell us whether the score is passing or not and return true if the grade is
    passing and false if it’s not.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是考虑用法。如果你有一个名为`isPassingGrade`的函数，它接受一个分数并返回一个bool结果，这会满足你的要求并且易于使用吗？这似乎足够简单。它将执行所需的一切来告诉我们分数是否及格，并在分数及格时返回true，不及格时返回false。
- en: Then, you can think about how to test this function. It’s always good to test
    boundary conditions, so we can start by asking whether a score of 0 is passing
    or not. We assign the passing result to a variable that can be tested against
    an expected value. We expect 0 to be a failing grade, which is why the code throws
    something if the result is true instead. This will cause the test case to fail
    because of an unexpected exception.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以考虑如何测试这个函数。测试边界条件总是好的，所以我们可以先问一个分数为0是否及格。我们将及格结果赋给一个可以与预期值进行比较的变量。我们预期0分是不及格的，这就是为什么如果结果是true，代码会抛出异常。这将导致测试案例因为意外的异常而失败。
- en: 'We’re on the right track. This is what I want you to understand about checking
    along the way to make sure everything is running okay. We could add another check
    in the same test like this to make sure that 100 is a passing grade:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在正确的轨道上。这是我想让你了解的关于在过程中进行检查以确保一切运行正常的内容。我们可以在同一个测试中添加另一个检查，如下所示，以确保100分是及格分数：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, you can see a single test that checks two things. First, it makes sure
    that a score of 0 is a failing grade and then that a score of 100 is a passing
    grade. Because these checks are so related, I would put them in the same test
    as this and confirm that the first case should be a failing grade and the second
    should be a passing grade.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到单个测试检查了两件事。首先，它确保0分是不及格的，然后100分是及格的。因为这些检查非常相关，我会把它们放在同一个测试中，并确认第一个案例应该是不及格的，第二个应该是及格的。
- en: A test confirmation is nothing more than a simple check against an expected
    value that throws an exception if the expectation is not met.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试确认不过是简单地对预期值进行检查，如果预期未满足，则会抛出异常。
- en: Some TDD purists will recommend that you split the test into two separate tests.
    My advice is to use your best judgment. I tend to avoid absolute guidance that
    says you should *always* do something one way or another. I think there’s room
    to be flexible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些TDD纯粹主义者会建议你将测试分成两个独立的测试。我的建议是使用你的最佳判断。我倾向于避免绝对指导，即你应该“总是”以某种方式做某事。我认为有空间灵活处理。
- en: Let’s get this building so that we can run it and see the results. All we need
    to do is add the `isPassingGrade` function. We’ll add the function to the top
    of `Confirm.cpp`. If this was a real project you were working on, then you would
    have a better place to put this function. It would not be in the test project;
    instead, it would be included in the project being tested.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建，以便我们可以运行它并查看结果。我们唯一需要做的是添加`isPassingGrade`函数。我们将函数添加到`Confirm.cpp`的顶部。如果这是一个你正在工作的真实项目，那么你会有一个更好的地方来放置这个函数。它不会在测试项目中；相反，它将被包含在正在测试的项目中。
- en: 'Inside `Confirm.cpp`, create a function called `isPassingGrade`, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Confirm.cpp`内部，创建一个名为`isPassingGrade`的函数，如下所示：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we can build and run the project to see the results. The test result we’re
    interested in fails like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建并运行项目以查看结果。我们感兴趣的测试结果会失败如下：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The function should obviously fail because it always returns true for a passing
    grade regardless of the score given. But that’s not the part we’re going to focus
    on next. It would be if you really were building and testing a grading application.
    You would enhance the design, get the test to pass, and then enhance the test,
    and continue until all the tests pass.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数显然应该失败，因为它总是返回true，不管给出的分数是多少。但那不是我们接下来要关注的重点。如果你真的在构建和测试一个评分应用程序，你会增强设计，让测试通过，然后增强测试，并继续直到所有测试都通过。
- en: This is enough to demonstrate what I mean by checking on the progress of a running
    test to make sure it’s proceeding as expected. Now we have a test that, first,
    checks to make sure 0 is a failing grade and then checks to make sure 100 is a
    passing grade. Each of these is a confirm. At each point, we are checking whether
    the actual result matches what we expect. And we confirm in different ways to
    fit each condition.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以说明我所说的通过检查正在运行的测试的进度，以确保其按预期进行。现在我们有一个测试，首先检查确保0分是一个不及格的分数，然后检查确保100分是一个及格的分数。这些检查中的每一个都是一个确认。在每一个点上，我们都在检查实际结果是否与预期相符。并且我们以不同的方式确认，以适应每种条件。
- en: In the next section, we’re going to enhance the test library to fix problems
    with the current solution and make it easier to write confirms. Right now, the
    code throws an int when it detects a problem, and while the throw definitely causes
    the test to fail, it leads to a test result that says the failure was caused by
    an unexpected exception.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将增强测试库，以修复当前解决方案的问题，并使其更容易编写确认。目前，代码在检测到问题时抛出一个整数，虽然抛出确实会导致测试失败，但它会导致一个测试结果说明失败是由意外的异常引起的。
- en: The next section will wrap the `if` statement with its criteria and the exception
    throwing into an easy macro that will handle everything and lead to a better description
    of what actually failed and where it failed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将把`if`语句及其标准以及异常抛出包装成一个易于使用的宏，这将处理一切，并更好地描述实际失败的地方和原因。
- en: Enhancing the testing library to support assertions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强测试库以支持断言
- en: 'The passing grades test from the previous section has two confirms that we’re
    going to improve in this section. It looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的及格分数测试有两个确认，我们将在本节中对其进行改进。它看起来是这样的：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the first confirm, we want to make sure that `result` is false because we
    know that a score of 0 should not be a passing grade. And for the second confirm,
    we want to make sure that, this time, `result` is true because we know that a
    score of 100 should lead to a passing grade.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个确认中，我们想确保`result`是false，因为我们知道0分不应该是一个及格的分数。而在第二个确认中，我们想确保这次`result`是true，因为我们知道100分应该导致及格。
- en: Can you see how the `if` condition needs to be the *opposite* of what we’re
    trying to confirm? This is because the `if` block runs when the confirm does *not*
    meet the expected value. We’ll need to make this easier to use because it will
    lead to bugs if we always have to write confirms like this. But there are still
    bigger problems with the test code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出`if`条件需要与我们要确认的内容相反吗？这是因为当确认不符合预期值时，`if`块会运行。我们需要使其更容易使用，因为如果我们总是必须这样编写确认，这会导致错误。但测试代码中仍然存在更大的问题。
- en: Why does it throw an int if the check fails? That’s because we’re still exploring
    what a real confirm should look like. The code we have now just shows you the
    need for making checks along the way inside of a test to ensure things are proceeding
    as expected. This section will change how we’re going to be writing confirms in
    our tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么检查失败时会抛出一个整数？这是因为我们仍在探索一个真正的确认应该是什么样子。我们现在的代码只是展示了在测试过程中进行检查的需要，以确保一切按预期进行。本节将改变我们在测试中编写确认的方式。
- en: Throwing an int when a value does not match what was expected also leads to
    the wrong test result description. We don’t want the test results to say that
    an unexpected exception was thrown.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值不符合预期时抛出一个整数，也会导致错误的测试结果描述。我们不希望测试结果说明抛出了意外的异常。
- en: However, we do want to throw something. Because once a test deviates from the
    expected path, we don’t want the test to continue. It’s already shown that it
    has failed. Throwing whenever an expected condition is not met is a great way
    to fail the test at that point. We need to figure out a way to change the test
    result description to better inform us of what went wrong.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实想要抛出一个东西。因为一旦测试偏离了预期的路径，我们不想让测试继续进行。它已经表明测试已经失败了。在预期条件未满足时随时抛出是一个在那个点上失败测试的好方法。我们需要找出一种方法来更改测试结果描述，以便更好地告诉我们出了什么问题。
- en: 'First, let’s fix the test result by throwing something more meaningful. Note
    that the following code uses hardcoded numeric values, such as 17 and 23\. Numbers
    such as these are often called *magic numbers* and should be avoided. We’ll be
    fixing the problem soon, and the use of direct numbers whose meaning is unclear
    is included to show you that there is a better way. In `Confirm.cpp`, change the
    passing grades test to throw `BoolConfirmException` from both confirms like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过抛出一个更有意义的东西来修复测试结果。请注意，以下代码使用了硬编码的数值，例如17和23。这样的数字通常被称为*魔法数字*，应该避免使用。我们很快就会解决这个问题，直接使用意义不明确的数字是为了向您展示有更好的方法。在`Confirm.cpp`中，将及格分数测试从两个确认中抛出`BoolConfirmException`，如下所示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Later, we’ll need to create this class. For now, we want to code it like we
    intend to use it. It’s called `BoolConfirmException` because it will let us confirm
    that a bool value matches what we expect. The constructor parameters will be the
    expected bool value and the line number. I used line numbers 17 and 23 because
    they are the line numbers in my editor for the two `throw` statements. Later in
    this section, we’ll use a macro so that we can let the macro provide the line
    number automatically. Normally, you would want to avoid hardcoding any numeric
    value in the code except for simple values such as 0, 1, and maybe -1\. Any other
    values are called magic numbers because the meaning is confusing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在稍后创建这个类。现在，我们想按照我们打算使用它的方式来编写代码。它被称为`BoolConfirmException`，因为它将让我们确认一个布尔值是否符合我们的预期。构造函数参数将是预期的布尔值和行号。我使用了行号17和23，因为它们是我编辑器中两个`throw`语句的行号。在本节稍后，我们将使用一个宏，这样宏就可以自动提供行号。通常，你想要避免在代码中硬编码任何数值，除非是简单的值，如0、1和可能-1。任何其他值都被称为魔法数字，因为它们的含义是混淆的。
- en: The exception thrown in confirms will be based on the information needed to
    make a meaningful test result description. For bool values, the expected value
    and line number are enough. Other exceptions will need more information and will
    be explained in the next chapter. We’ll have more than one exception type, but
    they will be related. Inheritance is a good way to represent the different exception
    types that we’ll be throwing. The base class for all the types will be called
    `ConfirmException`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认中抛出的异常将基于制作有意义的测试结果描述所需的信息。对于布尔值，预期的值和行号就足够了。其他异常将需要更多信息，将在下一章中解释。我们将有多个异常类型，但它们将是相关的。继承是表示我们将抛出的不同异常类型的好方法。所有类型的基类将被称为`ConfirmException`。
- en: 'In `Test.h`, create a new class called `ConfirmException` inside the `MereTDD`
    namespace like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Test.h`中，在`MereTDD`命名空间内创建一个名为`ConfirmException`的新类，如下所示：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, right after the base exception class, we can declare the derived `BoolConfirmException`
    class like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，紧随基异常类之后，我们可以声明派生的`BoolConfirmException`类，如下所示：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The purpose of `BoolConfirmException` is to format a meaningful description
    that can be read through the `reason` method in the base class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoolConfirmException`的目的是通过基类中的`reason`方法格式化一个有意义的描述。'
- en: 'The next thing we need to do is catch the base class when running the tests
    and display the confirm reason instead of a message saying that there was an unexpected
    exception. Modify the `runTests` method in `Test.h` so that it will catch the
    new exception base class and set the appropriate failed message like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在运行测试时捕获基类，并显示确认原因而不是显示有意外异常的消息。修改`Test.h`中的`runTests`方法，使其能够捕获新的异常基类，并设置适当的失败消息，如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The confirm exception is ready. Building and running shows the following test
    result:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 确认异常已准备好。构建和运行显示以下测试结果：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a lot better than saying there was an unexpected exception. Now, we
    understand there was a confirm failure on line 17 and that the test expected the
    value to be false. Line 17 is for grade 0, which we expected to be a failing grade.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这比说出现了意外的异常要好得多。现在，我们了解到在第17行出现了确认失败，测试期望的值是错误的。第17行对应于0分，这是我们期望的失败分数。
- en: 'Let’s add a macro for the confirm so that we no longer have to provide the
    line number manually. And the macro can include the backward logic in the `if`
    condition and the throwing of the proper confirm exception. Here’s what the test
    should look like with the macro. We’ll add the macro but only after we write the
    code that intends to use the macro. Change the passing grades test in `Confirm.cpp`
    to look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为确认添加一个宏，这样我们就不必手动提供行号了。并且宏可以在`if`条件中包含反向逻辑以及抛出适当的确认异常。以下是使用宏的测试应该看起来像什么。我们将添加宏，但只有在编写了打算使用宏的代码之后。将`Confirm.cpp`中的及格分数测试更改如下：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now the test really looks like it’s using confirms. Additionally, the macros
    make it very clear that the first confirm is *expecting* `result` to be false,
    while the second confirm is *expecting* `result` to be true. The value that gets
    passed to the macro is called the *actual* value. As long as the actual value
    matches the expected value, then the confirm passes and lets the test continue.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试看起来真的像是在使用确认。此外，宏使得第一个确认期望`result`为假，而第二个确认期望`result`为真变得非常清楚。传递给宏的值称为*实际*值。只要实际值与期望值匹配，确认就通过并允许测试继续。
- en: 'To define these macros, we’ll put them at the end of `Test.h`. Note that each
    one is almost identical to what the test used to code manually:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义这些宏，我们将它们放在`Test.h`的末尾。请注意，每个宏几乎与测试手动编写的代码完全相同：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see that when confirming a false expected value, the `if` condition
    looks for a true actual value. Additionally, when confirming a true expected value,
    the `if` condition looks for a false actual value. Both macros throw `BoolConfirmException`
    and use `__LINE__` to get the line number automatically.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当确认一个期望的值为假时，`if`条件寻找一个真实的实际值。此外，当确认一个期望的值为真时，`if`条件寻找一个错误实际值。这两个宏都会抛出`BoolConfirmException`并使用`__LINE__`自动获取行号。
- en: 'Now, running the tests shows almost the exact same results. The only difference
    is the line number that the passing grades test fails at. This is because the
    confirm macros now use a single line each. The results look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试显示几乎完全相同的结果。唯一的区别是及格分数测试失败的行号。这是因为确认宏现在每行使用一个。结果如下所示：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The confirms are much easier to use now, and they make the test clearer to read
    and understand. Our goal is not to build a school grading application, so we’ll
    be removing the exploratory code. However, before removing it, the next section
    will use the passing grades test to explain another important aspect of TDD. And
    that is the question of what to do about error cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确认的使用更加简单，它们使得测试更容易阅读和理解。我们的目标不是构建一个学校评分应用程序，所以我们将移除探索性代码。然而，在移除之前，下一节将使用及格分数测试来解释TDD的另一个重要方面。那就是关于错误情况应该怎么办的问题。
- en: Should error cases be tested, too?
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是否也应该测试错误情况？
- en: Is it possible to get to 100% testing code coverage? And what does that mean?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可能达到100%的测试代码覆盖率？这意味着什么？
- en: 'Let me explain by continuing to use the passing grades code we were exploring
    in the previous section. Here is the test again:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我通过继续使用我们在上一节中探索的及格分数代码来解释。这里再次是测试：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Right now, this test does cover 100% of the function under test. That means
    that all of the code inside the `isPassingGrade` function is being run by at least
    one test. I know, the `isPassingGrade` function is a simple function with a single
    line of code that always returns true. It looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个测试确实覆盖了被测试函数的100%。这意味着`isPassingGrade`函数中的所有代码至少被一个测试运行。我知道，`isPassingGrade`函数是一个简单的函数，只有一行代码，总是返回true。它看起来像这样：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With a function this simple, just calling it from within a test will make sure
    that all of the code is covered or run. As it is, the function doesn’t work and
    needs to be enhanced to pass both confirms. We can enhance it to look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的函数，只需在测试中调用它，就可以确保所有代码都被覆盖或运行。目前，这个函数不起作用，需要增强以通过两个确认。我们可以将其增强为如下所示：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Building and running the project now passes the test. The results of the passing
    grades test look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建和运行项目可以通过测试。及格分数测试的结果如下所示：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And we still have 100% code coverage for this function because the passing grades
    test calls the function twice with the values of 0 and 100\. The first call causes
    the `if` condition to be true, which executes the code inside the `if` block.
    And the second call causes the `return` statement after the `if` block to run.
    By calling `isPassingGrade` with both the 0 and 100 values, we cause all of the
    code inside to be run at least once. That is what it means to achieve 100% code
    coverage.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 而且我们仍然为这个函数保持了100%的代码覆盖率，因为通过成绩测试调用了函数两次，分别使用0和100的值。第一次调用使`if`条件为真，从而执行`if`块内的代码。第二次调用使`if`块之后的`return`语句执行。通过使用0和100的值调用`isPassingGrade`，我们确保了所有代码至少运行一次。这就是实现100%代码覆盖率的意义。
- en: Both values of 0 and 100 are valid grades, and it makes sense to test with them.
    We don’t need to test what will happen if we call `isPassingGrade` with the values
    of 1 or 99\. That’s because they are not interesting.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 0和100这两个值都是有效的成绩，使用它们进行测试是有意义的。我们不需要测试如果我们用1或99的值调用`isPassingGrade`会发生什么。这是因为它们并不有趣。
- en: Edge values are almost always interesting. So, it would make sense to add a
    couple more calls inside the test for values 59 and 60\. While these represent
    good call values and confirms to add to the test, they won’t do anything for the
    code coverage.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘值几乎总是有趣的。因此，在测试中添加对59和60这两个值的几个调用是有意义的。虽然这些代表良好的调用值并确认需要添加到测试中，但它们对代码覆盖率没有任何帮助。
- en: That leads to the first point I want you to understand. Simply achieving 100%
    code coverage is not enough. You want to ensure that you are testing everything
    that needs to be tested. Look for edge cases that should be tested even if they
    don’t do anything to improve your code coverage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了我想让你理解的第一点。仅仅达到100%的代码覆盖率是不够的。你需要确保测试了所有需要测试的内容。寻找那些即使不会提高你的代码覆盖率，也应该进行测试的边缘情况。
- en: And then look for error cases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后寻找错误情况。
- en: Error cases will likely drive your code to add extra checking to make sure the
    error cases are properly handled. TDD is a great way to drive these conditions.
    Alternatively, you might decide to change your design as a way to make an error
    case no longer applicable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 错误情况可能会驱使你添加额外的检查以确保错误情况得到适当处理。TDD（测试驱动开发）是驱动这些条件的好方法。或者，你可能会决定改变设计，使错误情况不再适用。
- en: For example, does it make sense to check whether a negative grade is passing?
    If so, definitely add a test and then add the code to make the test pass. This
    is something that I would put into a new test. Remember the balance between having
    a single confirm per test versus allowing multiple confirms?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，检查一个负分是否通过是否有意义？如果是这样，肯定要添加一个测试，然后添加代码使测试通过。这是我会放入新测试中的事情。记住在每次测试中只有一个确认与允许多个确认之间的平衡？
- en: It makes sense to include all confirms for calling `isPassingGrade` for the
    values of 0, 59, 60, and 100 in a single test. At least to me.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将调用`isPassingGrade`的0、59、60和100的值的所有确认包含在一个测试中是有意义的。至少对我来说是这样的。
- en: However, calling `isPassingGrade` with a value of -1 is different enough that
    it should have its own test. Or maybe thinking of this test is enough to cause
    you to change the design so that `isPassingGrade` no longer accepts an int parameter,
    and you decide to use an unsigned int parameter instead. For this particular example,
    I would probably use an unsigned int. That would mean we no longer need a test
    for -1 or any negative number grade.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用-1的值调用`isPassingGrade`是足够不同的，应该有它自己的测试。或者，考虑这个测试可能足以让你改变设计，使`isPassingGrade`不再接受int参数，而你决定使用无符号int参数。对于这个特定的例子，我可能会使用无符号int。这意味着我们不再需要为-1或任何负数成绩进行测试。
- en: But what about grades above 100? Maybe they should be allowed for extra credit
    grades. If so, then add a new test for grades above 100 and make sure to confirm
    they pass. You might find the values of 101, 110, and 1,000,000 to be interesting.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于超过100分的成绩呢？也许应该允许它们作为额外学分成绩。如果是这样，那么添加一个新的测试来测试超过100分的成绩，并确保它们通过。你可能会发现101、110和1,000,000这些值很有趣。
- en: Why the values of 101, 110, and 1,000,000? Well, 101 is an edge value and should
    be included. The value of 110 seems like a reasonable extra credit value. And
    the value of 1,000,000 is a good example of a ridiculous value that should be
    included just to make sure the code doesn’t fail with some unexpected exception.
    You might even consider putting the 1,000,000 value in its own test.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是101、110和1,000,000这些值呢？好吧，101是一个边缘值，应该包含在内。110的值看起来像是一个合理的额外加分值。而1,000,000的值是一个很好的例子，它是一个荒谬的值，应该包含在内以确保代码不会因为一些意外的异常而失败。你甚至可以考虑将1,000,000的值放在自己的测试中。
- en: Error cases should be tested. Ideally, you will think of the error cases while
    writing the tests, and you can write the test first before adding code to handle
    the error condition. For example, if you decide that any grade over 1,000 should
    result in an exception being thrown, then write a test that expects the exception
    and call `isPassingGrade` with the value of 1,000 to make sure that it does throw.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 错误情况应该被测试。理想情况下，你可以在编写测试时考虑错误情况，并在添加处理错误条件的代码之前先编写测试。例如，如果你决定任何超过1,000分的成绩都应该抛出异常，那么就编写一个期望异常的测试，并用1,000的值调用`isPassingGrade`以确保它确实抛出了异常。
- en: 'One final thought about testing error cases is this: I’ve seen a lot of code
    that was not designed using TDD, and one thing that stands out to me regarding
    a lot of this code is that error cases are much harder to test. Sometimes, it’s
    no longer feasible to add tests for certain error cases because they are too difficult
    to isolate and get them to run so that the test can verify how the code responds.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试错误情况的最后一个想法是：我见过很多没有使用TDD（测试驱动开发）设计的代码，而且让我印象深刻的是，很多这样的代码中错误情况测试起来非常困难。有时，添加某些错误情况的测试已经不再可行，因为它们太难隔离，而且很难让它们运行，以便测试可以验证代码的响应。
- en: Once you start following TDD, you’ll find that you have much better test coverage.
    That’s because you designed tests first, including the tests for error cases.
    This forces you to make your designs *testable* from the very beginning.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始遵循TDD，你会发现你的测试覆盖率要好得多。这是因为你首先设计了测试，包括错误情况的测试。这迫使你从一开始就设计出可测试的设计。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to write tests that can detect a failure even
    before reaching the end of the test. You learned how to use confirms to make sure
    that the actual values match what you expect them to be. However, this chapter
    only explained how to check bool values. There are many other types of values
    you will need to check, such as the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写可以在测试结束前就检测到失败的测试。你学习了如何使用确认来确保实际值与你期望的值相匹配。然而，本章只解释了如何检查布尔值。你还需要检查许多其他类型的值，例如以下内容：
- en: You might have a number such as a count that needs to be confirmed
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能有一个需要确认的数字，比如计数。
- en: You might need to check a string value to make sure it contains the text you
    expect
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能需要检查一个字符串值，以确保它包含你期望的文本。
- en: The next chapter will add these additional types and explain a common problem
    when comparing fractional or floating-point numeric values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将添加这些额外的类型，并解释比较分数或浮点数值时常见的一个问题。
