["```cpp\nPerson p1(\"Alexa\", \"Gutierrez\", 'R', \"Ms.\");\nPerson p2(move(p1));  // move copy constructor\nPerson p3 = move(p2); // also the move copy constructor\n```", "```cpp\nPerson p3(\"Alexa\", \"Gutierrez\", 'R', \"Ms.\");\nPerson p5(\"Xander\", \"LeBrun\", 'R', \"Dr.\");\np5 = move(p3);  // move assignment; replaces p5\n```", "```cpp\nclass Person\n{\nprivate:    // Note slightly modified data members\n    string firstName, lastName;\n    char middleInitial = '\\0';   // in-class initialization\n    // pointer data member to demo deep copy and operator =\n    char *title = nullptr;      // in-class initialization\nprotected: // Assume usual protected member functions exist \npublic:\n    Person() = default;      // default constructor\n    // Assume other usual constructors exist  \n    Person(const Person &);  // copy constructor\n    Person(Person &&);       // move copy constructor\n    virtual ~Person() { delete [] title }; // virtual dest.\n    // Assume usual access functions and virtual fns. exist \n    Person &operator=(const Person &);  // assignment op.\n    Person &operator=(Person &&);  // move assignment op.\n};\n// copy constructor\nPerson::Person(const Person &p): firstName(p.firstName),\n      lastName(p.lastName), middleInitial(p.middleInitial)\n{ \n    // Perform a deep copy for the pointer data member \n    // That is, allocate memory, then copy contents\n    title = new char [strlen(p.title) + 1];\n    strcpy(title, p.title);\n}\n// overloaded assignment operator\nPerson &Person::operator=(const Person &p)\n{\n    if (this != &p)  // check for self-assignment\n    {\n       // delete existing Person ptr data mbrs. for 'this'\n       delete [] title;\n       // Now re-allocate correct size and copy from source\n       // Non-pointer data members are simply copied from\n       // source to destination object\n       firstName = p.firstName; // assignment btwn. strings\n       lastName = p.lastName;\n       middleInitial = p.middleInitial;\n       title = new char [strlen(p.title) + 1]; // mem alloc \n       strcpy(title, p.title);\n    }\n    return *this;  // allow for cascaded assignments\n}\n```", "```cpp\n// move copy constructor\nPerson::Person(Person &&p): firstName(p.firstName), \n    lastName(p.lastName), middleInitial(p.middleInitial),\n    title(p.title)  // dest ptr takes over src ptr's memory\n{   \n    // Overtake source object's dynamically alloc. memory\n    // or use simple assignments (non-ptr data members) \n    // to copy source object's members in member init. list \n    // Then null-out source object's ptrs to that memory\n    // Clear source obj's string mbrs, or set w null char\n    p.firstName.clear(); // set src object to empty string\n    p.lastName.clear();\n    p.middleInitial = '\\0'; // null char indicates non-use\n    p.title = nullptr; // null out src ptr; don't share mem\n}\n// move overloaded assignment operator\nPerson &Person::operator=(Person &&p)\n{ \n    if (this != &p)       // check for self-assignment\n    {\n        // delete destination object's ptr data members\n        delete [] title;      \n        // for ptr mbrs: overtake src obj's dynam alloc mem\n        // and null source object's pointers to that memory\n        // for non-ptr mbrs, a simple assignment suffices\n        // followed by clearing source data member\n        firstName = p.firstName;  // string assignment\n        p.firstName.clear();   // clear source data member \n        lastName = p.lastName;\n        p.lastName.clear();\n        middleInitial = p.middleInitial; // simple =\n        p.middleInitial = '\\0'; // null char shows non-use\n        title = p.title; // ptr assignment to take over mem\n        p.title = nullptr;   // null out src pointer\n    }\n    return *this;  // allow for cascaded assignments  \n}\n```", "```cpp\nclass Student: public Person\n{\nprivate:  \n    float gpa = 0.0;        // in-class initialization\n    string currentCourse;\n    // one pointer data member to demo deep copy and op=\n    const char *studentId = nullptr; // in-class init.\n    static int numStudents; \npublic:\n    Student();                 // default constructor\n    // Assume other usual constructors exist  \n    Student(const Student &);  // copy constructor\n    Student(Student &&);       // move copy constructor\n    ~Student() override;       // virtual destructor\n    // Assume usual access functions exist \n    // as well as virtual overrides and additional methods\n    Student &operator=(const Student &);  // assignment op.\n    Student &operator=(Student &&);  // move assignment op.\n};\n// See online code for default constructor implementation\n// as well as implementation for other usual member fns.\n// copy constructor\nStudent::Student(const Student &s): Person(s), \n                 gpa(s.gpa), currentCourse(s.currentCourse)\n{   // Use member init. list to specify base copy \n    // constructor to initialize base sub-object\n    // Also use mbr init list to set most derived data mbrs\n    // Perform deep copy for Student ptr data members \n    // use temp - const data can't be directly modified \n    char *temp = new char [strlen(s.studentId) + 1];\n    strcpy (temp, s.studentId);\n    studentId = temp;\n    numStudents++;\n}\n// Overloaded assignment operator\nStudent &Student::operator=(const Student &s)\n{\n   if (this != &s)   // check for self-assignment\n   {   // call base class assignment operator\n       Person::operator=(s); \n       // delete existing Student ptr data mbrs for 'this'\n       delete [] studentId;\n       // for ptr members, reallocate correct size and copy\n       // from source; for non-ptr members, just use =\n       gpa = s.gpa;  // simple assignment\n       currentCourse = s.currentCourse;\n       // deep copy of pointer data mbr (use a temp since\n       // data is const and can't be directly modified)\n       char *temp = new char [strlen(s.studentId) + 1];\n       strcpy (temp, s.studentId);\n       studentId = temp;\n   }\n   return *this;\n}\n```", "```cpp\n// move copy constructor\nStudent::Student(Student &&s): Person(move(s)), gpa(s.gpa),\n    currentCourse(s.currentCourse), \n    studentId(s.studentId) // take over src obj's resource \n{   \n    // First, use mbr. init. list to specify base move copy \n    // constructor to initialize base sub-object. Then\n    // overtake source object's dynamically allocated mem.\n    // or use simple assignments (non-ptr data members) \n    // to copy source object's members in mbr. init. list.\n    // Then null-out source object's ptrs to that memory or \n    // clear out source obj's string mbrs. in method body\n    s.gpa = 0.0;     // then zero-out source object member\n    s.currentCourse.clear();  // clear out source member\n    s.studentId = nullptr; // null out src ptr data member\n    numStudents++;  // it is a design choice whether or not \n    // to inc. counter; src obj is empty but still exists\n}\n// move assignment operator\nStudent &Student::operator=(Student &&s)\n{\n   // make sure we're not assigning an object to itself\n   if (this != &s)\n   {\n      Person::operator=(move(s));  // call base move oper=\n      delete [] studentId;  // delete existing ptr data mbr\n      // for ptr data members, take over src objects memory\n      // for non-ptr data members, simple assignment is ok\n      gpa = s.gpa; // assignment of source to dest data mbr\n      s.gpa = 0.0; // zero out source object data member\n      currentCourse = s.currentCourse; // string assignment\n      s.currentCourse.clear(); // set src to empty string\n      studentId = s.studentId; // pointer assignment\n      s.studentId = nullptr;   // null out src ptr data mbr\n   }\n   return *this;  // allow for cascaded assignments\n}\n```", "```cpp\n#include \"Person.h\"  // include relevant class header files\n#include \"Student.h\"\nusing std::cout;    // preferred to: using namespace std;\nusing std::endl;\nconstexpr int MAX = 3;\nint main() // Driver to test Student class, stored in above\n{          // filename for chapter example consistency \n    // Test all instantiation means, even copy constructor\n    Student s0; // Default construction\n    // alternate constructor\n    Student s1(\"Jo\", \"Li\", 'H', \"Ms.\", 3.7, \"C++\", \n               \"UD1234\");\n    Student s2(\"Sam\", \"Lo\", 'A', \"Mr.\", 3.5, \"C++\",\n               \"UD2245\");\n    // These initializations implicitly invoke copy const.\n    Student s3(s1);\n    Student s4 = s2;   // This is also initialization\n    // Test the assignment operator\n    Student s5(\"Ren\", \"Ze\", 'A', \"Dr.\", 3.8, \"C++\",\n               \"BU5563\");\n    Student s6;\n    s6 = s5;  // this is an assignment, not initialization\n    // Test each public method. A sample is shown here\n    s1.Print();  // Be sure to test each method! \n\n    // Generalize derived instances as base types \n    // Do the polymorphic operations work as expected?\n    Person *people[MAX] = { }; // initialized with nullptrs\n    // base instance for comparison\n    people[0] = new Person(\"Juliet\", \"Martinez\", 'M',\n                           \"Ms.\");\n    // derived instances, generalized with base class ptrs.   \n    people[1] = new Student(\"Zack\", \"Moon\", 'R', \"Dr.\",\n                            3.8, \"C++\", \"UMD1234\");  \n    people[2] = new Student(\"Gabby\", \"Doone\", 'A', \"Dr.\", \n                            3.9, \"C++\", \"GWU4321\");\n    for (auto *item : people)  // loop through all elements\n    {\n       item->IsA();\n       cout << \"  \";\n       item->Print();\n    }\n    // Test destruction sequence (dynam. alloc. instances)\n    for (auto *item : people)  // loop thru all elements\n       delete item;   // engage virtual dest. sequence\n    return 0;\n}\n```"]