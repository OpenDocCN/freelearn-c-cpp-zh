- en: Chapter 4. Pause Menu Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 暂停菜单框架
- en: At this point, we have created a basic combat engine for our game. We can now
    dive into out-of-combat operations such as the creation of a pause menu screen,
    where we will be able to view player stats and edit inventory.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为我们的游戏创建了一个基本的战斗引擎。现在我们可以深入到战斗外的操作，例如创建一个暂停菜单屏幕，在那里我们可以查看玩家统计数据和编辑库存。
- en: 'In this chapter, we will create the first part of our menu system, which is
    to design and create a framework for a pause menu. We will cover the following
    topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建菜单系统的第一部分，即设计和创建一个暂停菜单的框架。本章将涵盖以下主题：
- en: UMG pause screen initial setup
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMG 暂停屏幕初始设置
- en: UMG background color
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMG 背景颜色
- en: UMG text
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMG 文本
- en: UMG buttons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMG 按钮
- en: UMG inventory submenu
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMG 库存子菜单
- en: UMG equipment submenu
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMG 设备子菜单
- en: Key binding
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键绑定
- en: Button programming
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮编程
- en: UMG pause screen initial setup
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG 暂停屏幕初始设置
- en: For our pause screen, we will need to think about quite a few things regarding
    the design. As listed in the earlier chapter, the pause screen will give the ability
    to the player to view party members, equip and unequip equipment, use items, and
    so on. So we must design our pause screen with that sort of functionality in mind.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的暂停屏幕，我们需要考虑很多关于设计的问题。如前一章所述，暂停屏幕将允许玩家查看团队成员、装备和卸载装备、使用物品等。因此，我们必须在设计暂停屏幕时考虑到这种功能。
- en: To design the pause screen, we will be using **Unreal Motion Graphics** (**UMG**),
    which is a separate portion of UE4 that allows us to design virtual user interfaces
    without the need for programs such as Adobe Flash. UMG is very intuitive and does
    not require programming knowledge in order to use it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计暂停屏幕，我们将使用 **Unreal Motion Graphics** (**UMG**)，这是 UE4 的一个独立部分，允许我们设计虚拟用户界面，而无需使用
    Adobe Flash 等程序。UMG 非常直观，使用它不需要编程知识。
- en: 'To start with, we will navigate to our already created **Blueprints** | **UI**
    folder and create a Widget Blueprint for our pause menu. To do this, right-click
    on your **UI** folder and then navigate to **User Interface** | **Widget Blueprint**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始设计，我们首先将导航到已经创建的 **蓝图** | **UI** 文件夹，并为暂停菜单创建一个 Widget 蓝图。为此，右键单击您的 **UI**
    文件夹，然后导航到 **用户界面** | **Widget 蓝图**：
- en: '![UMG pause screen initial setup](img/B04548_04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 暂停屏幕初始设置](img/B04548_04_01.jpg)'
- en: 'Name the Widget Blueprint as `Pause`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Widget 蓝图命名为 `Pause`：
- en: '![UMG pause screen initial setup](img/B04548_04_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 暂停屏幕初始设置](img/B04548_04_02.jpg)'
- en: The Widget Blueprint will allow you to use UMG to design any user interface;
    we will be using this widget to design our own UI for the pause menu.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Widget 蓝图将允许您使用 UMG 设计任何用户界面；我们将使用此 Widget 为暂停菜单设计我们自己的 UI。
- en: 'To start designing the pause menu, open the **Pause** Widget Blueprint by double-clicking
    on it from within **Content Browser**. You should see the **Designer** screen
    that looks like the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始设计暂停菜单，双击 **内容浏览器** 中的 **暂停** Widget 蓝图。您应该会看到类似于以下截图的 **设计师** 屏幕：
- en: '![UMG pause screen initial setup](img/B04548_04_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 暂停屏幕初始设置](img/B04548_04_03.jpg)'
- en: 'We are first going to create an area for our first screen where we want the
    pause menu to be. We will first be adding a Canvas Panel that acts as a container
    to allow several widgets to be laid out within it. This is a great place to start
    because we will need to feature several navigation points, which we will design
    in the form of buttons within our pause screen. To add a Canvas Panel, navigate
    to **Palette** | **Panel** | **Canvas Panel**. Then, drag the Canvas Panel into
    your **Designer** viewport (note that if you already have a Canvas Panel in your
    **Hierarchy** tab by default, you can skip this step):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将创建一个区域，用于放置我们希望暂停菜单所在的第一个屏幕。我们首先将添加一个 Canvas Panel，它作为一个容器，允许在内部布局多个 Widget。这是一个很好的开始，因为我们需要展示几个导航点，我们将以按钮的形式在我们的暂停屏幕中设计它们。要添加
    Canvas Panel，导航到 **调色板** | **面板** | **Canvas Panel**。然后，将 Canvas Panel 拖动到您的 **设计师**
    视图中（注意，如果您在 **层次结构** 选项卡中默认已经有 Canvas Panel，您可以跳过此步骤）：
- en: '![UMG pause screen initial setup](img/B04548_04_05.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 暂停屏幕初始设置](img/B04548_04_05.jpg)'
- en: You should see a few new things in your pause menu. Firstly, you will see that
    under the **Hierarchy** tab, there is now **CanvasPanel** in **Root**. This means
    that in the root of the pause screen is the Canvas Panel that we just added. You
    will also notice that your Canvas Panel, while selected, contains details that
    can be seen in the **Details** tab. The **Details** tab will allow you to edit
    properties of any selected item. We will be using these areas of Widget Blueprint
    frequently throughout our development process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在暂停菜单中看到一些新内容。首先，你会在**层次结构**选项卡下看到现在在**根**中有一个**CanvasPanel**。这意味着暂停屏幕的根目录是我们刚刚添加的Canvas
    Panel。你也会注意到，当Canvas Panel被选中时，它包含可以在**详情**选项卡中看到的详细信息。**详情**选项卡将允许你编辑任何选中项的属性。我们将在开发过程中频繁使用Widget
    Blueprint的这些区域。
- en: 'We now need to think about what sorts of navigation points and information
    we need on our screen when the player presses the pause button. Based on the functionality,
    the following are the items we will need to lay out on our first screen:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要考虑当玩家按下暂停按钮时，屏幕上需要显示哪些导航点和信息。根据功能，以下是我们将在第一个屏幕上布局的项目：
- en: Characters along with their stats (level, HP, MP, and experience/next level)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色及其统计数据（等级、HP、MP和经验/下一级）
- en: The **Inventory** button
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物品栏**按钮'
- en: The **Equipment** button
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装备**按钮'
- en: The **Exit** button
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出**按钮'
- en: Gold
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金色
- en: UMG background color
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG 背景颜色
- en: Before we begin creating texts and buttons for our menu, we should first make
    a background color that will be laid behind the texts and buttons of the pause
    screen. To do this, navigate to **Palette** | **Common** | **Image**. Then, drag
    and drop the image onto the Canvas Panel so that the image is within the Canvas
    Panel. From here, locate the **Anchors** drop-down menu under **Details** | **Slots**.
    Select the **Anchors** option that creates anchors on all the four corners of
    the canvas.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为菜单创建文本和按钮之前，我们首先应该制作一个背景颜色，这个颜色将放置在暂停屏幕的文本和按钮后面。为此，导航到**调色板** | **常用**
    | **图像**。然后，将图像拖放到Canvas Panel上，使图像位于Canvas Panel内。从这里，在**详情** | **槽位**下找到**锚点**下拉菜单。选择创建四个角落锚点的**锚点**选项。
- en: 'This is an icon that looks like a large square covering the entire canvas located
    on the bottom-right of the **Anchors** drop-down menu:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在**锚点**下拉菜单底部右侧的一个看起来像覆盖整个画布的大正方形的图标：
- en: '![UMG background color](img/B04548_04_07.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 背景颜色](img/B04548_04_07.jpg)'
- en: 'Once this is done, set the **Offset Right** and **Offset Bottom** values to
    0\. This will ensure that, just like the left and the top of the image, the right
    and the bottom of the image will start at 0, thus, allowing the image to stretch
    to all our anchor points that are positioned at all four corners of our canvas:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将**偏移右**和**偏移下**值设置为0。这将确保，就像图像的左上角一样，图像的右下角也将从0开始，从而允许图像拉伸到我们画布四个角落的所有锚点：
- en: '![UMG background color](img/B04548_04_08.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 背景颜色](img/B04548_04_08.jpg)'
- en: 'To make the background image a little easier on the eyes, we should make it
    a bit more of a dull color. To adjust the color, navigate to **Details** | **Appearance**
    | **Color and Opacity** and then click on the rectangular box next to it. This
    will open a **Color Picker** box where we can pick any color we want. In our example,
    we will use a dull blue:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使背景图像对眼睛更友好，我们应该将其颜色调得暗一些。要调整颜色，导航到**详情** | **外观** | **颜色和透明度**，然后点击旁边的矩形框。这将打开一个**颜色选择器**框，我们可以从中选择任何颜色。在我们的例子中，我们将使用暗蓝色：
- en: '![UMG background color](img/B04548_04_10.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 背景颜色](img/B04548_04_10.jpg)'
- en: 'Press **OK** once you are finished. You will notice that your image name is
    something like **Image_###**; we should adjust this so that it is more descriptive.
    To rename the image, simply navigate to **Details** and change the name. We will
    change the name to **BG_Color**. Lastly, change the **ZOrder** value in **Details**
    | **Slot** to **-1**. This will ensure that the background is drawn behind other
    widgets:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后按**确定**。你会注意到你的图像名称类似于**Image_###**；我们应该调整这个名字，使其更具描述性。要重命名图像，只需导航到**详情**并更改名称。我们将名称更改为**BG_Color**。最后，在**详情**
    | **槽位**中更改**ZOrder**值到**-1**。这将确保背景绘制在其他小部件之后：
- en: '![UMG background color](img/B04548_04_12.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 背景颜色](img/B04548_04_12.jpg)'
- en: UMG text
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG 文本
- en: 'Now that we have finished creating a background for our menu, it is time to
    lay out our text and navigation. We will add text by navigating to **Common**
    | **Text**. Then, we will drag and drop the text into the Canvas Panel located
    in the **Hierarchy** tab:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了菜单背景的创建，是时候布局我们的文本和导航了。我们将通过导航到**常用** | **文本**来添加文本。然后，我们将拖放文本到位于**层次结构**选项卡中的画布面板：
- en: '![UMG text](img/B04548_04_14.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![UMG文本](img/B04548_04_14.jpg)'
- en: Note down a few important details. Firstly, you will see that in the **Hierarchy**
    tab, the Text Block is located within the Canvas Panel. This means that the Canvas
    Panel is acting as a container for the text; thus, it can only be seen if the
    player is navigating through the Canvas Panel. You will also notice that the **Details**
    tab has changed in order to include specific properties for the text. Some really
    important details are listed here, such as position, size, text, and anchors.
    Lastly, you should see that the selected text is in the form of a movable and
    resizable text box, which means we can place and edit this however we choose to.
    For now, we won't worry about making the pause screen look pretty, we just need
    to focus on the layout and functionality. A common layout will be one that navigates
    the eyes left to right and top to bottom. Since we are starting with the characters,
    we will make our first text be the character names. Also, we will have them start
    at the top-left corner of the pause menu.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 记下一些重要细节。首先，你会在**层次结构**选项卡中看到文本块位于画布面板内。这意味着画布面板正在充当文本的容器；因此，只有当玩家在画布面板中导航时才能看到它。你还会注意到**详细信息**选项卡已更改，以包含特定于文本的属性。这里列出了几个非常重要的细节，例如位置、大小、文本和锚点。最后，你应该会看到选定的文本以可移动和可调整大小的文本框的形式出现，这意味着我们可以根据需要放置和编辑它。现在，我们不会担心使暂停屏幕看起来很漂亮，我们只需要关注布局和功能。常见的布局将是导航从左到右和从上到下。由于我们是从角色开始的，所以我们将第一个文本设置为角色名称。此外，我们将它们从暂停菜单的左上角开始。
- en: 'Firstly, we will add the text necessary for the character names or classes.
    While selecting the text, navigate to **Details** | **Content** | **Text** and
    type the name of the first class—`Soldier`. You will notice that the text that
    you wrote in the **Content** tab is now written in your Text Block in the **Designer**
    view. However, it is small, which makes the text hard to see. Change its size
    by navigating to **Details** | **Appearance** | **Font**. Here, you can change
    the size to something larger such as **48**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加必要的文本以显示角色名称或类别。在选择文本时，导航到**详细信息** | **内容** | **文本**，并输入第一个类别的名称——`Soldier`。你会注意到你在**内容**选项卡中输入的文本现在已出现在**设计师**视图中的文本块中。然而，它很小，这使得文本难以看清。通过导航到**详细信息**
    | **外观** | **字体**来更改其大小。在这里，你可以将其大小更改为更大的数字，例如**48**：
- en: '![UMG text](img/B04548_04_15.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![UMG文本](img/B04548_04_15.jpg)'
- en: 'Position the text by navigating to **Details** | **Slot** and moving the text
    so that it is located on the top-left corner, but give it some padding. In our
    example, we will set **Position X** to **100** and **Position Y** to **100** so
    that there is a 100-pixel padding for **Soldier**. Lastly, we will rename the
    text as **Header_Soldier**:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本定位到**详细信息** | **槽位**，然后移动文本使其位于左上角，但给它留一些填充空间。在我们的例子中，我们将**位置 X**设置为**100**，将**位置
    Y**设置为**100**，这样**士兵**就有100像素的填充空间。最后，我们将文本重命名为**Header_Soldier**：
- en: '![UMG text](img/B04548_04_17.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![UMG文本](img/B04548_04_17.jpg)'
- en: 'You will notice that the font size does not change and this is because you
    must press **Compile** at the top-left corner of the window. You will need to
    press **Compile** whenever you make technical changes such as these in your **Design**
    view. Once compiled, you should see that your font is resized. However, the text
    is too large for the Text Block. You can fix this by simply checking **Size to
    Content**, which is located in **Details** | **Slot**:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到字体大小没有变化，这是因为你必须按下窗口左上角的**编译**按钮。每次你在**设计**视图中进行此类技术更改时，都需要按下**编译**按钮。编译完成后，你应该会看到你的字体大小已调整。然而，文本对于文本块来说太大。你可以通过简单地勾选**大小适应内容**来修复这个问题，它位于**详细信息**
    | **槽位**：
- en: '![UMG text](img/B04548_04_19.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![UMG文本](img/B04548_04_19.jpg)'
- en: 'Now that we have created the header for our first character, we can continue
    to create more texts for its stats. We will start by creating a font for HP. To
    do so, you will need another Text Block on your canvas:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的第一个角色创建了标题，我们可以继续为其状态创建更多文本。我们将首先创建一个用于HP的字体。为此，你需要在画布上添加另一个文本块：
- en: '![UMG text](img/B04548_04_20.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![UMG文本](img/B04548_04_20.jpg)'
- en: 'From here, you can position your Text Block so that it is somewhere below the
    **Header_Soldier** text. In this example, we will place it at a **Position X**
    value of **200** and a **Position Y** value of **200**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以调整你的文本块的位置，使其位于**Header_Soldier**文本的下方。在这个例子中，我们将将其放置在**Position X**值为**200**和**Position
    Y**值为**200**的位置：
- en: '![UMG text](img/B04548_04_21.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 文本](img/B04548_04_21.jpg)'
- en: 'We will then write content for the text; in this case, the content will be
    **HP**. Here, we will give a font size of **32** to the text and compile it; then,
    we will check **Size to Content**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为文本编写内容；在这种情况下，内容将是**HP**。在这里，我们将文本的字体大小设置为**32**并编译它；然后，我们将勾选**Size to
    Content**：
- en: '![UMG text](img/B04548_04_23.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 文本](img/B04548_04_23.jpg)'
- en: 'Lastly, we will name this widget **Menu_HP**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这个小部件命名为**Menu_HP**：
- en: '![UMG text](img/B04548_04_24.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 文本](img/B04548_04_24.jpg)'
- en: 'As you can see, all we did was added text that says **HP** in the menu; however,
    you will also need actual numbers for the HP displayed on the screen. For now,
    we are simply going to make a blank Text Block on the right-hand side of the HP
    text. Later on in this chapter, we will tie this in with the code we created for
    the character HP in the previous chapter. So for now, drag and drop a Text Block
    as a child of your Canvas Panel:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只是添加了在菜单中显示**HP**的文本；然而，你还需要在屏幕上显示的实际数字。现在，我们只是在HP文本的右侧创建一个空的文本块。在本章的后面部分，我们将将其与上一章中为角色HP创建的代码联系起来。所以现在，将一个文本块拖放到你的Canvas面板下：
- en: '![UMG text](img/B04548_04_25.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 文本](img/B04548_04_25.jpg)'
- en: 'Rename it as **Editable_Soldier_HP**. Then, position it so that it is to the
    right of **Menu_HP**. In this case, we can set the **Position X** value as **300**
    and the **Position Y** value as **200**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将其重命名为**Editable_Soldier_HP**。然后，将其放置在**Menu_HP**的右侧。在这种情况下，我们可以将**Position
    X**值设置为**300**，将**Position Y**值设置为**200**：
- en: '![UMG text](img/B04548_04_27.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 文本](img/B04548_04_27.jpg)'
- en: 'Lastly, we can change the font style to **Regular**, the font size to **32**,
    check **Size to Content**, and compile:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将字体样式改为**Regular**，字体大小设置为**32**，勾选**Size to Content**，并编译：
- en: '![UMG text](img/B04548_04_28.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 文本](img/B04548_04_28.jpg)'
- en: 'Now that you know what the layout is like and how we can create text blocks
    for characters and their stats, you can proceed to create the other necessary
    stats for your character such as level, MP, and experience/next level. After you
    have finished laying out characters and their stats, your final result should
    look something like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了布局的样子以及我们如何为角色及其属性创建文本块，你可以继续创建其他必要的属性，例如等级、魔法值（MP）和经验值/下一级。在你完成角色及其属性的布局后，你的最终结果应该看起来像以下这样：
- en: '![UMG text](img/B04548_04_29.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 文本](img/B04548_04_29.jpg)'
- en: 'At this point, you may also move on to creating more characters. For instance,
    if you wanted to create a Healer, you could have easily copied most of the content
    we created for the Soldier and its layout in our pause screen. Your pause screen
    with placeholders for both Soldier and Healer stats may look something like the
    following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你也可以继续创建更多角色。例如，如果你想创建一个治疗者，你可以轻松地复制我们在暂停屏幕中为士兵创建的大部分内容和布局。你的暂停屏幕中可能有士兵和治疗者属性的占位符，可能看起来像以下这样：
- en: '![UMG text](img/B04548_04_30.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 文本](img/B04548_04_30.jpg)'
- en: 'The last placeholder we need to make on this screen is for gold that is collected
    by the player. Just like we did for the party stats, create a Text Block and make
    sure the content of the text is **Gold**. Place this somewhere away from the character
    stats, for example, in the bottom-left corner of the pause screen. Then, rename
    the Text Block as **Menu_Gold**. Finally, create a second Text Block, place it
    to the right of **Menu_Gold**, and call it **Editable_Gold**:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，我们还需要创建一个用于玩家收集的黄金的占位符。就像我们为团队属性所做的那样，创建一个文本块，并确保文本内容为**Gold**。将其放置在角色属性之外的地方，例如，在暂停屏幕的左下角。然后，将文本块重命名为**Menu_Gold**。最后，创建第二个文本块，将其放置在**Menu_Gold**的右侧，并命名为**Editable_Gold**：
- en: '![UMG text](img/B04548_04_32.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![UMG 文本](img/B04548_04_32.jpg)'
- en: Like the empty text boxes in the character stats, we will link **Editable_Gold**
    with the gold accumulated in the game later on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就像角色属性中的空白文本框一样，我们将**Editable_Gold**与游戏后期积累的黄金联系起来。
- en: We can now move on to creating buttons for our menu, which will eventually navigate
    to submenus.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续创建菜单的按钮，这些按钮最终将导航到子菜单。
- en: UMG buttons
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG 按钮
- en: So far, we have created the first screen of our pause menu that includes all
    of our characters and placeholders for their stats and gold. The next thing we
    need to design is buttons, which will be the last portion of our first pause screen.
    Much like buttons in other software packages, they are typically used to trigger
    events built around mouse clicks. A programmer can simply have their button listen
    to a press from a mouse button and cause an action or series of actions to occur
    based around that button click. The buttons we are creating will be used as navigation
    to submenus since we need a way of navigating through the inventory and equipment
    screens. Therefore, on our main screen, we will need a button for both inventory
    and equipment. We will also need a button to go to the pause menu and resume playing
    the game as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了暂停菜单的第一屏，其中包括所有角色以及他们统计数据和金币的占位符。接下来我们需要设计的是按钮，这将是第一屏的最后一部分。与其他软件包中的按钮类似，它们通常用于触发围绕鼠标点击构建的事件。程序员可以让按钮监听鼠标按钮的按下，并基于该按钮点击执行一系列动作。我们创建的按钮将被用作子菜单的导航，因为我们需要一种在物品栏和装备屏幕之间导航的方法。因此，在我们的主屏幕上，我们需要一个用于库存和装备的按钮。我们还需要一个按钮来进入暂停菜单并继续玩游戏。
- en: 'Let us start by creating our first button. Navigate to **Palette** | **Common**
    | **Button** and place it in your Canvas Panel under the **Hierarchy** tab:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建第一个按钮开始。导航到**调色板** | **常用** | **按钮**，并在**层次**选项卡下的画布面板中放置它：
- en: '![UMG buttons](img/B04548_04_34.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_34.jpg)'
- en: 'For organization purposes, we will lay our first button on the top-right of
    the menu. So the best thing to do is navigate to **Details** | **Slot** | **Anchors**
    and anchor the button at the top-right. This will ensure that as the screen or
    objects resize, the button aligns to the right-hand side:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织起见，我们将第一个按钮放置在菜单的右上角。所以最好的做法是导航到**详情** | **槽位** | **锚点**，并将按钮锚定在右上角。这将确保当屏幕或对象调整大小时，按钮会与右侧对齐：
- en: '![UMG buttons](img/B04548_04_35.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_35.jpg)'
- en: 'You should notice that the anchor icon on your screen moves to the top-right
    of the screen. You will also notice that the **Position X** value changes to a
    negative number that reflects the size of your screen, since the origin of the
    button position is placed at the opposite end of the screen; the values of **Position
    X** of this particular button are now flipped. This concept may be confusing at
    first, but it will make the math for the placement of each button much easier
    in the long run:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会注意到屏幕上的锚点图标移动到了屏幕的右上角。你还会注意到**位置X**的值变成了一个负数，这反映了屏幕的大小，因为按钮位置的原点被放置在屏幕的另一端；这个特定按钮的**位置X**值现在被反转。这个概念一开始可能有些令人困惑，但从长远来看，它将使每个按钮的放置计算变得更容易：
- en: '![UMG buttons](img/B04548_04_36.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_36.jpg)'
- en: 'Change the **Position X** value to **-200** (since **Position X** of the button
    is now **-1920** to be positioned from the left and **-100** to be positioned
    to the right, to add **100** pixels of padding would be **-200**) and **Position
    Y** value to **100**. Name this button **Button_Inventory**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将**位置X**值更改为**-200**（因为按钮的**位置X**现在是**-1920**，以便从左侧定位，而**-100**用于定位到右侧，为了添加**100**像素的填充，应该是**-200**），并将**位置Y**值更改为**100**。将此按钮命名为**Button_Inventory**：
- en: '![UMG buttons](img/B04548_04_38.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_38.jpg)'
- en: 'We will now add text to the button. So select **Text** under **Palette** |
    **Common** | **Text** and drag it into the button. You will notice that the text
    is within the button in both the **Hierarchy** tab and the **Designer** view:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向按钮添加文本。因此，在**调色板** | **常用** | **文本**下选择**文本**，并将其拖入按钮中。你会注意到文本在**层次**选项卡和**设计器**视图中都在按钮内：
- en: '![UMG buttons](img/B04548_04_39.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_39.jpg)'
- en: 'You may also notice that the text is not sized to our liking and it does not
    fit into the button. Rather than resizing the button right away, let us resize
    the text to our liking first and then resize the button around the text so that
    the text is readable. Navigate to **Details** | **Appearance** | **Font** and
    change the font size to **48**:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到文本的大小并不符合我们的喜好，它也没有完全适应按钮。我们不必立即调整按钮的大小，而是先调整文本到我们喜欢的尺寸，然后再调整按钮以适应文本，这样文本才能被清晰地阅读。导航到**详情**
    | **外观** | **字体**，并将字体大小更改为**48**：
- en: '![UMG buttons](img/B04548_04_40.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_40.jpg)'
- en: 'Then, under **Details** | **Content** | **Text**, change the text to **Inventory**
    and the name of the Text widget to **Menu_Inventory**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在**详细信息** | **内容** | **文本**下，将文本更改为**库存**，并将文本小部件的名称更改为**Menu_Inventory**：
- en: '![UMG buttons](img/B04548_04_41.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_41.jpg)'
- en: 'Click on **Button_Inventory**. You may be thinking that checking **Size to
    Content** would be the right idea here, but it isn''t in our circumstances because
    you will be creating multiple buttons, each with a different text in it. Therefore,
    if they were all sized to the content (content being the text within the button),
    all your buttons would be sized differently, which is very unattractive. Instead,
    you should pick a button size that will easily fit all the text, even for your
    longest worded text. For this button, we will change the **Size X** value to **350**
    and **Size Y** value to **100**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**按钮_库存**。你可能认为在这里检查**大小到内容**是个好主意，但在这个情况下并不适用，因为你会创建多个按钮，每个按钮中都有不同的文本。因此，如果它们都根据内容（即按钮内的文本）来调整大小，所有按钮的大小都会不同，这看起来非常不吸引人。相反，你应该选择一个可以轻松容纳所有文本的按钮大小，即使是对于最长的文本。对于这个按钮，我们将将**大小
    X**值更改为**350**，**大小 Y**值更改为**100**：
- en: '![UMG buttons](img/B04548_04_42.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_42.jpg)'
- en: 'You will notice that the button is drawn off the screen and this is because
    the button, like every other object, is still drawn from the top-left of the object,
    so we will need to adjust our **Position X** value again; however, the math is
    easy since we are anchored at the top-right. All we need to do is take the horizontal
    sizes of our button, 350, and then subtract it from where the button thinks the
    right edge of our screen is due to the anchor, which is 0\. So this gives us *0
    - 350 = -350*. Then, we take -350 and subtract the 100 pixels of padding that
    we want, which gives us *-350 - 100 = -450*, which is the value we should change
    our **Position X** to:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到按钮被绘制在屏幕之外，这是因为按钮，就像其他所有对象一样，仍然是从对象的左上角开始绘制的，所以我们需要再次调整我们的**位置 X**值；然而，由于我们锚定在右上角，数学运算很简单。我们只需要取按钮的水平尺寸，350，然后从按钮认为屏幕右边缘的位置减去它，由于锚定，这个位置是0。所以这给出了*0
    - 350 = -350*。然后，我们取-350并减去我们想要的100像素的填充，这给出了*-350 - 100 = -450*，这就是我们应该更改**位置
    X**的值：
- en: '![UMG buttons](img/B04548_04_43.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_43.jpg)'
- en: 'Now that we have a button perfectly placed, we can place more buttons. We will
    use the same steps to create an **Equipment** button below the **Inventory** button.
    Once you have completed creating the **Equipment** button, it can be placed just
    below the **Inventory** button:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将按钮放置得恰到好处，我们可以放置更多按钮。我们将使用相同的步骤在**库存**按钮下方创建一个**装备**按钮。一旦你完成了**装备**按钮的创建，它就可以放置在**库存**按钮的正下方：
- en: '![UMG buttons](img/B04548_04_44.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_44.jpg)'
- en: 'We can also create an **Exit** button, which we will place at the bottom-right
    of the screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个**退出**按钮，我们将将其放置在屏幕的右下角：
- en: '![UMG buttons](img/B04548_04_45.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![UMG按钮](img/B04548_04_45.jpg)'
- en: There you have it—we have finished designing the first screen of our pause menu.
    You will notice that we have not yet programmed the buttons to do anything, and
    this is because we do not have screens for the buttons to navigate to, so it won't
    make sense to program the buttons just yet. The next steps will be to design our
    submenus.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——我们已经完成了暂停菜单的第一屏的设计。你会注意到我们还没有为按钮编写任何程序，这是因为我们还没有为按钮导航到屏幕，所以现在编写按钮程序还没有意义。下一步将是设计我们的子菜单。
- en: The UMG inventory submenu
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG库存子菜单
- en: As mentioned earlier, we need to create submenus for our buttons to navigate
    to. Using UMG, there are several ways to create submenus, but the most straightforward
    way is to create a new Widget Blueprint for each submenu and then bind the Widget
    Blueprints together.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要为按钮创建子菜单以便导航。使用UMG，有几种创建子菜单的方法，但最直接的方法是为每个子菜单创建一个新的Widget Blueprint，然后将Widget
    Blueprints绑定在一起。
- en: 'Since we will need many of the same items in our submenus such as the character
    names and most of their stats, we can save a lot of time by carefully making a
    copy of our main pause menu, renaming it, and then editing it to fit whatever
    submenus we need. Since we have initially saved the main pause menu as **Pause**,
    we may want to first rename it so that it is more descriptive. So head back into
    your **Content Browser**, locate where you saved your pause menu, and rename it
    by right-clicking on the pause menu widget and selecting **Rename**. Rename this
    file as **Pause_Main**:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在子菜单中需要许多相同的物品，如角色名称和大部分统计数据，我们可以通过仔细复制我们的主暂停菜单、重命名它，然后编辑以适应我们需要的任何子菜单来节省大量时间。由于我们最初将主暂停菜单保存为**Pause**，我们可能想要首先将其重命名，使其更具描述性。因此，返回到您的**内容浏览器**，找到您保存暂停菜单的位置，通过右键单击暂停菜单小部件并选择**重命名**来重命名它。将此文件重命名为**Pause_Main**：
- en: '![The UMG inventory submenu](img/B04548_04_46.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_46.jpg)'
- en: 'Next, make a duplicate of **Pause_Main** by right clicking on the file and
    selecting **Duplicate**:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过右键单击文件并选择**复制**来复制**Pause_Main**：
- en: '![The UMG inventory submenu](img/B04548_04_47.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_47.jpg)'
- en: 'Rename this as **Pause_Inventory**:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将其重命名为**Pause_Inventory**：
- en: '![The UMG inventory submenu](img/B04548_04_48.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_48.jpg)'
- en: 'We will now be able to design an **Inventory** screen. Open up your newly created
    **Pause_Inventory** Widget Blueprint. You will notice that it is an exact duplicate
    of **Pause_Main**. From here, we can edit out what is not needed. First of all,
    we are not planning to have any items that affect XP, so we can remove XP Text
    Blocks from our characters:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将能够设计一个**库存**屏幕。打开您新创建的**Pause_Inventory** Widget Blueprint。您会注意到它是对**Pause_Main**的精确复制。从这里，我们可以编辑掉不需要的内容。首先，我们计划不包含任何影响经验值的物品，因此我们可以从角色中移除经验值文本块：
- en: '![The UMG inventory submenu](img/B04548_04_49.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_49.jpg)'
- en: Also, we will not need to keep a track of gold in our **Inventory** screen either.
    So, we can remove gold.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们也不需要在**库存**屏幕中跟踪金币。因此，我们可以移除金币。
- en: 'For ease of creation, we will also make the navigation around the main pause
    screen and its submenus "old school", by using **Pause_Main** as a central hub
    to all submenus, such as **Pause_Inventory** and **Pause_Equipment**, and only
    allowing the player to enter the **Equipment** screen if they are backed out to
    **Pause_Main** and they press the **Equipment** button from there. Based on the
    idea behind this design, we may also remove the **Inventory** and **Equipment**
    buttons from this screen:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于创建，我们还将通过使用**Pause_Main**作为所有子菜单（如**Pause_Inventory**和**Pause_Equipment**）的中心枢纽，并将导航设置为“老式”方式，只允许玩家在退回到**Pause_Main**并从那里按下**装备**按钮时进入**装备**屏幕。基于这种设计背后的想法，我们可能还会从该屏幕中移除**库存**和**装备**按钮：
- en: '![The UMG inventory submenu](img/B04548_04_51.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_51.jpg)'
- en: 'We can, however, keep the **Exit** button, but based on our ideas behind the
    screen navigation, we should rename this button and its Text Block to reflect
    backing out of the screen and going to **Pause_Main** when pressed. So we can
    select **Button_Exit** and rename it as **Button_Back**:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以保留**退出**按钮，但根据我们屏幕导航背后的想法，我们应该将此按钮及其文本块重命名为反映按下时退出屏幕并进入**Pause_Main**。因此，我们可以选择**Button_Exit**并将其重命名为**Button_Back**：
- en: '![The UMG inventory submenu](img/B04548_04_52.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_52.jpg)'
- en: 'Then, select the Text Block within the **Exit** button, rename it as **Menu_Back**,
    and change the text to **Back**:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择**退出**按钮内的文本块，将其重命名为**Menu_Back**，并将文本更改为**返回**：
- en: '![The UMG inventory submenu](img/B04548_04_53.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_53.jpg)'
- en: In the previous chapter, we defined more stats than just HP and MP; we also
    defined attack power, defense, and luck. While health and magic potions don't
    typically affect any stats other than HP or MP, you may later on want to create
    items that are usable and effect things such as luck, defense, or attack power.
    In preparation of this, we will create placeholders for these three other stats
    for each character in the same way you created the HP and MP Text Blocks. We will
    be positioning these stats below the HP and MP stats. Note that, if you run out
    of room for these stats, you may need to play around with spacing. Also, remember
    to name all Text Blocks you make with something very descriptive so that you can
    identify them when the time comes to reference them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们定义的统计数据不仅仅是HP和MP；我们还定义了攻击力、防御力和幸运。虽然健康和魔法药水通常不会影响除了HP或MP之外的任何统计数据，但你可能稍后想要创建一些可使用并影响幸运、防御力或攻击力的物品。为此，我们将以创建HP和MP文本块相同的方式为每个角色创建这三个其他统计数据的占位符。我们将将这些统计数据定位在HP和MP统计数据下方。请注意，如果你为这些统计数据没有足够的空间，你可能需要调整间距。此外，记得用非常描述性的名称命名你创建的所有文本块，这样你就可以在需要引用它们的时候识别它们。
- en: 'When you are finished adding stats, your Text Blocks should look something
    like the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成添加统计数据后，你的文本块应该看起来像以下截图：
- en: '![The UMG inventory submenu](img/B04548_04_54.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_54.jpg)'
- en: 'We now need a place that will populate our inventory. Since we are unsure about
    how many items the player in the game will carry, it will be safest to create
    a Scroll Box that will be populated with our inventory. We will also want to create
    a Scroll Box that is wide enough in case we have items that have very long names.
    If you designed your screen like I have, you should have plenty of room for a
    Scroll Box. To create a Scroll Box, navigate to **Palette** | **Panel** | **Scroll
    Box**:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个地方来填充我们的库存。由于我们不确定游戏中的玩家会携带多少物品，因此创建一个将填充我们库存的滚动框是最安全的。我们还想创建一个足够宽的滚动框，以防我们有一些非常长的物品名称。如果你设计的屏幕像我一样，你应该有足够的空间放置滚动框。要创建滚动框，导航到**调色板**
    | **面板** | **滚动框**：
- en: '![The UMG inventory submenu](img/B04548_04_55.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_55.jpg)'
- en: 'Then, drag it into your Canvas Panel under the **Hierarchy** tab:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其拖动到**层次**选项卡下的Canvas面板中：
- en: '![The UMG inventory submenu](img/B04548_04_56.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_56.jpg)'
- en: 'For now, rename the Scroll Box as **ScrollBox_Inventory**. Then, change the
    position so that it is placed in the middle of the screen while neatly taking
    up a wide amount space on the screen. I will change my **Position X** value to
    **700**, **Position Y** value to **200**, **Size X** value to 600, and **Size
    Y** value to **600**. When you are finished, your Scroll Box should look something
    like the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，将滚动框重命名为**ScrollBox_Inventory**。然后，调整位置使其位于屏幕中间，同时占据屏幕上的大量空间。我将我的**位置X**值更改为**700**，**位置Y**值更改为**200**，**大小X**值更改为**600**，**大小Y**值更改为**600**。完成时，你的滚动框应该看起来像以下截图：
- en: '![The UMG inventory submenu](img/B04548_04_57.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_57.jpg)'
- en: In a later chapter, we will be dynamically inserting items into the Scroll Box
    and creating logic to apply the effects of the items to each character.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将动态地将物品插入滚动框，并创建将物品效果应用于每个角色的逻辑。
- en: 'To finish off this screen, you should notify the player about which screen
    they are currently viewing. So create another Text Block and size the font to
    something large, such as 48 pixels. Pick an anchor for your Text Block that is
    at the center-top. This will make it such that your Text Block recognizes the
    0 *X* position as the middle of the screen and the *0* Y position as the top of
    the screen. So you can now put **0** as the **Position X** value and pad the **Position
    Y** value:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个屏幕，你应该通知玩家他们目前正在查看哪个屏幕。因此创建另一个文本块，并将字体大小调整为48像素。为你的文本块选择一个中心顶部的锚点。这将使得你的文本块将0
    *X*位置识别为屏幕中间，将*0* Y位置识别为屏幕顶部。因此，你现在可以将**0**作为**位置X**值，并填充**位置Y**值：
- en: '![The UMG inventory submenu](img/B04548_04_59.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_59.jpg)'
- en: 'You will notice that the inventory is not quite written at the middle of the
    screen, so adjust the **Position X** value until it is. I changed my **Position
    X** value to half of the size of the Text Block, which came out to be -135:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到库存并没有正好位于屏幕中间，因此调整**位置X**值直到它居中。我将我的**位置X**值调整为文本块大小的一半，结果是-135：
- en: '![The UMG inventory submenu](img/B04548_04_60.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![UMG库存子菜单](img/B04548_04_60.jpg)'
- en: At this point, you can save and compile your **Inventory** screen. We are done
    for now.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以保存并编译您的**库存**屏幕。我们现在就到这里。
- en: The UMG equipment submenu
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG设备子菜单
- en: The last submenu we need to design is the equipment submenu. Since our submenu
    for equipment will be very similar to the submenu for inventory, the easiest way
    to start would be to navigate back to **Content Browser**, duplicate **Pause_Inventory**,
    and rename it as **Pause_Equipment** so that **Pause_Equipment** is a direct copy
    of **Pause_Inventory**. Next, open up **Pause_Equipment**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设计的最后一个子菜单是设备子菜单。由于我们的设备子菜单将与库存子菜单非常相似，因此最简单的方法是返回到**内容浏览器**，复制**Pause_Inventory**，并将其重命名为**Pause_Equipment**，这样**Pause_Equipment**就成为了**Pause_Inventory**的直接副本。接下来，打开**Pause_Equipment**。
- en: 'We will be designing this screen in a similar way to the **Inventory** screen.
    We will still be using the Scroll Box to populate items (in this case, equipment).
    We will be mostly keeping the same stats for each character; we will continue
    utilizing the Back button that will eventually navigate back to the pause screen.
    Let us edit the differences. First, change the title of the screen from **Inventory**
    to **Equipment** and reposition it so that it is horizontally aligned to the middle
    of the screen:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与**库存**屏幕类似的方式设计这个屏幕。我们仍然会使用滚动框来填充项目（在这种情况下，是装备）。我们将主要保持每个角色的相同属性；我们将继续使用Back按钮，最终将导航回暂停屏幕。让我们编辑差异。首先，将屏幕标题从**库存**更改为**装备**，并重新定位使其水平居中屏幕：
- en: '![The UMG equipment submenu](img/B04548_04_61.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![UMG设备子菜单](img/B04548_04_61.jpg)'
- en: 'Next, we will need to edit the character stats. We may have equipment in this
    game that when equipped, will change the AP, DP, and Lk stats. However, we will
    most likely not have equipment that will have an effect on HP and MP. We also
    know that we will need weapons and armor for each character. Therefore, we can
    easily edit the text of HP and MP out with weapon and armor (which I will call
    **Weap** and **Arm** to save space). In terms of details, I will change the name
    of the **Menu_HP** text block to **Menu_Weapon** and the text of the Text Block
    to **Weap**. We will do something similar to **Menu_MP** by changing it to an
    armor slot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编辑角色属性。我们可能在这个游戏中有一些装备，当装备时，会改变AP、DP和Lk属性。然而，我们很可能不会有影响HP和MP的装备。我们还知道，我们需要为每个角色提供武器和盔甲。因此，我们可以轻松地将HP和MP的文本编辑为武器和盔甲（我将它们称为**Weap**和**Arm**以节省空间）。在细节方面，我将**Menu_HP**文本块的名称更改为**Menu_Weapon**，并将文本块的内容更改为**Weap**。我们将对**Menu_MP**做类似处理，将其更改为盔甲槽位：
- en: '![The UMG equipment submenu](img/B04548_04_62.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![UMG设备子菜单](img/B04548_04_62.jpg)'
- en: 'Follow similar naming conventions when switching out any other character''s
    HP and MP with weapon and armor placeholders. When you are finished, your screen
    should look like the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换任何其他角色的HP和MP值时，使用武器和盔甲占位符时，遵循类似的命名约定。当你完成时，你的屏幕应该看起来像下面的截图：
- en: '![The UMG equipment submenu](img/B04548_04_63.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![UMG设备子菜单](img/B04548_04_63.jpg)'
- en: 'Since our characters will be equipping weapons and armor, we will need placeholders
    for these slots. Eventually, we will allow the player to select equipment that
    they want to equip, and the equipment will appear in the appropriate weapon or
    armor slot. The type of widget that would be most appropriate is **Border**. This
    will contain a Text Block that will change when a weapon or armor is equipped.
    To do this, select **Border** from **Palette** | **Common** | **Border**. Drag
    the Border into the Canvas Panel:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的角色将装备武器和盔甲，我们需要为这些槽位提供占位符。最终，我们将允许玩家选择他们想要装备的装备，装备将出现在适当的武器或盔甲槽位中。最合适的小部件类型是**Border**。这将包含一个文本块，当装备武器或盔甲时，文本块将发生变化。为此，从**调色板**
    | **常用** | **Border**中选择**Border**。将Border拖入画布面板：
- en: '![The UMG equipment submenu](img/B04548_04_65.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![UMG设备子菜单](img/B04548_04_65.jpg)'
- en: 'Then, position the Canvas Panel so that it is in the same position as the Text
    Block that is placed to the right of the soldier''s **Menu_Weapon**. At this point,
    you may delete the Text Block that is to the right of **Menu_Weapon**. It was
    originally used as the text for HP, and we will no longer need it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调整画布面板的位置，使其与放置在士兵**Menu_Weapon**右侧的文本块相同。此时，您可以删除**Menu_Weapon**右侧的文本块。它最初用作HP的文本，我们现在不再需要它：
- en: '![The UMG equipment submenu](img/B04548_04_67.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![UMG设备子菜单](img/B04548_04_67.jpg)'
- en: 'We will still need text in the border, so drop text from **Palette** | **Common**
    | **Text** into your Border:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要在边框中添加文本，所以从**调色板** | **常用** | **文本**中拖拽文本到你的边框中：
- en: '![The UMG equipment submenu](img/B04548_04_68.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![UMG装备子菜单](img/B04548_04_68.jpg)'
- en: 'You can keep the defaults of the Text Block for now, except you will notice
    that the border did not resize and everything is still white. Navigate back to
    your Border and check **Size to Content**. Under **Appearance** | **Brush Color**,
    change the **A** value to **0**. The **A** value is alpha. When the alpha is 0,
    the color is completely transparent, and when the alpha is 1, the color is completely
    opaque; anywhere in between is only slightly transparent. We don''t really care
    about seeing the color of the block, we want it to be invisible to the player:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你可以保留文本块的默认设置，但你会注意到边框没有调整大小，一切仍然是白色。返回到你的边框，并检查**大小调整到内容**。在**外观** | **画笔颜色**下，将**A**值改为**0**。**A**值是透明度。当透明度为0时，颜色完全透明，当透明度为1时，颜色完全不透明；介于两者之间的颜色则只有轻微的透明度。我们并不关心看到块的颜色，我们希望它对玩家不可见：
- en: '![The UMG equipment submenu](img/B04548_04_69.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![UMG装备子菜单](img/B04548_04_69.jpg)'
- en: 'Lastly, change the Border name to something descriptive such as **Border_Weapon**:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将边框名称更改为描述性的名称，例如**Border_Weapon**：
- en: '![The UMG equipment submenu](img/B04548_04_70.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![UMG装备子菜单](img/B04548_04_70.jpg)'
- en: 'Navigate back to the Text Block within the border. Name the Text Block **Text_Weapon**,
    and change the font to a regular style at 32 pixels to match the rest of the Text
    Blocks:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到边框内的文本块。将文本块命名为**Text_Weapon**，并将字体改为32像素的常规样式，以匹配其他文本块：
- en: '![The UMG equipment submenu](img/B04548_04_71.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![UMG装备子菜单](img/B04548_04_71.jpg)'
- en: 'Now that you know how to design borders and Text Blocks for the soldier''s
    weapon, you can design Borders and Text Blocks for the soldier''s armor and any
    other character''s weapon and armor. When you are finished, you should have something
    that looks like the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何为士兵的武器设计边框和文本块，你还可以为士兵的盔甲以及任何其他角色的武器和盔甲设计边框和文本块。完成之后，你应该会有以下截图所示的内容：
- en: '![The UMG equipment submenu](img/B04548_04_72.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![UMG装备子菜单](img/B04548_04_72.jpg)'
- en: At this point, we are finished designing all our screens that appear when the
    player presses the pause button. The next steps will be to program the functionality
    of these screens.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了所有当玩家按下暂停按钮时出现的屏幕的设计。下一步将是编写这些屏幕的功能程序。
- en: Key binding
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按键绑定
- en: 'We are now going to bind a key to open up the pause menu, and only allow this
    to happen when the player is not in battle (in other words, the player is out
    in the field). Since we already have a **FieldPlayer** set up from the previous
    chapter, we can easily create actions within our **FieldPlayer** Blueprint class
    that will control our pause menu. To start, navigate to **Blueprints** | **Open
    Blueprint Class…** | **FieldPlayer**:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将绑定一个键来打开暂停菜单，并且只有在玩家不在战斗中（换句话说，玩家在野外）时才允许这样做。由于我们已经在上一章中设置了**FieldPlayer**，我们可以在我们的**FieldPlayer**蓝图类中轻松创建控制暂停菜单的动作。首先，导航到**蓝图**
    | **打开蓝图类…** | **FieldPlayer**：
- en: '![Key binding](img/B04548_04_73.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![按键绑定](img/B04548_04_73.jpg)'
- en: 'At this point, we are going to want to have the pause screen pop up when the
    player presses a key; in this case, we will use *P* for pause. To do this, we
    will first need to create a key event that will fire off a set of actions of our
    choice after a specific key is pressed. To start this key event, right-click on
    your Event Graph, which will open up all actions that can be associated with this
    Blueprint, and then navigate to **Input** | **KeyEvents** | **P**:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们希望在玩家按下某个键时弹出暂停屏幕；在这种情况下，我们将使用*P*键来暂停。为此，我们首先需要创建一个按键事件，在按下特定键后触发我们选择的一系列动作。要开始这个按键事件，右键点击你的事件图，这将打开所有可以与这个蓝图关联的动作，然后导航到**输入**
    | **按键事件** | **P**：
- en: '![Key binding](img/B04548_04_74.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![按键绑定](img/B04548_04_74.jpg)'
- en: 'Once done, this will create a key event for the press and release of *P*. You
    will notice that this event has pressed and released executables that work as
    they are described, an action can occur when the player presses *P* or when the
    player releases *P*. For our actions regarding the pausing of the game and the
    pop up of the pause menu, we will use the released executable, because in order
    for the released executable to be called, it would mean that the player has gone
    through the act of pressing and releasing the key. It is often the best practice
    for a player to commit to a button press just like a player commits to a move
    in Chess by letting go of a piece. Before we pop up the pause menu, let us pause
    the game by creating a call to the **Set Game Paused** function that can be found
    by right-clicking in the Event Graph and navigating to **Game** | **Set Game Paused**:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，这将创建一个针对*P*的按下和释放的关键事件。你会注意到，这个事件具有按下和释放的可执行文件，它们按描述工作，当玩家按下*P*或玩家释放*P*时可以执行动作。对于我们的暂停游戏和弹出暂停菜单的操作，我们将使用释放的可执行文件，因为只有当释放的可执行文件被调用时，这意味着玩家已经完成了按下和释放键的动作。对于玩家来说，像在棋盘上放下棋子一样按下按钮是一种常见的最佳实践。在我们弹出暂停菜单之前，让我们通过在事件图中右键单击并导航到**游戏**
    | **设置游戏暂停**来创建一个调用**设置游戏暂停**函数：
- en: '![Key binding](img/B04548_04_75.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![键绑定](img/B04548_04_75.jpg)'
- en: 'Within the **Set Game Paused** node, check **Paused** so that it is set to
    true, and link the **Released** executable of the key event **P** to the in pin
    of the **Set Game Paused**. Your game should now pause whenever the player presses
    and releases *P*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在**游戏暂停节点**中，检查**暂停**以确保它设置为true，并将关键事件**P**的**释放**可执行链接到**设置游戏暂停**的输入端口。现在，当玩家按下并释放*P*键时，你的游戏应该会暂停：
- en: '![Key binding](img/B04548_04_76.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![键绑定](img/B04548_04_76.jpg)'
- en: 'From here, we will pop up the pause menu. To do so, upon the game being paused,
    we will create the main pause screen by right-clicking on the Event Graph and
    navigating to **User Interface** | **Create Widget**. This allows us to create
    instances of any widget that we made. We can create our **Pause_Main** here by
    pressing the **Select Class** drop-down menu within **Create Widget** and selecting
    **Pause_Main**:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们将弹出暂停菜单。为此，在游戏暂停时，我们将通过在事件图上右键单击并导航到**用户界面** | **创建小部件**来创建主暂停屏幕。这允许我们创建我们制作的任何小部件的实例。我们可以在**创建小部件**中创建**Pause_Main**，方法是按**选择类**下拉菜单，然后选择**Pause_Main**：
- en: '![Key binding](img/B04548_04_78.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![键绑定](img/B04548_04_78.jpg)'
- en: 'Next, we can link the out pin of **Set Game Paused** to the in pin of the **Create
    Pause_MainWidget**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将**设置游戏暂停**的输出引脚链接到**创建Pause_MainWidget**的输入引脚：
- en: '![Key binding](img/B04548_04_79.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![键绑定](img/B04548_04_79.jpg)'
- en: 'This will make it such that after the game is paused, **Pause_Main** will be
    created. Although we are creating **Pause_Main**, this will still not pop up on
    screen until we tell it to draw on screen. To do so, we will need to create a
    call to the **Add to Viewport** function that can add any graphic to a viewport.
    To do this, left-click and drag out the **Return Value** pin from the **Create
    Pause_Main** widget node, and select **User Interface** | **Viewport** | **Add
    to Viewport**. This will create a new **Add to Viewport** node:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在游戏暂停后，将创建**Pause_Main**。尽管我们正在创建**Pause_Main**，但它仍然不会在屏幕上弹出，直到我们告诉它绘制到屏幕上。为此，我们需要创建一个调用**添加到视口**函数的调用，该函数可以将任何图形添加到视口中。为此，在**创建Pause_Main**小部件节点上左键单击并拖出**返回值**引脚，然后选择**用户界面**
    | **视口** | **添加到视口**。这将创建一个新的**添加到视口**节点：
- en: '![Key binding](img/B04548_04_80.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![键绑定](img/B04548_04_80.jpg)'
- en: 'If you test this, you will notice that the game pauses and the pause menu pops
    up, but it is missing a mouse cursor. To add the mouse cursor, we will first need
    to get the player controller by right-clicking on the Event Graph and navigating
    to **Game** | **Get Player Controller** | **Get Player Controller**:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你测试这个，你会注意到游戏暂停，暂停菜单弹出，但缺少鼠标光标。为了添加鼠标光标，我们首先需要通过在事件图上右键单击并导航到**游戏** | **获取玩家控制器**
    | **获取玩家控制器**来获取玩家控制器：
- en: '![Key binding](img/B04548_04_81.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![键绑定](img/B04548_04_81.jpg)'
- en: 'From here, simply left-click and drag out the **Return Value** pin from the
    **Get Player Controller** node, then select **Variables** | **Mouse Interface**
    | **Set Show Mouse Cursor**:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，只需左键单击并拖出**Get Player Controller**节点的**返回值**引脚，然后选择**变量** | **鼠标界面** | **设置显示鼠标光标**：
- en: '![Key binding](img/B04548_04_82.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![键绑定](img/B04548_04_82.jpg)'
- en: Once done, link the out pin of the **Add to Viewport** node to the in pin of
    **Set Show Mouse Cursor**. What this will do is set the **Show Mouse Cursor**
    variable (which is a Boolean) to either true or false after the pause menu has
    been displayed in the viewport. The **Set Show Mouse Cursor** variable needs to
    also get the player controller because the player controller holds the mouse input
    information.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将**添加到视图**节点的输出引脚连接到**设置显示鼠标光标**的输入引脚。这将做的是在视图中显示暂停菜单后，将**显示鼠标光标**变量（这是一个布尔值）设置为true或false。**设置显示鼠标光标**变量还需要获取玩家控制器，因为玩家控制器持有鼠标输入信息。
- en: If you playtest this now, you will notice that the mouse cursor still does not
    show up; this is because **Show Mouse Cursor** within **Set Show Mouse Cursor**
    is unchecked, meaning that **Show Mouse Cursor** is set to false, so check the
    box whenever you want to show the mouse cursor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在进行测试，你会注意到鼠标光标仍然没有显示；这是因为**设置显示鼠标光标**中的**显示鼠标光标**未勾选，这意味着**显示鼠标光标**被设置为false，所以每次你想显示鼠标光标时都要勾选复选框。
- en: 'At this point, your menu should pop up perfectly after pressing *P* and the
    mouse should be completely visible and controllable. Your level blueprint should
    now look like the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，按下*P*键后，你的菜单应该会完美弹出，鼠标应该完全可见且可控制。你的关卡蓝图现在应该看起来像以下截图：
- en: '![Key binding](img/B04548_04_84.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![键绑定](img/B04548_04_84.jpg)'
- en: You will notice that none of the buttons work in the actual menu so we cannot
    exit the pause menu or view any of the submenus. This is because we have not programmed
    any of the menu buttons yet. We will now focus on programming those buttons.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到实际菜单中的所有按钮都无法工作，因此我们无法退出暂停菜单或查看任何子菜单。这是因为我们还没有对任何菜单按钮进行编程。现在，我们将专注于编程这些按钮。
- en: Button programming
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮编程
- en: 'Now that we have completed player access to the pause menu, we will now focus
    on navigation within the main pause menu and its submenus. At this point, head
    back into your **Pause_Main** widget. Let us first create the navigation to **Pause_Inventory**.
    To do this, click on the **Inventory** button:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了玩家对暂停菜单的访问，接下来我们将专注于主暂停菜单及其子菜单内的导航。此时，返回到你的**Pause_Main**部件。让我们首先创建到**Pause_Inventory**的导航。为此，点击**库存**按钮：
- en: '![Button programming](img/B04548_04_85.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_85.jpg)'
- en: 'Navigate to **Details** | **Events** | **OnClicked** and then press the **+**
    button:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到**详情** | **事件** | **OnClicked**，然后按下**+**按钮：
- en: '![Button programming](img/B04548_04_86.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_86.jpg)'
- en: 'Clicking on the **+** button will automatically open the Event Graph of **Pause_Main**
    and also create an **OnClicked** event:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**+**按钮将自动打开**Pause_Main**的事件图，并创建一个**OnClicked**事件：
- en: '![Button programming](img/B04548_04_87.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_87.jpg)'
- en: 'The **OnClicked** event will work similar to our key bind in the previous section
    where we created something that allows us to press a key, which triggers an event
    that can then trigger a series of actions. Only this time, the **OnClicked** event
    is bound to our **Inventory** button and will only trigger when the user has left-clicked
    on the **Inventory** button. What we will want to do is, when we click on the
    **Inventory** button, have it create a **Pause_Inventory** widget that gets displayed
    on the screen. This should sound very familiar because we just did something like
    this with **Pause_Main**. So firstly, create a widget and attach it to the **OnClicked**
    event. Next, you will notice that the **Class** pin in the widget is empty so
    we need to select a class. You will be selecting **Pause_Inventory** since we
    want to create the inventory widget when the button is pressed:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**OnClicked** 事件的工作方式将与我们在上一节中创建的键绑定相似，那里我们创建了一个允许我们按下一个键的东西，这个键可以触发一个事件，进而触发一系列动作。但这次，**OnClicked**
    事件绑定到我们的**库存**按钮上，并且只有在用户左键点击了**库存**按钮时才会触发。我们想要做的是，当我们点击**库存**按钮时，创建一个**Pause_Inventory**小部件，并在屏幕上显示。这听起来非常熟悉，因为我们刚刚用**Pause_Main**做了类似的事情。所以首先，创建一个部件并将其附加到**OnClicked**事件。接下来，你会注意到部件中的**Class**引脚是空的，因此我们需要选择一个类。你会选择**Pause_Inventory**，因为我们希望在按钮被按下时创建库存小部件：'
- en: '![Button programming](img/B04548_04_89.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_89.jpg)'
- en: 'Lastly, just add this widget to the viewport so the user can see the inventory
    being displayed. In the end, your Blueprint should look like the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，只需将此部件添加到视图中，以便用户可以看到显示的库存。最终，你的蓝图应该看起来像以下截图：
- en: '![Button programming](img/B04548_04_90.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_90.jpg)'
- en: 'If you test your pause screen now, you should notice that you are able to navigate
    to your inventory screen, but you are not able to navigate back to your main pause
    screen. This is easily fixable. Simply open your **Pause_Inventory** widget, press
    the **Back** button, navigate to **Details** | **Events** | **OnClicked**, and
    then press the **+** button:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试你的暂停屏幕，你应该会注意到你可以导航到你的库存屏幕，但你不能导航回你的主暂停屏幕。这很容易修复。只需打开你的**Pause_Inventory**小部件，按下**Back**按钮，导航到**Details**
    | **Events** | **OnClicked**，然后按下**+**按钮：
- en: '![Button programming](img/B04548_04_91.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_91.jpg)'
- en: 'Just like our last button, the Event Graph will automatically open up and an
    **OnClicked** event for our button will be created; only this time, the event
    is bound to our **Back** button:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们上一个按钮一样，事件图将自动打开，并为我们的按钮创建一个**OnClicked**事件；只是这次，事件绑定到了我们的**Back**按钮上：
- en: '![Button programming](img/B04548_04_92.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_92.jpg)'
- en: From here, you will set the screen to remove itself by linking the **OnClicked**
    event to **Remove from Parent**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你将通过将**OnClicked**事件链接到**Remove from Parent**来设置屏幕移除自己。
- en: 'When you are finished creating the Blueprint for your **Back** button, it should
    look like the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成创建**Back**按钮的蓝图后，它应该看起来像下面的截图：
- en: '![Button programming](img/B04548_04_93.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_93.jpg)'
- en: You can now create the same setup for navigation from **Pause_Equipment** by
    making sure that when we click on the **Equipment** button, we create a **Pause_Equipment**
    widget and display it; when we click on the **Back** button in the **Pause_Equipment**,
    we navigate back to the **Pause_Main** removing the **Pause_Inventory** screen.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过确保当我们点击**Equipment**按钮时创建一个**Pause_Equipment**小部件并显示它；当我们点击**Pause_Equipment**中的**Back**按钮时，导航回**Pause_Main**并移除**Pause_Inventory**屏幕来为**Pause_Equipment**创建相同的导航设置。
- en: 'The next step is to allow the player to exit when they click on the **Exit**
    button. To do this, you must first create an **OnClicked** event on the **Exit**
    button within **Pause_Main**. Again, when you press the **+** button of **OnClicked**
    within the **Design** view, an **OnClicked** button for the **Exit** button will
    be created in the Event Graph:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是允许玩家在点击**Exit**按钮时退出。为此，你必须在**Pause_Main**中的**Exit**按钮上创建一个**OnClicked**事件。再次，当你按下**Design**视图中的**OnClicked**的**+**按钮时，事件图中会创建一个**Exit**按钮的**OnClicked**按钮：
- en: '![Button programming](img/B04548_04_94.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_94.jpg)'
- en: 'From here, you will set the screen to remove itself by linking the **OnClicked**
    event to **Remove from Parent**:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你将通过将**OnClicked**事件链接到**Remove from Parent**来设置屏幕移除自己：
- en: '![Button programming](img/B04548_04_95.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_95.jpg)'
- en: 'Your screens should now navigate perfectly, but we are not done yet. The last
    thing you will notice is that the game is still paused when the pause menu is
    exited. We will need to unpause the game. This fix is very simple. Within the
    **Pause_Main** Blueprint, simply link **Set Game Paused** to **Remove from Parent**
    so that when the widget is removed, the game unpauses:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你的屏幕现在应该可以完美导航，但我们还没有完成。你最后会注意到，当退出暂停菜单时，游戏仍然是暂停状态。我们需要取消暂停游戏。这个修复非常简单。在**Pause_Main**蓝图内部，只需将**Set
    Game Paused**链接到**Remove from Parent**，这样当小部件被移除时，游戏就会取消暂停：
- en: '![Button programming](img/B04548_04_96.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![按钮编程](img/B04548_04_96.jpg)'
- en: You may notice that when leaving the pause menu, the mouse cursor is still present.
    You can remove the mouse cursor by simply creating a **Set Show Mouse Cursor**
    node and having it connected to your **OnClicked Button_Exit** event after you
    unpause the game, which would be similar to how you added a mouse cursor in the
    first place, this time making sure the checkbox within the **Set Show Mouse Cursor**
    node is unchecked meaning that S**et Show Mouse Cursor** is set to false, and
    attaching a **Get Player Controller** to it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，当你离开暂停菜单时，鼠标光标仍然存在。你可以通过创建一个**Set Show Mouse Cursor**节点并将其连接到你在取消暂停游戏后添加的**OnClicked
    Button_Exit**事件来移除鼠标光标，这与你最初添加鼠标光标的方式类似，这次确保**Set Show Mouse Cursor**节点内的复选框未勾选，意味着**Set
    Show Mouse Cursor**被设置为false，并将其连接到一个**Get Player Controller**。
- en: There you have it. We are now finished with the navigation of our pause menu
    and its submenus.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们现在已经完成了暂停菜单及其子菜单的导航。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we completed pause menu placeholders for other important aspects
    of our game such as the **Inventory** and **Equipment** Scroll Boxes that will
    hold the inventory/equipment that we acquire in the game. We will continue to
    add to this pause menu in the next few chapters by covering the tracking of stats,
    gold, items, and equipment.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了暂停菜单的占位符，用于游戏中的其他重要方面，例如**库存**和**装备**滚动框，这些框将保存我们在游戏中获得的库存/装备。在接下来的几章中，我们将继续扩展这个暂停菜单，涵盖统计数据、金币、物品和装备的跟踪。
