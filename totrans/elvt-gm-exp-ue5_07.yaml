- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Working with UE5 Utilities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 UE5 工具一起工作
- en: In the previous chapter, we learned about the remaining collision-related concepts
    in UE5, such as collision events, object types, physics simulation, and collision
    components. We learned how to have objects collide against one another, changing
    their responses to different collision channels, as well as how to create collision
    presets, spawn actors, and use timers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 UE5 中剩余的碰撞相关概念，例如碰撞事件、对象类型、物理模拟和碰撞组件。我们学习了如何使对象相互碰撞，改变它们对不同碰撞通道的响应，以及如何创建碰撞预设、生成演员和使用计时器。
- en: In this chapter, we will look at several UE5 utilities that will allow you to
    easily move logic from one project to another and keep your project well-structured
    and organized, which will make life much easier for you in the long run and also
    make it easier for other people in your team to understand your work and modify
    it in the future. Game development is a tremendously hard task and is rarely done
    individually, but rather in teams, so it’s important to take these things into
    account when building your projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几个 UE5 工具，这些工具将允许你轻松地将逻辑从一个项目移动到另一个项目，并保持你的项目结构良好和组织有序，这将在长期内使你的生活更加轻松，并使你的团队成员更容易理解你的工作并在将来对其进行修改。游戏开发是一项极其艰巨的任务，很少是单独完成的，而是团队合作完成的，因此在构建项目时考虑这些因素非常重要。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Good practices – loose coupling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的实践 - 松耦合
- en: Blueprint Function Libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图函数库
- en: Actor components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actor 组件
- en: Exploring interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索接口
- en: Blueprint native events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图原生事件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The project for this chapter can be found in the Chapter07 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的 Chapter07 文件夹中找到，代码包可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: Good practices – loose coupling
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好的实践 - 松耦合
- en: We can use Blueprint Function Libraries to move some generic functions in our
    project from a specific actor to a Blueprint Function Library so that they can
    be used in other parts of our project’s logic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用蓝图函数库将我们项目中的一些通用函数从特定的演员移动到蓝图函数库，以便它们可以在项目的其他部分逻辑中使用。
- en: We will use Actor components to move part of some actor classes’ source code
    into an Actor component so that we can easily use that logic in other projects.
    This will keep our project loosely coupled. Loose coupling is a software engineering
    concept that refers to having your project structured in such a way that you can
    easily remove and add things as you need. The reason you should strive for loose
    coupling is if you want to reuse parts of one of your projects for another project.
    As a game developer, loose coupling will allow you to do that much more easily.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Actor 组件将一些演员类源代码的一部分移动到 Actor 组件中，这样我们就可以轻松地在其他项目中使用该逻辑。这将使我们的项目保持松耦合。松耦合是软件工程概念，指的是以这种方式构建项目，即你可以根据需要轻松地删除和添加东西。你应该努力追求松耦合的原因是，如果你想将你项目的一部分用于另一个项目。作为一名游戏开发者，松耦合将使你更容易做到这一点。
- en: A practical example of how you could apply loose coupling is if you had a player
    character class that was able to fly and also had an inventory that contained
    several usable items. Instead of implementing the code responsible for both of
    those things in that player character class, you would implement the logic for
    each of them in separate Actor components, which you would then add to the class.
    This will not only make it easier to add and remove things that this class will
    do, by simply adding and removing the Actor components responsible for those things,
    but also allow you to reuse those Actor components in other projects where you
    have a character that has an inventory or can fly. This is one of the main purposes
    of Actor components.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用松耦合的实际例子是，如果你有一个玩家角色类，它能够飞行并且有一个包含几个可用物品的库存。你不需要在那个玩家角色类中实现这两个功能的代码，而是将每个功能的逻辑分别实现为独立的
    Actor 组件，然后将这些组件添加到类中。这样不仅可以通过简单地添加和删除负责这些功能的 Actor 组件来更容易地添加和删除这个类将执行的事情，还可以让你在其他项目中重用这些
    Actor 组件，其中你可能有一个拥有库存或能够飞行的角色。这是 Actor 组件的主要目的之一。
- en: Interfaces, much like Actor components, make our project better structured and
    organized.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接口，就像演员组件一样，使我们的项目结构更好，组织更有序。
- en: Let’s start by talking about Blueprint Function Libraries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来谈谈蓝图函数库。
- en: Blueprint Function Libraries
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图函数库
- en: In UE5, there’s a class called `BlueprintFunctionLibary` that is meant to contain
    a collection of static functions that don’t belong to any specific actor and can
    be used in multiple parts of your project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE5中，有一个名为`BlueprintFunctionLibary`的类，旨在包含一组不属于任何特定演员的静态函数，这些函数可以在项目的多个部分中使用。
- en: For instance, some of the objects that we used previously, such as the `GameplayStatics`
    object and `Kismet` libraries such as `KismetMathLibrary` and `KismetSystemLibrary`,
    are Blueprint Function Libraries. These contain functions that can be used in
    any part of your project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们之前使用的一些对象，例如`GameplayStatics`对象和`Kismet`库，如`KismetMathLibrary`和`KismetSystemLibrary`，都是蓝图函数库。这些库包含可以在项目的任何部分使用的函数。
- en: 'There is at least one function in our project that’s been created by us that
    can be moved to a Blueprint Function Library: the `CanSeeActor` function defined
    in the `EnemyCharacter` class.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，至少有一个我们创建的函数可以被移动到蓝图函数库：在`EnemyCharacter`类中定义的`CanSeeActor`函数。
- en: In the first exercise of this chapter, we will create a Blueprint Function Library
    so that we can move the `CanSeeActor` function from the `EnemyCharacter` class
    to the `BlueprintFunctionLibrary` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个练习中，我们将创建一个蓝图函数库，以便我们可以将`CanSeeActor`函数从`EnemyCharacter`类移动到`BlueprintFunctionLibrary`类。
- en: Exercise 7.01 – moving the CanSeeActor function to the Blueprint Function Library
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.01 – 将`CanSeeActor`函数移动到蓝图函数库
- en: In this exercise, we will be moving the `CanSeeActor` function that we created
    for the `EnemyCharacter` class to a Blueprint Function Library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将把为`EnemyCharacter`类创建的`CanSeeActor`函数移动到蓝图函数库。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Open Unreal Editor.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Unreal编辑器。
- en: '*Right-click* inside the **Content Browser** area and select **New C++ Class**.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**区域内*右键单击*并选择**新建C++类**。
- en: Choose **BlueprintFunctionLibrary** as the parent class of this C++ class (you’ll
    find it by scrolling to the end of the panel).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**BlueprintFunctionLibrary**作为此C++类的父类（您可以通过滚动到面板底部找到它）。
- en: Name the new C++ class `DodgeballFunctionLibrary`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的C++类命名为`DodgeballFunctionLibrary`。
- en: After the class’s files have been generated in Visual Studio, open them and
    close the editor.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中生成类的文件后，打开它们并关闭编辑器。
- en: In the header file of `DodgeballFunctionLibrary`, add a declaration for a `public`
    function called `CanSeeActor`. This function will be similar to the one we created
    in the `EnemyCharacter` class; however, there will be some differences.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DodgeballFunctionLibrary`的头文件中，添加一个名为`public`的函数声明`CanSeeActor`。此函数将与我们在`EnemyCharacter`类中创建的函数类似；然而，将有一些差异。
- en: 'The new `CanSeeActor` function will be `static`, will return a `bool`, and
    will receive the following parameters:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`CanSeeActor`函数将是`static`的，将返回`bool`类型，并将接收以下参数：
- en: A `const UWorld* World` property, which we will use to access the `Line Trace`
    functions.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`const UWorld* World`属性，我们将用它来访问`Line Trace`函数。
- en: An `FVector Location` property, which we will use as the location of the actor
    that is checking whether it can see the target actor.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`FVector Location`属性，我们将用它作为检查是否可以看到目标演员的演员的位置。
- en: A `const AActor* TargetActor` property, which will be the actor we’re checking
    visibility for.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`const AActor* TargetActor`属性，它将是我们要检查可见性的演员。
- en: 'A `TArray<const AActor*> IgnoreActors` property, which will specify the actors
    that should be ignored during the `Line Trace` functions. This property can have
    an empty array as a default argument:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`TArray<const AActor*> IgnoreActors`属性，它将指定在`Line Trace`函数期间应忽略的演员。此属性可以有一个空数组作为默认参数：
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the implementation of this function in the class’s source file and copy
    the implementation of the `EnemyCharacter` class’s version into this new class.
    Once you’ve done that, make the following modifications to the implementation:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中创建此函数的实现，并将`EnemyCharacter`类版本的实现复制到这个新类中。完成这些后，对实现进行以下修改：
- en: 'Change the value of the `Start` location of the `Line Trace` to the `Location`
    parameter:'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Line Trace`的`Start`位置值更改为`Location`参数：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead of ignoring this actor (using the `this` pointer) and `TargetActor`,
    ignore the entire `IgnoreActors` array using the `AddIgnoredActors` function of
    `FCollisionQueryParams` and send that array as a parameter:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是忽略这个角色（使用 `this` 指针）和 `TargetActor`，使用 `FCollisionQueryParams` 的 `AddIgnoredActors`
    函数忽略整个 `IgnoreActors` 数组，并将该数组作为参数发送：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Replace both calls to the `GetWorld` function with the received `World` parameter:'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对 `GetWorld` 函数的两个调用都替换为接收到的 `World` 参数：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the necessary includes to the top of the `DodgeballFunctionLibrary` class,
    as shown in the following code snippet:'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `DodgeballFunctionLibrary` 类的顶部添加必要的包含，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you’ve created the new version of the `CanSeeActor` function inside `DodgeballFunctionLibrary`,
    head to our `EnemyCharacter` class and make the following changes:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你在 `DodgeballFunctionLibrary` 中创建了 `CanSeeActor` 函数的新版本，转到我们的 `EnemyCharacter`
    类并做出以下更改：
- en: Remove the declaration and implementation of the `CanSeeActor` function, inside
    its header and source file, respectively.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除 `CanSeeActor` 函数的声明和实现，分别在头文件和源文件中。
- en: 'Remove the `DrawDebugHelpers` include, given that we will no longer need that
    file:'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们不再需要那个文件，删除 `DrawDebugHelpers` 包含：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add an include for `DodgeballFunctionLibrary`:'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对 `DodgeballFunctionLibrary` 的包含：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside the class’s `LookAtActor` function, just before the `if` statement that
    calls the `CanSeeActor` function, declare a `const TArray<const AActor*> IgnoreActors`
    variable and set it to both the `this` pointer and the `TargetActor` parameter:'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类的 `LookAtActor` 函数中，在调用 `CanSeeActor` 函数的 `if` 语句之前，声明一个 `const TArray<const
    AActor*> IgnoreActors` 变量，并将其设置为 `this` 指针和 `TargetActor` 参数：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Introducing the preceding code snippet may give you an IntelliSense error in
    Visual Studio. You can safely ignore it, as your code should compile with no issues
    regardless.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中引入前面的代码片段可能会给你一个 IntelliSense 错误。你可以安全地忽略它，因为你的代码应该没有问题地编译。
- en: 'Replace the existing call to the `CanSeeActor` function with the one we just
    created by sending the following as parameters:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的对 `CanSeeActor` 函数的调用替换为我们刚刚创建的函数，通过发送以下参数：
- en: The current world, through the `GetWorld` function
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前世界，通过 `GetWorld` 函数
- en: The `SightSource` component’s location, using its `GetComponentLocation` function
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SightSource` 组件的位置，通过其 `GetComponentLocation` 函数
- en: The `TargetActor` parameter
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TargetActor` 参数'
- en: 'The `IgnoreActors` array we just created:'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们刚刚创建的 `IgnoreActors` 数组：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that you’ve made all those changes, compile your code, open your project,
    and verify that the `EnemyCharacter` class still looks at the player as it walks
    around, so long as it’s in the enemy character’s sight, as shown in the following
    screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经做了所有这些更改，编译你的代码，打开你的项目，并验证 `EnemyCharacter` 类在四处走动时仍然看着玩家，只要它在敌对角色的视野内，如以下截图所示：
- en: '![Figure 7.1 – The enemy character still looking at the player character ](img/Figure_7.01_B18531.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 敌对角色仍然在看着玩家角色](img/Figure_7.01_B18531.jpg)'
- en: Figure 7.1 – The enemy character still looking at the player character
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 敌对角色仍然在看着玩家角色
- en: And that concludes our exercise. We’ve put our `CanSeeActor` function inside
    a Blueprint Function Library and can now reuse it for other actors that require
    the same type of functionality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就结束了我们的练习。我们将 `CanSeeActor` 函数放在了蓝图函数库中，现在可以将其用于需要相同类型功能的其他角色。
- en: The next step in our project is going to be learning more about Actor components
    and how we can use them to our advantage. Let’s take a look.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '我们项目的下一步将是学习更多关于角色组件以及我们如何利用它们的知识。让我们看看。 '
- en: Actor components
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色组件
- en: As we saw in the first few chapters of this book, Actors are the main way to
    create logic in UE5\. However, we’ve also seen that Actors can contain several
    Actor components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的前几章中看到的，角色是创建 UE5 中逻辑的主要方式。然而，我们也看到角色可以包含多个角色组件。
- en: Actor components are objects that can be added to an Actor and can have multiple
    types of functionality, such as being responsible for a character’s inventory
    or making a character fly. Actor components must always belong to and live inside
    an Actor, which is referred to as their **Owner**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 角色组件是对象，可以添加到角色中，并且可以具有多种类型的功能，例如负责角色的库存或使角色飞行。角色组件必须始终属于并存在于一个角色中，这被称为它们的 **所有者**。
- en: 'There are several different types of existing Actor components. Some of these
    are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同类型的现有角色组件。以下是一些例子：
- en: Code-only Actor components, which act as their own class inside an actor. They
    have their own properties and functions and can both interact with the Actor they
    belong to and be interacted with by it.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅代码的Actor组件，它们在actor内部充当自己的类。它们有自己的属性和函数，可以与其所属的Actor交互，也可以被Actor交互。
- en: Mesh components, which are used to draw several types of Mesh objects (Static
    Meshes, Skeletal Meshes, and so on).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格组件，用于绘制多种类型的网格对象（静态网格、骨骼网格等）。
- en: Collision components, which are used to receive and generate collision events.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞组件，用于接收和生成碰撞事件。
- en: Camera components.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像机组件。
- en: 'This leaves us with two main ways to add logic to our Actors: directly in the
    `Actor` class or through `Actor` components. To follow good software development
    practices, namely loose coupling (mentioned previously), you should strive to
    use Actor components instead of placing logic directly inside an Actor whenever
    possible. Let’s take a look at a practical example to understand the usefulness
    of Actor components.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们有了两种向我们的Actor添加逻辑的主要方法：直接在`Actor`类中或通过`Actor`组件。为了遵循良好的软件开发实践，即松耦合（如前所述），你应该尽可能使用Actor组件，而不是将逻辑直接放在Actor中。让我们通过一个实际例子来看看Actor组件的有用性。
- en: 'Let’s say you’re making a game where you have the player character and enemy
    characters, both of which have health, and where the player character must fight
    enemies, who can also fight back. If you had to implement the health logic, which
    includes gaining health, losing health, and tracking the character’s health, you’d
    have two options:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在制作一个游戏，其中包含玩家角色和敌人角色，它们都有健康值，玩家角色必须与敌人战斗，敌人也可以反击。如果你必须实现健康逻辑，包括获得健康、失去健康和跟踪角色的健康，你有两个选择：
- en: You can implement the health logic in a base character class, from which both
    the player character class and the enemy character class would inherit.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在基础角色类中实现健康逻辑，该类既是玩家角色类也是敌人角色类的继承者。
- en: You can implement the health logic in an Actor component and add that component
    to both the player character and enemy character classes separately.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Actor组件中实现健康逻辑，并将该组件分别添加到玩家角色和敌人角色类中。
- en: 'There are a few reasons why the first option is not a good option, but the
    main one is this: if you wanted to add another piece of logic to both character
    classes (for example, stamina, which would limit the strength and frequency of
    the characters’ attacks), doing so using the same approach of a base class wouldn’t
    be a viable option. Given that, in UE5, C++ classes can only inherit from one
    class and there’s no such thing as multiple inheritance, that would be very hard
    to manage. It would also only get more complicated and unmanageable the more logic
    you decided to add to your project.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因说明第一个选项不是好的选择，但主要原因是这个：如果你想在两个角色类（例如，耐力，这将限制角色的攻击强度和频率）中添加另一段逻辑，使用基类的方法就不会是一个可行的选择。鉴于在UE5中，C++类只能从一个类继承，并且没有多重继承这样的东西，这将非常难以管理。随着你决定向你的项目中添加更多逻辑，这也会变得更加复杂和难以管理。
- en: With that said, when adding logic to your project that can be encapsulated in
    a separate component, allowing you to achieve loose coupling, you should always
    do so.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，当你在项目中添加可以封装在单独组件中的逻辑时，允许你实现松耦合（如前所述），你应该始终这样做。
- en: Now, let’s create a new Actor component that will be responsible for keeping
    track of an actor’s health, as well as gaining and losing that health.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的Actor组件，该组件将负责跟踪演员的健康状况，以及获得和失去健康。
- en: Exercise 7.02 – creating the HealthComponent Actor component
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.02 – 创建HealthComponent Actor组件
- en: In this exercise, we will be creating a new actor component responsible for
    gaining, losing, and keeping track of an actor’s health (its Owner).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的演员组件，该组件负责获得、失去和跟踪演员的健康（其所有者）。
- en: For the player to lose, we’ll have to make the player character lose health
    and then end the game when it runs out of health. We’ll want to put this logic
    inside an actor component so that we can easily add all this health-related logic
    to other actors if we need to.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家失去健康，我们必须让玩家角色失去健康，并在健康耗尽时结束游戏。我们希望将此逻辑放在actor组件中，这样我们就可以轻松地将所有这些与健康相关的逻辑添加到其他actor中，如果需要的话。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成练习：
- en: Open the editor and create a new C++ class, whose parent class will be the `ActorComponent`
    class. Its name will be `HealthComponent`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器并创建一个新的 C++ 类，其父类将是 `ActorComponent` 类。它的名字将是 `HealthComponent`。
- en: 'Once this class has been created and its files have been opened in Visual Studio,
    go to its header file and add a protected `float` property called `Health`, which
    will keep track of the Owner’s current health points. Its default value can be
    set to the number of health points its Owner will start the game with. In this
    case, we’ll initialize it with a value of `100` health points:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了此类并且其文件已在 Visual Studio 中打开，转到其头文件并添加一个受保护的 `float` 属性名为 `Health`，它将跟踪所有者的当前健康点数。其默认值可以设置为所有者开始游戏时的健康点数。在这种情况下，我们将将其初始化为
    `100` 健康点数：
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a declaration for the function that’s responsible for taking health
    away from its Owner. This function should be `public`; return nothing; receive
    a `float Amount` property as input, which indicates how many health points its
    Owner should lose; and be called `LoseHealth`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为负责从其所有者那里移除健康的函数创建一个声明。这个函数应该是 `public` 的；不返回任何内容；接收一个 `float Amount` 属性作为输入，该属性表示所有者应该失去多少健康点数；并且被命名为
    `LoseHealth`：
- en: '[PRE10]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, in the class’s source file, let’s start by notifying it that it should
    never use the `Tick` event so that its performance can be slightly improved.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在类的源文件中，让我们首先通知它它永远不应该使用 `Tick` 事件，这样它的性能可以略有提高。
- en: 'Change the `bCanEverTick` property’s value to `false` inside the class’s constructor:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的构造函数中将 `bCanEverTick` 属性的值更改为 `false`：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the implementation for our `LoseHealth` function, where we’ll start
    by removing the `Amount` parameter’s value from our `Health` property:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的 `LoseHealth` 函数创建实现，我们将首先从我们的 `Health` 属性中移除 `Amount` 参数的值：
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, in that same function, we’ll check whether the current amount of health
    is less than or equal to `0`, which means that it has run out of health points
    (*has died or been destroyed*):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在同一个函数中，我们将检查当前的健康量是否小于或等于 `0`，这意味着它已经耗尽健康点数（*已死亡或被摧毁*）：
- en: '[PRE13]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the `if` statement is true, we’ll do the following things:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `if` 语句为真，我们将执行以下操作：
- en: 'Set the `Health` property to `0` to make sure that our Owner doesn’t have negative
    health points:'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Health` 属性设置为 `0` 以确保我们的所有者没有负健康点数：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Quit the game, the same way we did in [*Chapter 6*](B18531_06.xhtml#_idTextAnchor134),
    *Setting Up* *Collision Objects*, when creating the `VictoryBox` class:'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与我们在 [*第 6 章*](B18531_06.xhtml#_idTextAnchor134) *设置碰撞对象* 中创建 `VictoryBox` 类时一样退出游戏：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Don’t forget to include the `KismetSystemLibrary` object:'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记包含 `KismetSystemLibrary` 对象：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this logic done, whenever any actor that has `HealthComponent` runs out
    of health, the game will end. This isn’t exactly the behavior we want in our **Dodgeball**
    game. However, we’ll change it when we talk about interfaces later in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个逻辑后，每当任何具有 `HealthComponent` 的演员耗尽健康时，游戏将结束。这并不是我们想要的 **躲避球** 游戏中的行为。然而，当我们在本章后面讨论接口时，我们会将其更改。
- en: In the next exercise, we’ll be making the necessary modifications to some classes
    in our project to accommodate our newly created `HealthComponent`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将对项目中的某些类进行必要的修改，以适应我们新创建的 `HealthComponent`。
- en: Exercise 7.03 – integrating the HealthComponent Actor component
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.03 – 集成 HealthComponent Actor 组件
- en: In this exercise, we will be modifying our `DodgeballProjectile` class so that
    it damages the player’s character when it comes into contact with it, as well
    as the `DodgeballCharacter` class so that it has a `HealthComponent`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将修改我们的 `DodgeballProjectile` 类，使其在与玩家角色接触时对其造成伤害，以及修改 `DodgeballCharacter`
    类，使其具有 `HealthComponent`。
- en: 'Open the `DodgeballProjectile` class’s files in Visual Studio and make the
    following modifications:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开 `DodgeballProjectile` 类的文件并做出以下修改：
- en: 'In the class’s header file, add a protected `float` property called `Damage`
    and set its default value to `34` so that our player character will lose all of
    its health points after being hit three times. This property should be a `UPROPERTY`
    and have the `EditAnywhere` tag so that you can easily change its value in its
    Blueprint class:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的头文件中，添加一个受保护的 `float` 属性名为 `Damage`，并将其默认值设置为 `34`，这样我们的玩家角色在被击中三次后就会失去所有的健康点数。这个属性应该是一个
    `UPROPERTY`，并带有 `EditAnywhere` 标签，这样你就可以轻松地在它的蓝图类中更改其值：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the class’s source file, we’ll have to make some modifications to the `OnHit`
    function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的源文件中，我们需要对 `OnHit` 函数进行一些修改。
- en: 'Since we’ll be using the `HealthComponent` class, we’ll have to add the `include`
    statement for it:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用`HealthComponent`类，因此我们必须为它添加`include`语句：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The existing cast that is being done for `DodgeballCharacter` from the `OtherActor`
    property, which we did in *s**tep 17* of *Exercise 6.01 – creating the Dodgeball
    class*, and is inside the `if` statement, should be done before that `if` statement
    and be saved inside a variable. Then, you should check whether that variable is
    `nullptr`. We are doing this to access the player character’s `HealthComponent`
    inside the `if` statement:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`语句中，我们对`DodgeballCharacter`从`OtherActor`属性进行的现有转换，我们在*步骤17*的*练习6.01 – 创建躲避球类*中执行，应该在该`if`语句之前执行，并将其保存到变量中。然后，你应该检查该变量是否为`nullptr`。我们这样做是为了在`if`语句中访问玩家角色的`HealthComponent`：
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the `if` statement is true (that is, if the actor we hit is the player’s
    character), we want to access that character’s `HealthComponent` and reduce the
    character’s health. To access `HealthComponent`, we must call the character’s
    `FindComponentByClass` function and send the `UHealthComponent` class as a template
    parameter (to indicate the class of the component we want to access):'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`if`语句为真（即，如果我们击中的是玩家的角色），我们想要访问该角色的`HealthComponent`并减少角色的健康值。要访问`HealthComponent`，我们必须调用角色的`FindComponentByClass`函数，并传递`UHealthComponent`类作为模板参数（以指示我们想要访问的组件的类）：
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `FindComponentByClass` function, included in the `Actor` class, will return
    a reference(s) to the actor component(s) of a specific class that the actor contains.
    If the function returns `nullptr`, that means the actor doesn’t have an Actor
    component of that class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在`Actor`类中的`FindComponentByClass`函数将返回对演员包含的特定类演员组件的引用（s）。如果函数返回`nullptr`，则表示演员没有该类的`Actor`组件。
- en: You may also find the `GetComponents` function inside the `Actor` class useful,
    which will return a list of all the Actor components inside that actor.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能在`Actor`类中找到有用的`GetComponents`函数，该函数将返回该演员中所有`Actor`组件的列表。
- en: 'After that, check whether `HealthComponent` is `nullptr`. If it isn’t, we’ll
    call its `LoseHealth` function and send the `Damage` property as a parameter:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，检查`HealthComponent`是否为`nullptr`。如果不是，我们将调用它的`LoseHealth`函数，并将`Damage`属性作为参数传递：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Make sure the existing `Destroy` function is called after doing the null check
    for `HealthComponent`, as shown in the previous code snippet.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在执行`HealthComponent`的空检查之后调用现有的`Destroy`函数，如前一个代码片段所示。
- en: Before we finish this exercise, we’ll need to make some modifications to our
    `DodgeballCharacter` class. Open the class’s files in Visual Studio.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这个练习之前，我们需要对我们的`DodgeballCharacter`类进行一些修改。在Visual Studio中打开类的文件。
- en: 'In the class’s header file, add a `private` property of the `class UhealthComponent*`
    type called `HealthComponent`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的头文件中，添加一个名为`HealthComponent`的`private`属性，类型为`UhealthComponent*`：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the class’s source file, add an `include` statement to the `HealthComponent`
    class:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中，向`HealthComponent`类添加一个`include`语句：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At the end of the class’s constructor, create `HealthComponent` by using the
    `CreateDefaultSubobject` function and name it `HealthComponent`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的构造函数末尾，使用`CreateDefaultSubobject`函数创建`HealthComponent`并将其命名为`HealthComponent`：
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once you’ve made all these changes, compile your code and open the editor.
    When you play the game, if you let your player character get hit by a dodgeball
    three times, you’ll notice that the game abruptly stops, as intended:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成所有这些更改，编译你的代码并打开编辑器。当你玩游戏时，如果你让你的玩家角色被躲避球击中三次，你会注意到游戏会突然停止，正如预期的那样：
- en: '![Figure 7.2 – The enemy character throwing dodgeballs at the player character
    ](img/Figure_7.02_B18531.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 敌对角色向玩家角色投掷躲避球](img/Figure_7.02_B18531.jpg)'
- en: Figure 7.2 – The enemy character throwing dodgeballs at the player character
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 敌对角色向玩家角色投掷躲避球
- en: 'Once the game is stopped, it will look as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦游戏停止，它将看起来如下所示：
- en: '![Figure 7.3 – The editor after the player character runs out of health points
    and the game stops ](img/Figure_7.03_B18531.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 玩家角色健康值耗尽且游戏停止后的编辑器](img/Figure_7.03_B18531.jpg)'
- en: Figure 7.3 – The editor after the player character runs out of health points
    and the game stops
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 玩家角色健康值耗尽且游戏停止后的编辑器
- en: And that completes this exercise. You now know how to create Actor components
    and how to access an actor’s Actor components. This is a very important step toward
    making your game projects more understandable and better structured, so good job.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了这个练习。你现在知道如何创建角色组件以及如何访问角色的角色组件。这是使你的游戏项目更易于理解和结构化的一个非常重要的步骤，所以做得很好。
- en: 'Now that we’ve learned about Actor components, let’s learn about another way
    to make our projects better structured and organized: by using interfaces.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了角色组件，让我们学习另一种使我们的项目更有结构和组织的方式：通过使用接口。
- en: Exploring interfaces
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索接口
- en: There’s a chance that you may already know about interfaces, given that other
    programming languages, such as Java, already have them. If you do, they work pretty
    similarly in UE5, but if you don’t, let’s see how they work, taking the example
    of the `HealthComponent` class we created.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其他编程语言，如 Java，已经存在接口，所以你可能已经了解接口。如果你了解，它们在 UE5 中的工作方式非常相似，但如果你不了解，让我们以我们创建的
    `HealthComponent` 类为例，看看它们是如何工作的。
- en: 'As you saw in the previous exercise, when the `Health` property of the `HealthComponent`
    class reaches `0`, that component will simply end the game. However, we don’t
    want that to happen every time an actor’s health points run out: some actors may
    simply be destroyed, some may notify another actor that they have run out of health
    points, and so on. We want each actor to be able to determine what happens to
    them when they run out of health points. But how can we handle this?'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在之前的练习中看到的，当 `HealthComponent` 类的 `Health` 属性达到 `0` 时，该组件将简单地结束游戏。然而，我们不想每次一个角色的健康点耗尽时都发生这种情况：一些角色可能只是被销毁，一些可能通知另一个角色它们已经耗尽健康点，等等。我们希望每个角色都能确定它们健康点耗尽时会发生什么。但我们应该如何处理这个问题呢？
- en: Ideally, we would simply call a specific function that belongs to Owner of the
    `HealthComponent` class, which would then choose how to handle the fact that Owner
    has run out of health points. But in which class should you implement that function,
    given that our Owner can be of any class, so long as it inherits from the Actor
    class? As we discussed at the beginning of this chapter, having a class that’s
    responsible just for this would quickly become unmanageable. Luckily for us, interfaces
    solve this problem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们会调用属于 `HealthComponent` 类所有者的特定函数，然后该所有者将决定如何处理所有者健康点耗尽的事实。但考虑到我们的所有者可以是任何类，只要它继承自
    `Actor` 类，那么你应该在哪个类中实现这个函数呢？正如我们在本章开头讨论的那样，拥有只负责这一功能的类会很快变得难以管理。幸运的是，接口解决了这个问题。
- en: Interfaces are classes that contain a collection of functions that an object
    must have if it implements that interface. It essentially works as a contract
    that the object signs, saying that it will implement all the functions present
    on that interface. Then, you can simply check whether an object implements a specific
    interface and call the object’s implementation of the function defined in the
    interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是包含了一组函数的类，如果一个对象实现了该接口，那么它必须拥有这些函数。这本质上是一个对象签订的合同，表明它将实现该接口上所有存在的函数。然后，你可以简单地检查一个对象是否实现了特定的接口，并调用该对象在接口中定义的函数实现。
- en: 'In our specific case, we’ll want to have an interface that has a function that
    will be called when an object runs out of health points so that our `HealthComponent`
    class can check whether its Owner implements that interface and then call that
    function from the interface. This will make it easy for us to specify how each
    actor behaves when running out of health points: some actors may simply be destroyed,
    others may trigger an in-game event, and others may simply end the game (which
    is the case with our player character).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定情况下，我们希望有一个接口，其中包含一个当对象健康点耗尽时将被调用的函数，这样我们的 `HealthComponent` 类就可以检查其所有者是否实现了该接口，然后从接口中调用该函数。这将使我们能够轻松指定每个角色在健康点耗尽时的行为：一些角色可能只是被销毁，其他可能触发一个游戏内事件，还有一些可能只是结束游戏（这是我们的玩家角色的案例）。
- en: However, before we create our first interface, we should talk a bit about Blueprint
    native events.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们创建第一个接口之前，我们应该稍微谈谈蓝图原生事件。
- en: Blueprint native events
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图原生事件
- en: When using the `UFUNCTION` macro in C++, you can turn a function into a Blueprint
    native event by simply adding the `BlueprintNativeEvent` tag to that macro.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 C++ 中使用 `UFUNCTION` 宏时，你只需将 `BlueprintNativeEvent` 标签添加到该宏中，就可以将一个函数转换成蓝图原生事件。
- en: 'So, what is a Blueprint native event? It’s an event that is declared in C++
    that can have a default behavior, which is also defined in C++, but that can be
    overridden in Blueprint. Let’s declare a Blueprint native event called `MyEvent`
    by declaring a `MyEvent` function using the `UFUNCTION` macro with the `BlueprintNativeEvent`
    tag, followed by the virtual `MyEvent_Implementation` function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是蓝图原生事件呢？它是在C++中声明的可以具有默认行为的事件，这个默认行为也在C++中定义，但可以在蓝图中覆盖。让我们通过使用带有`BlueprintNativeEvent`标记的`UFUNCTION`宏声明一个名为`MyEvent`的函数来声明一个名为`MyEvent`的蓝图原生事件，然后是虚拟的`MyEvent_Implementation`函数：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The reason why you have to declare these two functions is that the first one
    is the Blueprint signature, which allows you to override the event in Blueprint,
    while the second one is the C++ signature, which allows you to override the event
    in C++.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须声明这两个函数的原因是，第一个是蓝图签名，它允许你在蓝图中覆盖事件，而第二个是C++签名，它允许你在C++中覆盖事件。
- en: The C++ signature is simply the name of the event followed by `_Implementation`,
    and it should always be a `virtual` function. Given that you declared this event
    in C++, to implement its default behavior, you must implement the `MyEvent_Implementation`
    function, not the `MyEvent` function (that one should remain untouched). To call
    a Blueprint native event, you can simply call the normal function without the
    `_Implementation` suffix; in this case, `MyEvent()`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: C++签名只是事件名称后跟`_Implementation`，它应该始终是一个`virtual`函数。鉴于你在C++中声明了此事件，为了实现其默认行为，你必须实现`MyEvent_Implementation`函数，而不是`MyEvent`函数（那个应该保持不变）。要调用蓝图原生事件，你可以简单地调用正常函数而不带`_Implementation`后缀；在这种情况下，`MyEvent()`。
- en: In the next exercise, we’ll learn how to use Blueprint native events in practice,
    where we’ll create a new interface.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将学习如何在实践中使用蓝图原生事件，我们将创建一个新的接口。
- en: Exercise 7.04 – creating the HealthInterface class
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.04 – 创建HealthInterface类
- en: In this exercise, we will be creating an interface that’s responsible for handling
    how an object behaves when it runs out of health points.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个负责处理对象健康点耗尽时行为的接口。
- en: 'To do this, follow these steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，请按照以下步骤操作：
- en: Open the editor and create a new C++ class that inherits from `Interface` (called
    `Unreal Interface` in the scrollable menu) and call it `HealthInterface`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器并创建一个新的从`Interface`继承的C++类（在可滚动菜单中称为`Unreal Interface`），并将其命名为`HealthInterface`。
- en: Once the class’s files have been generated and opened in Visual Studio, go to
    the newly created class’s header file. You’ll notice that the generated file has
    two classes – `UHealthInterface` and `IHealthInterface`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦类的文件被生成并在Visual Studio中打开，请转到新创建的类的头文件。你会注意到生成的文件有两个类 – `UHealthInterface`和`IHealthInterface`。
- en: 'These will be used in combination when checking whether an object implements
    the interface and calls its functions. However, you should only add function declarations
    in the class prefixed with `I` – in this case, `IHealthInterface`. Add a `public`
    Blueprint native event called `OnDeath` that returns nothing and receives no parameters.
    This function will be called when an object runs out of health points:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些将在检查对象是否实现了接口并调用其函数时组合使用。然而，你应该只向以`I`开头（在这个例子中是`IHealthInterface`）的类中添加函数声明。添加一个名为`OnDeath`的`public`蓝图原生事件，它不返回任何内容，也不接收任何参数。当对象健康点耗尽时，将调用此函数：
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the `OnDeath_Implementation` function declaration needs its own implementation.
    However, there is no need for the interface to implement that function because
    it would simply be empty. To notify the compiler that this function has no implementation
    in this class, we added `= 0` to the end of its declaration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`OnDeath_Implementation`函数声明需要其自己的实现。然而，接口不需要实现该函数，因为它将简单地是空的。为了通知编译器这个类中没有该函数的实现，我们在其声明末尾添加了`=
    0`。
- en: 'Go to the `DodgeballCharacter` class’s header file. We’ll want this class to
    implement our newly created `HealthInterface`, but how do we do that? The first
    thing we have to do is include the `HealthInterface` class. Make sure you include
    it before the `.generated.h` `include` statement:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`DodgeballCharacter`类的头文件。我们希望这个类实现我们新创建的`HealthInterface`，但我们该如何做到这一点呢？我们首先要做的是包含`HealthInterface`类。确保你在`.generated.h`
    `include`语句之前包含它：
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, replace the line in the header file that makes the `DodgeballCharacter`
    class inherit from the `Character` class with the following line, which will make
    this class implement `HealthInterface`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将头文件中使`DodgeballCharacter`类继承自`Character`类的行替换为以下行，这将使此类实现`HealthInterface`：
- en: '[PRE28]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next thing we have to do is implement the `OnDeath` function in the `DodgeballCharacter`
    class. To do this, add a declaration for the `OnDeath_Implementation` function
    that overrides the interface’s C++ signature. This function should be `public`.
    To override a `virtual` function, you must add the `override` keyword to the end
    of its declaration:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须在`DodgeballCharacter`类中实现`OnDeath`函数。为此，添加一个`OnDeath_Implementation`函数的声明，该函数覆盖了接口的C++签名。这个函数应该是`public`的。要覆盖一个`virtual`函数，你必须在其声明末尾添加`override`关键字：
- en: '[PRE29]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this function’s implementation, within the class’s source file, simply quit
    the game, the same way that is being done in the `HealthComponent` class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数的实现中，在类的源文件内，简单地退出游戏，就像在`HealthComponent`类中做的那样：
- en: '[PRE30]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because we’re now using `KismetSystemLibrary`, we’ll have to include it:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在使用`KismetSystemLibrary`，我们不得不包含它：
- en: '[PRE31]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we must go to our `HealthComponent` class’s source file. Because we’ll
    no longer be using `KistemSystemLibrary` and will be using the `HealthInterface`
    instead, replace the `include` statement for the first class with an `include`
    statement for the second one:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须转到我们的`HealthComponent`类的源文件。由于我们将不再使用`KismetSystemLibrary`，而是使用`HealthInterface`，所以将第一个类的`include`语句替换为第二个类的`include`语句：
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, change the logic that is responsible for quitting the game when Owner
    runs out of health points. Instead of doing this, we’ll want to check whether
    Owner implements `HealthInterface` and, if it does, call its implementation of
    the `OnDeath` function. Remove the existing call to the `QuitGame` function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更改负责在所有者健康点耗尽时退出游戏的逻辑。我们不想这样做，而是想检查所有者是否实现了`HealthInterface`，如果是，就调用其`OnDeath`函数的实现。删除现有的`QuitGame`函数调用：
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To check whether an object implements a specific interface, we can call that
    object’s `Implements` function, using the interface’s class as a template parameter.
    The class of the interface that you should use in this function is the one that
    is prefixed with `U`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查一个对象是否实现了特定的接口，我们可以调用该对象的`Implements`函数，使用接口的类作为模板参数。在这个函数中应该使用的接口类是前面带有`U`前缀的类：
- en: '[PRE34]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Because we’ll be using methods that belong to the `Actor` class, we’ll also
    need to include it:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用属于`Actor`类的方法，我们还需要包含它：
- en: '[PRE35]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If this `if` statement is true, that means that our Owner implements `HealthInterface`.
    In this case, we’ll want to call its implementation of the `OnDeath` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个`if`语句为真，这意味着我们的所有者实现了`HealthInterface`。在这种情况下，我们将想调用其`OnDeath`函数的实现。
- en: 'To do this, call it through the interface’s class (this time, the one that
    is prefixed with `I`). The function inside the interface that you’ll want to call
    is `Execute_OnDeath` (note that the function you should call inside the interface
    will always be its normal name prefixed with `Execute_`). This function must receive
    at least one parameter, which is the object that the function will be called on
    and that implements that interface; in this case, Owner:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，通过接口的类（这次是前面带有`I`前缀的类）来调用它。你想要调用的接口内的函数是`Execute_OnDeath`（注意，你应在接口内调用的函数将始终是其正常名称前缀为`Execute_`）。这个函数必须至少接收一个参数，即将被调用的对象和实现该接口的对象；在这种情况下，所有者：
- en: '[PRE36]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If your interface’s function receives parameters, you can send them in the function
    call after the first parameter mentioned in the preceding step. For instance,
    if our `OnDeath` function received an `int` property as a parameter, you would
    call it with `IHealthInterface::Execute_OnDeath(GetOwner(), 5)`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的接口函数接收参数，你可以在前一步提到的第一个参数之后在函数调用中发送它们。例如，如果我们的`OnDeath`函数接收一个`int`属性作为参数，你将使用`IHealthInterface::Execute_OnDeath(GetOwner(),
    5)`来调用它。
- en: The first time you try to compile your code after adding a new function to an
    interface and then calling `Execute_ version`, you may get an `Intellisense` error.
    You can safely ignore this error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在向接口添加新函数并调用`Execute_版本`后第一次尝试编译代码时，你可能会得到一个`Intellisense`错误。你可以安全地忽略这个错误。
- en: 'Once you’ve made all these changes, compile your code and open the editor.
    When you play the game, try letting the character get hit by three dodgeballs:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成所有这些更改，编译你的代码并打开编辑器。当你玩游戏时，尝试让角色被三个躲避球击中：
- en: '![Figure 7.4 – The enemy character throwing dodgeballs at the player character
    ](img/Figure_7.04_B18531.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 敌人角色向玩家角色投掷躲避球](img/Figure_7.04_B18531.jpg)'
- en: Figure 7.4 – The enemy character throwing dodgeballs at the player character
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 敌人角色向玩家角色投掷躲避球
- en: 'If the game ends after that, then that means that all our changes worked and
    the game’s logic remains the same:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏结束后，那么这意味着我们所有的更改都成功了，游戏的逻辑保持不变：
- en: '![Figure 7.5 – The editor after the player character runs out of health points
    and the game stops ](img/Figure_7.05_B18531.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 玩家角色生命值耗尽且游戏停止后的编辑器](img/Figure_7.05_B18531.jpg)'
- en: Figure 7.5 – The editor after the player character runs out of health points
    and the game stops
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 玩家角色生命值耗尽且游戏停止后的编辑器
- en: And with that, we conclude this exercise. You now know how to use interfaces.
    The benefit of the change that we just made is that we can now have other actors
    that lose health, as well as specify what happens when they run out of health
    points by using the `Health` interface.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了这个练习。你现在知道如何使用接口。我们刚刚做出的改变的优点是，我们现在可以有其他失去生命值的演员，以及通过使用`Health`接口来指定它们生命值耗尽时会发生什么。
- en: Now, we will complete an activity where we’ll move all of the logic related
    to the `LookAtActor` function to its own Actor component and use it to replace
    the `SightSource` component we created.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将完成一个活动，我们将把与`LookAtActor`函数相关的所有逻辑移动到它自己的Actor组件中，并使用它来替换我们创建的`SightSource`组件。
- en: Activity 7.01 – moving the LookAtActor logic to an Actor component
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动七.01 – 将`LookAtActor`逻辑移动到Actor组件
- en: In this activity, we’ll be moving all of the logic related to the `LookAtActor`
    function, inside the `EnemyCharacter` class, to its own Actor component (similarly
    to how we moved the `CanSeeActor` function to a Blueprint Function Library). This
    way, if we want an actor (that isn’t an `EnemyCharacter`) to look at another actor,
    we will simply be able to add this component to it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将把与`LookAtActor`函数相关的所有逻辑，在`EnemyCharacter`类内部，移动到它自己的Actor组件中（类似于我们将`CanSeeActor`函数移动到蓝图函数库）。这样，如果我们想让一个演员（不是`EnemyCharacter`）看另一个演员，我们只需简单地将此组件添加到它上面。
- en: 'Follow these steps to complete this activity:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Open the editor and create a new C++ class that inherits from `SceneComponent`,
    called `LookAtActorComponent`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器并创建一个新的C++类，从`SceneComponent`继承，命名为`LookAtActorComponent`。
- en: Head to the class’s files, which are open in Visual Studio.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 转到类的文件，这些文件在Visual Studio中是打开的。
- en: Go to its header file and add a declaration for the `LookAtActor` function,
    which should be `protected`, return a `bool`, and receive no parameters.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往其头文件，并为`LookAtActor`函数添加一个声明，该函数应该是`protected`的，返回`bool`，并且不接受任何参数。
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the `LookAtActor` function of `EnemyCharacter` received the `AActor* TargetActor`
    parameter, this Actor component will have its `TargetActor` as a class property,
    which is why we won’t need to receive it as a parameter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`EnemyCharacter`的`LookAtActor`函数接收了`AActor* TargetActor`参数，但这个Actor组件将拥有其`TargetActor`作为类属性，因此我们不需要将其作为参数接收。
- en: Add a protected `AActor*` property called `TargetActor`. This property will
    represent the actor we want to look at.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`TargetActor`的受保护`AActor*`属性。此属性将代表我们想要看的演员。
- en: Add a protected `bool` property called `bCanSeeTarget`, with a default value
    of `false`, which will indicate whether `TargetActor` can be seen.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`bCanSeeTarget`的受保护`bool`属性，默认值为`false`，它将指示是否可以看到`TargetActor`。
- en: Add a declaration for a public `FORCEINLINE` function, as covered in [*Chapter
    6*](B18531_06.xhtml#_idTextAnchor134), *Setting Up Collision Objects*, called
    `SetTarget`, which will return nothing and receive `AActor* NewTarget` as a parameter.
    The implementation of this function will simply set the `TargetActor` property
    to the value of the `NewTarget` property.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个声明为`FORCEINLINE`的公共函数，如[*第6章*](B18531_06.xhtml#_idTextAnchor134)中所述，*设置碰撞对象*，名为`SetTarget`，该函数不返回任何内容，并接收`AActor*
    NewTarget`作为参数。此函数的实现将简单地设置`TargetActor`属性为`NewTarget`属性的值。
- en: Add a declaration for a public `FORCEINLINE` function called `CanSeeTarget`,
    which will be `const`, return a `bool`, and receive no parameters. The implementation
    of this function will simply return the value of the `bCanSeeTarget` property.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为一个名为`CanSeeTarget`的公共`FORCEINLINE`函数添加声明，该函数将是`const`，返回`bool`类型，并且不接受任何参数。此函数的实现将简单地返回`bCanSeeTarget`属性的值。
- en: Now, go to the class’s source file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到类的源文件。
- en: In the class’s `TickComponent` function, set the value of the `bCanSeeTarget`
    property to the return value of the `LookAtActor` function call.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的`TickComponent`函数中，将`bCanSeeTarget`属性的值设置为`LookAtActor`函数调用的返回值。
- en: Add an empty implementation of the `LookAtActor` function and copy the `EnemyCharacter`
    class’s implementation of the `LookAtActor` function into the implementation of
    `LookAtActorComponent`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个空的`LookAtActor`函数实现，并将`EnemyCharacter`类的`LookAtActor`函数实现复制到`LookAtActorComponent`的实现中。
- en: 'Make the following modifications to the `LookAtActorComponent` class’s implementation
    of the `LookAtActor` function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`LookAtActorComponent`类的`LookAtActor`函数实现进行以下修改：
- en: Change the first element of the `IgnoreActors` array to the Actor’s component’s
    Owner.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IgnoreActors`数组的第一个元素更改为Actor组件的所有者。
- en: Change the second parameter of the `CanSeeActor` function call to this component’s
    location.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CanSeeActor`函数调用的第二个参数更改为此组件的位置。
- en: Change the value of the `Start` property to the location of Owner.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Start`属性的值更改为所有者的位置。
- en: Finally, replace the call to the `SetActorRotation` function with a call to
    the `SetActorRotation` function of Owner.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将调用`SetActorRotation`函数替换为调用所有者的`SetActorRotation`函数。
- en: Because of the modifications we’ve made to the implementation of the `LookAtActor`
    function, we’ll need to add some includes to our `LookAtActorComponent` class
    and remove some includes from our `EnemyCharacter` class. Remove the includes
    to `KismetMathLibrary` and `DodgeballFunctionLibrary` from the `EnemyCharacter`
    class and add them to the `LookAtActorComponent` class.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们对`LookAtActor`函数的实现进行了修改，我们需要在我们的`LookAtActorComponent`类中添加一些包含，并从我们的`EnemyCharacter`类中删除一些包含。从`EnemyCharacter`类中删除对`KismetMathLibrary`和`DodgeballFunctionLibrary`的包含，并将它们添加到`LookAtActorComponent`类中。
- en: We’ll also need to add an include to the `Actor` class since we’ll be accessing
    several functions belonging to that class.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加对`Actor`类的包含，因为我们将会访问该类所属的几个函数。
- en: 'Now, let’s make some further modifications to our `EnemyCharacter` class:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对我们的`EnemyCharacter`类进行一些进一步的修改：
- en: In its header file, remove the declaration of the `LookAtActor` function.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其头文件中，删除`LookAtActor`函数的声明。
- en: Replace the `SightSource` property with a property of the `UlookAtActorComponent*`
    type called `LookAtActorComponent`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SightSource`属性替换为名为`LookAtActorComponent`的`UlookAtActorComponent*`类型的属性。
- en: In the class’s source file, add an include to the `LookAtActorComponent` class.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中，添加对`LookAtActorComponent`类的包含。
- en: Inside the class’s constructor, replace the references to the `SightSource`
    property with a reference to the `LookAtActorComponent` property. Additionally,
    the `CreateDefaultSubobject` function’s template parameter should be the `ULookAtActorComponent`
    class and its parameter should be `“Look At Actor Component”`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的构造函数内部，将`SightSource`属性的引用替换为`LookAtActorComponent`属性的引用。此外，`CreateDefaultSubobject`函数的模板参数应该是`ULookAtActorComponent`类，其参数应该是`“Look
    At Actor Component”`。
- en: Remove the class’s implementation of the `LookAtActor` function.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除类的`LookAtActor`函数实现。
- en: In the class’s `Tick` function, remove the line of code where you create the
    `PlayerCharacter` property, and add that exact line of code to the end of the
    class’s `BeginPlay` function.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的`Tick`函数中，删除创建`PlayerCharacter`属性的代码行，并将该行代码添加到类`BeginPlay`函数的末尾。
- en: After this line, call the `SetTarget` function of `LookAtActorComponent` and
    send the `PlayerCharacter` property as a parameter.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一行之后，调用`LookAtActorComponent`的`SetTarget`函数，并将`PlayerCharacter`属性作为参数发送。
- en: Inside the class’s `Tick` function, set the `bCanSeePlayer` property’s value
    to the return value of the `CanSeeTarget` function call of `LookAtActorComponent`,
    instead of the return value of the `LookAtActor` function call.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的`Tick`函数内部，将`bCanSeePlayer`属性的值设置为`LookAtActorComponent`的`CanSeeTarget`函数调用的返回值，而不是`LookAtActor`函数调用的返回值。
- en: Now, there’s only one last step we have to do before this activity is completed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在完成此活动之前，我们只剩最后一步要做了。
- en: Close the editor (if you have it opened), compile your changes in Visual Studio,
    open the editor, and open the `BP_EnemyCharacter` Blueprint. Find `LookAtActorComponent`
    and change its location to `(10, 0, 80)`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器（如果你已经打开的话），在Visual Studio中编译你的更改，然后打开编辑器，打开`BP_EnemyCharacter`蓝图。找到`LookAtActorComponent`并将其位置更改为`(10,
    0, 80)`。
- en: '**Expected output**:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**：'
- en: '![Figure 7.6 – The enemy character looking at the player character remains
    functional ](img/Figure_7.06_B18531.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 敌对角色观察玩家角色的功能仍然有效](img/Figure_7.06_B18531.jpg)'
- en: Figure 7.6 – The enemy character looking at the player character remains functional
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 敌对角色观察玩家角色的功能仍然有效
- en: And with that, we conclude our activity. You have applied your knowledge of
    refactoring part of an actor’s logic into an Actor component so that you can reuse
    it in other parts of your project, or even in other projects of your own.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就结束了这次活动。你已经将部分演员逻辑重构为Actor组件，以便你在项目的其他部分或你自己的其他项目中重用它。
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)找到。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You now know about several utilities that will help you keep your projects more
    organized and allow you to reuse the things that you make.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在了解了几种实用工具，这些工具将帮助你使你的项目更有条理，并允许你重用你所制作的东西。
- en: You learned how to create a Blueprint Function Library, create Actor components
    and use them to refactor the existing logic in your project, and create interfaces
    and call functions from an object that implements a specific interface. Altogether,
    these new topics will allow you to refactor and reuse all the code that you write
    in a project in that same project or another project.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何创建蓝图函数库，创建Actor组件，并使用它们来重构项目中现有的逻辑，以及如何创建接口并从实现特定接口的对象中调用函数。总的来说，这些新主题将允许你在同一项目或另一个项目中重构和重用你在项目中编写的所有代码。
- en: In the next chapter, we’ll look at UMG, UE5’s system for creating user interfaces,
    and learn how to create user interfaces.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨UMG，即UE5创建用户界面的系统，并学习如何创建用户界面。
