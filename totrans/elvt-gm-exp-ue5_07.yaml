- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with UE5 Utilities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the remaining collision-related concepts
    in UE5, such as collision events, object types, physics simulation, and collision
    components. We learned how to have objects collide against one another, changing
    their responses to different collision channels, as well as how to create collision
    presets, spawn actors, and use timers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at several UE5 utilities that will allow you to
    easily move logic from one project to another and keep your project well-structured
    and organized, which will make life much easier for you in the long run and also
    make it easier for other people in your team to understand your work and modify
    it in the future. Game development is a tremendously hard task and is rarely done
    individually, but rather in teams, so it’s important to take these things into
    account when building your projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Good practices – loose coupling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blueprint Function Libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actor components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blueprint native events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project for this chapter can be found in the Chapter07 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Good practices – loose coupling
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use Blueprint Function Libraries to move some generic functions in our
    project from a specific actor to a Blueprint Function Library so that they can
    be used in other parts of our project’s logic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: We will use Actor components to move part of some actor classes’ source code
    into an Actor component so that we can easily use that logic in other projects.
    This will keep our project loosely coupled. Loose coupling is a software engineering
    concept that refers to having your project structured in such a way that you can
    easily remove and add things as you need. The reason you should strive for loose
    coupling is if you want to reuse parts of one of your projects for another project.
    As a game developer, loose coupling will allow you to do that much more easily.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A practical example of how you could apply loose coupling is if you had a player
    character class that was able to fly and also had an inventory that contained
    several usable items. Instead of implementing the code responsible for both of
    those things in that player character class, you would implement the logic for
    each of them in separate Actor components, which you would then add to the class.
    This will not only make it easier to add and remove things that this class will
    do, by simply adding and removing the Actor components responsible for those things,
    but also allow you to reuse those Actor components in other projects where you
    have a character that has an inventory or can fly. This is one of the main purposes
    of Actor components.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces, much like Actor components, make our project better structured and
    organized.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by talking about Blueprint Function Libraries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint Function Libraries
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In UE5, there’s a class called `BlueprintFunctionLibary` that is meant to contain
    a collection of static functions that don’t belong to any specific actor and can
    be used in multiple parts of your project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: For instance, some of the objects that we used previously, such as the `GameplayStatics`
    object and `Kismet` libraries such as `KismetMathLibrary` and `KismetSystemLibrary`,
    are Blueprint Function Libraries. These contain functions that can be used in
    any part of your project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'There is at least one function in our project that’s been created by us that
    can be moved to a Blueprint Function Library: the `CanSeeActor` function defined
    in the `EnemyCharacter` class.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In the first exercise of this chapter, we will create a Blueprint Function Library
    so that we can move the `CanSeeActor` function from the `EnemyCharacter` class
    to the `BlueprintFunctionLibrary` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.01 – moving the CanSeeActor function to the Blueprint Function Library
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be moving the `CanSeeActor` function that we created
    for the `EnemyCharacter` class to a Blueprint Function Library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Open Unreal Editor.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* inside the **Content Browser** area and select **New C++ Class**.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **BlueprintFunctionLibrary** as the parent class of this C++ class (you’ll
    find it by scrolling to the end of the panel).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new C++ class `DodgeballFunctionLibrary`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the class’s files have been generated in Visual Studio, open them and
    close the editor.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the header file of `DodgeballFunctionLibrary`, add a declaration for a `public`
    function called `CanSeeActor`. This function will be similar to the one we created
    in the `EnemyCharacter` class; however, there will be some differences.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new `CanSeeActor` function will be `static`, will return a `bool`, and
    will receive the following parameters:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: A `const UWorld* World` property, which we will use to access the `Line Trace`
    functions.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `FVector Location` property, which we will use as the location of the actor
    that is checking whether it can see the target actor.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `const AActor* TargetActor` property, which will be the actor we’re checking
    visibility for.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `TArray<const AActor*> IgnoreActors` property, which will specify the actors
    that should be ignored during the `Line Trace` functions. This property can have
    an empty array as a default argument:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the implementation of this function in the class’s source file and copy
    the implementation of the `EnemyCharacter` class’s version into this new class.
    Once you’ve done that, make the following modifications to the implementation:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the value of the `Start` location of the `Line Trace` to the `Location`
    parameter:'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead of ignoring this actor (using the `this` pointer) and `TargetActor`,
    ignore the entire `IgnoreActors` array using the `AddIgnoredActors` function of
    `FCollisionQueryParams` and send that array as a parameter:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Replace both calls to the `GetWorld` function with the received `World` parameter:'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the necessary includes to the top of the `DodgeballFunctionLibrary` class,
    as shown in the following code snippet:'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you’ve created the new version of the `CanSeeActor` function inside `DodgeballFunctionLibrary`,
    head to our `EnemyCharacter` class and make the following changes:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the declaration and implementation of the `CanSeeActor` function, inside
    its header and source file, respectively.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the `DrawDebugHelpers` include, given that we will no longer need that
    file:'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add an include for `DodgeballFunctionLibrary`:'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside the class’s `LookAtActor` function, just before the `if` statement that
    calls the `CanSeeActor` function, declare a `const TArray<const AActor*> IgnoreActors`
    variable and set it to both the `this` pointer and the `TargetActor` parameter:'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the preceding code snippet may give you an IntelliSense error in
    Visual Studio. You can safely ignore it, as your code should compile with no issues
    regardless.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing call to the `CanSeeActor` function with the one we just
    created by sending the following as parameters:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current world, through the `GetWorld` function
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SightSource` component’s location, using its `GetComponentLocation` function
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TargetActor` parameter
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `IgnoreActors` array we just created:'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that you’ve made all those changes, compile your code, open your project,
    and verify that the `EnemyCharacter` class still looks at the player as it walks
    around, so long as it’s in the enemy character’s sight, as shown in the following
    screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The enemy character still looking at the player character ](img/Figure_7.01_B18531.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The enemy character still looking at the player character
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes our exercise. We’ve put our `CanSeeActor` function inside
    a Blueprint Function Library and can now reuse it for other actors that require
    the same type of functionality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The next step in our project is going to be learning more about Actor components
    and how we can use them to our advantage. Let’s take a look.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Actor components
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the first few chapters of this book, Actors are the main way to
    create logic in UE5\. However, we’ve also seen that Actors can contain several
    Actor components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Actor components are objects that can be added to an Actor and can have multiple
    types of functionality, such as being responsible for a character’s inventory
    or making a character fly. Actor components must always belong to and live inside
    an Actor, which is referred to as their **Owner**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different types of existing Actor components. Some of these
    are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Code-only Actor components, which act as their own class inside an actor. They
    have their own properties and functions and can both interact with the Actor they
    belong to and be interacted with by it.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesh components, which are used to draw several types of Mesh objects (Static
    Meshes, Skeletal Meshes, and so on).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision components, which are used to receive and generate collision events.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camera components.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This leaves us with two main ways to add logic to our Actors: directly in the
    `Actor` class or through `Actor` components. To follow good software development
    practices, namely loose coupling (mentioned previously), you should strive to
    use Actor components instead of placing logic directly inside an Actor whenever
    possible. Let’s take a look at a practical example to understand the usefulness
    of Actor components.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you’re making a game where you have the player character and enemy
    characters, both of which have health, and where the player character must fight
    enemies, who can also fight back. If you had to implement the health logic, which
    includes gaining health, losing health, and tracking the character’s health, you’d
    have two options:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: You can implement the health logic in a base character class, from which both
    the player character class and the enemy character class would inherit.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can implement the health logic in an Actor component and add that component
    to both the player character and enemy character classes separately.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few reasons why the first option is not a good option, but the
    main one is this: if you wanted to add another piece of logic to both character
    classes (for example, stamina, which would limit the strength and frequency of
    the characters’ attacks), doing so using the same approach of a base class wouldn’t
    be a viable option. Given that, in UE5, C++ classes can only inherit from one
    class and there’s no such thing as multiple inheritance, that would be very hard
    to manage. It would also only get more complicated and unmanageable the more logic
    you decided to add to your project.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: With that said, when adding logic to your project that can be encapsulated in
    a separate component, allowing you to achieve loose coupling, you should always
    do so.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a new Actor component that will be responsible for keeping
    track of an actor’s health, as well as gaining and losing that health.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.02 – creating the HealthComponent Actor component
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating a new actor component responsible for
    gaining, losing, and keeping track of an actor’s health (its Owner).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: For the player to lose, we’ll have to make the player character lose health
    and then end the game when it runs out of health. We’ll want to put this logic
    inside an actor component so that we can easily add all this health-related logic
    to other actors if we need to.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor and create a new C++ class, whose parent class will be the `ActorComponent`
    class. Its name will be `HealthComponent`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once this class has been created and its files have been opened in Visual Studio,
    go to its header file and add a protected `float` property called `Health`, which
    will keep track of the Owner’s current health points. Its default value can be
    set to the number of health points its Owner will start the game with. In this
    case, we’ll initialize it with a value of `100` health points:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a declaration for the function that’s responsible for taking health
    away from its Owner. This function should be `public`; return nothing; receive
    a `float Amount` property as input, which indicates how many health points its
    Owner should lose; and be called `LoseHealth`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, in the class’s source file, let’s start by notifying it that it should
    never use the `Tick` event so that its performance can be slightly improved.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `bCanEverTick` property’s value to `false` inside the class’s constructor:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the implementation for our `LoseHealth` function, where we’ll start
    by removing the `Amount` parameter’s value from our `Health` property:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, in that same function, we’ll check whether the current amount of health
    is less than or equal to `0`, which means that it has run out of health points
    (*has died or been destroyed*):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the `if` statement is true, we’ll do the following things:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `Health` property to `0` to make sure that our Owner doesn’t have negative
    health points:'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Quit the game, the same way we did in [*Chapter 6*](B18531_06.xhtml#_idTextAnchor134),
    *Setting Up* *Collision Objects*, when creating the `VictoryBox` class:'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Don’t forget to include the `KismetSystemLibrary` object:'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this logic done, whenever any actor that has `HealthComponent` runs out
    of health, the game will end. This isn’t exactly the behavior we want in our **Dodgeball**
    game. However, we’ll change it when we talk about interfaces later in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we’ll be making the necessary modifications to some classes
    in our project to accommodate our newly created `HealthComponent`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.03 – integrating the HealthComponent Actor component
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be modifying our `DodgeballProjectile` class so that
    it damages the player’s character when it comes into contact with it, as well
    as the `DodgeballCharacter` class so that it has a `HealthComponent`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `DodgeballProjectile` class’s files in Visual Studio and make the
    following modifications:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'In the class’s header file, add a protected `float` property called `Damage`
    and set its default value to `34` so that our player character will lose all of
    its health points after being hit three times. This property should be a `UPROPERTY`
    and have the `EditAnywhere` tag so that you can easily change its value in its
    Blueprint class:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the class’s source file, we’ll have to make some modifications to the `OnHit`
    function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ll be using the `HealthComponent` class, we’ll have to add the `include`
    statement for it:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The existing cast that is being done for `DodgeballCharacter` from the `OtherActor`
    property, which we did in *s**tep 17* of *Exercise 6.01 – creating the Dodgeball
    class*, and is inside the `if` statement, should be done before that `if` statement
    and be saved inside a variable. Then, you should check whether that variable is
    `nullptr`. We are doing this to access the player character’s `HealthComponent`
    inside the `if` statement:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the `if` statement is true (that is, if the actor we hit is the player’s
    character), we want to access that character’s `HealthComponent` and reduce the
    character’s health. To access `HealthComponent`, we must call the character’s
    `FindComponentByClass` function and send the `UHealthComponent` class as a template
    parameter (to indicate the class of the component we want to access):'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The `FindComponentByClass` function, included in the `Actor` class, will return
    a reference(s) to the actor component(s) of a specific class that the actor contains.
    If the function returns `nullptr`, that means the actor doesn’t have an Actor
    component of that class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: You may also find the `GetComponents` function inside the `Actor` class useful,
    which will return a list of all the Actor components inside that actor.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, check whether `HealthComponent` is `nullptr`. If it isn’t, we’ll
    call its `LoseHealth` function and send the `Damage` property as a parameter:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Make sure the existing `Destroy` function is called after doing the null check
    for `HealthComponent`, as shown in the previous code snippet.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we finish this exercise, we’ll need to make some modifications to our
    `DodgeballCharacter` class. Open the class’s files in Visual Studio.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'In the class’s header file, add a `private` property of the `class UhealthComponent*`
    type called `HealthComponent`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the class’s source file, add an `include` statement to the `HealthComponent`
    class:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At the end of the class’s constructor, create `HealthComponent` by using the
    `CreateDefaultSubobject` function and name it `HealthComponent`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once you’ve made all these changes, compile your code and open the editor.
    When you play the game, if you let your player character get hit by a dodgeball
    three times, you’ll notice that the game abruptly stops, as intended:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The enemy character throwing dodgeballs at the player character
    ](img/Figure_7.02_B18531.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – The enemy character throwing dodgeballs at the player character
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the game is stopped, it will look as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The editor after the player character runs out of health points
    and the game stops ](img/Figure_7.03_B18531.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The editor after the player character runs out of health points
    and the game stops
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: And that completes this exercise. You now know how to create Actor components
    and how to access an actor’s Actor components. This is a very important step toward
    making your game projects more understandable and better structured, so good job.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve learned about Actor components, let’s learn about another way
    to make our projects better structured and organized: by using interfaces.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Exploring interfaces
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s a chance that you may already know about interfaces, given that other
    programming languages, such as Java, already have them. If you do, they work pretty
    similarly in UE5, but if you don’t, let’s see how they work, taking the example
    of the `HealthComponent` class we created.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in the previous exercise, when the `Health` property of the `HealthComponent`
    class reaches `0`, that component will simply end the game. However, we don’t
    want that to happen every time an actor’s health points run out: some actors may
    simply be destroyed, some may notify another actor that they have run out of health
    points, and so on. We want each actor to be able to determine what happens to
    them when they run out of health points. But how can we handle this?'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we would simply call a specific function that belongs to Owner of the
    `HealthComponent` class, which would then choose how to handle the fact that Owner
    has run out of health points. But in which class should you implement that function,
    given that our Owner can be of any class, so long as it inherits from the Actor
    class? As we discussed at the beginning of this chapter, having a class that’s
    responsible just for this would quickly become unmanageable. Luckily for us, interfaces
    solve this problem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are classes that contain a collection of functions that an object
    must have if it implements that interface. It essentially works as a contract
    that the object signs, saying that it will implement all the functions present
    on that interface. Then, you can simply check whether an object implements a specific
    interface and call the object’s implementation of the function defined in the
    interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'In our specific case, we’ll want to have an interface that has a function that
    will be called when an object runs out of health points so that our `HealthComponent`
    class can check whether its Owner implements that interface and then call that
    function from the interface. This will make it easy for us to specify how each
    actor behaves when running out of health points: some actors may simply be destroyed,
    others may trigger an in-game event, and others may simply end the game (which
    is the case with our player character).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: However, before we create our first interface, we should talk a bit about Blueprint
    native events.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint native events
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the `UFUNCTION` macro in C++, you can turn a function into a Blueprint
    native event by simply adding the `BlueprintNativeEvent` tag to that macro.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is a Blueprint native event? It’s an event that is declared in C++
    that can have a default behavior, which is also defined in C++, but that can be
    overridden in Blueprint. Let’s declare a Blueprint native event called `MyEvent`
    by declaring a `MyEvent` function using the `UFUNCTION` macro with the `BlueprintNativeEvent`
    tag, followed by the virtual `MyEvent_Implementation` function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The reason why you have to declare these two functions is that the first one
    is the Blueprint signature, which allows you to override the event in Blueprint,
    while the second one is the C++ signature, which allows you to override the event
    in C++.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The C++ signature is simply the name of the event followed by `_Implementation`,
    and it should always be a `virtual` function. Given that you declared this event
    in C++, to implement its default behavior, you must implement the `MyEvent_Implementation`
    function, not the `MyEvent` function (that one should remain untouched). To call
    a Blueprint native event, you can simply call the normal function without the
    `_Implementation` suffix; in this case, `MyEvent()`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we’ll learn how to use Blueprint native events in practice,
    where we’ll create a new interface.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.04 – creating the HealthInterface class
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating an interface that’s responsible for handling
    how an object behaves when it runs out of health points.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor and create a new C++ class that inherits from `Interface` (called
    `Unreal Interface` in the scrollable menu) and call it `HealthInterface`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the class’s files have been generated and opened in Visual Studio, go to
    the newly created class’s header file. You’ll notice that the generated file has
    two classes – `UHealthInterface` and `IHealthInterface`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These will be used in combination when checking whether an object implements
    the interface and calls its functions. However, you should only add function declarations
    in the class prefixed with `I` – in this case, `IHealthInterface`. Add a `public`
    Blueprint native event called `OnDeath` that returns nothing and receives no parameters.
    This function will be called when an object runs out of health points:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the `OnDeath_Implementation` function declaration needs its own implementation.
    However, there is no need for the interface to implement that function because
    it would simply be empty. To notify the compiler that this function has no implementation
    in this class, we added `= 0` to the end of its declaration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `DodgeballCharacter` class’s header file. We’ll want this class to
    implement our newly created `HealthInterface`, but how do we do that? The first
    thing we have to do is include the `HealthInterface` class. Make sure you include
    it before the `.generated.h` `include` statement:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, replace the line in the header file that makes the `DodgeballCharacter`
    class inherit from the `Character` class with the following line, which will make
    this class implement `HealthInterface`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next thing we have to do is implement the `OnDeath` function in the `DodgeballCharacter`
    class. To do this, add a declaration for the `OnDeath_Implementation` function
    that overrides the interface’s C++ signature. This function should be `public`.
    To override a `virtual` function, you must add the `override` keyword to the end
    of its declaration:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this function’s implementation, within the class’s source file, simply quit
    the game, the same way that is being done in the `HealthComponent` class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because we’re now using `KismetSystemLibrary`, we’ll have to include it:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we must go to our `HealthComponent` class’s source file. Because we’ll
    no longer be using `KistemSystemLibrary` and will be using the `HealthInterface`
    instead, replace the `include` statement for the first class with an `include`
    statement for the second one:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, change the logic that is responsible for quitting the game when Owner
    runs out of health points. Instead of doing this, we’ll want to check whether
    Owner implements `HealthInterface` and, if it does, call its implementation of
    the `OnDeath` function. Remove the existing call to the `QuitGame` function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To check whether an object implements a specific interface, we can call that
    object’s `Implements` function, using the interface’s class as a template parameter.
    The class of the interface that you should use in this function is the one that
    is prefixed with `U`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Because we’ll be using methods that belong to the `Actor` class, we’ll also
    need to include it:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If this `if` statement is true, that means that our Owner implements `HealthInterface`.
    In this case, we’ll want to call its implementation of the `OnDeath` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, call it through the interface’s class (this time, the one that
    is prefixed with `I`). The function inside the interface that you’ll want to call
    is `Execute_OnDeath` (note that the function you should call inside the interface
    will always be its normal name prefixed with `Execute_`). This function must receive
    at least one parameter, which is the object that the function will be called on
    and that implements that interface; in this case, Owner:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: If your interface’s function receives parameters, you can send them in the function
    call after the first parameter mentioned in the preceding step. For instance,
    if our `OnDeath` function received an `int` property as a parameter, you would
    call it with `IHealthInterface::Execute_OnDeath(GetOwner(), 5)`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The first time you try to compile your code after adding a new function to an
    interface and then calling `Execute_ version`, you may get an `Intellisense` error.
    You can safely ignore this error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve made all these changes, compile your code and open the editor.
    When you play the game, try letting the character get hit by three dodgeballs:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The enemy character throwing dodgeballs at the player character
    ](img/Figure_7.04_B18531.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The enemy character throwing dodgeballs at the player character
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'If the game ends after that, then that means that all our changes worked and
    the game’s logic remains the same:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The editor after the player character runs out of health points
    and the game stops ](img/Figure_7.05_B18531.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – The editor after the player character runs out of health points
    and the game stops
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we conclude this exercise. You now know how to use interfaces.
    The benefit of the change that we just made is that we can now have other actors
    that lose health, as well as specify what happens when they run out of health
    points by using the `Health` interface.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will complete an activity where we’ll move all of the logic related
    to the `LookAtActor` function to its own Actor component and use it to replace
    the `SightSource` component we created.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Activity 7.01 – moving the LookAtActor logic to an Actor component
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we’ll be moving all of the logic related to the `LookAtActor`
    function, inside the `EnemyCharacter` class, to its own Actor component (similarly
    to how we moved the `CanSeeActor` function to a Blueprint Function Library). This
    way, if we want an actor (that isn’t an `EnemyCharacter`) to look at another actor,
    we will simply be able to add this component to it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor and create a new C++ class that inherits from `SceneComponent`,
    called `LookAtActorComponent`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Head to the class’s files, which are open in Visual Studio.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Go to its header file and add a declaration for the `LookAtActor` function,
    which should be `protected`, return a `bool`, and receive no parameters.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: While the `LookAtActor` function of `EnemyCharacter` received the `AActor* TargetActor`
    parameter, this Actor component will have its `TargetActor` as a class property,
    which is why we won’t need to receive it as a parameter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Add a protected `AActor*` property called `TargetActor`. This property will
    represent the actor we want to look at.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a protected `bool` property called `bCanSeeTarget`, with a default value
    of `false`, which will indicate whether `TargetActor` can be seen.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a declaration for a public `FORCEINLINE` function, as covered in [*Chapter
    6*](B18531_06.xhtml#_idTextAnchor134), *Setting Up Collision Objects*, called
    `SetTarget`, which will return nothing and receive `AActor* NewTarget` as a parameter.
    The implementation of this function will simply set the `TargetActor` property
    to the value of the `NewTarget` property.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a declaration for a public `FORCEINLINE` function called `CanSeeTarget`,
    which will be `const`, return a `bool`, and receive no parameters. The implementation
    of this function will simply return the value of the `bCanSeeTarget` property.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go to the class’s source file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In the class’s `TickComponent` function, set the value of the `bCanSeeTarget`
    property to the return value of the `LookAtActor` function call.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an empty implementation of the `LookAtActor` function and copy the `EnemyCharacter`
    class’s implementation of the `LookAtActor` function into the implementation of
    `LookAtActorComponent`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following modifications to the `LookAtActorComponent` class’s implementation
    of the `LookAtActor` function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the first element of the `IgnoreActors` array to the Actor’s component’s
    Owner.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the second parameter of the `CanSeeActor` function call to this component’s
    location.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the value of the `Start` property to the location of Owner.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, replace the call to the `SetActorRotation` function with a call to
    the `SetActorRotation` function of Owner.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Because of the modifications we’ve made to the implementation of the `LookAtActor`
    function, we’ll need to add some includes to our `LookAtActorComponent` class
    and remove some includes from our `EnemyCharacter` class. Remove the includes
    to `KismetMathLibrary` and `DodgeballFunctionLibrary` from the `EnemyCharacter`
    class and add them to the `LookAtActorComponent` class.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll also need to add an include to the `Actor` class since we’ll be accessing
    several functions belonging to that class.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make some further modifications to our `EnemyCharacter` class:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In its header file, remove the declaration of the `LookAtActor` function.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the `SightSource` property with a property of the `UlookAtActorComponent*`
    type called `LookAtActorComponent`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the class’s source file, add an include to the `LookAtActorComponent` class.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the class’s constructor, replace the references to the `SightSource`
    property with a reference to the `LookAtActorComponent` property. Additionally,
    the `CreateDefaultSubobject` function’s template parameter should be the `ULookAtActorComponent`
    class and its parameter should be `“Look At Actor Component”`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the class’s implementation of the `LookAtActor` function.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the class’s `Tick` function, remove the line of code where you create the
    `PlayerCharacter` property, and add that exact line of code to the end of the
    class’s `BeginPlay` function.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this line, call the `SetTarget` function of `LookAtActorComponent` and
    send the `PlayerCharacter` property as a parameter.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the class’s `Tick` function, set the `bCanSeePlayer` property’s value
    to the return value of the `CanSeeTarget` function call of `LookAtActorComponent`,
    instead of the return value of the `LookAtActor` function call.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, there’s only one last step we have to do before this activity is completed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Close the editor (if you have it opened), compile your changes in Visual Studio,
    open the editor, and open the `BP_EnemyCharacter` Blueprint. Find `LookAtActorComponent`
    and change its location to `(10, 0, 80)`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器（如果你已经打开的话），在Visual Studio中编译你的更改，然后打开编辑器，打开`BP_EnemyCharacter`蓝图。找到`LookAtActorComponent`并将其位置更改为`(10,
    0, 80)`。
- en: '**Expected output**:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**：'
- en: '![Figure 7.6 – The enemy character looking at the player character remains
    functional ](img/Figure_7.06_B18531.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 敌对角色观察玩家角色的功能仍然有效](img/Figure_7.06_B18531.jpg)'
- en: Figure 7.6 – The enemy character looking at the player character remains functional
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 敌对角色观察玩家角色的功能仍然有效
- en: And with that, we conclude our activity. You have applied your knowledge of
    refactoring part of an actor’s logic into an Actor component so that you can reuse
    it in other parts of your project, or even in other projects of your own.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就结束了这次活动。你已经将部分演员逻辑重构为Actor组件，以便你在项目的其他部分或你自己的其他项目中重用它。
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)找到。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You now know about several utilities that will help you keep your projects more
    organized and allow you to reuse the things that you make.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在了解了几种实用工具，这些工具将帮助你使你的项目更有条理，并允许你重用你所制作的东西。
- en: You learned how to create a Blueprint Function Library, create Actor components
    and use them to refactor the existing logic in your project, and create interfaces
    and call functions from an object that implements a specific interface. Altogether,
    these new topics will allow you to refactor and reuse all the code that you write
    in a project in that same project or another project.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何创建蓝图函数库，创建Actor组件，并使用它们来重构项目中现有的逻辑，以及如何创建接口并从实现特定接口的对象中调用函数。总的来说，这些新主题将允许你在同一项目或另一个项目中重构和重用你在项目中编写的所有代码。
- en: In the next chapter, we’ll look at UMG, UE5’s system for creating user interfaces,
    and learn how to create user interfaces.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨UMG，即UE5创建用户界面的系统，并学习如何创建用户界面。
