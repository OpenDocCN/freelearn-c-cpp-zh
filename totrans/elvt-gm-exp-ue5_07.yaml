- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with UE5 Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the remaining collision-related concepts
    in UE5, such as collision events, object types, physics simulation, and collision
    components. We learned how to have objects collide against one another, changing
    their responses to different collision channels, as well as how to create collision
    presets, spawn actors, and use timers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at several UE5 utilities that will allow you to
    easily move logic from one project to another and keep your project well-structured
    and organized, which will make life much easier for you in the long run and also
    make it easier for other people in your team to understand your work and modify
    it in the future. Game development is a tremendously hard task and is rarely done
    individually, but rather in teams, so it’s important to take these things into
    account when building your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Good practices – loose coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blueprint Function Libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actor components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blueprint native events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project for this chapter can be found in the Chapter07 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Good practices – loose coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use Blueprint Function Libraries to move some generic functions in our
    project from a specific actor to a Blueprint Function Library so that they can
    be used in other parts of our project’s logic.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Actor components to move part of some actor classes’ source code
    into an Actor component so that we can easily use that logic in other projects.
    This will keep our project loosely coupled. Loose coupling is a software engineering
    concept that refers to having your project structured in such a way that you can
    easily remove and add things as you need. The reason you should strive for loose
    coupling is if you want to reuse parts of one of your projects for another project.
    As a game developer, loose coupling will allow you to do that much more easily.
  prefs: []
  type: TYPE_NORMAL
- en: A practical example of how you could apply loose coupling is if you had a player
    character class that was able to fly and also had an inventory that contained
    several usable items. Instead of implementing the code responsible for both of
    those things in that player character class, you would implement the logic for
    each of them in separate Actor components, which you would then add to the class.
    This will not only make it easier to add and remove things that this class will
    do, by simply adding and removing the Actor components responsible for those things,
    but also allow you to reuse those Actor components in other projects where you
    have a character that has an inventory or can fly. This is one of the main purposes
    of Actor components.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces, much like Actor components, make our project better structured and
    organized.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by talking about Blueprint Function Libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint Function Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In UE5, there’s a class called `BlueprintFunctionLibary` that is meant to contain
    a collection of static functions that don’t belong to any specific actor and can
    be used in multiple parts of your project.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, some of the objects that we used previously, such as the `GameplayStatics`
    object and `Kismet` libraries such as `KismetMathLibrary` and `KismetSystemLibrary`,
    are Blueprint Function Libraries. These contain functions that can be used in
    any part of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is at least one function in our project that’s been created by us that
    can be moved to a Blueprint Function Library: the `CanSeeActor` function defined
    in the `EnemyCharacter` class.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first exercise of this chapter, we will create a Blueprint Function Library
    so that we can move the `CanSeeActor` function from the `EnemyCharacter` class
    to the `BlueprintFunctionLibrary` class.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.01 – moving the CanSeeActor function to the Blueprint Function Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be moving the `CanSeeActor` function that we created
    for the `EnemyCharacter` class to a Blueprint Function Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Unreal Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* inside the **Content Browser** area and select **New C++ Class**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **BlueprintFunctionLibrary** as the parent class of this C++ class (you’ll
    find it by scrolling to the end of the panel).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new C++ class `DodgeballFunctionLibrary`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the class’s files have been generated in Visual Studio, open them and
    close the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the header file of `DodgeballFunctionLibrary`, add a declaration for a `public`
    function called `CanSeeActor`. This function will be similar to the one we created
    in the `EnemyCharacter` class; however, there will be some differences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new `CanSeeActor` function will be `static`, will return a `bool`, and
    will receive the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A `const UWorld* World` property, which we will use to access the `Line Trace`
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `FVector Location` property, which we will use as the location of the actor
    that is checking whether it can see the target actor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `const AActor* TargetActor` property, which will be the actor we’re checking
    visibility for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `TArray<const AActor*> IgnoreActors` property, which will specify the actors
    that should be ignored during the `Line Trace` functions. This property can have
    an empty array as a default argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the implementation of this function in the class’s source file and copy
    the implementation of the `EnemyCharacter` class’s version into this new class.
    Once you’ve done that, make the following modifications to the implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the value of the `Start` location of the `Line Trace` to the `Location`
    parameter:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of ignoring this actor (using the `this` pointer) and `TargetActor`,
    ignore the entire `IgnoreActors` array using the `AddIgnoredActors` function of
    `FCollisionQueryParams` and send that array as a parameter:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace both calls to the `GetWorld` function with the received `World` parameter:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the necessary includes to the top of the `DodgeballFunctionLibrary` class,
    as shown in the following code snippet:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you’ve created the new version of the `CanSeeActor` function inside `DodgeballFunctionLibrary`,
    head to our `EnemyCharacter` class and make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the declaration and implementation of the `CanSeeActor` function, inside
    its header and source file, respectively.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the `DrawDebugHelpers` include, given that we will no longer need that
    file:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an include for `DodgeballFunctionLibrary`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the class’s `LookAtActor` function, just before the `if` statement that
    calls the `CanSeeActor` function, declare a `const TArray<const AActor*> IgnoreActors`
    variable and set it to both the `this` pointer and the `TargetActor` parameter:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the preceding code snippet may give you an IntelliSense error in
    Visual Studio. You can safely ignore it, as your code should compile with no issues
    regardless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing call to the `CanSeeActor` function with the one we just
    created by sending the following as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current world, through the `GetWorld` function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SightSource` component’s location, using its `GetComponentLocation` function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TargetActor` parameter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `IgnoreActors` array we just created:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that you’ve made all those changes, compile your code, open your project,
    and verify that the `EnemyCharacter` class still looks at the player as it walks
    around, so long as it’s in the enemy character’s sight, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The enemy character still looking at the player character ](img/Figure_7.01_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The enemy character still looking at the player character
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes our exercise. We’ve put our `CanSeeActor` function inside
    a Blueprint Function Library and can now reuse it for other actors that require
    the same type of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in our project is going to be learning more about Actor components
    and how we can use them to our advantage. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Actor components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the first few chapters of this book, Actors are the main way to
    create logic in UE5\. However, we’ve also seen that Actors can contain several
    Actor components.
  prefs: []
  type: TYPE_NORMAL
- en: Actor components are objects that can be added to an Actor and can have multiple
    types of functionality, such as being responsible for a character’s inventory
    or making a character fly. Actor components must always belong to and live inside
    an Actor, which is referred to as their **Owner**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different types of existing Actor components. Some of these
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Code-only Actor components, which act as their own class inside an actor. They
    have their own properties and functions and can both interact with the Actor they
    belong to and be interacted with by it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesh components, which are used to draw several types of Mesh objects (Static
    Meshes, Skeletal Meshes, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision components, which are used to receive and generate collision events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camera components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This leaves us with two main ways to add logic to our Actors: directly in the
    `Actor` class or through `Actor` components. To follow good software development
    practices, namely loose coupling (mentioned previously), you should strive to
    use Actor components instead of placing logic directly inside an Actor whenever
    possible. Let’s take a look at a practical example to understand the usefulness
    of Actor components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you’re making a game where you have the player character and enemy
    characters, both of which have health, and where the player character must fight
    enemies, who can also fight back. If you had to implement the health logic, which
    includes gaining health, losing health, and tracking the character’s health, you’d
    have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: You can implement the health logic in a base character class, from which both
    the player character class and the enemy character class would inherit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can implement the health logic in an Actor component and add that component
    to both the player character and enemy character classes separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few reasons why the first option is not a good option, but the
    main one is this: if you wanted to add another piece of logic to both character
    classes (for example, stamina, which would limit the strength and frequency of
    the characters’ attacks), doing so using the same approach of a base class wouldn’t
    be a viable option. Given that, in UE5, C++ classes can only inherit from one
    class and there’s no such thing as multiple inheritance, that would be very hard
    to manage. It would also only get more complicated and unmanageable the more logic
    you decided to add to your project.'
  prefs: []
  type: TYPE_NORMAL
- en: With that said, when adding logic to your project that can be encapsulated in
    a separate component, allowing you to achieve loose coupling, you should always
    do so.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a new Actor component that will be responsible for keeping
    track of an actor’s health, as well as gaining and losing that health.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.02 – creating the HealthComponent Actor component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating a new actor component responsible for
    gaining, losing, and keeping track of an actor’s health (its Owner).
  prefs: []
  type: TYPE_NORMAL
- en: For the player to lose, we’ll have to make the player character lose health
    and then end the game when it runs out of health. We’ll want to put this logic
    inside an actor component so that we can easily add all this health-related logic
    to other actors if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor and create a new C++ class, whose parent class will be the `ActorComponent`
    class. Its name will be `HealthComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once this class has been created and its files have been opened in Visual Studio,
    go to its header file and add a protected `float` property called `Health`, which
    will keep track of the Owner’s current health points. Its default value can be
    set to the number of health points its Owner will start the game with. In this
    case, we’ll initialize it with a value of `100` health points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a declaration for the function that’s responsible for taking health
    away from its Owner. This function should be `public`; return nothing; receive
    a `float Amount` property as input, which indicates how many health points its
    Owner should lose; and be called `LoseHealth`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the class’s source file, let’s start by notifying it that it should
    never use the `Tick` event so that its performance can be slightly improved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `bCanEverTick` property’s value to `false` inside the class’s constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the implementation for our `LoseHealth` function, where we’ll start
    by removing the `Amount` parameter’s value from our `Health` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in that same function, we’ll check whether the current amount of health
    is less than or equal to `0`, which means that it has run out of health points
    (*has died or been destroyed*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `if` statement is true, we’ll do the following things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `Health` property to `0` to make sure that our Owner doesn’t have negative
    health points:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Quit the game, the same way we did in [*Chapter 6*](B18531_06.xhtml#_idTextAnchor134),
    *Setting Up* *Collision Objects*, when creating the `VictoryBox` class:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Don’t forget to include the `KismetSystemLibrary` object:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: With this logic done, whenever any actor that has `HealthComponent` runs out
    of health, the game will end. This isn’t exactly the behavior we want in our **Dodgeball**
    game. However, we’ll change it when we talk about interfaces later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we’ll be making the necessary modifications to some classes
    in our project to accommodate our newly created `HealthComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.03 – integrating the HealthComponent Actor component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be modifying our `DodgeballProjectile` class so that
    it damages the player’s character when it comes into contact with it, as well
    as the `DodgeballCharacter` class so that it has a `HealthComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `DodgeballProjectile` class’s files in Visual Studio and make the
    following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the class’s header file, add a protected `float` property called `Damage`
    and set its default value to `34` so that our player character will lose all of
    its health points after being hit three times. This property should be a `UPROPERTY`
    and have the `EditAnywhere` tag so that you can easily change its value in its
    Blueprint class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the class’s source file, we’ll have to make some modifications to the `OnHit`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ll be using the `HealthComponent` class, we’ll have to add the `include`
    statement for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The existing cast that is being done for `DodgeballCharacter` from the `OtherActor`
    property, which we did in *s**tep 17* of *Exercise 6.01 – creating the Dodgeball
    class*, and is inside the `if` statement, should be done before that `if` statement
    and be saved inside a variable. Then, you should check whether that variable is
    `nullptr`. We are doing this to access the player character’s `HealthComponent`
    inside the `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `if` statement is true (that is, if the actor we hit is the player’s
    character), we want to access that character’s `HealthComponent` and reduce the
    character’s health. To access `HealthComponent`, we must call the character’s
    `FindComponentByClass` function and send the `UHealthComponent` class as a template
    parameter (to indicate the class of the component we want to access):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `FindComponentByClass` function, included in the `Actor` class, will return
    a reference(s) to the actor component(s) of a specific class that the actor contains.
    If the function returns `nullptr`, that means the actor doesn’t have an Actor
    component of that class.
  prefs: []
  type: TYPE_NORMAL
- en: You may also find the `GetComponents` function inside the `Actor` class useful,
    which will return a list of all the Actor components inside that actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, check whether `HealthComponent` is `nullptr`. If it isn’t, we’ll
    call its `LoseHealth` function and send the `Damage` property as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the existing `Destroy` function is called after doing the null check
    for `HealthComponent`, as shown in the previous code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we finish this exercise, we’ll need to make some modifications to our
    `DodgeballCharacter` class. Open the class’s files in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the class’s header file, add a `private` property of the `class UhealthComponent*`
    type called `HealthComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the class’s source file, add an `include` statement to the `HealthComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the class’s constructor, create `HealthComponent` by using the
    `CreateDefaultSubobject` function and name it `HealthComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you’ve made all these changes, compile your code and open the editor.
    When you play the game, if you let your player character get hit by a dodgeball
    three times, you’ll notice that the game abruptly stops, as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The enemy character throwing dodgeballs at the player character
    ](img/Figure_7.02_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – The enemy character throwing dodgeballs at the player character
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the game is stopped, it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The editor after the player character runs out of health points
    and the game stops ](img/Figure_7.03_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The editor after the player character runs out of health points
    and the game stops
  prefs: []
  type: TYPE_NORMAL
- en: And that completes this exercise. You now know how to create Actor components
    and how to access an actor’s Actor components. This is a very important step toward
    making your game projects more understandable and better structured, so good job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve learned about Actor components, let’s learn about another way
    to make our projects better structured and organized: by using interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s a chance that you may already know about interfaces, given that other
    programming languages, such as Java, already have them. If you do, they work pretty
    similarly in UE5, but if you don’t, let’s see how they work, taking the example
    of the `HealthComponent` class we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in the previous exercise, when the `Health` property of the `HealthComponent`
    class reaches `0`, that component will simply end the game. However, we don’t
    want that to happen every time an actor’s health points run out: some actors may
    simply be destroyed, some may notify another actor that they have run out of health
    points, and so on. We want each actor to be able to determine what happens to
    them when they run out of health points. But how can we handle this?'
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we would simply call a specific function that belongs to Owner of the
    `HealthComponent` class, which would then choose how to handle the fact that Owner
    has run out of health points. But in which class should you implement that function,
    given that our Owner can be of any class, so long as it inherits from the Actor
    class? As we discussed at the beginning of this chapter, having a class that’s
    responsible just for this would quickly become unmanageable. Luckily for us, interfaces
    solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are classes that contain a collection of functions that an object
    must have if it implements that interface. It essentially works as a contract
    that the object signs, saying that it will implement all the functions present
    on that interface. Then, you can simply check whether an object implements a specific
    interface and call the object’s implementation of the function defined in the
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our specific case, we’ll want to have an interface that has a function that
    will be called when an object runs out of health points so that our `HealthComponent`
    class can check whether its Owner implements that interface and then call that
    function from the interface. This will make it easy for us to specify how each
    actor behaves when running out of health points: some actors may simply be destroyed,
    others may trigger an in-game event, and others may simply end the game (which
    is the case with our player character).'
  prefs: []
  type: TYPE_NORMAL
- en: However, before we create our first interface, we should talk a bit about Blueprint
    native events.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint native events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the `UFUNCTION` macro in C++, you can turn a function into a Blueprint
    native event by simply adding the `BlueprintNativeEvent` tag to that macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is a Blueprint native event? It’s an event that is declared in C++
    that can have a default behavior, which is also defined in C++, but that can be
    overridden in Blueprint. Let’s declare a Blueprint native event called `MyEvent`
    by declaring a `MyEvent` function using the `UFUNCTION` macro with the `BlueprintNativeEvent`
    tag, followed by the virtual `MyEvent_Implementation` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The reason why you have to declare these two functions is that the first one
    is the Blueprint signature, which allows you to override the event in Blueprint,
    while the second one is the C++ signature, which allows you to override the event
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ signature is simply the name of the event followed by `_Implementation`,
    and it should always be a `virtual` function. Given that you declared this event
    in C++, to implement its default behavior, you must implement the `MyEvent_Implementation`
    function, not the `MyEvent` function (that one should remain untouched). To call
    a Blueprint native event, you can simply call the normal function without the
    `_Implementation` suffix; in this case, `MyEvent()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we’ll learn how to use Blueprint native events in practice,
    where we’ll create a new interface.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.04 – creating the HealthInterface class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating an interface that’s responsible for handling
    how an object behaves when it runs out of health points.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor and create a new C++ class that inherits from `Interface` (called
    `Unreal Interface` in the scrollable menu) and call it `HealthInterface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the class’s files have been generated and opened in Visual Studio, go to
    the newly created class’s header file. You’ll notice that the generated file has
    two classes – `UHealthInterface` and `IHealthInterface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These will be used in combination when checking whether an object implements
    the interface and calls its functions. However, you should only add function declarations
    in the class prefixed with `I` – in this case, `IHealthInterface`. Add a `public`
    Blueprint native event called `OnDeath` that returns nothing and receives no parameters.
    This function will be called when an object runs out of health points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `OnDeath_Implementation` function declaration needs its own implementation.
    However, there is no need for the interface to implement that function because
    it would simply be empty. To notify the compiler that this function has no implementation
    in this class, we added `= 0` to the end of its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `DodgeballCharacter` class’s header file. We’ll want this class to
    implement our newly created `HealthInterface`, but how do we do that? The first
    thing we have to do is include the `HealthInterface` class. Make sure you include
    it before the `.generated.h` `include` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, replace the line in the header file that makes the `DodgeballCharacter`
    class inherit from the `Character` class with the following line, which will make
    this class implement `HealthInterface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next thing we have to do is implement the `OnDeath` function in the `DodgeballCharacter`
    class. To do this, add a declaration for the `OnDeath_Implementation` function
    that overrides the interface’s C++ signature. This function should be `public`.
    To override a `virtual` function, you must add the `override` keyword to the end
    of its declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this function’s implementation, within the class’s source file, simply quit
    the game, the same way that is being done in the `HealthComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because we’re now using `KismetSystemLibrary`, we’ll have to include it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must go to our `HealthComponent` class’s source file. Because we’ll
    no longer be using `KistemSystemLibrary` and will be using the `HealthInterface`
    instead, replace the `include` statement for the first class with an `include`
    statement for the second one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, change the logic that is responsible for quitting the game when Owner
    runs out of health points. Instead of doing this, we’ll want to check whether
    Owner implements `HealthInterface` and, if it does, call its implementation of
    the `OnDeath` function. Remove the existing call to the `QuitGame` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether an object implements a specific interface, we can call that
    object’s `Implements` function, using the interface’s class as a template parameter.
    The class of the interface that you should use in this function is the one that
    is prefixed with `U`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because we’ll be using methods that belong to the `Actor` class, we’ll also
    need to include it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If this `if` statement is true, that means that our Owner implements `HealthInterface`.
    In this case, we’ll want to call its implementation of the `OnDeath` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, call it through the interface’s class (this time, the one that
    is prefixed with `I`). The function inside the interface that you’ll want to call
    is `Execute_OnDeath` (note that the function you should call inside the interface
    will always be its normal name prefixed with `Execute_`). This function must receive
    at least one parameter, which is the object that the function will be called on
    and that implements that interface; in this case, Owner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If your interface’s function receives parameters, you can send them in the function
    call after the first parameter mentioned in the preceding step. For instance,
    if our `OnDeath` function received an `int` property as a parameter, you would
    call it with `IHealthInterface::Execute_OnDeath(GetOwner(), 5)`.
  prefs: []
  type: TYPE_NORMAL
- en: The first time you try to compile your code after adding a new function to an
    interface and then calling `Execute_ version`, you may get an `Intellisense` error.
    You can safely ignore this error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve made all these changes, compile your code and open the editor.
    When you play the game, try letting the character get hit by three dodgeballs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The enemy character throwing dodgeballs at the player character
    ](img/Figure_7.04_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The enemy character throwing dodgeballs at the player character
  prefs: []
  type: TYPE_NORMAL
- en: 'If the game ends after that, then that means that all our changes worked and
    the game’s logic remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The editor after the player character runs out of health points
    and the game stops ](img/Figure_7.05_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – The editor after the player character runs out of health points
    and the game stops
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we conclude this exercise. You now know how to use interfaces.
    The benefit of the change that we just made is that we can now have other actors
    that lose health, as well as specify what happens when they run out of health
    points by using the `Health` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will complete an activity where we’ll move all of the logic related
    to the `LookAtActor` function to its own Actor component and use it to replace
    the `SightSource` component we created.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 7.01 – moving the LookAtActor logic to an Actor component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we’ll be moving all of the logic related to the `LookAtActor`
    function, inside the `EnemyCharacter` class, to its own Actor component (similarly
    to how we moved the `CanSeeActor` function to a Blueprint Function Library). This
    way, if we want an actor (that isn’t an `EnemyCharacter`) to look at another actor,
    we will simply be able to add this component to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor and create a new C++ class that inherits from `SceneComponent`,
    called `LookAtActorComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Head to the class’s files, which are open in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Go to its header file and add a declaration for the `LookAtActor` function,
    which should be `protected`, return a `bool`, and receive no parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While the `LookAtActor` function of `EnemyCharacter` received the `AActor* TargetActor`
    parameter, this Actor component will have its `TargetActor` as a class property,
    which is why we won’t need to receive it as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Add a protected `AActor*` property called `TargetActor`. This property will
    represent the actor we want to look at.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a protected `bool` property called `bCanSeeTarget`, with a default value
    of `false`, which will indicate whether `TargetActor` can be seen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a declaration for a public `FORCEINLINE` function, as covered in [*Chapter
    6*](B18531_06.xhtml#_idTextAnchor134), *Setting Up Collision Objects*, called
    `SetTarget`, which will return nothing and receive `AActor* NewTarget` as a parameter.
    The implementation of this function will simply set the `TargetActor` property
    to the value of the `NewTarget` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a declaration for a public `FORCEINLINE` function called `CanSeeTarget`,
    which will be `const`, return a `bool`, and receive no parameters. The implementation
    of this function will simply return the value of the `bCanSeeTarget` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go to the class’s source file.
  prefs: []
  type: TYPE_NORMAL
- en: In the class’s `TickComponent` function, set the value of the `bCanSeeTarget`
    property to the return value of the `LookAtActor` function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an empty implementation of the `LookAtActor` function and copy the `EnemyCharacter`
    class’s implementation of the `LookAtActor` function into the implementation of
    `LookAtActorComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following modifications to the `LookAtActorComponent` class’s implementation
    of the `LookAtActor` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the first element of the `IgnoreActors` array to the Actor’s component’s
    Owner.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the second parameter of the `CanSeeActor` function call to this component’s
    location.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the value of the `Start` property to the location of Owner.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, replace the call to the `SetActorRotation` function with a call to
    the `SetActorRotation` function of Owner.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the modifications we’ve made to the implementation of the `LookAtActor`
    function, we’ll need to add some includes to our `LookAtActorComponent` class
    and remove some includes from our `EnemyCharacter` class. Remove the includes
    to `KismetMathLibrary` and `DodgeballFunctionLibrary` from the `EnemyCharacter`
    class and add them to the `LookAtActorComponent` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll also need to add an include to the `Actor` class since we’ll be accessing
    several functions belonging to that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make some further modifications to our `EnemyCharacter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: In its header file, remove the declaration of the `LookAtActor` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the `SightSource` property with a property of the `UlookAtActorComponent*`
    type called `LookAtActorComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the class’s source file, add an include to the `LookAtActorComponent` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the class’s constructor, replace the references to the `SightSource`
    property with a reference to the `LookAtActorComponent` property. Additionally,
    the `CreateDefaultSubobject` function’s template parameter should be the `ULookAtActorComponent`
    class and its parameter should be `“Look At Actor Component”`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the class’s implementation of the `LookAtActor` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the class’s `Tick` function, remove the line of code where you create the
    `PlayerCharacter` property, and add that exact line of code to the end of the
    class’s `BeginPlay` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this line, call the `SetTarget` function of `LookAtActorComponent` and
    send the `PlayerCharacter` property as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the class’s `Tick` function, set the `bCanSeePlayer` property’s value
    to the return value of the `CanSeeTarget` function call of `LookAtActorComponent`,
    instead of the return value of the `LookAtActor` function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, there’s only one last step we have to do before this activity is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Close the editor (if you have it opened), compile your changes in Visual Studio,
    open the editor, and open the `BP_EnemyCharacter` Blueprint. Find `LookAtActorComponent`
    and change its location to `(10, 0, 80)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Expected output**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The enemy character looking at the player character remains
    functional ](img/Figure_7.06_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – The enemy character looking at the player character remains functional
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we conclude our activity. You have applied your knowledge of
    refactoring part of an actor’s logic into an Actor component so that you can reuse
    it in other parts of your project, or even in other projects of your own.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now know about several utilities that will help you keep your projects more
    organized and allow you to reuse the things that you make.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to create a Blueprint Function Library, create Actor components
    and use them to refactor the existing logic in your project, and create interfaces
    and call functions from an object that implements a specific interface. Altogether,
    these new topics will allow you to refactor and reuse all the code that you write
    in a project in that same project or another project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at UMG, UE5’s system for creating user interfaces,
    and learn how to create user interfaces.
  prefs: []
  type: TYPE_NORMAL
