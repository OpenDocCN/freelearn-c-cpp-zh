["```cpp\n#include <iostream>\n#include <string>\nclass Car {\nprivate:\n    std::string _model;\n    double _speed;\n    double _fuel_level;\n    int _gear;\n    bool _entertainment_system_on;\npublic:\n    Car(const std::string& model) : _model(model), _speed(0), _fuel_level(50), _gear(1), _entertainment_system_on(false) {}\n    void accelerate() {\n        if (_fuel_level > 0) {\n            _speed += 10;\n            _fuel_level -= 5;\n            std::cout << \"Accelerating. Current speed: \" << _speed << \" km/h, Fuel level: \" << _fuel_level << \" liters\" << std::endl;\n        } else {\n            std::cout << \"Not enough fuel.\" << std::endl;\n        }\n    }\n    void change_gear(int new_gear) {\n        _gear = new_gear;\n        std::cout << \"Gear changed to: \" << _gear << std::endl;\n    }\n    void toggle_entertainment_system() {\n        _entertainment_system_on = !_entertainment_system_on;\n        std::cout << \"Entertainment System is now \" << (_entertainment_system_on ? \"on\" : \"off\") << std::endl;\n    }\n    void refuel(double amount) {\n        _fuel_level += amount;\n        std::cout << \"Refueling. Current fuel level: \" << _fuel_level << \" liters\" << std::endl;\n    }\n};\n```", "```cpp\n#include <iostream>\n#include <string>\nclass Engine {\nprivate:\n    double _fuel_level;\npublic:\n    Engine() : _fuel_level(50) {}\n    void consume_fuel(double amount) {\n        _fuel_level -= amount;\n        std::cout << \"Consuming fuel. Current fuel level: \" << _fuel_level << \" liters\" << std::endl;\n    }\n    void refuel(double amount) {\n        _fuel_level += amount;\n        std::cout << \"Engine refueled. Current fuel level: \" << _fuel_level << \" liters\" << std::endl;\n    }\n    double get_fuel_level() const {\n        return _fuel_level;\n    }\n};\nclass Transmission {\nprivate:\n    int _gear;\npublic:\n    Transmission() : _gear(1) {}\n    void change_gear(int new_gear) {\n        _gear = new_gear;\n        std::cout << \"Transmission: Gear changed to \" << _gear << std::endl;\n    }\n};\nclass EntertainmentSystem {\nprivate:\n    bool _is_on;\npublic:\n    EntertainmentSystem() : _is_on(false) {}\n    void toggle() {\n        _is_on = !_is_on;\n        std::cout << \"Entertainment System is now \" << (_is_on ? \"on\" : \"off\") << std::endl;\n    }\n};\nclass Car {\nprivate:\n    std::string _model;\n    double _speed;\n    Engine _engine;\n    Transmission _transmission;\n    EntertainmentSystem _entertainment_system;\npublic:\n    Car(const std::string& model) : _model(model), _speed(0) {}\n    void accelerate() {\n        if (_engine.get_fuel_level() > 0) {\n            _speed += 10;\n            _engine.consume_f\nuel(5);\n            std::cout << \"Car accelerating. Current speed: \" << _speed << \" km/h\" << std::endl;\n        } else {\n            std::cout << \"Not enough fuel to accelerate.\" << std::endl;\n        }\n    }\n    void change_gear(int gear) {\n        _transmission.change_gear(gear);\n    }\n    void toggle_entertainment_system() {\n        _entertainment_system.toggle();\n    }\n    void refuel(double amount) {\n        _engine.refuel(amount);\n    }\n};\n```", "```cpp\n    struct Color {\n    ```", "```cpp\n        int red = 0;\n    ```", "```cpp\n        int green = 0;\n    ```", "```cpp\n        int blue = 0;\n    ```", "```cpp\n    };\n    ```", "```cpp\n    struct Point {\n    ```", "```cpp\n        double x = 0.0;\n    ```", "```cpp\n        double y = 0.0;\n    ```", "```cpp\n        double z = 0.0;\n    ```", "```cpp\n    };\n    ```", "```cpp\n    Fortunately, C++ 11 and C++ 20 provide aggregate initialization and designated initializers, making it easier to initialize structs with default values.\n    ```", "```cpp\n    // C++ 11\n    ```", "```cpp\n       auto point = Point {1.1, 2.2, 3.3};\n    ```", "```cpp\n    // C++ 20\n    ```", "```cpp\n       auto point2 = Point {.x = 1.1, .y = 2.2, .z = 3.3};\n    ```", "```cpp\n       auto point3 = Point {.x = 1.1, .y = 2.2, .z = 3.3};\n    ```", "```cpp\n    class Car {\n    ```", "```cpp\n    private:\n    ```", "```cpp\n        int speed;\n    ```", "```cpp\n        double fuel_level;\n    ```", "```cpp\n    public:\n    ```", "```cpp\n        void accelerate();\n    ```", "```cpp\n        void brake();\n    ```", "```cpp\n        void refuel(double amount);\n    ```", "```cpp\n    };\n    ```", "```cpp\nclass Person {\nprivate:\n    std::string _name;\n    int _age;\npublic:\n    // Getter for the name property\n    std::string get_name() const { return _name; }\n    // Setter for the name property\n    void set_name(const std::string& name) { _name = name; }\n    // Getter for the age property\n    int get_age() const { return _age; }\n    // Setter for the age property\n    void set_age(int age) {\n        if (age >= 0) { // validate the age\n            _age = age;\n        }\n    }\n};\n```", "```cpp\nclass BaseSocket {\npublic:\n    virtual ssize_t send(const std::vector<uint8_t>& data) = 0;\n    virtual ~BaseSocket() = default;\n};\nclass TcpSocket : public BaseSocket {\npublic:\n    ssize_t send(const std::vector<uint8_t>& data) override {\n        // Implement TCP-specific send logic here\n    }\n};\nclass UdpSocket : public BaseSocket {\npublic:\n    ssize_t send(const std::vector<uint8_t>& data) override {\n        // Implement UDP-specific send logic here\n    }\n};\n```", "```cpp\nclass CommunicationChannel {\npublic:\n    CommunicationChannel(std::unique_ptr<BaseSocket> sock) : _socket(sock) {}\n    bool transmit(const std::vector<uint8_t>& data) {\n        size_t total_sent = 0;\n        size_t data_size = data.size();\n        while (total_sent < data_size) {\n            ssize_t bytesSent = _socket->send({data.begin() + total_sent, data.end()});\n            if (bytesSent < 0) {\n                std::cerr << \"Error sending data.\" << std::endl;\n                return false;\n            }\n            total_sent += bytesSent;\n        }\n        std::cout << \"Communication channel transmitted \" << total_sent << \" bytes.\" << std::endl;\n        return true;\n    }\nprivate:\n    std::unique_ptr<BaseSocket> _socket;\n};\nint main() {\n    TcpSocket tcp;\n    CommunicationChannel channel(std::make_unique<TcpSocket>());\n    std::vector<uint8_t> data = {1, 2, 3, 4, 5};\n    if (channel.transmit(data)) {\n        std::cout << \"Data transmitted successfully.\" << std::endl;\n    } else {\n        std::cerr << \"Data transmission failed.\" << std::endl;\n    }\n    return 0;\n}\n```", "```cpp\n+-------------------+\n|   Derived Class   |\n|-------------------|\n|  Base Class Part  | <- Base class subobject\n|-------------------|\n| Derived Class Data| <- Additional data members of the derived class\n+-------------------+\n```", "```cpp\n    #include <iostream>\n    ```", "```cpp\n    #include <string>\n    ```", "```cpp\n    // Base class for all media content\n    ```", "```cpp\n    class MediaContent {\n    ```", "```cpp\n    protected:\n    ```", "```cpp\n        std::string _title;\n    ```", "```cpp\n        int _duration; // Duration in seconds\n    ```", "```cpp\n    public:\n    ```", "```cpp\n        MediaContent(const std::string& title, int duration)\n    ```", "```cpp\n            : _title(title), _duration(duration) {}\n    ```", "```cpp\n        auto title() const { return _title; }\n    ```", "```cpp\n        auto duration() const { return duration; }\n    ```", "```cpp\n        virtual void play() = 0; // Start playing the content\n    ```", "```cpp\n        virtual void pause() = 0;\n    ```", "```cpp\n        virtual void stop() = 0;\n    ```", "```cpp\n        virtual ~MediaContent() = default;\n    ```", "```cpp\n    };\n    ```", "```cpp\n    class Audio : public MediaContent {\n    ```", "```cpp\n    private:\n    ```", "```cpp\n        int _bitrate; // Bitrate in kbps\n    ```", "```cpp\n    public:\n    ```", "```cpp\n        Audio(const std::string& title, int duration, int bitrate)\n    ```", "```cpp\n            : MediaContent(title, duration), _bitrate(bitrate) {}\n    ```", "```cpp\n        auto bitrate() const { return _bitrate; }\n    ```", "```cpp\n        void play() override {\n    ```", "```cpp\n            std::cout << \"Playing audio: \" << title << \", Duration: \" << duration\n    ```", "```cpp\n                      << \"s, Bitrate: \" << bitrate << \"kbps\" << std::endl;\n    ```", "```cpp\n        }\n    ```", "```cpp\n        void pause() override {\n    ```", "```cpp\n            std::cout << \"Audio paused: \" << title << std::endl;\n    ```", "```cpp\n        }\n    ```", "```cpp\n        void stop() override {\n    ```", "```cpp\n            std::cout << \"Audio stopped: \" << title << std::endl;\n    ```", "```cpp\n        }\n    ```", "```cpp\n    };\n    ```", "```cpp\n    class Video : public MediaContent {\n    ```", "```cpp\n    private:\n    ```", "```cpp\n        std::string _resolution; // Resolution as width x height\n    ```", "```cpp\n    public:\n    ```", "```cpp\n        Video(const std::string& title, int duration, const std::string& resolution)\n    ```", "```cpp\n            : MediaContent(title, duration), _resolution(resolution) {}\n    ```", "```cpp\n        auto resolution() const { return _resolution; }\n    ```", "```cpp\n        void play() override {\n    ```", "```cpp\n            std::cout << \"Playing video: \" << title << \", Duration: \" << duration\n    ```", "```cpp\n                      << \"s, Resolution: \" << resolution << std::endl;\n    ```", "```cpp\n        }\n    ```", "```cpp\n        void pause() override {\n    ```", "```cpp\n            std::cout << \"Video paused: \" << title << std::endl;\n    ```", "```cpp\n        }\n    ```", "```cpp\n        void stop() override {\n    ```", "```cpp\n            std::cout << \"Video stopped: \" << title << std::endl;\n    ```", "```cpp\n        }\n    ```", "```cpp\n    };\n    ```", "```cpp\n    int main() {\n    ```", "```cpp\n        Audio my_song(\"Song Example\", 300, 320);\n    ```", "```cpp\n        Video my_movie(\"Movie Example\", 7200, \"1920x1080\");\n    ```", "```cpp\n        my_song.play();\n    ```", "```cpp\n        my_song.pause();\n    ```", "```cpp\n        my_song.stop();\n    ```", "```cpp\n        my_movie.play();\n    ```", "```cpp\n        my_movie.pause();\n    ```", "```cpp\n        my_movie.stop();\n    ```", "```cpp\n        return 0;\n    ```", "```cpp\n    }\n    ```", "```cpp\n    class MediaPlayer {\n    ```", "```cpp\n    private:\n    ```", "```cpp\n        std::vector<std::unique_ptr<MediaContent>> _playlist;\n    ```", "```cpp\n    public:\n    ```", "```cpp\n        void add_media(std::unique_ptr<MediaContent> media) {\n    ```", "```cpp\n            _playlist.push_back(std::move(media));\n    ```", "```cpp\n        }\n    ```", "```cpp\n        void play_all() {\n    ```", "```cpp\n            for (auto& media : _playlist) {\n    ```", "```cpp\n                media->play();\n    ```", "```cpp\n                // Additional controls can be implemented\n    ```", "```cpp\n            }\n    ```", "```cpp\n        }\n    ```", "```cpp\n    };\n    ```", "```cpp\n    int main() {\n    ```", "```cpp\n        MediaPlayer player;\n    ```", "```cpp\n        player.add(std::make_unique<Audio>(\"Jazz in Paris\", 192, 320));\n    ```", "```cpp\n        player.add(std::make_unique<Video>(\"Tour of Paris\", 1200, \"1280x720\"));\n    ```", "```cpp\n        player.play_all();\n    ```", "```cpp\n        return 0;\n    ```", "```cpp\n    }\n    ```", "```cpp\n#include <iostream>\nclass Discount {\nprotected:\n    double _discount_percent;  // Percent of discount\npublic:\n    Discount(double percent) : _discount_percent(percent) {}\n    virtual double apply_discount(double amount) {\n        return amount * (1 - _discount_percent / 100);\n    }\n};\n```", "```cpp\nclass SeasonalDiscount : public Discount {\npublic:\n    SeasonalDiscount(double percent) : Discount(percent) {}\n    double apply_discount(double amount) override {\n        // Let's assume the discount increases by an additional 5% during holidays\n        double additional = 0.05;  // 5% extra during holidays\n        return amount * (1 - (_discount_percent / 100 + additional));\n    }\n};\n```", "```cpp\nclass ClearanceDiscount : public Discount {\npublic:\n    ClearanceDiscount(double percent) : Discount(percent) {}\n    double apply_discount(double amount) override {\n        // Clearance items get an extra 10% off beyond the configured discount\n        double additional = 0.10;  // 10% extra for clearance items\n        return amount * (1 - (_discount_percent / 100 + additional));\n    }\n};\n```", "```cpp\nint main() {\n    Discount regular(20); // 20% regular discount\n    SeasonalDiscount holiday(20); // 20% holiday discount, plus extra\n    ClearanceDiscount clearance(20); // 20% clearance discount, plus extra\n    std::cout << \"Regular Price $100 after discount: $\" << regular.apply_discount(100) << std::endl;\n    std::cout << \"Holiday Price $100 after discount: $\" << holiday.apply_discount(100) << std::endl;\n    std::cout << \"Clearance Price $100 after discount: $\" << clearance.apply_discount(100) << std::endl;\n    return 0;\n}\n```", "```cpp\nclass DiscountStrategy {\npublic:\n    virtual double calculate(double amount) = 0;\n    virtual ~DiscountStrategy() {}\n};\nclass RegularDiscountStrategy : public DiscountStrategy {\npublic:\n    double calculate(double amount) override {\n        return amount * 0.80; // 20% discount\n    }\n};\nclass HolidayDiscountStrategy : public DiscountStrategy {\npublic:\n    double calculate(double amount) override {\n        return amount * 0.75; // 25% discount\n    }\n};\nclass ClearanceDiscountStrategy : public DiscountStrategy {\npublic:\n    double calculate(double amount) override {\n        return amount * 0.70; // 30% discount\n    }\n};\n// Use these strategies in a Discount context class\nclass Discount {\nprivate:\n    std::unique_ptr<DiscountStrategy> _strategy;\npublic:\n    Discount(std::unique_ptr<DiscountStrategy> strat) : _strategy(std::move(strat)) {}\n    double apply_discount(double amount) {\n        return _strategy->calculate(amount);\n    }\n};\n```", "```cpp\nclass Bird {\npublic:\n    virtual void fly() {\n        std::cout << \"This bird flies\" << std::endl;\n    }\n};\nclass Ostrich : public Bird {\npublic:\n    void fly() override {\n        throw std::logic_error(\"Ostriches can't fly!\");\n    }\n};\nvoid make_bird_fly(Bird& b) {\n    b.fly();  // Expecting all birds to fly\n}\n```", "```cpp\nclass Payment {\npublic:\n    virtual void pay(int amount) {\n        if (amount <= 0) {\n            throw std::invalid_argument(\"Amount must be positive\");\n        }\n        std::cout << \"Paying \" << amount << std::endl;\n    }\n};\nclass CreditPayment : public Payment {\npublic:\n    void pay(int amount) override {\n        if (amount < 100) {  // Stricter precondition than the base class\n            throw std::invalid_argument(\"Minimum amount for credit payment is 100\");\n        }\n        std::cout << \"Paying \" << amount << \" with credit\" << std::endl;\n    }\n};\n```", "```cpp\n#include <algorithm>\n#include <vector>\n#include <iostream>\ntemplate <typename T>\nvoid print(const std::vector<T>& vec) {\n    for (const T& elem : vec) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n}\nint main() {\n    std::vector<int> int_vec = {3, 1, 4, 1, 5};\n    std::sort(int_vec.begin(), int_vec.end());\n    print(int_vec); // Outputs: 1 1 3 4 5\n    std::vector<std::string> string_vec = {\"banana\", \"apple\", \"cherry\"};\n    std::sort(string_vec.begin(), string_vec.end());\n    print(string_vec); // Outputs: apple banana cherry\n    return 0;\n}\n```", "```cpp\n#include <vector>\n#include <iostream>\nint main() {\n    std::vector<int> int_vec = {1, 2, 3};\n    std::vector<std::string> string_vec = {\"hello\", \"world\"};\n    for (int val : int_vec) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n    for (const std::string& str : string_vec) {\n        std::cout << str << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n```", "```cpp\nclass BaseObject {};\nclass Vector {\npublic:\n    void push_back(BaseObject* obj);\n};\n```", "```cpp\n#include <memory>\n#include <iostream>\nint main() {\n    std::unique_ptr<int> ptr = std::make_unique<int>(42);\n    std::cout << \"Value: \" << *ptr << std::endl; // Outputs: Value: 42\n    std::shared_ptr<int> shared_ptr = std::make_shared<int>(100);\n    std::cout << \"Shared Value: \" << *shared_ptr << std::endl; // Outputs: Shared Value: 100\n    return 0;\n}\n```", "```cpp\ntemplate <typename T>\nT add(T a, T b) {\n    return a + b;\n}\nint main() {\n    std::cout << add<int>(5, 3) << std::endl;      // Outputs: 8\n    std::cout << add<double>(2.5, 3.5) << std::endl; // Outputs: 6.0\n    return 0;\n}\n```", "```cpp\ntemplate <typename T>\nT add(T a, T b) {\n    return a + b;\n}\nint main() {\n    std::cout << add<int>(5, 3) << std::endl;      // Outputs: 8\n    std::cout << add<double>(2.5, 3.5) << std::endl; // Outputs: 6.0\n    return 0;\n}\n```", "```cpp\nint addInt(int a, int b) {\n    return a + b;\n}\ndouble addDouble(double a, double b) {\n    return a + b;\n}\n```", "```cpp\ntemplate <typename T>\nclass Box {\nprivate:\n    T content;\npublic:\n    void set_content(const T& value) {\n        content = value;\n    }\n    T get_content() const {\n        return content;\n    }\n};\nint main() {\n    Box<int> intBox;\n    intBox.set_content(123);\n    std::cout << intBox.get_content() << std::endl; // Outputs: 123\n    Box<std::string> stringBox;\n    stringBox.set_content(\"Hello Templates!\");\n    std::cout << stringBox.get_content() << std::endl; // Outputs: Hello Templates!\n    return 0;\n}\n```", "```cpp\nclass BoxInt { /*Box<int>*/ };\nclass BoxString { /*Box<int>*/ };\n```", "```cpp\n    int main() {\n    ```", "```cpp\n        std::cout << add(5, 3) << std::endl; // The compiler infers the type as int\n    ```", "```cpp\n        return 0;\n    ```", "```cpp\n    }\n    ```", "```cpp\n    int main() {\n    ```", "```cpp\n        std::cout << add<int>(5, 3) << std::endl; // Explicitly specifies the type as int\n    ```", "```cpp\n        return 0;\n    ```", "```cpp\n    }\n    ```", "```cpp\n    double usd = 100.0;\n    ```", "```cpp\n    double eur = 90.0;\n    ```", "```cpp\n    double total = usd + eur; // Incorrectly adds USD and EUR\n    ```", "```cpp\n    class Currency {\n    ```", "```cpp\n    public:\n    ```", "```cpp\n        virtual std::string name() const = 0;\n    ```", "```cpp\n        virtual ~Currency() = default;\n    ```", "```cpp\n    };\n    ```", "```cpp\n    class USD : public Currency {\n    ```", "```cpp\n    public:\n    ```", "```cpp\n        std::string name() const override { return \"USD\"; }\n    ```", "```cpp\n    };\n    ```", "```cpp\n    class Euro : public Currency {\n    ```", "```cpp\n    public:\n    ```", "```cpp\n        std::string name() const override { return \"EUR\"; }\n    ```", "```cpp\n    };\n    ```", "```cpp\n    // USD and Euro can still be mixed inadvertently\n    ```", "```cpp\n    struct Usd {\n    ```", "```cpp\n        static const std::string &name() {\n    ```", "```cpp\n            static std::string name = \"USD\";\n    ```", "```cpp\n            return name;\n    ```", "```cpp\n        }\n    ```", "```cpp\n    };\n    ```", "```cpp\n    struct Euro {\n    ```", "```cpp\n        static const std::string &name() {\n    ```", "```cpp\n            static std::string name = \"EUR\";\n    ```", "```cpp\n            return name;\n    ```", "```cpp\n        }\n    ```", "```cpp\n    };\n    ```", "```cpp\n    template <typename Currency>\n    ```", "```cpp\n    class Price {\n    ```", "```cpp\n    public:\n    ```", "```cpp\n        Price(int64_t amount) : _amount(amount) {}\n    ```", "```cpp\n        int64_t count() const { return _amount; }\n    ```", "```cpp\n    private:\n    ```", "```cpp\n        int64_t _amount;\n    ```", "```cpp\n    };\n    ```", "```cpp\n    template <typename Currency>\n    ```", "```cpp\n    std::ostream &operator<<(std::ostream &os, const Price<Currency> &price) {\n    ```", "```cpp\n        os << price.count() << \" \" << Currency::name();\n    ```", "```cpp\n        return os;\n    ```", "```cpp\n    }\n    ```", "```cpp\n    template <typename Currency>\n    ```", "```cpp\n    Price<Currency> operator+(const Price<Currency> &lhs, const Price<Currency> &rhs) {\n    ```", "```cpp\n        return Price<Currency>(lhs.count() + rhs.count());\n    ```", "```cpp\n    }\n    ```", "```cpp\n    template <typename Currency>\n    ```", "```cpp\n    Price<Currency> operator-(const Price<Currency> &lhs, const Price<Currency> &rhs) {\n    ```", "```cpp\n        return Price<Currency>(lhs.count() - rhs.count());\n    ```", "```cpp\n    }\n    ```", "```cpp\n    // User can define other arithmetic operations as needed\n    ```", "```cpp\n    int main() {\n    ```", "```cpp\n        Price<Usd> usd(100);\n    ```", "```cpp\n        Price<Euro> euro(90);\n    ```", "```cpp\n        // The following line would cause a compile-time error\n    ```", "```cpp\n        // source>:113:27: error: no match for 'operator+' (operand types are 'Price<Usd>' and 'Price<Euro>')\n    ```", "```cpp\n        // Price<Usd> total= usd + euro;\n    ```", "```cpp\n        Price<Usd> total = usd+ Price<Usd>(50); // Correct usage\n    ```", "```cpp\n        std::cout << total<< std::endl; // Outputs: 150 USD\n    ```", "```cpp\n        return 0;\n    ```", "```cpp\n    }\n    ```", "```cpp\ntemplate <typename TickerT>\nclass Asset;\nstruct Apple {\n    static const std::string &name() {\n        static std::string name = \"AAPL\";\n        return name;\n    }\n    static const std::string &exchange() {\n        static std::string exchange = \"NASDAQ\";\n        return exchange;\n    }\n    using Asset = class Asset<Apple>;\n    using Currency = Usd;\n};\nstruct Mercedes {\n    static const std::string &name() {\n        static std::string name = \"MGB\";\n        return name;\n    }\n    static const std::string &exchange() {\n        static std::string exchange = \"FRA\";\n        return exchange;\n    }\n    using Asset = class Asset<Mercedes>;\n    using Currency = Euro;\n};\ntemplate <typename TickerT>\nclass Asset {\npublic:\n    using Ticker   = TickerT;\n    using Currency = typename Ticker::Currency;\n    Asset(int64_t amount, Price<Currency> price)\n        : _amount(amount), _price(price) {}\n    auto amount() const { return _amount; }\n    auto price() const { return _price; }\nprivate:\n    int64_t _amount;\n    Price<Currency> _price;\n};\ntemplate <typename TickerT>\nstd::ostream &operator<<(std::ostream &os, const Asset<TickerT> &asset) {\n    os << TickerT::name() << \", amount: \" << asset.amount()\n       << \", price: \" << asset.price();\n    return os;\n}\n```", "```cpp\nint main() {\n    Price<Usd> usd_price(100);\n    usd_price = usd_price + Price<Usd>(1);\n    std::cout << usd_price << std::endl; // Outputs: 101 USD\n    Asset<Apple> apple{10, Price<Usd>(100)};\n    Asset<Mercedes> mercedes{5, Price<Euro>(100)};\n    std::cout << apple << std::endl; // Outputs: AAPL, amount: 10, price: 100 USD\n    std::cout << mercedes << std::endl; // Outputs: MGB, amount: 5, price: 100 EUR\n    return 0;\n}\n```", "```cpp\nPrice<Usd> usdPrice(100);\nPrice<Euro> euroPrice(90);\nAsset<Apple> appleAsset(10, Price<Usd>(100));\nAsset<Mercedes> mercedesAsset(5, Price<Euro>(100));\n```", "```cpp\ntemplate <typename T>\nclass Price {\n    // Implementation\n};\nPrice<int> price(100); // Intended to be Price<Usd> but mistakenly used int\n```", "```cpp\nstruct BaseCurrency {\n};\nstruct Usd : public BaseCurrency {\n    static const std::string &name() {\n        static std::string name = \"USD\";\n        return name;\n    }\n};\n// Define a concept for currency classes\ntemplate<class T, class U>\nconcept Derived = std::is_base_of<U, T>::value;\n// Make sure that template parameter is derived from BaseCurrency\ntemplate <Derived<BaseCurrency> CurrencyT>\nclass Price {\npublic:\n    Price(int64_t amount) : _amount(amount) {}\n    int64_t count() const { return _amount; }\nprivate:\n    int64_t _amount;\n};\n```", "```cpp\nIn function 'int main()':\nerror: template constraint failure for 'template<class CurrencyT>  requires  Derived<CurrencyT, Currency> class Price'\n auto p = Price<int>(100);\n                   ^\nnote: constraints not satisfied\nIn substitution of 'template<class CurrencyT>  requires  Derived<CurrencyT, Currency> class Price [with CurrencyT = int]':\n```", "```cpp\ntemplate <typename CurrencyT,\n          typename Unused=typename std::enable_if<std::is_base_of<BaseCurrency,CurrencyT>::value>::type>\nclass Price {\npublic:\n    Price(int64_t amount) : _amount(amount) {}\n    int64_t count() const { return _amount; }\nprivate:\n    int64_t _amount;\n};\n```", "```cpp\nerror: no type named 'type' in 'struct std::enable_if<false, void>'\nauto p = Price<int>(100);\n      |                       ^\nerror: template argument 2 is invalid\n```", "```cpp\n#include <iostream>\n#include <string>\n// General template\ntemplate <typename T>\nclass Printer {\npublic:\n    void print(const T& value) {\n        std::cout << value << std::endl;\n    }\n};\n// Template specialization for std::string\ntemplate <>\nclass Printer<std::string> {\npublic:\n    void print(const std::string& value) {\n        std::cout << \"\\\"\" << value << \"\\\"\" << std::endl;\n    }\n};\nint main() {\n    Printer<int> int_printer;\n    int_printer.print(123); // Outputs: 123\n    Printer<std::string> string_printer;\n    string_printer.print(\"Hello, World!\"); // Outputs: \"Hello, World!\" with quotes\n    return 0;\n}\n```", "```cpp\n#ifndef PRINTER_H\n#define PRINTER_H\n#include <iostream>\ntemplate <typename T>\nclass Printer {\npublic:\n    void print(const T& value) {\n        std::cout << value << std::endl;\n    }\n};\n#endif // PRINTER_H\n```", "```cpp\n#ifndef PRINTER_STRING_H\n#define PRINTER_STRING_H\n#include \"printer.h\"\n#include <string>\ntemplate <>\nclass Printer<std::string> {\npublic:\n    void print(const std::string& value) {\n        std::cout << \"\\\"\" << value << \"\\\"\" << std::endl;\n    }\n};\n#endif // PRINTER_STRING_H\n```", "```cpp\n#include \"printer.h\"\n// #include \"printer_string.h\" // Uncomment this line to use the specialization\nint main() {\n    Printer<int> int_printer;\n    int_printer.print(123); // Outputs: 123\n    Printer<std::string> string_printer;\n    string_printer.print(\"Hello, World!\"); // Outputs: Hello, World! without quotes if the header is not included\n    return 0;\n}\n```"]