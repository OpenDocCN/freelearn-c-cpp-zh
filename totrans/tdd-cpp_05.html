<html><head></head><body>
		<div id="_idContainer012">
			<h1 id="_idParaDest-46" class="chapter-number" lang="en-GB"><a id="_idTextAnchor045"/>5</h1>
			<h1 id="_idParaDest-47" lang="en-GB"><a id="_idTextAnchor046"/>Adding More Confirm Types</h1>
			<p lang="en-GB">The previous chapter introduced confirmations and showed you how to use them to verify that the bool values within your tests match what you expect them to be. The chapter did this with some exploratory code based on a school grading example. We’re going to change the grading example to better fit with a test library and add additional types that you will be able to use in your confirms.</p>
			<p lang="en-GB">In this chapter, we will cover the following main topics:</p>
			<ul>
				<li lang="en-GB">Fixing the bool confirms</li>
				<li lang="en-GB">Confirming equality</li>
				<li lang="en-GB">Changing the code to fix a problem that line numbers are causing with test failures</li>
				<li lang="en-GB">Adding more confirm types</li>
				<li lang="en-GB">Confirming string literals</li>
				<li lang="en-GB">Confirming floating-point values</li>
				<li lang="en-GB">How to write confirms</li>
			</ul>
			<p lang="en-GB">The additional types add some new twists to confirms that, in this chapter, you’ll learn how to work around. By the end of this chapter, you’ll be able to write tests that can verify any result you need to be tested.</p>
			<h1 id="_idParaDest-48" lang="en-GB"><a id="_idTextAnchor047"/>Technical requirements</h1>
			<p lang="en-GB"><a id="_idTextAnchor048"/><a id="_idTextAnchor049"/>All of the code in this chapter uses standard C++ that builds on any modern C++ 17, or later, compiler and standard library. The code is based on and continues from the previous chapters.</p>
			<p lang="en-GB">You can find all the code for this chapter at the following GitHub repository:</p>
			<p lang="en-GB"><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</a></p>
			<h1 id="_idParaDest-49" lang="en-GB"><a id="_idTextAnchor050"/>Fixing the bool confirms</h1>
			<p lang="en-GB">The previous chapter explored<a id="_idIndexMarker123"/> what it means to confirm a value. However, it left us with some temporary code that we need to fix. Let’s start by fixing the code in <strong class="source-inline" lang="">Confirm.cpp</strong> so that it no longer refers to school grades. We want confirms to work with types such as bool. That’s why the confirm macros we have now are called <strong class="source-inline" lang="">CONFIRM_TRUE</strong> and <strong class="source-inline" lang="">CONFIRM_FALSE</strong>. The mention of true and false in the macro names are the expected values. Additionally, the macros accept a single parameter, which is the actual value.</p>
			<p lang="en-GB">Instead of a test about passing grades, let’s replace it with a test about bools like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test bool confirms")
{
    bool result = isNegative(0);
    CONFIRM_FALSE(result);
    result = isNegative(-1);
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The new test is clear about what it tests and needs a new helper function called <strong class="source-inline" lang="">isNegative</strong> instead of the previous function that determined whether a grade was passing or not. I wanted something that is simple and can be used to generate a result with an obvious expected value. The <strong class="source-inline" lang="">isNegative</strong> function replaces the previous <strong class="source-inline" lang="">isPassingGrade</strong> function and looks like this:</p>
			<pre class="source-code" lang="en-GB">
bool isNegative (int value)
{
    return value &lt; 0;
}</pre>
			<p lang="en-GB">This is a simple change that removes the exploratory code based on grades and gives us something that now fits in the test library. Now, in the next section, we can continue with confirms that test for equality.</p>
			<h1 id="_idParaDest-50" lang="en-GB"><a id="_idTextAnchor051"/>Confirming equality</h1>
			<p lang="en-GB">In a way, the bool confirms<a id="_idIndexMarker124"/> do test for equality. They ensure that the actual bool value is equal to the expected value. This is what the new confirms that are introduced in this chapter will do, too. The only difference is that the <strong class="source-inline" lang="">CONFIRM_TRUE</strong> and <strong class="source-inline" lang="">CONFIRM_FALSE</strong> confirms don’t need to accept a parameter for <a id="_idIndexMarker125"/>the expected value. Their expected value is implied in their name. We can do this for bool types because there are only two possible values.</p>
			<p lang="en-GB">However, let’s say that we want to verify that an actual int value equals 1. Do we really want a macro that’s called <strong class="source-inline" lang="">CONFIRM_1</strong>? We would need billions of macros for each possible 32-bit int and even more for a 64-bit int. And verifying text strings to make sure they match expected values becomes impossible with this approach.</p>
			<p lang="en-GB">Instead, all we need to do is modify the macros for the other types to accept both an expected value and an actual value. If the two values are not equal to each other, then the macros should result in the test failing with an appropriate message that explains what was expected and what was actually received.</p>
			<p lang="en-GB">Macros are not designed to resolve different types. They perform simple text replacement only. We’ll need real C++ functions to work properly with the different types we’ll be checking. Additionally, we might as well change the existing bool macros to call a function instead of defining the code directly inside the macro. Here are the existing bool macros, as we defined them in the previous chapter:</p>
			<pre class="source-code" lang="en-GB">
#define CONFIRM_FALSE( actual ) \
if (actual) \
{ \
    throw MereTDD::BoolConfirmException(false, __LINE__); \
}
#define CONFIRM_TRUE( actual ) \
if (not actual) \
{ \
    throw MereTDD::BoolConfirmException(true, __LINE__); \
}</pre>
			<p lang="en-GB">What we need to do is move the <strong class="source-inline" lang="">if</strong> and <strong class="source-inline" lang="">throw</strong> statements into a function. We only need one function for both true and false, and it will look like this:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    bool expected,
    bool actual,
    int line)
{
    if (actual != expected)
    {
        throw BoolConfirmException(expected, line);
    }
}</pre>
			<p lang="en-GB">This function can be placed in <strong class="source-inline" lang="">Test.h</strong> inside the <strong class="source-inline" lang="">MereTDD</strong> namespace right before <strong class="source-inline" lang="">TestBase</strong> is defined. The function needs to be inline and no longer needs to qualify the exception with the namespace since it’s now inside the same namespace.</p>
			<p lang="en-GB">Also, you can see better<a id="_idIndexMarker126"/> that this is an equality comparison even for bool values. The function checks to make sure that the actual value is equal to the expected value, and if not, then it throws an exception. The macros can be simplified to call the new function like this:</p>
			<pre class="source-code" lang="en-GB">
#define CONFIRM_FALSE( actual ) \
    MereTDD::confirm(false, actual, __LINE__)
#define CONFIRM_TRUE( actual ) \
    MereTDD:: confirm(true, actual, __LINE__)</pre>
			<p lang="en-GB">Building and running show that all of the tests pass, and we are ready to add additional types to confirm. Let’s start with a new test in <strong class="source-inline" lang="">Confirm.cpp</strong> for int types like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test int confirms")
{
    int result = multiplyBy2(0);
    CONFIRM(0, result);
    result = multiplyBy2(1);
    CONFIRM(2, result);
    result = multiplyBy2(-1);
    CONFIRM(-2, result);
}</pre>
			<p lang="en-GB">Instead of a bools, this code tests int values. It uses a new helper function that should be simple to understand, which just multiplies a value by 2. We need the new helper function to be declared at the top of the same file like this:</p>
			<pre class="source-code" lang="en-GB">
int multiplyBy2 (int value)
{
    return value * 2;
}</pre>
			<p lang="en-GB">The test won’t build yet. That’s okay because, when using a TDD approach, we want to focus on the usage first. This usage seems good. It will let us confirm that any int value is equal to whatever we expect it to be. Let’s create the <strong class="source-inline" lang="">CONFIRM</strong> macro and place it right after the two existing<a id="_idIndexMarker127"/> macros that confirm true and false like this:</p>
			<pre class="source-code" lang="en-GB">
#define CONFIRM_FALSE( actual ) \
    MereTDD::confirm(false, actual, __LINE__)
#define CONFIRM_TRUE( actual ) \
    MereTDD:: confirm(true, actual, __LINE__)
#define CONFIRM( expected, actual ) \
    MereTDD::confirm(expected, actual, __LINE__)</pre>
			<p lang="en-GB">Changing the macros to call a function is really paying off now. The <strong class="source-inline" lang="">CONFIRM</strong> macro needs an extra parameter for the expected value, and it can call the same function name. How can it call the same function, though? Well, that’s because we’re going to overload the function. What we have now only works for bool values. This is why we switched to a design that can make use of data types. All we need to do is provide another implementation of <strong class="source-inline" lang="">confirm</strong> that is overloaded to work with ints like this:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    int expected,
    int actual,
    int line)
{
    if (actual != expected)
    {
        throw ActualConfirmException(expected, actual, line);
    }
}</pre>
			<p lang="en-GB">This is almost identical to the existing <strong class="source-inline" lang="">confirm</strong> function. It takes ints for the expected and actual parameters instead of bools and will throw a new exception type. The reason for the new exception type is so that we can format a failure message that will display both the expected and actual values. The <strong class="source-inline" lang="">BoolConfirmException</strong> type will only be used for bools and will format a message that only mentions what was expected. Additionally, the new <strong class="source-inline" lang="">ActualConfirmException</strong> type will format a message that mentions both the expected and actual values.</p>
			<p lang="en-GB">The new exception type looks like this:</p>
			<pre class="source-code" lang="en-GB">
class ActualConfirmException : public ConfirmException
{
public:
    ActualConfirmException (int expected, int actual, int line)
    : mExpected(std::to_string(expected)),
      mActual(std::to_string(actual)),
      mLine(line)
    {
        formatReason();
    }
private:
    void formatReason ()
    {
        mReason =  "Confirm failed on line ";
        mReason += std::to_string(mLine) + "\n";
        mReason += "    Expected: " + mExpected + "\n";
        mReason += "    Actual  : " + mActual;
    }
    std::string mExpected;
    std::string mActual;
    int mLine;
};</pre>
			<p lang="en-GB">You might be wondering why<a id="_idIndexMarker128"/> the new exception type stores the expected and actual values as strings. The constructor accepts ints and then converts the ints into strings before formatting the reason. This is because we’ll be adding multiple data types, and we don’t really need to do anything different. Each type just needs to display a descriptive message based on strings when a test fails.</p>
			<p lang="en-GB">We don’t need to use the expected or actual values for any calculations. They just need to be formatted into a readable message. Additionally, this design will let us use a single exception for all the data types other than bool. We could use this new exception for bools too, but the message doesn’t need to mention the actual value for bools. So, we’ll keep the existing exception for bools and use this new exception type for everything else.</p>
			<p lang="en-GB">By storing the expected and actual values as strings, all we need is an overloaded constructor for each new data type we want to support. Each constructor can convert the expected and actual values into strings that can then be formatted into a readable message. This is better than having an <strong class="source-inline" lang="">IntActualConfirmException</strong> class, a <strong class="source-inline" lang="">StringActualConfirmException</strong> class, and more.</p>
			<p lang="en-GB">We can build and run the tests again. The results for both the bool and int tests look like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test bool confirms</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test int confirms</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">---------------</strong></pre>
			<p lang="en-GB">So, what happens<a id="_idIndexMarker129"/> if the confirms fail? Well, we’ve already seen in the previous chapter what a failed bool confirm looks like. But we don’t yet have any tests for failure cases. We should add them and make them expected failures so that the behavior can be captured. Even a failure should be tested to make sure it remains a failure. It would be bad if, in the future, we made some changes to the code that turned a failure into a success. That would be a breaking change because a failure should be expected. Let’s add a couple of new tests to <strong class="source-inline" lang="">Confirm.cpp</strong> like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test bool confirm failure")
{
    bool result = isNegative(0);
    CONFIRM_TRUE(result);
}
TEST("Test int confirm failure")
{
    int result = multiplyBy2(1);
    CONFIRM(0, result);
}</pre>
			<p lang="en-GB">We get the expected failures, and they look like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test bool confirm failure</strong>
<strong class="bold" lang="">Failed</strong>
<strong class="bold" lang="">Confirm failed on line 41</strong>
<strong class="bold" lang="">    Expected: true</strong>
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test int confirm failure</strong>
<strong class="bold" lang="">Failed</strong>
<strong class="bold" lang="">Confirm failed on line 47</strong>
<strong class="bold" lang="">    Expected: 0</strong>
<strong class="bold" lang="">    Actual  : 2</strong>
<strong class="bold" lang="">---------------</strong></pre>
			<p lang="en-GB">The next step<a id="_idIndexMarker130"/> is to set the expected failure messages so that these tests pass instead of fail. However, there’s a problem. The line number is part of the error message. We want the line number to be displayed in the test results. But that means we also have to include the line number in the expected failure message in order to treat the failures as passing. Why is this a problem? Well, that’s because every time a test is moved or even when other tests are added or removed, the line numbers will change. We don’t want to have to change the expected error messages for something that is not really part of the error. The line number tells us where the error happened and should not be part of the reason for why it happened.</p>
			<p lang="en-GB">In the next section, we’ll fix the line numbers with some refactoring.</p>
			<h1 id="_idParaDest-51" lang="en-GB"><a id="_idTextAnchor052"/>Decoupling test failures from line numbers</h1>
			<p lang="en-GB">We need to remove the line<a id="_idIndexMarker131"/> number from the confirm failure<a id="_idIndexMarker132"/> reason so that tests can be given an expected failure reason that won’t change as the test is moved or shifted to different locations in the source code file.</p>
			<p lang="en-GB">This type of change is called <em class="italic" lang="">refactoring</em>. We’re not going to make any<a id="_idIndexMarker133"/> changes that cause different or new behaviors to appear in the code. At least, that’s the goal. Using TDD will help you refactor your code because you should already have tests in place for all of the important aspects.</p>
			<p lang="en-GB">Refactoring with proper tests lets you verify that nothing has changed. Many times, refactoring without TDD is avoided because the risk of introducing new bugs is too great. This tends to make problems bigger, as the refactoring is delayed or avoided entirely.</p>
			<p lang="en-GB">We have a problem with the line numbers. We could ignore the problem and just update the tests with new line numbers in the expected failure messages anytime a change is made. But that is not right and will only lead to more work and brittle tests. As more tests are added, the problem will only get worse. We really should fix the problem now. Because we’re following TDD, we can feel confident that the changes we are about to make will not break anything that has already been tested. Or, at least, if it does break, we’ll know about it and can fix any breaks right away.</p>
			<p lang="en-GB">The first step is to add line number information to the <strong class="source-inline" lang="">ConfirmException</strong> base class in <strong class="source-inline" lang="">Test.cpp</strong>:</p>
			<pre class="source-code" lang="en-GB">
class ConfirmException
{
public:
    ConfirmException (int line)
    : mLine(line)
    { }
    virtual ~ConfirmException () = default;
    std::string_view reason () const
    {
        return mReason;
    }
    int line () const
    {
        return mLine;
    }
protected:
    std::string mReason;
    int mLine;
};</pre>
			<p lang="en-GB">Then, in the <strong class="source-inline" lang="">runTests</strong> function, we can<a id="_idIndexMarker134"/> get the line from the confirm<a id="_idIndexMarker135"/> exception and use it to set the failure location in the test like this:</p>
			<pre class="source-code" lang="en-GB">
        try
        {
            test-&gt;runEx();
        }
        catch (ConfirmException const &amp; ex)
        {
            test-&gt;setFailed(ex.reason(), ex.line());
        }</pre>
			<p lang="en-GB">Even though we are not starting with a test, notice how I’m still following a TDD approach to writing the code, as I’d like it to be used before implementing it fully. This is a great example because I originally thought about adding a new method to the test class. It was called <strong class="source-inline" lang="">setFailedLocation</strong>. But that made the existing <strong class="source-inline" lang="">setFailed</strong> method seem<a id="_idIndexMarker136"/> strange. I almost renamed <strong class="source-inline" lang="">setFailed</strong> to <strong class="source-inline" lang="">setFailedReason</strong>, which would have meant<a id="_idIndexMarker137"/> that it would need to be changed in the other places it’s called. Instead, I decided to add an extra parameter for the line number to the existing <strong class="source-inline" lang="">setFailed</strong> method. I also decided to give the parameter a default value so that the other code would not need to be changed. This makes sense and lets the caller set the failed reason by itself or with a line number if known.</p>
			<p lang="en-GB">We need to add a line number data member to the <strong class="source-inline" lang="">TestBase</strong> class. The line number will only be known for confirms, so it will be called <strong class="source-inline" lang="">mConfirmLocation</strong> like this:</p>
			<pre class="source-code" lang="en-GB">
    std::string mName;
    bool mPassed;
    std::string mReason;
    std::string mExpectedReason;
    int mConfirmLocation;
};</pre>
			<p lang="en-GB">The new data member needs to be initialized in the <strong class="source-inline" lang="">TestBase</strong> constructor. We’ll use the value of -1 to mean that the line number location is not applicable:</p>
			<pre class="source-code" lang="en-GB">
    TestBase (std::string_view name)
    : mName(name), mPassed(true), mConfirmLocation(-1)
    { }</pre>
			<p lang="en-GB">We need to add the line number parameter to the <strong class="source-inline" lang="">setFailed</strong> method like this:</p>
			<pre class="source-code" lang="en-GB">
    void setFailed (std::string_view reason,          int confirmLocation = -1)
    {
        mPassed = false;
        mReason = reason;
        mConfirmLocation = confirmLocation;
    }</pre>
			<p lang="en-GB">Additionally, we need to add a new getter method for the confirm location like this:</p>
			<pre class="source-code" lang="en-GB">
    int confirmLocation () const
    {
        return mConfirmLocation;
    }</pre>
			<p lang="en-GB">This will let the <strong class="source-inline" lang="">runTests</strong> function set the line number when it catches a confirm exception, and the test will be able to remember the line number. At the end of <strong class="source-inline" lang="">runTests</strong>, where the failure message is sent to the output, we need to test <strong class="source-inline" lang="">confirmLocation</strong> and change the output if we have a line number or not, as follows:</p>
			<pre class="source-code" lang="en-GB">
        else
        {
            ++numFailed;
            if (test-&gt;confirmLocation() != -1)
            {
                output &lt;&lt; "Failed confirm on line "
                    &lt;&lt; test-&gt;confirmLocation() &lt;&lt; "\n";
            }
            else
            {
                output &lt;&lt; "Failed\n";
            }
            output &lt;&lt; test-&gt;reason()
                &lt;&lt; std::endl;
        }</pre>
			<p lang="en-GB">This will<a id="_idIndexMarker138"/> also fix a minor<a id="_idIndexMarker139"/> problem with confirms. Previously, the test results printed a line that said the test failed and then another line that said a confirm failed. The new code will only display either a generic failed message or a confirm failed message with a line number.</p>
			<p lang="en-GB">We’re not done yet. We need to change both derived exception class constructors to initialize the base class line number and to stop including the line number as part of the reason. The constructor for <strong class="source-inline" lang="">BoolConfirmException</strong> looks like this:</p>
			<pre class="source-code" lang="en-GB">
    BoolConfirmException (bool expected, int line)
    : ConfirmException(line)
    {
        mReason += "    Expected: ";
        mReason += expected ? "true" : "false";
    }</pre>
			<p lang="en-GB">Additionally, the <strong class="source-inline" lang="">ActualConfirmException</strong> class needs to be changed throughout. The constructor needs to initialize the base class with the line number, the formatting needs to change, and the line number data member can be removed since it’s now in the base class. The class looks like this:</p>
			<pre class="source-code" lang="en-GB">
class ActualConfirmException : public ConfirmException
{
public:
    ActualConfirmException (int expected, int actual, int line)
    : ConfirmException(line),
      mExpected(std::to_string(expected)),
      mActual(std::to_string(actual))
    {
        formatReason();
    }
private:
    void formatReason ()
    {
        mReason += "    Expected: " + mExpected + "\n";
        mReason += "    Actual  : " + mActual;
    }
    std::string mExpected;
    std::string mActual;
};</pre>
			<p lang="en-GB">We can build again<a id="_idIndexMarker140"/> and running still shows the expected<a id="_idIndexMarker141"/> failures. The failure reasons are formatted slightly differently than before and look like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test bool confirm failure</strong>
<strong class="bold" lang="">Failed confirm on line 41</strong>
<strong class="bold" lang="">    Expected: true</strong>
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test int confirm failure</strong>
<strong class="bold" lang="">Failed confirm on line 47</strong>
<strong class="bold" lang="">    Expected: 0</strong>
<strong class="bold" lang="">    Actual  : 2</strong>
<strong class="bold" lang="">---------------</strong></pre>
			<p lang="en-GB">It looks almost the same, which is good. Now we can set the expected failure messages without needing to worry about the line numbers like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test bool confirm failure")
{
    std::string reason = "    Expected: true";
    setExpectedFailureReason(reason);
    bool result = isNegative(0);
    CONFIRM_TRUE(result);
}
TEST("Test int confirm failure")
{
    std::string reason = "    Expected: 0\n";
    reason += "    Actual  : 2";
    setExpectedFailureReason(reason);
    int result = multiplyBy2(1);
    CONFIRM(0, result);
}</pre>
			<p lang="en-GB">Notice that the expected<a id="_idIndexMarker142"/> failure reason needs to be formatted<a id="_idIndexMarker143"/> to exactly match what the test displays when it fails. This includes spaces used to indent and new lines. Once the expected failure reasons are set, all of the tests pass again like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test bool confirm failure</strong>
<strong class="bold" lang="">Expected failure</strong>
<strong class="bold" lang="">    Expected: true</strong>
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test int confirm failure</strong>
<strong class="bold" lang="">Expected failure</strong>
<strong class="bold" lang="">    Expected: 0</strong>
<strong class="bold" lang="">    Actual  : 2</strong>
<strong class="bold" lang="">---------------</strong></pre>
			<p lang="en-GB">Both tests are expected failures and are treated as passing. Now we can continue adding more confirm types.</p>
			<h1 id="_idParaDest-52" lang="en-GB"><a id="_idTextAnchor053"/>Adding more confirm types</h1>
			<p lang="en-GB">Currently, we can confirm<a id="_idIndexMarker144"/> bool and int values inside the tests. We need more than this, so what should we add next? Let’s add support for the long type. It’s similar to an int and, on many platforms, will effectively be the same. Even though it may or may not use the same number of bits as an int, to the C++ compiler, it is a different type. We can begin by adding a basic test to <strong class="source-inline" lang="">Confirm.cpp</strong> that tests the long type like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test long comfirms")
{
    long result = multiplyBy2(0L);
    CONFIRM(0L, result);
    result = multiplyBy2(1L);
    CONFIRM(2L, result);
    result = multiplyBy2(-1L);
    CONFIRM(-2L, result);
}</pre>
			<p lang="en-GB">The test calls the same <strong class="source-inline" lang="">multiplyBy2</strong> helper<a id="_idIndexMarker145"/> function, which performs extra conversions because it’s not working with longs throughout. We start with long literal values by adding the <strong class="source-inline" lang="">L</strong> suffix. These get converted into ints in order to be passed to <strong class="source-inline" lang="">multiplyBy2</strong>. The return value is also an int, which gets converted into a long in order to be assigned to <strong class="source-inline" lang="">result</strong>. Let’s prevent all of this extra conversion by creating an overloaded version of <strong class="source-inline" lang="">multiplyBy2</strong> that accepts a long type and returns a long type:</p>
			<pre class="source-code" lang="en-GB">
long multiplyBy2 (long value)
{
    return value * 2L;
}</pre>
			<p lang="en-GB">If we try to build right now, there will be an error because the compiler doesn’t know which overload of <strong class="source-inline" lang="">confirm</strong> to call. The only available choices are to either convert the long expected and actual values into ints or bools. Neither choice is a match, and the compiler sees the call as ambiguous. Remember that the <strong class="source-inline" lang="">CONFIRM</strong> macro gets transformed into a call to the overloaded <strong class="source-inline" lang="">confirm</strong> function.</p>
			<p lang="en-GB">We can fix this by adding a new overloaded version of <strong class="source-inline" lang="">confirm</strong> that uses long parameters. However, a better solution is to change the existing version of <strong class="source-inline" lang="">confirm</strong> that uses int parameters into a template like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
void confirm (
    T const &amp; expected,
    T const &amp; actual,
    int line)
{
    if (actual != expected)
    {
        throw ActualConfirmException(
            std::to_string(expected),
            std::to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">We still have the version of <strong class="source-inline" lang="">confirm</strong> that uses<a id="_idIndexMarker146"/> a bool parameter. The template will match both int and long types. Additionally, the template will match types that we don’t yet have tests for. The new templated <strong class="source-inline" lang="">confirm</strong> method also does the conversion into <strong class="source-inline" lang="">std::string</strong> when creating the exception to be thrown. In <a href="B18567_12.xhtml#_idTextAnchor123"><em class="italic" lang="">Chapter 12</em></a>, <em class="italic" lang="">Creating Better Test Confirmations</em>, you’ll see that there is a problem with how we convert the expected and actual values into strings. Or, at least, there is a better way. What we have does work but only for numeric types that can be passed to <strong class="source-inline" lang="">std::to_string</strong>.</p>
			<p lang="en-GB">Let’s update the <strong class="source-inline" lang="">ActualConfirmException</strong> constructor to use strings that we will now be calling <strong class="source-inline" lang="">std::to_string</strong> from within the <strong class="source-inline" lang="">confirm</strong> function. The constructor looks like this:</p>
			<pre class="source-code" lang="en-GB">
    ActualConfirmException (
        std::string_view expected,
        std::string_view actual,
        int line)
    : ConfirmException(line),
      mExpected(expected),
      mActual(actual)
    {
        formatReason();
    }</pre>
			<p lang="en-GB">Everything builds, and all the tests pass again. We can add a new test in <strong class="source-inline" lang="">Confirm.cpp</strong> for a long failure like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test long confirm failure")
{
    std::string reason = "    Expected: 0\n";
    reason += "    Actual  : 2";
    setExpectedFailureReason(reason);
    long result = multiplyBy2(1L);
    CONFIRM(0L, result);
}</pre>
			<p lang="en-GB">The failure reason string is the same as for an int even though we are testing a long type. The test result for the new test looks like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test long confirm failure</strong>
<strong class="bold" lang="">Expected failure</strong>
<strong class="bold" lang="">    Expected: 0</strong>
<strong class="bold" lang="">    Actual  : 2</strong>
<strong class="bold" lang="">---------------</strong></pre>
			<p lang="en-GB">Let’s try a type that will show<a id="_idIndexMarker147"/> something different. A <strong class="source-inline" lang="">long long</strong> type can definitely hold numeric values that are bigger than an int. Here is a new test in <strong class="source-inline" lang="">Confirm.cpp</strong> that tests <strong class="source-inline" lang="">long long</strong> values:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test long long confirms")
{
    long long result = multiplyBy2(0LL);
    CONFIRM(0LL, result);
    result = multiplyBy2(10'000'000'000LL);
    CONFIRM(20'000'000'000LL, result);
    result = multiplyBy2(-10'000'000'000LL);
    CONFIRM(-20'000'000'000LL, result);
}</pre>
			<p lang="en-GB">With a <strong class="source-inline" lang="">long long</strong> type, we can have values greater than a maximum 32-bit signed value. The code uses single quote marks to make the larger numbers easier to read. The compiler ignores the single quote marks, but they help us to visually separate every group of thousands. Also, the suffix, <strong class="source-inline" lang="">LL</strong>, tells the compiler to treat the literal value as a <strong class="source-inline" lang="">long long</strong> type.</p>
			<p lang="en-GB">The result for this passing test looks like the others:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test long long confirms</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">---------------</strong></pre>
			<p lang="en-GB">We need to look at a <strong class="source-inline" lang="">long long</strong> failure test result to see the larger numbers. Here is a failure test:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test long long confirm failure")
{
    std::string reason = "    Expected: 10000000000\n";
    reason += "    Actual  : 20000000000";
    setExpectedFailureReason(reason);
    long long result = multiplyBy2(10'000'000'000LL);
    CONFIRM(10'000'000'000LL, result);
}</pre>
			<p lang="en-GB">Because we’re not formatting<a id="_idIndexMarker148"/> the output with separators, we need to use the unadorned numbers in text format without any commas. This is probably for the best anyway because some locales use commas and some use dots. Note that we don’t try to do any formatting, so the expected failure message also uses no formatting.</p>
			<p lang="en-GB">Now we can see that the failure description does indeed match the larger numbers and looks like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test long long confirm failure</strong>
<strong class="bold" lang="">Expected failure</strong>
<strong class="bold" lang="">    Expected: 10000000000</strong>
<strong class="bold" lang="">    Actual  : 20000000000</strong>
<strong class="bold" lang="">---------------</strong></pre>
			<p lang="en-GB">I want to highlight one important point about failure tests. They are purposefully using incorrect expected values to force a failure. You will not do this in your tests. But then you also will not need to write tests that you <em class="italic" lang="">want</em> to fail. We want these tests to fail so that we can verify that the test library is able to properly detect and handle any failures. Because of this, we treat the failures as passes.</p>
			<p lang="en-GB">We could keep going and add tests for shorts, chars, and all of the unsigned versions. However, this is becoming uninteresting at this point because all we are doing is testing that the template function works properly. Instead, let’s focus on types that use non-template code that has been written to work properly.</p>
			<p lang="en-GB">Here is a simple test for the string type:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test string confirms")
{
    std::string result = "abc";
    std::string expected = "abc";
    CONFIRM(expected, result);
}</pre>
			<p lang="en-GB">Instead of writing a fake helper <a id="_idIndexMarker149"/>method that returns a string, this test simply declares two strings and will use one as the actual value and the other as the expected value. By initializing both strings with the same text, we expect them to be equal, so we call <strong class="source-inline" lang="">CONFIRM</strong> to make sure they are equal.</p>
			<p lang="en-GB">When you are writing a test, you will want to assign <strong class="source-inline" lang="">result</strong> a value that you get from the function or method that you are testing. Our goal here is to test that the <strong class="source-inline" lang="">CONFIRM</strong> macro and the underlying test library code work properly. So, we can skip the function being tested and go straight to the macro with two string values where we know what to expect.</p>
			<p lang="en-GB">This seems like a reasonable test. And it is. But it doesn’t compile. The problem is that the <strong class="source-inline" lang="">confirm</strong> template function tries to call <strong class="source-inline" lang="">std::to_string</strong> on the values provided. This doesn’t make sense when the values are already strings.</p>
			<p lang="en-GB">What we need is a new overload of <strong class="source-inline" lang="">confirm</strong> that uses strings. We’ll actually create two overloads, one for string views and one for strings. The first overload function looks like this:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    std::string_view expected,
    std::string_view actual,
    int line)
{
    if (actual != expected)
    {
        throw ActualConfirmException(
            expected,
            actual,
            line);
    }
}</pre>
			<p lang="en-GB">This first function takes string views, which will be a better match than the template method when working with string views. Then, it passes the strings given to the <strong class="source-inline" lang="">ActualConfirmException</strong> constructor without trying to call <strong class="source-inline" lang="">std::to_string</strong> because they are already strings.</p>
			<p lang="en-GB">The second overloaded function looks like this:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    std::string const &amp; expected,
    std::string const &amp; actual,
    int line)
{
    confirm(
        std::string_view(expected),
        std::string_view(actual),
        line);
}</pre>
			<p lang="en-GB">This second function takes constant string references, which will also be a better match than the template method when working with strings. Then, it converts the strings into string views and calls the first function.</p>
			<p lang="en-GB">Now we can add a string failure test like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test string confirm failure")
{
    std::string reason = "    Expected: def\n";
    reason += "    Actual  : abc";
    setExpectedFailureReason(reason);
    std::string result = "abc";
    std::string expected = "def";
    CONFIRM(expected, result);
}</pre>
			<p lang="en-GB">The test result after building and running the tests looks like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test string confirm failure</strong>
<strong class="bold" lang="">Expected failure</strong>
<strong class="bold" lang="">    Expected: def</strong>
<strong class="bold" lang="">    Actual  : abc</strong>
<strong class="bold" lang="">---------------</strong></pre>
			<p lang="en-GB">There’s one more important <a id="_idIndexMarker150"/>aspect to consider about strings. We need to consider string literals that are really constant char pointers. We’ll explore pointers followed by string literals in the next section.</p>
			<h1 id="_idParaDest-53" lang="en-GB"><a id="_idTextAnchor054"/>Confirming string literals</h1>
			<p lang="en-GB">A string literal might<a id="_idIndexMarker151"/> look like a string, but the C++ compiler treats a string literal as a pointer to the first of a set of constant chars. The set of constant chars is terminated with a null character value, which is the numeric value of zero. That’s how the compiler knows how long the string is. It just keeps going until it finds the null. The reason that the chars are constant is that the data is normally stored in memory that is write protected, so it cannot be modified.</p>
			<p lang="en-GB">When we try to confirm a string<a id="_idIndexMarker152"/> literal, the compiler sees a pointer and has to decide which overloaded <strong class="source-inline" lang="">confirm</strong> function to call. Before we get too far with our exploration of string literals, what other problems can we get into with pointers?</p>
			<p lang="en-GB">Let’s start with the simple bool type and see what kinds of problems we run into if we try to confirm bool pointers. This will help you to understand string literal pointers by, first, understanding a simpler example test for bool pointers. You don’t need to add this test to the project. It is included here just to explain what happens when we try to confirm a pointer. The test looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test bool pointer confirms")
{
    bool result1 = true;
    bool result2 = false;
    bool * pResult1 = &amp;result1;
    bool * pResult2 = &amp;result2;
    CONFIRM_TRUE(pResult1);
    CONFIRM_FALSE(pResult2);
}</pre>
			<p lang="en-GB">The preceding test actually compiles and runs. But it fails with the following result:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test bool pointer confirms</strong>
<strong class="bold" lang="">Failed confirm on line 86</strong>
<strong class="bold" lang="">    Expected: false</strong>
<strong class="bold" lang="">---------------</strong></pre>
			<p lang="en-GB">Line 86 is the second confirm in the test. So, what is going on? Why does the confirm think that <strong class="source-inline" lang="">pResult2</strong> points to a true value?</p>
			<p lang="en-GB">Well, remember that the confirm macro just gets replaced with a call to one of the <strong class="source-inline" lang="">confirm</strong> methods. The second confirm deals with the following macro:</p>
			<pre class="source-code" lang="en-GB">
#define CONFIRM_FALSE( actual ) \
    confirm(false, actual, __LINE__)</pre>
			<p lang="en-GB">And it tries to call <strong class="source-inline" lang="">confirm</strong> with a hardcoded false bool value, the bool pointer that was passed to the macro, and the int line number. There is no exact match for a bool, a bool pointer, or an int for any version of <strong class="source-inline" lang="">confirm</strong>, so something either has to be converted or the compiler will generate an error. We know there was no error because the code compiled and ran. So, what got converted?</p>
			<p lang="en-GB">This is a great example<a id="_idIndexMarker153"/> of the TDD process, as explained in <a href="B18567_03.xhtml#_idTextAnchor031"><em class="italic" lang="">Chapter 3</em></a>, <em class="italic" lang="">The TDD Process</em>, to write the code first as you want it to be used and compile it even if you expect the build to fail. In this case, the build did not fail, and that gives us insight that we might have otherwise missed.</p>
			<p lang="en-GB">The compiler was able to convert the pointer value into a bool and that was seen as the best choice available. In fact, I didn’t even get a warning about the conversion. The compiler silently made the decision to convert the pointer to a bool into a bool value. This is almost never what you want to happen.</p>
			<p lang="en-GB">So, what does it even mean to convert a pointer into a bool? Any pointer with a valid nonzero address will get converted into true. Additionally, any null pointer with a zero address will get converted into false. Because we have the real address of <strong class="source-inline" lang="">result2</strong> stored in the <strong class="source-inline" lang="">pResult2</strong> pointer, the conversion was made to a true bool value.</p>
			<p lang="en-GB">You might be wondering what happened to the first confirm and why it did not fail. Why did the test proceed to the second confirm before it failed? Well, the first confirm went through the same conversion for a bool, bool pointer, and int. Both conversions resulted in a true bool value because both pointers held valid addresses.</p>
			<p lang="en-GB">The first confirm called <strong class="source-inline" lang="">confirm</strong> with true, true, and the line number, which passed. But the second confirm called <strong class="source-inline" lang="">confirm</strong> with false, true, and the line number, which failed.</p>
			<p lang="en-GB">To solve this, we either need to add support for pointers of all types or remember to dereference the pointers before confirming them. Adding support for pointers might seem like a simple solution until we get to string literals, which are also pointers. It’s not as simple as it seems and is not something we need to do now. Let’s keep the test library as simple as possible. Here is how you can fix the bool confirm test shown earlier:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test bool pointer dereference confirms")
{
    bool result1 = true;
    bool result2 = false;
    bool * pResult1 = &amp;result1;
    bool * pResult2 = &amp;result2;
    CONFIRM_TRUE(*pResult1);
    CONFIRM_FALSE(*pResult2);
}</pre>
			<p lang="en-GB">Notice that the tests dereference<a id="_idIndexMarker154"/> the pointers instead of passing the pointers directly to the macros. This means that the test is really just testing bool values, and that’s why I said that you really don’t need to add the test.</p>
			<p lang="en-GB">String literals are frequently found in the source code. They are an easy way to represent an expected string value. The problem with string literals is they are not strings. They are a pointer to a constant char. And we can’t just dereference a string literal pointer as we did for a bool pointer. That would result in a single char. We want to confirm the whole string.</p>
			<p lang="en-GB">Here is a test that shows what will likely be the major usage of string literals. The most common usage will be comparing a string literal with a string. The test looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test string and string literal confirms")
{
    std::string result = "abc";
    CONFIRM("abc", result);
}</pre>
			<p lang="en-GB">This works because one of the argument types that ends up getting passed to the <strong class="source-inline" lang="">confirm</strong> function is <strong class="source-inline" lang="">std::string</strong>. The compiler doesn’t find an exact match for both arguments; however, because one is a string, it decides to convert the string literal into a string, too.</p>
			<p lang="en-GB">Where we run into problems is when we try to confirm two string literals for both the expected and actual values. The compiler sees two pointers and has no clue that they should both be converted into strings. This is not a normal situation that you will need to verify in a test. Additionally, if you ever do need to compare two string literals, it’s easy to wrap one of them into a <strong class="source-inline" lang="">std::string</strong> argument type before confirming.</p>
			<p lang="en-GB">Also, in <a href="B18567_12.xhtml#_idTextAnchor123"><em class="italic" lang="">Chapter 12</em></a>, <em class="italic" lang="">Creating Better Test Confirmations</em>, you’ll see how you can get around the problem of confirming two string literals. We’ll be improving the whole design used to confirm the test results. The design we have now is often called the classic way to confirm values. <a href="B18567_12.xhtml#_idTextAnchor123"><em class="italic" lang="">Chapter 12</em></a> will introduce a new way that is more extensible, easier to read, and more flexible.</p>
			<p lang="en-GB">We’ve come a long way in terms of adding support for different types, and you also understand how to work with string literals. However, I’ve stayed away from the two floating-point types, float<a id="_idIndexMarker155"/> and double, because they need some special consideration. They will be explained next.</p>
			<h1 id="_idParaDest-54" lang="en-GB"><a id="_idTextAnchor055"/>Confirming floating point values</h1>
			<p lang="en-GB">At the most basic level, confirms<a id="_idIndexMarker156"/> work by comparing an expected value with an actual value and throwing an exception if they are different. This works for all the integral types such as int and long, bool types, and even strings. The values either match or don’t match.</p>
			<p lang="en-GB">This is where things get difficult for the floa<a id="_idTextAnchor056"/>t and double floating point types – because it’s not always possible to accurately compare two floating-point values.</p>
			<p lang="en-GB">Even in the decimal system that we are used to from grade school, we understand there are some fractional values that can’t be accurately represented. A value such as 1/3 is easy to represent as a fraction. But writing it in a floating-point decimal format looks like 0.33333 with the digit 3 continuing forever. We can get close to the true value of 1/3, but at some point, we have to stop when writing 0.333333333... And no matter how many 3s we include, there are always more.</p>
			<p lang="en-GB">In C++, floating-point values use a binary number system that has similar accuracy issues. But the accuracy issues in binary are even more common than in decimal.</p>
			<p lang="en-GB">I won’t go into all the details because they are not important. However, the main cause of the extra issues in binary is caused by there being fewer factors of 2 than there are of 10. With the base 10 decimal system, the factors are 1, 2, 5, and 10. While in binary, the factors of 2 are only 1 and 2.</p>
			<p lang="en-GB">So, why are the factors important? Well, it’s because they determine which fractions can be accurately described and which cannot. A fraction such as 1/3 causes trouble for both systems because 3 is not a factor in either. Another example is 1/7. These fractions are not very common, though. The fraction of 1/10 is very common in decimal. Because 10 is a factor, this means that values such as 0.1, 0.2, 0.3, and more can all be accurately represented in decimal.</p>
			<p lang="en-GB">Additionally, because 10 is not a factor in binary base 2, these same values that are widely used have no representation with a fixed number of digits as they do in decimal.</p>
			<p lang="en-GB">So, what all of this means is that if you have a binary floating-point value that looks like 0.1, it is close to the actual value but can’t quite be exact. It might be displayed as 0.1 when converted into a string but that also involves a little bit of rounding.</p>
			<p lang="en-GB">Normally, we don’t worry<a id="_idIndexMarker157"/> about the computer’s inability to accurately represent values that we are used to being exact from grade school – that is, until we need to test one floating-point value to see if it equals another.</p>
			<p lang="en-GB">Even something as simple as 0.1 + 0.2 that looks like 0.3 will probably not equal 0.3.</p>
			<p lang="en-GB">When comparing computer floating-point values, we always have to allow for a certain amount of error. As long as the values are close, we can assume they are equal.</p>
			<p lang="en-GB">However, the ultimate problem is that there is no good single solution that can determine whether two values are close. The amount of error we can represent changes depending on how big or how small the values are. Floating-point values change drastically when they get really close to 0. And they lose the ability to represent small values as they get larger. Because floating-point values can get really large, the amount of accuracy that is lost with large values can also be large.</p>
			<p lang="en-GB">Let’s imagine if a bank used floating-point values to keep track of your money. Would you be happy if your bank could no longer track anything less than a thousand dollars just because you have billions? We’re no longer talking about losing a few cents. Or maybe you only have 30 cents in your account and you want to withdraw all 30 cents. Would you expect the bank to deny your withdrawal because it thinks 30 cents is more than the 30 cents you have? These are the types of problems that floating-point values can lead to.</p>
			<p lang="en-GB">Because we’re following a TDD process, we’re going to start out simple with floating point values and include a small margin of error when comparing either float, double, or long double values to see whether they are equal. We’re not going to get fancy and try to adjust the margin depending on how big or small the values are.</p>
			<p lang="en-GB">Here is a test that we will use for the float values:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test float confirms")
{
    float f1 = 0.1f;
    float f2 = 0.2f;
    float sum = f1 + f2;
    float expected = 0.3f;
    CONFIRM(expected, sum);
}</pre>
			<p lang="en-GB">The test for float types actually passes on my computer.</p>
			<p lang="en-GB">So, what happens<a id="_idIndexMarker158"/> if we create another test for double types? The new double test looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test double confirms")
{
    double d1 = 0.1;
    double d2 = 0.2;
    double sum = d1 + d2;
    double expected = 0.3;
    CONFIRM(expected, sum);
}</pre>
			<p lang="en-GB">This test is almost identical, yet it fails on my computer. And the crazy part is that the failure description makes no sense unless you understand that values can be printed as text, which has been adjusted to appear like a nice round number when it really is not. Here is what the failure message shows on my computer:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test double confirms</strong>
<strong class="bold" lang="">Failed confirm on line 122</strong>
<strong class="bold" lang="">    Expected: 0.300000</strong>
<strong class="bold" lang="">    Actual  : 0.300000</strong>
<strong class="bold" lang="">---------------</strong></pre>
			<p lang="en-GB">Looking at the message, you might ask how it is possible that 0.300000 does not equal 0.300000. The reason is that neither the expected nor the actual values are exactly 0.300000. They have both been adjusted slightly so that they will display these round-looking values.</p>
			<p lang="en-GB">The test for long doubles is almost the same as for doubles. Only the types have been changed, as follows:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test long double confirms")
{
    long double ld1 = 0.1;
    long double ld2 = 0.2;
    long double sum = ld1 + ld2;
    long double expected = 0.3;
    CONFIRM(expected, sum);
}</pre>
			<p lang="en-GB">The long double test also fails on my machine for the same reason as the test with doubles. We can fix all of the floating-point confirms by adding special overloads for all three of these types.</p>
			<p lang="en-GB">Here is an overloaded <strong class="source-inline" lang="">confirm</strong> function<a id="_idIndexMarker159"/> that uses a small margin of error when comparing float values:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    float expected,
    float actual,
    int line)
{
    if (actual &lt; (expected - 0.0001f) ||
        actual &gt; (expected + 0.0001f))
    {
        throw ActualConfirmException(
            std::to_string(expected),
            std::to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">We need almost the same overload for doubles as for floats. Here is the double overload that does the comparison with a margin of error that is plus or minus the expected value:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    double expected,
    double actual,
    int line)
{
    if (actual &lt; (expected - 0.000001) ||
        actual &gt; (expected + 0.000001))
    {
        throw ActualConfirmException(
            std::to_string(expected),
            std::to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">Other than the type changes from float to double, this method uses a smaller margin of error and leaves off the <strong class="source-inline" lang="">f</strong> suffix from the literal values.</p>
			<p lang="en-GB">The overload function for long doubles is similar to the one for doubles, as follows:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    long double expected,
    long double actual,
    int line)
{
    if (actual &lt; (expected - 0.000001) ||
        actual &gt; (expected + 0.000001))
    {
        throw ActualConfirmException(
            std::to_string(expected),
            std::to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">After adding these overloads for floats, doubles, and long doubles, all the tests pass again. We’ll be revisiting the problem of comparing floating-point values again in <a href="B18567_13.xhtml#_idTextAnchor131"><em class="italic" lang="">Chapter 13</em></a>, <em class="italic" lang="">How to Test Floating-Point and Custom Values</em>. The comparison solution we have is simple and will work for now.</p>
			<p lang="en-GB">We have also covered all of the confirm types we’ll be supporting at this time. Remember the TDD rule to do only what is necessary. We can always enhance the design of confirmations later, and that’s exactly what we’ll be doing in <a href="B18567_12.xhtml#_idTextAnchor123"><em class="italic" lang="">Chapter 12</em></a>, <em class="italic" lang="">Creating Better Test Confirmations</em>.</p>
			<p lang="en-GB">Before ending this chapter, I have some advice<a id="_idIndexMarker160"/> on writing confirmations. It’s nothing that we haven’t already been doing, but it does deserve mentioning so that you are aware of the pattern.</p>
			<h1 id="_idParaDest-55" lang="en-GB"><a id="_idTextAnchor057"/>How to write confirms</h1>
			<p lang="en-GB">Usually, there are many different <a id="_idIndexMarker161"/>ways you can write your code and your tests. What I’ll share here is based on years of experience, and while it’s not the only way to write tests, I hope you learn from it and follow a similar style. Specifically, I want to share guidance on how to write confirms.</p>
			<p lang="en-GB">The most important thing to remember is to keep your confirms outside of the normal flow of your tests but still close to where they are needed. When a test runs, it performs various activities that you want to ensure work as expected. You can add confirms along the way to make sure the test is making progress as expected. Or maybe you have a simple test that does one thing and needs one or more confirms at the end to make sure everything worked. All of this is good.</p>
			<p lang="en-GB">Consider the following<a id="_idIndexMarker162"/> three examples of test cases. They each do the same thing, but I want you to focus on how they are written. Here is the first example:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test int confirms")
{
    int result = multiplyBy2(0);
    CONFIRM(0, result);
    result = multiplyBy2(1);
    CONFIRM(2, result);
    result = multiplyBy2(-1);
    CONFIRM(-2, result);
}</pre>
			<p lang="en-GB">This test is one that was used earlier to make sure that we can confirm int values. Notice how it performs an action and assigns the result to a local variable. Then, that variable is checked to make sure its value matches what is expected. If so, the test proceeds to perform another action and assign the result to the local variable. This pattern continues, and if all the confirms match the expected values, the test passes.</p>
			<p lang="en-GB">Here is the same test written in a different form:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test int confirms")
{
    CONFIRM(0, multiplyBy2(0));
    CONFIRM(2, multiplyBy2(1));
    CONFIRM(-2, multiplyBy2(-1));
}</pre>
			<p lang="en-GB">This time, there is no local variable to store the result of each action. Some people would consider this an improvement. It <em class="italic" lang="">is</em> shorter. But I feel this hides what is being tested. I find it better to think about confirms as something that can be removed from a test without changing what a test does. Of course, if you do remove a confirm, then the test might miss a problem that the confirm would have caught. I’m talking about mentally ignoring confirms to get a feel for what a test does, and then thinking about what makes sense to verify along the way. Those verification points become the confirms.</p>
			<p lang="en-GB">Here is another example:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test int confirms")
{
    int result1 = multiplyBy2(0);
    int result2 = multiplyBy2(1);
    int result3 = multiplyBy2(-1);
    CONFIRM(0, result1);
    CONFIRM(2, result2);
    CONFIRM(-2, result3);
}</pre>
			<p lang="en-GB">This example avoids putting the test steps inside the confirms. However, I feel that it goes too far to separate the test steps from the confirms. There’s nothing wrong with sprinkling confirms into your test steps. Doing so lets you catch problems right away. This example puts all the confirms at the end, which means that it also has to wait until the end to catch any problems.</p>
			<p lang="en-GB">And then there’s the problem of the multiple result variables needed so that each can be checked later. This code looks too forced to me  – like a programmer who took the long way to reach a goal when there was a simple path available instead.</p>
			<p lang="en-GB">The first example shows the style<a id="_idIndexMarker163"/> of tests written so far in this book, and now you can see why they have been written in this manner. They use confirms where needed and as close to the point of verification as possible. And they avoid placing actual test steps inside the confirms.</p>
			<h1 id="_idParaDest-56" lang="en-GB"><a id="_idTextAnchor058"/>Summary</h1>
			<p lang="en-GB">This chapter took us past the simple ability to confirm true and false values. You can now verify anything you need to make sure it matches what you expect.</p>
			<p lang="en-GB">We simplified the confirm macros by putting the code into overloaded functions with a templated version to handle other types. You saw how to confirm simple data types and work with pointers by dereferencing them first.</p>
			<p lang="en-GB">The code needed to be refactored, and you saw how TDD helps when you need to make design changes to your code. I could have written the code in this book to make it seem like the code was written perfectly from the very beginning. But that wouldn’t help you because nobody writes perfect code from the beginning. As our understanding grows, we sometimes need to change the code. And TDD gives you the confidence to make those changes as soon as they become known instead of waiting – because problems that you delay have a tendency to get bigger instead of going away.</p>
			<p lang="en-GB">And you should be gaining an understanding of how to write your tests and the best way to incorporate confirms into your tests.</p>
			<p lang="en-GB">Up until now, we’ve been working with the C++ features and capabilities found in C++ 17. There is an important new feature found in C++ 20 that will help us get line numbers from the compiler. The next chapter will add this C++ 20 feature and explore some alternate designs. Even if we stay with the same overall design we have now, the next chapter will help you to understand how other testing libraries might do things differently.</p>
		</div>
	</body></html>