- en: Testing Resource-Restricted Platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing for MCUs and similar resource-restricted platforms is pretty much
    exclusively done on regular PCs, except for testing and debugging. The question
    is when one should be testing on the physical device and when one should be looking
    at alternative means of testing and debugging code in order to speed up development
    and debugging efforts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the resource needs of specific code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectively using Linux-based tools to test cross-platform code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using remote debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using cross-compilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a platform-independent build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing wear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, during development, there comes that point where one is fixing an issue
    in a system and have to go through the same tweak-compile-deploy-test cycle, over
    and over. Here are the main problems that are introduced with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s not fun**: It''s frustrating to have to constantly wait for results
    without a clear idea of whether it will actually be fixed this time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It''s not productive**: You spend a lot of time waiting for results you wouldn''t
    need if you could just analyze the problem better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It wears down the hardware**: After removing and reinserting the same connectors
    dozens of times, writing and overwriting the same sections of the ROM chip countless
    times, and power cycling the system hundreds of times, the hardware''s lifespan
    is reduced significantly, along with one''s own patience, and new errors are introduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fiddling with test hardware isn''t fun**: The best-case scenario for any
    embedded setup is to be able to take the development board, plug in all the peripherals
    and wiring, flash the ROM with the application, and power it up to see it work.
    Any deviation from this scenario is frustrating and time-consuming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding such cycles during development is therefore essential. The question
    is how we can most effectively get to a point where we can produce code for something
    such as an 8-bit MCU or a larger 32-bit ARM MCU without ever touching the hardware
    until the final stages of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Planning out a design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml), *Resource-Restricted
    Embedded Systems*, we looked at how to pick an appropriate microcontroller for
    an embedded platform. While designing the firmware for the MCU, it's essential
    that we consider not only the resource requirements of specific codes, but also
    the ease of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: An important advantage of using C++ is the abstractions it offers, including
    the ability to subdivide the code into logical classes, namespaces, and other
    abstractions that allow us to easily reuse, test, and debug the code. This is
    a crucial aspect in any design, and an aspect that needs to be implemented fully
    before one can proceed with actually implementing the design.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the design, it can be either very easy or frustratingly hard to
    debug any issue, or anything in between. If there's a clean separation between
    all the functionality, without leaky APIs or similar problems that could leak
    internal, private data, creating different versions of fundamental classes for
    things such as integration and unit testing will be easy.
  prefs: []
  type: TYPE_NORMAL
- en: Simply using classes and the like is no guarantee for a design that is modular.
    Even with such a design one can still end up passing internal class data between
    classes, thus breaking modularity. When this happens, i will complicate the overall
    design as the level of dependencies increases with changes to data structures
    and data formats potentially causing issues elsewhere in the application and will
    require creative hacks while writing tests and reimplementing APIs as part of
    larger integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml), *Resource-Restricted
    Embedded Systems*, we looked at how to pick the proper MCU. The points of RAM,
    ROM, and floating-point usage are obviously down to the design we picked to fit
    the project. As we covered in [Chapter 2](cae3bf4a-2936-42b4-a33e-569e693bfcc8.xhtml),
    *C++ as an Embedded Language*, it's important to understand what the code we write
    is compiled into. This understanding allows one to get an intuitive feeling for
    what the resource cost of a line of code is going to be like without having to
    step through the generated machine code and create an exact clock cycle count
    from there.
  prefs: []
  type: TYPE_NORMAL
- en: It should be obvious at this point that before one can pick an MCU, one must
    have a pretty good idea of the overall design and the resource requirements, so
    starting off with a solid design is essential.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-independent build systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, the project and build system we choose could be used to build the target
    platform on any desktop platform. Usually, the main consideration here is the
    availability of the same toolchain and programmer for each development platform.
    Fortunately, for AVR- and ARM-based MCU platforms, the same GCC-based toolchain
    is available, so that we do not have to take different toolchains with different
    naming conventions, flags and settings into account.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining challenge is simply to invoke the toolchain, and subsequently
    the programmer utility, in a way that doesn't require any knowledge of the underlying
    OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*, we looked at a multitarget build system, which could produce binaries
    for a wide variety of targets with minimal effort for each new target. For an
    MCU target, there would only be the following two targets:'
  prefs: []
  type: TYPE_NORMAL
- en: The physical MCU target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local OS target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the first target is obviously fixed, as we picked out the MCU that we
    wanted to target. Barring any unpleasant surprises, we will be using this one
    target for the entire development process. In addition, we will want to preform
    local testing on our development PC. This is the second target.
  prefs: []
  type: TYPE_NORMAL
- en: Here it would be great if there is a version of the same or similar  C++ toolchain
    on each mainstream desktop OS. Fortunately, we find that GCC is available on just
    about any platform imaginable, with the Clang C++ frontend of the LLVM toolchain
    using regular GCC-style flags, providing us with broad compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of requiring the complexity of a multitarget build system, as we saw
    in [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*, we can simplify it so it that  just uses GCC, which would allow
    us to use that toolchain on Linux- and BSD-based OSes, along with Windows (MinGW
    via MSYS2 or equivalent) and macOS (after installing GCC).
  prefs: []
  type: TYPE_NORMAL
- en: For full compatibility on macOS, the use of GCC is recommended, due to small
    issues in the Clang implementation. One of these current issues is the `__forceinline`
    macro attribute being broken, for example, which would break a lot of code that
    assumes the GCC compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Using cross-compilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every compiler toolchain consists of a side (frontend) that takes in the source
    code and a side that outputs the binary format for the target platform (backend).
    There's no reason why the backend couldn't work on any other platform than the
    one it's targeting. In the end, one merely transforms text files into sequences
    of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling in this fashion is an essential feature with MCU-oriented development,
    as compiling directly on those MCUs would be highly inefficient. There is, however,
    nothing magical about this process. In the case of GCC-based and GCC-compatible
    toolchains, one would still be interacting with the same interfaces on the toolchain,
    just with the tools usually prefixed with the target platform name to distinguish
    them from other toolchains for different targets. Essentially, instead of `g++` one
    would use `arm-none-eabi-g++`
  prefs: []
  type: TYPE_NORMAL
- en: The resulting binaries would be in the format appropriate for that target platform.
  prefs: []
  type: TYPE_NORMAL
- en: Local and on-chip debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*, we looked at debugging applications using Valgrind and similar
    tools, as well as GDB and kin. With the OS-based integration tests for MCU-based
    projects, such as those demonstrated in the *Example – ESP8266 integration test* section,
    we can use the exact same techniques, profiling and debugging the code without
    concerning ourselves just yet with the fact that the same code will be running
    on a much slower and more limited platform during final integration testing on
    real hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The real challenge comes during that final integration stage, when the firmware—which
    we have been debugging on our fast desktop system using Valgrind and other highly
    capable tools—is now running on a paltry 16 MHz ATmega MCU without the ability
    to quickly launch the code with a Valgrind tool or within a GDB session.
  prefs: []
  type: TYPE_NORMAL
- en: As one will inevitably encounter bugs and issues during this stage, we need
    to be prepared to deal with this situation. Often, one has to resort to **on-chip
    debugging** (**OCD**), which can be performed over whichever debugging interface
    the MCU provides. This can be JTAG, DebugWire or SWD, PDI, or some other type.
    In [Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml), *Resource-Restricted
    Embedded Systems*, we looked at some of those interfaces in the context of programming
    these MCUs.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded IDEs will provide the ability to perform OCD right out of the box,
    connecting with the target hardware, allowing one to set breakpoints, much like
    one would be used to setting for a local process. Of course, it's also possible
    to use GDB from the command line to do the same thing, using a program such as
    OpenOCD ([http://openocd.org/](http://openocd.org/)), which provides a `gdbserver`
    interface for GDB while interfacing with a wide variety of debug interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Example – ESP8266 integration test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example project, we will look at creating an implementation of the Arduino-like
    APIs of the Sming framework, which we first looked at it in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml),
    *Example - Soil Humidity Monitor with Wi-Fi*. The goal of this is to provide a
    native framework implementation for desktop **operating systems** (**OSes**),
    allowing the firmware to be compiled to an executable and run locally.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we want to have simulated sensors and actuators that the firmware
    can connect to in order to read out environmental data and send data to actuators
    as part of the BMaC project, which we had a glimpse of in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example -
    Soil Humidity Monitor with WiFi*, and which we will look at in more detail in
    [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml), *Example - Building Monitoring
    and Control*. For this, we also need to have a central service that keeps track
    of such information. This way, we can also have multiple firmware processes running,
    to simulate entire rooms full of devices.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this scope of the simulation is due to not having the physical
    hardware. Without a physical MCU system, we don't have physical sensors, and these
    sensors would not exist in a physical room. Ergo we have to generate plausible
    input for the sensors and simulate the effect of any actuators.  This does however
    come with a lot of advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Having this scaling ability is useful in that it allows us to validate the firmware
    not only as a standalone system, but also as part of the system it would be installed
    in. In the case of BMaC, this would mean a single node installed in a room of
    a building, with dozens to hundreds of further nodes installed in the same and
    other rooms across the building's floors, along with accompanying backend services
    running on the same network.
  prefs: []
  type: TYPE_NORMAL
- en: With this kind of large-scale simulation ability, one can test not only the
    basic correctness of the firmware by itself, but also that of the system as a
    whole, with the different firmware types or even versions running in tandem with
    the various sensors and actuators (for air-conditioning units, fans, coffee machines,
    switches, and so on). In addition to this, the backend services would be directing
    the nodes according to the data being passed to them from the same nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Within the simulated building, one could then configure specific rooms to have
    particular environmental conditions, run through a working day with people entering,
    working, and leaving, to determine the effect of different levels of building
    occupation, outside conditions, and so on. You could also do this with the firmware
    and backend services that would be used for the final production system. While
    testing a system this way won't fully eliminate any potential problems, it should
    at least validate that the software side of the system is functionally correct.
  prefs: []
  type: TYPE_NORMAL
- en: As embedded systems are by definition part of a larger (hardware-based) system,
    a full integration test will involve the actual hardware or its equivalent. One
    could therefore consider this example the software integration test, prior to
    deploying the firmware to the target hardware in a physical building.
  prefs: []
  type: TYPE_NORMAL
- en: Both the simulation server and the individual firmware processes have their
    own main function and run independently from each other. This allows us to inspect
    the functioning of the firmware with as little interference as possible and promotes
    a clean design. To allow efficient communication between these processes, we use
    a **remote procedure call** (**RPC**) library, which essentially creates a connection
    between the firmware and the I2C, SPI, and UART-based devices in the simulated
    room. The RPC library used with this example is NymphRPC, an RPC library developed
    by the author. The source for the current version has been included with the source
    code for this chapter. The current version of the NymphRPC library can be found
    at its GitHub repository at [https://github.com/MayaPosch/NymphRPC](https://github.com/MayaPosch/NymphRPC).
  prefs: []
  type: TYPE_NORMAL
- en: The server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will first look at the server for this integration test. Its role is to run
    the RPC server and to maintain the state of each of the sensor and actuator devices,
    as well as the rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main file, `simulation.cpp`, sets up the RPC configuration as well as the
    main loop, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The includes at the top shows us the basic structure and dependencies. We have
    a custom configuration class, a class defining the building, a static class for
    the nodes, and finally the multithreading headers (available since C++11) and
    the NymphRPC RPC header to gain access to its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A signal handler function is defined to be used with the waiting condition later
    on, allowing the server to be terminated with a simple control signal. Finally,
    a logging function is defined for use with the NymphRPC server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the callback functions for the RPC server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is the initial function that the clients will call on the server. It will
    check the global, static `Nodes` class for an available MAC address. This address
    uniquely identifies a new node instance, the way a device on the network would
    also be identified by its unique Ethernet MAC address. This is an internal function
    that will not require modification of the firmware, but shifts the ability to
    assign MACs to the server, instead of­ having them hardcoded somewhere. When a
    new MAC has been assigned, it gets associated with the NymphRPC session ID so
    that we can later use the MAC to find the appropriate session ID and, with it,
    the client to call for events generated by simulated devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we also see the basic signature of a NymphRPC callback function as used
    on a server instance. It obviously returns the return message, and it receives
    as its parameters the session ID associated with the connected client, the message
    received from this client, and some user-defined data, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This callback implements a way to write to the UART interface of a simulated
    node within the simulation, addressing whichever simulated device is hooked up
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the node, we use the MAC address and send it, along with the bytes,
    to be written to the appropriate `Nodes` class function, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For the SPI bus, a similar system is used for writing and reading. The MAC
    identifies the node and either a string is sent to the bus or is received from
    it. One limitation here is that we assume the presence of only a single SPI device,
    since there is no way to select a different SPI **chip-select** (**CS**) line.
    A separate CS parameter would have to be passed here to enable more than one SPI
    device. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For the I2C bus version, we pass the I2C slave device address to allow us to
    use more than a single I2C device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the main function registers the RPC methods, starts the simulation,
    and then enters a waiting condition, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We first get the configuration data for this simulation using the following
    code. This is all defined in a separate file, that we will load using the special
    `Config` class, which we will take a more detailed look at in a moment when we
    look at the configuration parser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we register the further methods we wish to provide to the client
    node processes, allowing these to call the functions we looked at earlier in this
    source file. In order to register a server-side function with NymphRPC, we have
    to define the parameter types (in order) and use these to define a new `NymphMethod`
    instance, which we provide with this parameter type list, the function name, and
    the return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'These method instances are then registered with `NymphRemoteClient`, which
    is the top-level class for the server-side NymphRPC, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we install the signal handler for SIGINT (*Ctrl* + *c*) signals. The
    NymphRPC server is started on port 4004, all interfaces. Next, a `Building` instance
    is created, providing it with the instance of the configuration we loaded earlier
    with the configuration parser class.
  prefs: []
  type: TYPE_NORMAL
- en: We then start a loop that checks whether the value of the `gPredicate` global
    variable has changed to `true`, which will be the case if the signal handler has
    been triggered, and this Boolean variable has been set to `true`. A condition
    variable is used to allow us to block the main thread execution as much as possible
    by having the signal handler notify this condition variable.
  prefs: []
  type: TYPE_NORMAL
- en: By having the condition variable's wait condition inside a loop, we ensure that
    even if the condition variable's wait condition suffers a spurious wake up, it'll
    simply go back to waiting to be notified.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if the server is requested to terminate, we shut down the NymphRPC server,
    before giving all active threads an additional two seconds to cleanly terminate.
    After this, the server shuts down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `config.cfg` file that we loaded for this simulation,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this configuration file uses the standard INI configuration file
    format. It defines a building with two floors, each with two rooms. Each room
    has a single node and each node has a BME280 sensor attached to it on the I2C
    bus.
  prefs: []
  type: TYPE_NORMAL
- en: More devices are defined, but are left unused here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the configuration parser shown in the following code, which
    parses the preceding format, declared in config.h:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see an interesting use of templates, as well as one of their limitations.
    The type passed to the template is used both for the default parameter and the
    return type, allowing the template to cast the raw string obtained from the configuration
    file to the desired type, while also avoiding the issue of incomplete templates
    by only using the type in the return type of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the limitation of C++, where every function with the same name must have
    a different set of parameters even if their return value differs, we must use
    the default value parameter here to circumvent that issue. As most of the time
    we want to provide a default value for the keys we are trying to read, this isn't
    much of an issue here.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we do a bit of type comparison with `std::is_same` to ensure that if
    the target return type is a string, we copy the string straight out of `stringstream`
    instead of trying to convert it using formatted output. As we read the values
    from the INI file using the POCO INI file reader as raw strings, there's no need
    to do any kind of conversion on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its implementation in `config.cpp` is pretty small, as a result of templates
    having to be defined in the header file. You can see this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We just implement the method here, which actually loads the configuration file
    from the filename string. In this implementation, we create an instance of the
    POCO `IniFileConfiguration` class on the assumption that we are trying to parse
    an INI file. If loading the configuration file fails for whatever reason, we return
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: In a more fleshed-out version of this parser, we would maybe support different
    configuration types or even sources, with advanced error handling. For our purposes,
    the humble INI format more than suffices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, the following code shows the `Building` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we haven''t added any advanced features to the simulation server, there
    isn''t much to see here yet, nor in its implementation, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we read each floor definition from the file and create a `Floor` instance
    for it, which we add to an array. The instances also receive a reference to the
    configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Floor` class is basic as well, for the same reason, as you can see in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Of note is the way that the central configuration file is being parsed one part
    at a time by each individual class, with each class instance only caring about
    the small section that it has been instructed to care about by the ID.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are only concerned with the rooms that are defined for this floor ID.
    We extract the IDs for those rooms, then create new class instances for those
    rooms, saving a copy of each room in a vector. In a more advanced implementation
    of the simulation server, we could implement floor-wide events here, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The utility header here defines a simple method for splitting strings, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function is quite simple, using the provided separator to take a string
    and separate it into parts defined by said separator, which then get copied into
    a vector using emplacement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, here''s the `Room` class, as declared in `room.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this class' constructor, we start off by setting the initial conditions of
    this room, specifically the temperature and humidity values. Next, we read out
    the nodes and devices for this room ID, creating instances of each. It starts
    by getting the list of nodes for this room, then for each node we get the list
    of devices, splitting this string into the individual device IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Each device ID has a device class instantiated for it, with this instance added
    to the node that uses it. This finishes the basic initialization of the simulation
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, here''s the `Device` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we read out the information for this specific device using
    the provided device ID. Depending on the device type, we look for specific keys.
    These are all stored inside member variables, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After a simple setter method for the MAC of the connected node, we get a method
    that allows generated UART events to trigger a callback to the node process via
    an RPC callback method (as we will see in more detail in a moment when we look
    at the `Nodes` class). This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a generic method to write to the device, regardless of the type.
    Here, we only handle the I2C interface to obtain the device register that''s being
    addressed, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `read` methods come with a version that defines a length parameter for the
    bytes to be read and a version without parameters, instead passing a zero to the
    first method. This parameter would be useful for a UART, where a fixed buffer
    size would be used for the data.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity's sake, we have hardcoded the response for a BME280 combined
    thermometer, hygrometer, and air pressure meter device. We check the value of
    the register that was sent over with an earlier `write` command, then return the
    value appropriate to it, reading the current room values as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more devices possible, we would want to implement them in their
    own configuration files or dedicated classes instead of hardcoding them all here
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom types for the application are defined in the `types.h` header, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see the enumeration for the different connection types, as well as
    the `RoomState` class, which defines a basic getter/setter-based construction,
    with a mutex providing thread-safe access to the individual values, as multiple
    nodes can try to access the same values while the room itself tries to update
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, here''s the `Node` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When a new class instance is created, it obtains its MAC address, adds it to
    its own local variable, and registers it with the `Nodes` class. A new instance
    of the node executable (in our case, called `esp8266`) is launched using the native
    system call, which will cause the OS to start this new process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the new process starts, it will connect to the RPC server and obtain the
    MAC using the RPC functions that we looked at earlier in this section. After this,
    the class instance and the remote process act as mirror images of each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When the `Room` class assigns a new device to the node, we assign our MAC to
    it to act as an identifier for which node it belongs to. After this, we query
    the device to see which type of interface it has, so that we can add it to the
    proper interface, taking into account the CS line (if used) for SPI and the bus
    address for I2C.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using move semantics, we ensure that we aren''t merely mindlessly making copies
    of the same device class instance, but essentially shifting ownership of the original
    instance, thus improving efficiency. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For the writing and reading functionality, not a lot is involved. Using the
    CS (SPI), the bus address (I2C), or neither (UART), we know which type of device
    to access and call its respective methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here''s the `Nodes` class that ties everything together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following methods, we can set and remove node class instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'New MAC and RPC session IDs are registered with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The methods for writing and reading from the different interfaces are basically
    pass-through methods, merely using the MAC address to find the appropriate `Node`
    instance to call the method on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of note here is the `sendUart()` method, which uses the NymphRPC server to
    call the callback method on the appropriate node process to trigger its UART receive
    callback, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we got the methods used to set and get the MAC address for new nodes.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have the basics of the full integration server. In the next section,
    we will take a look at the firmware and client side of the system before looking
    at how everything fits together.
  prefs: []
  type: TYPE_NORMAL
- en: Makefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Makefile for this part of the project looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is a rather simple Makefile as we have no special demands. We gather the
    source files, determine the names of the resulting object files, and compile all
    of them before generating a binary out of these object files.
  prefs: []
  type: TYPE_NORMAL
- en: The node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers the firmware for the integration test specifically the reimplementation
    of the (Arduino) APIs used in the Sming framework.
  prefs: []
  type: TYPE_NORMAL
- en: Most crucial here is that we don't in any way modify the firmware code itself.
    The only parts that we wish to change from the original firmware image for the
    ESP8266 MCU are the APIs that our own code interacts with.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we have to first determine the APIs that our code interacts
    with and reimplement these in a way that is supported on the target (desktop)
    platform. For our ESP8266-based firmware, this means, for example, that the Wi-Fi
    network side is left unimplemented, as we are using the local network stack of
    the OS and therefore don't care about such details.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the I2C, SPI, and UART interfaces are implemented as mere stubs that
    call their respective counterparts on the RPC interface, which we looked at in
    the previous section. For the MQTT protocol client, we could use the `emqtt` MQTT
    library that is part of the Sming framework, but as one will quickly find out,
    this library is meant to be used on embedded systems where the code using it is
    responsible for connecting it to the network stack.
  prefs: []
  type: TYPE_NORMAL
- en: Our code interacts with the API offered by the `MqttClient` class in Sming.
    It uses `emqtt` for the MQTT protocol, and inherits from the `TcpClient` class.
    Following the code down the hierarchy, one will end up at the TCP connection class
    before diving into the underlying LWIP network library stack.
  prefs: []
  type: TYPE_NORMAL
- en: In order to save ourselves a lot of trouble, it's easiest to just use an alternative
    MQTT library, such as the Mosquitto client library, which is meant to be run on
    a desktop OS, and will therefore use the OS-provided sockets API. This will cleanly
    map to the methods provided by Sming's MQTT client class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leave the header for this class almost entirely untouched, just adding
    our modifications to integrate the Mosquitto library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We're including the header file for the C++-based wrapper for the Mosquitto
    client library here from the version of the Mosquitto library that is included
    in the project for this chapter. This is because the official version of the library
    doesn't support building with MinGW.
  prefs: []
  type: TYPE_NORMAL
- en: With the header included, we have the class derive from the Mosquitto MQTT client
    class instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, the implementation of the Sming MQTT client class has been completely
    changed, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor simply initializes the Mosquitto library, with no further input
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the destructor (shown in the following code) we stop the MQTT client-listening
    thread that we launched when we connect to an MQTT broker and clean up the resources
    that were used by the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a number of utility functions, not all of which are being utilized,
    but they are still implemented here for the sake of completeness. It''s also hard
    to predict which ones will be required, therefore it''s often better to implement
    more than strictly necessary, especially if they are small functions that take
    less time to implement than to find out whether that function or method is used
    at all. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `connect` methods remain the same, as they all use the same `private` method
    of the class to perform the actual connection operation, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is the first section where we directly use the Mosquitto library. We reinitialize
    the instance either without a password or TLS (anonymous broker access), or with
    a password, or with TLS (left unimplemented here, as we don't need it).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this method, we also start the listening thread for the MQTT client, which
    will handle all incoming messages so that we don''t have to further concern ourselves
    with this aspect of the process. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The MQTT message-publish functionality directly maps to the Mosquitto library''s
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Subscribing and unsubscribing both also map easily to the MQTT client instance,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we implement the Mosquitto `callback` method for when we receive a
    new message from the broker. For each received message, we then call the registered
    `callback` method (from the firmware code) to provide it with the payload and
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: This takes care of the MQTT client aspect of the firmware. Next, we need to
    make the rest of the APIs compatible with a desktop OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The headers of the Sming framework that the firmware uses are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first header file defines some platform-related features that we don't need.
    The second header is the one that we will add everything that we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the firmware''s code for API dependencies, we use standard text searching
    tools to find all function calls, filtering out any that do not call into our
    code but into the Sming framework. After doing this we can write the following
    SmingCore.h file with these dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We start off with a combination of standard C library and STL includes, along
    with a number of headers that define the rest of the API that we are implementing.
    We also directly use a number of header files that define classes that are used
    throughout these APIs, but not by the firmware itself.
  prefs: []
  type: TYPE_NORMAL
- en: A class like the `Delegate` class is sufficiently abstract that it can be used
    as is. As we will see, the `Filesystem` and `Timer` classes required a fair bit
    of reworking to make them work for our purposes. We already looked at the modifications
    to the MQTT client earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, we also include the header file for the NymphRPC library, which
    will allow us to communicate with the server side of the integration test, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For compatibility reasons, we need to define a range of types that are used
    throughout the firmware code. These are equivalent to the types in `cstdint` from
    the C library, so we can use simple `typedefs`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first API we fully reimplement is the hardware-based serial device. Since
    this communicates directly with the virtual interface in the server, we just need
    to provide the methods here, with the definition in the source file, as we will
    see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also declare a global instantiation of this serial object class, identical
    to how the original framework implementation handles it, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The rboot boot manager and SPIFFS filesystem-related functionality has no equivalent
    on a desktop system, so we declare them here (but as we''ll see in a moment, they
    are left as empty stubs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'On the network side, we have to provide all of the class instances and related
    information that are normally used to connect to a WiFi access point and ensure
    that we are connected. As we aren''t testing WiFi functionality here, these methods
    are of little use, but are needed to satisfy the firmware code and the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declare the debug-related output function as well as the watchdog class
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the two types of communication buses here, as shown in the following
    code. Again, we declare that there is a global instantiation of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Since the firmware contains code that uses the GPIO and ADC pins, the above functions
    are needed as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we declare a number of classes and functions that are mostly there
    to satisfy the compiler as they have no practical use for our purposes, though
    we could potentially implement advanced test scenarios this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll look at the implementation of these functions using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handle` variable is the one variable we declare as being static in this
    compile unit. Its purpose is to store the remote server handle ID for future operations
    after we connect to the RPC server, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in the server-side code, we define a simple logging function to use
    with NymphRPC, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement the simple debug output function using C-style string formatting
    features to fit the function''s signature, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the serial callback delegate along with the serial receive buffer
    as static, as we assume the presence of a single UART capable of **receiving data**
    (RX), which happens to be the case on the ESP8266 MCU. We also create a single
    instance of the `HardwareSerial` class, for UART 0, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is just there to act as a stub. As none of the code actually uses
    this object''s methods, we can leave them all unimplemented, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of the methods in this class are simple enough that they can be implemented
    as a simple write to the standard (system) output or with an assignment to a variable.
    Occasionally a method is left unaltered from the original, though even for the
    setting of the callback delegate function in the last method in this group, the
    original code is called into the C-based low-level APIs of the ESP8266''s SDK.
    Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: To receive UART messages, we define a NymphRPC callback function, which for
    that reason is defined as being static. Since the ESP8266 only has a single UART
    capable of receiving data this suffices.
  prefs: []
  type: TYPE_NORMAL
- en: 'When called, this method reads out the payload being received on the UART and
    calls the `callback` function that the firmware registered previously, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Writing to the remote UART is done using an RPC call. To do this, we create
    an STL vector and fill it with the parameters to pass in the proper order—in this
    case, the node's MAC address and the data that we wish to send on the remote UART.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we use the NymphRPC handle that we got when we connected to call
    the RPC server and wait for the response from the remote function, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading from the UART is done after we''ve received data on the UART, after
    which we can read it out with the following method, just as we would with the
    original code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the rboot boot manager and the SPIFFS filesystem are not used, so they
    can just return safe values, as shown in the following code. The **over-the-air**
    (**OTA**) functionality could potentially be implemented as well, depending on
    the kind of features of the system one would want to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we don''t have a Wi-Fi adapter that we want to use directly and are just
    using the OS''s network capabilities, the `WiFiStation` object doesn''t do a lot
    for most of its methods, except for when we actually connect to the RPC server,
    which is done using the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the first methods that gets called in the firmware when it tries
    to connect to the Wi-Fi access point. Instead of connecting to a Wi-Fi access
    point, we use this method to connect to the RPC server instead.
  prefs: []
  type: TYPE_NORMAL
- en: We start by initializing the NymphRPC library, calling the initialization method
    on its `NymphRemoteServer` class, and then connecting to the RPC server using
    the hardcoded location and port number. Upon successfully connecting to the RPC
    server, this client will receive a list of the available methods on the RPC server—in
    this case, all of the methods we registered, as we saw in the previous section
    on the simulation server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we request our MAC address from the server, verify that it''s a string
    that we received, and set it for later use. Finally, we locally register the callback
    for the UART with NymphRPC, as shown in the following code. As we saw in the simulation
    server''s section, the `Nodes` class on the server expects this callback to exist
    on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We conclude this networking section with some more stub classes and, finally,
    the watchdog class, which might make for a nice point for advanced testing, including
    soft reset testing for long-running code. Of course, such advanced tests would
    also require that the code runs with the performance of the ESP8266's sub-100
    MHz processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of note here is the Wi-Fi events class, where we immediately call the `callback`
    function for a successful connection to the Wi-Fi access point, or at least pretend
    to. Without this step, the firmware would forever wait for something to happen.
    Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To write on the SPI bus, we again just call the RPC method on the server, getting
    the response once that call has been completed, as shown in the following code.
    For simplicity''s sake, no SPI read functionality is implemented in this example
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'After some stub methods in the I2C class, we find the `write` methods. These
    are essentially the same methods, calling the `remote` method to send the data
    to the simulated I2C bus on the server, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To read from the I2C bus, we use the preceding method, first writing the I2C
    address we wish to write to, then calling the RPC function to read from the simulated
    I2C device that should have data available to read, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The I2C read functionality is essentially the same as it was in the original
    implementation, as both just interact with a local buffer, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are more stub implementations that could be of use for specific test scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We left these functions unimplemented, but they could implement GPIO and ADC
    pins that are connected to virtual GPIO pins on the server side, to control devices
    and record data that does not use a UART, SPI, or I2C interface. The same would
    work for PWM functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the final part in this source file, we implement the main function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Just like the Sming version of the entry point, we call the global `init()`
    function in the custom firmware code, which serves as the entrance point there.
    Conceivably, we could also perform various types of initialization in this main
    function if we needed to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The filesystem class methods are implemented using a mixture of C-style file
    access and C++17-style filesystem operations, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify this method, we ignore the provided flags and always open the file
    in full read and write mode (one would only implement the full set of flags if
    it contributed to the integration test in some way). Let''s look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: These are all standard file operations, so they don't require a lot of explanation.
    The main reason why both C-style and C++17-style file access are used is because
    the original API methods assume a C-style way of handling things, and also because
    of the underlying, C-based SDK functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We would map all API methods to a pure C++17 filesystem functionality, but this
    would be an additional time investment without any obvious payoff.
  prefs: []
  type: TYPE_NORMAL
- en: 'The timer functionality uses POCO''s `Timer` class in Sming''s `SimpleTimer`
    class to implement an equivalent functionality, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for the reimplementation of the `Clock` class, we use STL''s chrono
    functionality, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here, we leave the `delay` functions unimplemented since we don't need them
    at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Makefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Makefile for this part of the project looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The main thing to note about this Makefile is that it gathers source files from
    two different source folders, both for the test API and for the firmware source.
    The former source files are first compiled to object files, which are assembled
    into an archive. The firmware source is used directly along with this test framework
    library, though we also have the firmware object files available if we need them.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for creating an archive of the test API before linking it has to
    do with the way that the linker finds symbols. By using the AR tool, it will create
    an index of all symbols in the object files inside the archive, ensuring that
    we will not get any linker errors. Especially for large projects this is often
    a requirement to have the object files successfully link into a binary.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling to object files first is also helpful with larger projects, as Make
    will ensure that only files that have actually changed will be recompiled, which
    can really speed up development time. Since the target firmware source for this
    project is fairly minimal, we can compile directly from the source files here.
  prefs: []
  type: TYPE_NORMAL
- en: We also include two more Makefiles from this one. The first includes the version
    number of the firmware source we are compiling with, which is useful since it'll
    ensure that the produced node binary will report the exact same version as the
    version installed on an ESP8266 module would. This making validation of a specific
    firmware version much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second is the Makefile with user-definable settings, copied *verbatim*
    from the firmware project Makefile, but with just the variables we need for the
    firmware source to compile and work, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Including this Makefile sets all of these defines to be passed to the compiler.
    These are all preprocessor statements that are used to set strings or to change
    which parts of the code will be compiled, such as the SSL code.
  prefs: []
  type: TYPE_NORMAL
- en: However, for simplicity's sake, we aren't implementing SSL functionality for
    this example project.
  prefs: []
  type: TYPE_NORMAL
- en: Building the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the server side, we have the following library dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: NymphRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POCO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the node, we have the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: NymphRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POCO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mosquitto
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NymphRPC library (described at the beginning of this section) is compiled
    according to the project's instructions and installed in a place where the linker
    can find it. The POCO libraries are installed using the system's package manager
    (Linux, BSD, or MSYS2) or by hand.
  prefs: []
  type: TYPE_NORMAL
- en: For the Mosquitto library dependency, we can compile the `libmosquitto` and
    `libmosquittopp` library files using the project's library version by using the
    Makefile in the `test/SmingCore/network/libmosquitto` folder. Again you should
    install the resulting library files where the linker can find them.
  prefs: []
  type: TYPE_NORMAL
- en: When not using MinGW, one can also use the generally available version via the
    OS's package manager or similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these steps, we can compile the server and client using the following
    command-line command from the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This should compile both the server and node projects using the top-level Makefile,
    resulting in an executable for each in their respective `bin/` folder. You should
    ensure that the executable name and path in the server's `Node` class match that
    of the node executable's location.
  prefs: []
  type: TYPE_NORMAL
- en: We should now be able to run the project and start to collect test results.
    The project includes a stripped version of the ESP8266-based BMAC firmware, which
    we'll be covering in detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml),
    *Example - Building Monitoring and Control*. Please refer to that chapter to understand
    how to communicate with the simulated nodes via MQTT, how to turn on modules inside
    the firmware and how to interpret the data sent over MQTT by the modules.
  prefs: []
  type: TYPE_NORMAL
- en: After setting things up as described in that chapter - requiring at the least
    an MQTT broker and a suitable MQTT client - and turning on the BME280 module in
    the simulated node, we expect it to start sending over MQTT the temperature, humidity
    and air pressure values we set for the room the simulated node is in.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to effectively develop for MCU-based targets
    in a way that allows us to test them without expensive and long-winded development
    cycles. We learned how to implement an integration environment that allows us
    to debug MCU-based applications from the comfort of a desktop OS and the tools
    it provides.
  prefs: []
  type: TYPE_NORMAL
- en: The reader should now be able to develop integration tests for MCU-based projects
    and effectively use OS-based tools to profile and debug them before doing final
    integration work on real hardware. The reader should also be able to perform on-chip
    debugging, and have a feel for the relative cost of specific software implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll develop a simple infotainment system, based on an
    SBC platform.
  prefs: []
  type: TYPE_NORMAL
