- en: Testing Resource-Restricted Platforms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试资源受限平台
- en: Developing for MCUs and similar resource-restricted platforms is pretty much
    exclusively done on regular PCs, except for testing and debugging. The question
    is when one should be testing on the physical device and when one should be looking
    at alternative means of testing and debugging code in order to speed up development
    and debugging efforts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为MCU和类似资源受限的平台开发几乎完全在常规PC上进行，除了测试和调试。问题是何时应该在物理设备上进行测试，何时应该寻找替代的测试和调试代码的方法，以加快开发和调试工作。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the resource needs of specific code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解特定代码的资源需求
- en: Effectively using Linux-based tools to test cross-platform code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用基于Linux的工具测试跨平台代码
- en: Using remote debugging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程调试
- en: Using cross-compilers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交叉编译器
- en: Creating a platform-independent build system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建平台无关的构建系统
- en: Reducing wear
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少磨损
- en: 'Often, during development, there comes that point where one is fixing an issue
    in a system and have to go through the same tweak-compile-deploy-test cycle, over
    and over. Here are the main problems that are introduced with this approach:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在开发过程中，会出现这样一个时刻，即一个人在系统中修复一个问题，不得不一次又一次地经历相同的调整-编译-部署-测试循环。以下是这种方法引入的主要问题：
- en: '**It''s not fun**: It''s frustrating to have to constantly wait for results
    without a clear idea of whether it will actually be fixed this time.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这并不有趣**：在没有明确想法的情况下，不得不不断等待结果，这很令人沮丧。'
- en: '**It''s not productive**: You spend a lot of time waiting for results you wouldn''t
    need if you could just analyze the problem better.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这并不高效**：如果你能更好地分析问题，你就不需要花费大量时间等待结果。'
- en: '**It wears down the hardware**: After removing and reinserting the same connectors
    dozens of times, writing and overwriting the same sections of the ROM chip countless
    times, and power cycling the system hundreds of times, the hardware''s lifespan
    is reduced significantly, along with one''s own patience, and new errors are introduced.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这会磨损硬件**：在反复拔插相同的连接器数十次，无数次写入和覆盖ROM芯片的相同部分，以及数百次系统电源循环之后，硬件的使用寿命显著降低，同时也会消耗个人的耐心，并引入新的错误。'
- en: '**Fiddling with test hardware isn''t fun**: The best-case scenario for any
    embedded setup is to be able to take the development board, plug in all the peripherals
    and wiring, flash the ROM with the application, and power it up to see it work.
    Any deviation from this scenario is frustrating and time-consuming.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摆弄测试硬件并不有趣**：任何嵌入式设置的理想情况是能够拿开发板，插入所有外围设备和线路，用应用程序闪存ROM，然后通电以查看其工作。任何与此场景的偏差都是令人沮丧且费时的。'
- en: Avoiding such cycles during development is therefore essential. The question
    is how we can most effectively get to a point where we can produce code for something
    such as an 8-bit MCU or a larger 32-bit ARM MCU without ever touching the hardware
    until the final stages of testing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在开发过程中避免此类循环至关重要。问题是，我们如何最有效地达到这样一个点，即在没有接触硬件的情况下，直到测试的最后阶段，为8位MCU或更大的32位ARM
    MCU生成代码。
- en: Planning out a design
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计规划
- en: In [Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml), *Resource-Restricted
    Embedded Systems*, we looked at how to pick an appropriate microcontroller for
    an embedded platform. While designing the firmware for the MCU, it's essential
    that we consider not only the resource requirements of specific codes, but also
    the ease of debugging.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml)《资源受限嵌入式系统》中，我们探讨了如何为嵌入式平台选择合适的微控制器。在设计MCU的固件时，我们不仅要考虑特定代码的资源需求，还要考虑调试的便捷性。
- en: An important advantage of using C++ is the abstractions it offers, including
    the ability to subdivide the code into logical classes, namespaces, and other
    abstractions that allow us to easily reuse, test, and debug the code. This is
    a crucial aspect in any design, and an aspect that needs to be implemented fully
    before one can proceed with actually implementing the design.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++的一个重要优势是它提供的抽象，包括将代码细分为逻辑类、命名空间和其他抽象的能力，这些抽象使我们能够轻松地重用、测试和调试代码。这是任何设计的关键方面，并且在开始实际实施设计之前，需要完全实现这一方面。
- en: Depending on the design, it can be either very easy or frustratingly hard to
    debug any issue, or anything in between. If there's a clean separation between
    all the functionality, without leaky APIs or similar problems that could leak
    internal, private data, creating different versions of fundamental classes for
    things such as integration and unit testing will be easy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设计，调试任何问题或任何内容可能非常容易或令人沮丧地困难，或者介于两者之间。如果所有功能之间有清晰的分离，没有泄漏API或类似问题，这些可能泄露内部、私有数据，那么为集成和单元测试等创建基本类的不同版本将很容易。
- en: Simply using classes and the like is no guarantee for a design that is modular.
    Even with such a design one can still end up passing internal class data between
    classes, thus breaking modularity. When this happens, i will complicate the overall
    design as the level of dependencies increases with changes to data structures
    and data formats potentially causing issues elsewhere in the application and will
    require creative hacks while writing tests and reimplementing APIs as part of
    larger integration tests.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用类等并不能保证设计是模块化的。即使有这样的设计，仍然可能在类之间传递内部类数据，从而破坏模块化。当这种情况发生时，随着数据结构和数据格式的变化，依赖性水平增加，可能会在应用程序的其他地方引起问题，并需要在编写测试和重新实现API作为更大集成测试的一部分时进行创造性修复。
- en: In [Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml), *Resource-Restricted
    Embedded Systems*, we looked at how to pick the proper MCU. The points of RAM,
    ROM, and floating-point usage are obviously down to the design we picked to fit
    the project. As we covered in [Chapter 2](cae3bf4a-2936-42b4-a33e-569e693bfcc8.xhtml),
    *C++ as an Embedded Language*, it's important to understand what the code we write
    is compiled into. This understanding allows one to get an intuitive feeling for
    what the resource cost of a line of code is going to be like without having to
    step through the generated machine code and create an exact clock cycle count
    from there.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml)，*资源受限嵌入式系统*中，我们探讨了如何选择合适的微控制器（MCU）。RAM、ROM和浮点使用的要点显然取决于我们为项目选择的设计。正如我们在[第2章](cae3bf4a-2936-42b4-a33e-569e693bfcc8.xhtml)，*C++作为嵌入式语言*中提到的，理解我们编写的代码被编译成什么是很重要的。这种理解使得人们可以直观地感受到一行代码的资源消耗，而无需逐行检查生成的机器代码并创建精确的时钟周期计数。
- en: It should be obvious at this point that before one can pick an MCU, one must
    have a pretty good idea of the overall design and the resource requirements, so
    starting off with a solid design is essential.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，很明显，在挑选微控制器之前，必须对整体设计和资源需求有一个相当好的了解，因此从稳固的设计开始是至关重要的。
- en: Platform-independent build systems
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台无关的构建系统
- en: Ideally, the project and build system we choose could be used to build the target
    platform on any desktop platform. Usually, the main consideration here is the
    availability of the same toolchain and programmer for each development platform.
    Fortunately, for AVR- and ARM-based MCU platforms, the same GCC-based toolchain
    is available, so that we do not have to take different toolchains with different
    naming conventions, flags and settings into account.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们选择的项目和构建系统可以用于在任意桌面平台上构建目标平台。通常，这里的主要考虑因素是每个开发平台是否都有相同的工具链和程序员。幸运的是，对于基于AVR和ARM的MCU平台，可用的GCC工具链是相同的，因此我们不需要考虑不同命名约定、标志和设置的多种工具链。
- en: The remaining challenge is simply to invoke the toolchain, and subsequently
    the programmer utility, in a way that doesn't require any knowledge of the underlying
    OS.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的挑战仅仅是调用工具链，随后是程序员工具，而无需了解底层操作系统。
- en: 'In [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*, we looked at a multitarget build system, which could produce binaries
    for a wide variety of targets with minimal effort for each new target. For an
    MCU target, there would only be the following two targets:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)，*基于操作系统的应用程序测试*中，我们探讨了一个多目标构建系统，它可以以最小的努力为各种目标生成二进制文件。对于MCU目标，将只有以下两个目标：
- en: The physical MCU target
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理MCU目标
- en: The local OS target
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地操作系统目标
- en: Here, the first target is obviously fixed, as we picked out the MCU that we
    wanted to target. Barring any unpleasant surprises, we will be using this one
    target for the entire development process. In addition, we will want to preform
    local testing on our development PC. This is the second target.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个目标显然是固定的，因为我们选择了我们想要的目标MCU。除非出现任何不愉快的情况，否则我们将在整个开发过程中使用这个目标。此外，我们还想在我们的开发PC上进行本地测试。这是第二个目标。
- en: Here it would be great if there is a version of the same or similar  C++ toolchain
    on each mainstream desktop OS. Fortunately, we find that GCC is available on just
    about any platform imaginable, with the Clang C++ frontend of the LLVM toolchain
    using regular GCC-style flags, providing us with broad compatibility.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在每个主流桌面操作系统上都有一个相同或类似的C++工具链版本，那就太好了。幸运的是，我们发现GCC几乎在任何可想象的平台上都可用，LLVM工具链的Clang
    C++前端使用常规GCC风格的标志，为我们提供了广泛的兼容性。
- en: Instead of requiring the complexity of a multitarget build system, as we saw
    in [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*, we can simplify it so it that  just uses GCC, which would allow
    us to use that toolchain on Linux- and BSD-based OSes, along with Windows (MinGW
    via MSYS2 or equivalent) and macOS (after installing GCC).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)中看到的需要多目标构建系统的复杂性不同，*基于操作系统的应用程序测试*，我们可以简化它，使其仅使用GCC，这将允许我们在基于Linux和BSD的操作系统以及Windows（通过MSYS2或等效工具）和macOS（安装GCC后）上使用该工具链。
- en: For full compatibility on macOS, the use of GCC is recommended, due to small
    issues in the Clang implementation. One of these current issues is the `__forceinline`
    macro attribute being broken, for example, which would break a lot of code that
    assumes the GCC compiler.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Clang实现中存在一些小问题，建议在macOS上使用GCC以实现完全兼容性。其中一个当前的问题是`__forceinline`宏属性损坏，例如，这会破坏许多假设使用GCC编译器的代码。
- en: Using cross-compilers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用交叉编译器
- en: Every compiler toolchain consists of a side (frontend) that takes in the source
    code and a side that outputs the binary format for the target platform (backend).
    There's no reason why the backend couldn't work on any other platform than the
    one it's targeting. In the end, one merely transforms text files into sequences
    of bytes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编译器工具链都由一个前端（前端）组成，它接收源代码，以及一个后端，它为目标平台输出二进制格式。没有理由后端不能在除了它所针对的平台之外的任何其他平台上工作。最终，它只是将文本文件转换为字节序列。
- en: Cross-compiling in this fashion is an essential feature with MCU-oriented development,
    as compiling directly on those MCUs would be highly inefficient. There is, however,
    nothing magical about this process. In the case of GCC-based and GCC-compatible
    toolchains, one would still be interacting with the same interfaces on the toolchain,
    just with the tools usually prefixed with the target platform name to distinguish
    them from other toolchains for different targets. Essentially, instead of `g++` one
    would use `arm-none-eabi-g++`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式的交叉编译对于以MCU为导向的开发是基本功能，因为直接在这些MCU上编译将非常低效。然而，这个过程并没有什么神奇之处。对于基于GCC和GCC兼容的工具链，用户仍然会与工具链上的相同接口交互，只是工具通常以目标平台名称作为前缀来区分它们与其他目标的不同工具链。本质上，用户将使用`arm-none-eabi-g++`而不是`g++`。
- en: The resulting binaries would be in the format appropriate for that target platform.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的二进制文件将适合该目标平台的格式。
- en: Local and on-chip debugging
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地和片上调试
- en: In [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*, we looked at debugging applications using Valgrind and similar
    tools, as well as GDB and kin. With the OS-based integration tests for MCU-based
    projects, such as those demonstrated in the *Example – ESP8266 integration test* section,
    we can use the exact same techniques, profiling and debugging the code without
    concerning ourselves just yet with the fact that the same code will be running
    on a much slower and more limited platform during final integration testing on
    real hardware.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)中，*基于操作系统的应用程序测试*，我们探讨了使用Valgrind和类似工具以及GDB等工具调试应用程序，以及基于MCU项目的基于操作系统的集成测试，例如在*示例
    - ESP8266集成测试*部分中展示的。我们可以使用完全相同的技术，在代码进行最终硬件集成测试时，无需担心相同的代码将在一个速度较慢且功能更有限的平台上运行。
- en: The real challenge comes during that final integration stage, when the firmware—which
    we have been debugging on our fast desktop system using Valgrind and other highly
    capable tools—is now running on a paltry 16 MHz ATmega MCU without the ability
    to quickly launch the code with a Valgrind tool or within a GDB session.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的挑战出现在最终的集成阶段，当我们在使用 Valgrind 和其他高度强大的工具在快速的桌面系统上调试固件时，固件现在运行在一个可怜的 16 MHz
    ATmega MCU 上，没有能力快速使用 Valgrind 工具或 GDB 会话来启动代码。
- en: As one will inevitably encounter bugs and issues during this stage, we need
    to be prepared to deal with this situation. Often, one has to resort to **on-chip
    debugging** (**OCD**), which can be performed over whichever debugging interface
    the MCU provides. This can be JTAG, DebugWire or SWD, PDI, or some other type.
    In [Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml), *Resource-Restricted
    Embedded Systems*, we looked at some of those interfaces in the context of programming
    these MCUs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个阶段不可避免地会遇到错误和问题，我们需要准备好处理这种情况。通常，人们不得不求助于**片上调试**（**OCD**），这可以通过 MCU 提供的任何调试接口进行。这可以是
    JTAG、DebugWire 或 SWD、PDI 或其他类型。在[第4章](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml)
    *资源受限嵌入式系统*中，我们探讨了这些接口在编程这些 MCU 时的应用。
- en: Embedded IDEs will provide the ability to perform OCD right out of the box,
    connecting with the target hardware, allowing one to set breakpoints, much like
    one would be used to setting for a local process. Of course, it's also possible
    to use GDB from the command line to do the same thing, using a program such as
    OpenOCD ([http://openocd.org/](http://openocd.org/)), which provides a `gdbserver`
    interface for GDB while interfacing with a wide variety of debug interfaces.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式 IDE 将提供直接进行 OCD 的能力，连接到目标硬件，允许用户设置断点，就像设置本地进程的断点一样。当然，也可以使用命令行中的 GDB 来做同样的事情，使用像
    OpenOCD ([http://openocd.org/](http://openocd.org/)) 这样的程序，它为 GDB 提供了一个 `gdbserver`
    接口，同时与各种调试接口进行交互。
- en: Example – ESP8266 integration test
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - ESP8266 集成测试
- en: In this example project, we will look at creating an implementation of the Arduino-like
    APIs of the Sming framework, which we first looked at it in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml),
    *Example - Soil Humidity Monitor with Wi-Fi*. The goal of this is to provide a
    native framework implementation for desktop **operating systems** (**OSes**),
    allowing the firmware to be compiled to an executable and run locally.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例项目中，我们将探讨创建 Sming 框架类似 Arduino 的 API 的实现，我们首次在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中看到它，*示例
    - 带Wi-Fi的土壤湿度监测器*。这个目标是为桌面**操作系统**（**OSes**）提供一个本机框架实现，允许固件被编译成可执行文件并在本地运行。
- en: In addition, we want to have simulated sensors and actuators that the firmware
    can connect to in order to read out environmental data and send data to actuators
    as part of the BMaC project, which we had a glimpse of in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example -
    Soil Humidity Monitor with WiFi*, and which we will look at in more detail in
    [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml), *Example - Building Monitoring
    and Control*. For this, we also need to have a central service that keeps track
    of such information. This way, we can also have multiple firmware processes running,
    to simulate entire rooms full of devices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望在 BMaC 项目中，固件能够连接到模拟的传感器和执行器，以便读取环境数据并将数据发送到执行器。我们曾在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中一瞥该项目，*示例
    - 带WiFi的土壤湿度监测器*，并在[第9章](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)中更详细地探讨，*示例
    - 建筑监控与控制*。为此，我们还需要一个中央服务来跟踪此类信息。这样，我们也可以运行多个固件进程，以模拟充满设备的整个房间。
- en: The reason for this scope of the simulation is due to not having the physical
    hardware. Without a physical MCU system, we don't have physical sensors, and these
    sensors would not exist in a physical room. Ergo we have to generate plausible
    input for the sensors and simulate the effect of any actuators.  This does however
    come with a lot of advantages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟这个范围的原因是因为没有物理硬件。没有物理 MCU 系统，我们就没有物理传感器，这些传感器在物理房间中也不存在。因此，我们必须为传感器生成合理的输入，并模拟任何执行器的效果。然而，这确实带来了很多优势。
- en: Having this scaling ability is useful in that it allows us to validate the firmware
    not only as a standalone system, but also as part of the system it would be installed
    in. In the case of BMaC, this would mean a single node installed in a room of
    a building, with dozens to hundreds of further nodes installed in the same and
    other rooms across the building's floors, along with accompanying backend services
    running on the same network.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这种扩展能力是有用的，因为它不仅允许我们验证固件作为一个独立系统，还允许我们验证它将安装在内的系统。在BMaC的情况下，这意味着在建筑的一个房间中安装一个节点，然后在建筑的其他楼层和房间中安装数十到数百个其他节点，同时伴随在相同网络上的后端服务运行。
- en: With this kind of large-scale simulation ability, one can test not only the
    basic correctness of the firmware by itself, but also that of the system as a
    whole, with the different firmware types or even versions running in tandem with
    the various sensors and actuators (for air-conditioning units, fans, coffee machines,
    switches, and so on). In addition to this, the backend services would be directing
    the nodes according to the data being passed to them from the same nodes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这种大规模仿真能力，人们不仅可以测试固件本身的基本正确性，还可以测试整个系统的正确性，包括不同类型的固件或版本与各种传感器和执行器（如空调单元、风扇、咖啡机、开关等）协同运行。除此之外，后端服务还会根据从同一节点传递给它们的数据来指导节点。
- en: Within the simulated building, one could then configure specific rooms to have
    particular environmental conditions, run through a working day with people entering,
    working, and leaving, to determine the effect of different levels of building
    occupation, outside conditions, and so on. You could also do this with the firmware
    and backend services that would be used for the final production system. While
    testing a system this way won't fully eliminate any potential problems, it should
    at least validate that the software side of the system is functionally correct.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟的建筑内，可以配置特定的房间以具有特定的环境条件，模拟一个工作日，人们进入、工作和离开，以确定不同建筑占用水平、外部条件等因素的影响。您也可以使用最终生产系统将使用的固件和后端服务进行此操作。虽然以这种方式测试系统不会完全消除任何潜在问题，但它至少可以验证系统的软件部分在功能上是正确的。
- en: As embedded systems are by definition part of a larger (hardware-based) system,
    a full integration test will involve the actual hardware or its equivalent. One
    could therefore consider this example the software integration test, prior to
    deploying the firmware to the target hardware in a physical building.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于嵌入式系统本质上是大系统（基于硬件）的一部分，完整的集成测试将涉及实际硬件或其等效物。因此，可以将此示例视为软件集成测试，在将固件部署到物理建筑的目标硬件之前。
- en: Both the simulation server and the individual firmware processes have their
    own main function and run independently from each other. This allows us to inspect
    the functioning of the firmware with as little interference as possible and promotes
    a clean design. To allow efficient communication between these processes, we use
    a **remote procedure call** (**RPC**) library, which essentially creates a connection
    between the firmware and the I2C, SPI, and UART-based devices in the simulated
    room. The RPC library used with this example is NymphRPC, an RPC library developed
    by the author. The source for the current version has been included with the source
    code for this chapter. The current version of the NymphRPC library can be found
    at its GitHub repository at [https://github.com/MayaPosch/NymphRPC](https://github.com/MayaPosch/NymphRPC).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟服务器和单个固件进程都有自己的主函数，并且相互独立运行。这使我们能够尽可能少地干扰地检查固件的功能，并促进良好的设计。为了允许这些进程之间高效通信，我们使用了一个**远程过程调用**（**RPC**）库，它本质上在固件和模拟房间中的基于I2C、SPI和UART的设备之间建立连接。本例中使用的RPC库是NymphRPC，这是作者开发的一个RPC库。当前版本的源代码已包含在本章的源代码中。当前版本的NymphRPC库可以在其GitHub仓库[https://github.com/MayaPosch/NymphRPC](https://github.com/MayaPosch/NymphRPC)找到。
- en: The server
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: We will first look at the server for this integration test. Its role is to run
    the RPC server and to maintain the state of each of the sensor and actuator devices,
    as well as the rooms.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看这个集成测试的服务器。其作用是运行RPC服务器并维护每个传感器和执行器设备以及房间的状态。
- en: 'The main file, `simulation.cpp`, sets up the RPC configuration as well as the
    main loop, as shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 主要文件`simulation.cpp`设置了RPC配置以及主循环，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The includes at the top shows us the basic structure and dependencies. We have
    a custom configuration class, a class defining the building, a static class for
    the nodes, and finally the multithreading headers (available since C++11) and
    the NymphRPC RPC header to gain access to its functionality.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的包含文件显示了基本结构和依赖关系。我们有一个自定义配置类，一个定义构建的类，一个用于节点的静态类，最后是多线程头文件（自C++11起可用）和NymphRPC
    RPC头文件，以便访问其功能。
- en: A signal handler function is defined to be used with the waiting condition later
    on, allowing the server to be terminated with a simple control signal. Finally,
    a logging function is defined for use with the NymphRPC server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个信号处理函数，稍后将与等待条件一起使用，允许服务器通过简单的控制信号终止。最后，定义了一个用于NymphRPC服务器的日志函数。
- en: 'Next, we define the callback functions for the RPC server, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义RPC服务器的回调函数，如下所示：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the initial function that the clients will call on the server. It will
    check the global, static `Nodes` class for an available MAC address. This address
    uniquely identifies a new node instance, the way a device on the network would
    also be identified by its unique Ethernet MAC address. This is an internal function
    that will not require modification of the firmware, but shifts the ability to
    assign MACs to the server, instead of­ having them hardcoded somewhere. When a
    new MAC has been assigned, it gets associated with the NymphRPC session ID so
    that we can later use the MAC to find the appropriate session ID and, with it,
    the client to call for events generated by simulated devices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端将在服务器上调用的初始函数。它将检查全局静态`Nodes`类以获取可用的MAC地址。这个地址唯一地标识了一个新的节点实例，就像网络上的设备也会通过其唯一的以太网MAC地址被识别一样。这是一个内部函数，不需要修改固件，但将分配MAC的能力从服务器转移到，而不是将它们硬编码在某个地方。当一个新MAC被分配后，它将与NymphRPC会话ID相关联，这样我们就可以稍后使用MAC来找到适当的会话ID，以及与之相关的客户端，以调用由模拟设备生成的事件。
- en: 'Here, we also see the basic signature of a NymphRPC callback function as used
    on a server instance. It obviously returns the return message, and it receives
    as its parameters the session ID associated with the connected client, the message
    received from this client, and some user-defined data, as shown in the following
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还可以看到NymphRPC回调函数的基本签名，如用于服务器实例的。它显然返回返回消息，并接收与其关联的客户端会话ID、从该客户端接收的消息以及一些用户定义的数据，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This callback implements a way to write to the UART interface of a simulated
    node within the simulation, addressing whichever simulated device is hooked up
    to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调函数实现了一种在模拟中向模拟节点UART接口写入数据的方法，解决了连接到该接口的任何模拟设备。
- en: 'To find the node, we use the MAC address and send it, along with the bytes,
    to be written to the appropriate `Nodes` class function, as shown in the following
    code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到节点，我们使用MAC地址，并发送它以及要写入的字节到适当的`Nodes`类函数，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the SPI bus, a similar system is used for writing and reading. The MAC
    identifies the node and either a string is sent to the bus or is received from
    it. One limitation here is that we assume the presence of only a single SPI device,
    since there is no way to select a different SPI **chip-select** (**CS**) line.
    A separate CS parameter would have to be passed here to enable more than one SPI
    device. Let''s look at the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SPI总线，用于写入和读取的系统类似。MAC标识节点，要么向总线发送字符串，要么从总线接收字符串。这里的限制是，我们假设只有一个SPI设备的存在，因为没有方法来选择不同的SPI
    **芯片选择**（**CS**）线。必须在这里传递一个单独的CS参数，才能启用多个SPI设备。让我们看看以下代码：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the I2C bus version, we pass the I2C slave device address to allow us to
    use more than a single I2C device.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于I2C总线版本，我们传递I2C从设备地址，以便我们可以使用多个I2C设备。
- en: 'Finally, the main function registers the RPC methods, starts the simulation,
    and then enters a waiting condition, as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主函数注册RPC方法，启动模拟，然后进入等待状态，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We first get the configuration data for this simulation using the following
    code. This is all defined in a separate file, that we will load using the special
    `Config` class, which we will take a more detailed look at in a moment when we
    look at the configuration parser.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用以下代码获取此模拟的配置数据。所有这些都在一个单独的文件中定义，我们将使用特殊的`Config`类来加载它，我们将在稍后查看配置解析器时更详细地了解这个类。
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this code, we register the further methods we wish to provide to the client
    node processes, allowing these to call the functions we looked at earlier in this
    source file. In order to register a server-side function with NymphRPC, we have
    to define the parameter types (in order) and use these to define a new `NymphMethod`
    instance, which we provide with this parameter type list, the function name, and
    the return type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们注册了希望提供给客户端节点进程的进一步方法，允许它们调用我们在这篇源文件中之前查看过的函数。为了将服务器端函数注册到NymphRPC，我们必须定义参数类型（按顺序）并使用这些类型来定义一个新的`NymphMethod`实例，我们将这个参数类型列表、函数名和返回类型提供给这个实例。
- en: 'These method instances are then registered with `NymphRemoteClient`, which
    is the top-level class for the server-side NymphRPC, as shown in the following
    code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法实例随后被注册到`NymphRemoteClient`，这是服务器端NymphRPC的顶级类，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, we install the signal handler for SIGINT (*Ctrl* + *c*) signals. The
    NymphRPC server is started on port 4004, all interfaces. Next, a `Building` instance
    is created, providing it with the instance of the configuration we loaded earlier
    with the configuration parser class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们安装了SIGINT（*Ctrl* + *c*）信号的信号处理程序。NymphRPC服务器在端口4004上启动，所有接口。接下来，创建一个`Building`实例，通过配置解析器类提供我们之前加载的配置实例。
- en: We then start a loop that checks whether the value of the `gPredicate` global
    variable has changed to `true`, which will be the case if the signal handler has
    been triggered, and this Boolean variable has been set to `true`. A condition
    variable is used to allow us to block the main thread execution as much as possible
    by having the signal handler notify this condition variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动一个循环，检查全局变量`gPredicate`的值是否已更改为`true`，如果是这样，那么信号处理程序已经被触发，并且这个布尔变量已被设置为`true`。我们使用条件变量来允许我们尽可能多地阻塞主线程的执行，通过让信号处理程序通知这个条件变量。
- en: By having the condition variable's wait condition inside a loop, we ensure that
    even if the condition variable's wait condition suffers a spurious wake up, it'll
    simply go back to waiting to be notified.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将条件变量的等待条件放在循环中，我们确保即使条件变量的等待条件遭受了虚假唤醒，它也会简单地回到等待被通知的状态。
- en: Lastly, if the server is requested to terminate, we shut down the NymphRPC server,
    before giving all active threads an additional two seconds to cleanly terminate.
    After this, the server shuts down.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果服务器被请求终止，我们在给所有活跃线程额外两秒钟时间干净地终止之前关闭NymphRPC服务器。之后，服务器关闭。
- en: 'Next, let''s look at the `config.cfg` file that we loaded for this simulation,
    as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看为这次模拟加载的`config.cfg`文件，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, this configuration file uses the standard INI configuration file
    format. It defines a building with two floors, each with two rooms. Each room
    has a single node and each node has a BME280 sensor attached to it on the I2C
    bus.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个配置文件使用了标准的INI配置文件格式。它定义了一栋有两层楼的建筑，每层楼有两间房间。每个房间有一个节点，每个节点都通过I2C总线连接了一个BME280传感器。
- en: More devices are defined, but are left unused here.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了更多设备，但在这里留作未使用。
- en: 'Let''s look at the configuration parser shown in the following code, which
    parses the preceding format, declared in config.h:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码中所示的配置解析器，它解析了在config.h中声明的先前格式：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we see an interesting use of templates, as well as one of their limitations.
    The type passed to the template is used both for the default parameter and the
    return type, allowing the template to cast the raw string obtained from the configuration
    file to the desired type, while also avoiding the issue of incomplete templates
    by only using the type in the return type of the function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到模板的一个有趣的使用，以及它们的局限性之一。传递给模板的类型既用于默认参数也用于返回类型，这使得模板可以将从配置文件中获得的原始字符串转换为所需的类型，同时通过仅在函数的返回类型中使用类型来避免不完整的模板问题。
- en: Due to the limitation of C++, where every function with the same name must have
    a different set of parameters even if their return value differs, we must use
    the default value parameter here to circumvent that issue. As most of the time
    we want to provide a default value for the keys we are trying to read, this isn't
    much of an issue here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++的限制，即使函数的返回值不同，同名函数也必须有一组不同的参数，因此我们必须在这里使用默认值参数来规避这个问题。由于我们大多数时候都希望为尝试读取的键提供默认值，所以这在这里并不是一个大问题。
- en: Finally, we do a bit of type comparison with `std::is_same` to ensure that if
    the target return type is a string, we copy the string straight out of `stringstream`
    instead of trying to convert it using formatted output. As we read the values
    from the INI file using the POCO INI file reader as raw strings, there's no need
    to do any kind of conversion on this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`std::is_same`进行一些类型比较，以确保如果目标返回类型是字符串，我们直接从`stringstream`中复制字符串，而不是尝试使用格式化输出进行转换。由于我们使用POCO
    INI文件读取器以原始字符串的形式从INI文件中读取值，因此不需要进行任何类型的转换。
- en: 'Its implementation in `config.cpp` is pretty small, as a result of templates
    having to be defined in the header file. You can see this in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config.cpp`中的实现相当小，因为模板必须在头文件中定义。您可以在以下代码中看到这一点：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We just implement the method here, which actually loads the configuration file
    from the filename string. In this implementation, we create an instance of the
    POCO `IniFileConfiguration` class on the assumption that we are trying to parse
    an INI file. If loading the configuration file fails for whatever reason, we return
    an error.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只是实现了这个方法，它实际上是从文件名字符串中加载配置文件。在这个实现中，我们假设我们正在尝试解析INI文件，因此创建了一个POCO `IniFileConfiguration`类的实例。如果由于任何原因无法加载配置文件，我们返回一个错误。
- en: In a more fleshed-out version of this parser, we would maybe support different
    configuration types or even sources, with advanced error handling. For our purposes,
    the humble INI format more than suffices.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解析器的更完善版本中，我们可能会支持不同的配置类型或甚至来源，并具有高级错误处理。对于我们的目的，简单的INI格式已经足够。
- en: 'Moving on, the following code shows the `Building` class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以下代码显示了`Building`类：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because we haven''t added any advanced features to the simulation server, there
    isn''t much to see here yet, nor in its implementation, as shown in the following
    code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有向模拟服务器添加任何高级功能，这里以及其实现中目前还没有太多可看的内容，如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we read each floor definition from the file and create a `Floor` instance
    for it, which we add to an array. The instances also receive a reference to the
    configuration object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从文件中读取每个楼层的定义，并为它创建一个`Floor`实例，将其添加到数组中。这些实例也接收对配置对象的引用。
- en: 'The `Floor` class is basic as well, for the same reason, as you can see in
    the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Floor`类同样很简单，原因相同，您可以在以下代码中看到：'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s its implementation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其实现：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of note is the way that the central configuration file is being parsed one part
    at a time by each individual class, with each class instance only caring about
    the small section that it has been instructed to care about by the ID.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，中央配置文件是由每个类逐部分解析的，每个类实例只关心它被ID指示关注的小部分。
- en: Here, we are only concerned with the rooms that are defined for this floor ID.
    We extract the IDs for those rooms, then create new class instances for those
    rooms, saving a copy of each room in a vector. In a more advanced implementation
    of the simulation server, we could implement floor-wide events here, for example.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只关注为该楼层ID定义的房间。我们提取这些房间的ID，然后为这些房间创建新的类实例，并将每个房间的副本保存到vector中。在更高级的模拟服务器实现中，我们可以在这里实现楼层范围的事件，例如。
- en: 'The utility header here defines a simple method for splitting strings, as shown
    in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义了一个简单的字符串分割方法，如下所示：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s its implementation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其实现：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function is quite simple, using the provided separator to take a string
    and separate it into parts defined by said separator, which then get copied into
    a vector using emplacement.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当简单，使用提供的分隔符将字符串分割成由该分隔符定义的部分，然后将这些部分复制到使用emplacement的vector中。
- en: 'Next, here''s the `Room` class, as declared in `room.h`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是在`room.h`中声明的`Room`类：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s its implementation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其实现：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this class' constructor, we start off by setting the initial conditions of
    this room, specifically the temperature and humidity values. Next, we read out
    the nodes and devices for this room ID, creating instances of each. It starts
    by getting the list of nodes for this room, then for each node we get the list
    of devices, splitting this string into the individual device IDs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类的构造函数中，我们首先设置这个房间的初始条件，特别是温度和湿度值。接下来，我们读取这个房间ID的节点和设备，为每个创建实例。它首先获取这个房间的节点列表，然后对于每个节点，我们获取设备列表，将这个字符串分割成单个设备ID。
- en: Each device ID has a device class instantiated for it, with this instance added
    to the node that uses it. This finishes the basic initialization of the simulation
    server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备ID都有一个为其实例化的设备类，并将此实例添加到使用它的节点中。这完成了模拟服务器的初步初始化。
- en: 'Next, here''s the `Device` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是`Device`类：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s its definition:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的定义：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the constructor, we read out the information for this specific device using
    the provided device ID. Depending on the device type, we look for specific keys.
    These are all stored inside member variables, as shown in the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用提供的设备ID读取此特定设备的信息。根据设备类型，我们查找特定的键。所有这些都存储在成员变量中，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After a simple setter method for the MAC of the connected node, we get a method
    that allows generated UART events to trigger a callback to the node process via
    an RPC callback method (as we will see in more detail in a moment when we look
    at the `Nodes` class). This is shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在为连接节点的MAC地址实现了一个简单的setter方法之后，我们得到了一个允许生成的UART事件通过RPC回调方法触发对节点进程的回调的方法（正如我们将在查看`Nodes`类时更详细地看到的那样）。这如下面的代码所示：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We define a generic method to write to the device, regardless of the type.
    Here, we only handle the I2C interface to obtain the device register that''s being
    addressed, as shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个通用的写入设备的方法，无论类型如何。在这里，我们只处理I2C接口以获取正在寻址的设备寄存器，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `read` methods come with a version that defines a length parameter for the
    bytes to be read and a version without parameters, instead passing a zero to the
    first method. This parameter would be useful for a UART, where a fixed buffer
    size would be used for the data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法提供了一个定义了要读取的字节数长度的版本，以及一个不带参数的版本，而不是将零传递给第一个方法。这个参数对于UART很有用，因为在UART中会使用固定大小的缓冲区来存储数据。'
- en: For simplicity's sake, we have hardcoded the response for a BME280 combined
    thermometer, hygrometer, and air pressure meter device. We check the value of
    the register that was sent over with an earlier `write` command, then return the
    value appropriate to it, reading the current room values as appropriate.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们硬编码了BME280组合温度计、湿度计和空气压力计设备的响应。我们检查通过之前的`write`命令发送的寄存器的值，然后返回适当的值，读取适当的当前房间值。
- en: There are many more devices possible, we would want to implement them in their
    own configuration files or dedicated classes instead of hardcoding them all here
    like this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的设备种类还有很多，我们希望将它们实现在自己的配置文件或专用类中，而不是像这样在这里硬编码所有内容。
- en: 'Custom types for the application are defined in the `types.h` header, as shown
    in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的自定义类型在`types.h`头文件中定义，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we see the enumeration for the different connection types, as well as
    the `RoomState` class, which defines a basic getter/setter-based construction,
    with a mutex providing thread-safe access to the individual values, as multiple
    nodes can try to access the same values while the room itself tries to update
    them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到不同连接类型的枚举，以及`RoomState`类，它定义了一个基于基本getter/setter的构造，使用互斥锁提供对单个值的线程安全访问，因为多个节点可能在房间本身尝试更新它们的同时尝试访问相同的值。
- en: 'Next, here''s the `Node` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是`Node`类：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here''s its implementation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的实现：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When a new class instance is created, it obtains its MAC address, adds it to
    its own local variable, and registers it with the `Nodes` class. A new instance
    of the node executable (in our case, called `esp8266`) is launched using the native
    system call, which will cause the OS to start this new process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的类实例时，它会获取其MAC地址，将其添加到自己的局部变量中，并注册到`Nodes`类。使用本地系统调用启动节点可执行程序的新实例（在我们的例子中称为`esp8266`），这将导致操作系统启动这个新进程。
- en: 'As the new process starts, it will connect to the RPC server and obtain the
    MAC using the RPC functions that we looked at earlier in this section. After this,
    the class instance and the remote process act as mirror images of each other:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的进程启动时，它将通过我们在此节之前查看的RPC函数连接到RPC服务器并获取MAC地址。之后，类实例和远程进程将作为彼此的镜像：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the `Room` class assigns a new device to the node, we assign our MAC to
    it to act as an identifier for which node it belongs to. After this, we query
    the device to see which type of interface it has, so that we can add it to the
    proper interface, taking into account the CS line (if used) for SPI and the bus
    address for I2C.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Room`类将新设备分配给节点时，我们将我们的MAC地址分配给它，作为标识符，表明它属于哪个节点。之后，我们查询设备以查看它具有哪种类型的接口，这样我们就可以将其添加到适当的接口，考虑到CS线（如果使用）用于SPI和总线地址用于I2C。
- en: 'Using move semantics, we ensure that we aren''t merely mindlessly making copies
    of the same device class instance, but essentially shifting ownership of the original
    instance, thus improving efficiency. Let''s look at the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移动语义，我们确保我们不仅仅是无意识地复制相同的设备类实例，而是本质上转移原始实例的所有权，从而提高效率。让我们看看以下代码：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For the writing and reading functionality, not a lot is involved. Using the
    CS (SPI), the bus address (I2C), or neither (UART), we know which type of device
    to access and call its respective methods.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于写入和读取功能，涉及的内容不多。使用CS（SPI）、总线地址（I2C）或两者都不用（UART），我们知道要访问哪种类型的设备并调用其相应的方法。
- en: 'Finally, here''s the `Nodes` class that ties everything together:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是将一切联系起来的`Nodes`类：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here''s its definition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的定义：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the following methods, we can set and remove node class instances:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方法，我们可以设置和删除节点类实例：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'New MAC and RPC session IDs are registered with the following function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 新的MAC和RPC会话ID通过以下函数注册：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The methods for writing and reading from the different interfaces are basically
    pass-through methods, merely using the MAC address to find the appropriate `Node`
    instance to call the method on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同接口写入和读取的方法基本上是透传方法，仅使用MAC地址来找到适当的`Node`实例并调用其方法。
- en: 'Of note here is the `sendUart()` method, which uses the NymphRPC server to
    call the callback method on the appropriate node process to trigger its UART receive
    callback, as shown in the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是`sendUart()`方法，它使用NymphRPC服务器在适当的节点进程中调用回调方法以触发其UART接收回调，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, we got the methods used to set and get the MAC address for new nodes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了用于设置和获取新节点MAC地址的方法。
- en: With this, we have the basics of the full integration server. In the next section,
    we will take a look at the firmware and client side of the system before looking
    at how everything fits together.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们有了完整集成服务器的基础知识。在下一节中，我们将先查看系统的固件和客户端，然后再看看一切是如何结合在一起的。
- en: Makefile
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Makefile
- en: 'The Makefile for this part of the project looks as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的这部分Makefile如下所示：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a rather simple Makefile as we have no special demands. We gather the
    source files, determine the names of the resulting object files, and compile all
    of them before generating a binary out of these object files.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的Makefile，因为我们没有特殊要求。我们收集源文件，确定结果目标文件的名称，然后在这些目标文件生成二进制文件之前将它们全部编译。
- en: The node
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: This section covers the firmware for the integration test specifically the reimplementation
    of the (Arduino) APIs used in the Sming framework.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了集成测试的固件，特别是对Sming框架中使用的（Arduino）API的重实现。
- en: Most crucial here is that we don't in any way modify the firmware code itself.
    The only parts that we wish to change from the original firmware image for the
    ESP8266 MCU are the APIs that our own code interacts with.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们以任何方式都不会修改固件代码本身。我们希望从原始ESP8266 MCU固件映像中更改的唯一部分是我们自己的代码与之交互的API。
- en: This means that we have to first determine the APIs that our code interacts
    with and reimplement these in a way that is supported on the target (desktop)
    platform. For our ESP8266-based firmware, this means, for example, that the Wi-Fi
    network side is left unimplemented, as we are using the local network stack of
    the OS and therefore don't care about such details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们首先必须确定我们的代码与之交互的API，并以在目标（桌面）平台上支持的方式重新实现这些API。对于我们的基于ESP8266的固件，这意味着例如，Wi-Fi网络部分被留空实现，因为我们正在使用操作系统的本地网络堆栈，因此我们不需要关心这些细节。
- en: Similarly, the I2C, SPI, and UART interfaces are implemented as mere stubs that
    call their respective counterparts on the RPC interface, which we looked at in
    the previous section. For the MQTT protocol client, we could use the `emqtt` MQTT
    library that is part of the Sming framework, but as one will quickly find out,
    this library is meant to be used on embedded systems where the code using it is
    responsible for connecting it to the network stack.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，I2C、SPI 和 UART 接口被实现为仅调用 RPC 接口相应对等的简单存根，我们在上一节中讨论过。对于 MQTT 协议客户端，我们可以使用
    Sming 框架中包含的 `emqtt` MQTT 库，但正如人们很快会发现的那样，这个库旨在用于嵌入式系统，其中使用它的代码负责将其连接到网络堆栈。
- en: Our code interacts with the API offered by the `MqttClient` class in Sming.
    It uses `emqtt` for the MQTT protocol, and inherits from the `TcpClient` class.
    Following the code down the hierarchy, one will end up at the TCP connection class
    before diving into the underlying LWIP network library stack.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码与 Sming 中 `MqttClient` 类提供的 API 交互。它使用 `emqtt` 进行 MQTT 协议，并从 `TcpClient`
    类继承。沿着代码层次结构向下，最终会到达 TCP 连接类，然后再深入到底层的 LWIP 网络库堆栈。
- en: In order to save ourselves a lot of trouble, it's easiest to just use an alternative
    MQTT library, such as the Mosquitto client library, which is meant to be run on
    a desktop OS, and will therefore use the OS-provided sockets API. This will cleanly
    map to the methods provided by Sming's MQTT client class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免给自己带来很多麻烦，最简单的方法就是使用一个替代的 MQTT 库，例如 Mosquitto 客户端库，它旨在在桌面操作系统上运行，因此将使用操作系统提供的套接字
    API。这将干净地映射到 Sming 的 MQTT 客户端类提供的方法。
- en: 'We can leave the header for this class almost entirely untouched, just adding
    our modifications to integrate the Mosquitto library, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以几乎完全保留这个类的头文件，只需添加我们的修改以集成 Mosquitto 库，如下所示：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We're including the header file for the C++-based wrapper for the Mosquitto
    client library here from the version of the Mosquitto library that is included
    in the project for this chapter. This is because the official version of the library
    doesn't support building with MinGW.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里包含了项目章节中包含的 Mosquitto 库版本的基于 C++ 的包装器头文件。这是因为库的官方版本不支持使用 MinGW 构建。
- en: With the header included, we have the class derive from the Mosquitto MQTT client
    class instead.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了头文件后，我们让这个类从 Mosquitto MQTT 客户端类派生。
- en: 'Naturally, the implementation of the Sming MQTT client class has been completely
    changed, as you can see in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Sming MQTT 客户端类的实现已经完全改变，如下所示代码所示：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The constructor simply initializes the Mosquitto library, with no further input
    required:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只是初始化 Mosquitto 库，不需要进一步输入：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the destructor (shown in the following code) we stop the MQTT client-listening
    thread that we launched when we connect to an MQTT broker and clean up the resources
    that were used by the library:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在析构函数（如下所示代码所示）中，我们停止了在连接到 MQTT 代理时启动的 MQTT 客户端监听线程，并清理了库使用的资源：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have a number of utility functions, not all of which are being utilized,
    but they are still implemented here for the sake of completeness. It''s also hard
    to predict which ones will be required, therefore it''s often better to implement
    more than strictly necessary, especially if they are small functions that take
    less time to implement than to find out whether that function or method is used
    at all. Let''s look at the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些实用函数，并非所有这些函数都在使用中，但为了完整性，我们仍然在这里实现了它们。也很难预测哪些会被需要，因此通常最好实现比严格必要的更多，特别是如果它们是小型函数，实现它们比发现该函数或方法是否被使用要快得多。让我们看看以下代码：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `connect` methods remain the same, as they all use the same `private` method
    of the class to perform the actual connection operation, as shown in the following
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` 方法保持不变，因为它们都使用类中相同的 `private` 方法来执行实际的连接操作，如下所示代码所示：'
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is the first section where we directly use the Mosquitto library. We reinitialize
    the instance either without a password or TLS (anonymous broker access), or with
    a password, or with TLS (left unimplemented here, as we don't need it).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个我们直接使用 Mosquitto 库的部分。我们重新初始化实例，要么不使用密码或 TLS（匿名代理访问），要么使用密码，或者使用 TLS（在这里未实现，因为我们不需要它）。
- en: 'In this method, we also start the listening thread for the MQTT client, which
    will handle all incoming messages so that we don''t have to further concern ourselves
    with this aspect of the process. Let''s look at the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们还启动了MQTT客户端的监听线程，它将处理所有传入的消息，这样我们就不必进一步关注这个过程的这个方面。让我们看看下面的代码：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The MQTT message-publish functionality directly maps to the Mosquitto library''s
    methods:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT消息发布功能直接映射到Mosquitto库的方法：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Subscribing and unsubscribing both also map easily to the MQTT client instance,
    as shown in the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅和取消订阅也容易映射到MQTT客户端实例，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, we implement the Mosquitto `callback` method for when we receive a
    new message from the broker. For each received message, we then call the registered
    `callback` method (from the firmware code) to provide it with the payload and
    topic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了当从代理收到新消息时使用的Mosquitto `callback`方法。对于每个接收到的消息，我们随后调用注册的`callback`方法（来自固件代码），向它提供负载和主题。
- en: This takes care of the MQTT client aspect of the firmware. Next, we need to
    make the rest of the APIs compatible with a desktop OS.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了固件的MQTT客户端方面。接下来，我们需要使其他API与桌面操作系统兼容。
- en: 'The headers of the Sming framework that the firmware uses are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 固件使用的Sming框架的头文件如下：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first header file defines some platform-related features that we don't need.
    The second header is the one that we will add everything that we need to.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个头文件定义了一些我们不需要的平台相关功能。第二个头文件是我们将添加所有我们需要的东西的地方。
- en: 'To check the firmware''s code for API dependencies, we use standard text searching
    tools to find all function calls, filtering out any that do not call into our
    code but into the Sming framework. After doing this we can write the following
    SmingCore.h file with these dependencies:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查固件的代码以确定API依赖关系，我们使用标准的文本搜索工具来查找所有函数调用，过滤掉任何没有调用我们的代码而是调用Sming框架的调用。完成此操作后，我们可以编写以下SmingCore.h文件，其中包含这些依赖项：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We start off with a combination of standard C library and STL includes, along
    with a number of headers that define the rest of the API that we are implementing.
    We also directly use a number of header files that define classes that are used
    throughout these APIs, but not by the firmware itself.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始时使用标准C库和STL包含的组合，以及一些定义我们正在实现的其他API的头的文件。我们还直接使用一些头文件，这些文件定义了在整个这些API中使用但不是固件本身使用的类。
- en: A class like the `Delegate` class is sufficiently abstract that it can be used
    as is. As we will see, the `Filesystem` and `Timer` classes required a fair bit
    of reworking to make them work for our purposes. We already looked at the modifications
    to the MQTT client earlier.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`Delegate`类这样的类足够抽象，可以直接使用。正如我们将看到的，`Filesystem`和`Timer`类需要相当多的修改才能为我们所用。我们之前已经看到了MQTT客户端的修改。
- en: 'Naturally, we also include the header file for the NymphRPC library, which
    will allow us to communicate with the server side of the integration test, as
    shown in the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们也包含了NymphRPC库的头文件，这将允许我们与集成测试的服务器端通信，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For compatibility reasons, we need to define a range of types that are used
    throughout the firmware code. These are equivalent to the types in `cstdint` from
    the C library, so we can use simple `typedefs`, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于兼容性的原因，我们需要定义一系列在固件代码中使用的类型。这些类型与C库中的`cstdint`中的类型相当，因此我们可以使用简单的`typedefs`，如下所示：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first API we fully reimplement is the hardware-based serial device. Since
    this communicates directly with the virtual interface in the server, we just need
    to provide the methods here, with the definition in the source file, as we will
    see in a moment.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完全重新实现的第一个API是基于硬件的串行设备。由于它直接与服务器中的虚拟接口通信，我们只需要在这里提供方法，并在源文件中定义，正如我们一会儿会看到的。
- en: 'We also declare a global instantiation of this serial object class, identical
    to how the original framework implementation handles it, as shown in the following
    code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了这个串行对象类的全局实例，与原始框架的实现方式相同，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The rboot boot manager and SPIFFS filesystem-related functionality has no equivalent
    on a desktop system, so we declare them here (but as we''ll see in a moment, they
    are left as empty stubs):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: rboot引导管理器和SPIFFS文件系统相关的功能在桌面系统中没有等效功能，所以我们在这里声明它们（但正如我们一会儿会看到的，它们被留为空占位符）：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'On the network side, we have to provide all of the class instances and related
    information that are normally used to connect to a WiFi access point and ensure
    that we are connected. As we aren''t testing WiFi functionality here, these methods
    are of little use, but are needed to satisfy the firmware code and the compiler:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络方面，我们必须提供所有通常用于连接到WiFi接入点并确保我们已连接的类实例和相关信息。由于我们这里没有测试WiFi功能，这些方法用处不大，但它们是满足固件代码和编译器的需求所必需的：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We then declare the debug-related output function as well as the watchdog class
    using the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码声明了与调试相关的输出函数以及看门狗类：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We declare the two types of communication buses here, as shown in the following
    code. Again, we declare that there is a global instantiation of each:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此声明了两种通信总线，如下所示。同样，我们声明了每个的全局实例化：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since the firmware contains code that uses the GPIO and ADC pins, the above functions
    are needed as well.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于固件包含使用GPIO和ADC引脚的代码，因此需要上述函数。
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, we declare a number of classes and functions that are mostly there
    to satisfy the compiler as they have no practical use for our purposes, though
    we could potentially implement advanced test scenarios this way.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明了多个类和函数，它们主要是为了满足编译器的需求，因为它们对我们来说没有实际用途，尽管我们可能以这种方式实现高级测试场景。
- en: 'Next, we''ll look at the implementation of these functions using the following
    code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下代码查看这些函数的实现：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `handle` variable is the one variable we declare as being static in this
    compile unit. Its purpose is to store the remote server handle ID for future operations
    after we connect to the RPC server, as shown in the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle`变量是我们在这个编译单元中声明的唯一静态变量。它的目的是在连接到RPC服务器后存储远程服务器句柄ID，以便进行未来的操作，如下所示：'
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Just like in the server-side code, we define a simple logging function to use
    with NymphRPC, as shown in the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在服务器端代码中一样，我们定义了一个简单的日志函数，用于与NymphRPC一起使用，如下所示：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We implement the simple debug output function using C-style string formatting
    features to fit the function''s signature, as shown in the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用C风格的字符串格式化功能来实现简单的调试输出函数，以适应函数的签名，如下所示：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We define the serial callback delegate along with the serial receive buffer
    as static, as we assume the presence of a single UART capable of **receiving data**
    (RX), which happens to be the case on the ESP8266 MCU. We also create a single
    instance of the `HardwareSerial` class, for UART 0, as shown in the following
    code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将串行回调委托和串行接收缓冲区定义为静态的，因为我们假设存在一个能够**接收数据**（RX）的单个UART，这在ESP8266 MCU上恰好是这种情况。我们还创建了一个`HardwareSerial`类的单个实例，用于UART
    0，如下所示：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This class is just there to act as a stub. As none of the code actually uses
    this object''s methods, we can leave them all unimplemented, as shown in the following
    code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是作为一个占位符。由于没有任何代码实际使用这个对象的方法，我们可以将它们全部留作未实现，如下所示：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'A lot of the methods in this class are simple enough that they can be implemented
    as a simple write to the standard (system) output or with an assignment to a variable.
    Occasionally a method is left unaltered from the original, though even for the
    setting of the callback delegate function in the last method in this group, the
    original code is called into the C-based low-level APIs of the ESP8266''s SDK.
    Let''s look at the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的许多方法都足够简单，可以简单地写入标准（系统）输出或通过变量赋值来实现。偶尔会有一个方法保持原样未修改，尽管即使在最后一个方法中设置回调委托函数时，原始代码也是调用ESP8266
    SDK的基于C的低级API。让我们看看以下代码：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: To receive UART messages, we define a NymphRPC callback function, which for
    that reason is defined as being static. Since the ESP8266 only has a single UART
    capable of receiving data this suffices.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收UART消息，我们定义了一个NymphRPC回调函数，因此它被定义为静态的。由于ESP8266只有一个能够接收数据的UART，这已经足够了。
- en: 'When called, this method reads out the payload being received on the UART and
    calls the `callback` function that the firmware registered previously, as shown
    in the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，此方法读取UART上接收到的有效载荷，并调用固件先前注册的`callback`函数，如下所示：
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Writing to the remote UART is done using an RPC call. To do this, we create
    an STL vector and fill it with the parameters to pass in the proper order—in this
    case, the node's MAC address and the data that we wish to send on the remote UART.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RPC调用写入远程UART。为此，我们创建一个STL向量并填充传递参数的顺序——在这种情况下，节点的MAC地址和我们要在远程UART上发送的数据。
- en: 'After this, we use the NymphRPC handle that we got when we connected to call
    the RPC server and wait for the response from the remote function, as shown in
    the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们使用连接时获得的NymphRPC句柄调用RPC服务器并等待远程函数的响应，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Reading from the UART is done after we''ve received data on the UART, after
    which we can read it out with the following method, just as we would with the
    original code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从UART接收数据之后，我们会使用以下方法来读取它，就像我们在原始代码中所做的那样：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Both the rboot boot manager and the SPIFFS filesystem are not used, so they
    can just return safe values, as shown in the following code. The **over-the-air**
    (**OTA**) functionality could potentially be implemented as well, depending on
    the kind of features of the system one would want to test:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是rboot引导管理器还是SPIFFS文件系统都没有使用，因此它们可以简单地返回安全值，如下面的代码所示。**空中传输**（**OTA**）功能也可以根据系统想要测试的功能类型实现：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Since we don''t have a Wi-Fi adapter that we want to use directly and are just
    using the OS''s network capabilities, the `WiFiStation` object doesn''t do a lot
    for most of its methods, except for when we actually connect to the RPC server,
    which is done using the following method:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有想要直接使用的Wi-Fi适配器，只是使用操作系统的网络功能，所以`WiFiStation`对象在大多数方法上并没有做什么，除了当我们实际连接到RPC服务器时，这是使用以下方法完成的：
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is one of the first methods that gets called in the firmware when it tries
    to connect to the Wi-Fi access point. Instead of connecting to a Wi-Fi access
    point, we use this method to connect to the RPC server instead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是固件尝试连接到Wi-Fi接入点时最早被调用的方法之一。而不是连接到Wi-Fi接入点，我们使用这个方法连接到RPC服务器。
- en: We start by initializing the NymphRPC library, calling the initialization method
    on its `NymphRemoteServer` class, and then connecting to the RPC server using
    the hardcoded location and port number. Upon successfully connecting to the RPC
    server, this client will receive a list of the available methods on the RPC server—in
    this case, all of the methods we registered, as we saw in the previous section
    on the simulation server.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化NymphRPC库，调用其`NymphRemoteServer`类的初始化方法，然后使用硬编码的位置和端口号连接到RPC服务器。成功连接到RPC服务器后，这个客户端将接收到RPC服务器上可用的方法列表——在这种情况下，所有我们注册的方法，正如我们在上一节关于模拟服务器的部分所看到的。
- en: 'Next, we request our MAC address from the server, verify that it''s a string
    that we received, and set it for later use. Finally, we locally register the callback
    for the UART with NymphRPC, as shown in the following code. As we saw in the simulation
    server''s section, the `Nodes` class on the server expects this callback to exist
    on the client:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从服务器请求我们的MAC地址，验证它是一个我们接收到的字符串，并将其设置为后续使用。最后，我们像以下代码所示在本地使用NymphRPC注册UART的回调。正如我们在模拟服务器部分所看到的，服务器上的`Nodes`类期望客户端存在这个回调：
- en: '[PRE66]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We conclude this networking section with some more stub classes and, finally,
    the watchdog class, which might make for a nice point for advanced testing, including
    soft reset testing for long-running code. Of course, such advanced tests would
    also require that the code runs with the performance of the ESP8266's sub-100
    MHz processor.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加一些存根类来结束这个网络部分，最后是看门狗类，这可能会成为高级测试的一个很好的切入点，包括对长时间运行代码的软重置测试。当然，这样的高级测试也要求代码以ESP8266的sub-100
    MHz处理器的性能运行。
- en: 'Of note here is the Wi-Fi events class, where we immediately call the `callback`
    function for a successful connection to the Wi-Fi access point, or at least pretend
    to. Without this step, the firmware would forever wait for something to happen.
    Let''s look at the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是Wi-Fi事件类，我们立即调用`callback`函数以成功连接到Wi-Fi接入点，或者至少假装这样做。没有这一步，固件将永远等待某个事件发生。让我们看看下面的代码：
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To write on the SPI bus, we again just call the RPC method on the server, getting
    the response once that call has been completed, as shown in the following code.
    For simplicity''s sake, no SPI read functionality is implemented in this example
    project:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要在SPI总线上写入数据，我们再次在服务器上调用RPC方法，一旦调用完成就获取响应，如下面的代码所示。为了简化，本示例项目中没有实现SPI读取功能：
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'After some stub methods in the I2C class, we find the `write` methods. These
    are essentially the same methods, calling the `remote` method to send the data
    to the simulated I2C bus on the server, as shown in the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在I2C类的某些存根方法之后，我们找到了`write`方法。这些方法基本上是相同的，调用`remote`方法将数据发送到服务器上模拟的I2C总线，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To read from the I2C bus, we use the preceding method, first writing the I2C
    address we wish to write to, then calling the RPC function to read from the simulated
    I2C device that should have data available to read, as shown in the following
    code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要从I2C总线读取数据，我们使用前面提到的方法，首先写入我们希望写入的I2C地址，然后调用RPC函数从应该有可读数据的模拟I2C设备中读取，如下面的代码所示：
- en: '[PRE70]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The I2C read functionality is essentially the same as it was in the original
    implementation, as both just interact with a local buffer, as shown in the following
    code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: I2C读取功能与原始实现基本相同，因为它们只是与本地缓冲区交互，如下面的代码所示：
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here are more stub implementations that could be of use for specific test scenarios:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可能对特定测试场景有用的存根实现：
- en: '[PRE72]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We left these functions unimplemented, but they could implement GPIO and ADC
    pins that are connected to virtual GPIO pins on the server side, to control devices
    and record data that does not use a UART, SPI, or I2C interface. The same would
    work for PWM functionality.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了这些函数未实现，但它们可以实现对连接到服务器端虚拟GPIO引脚的GPIO和ADC引脚的访问，以控制不使用UART、SPI或I2C接口的设备并记录数据。PWM功能也是如此。
- en: 'Moving on to the final part in this source file, we implement the main function
    as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在这个源文件的最后一部分，我们按照以下方式实现主函数：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Just like the Sming version of the entry point, we call the global `init()`
    function in the custom firmware code, which serves as the entrance point there.
    Conceivably, we could also perform various types of initialization in this main
    function if we needed to.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Sming版本的入口点一样，我们在自定义固件代码中调用全局的`init()`函数，这在那里充当入口点。理论上，如果我们需要，我们也可以在这个主函数中执行各种类型的初始化。
- en: 'The filesystem class methods are implemented using a mixture of C-style file
    access and C++17-style filesystem operations, as shown in the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统类方法使用C风格文件访问和C++17风格文件系统操作的混合来实现，如下面的代码所示：
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To simplify this method, we ignore the provided flags and always open the file
    in full read and write mode (one would only implement the full set of flags if
    it contributed to the integration test in some way). Let''s look at the following
    code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个方法，我们忽略提供的标志，并始终以全读和写模式打开文件（如果完整的一组标志以某种方式有助于集成测试，则只会实现完整的一组标志）。让我们看看下面的代码：
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: These are all standard file operations, so they don't require a lot of explanation.
    The main reason why both C-style and C++17-style file access are used is because
    the original API methods assume a C-style way of handling things, and also because
    of the underlying, C-based SDK functionality.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是标准的文件操作，因此不需要过多解释。之所以使用C风格和C++17风格的文件访问，主要是因为原始API方法假设使用C风格处理事情，以及因为底层的基于C的SDK功能。
- en: We would map all API methods to a pure C++17 filesystem functionality, but this
    would be an additional time investment without any obvious payoff.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会将所有API方法映射到纯C++17文件系统功能，但这将是一个额外的投资，而没有明显的回报。
- en: 'The timer functionality uses POCO''s `Timer` class in Sming''s `SimpleTimer`
    class to implement an equivalent functionality, as shown in the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器功能使用Sming的`SimpleTimer`类中的POCO的`Timer`类来实现等效功能，如下面的代码所示：
- en: '[PRE76]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, for the reimplementation of the `Clock` class, we use STL''s chrono
    functionality, as shown in the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`Clock`类的重新实现，我们使用STL的chrono功能，如下面的代码所示：
- en: '[PRE77]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we leave the `delay` functions unimplemented since we don't need them
    at this point.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们保留`delay`函数未实现，因为我们目前不需要它们。
- en: Makefile
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Makefile
- en: 'The Makefile for this part of the project looks like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目这一部分的Makefile如下所示：
- en: '[PRE78]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The main thing to note about this Makefile is that it gathers source files from
    two different source folders, both for the test API and for the firmware source.
    The former source files are first compiled to object files, which are assembled
    into an archive. The firmware source is used directly along with this test framework
    library, though we also have the firmware object files available if we need them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此Makefile需要注意的主要事项是，它从两个不同的源文件夹中收集源文件，这两个文件夹分别用于测试API和固件源。前者源文件首先被编译成目标文件，然后被组装成归档。固件源文件直接与这个测试框架库一起使用，尽管如果我们需要，我们也有固件目标文件可用。
- en: The reason for creating an archive of the test API before linking it has to
    do with the way that the linker finds symbols. By using the AR tool, it will create
    an index of all symbols in the object files inside the archive, ensuring that
    we will not get any linker errors. Especially for large projects this is often
    a requirement to have the object files successfully link into a binary.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接之前创建测试API的归档的原因与链接器查找符号的方式有关。通过使用AR工具，它将创建归档中所有目标文件的符号索引，确保我们不会遇到任何链接错误。特别是对于大型项目，这通常是一个要求，以确保目标文件能够成功链接到二进制文件中。
- en: Compiling to object files first is also helpful with larger projects, as Make
    will ensure that only files that have actually changed will be recompiled, which
    can really speed up development time. Since the target firmware source for this
    project is fairly minimal, we can compile directly from the source files here.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编译成目标文件对于大型项目也有帮助，因为Make将确保只有实际更改的文件会被重新编译，这可以真正加快开发速度。由于本项目目标固件源代码相当简单，我们可以直接从源文件编译。
- en: We also include two more Makefiles from this one. The first includes the version
    number of the firmware source we are compiling with, which is useful since it'll
    ensure that the produced node binary will report the exact same version as the
    version installed on an ESP8266 module would. This making validation of a specific
    firmware version much easier.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从这个项目中包含了两个额外的Makefile。第一个包含了我们正在编译的固件源版本的版本号，这很有用，因为它将确保生成的节点二进制文件会报告与安装在ESP8266模块上的版本完全相同的版本。这使得验证特定固件版本变得容易得多。
- en: 'The second is the Makefile with user-definable settings, copied *verbatim*
    from the firmware project Makefile, but with just the variables we need for the
    firmware source to compile and work, as shown in the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是带有用户定义设置的Makefile，它直接从固件项目的Makefile复制过来，但只包含用于编译和运行固件源所需的变量，如下面的代码所示：
- en: '[PRE79]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Including this Makefile sets all of these defines to be passed to the compiler.
    These are all preprocessor statements that are used to set strings or to change
    which parts of the code will be compiled, such as the SSL code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 包含此Makefile会将所有这些定义传递给编译器。这些都是预处理语句，用于设置字符串或更改将被编译的代码部分，例如SSL代码。
- en: However, for simplicity's sake, we aren't implementing SSL functionality for
    this example project.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了简化起见，我们在这个示例项目中没有实现SSL功能。
- en: Building the project
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建项目
- en: 'For the server side, we have the following library dependencies:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器端，我们有以下库依赖项：
- en: NymphRPC
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NymphRPC
- en: POCO
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POCO
- en: 'For the node, we have the following dependencies:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于节点，我们有以下依赖项：
- en: NymphRPC
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NymphRPC
- en: POCO
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POCO
- en: Mosquitto
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mosquitto
- en: The NymphRPC library (described at the beginning of this section) is compiled
    according to the project's instructions and installed in a place where the linker
    can find it. The POCO libraries are installed using the system's package manager
    (Linux, BSD, or MSYS2) or by hand.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: NymphRPC库（在本节开头描述）根据项目说明进行编译，并安装到链接器可以找到的位置。POCO库使用系统的包管理器（Linux、BSD或MSYS2）或手动安装。
- en: For the Mosquitto library dependency, we can compile the `libmosquitto` and
    `libmosquittopp` library files using the project's library version by using the
    Makefile in the `test/SmingCore/network/libmosquitto` folder. Again you should
    install the resulting library files where the linker can find them.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mosquitto库依赖项，我们可以通过在`test/SmingCore/network/libmosquitto`文件夹中的Makefile中使用项目库版本来编译`libmosquitto`和`libmosquittopp`库文件。再次提醒，你应该将生成的库文件安装到链接器可以找到它们的位置。
- en: When not using MinGW, one can also use the generally available version via the
    OS's package manager or similar.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当不使用MinGW时，也可以通过操作系统的包管理器或类似工具使用通常可用的版本。
- en: 'After these steps, we can compile the server and client using the following
    command-line command from the root of the project:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些步骤后，我们可以使用以下命令行命令从项目的根目录编译服务器和客户端：
- en: '[PRE80]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This should compile both the server and node projects using the top-level Makefile,
    resulting in an executable for each in their respective `bin/` folder. You should
    ensure that the executable name and path in the server's `Node` class match that
    of the node executable's location.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会使用顶层Makefile编译服务器和节点项目，在每个相应的`bin/`文件夹中生成可执行文件。你应该确保服务器`Node`类中的可执行文件名称和路径与节点可执行文件的位置相匹配。
- en: We should now be able to run the project and start to collect test results.
    The project includes a stripped version of the ESP8266-based BMAC firmware, which
    we'll be covering in detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml),
    *Example - Building Monitoring and Control*. Please refer to that chapter to understand
    how to communicate with the simulated nodes via MQTT, how to turn on modules inside
    the firmware and how to interpret the data sent over MQTT by the modules.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够运行项目并开始收集测试结果。该项目包括基于ESP8266的BMAC固件的精简版，我们将在第9章[示例 - 构建监控和控制](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)中详细讨论。请参考该章节了解如何通过MQTT与模拟节点通信，如何在固件内部打开模块以及如何解释模块通过MQTT发送的数据。
- en: After setting things up as described in that chapter - requiring at the least
    an MQTT broker and a suitable MQTT client - and turning on the BME280 module in
    the simulated node, we expect it to start sending over MQTT the temperature, humidity
    and air pressure values we set for the room the simulated node is in.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在按照该章节所述设置好一切（至少需要一个MQTT代理和一个合适的MQTT客户端）并在模拟节点中打开BME280模块后，我们期望它开始通过MQTT发送我们为模拟节点所在的房间设置的温度、湿度和空气压力值。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to effectively develop for MCU-based targets
    in a way that allows us to test them without expensive and long-winded development
    cycles. We learned how to implement an integration environment that allows us
    to debug MCU-based applications from the comfort of a desktop OS and the tools
    it provides.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何有效地为基于MCU的目标进行开发，这样我们可以在不昂贵的长时间开发周期中测试它们。我们学习了如何实现一个集成环境，使我们能够从桌面操作系统及其提供的工具中调试基于MCU的应用程序。
- en: The reader should now be able to develop integration tests for MCU-based projects
    and effectively use OS-based tools to profile and debug them before doing final
    integration work on real hardware. The reader should also be able to perform on-chip
    debugging, and have a feel for the relative cost of specific software implementations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 读者现在应该能够为基于MCU的项目开发集成测试，并有效地使用基于操作系统的工具在最终在真实硬件上进行集成工作之前对它们进行性能分析和调试。读者还应该能够进行片上调试，并对特定软件实现的相对成本有所了解。
- en: In the next chapter, we'll develop a simple infotainment system, based on an
    SBC platform.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开发一个基于SBC平台的简单信息娱乐系统。
