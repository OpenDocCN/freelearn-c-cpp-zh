["```cpp\n// ...\nint *p = std::malloc(lots * sizeof(int)); // <-- HERE\nif(p) {\n    // use p as an array of int objects\n    std::free(p);\n}\n// ...\n```", "```cpp\nconst int N = 3; // global constant\nclass X {\n    int n; // note: not const\npublic:\n    X(int n) : n{ n } {\n    }\n    int g() { // note: not const\n      return n += N; // thus, n's state can be mutated\n    }\n    int f() const { // const applies to this, and\n                    // transitively to its members\n      // return g(); // illegal as g() is not const\n      return n + 1;\n    }\n};\nint f(const int &n) { // f() will not mutate argument n\n    return X{ n }.f() + 1; // X::X(int) takes its argument\n                          // by value so n remains intact\n}\nint main() {\n    int a = 4;\n    a = f(a); // a is not const in main()\n}\n```", "```cpp\nstruct B { virtual ~B() = default; /* ... */ };\nstruct D0 : B { /* ... */ };\nstruct D1 : B { /* ... */ };\nclass X {\npublic:\n    X(int, double);\n};\nvoid f(D0&);\nvoid f(D1*);\nint main() {\n    const float x = 3.14159f;\n    int n = static_cast<int>(x); // Ok, no warning\n    X x0{ 3, 3.5 }; // Ok\n    // compiles, probably warns (narrowing conversion)\n    X x1(3.5,0);\n    // does not compile, narrowing not allowed with braces\n    // X x2{ 3.5, 0 };\n    X x3{ static_cast<int>(x), 3 }; // Ok\n    D0 d0;\n    // illegal, no base-derived relationship with D0 and D1\n    // D1* d1 = static_cast<D1*>(&d0);\n    // Ok, static_cast could be omitted\n    B *b = static_cast<B*>(&d0);\n    // f(*b); // illegal\n    f(*static_cast<D0*>(b)); // Ok\n    f(static_cast<D1*>(b)); // compiles but very dangerous!\n}\n```", "```cpp\nstruct B0 {\n    virtual int f() const = 0;\n    virtual ~B0() = default;\n};\nstruct B1 {\n    virtual int g() const = 0;\n    virtual ~B1() = default;\n};\nclass D0 : public B0 {\n    public: int f() const override { return 3; }\n};\nclass D1 : public B1 {\n    public: int g() const override { return 4; }\n};\nclass D : public D0, public D1 {};\nint f(D *p) {\n    return p? p->f() + p->g() : -1; // Ok\n}\n// g has the wrong interface: it accepts a D0& but\n// tries to use it as a D1&, which makes sense if\n// the referred object is publicly D0 and D1 (for\n// example, class D\nint g(D0 &d0) {\n    D1 &d1 = dynamic_cast<D1&>(d0); // throws if wrong\n    return d1.g();\n}\n#include <iostream>\nint main() {\n    D d;\n    f(&d); // Ok\n    g(d); // Ok, a D is a D0\n    D0 d0;\n    // calls f(nullptr) as &d0 does not point to a D\n    std::cout << f(dynamic_cast<D*>(&d0)) << '\\n'; // -1\n    try {\n      g(d0); // compiles but will throw bad_cast\n    } catch(std::bad_cast&) {\n      std::cerr << \"Nice try\\n\";\n    }\n}\n```", "```cpp\n#include <vector>\nstruct ResourceHandle { /* ... */ };\n// this function observes a resource without modifying it,\n// but the type system is not aware of that fact (the\n// argument is not const)\nvoid observe_resource(ResourceHandle*);\nclass ResourceManager {\n    std::vector<ResourceHandle *> resources;\n    // ...\npublic:\n    // note: const member function\n    void observe_resources() const {\n      // we want to observe each resource, for example\n      // to collect data\n      for(const ResourceHandle * h : resources) {\n       // does not compile, h is const\n       // observe_resource(h);\n      // temporarily dismiss constness\n          observe_resource(const_cast<ResourceHandle*>(h));\n      }\n    }\n    // ...\n};\n```", "```cpp\nstruct B0 { int n = 3; };\nstruct B1 { float f = 3.5f; };\n// B0 is the first base subobject of D\nclass D : public B0, public B1 { };\nint main() {\n    D d;\n    // b0 and &d point to the same address\n    // b1 and &d do not point to the same address\n    B0 *b0 = static_cast<B0*>(&d);\n    B1 *b1 = static_cast<B1*>(&d);\n    int n0 = b0->n; // Ok\n    float f0 = b1->f; // Ok\n    // r0 and &d point to the same address\n    // r1 and &d also point to the same address... oops!\n    B0 *r0 = reinterpret_cast<B0*>(&d); // fragile\n    B1 *r1 = reinterpret_cast<B1*>(&d); // bad idea\n    int nr0 = r0->n; // Ok but fragile\n    float fr0 = r1->f; // UB\n}\n```", "```cpp\n#include <bit>\nstruct A { int a; double b; };\nstruct B { unsigned int c; double d; };\nint main() {\n    constexpr A a{ 3, 3.5 }; // ok\n    constexpr B b = std::bit_cast<B>(a); // Ok\n    static_assert(a.a == b.c && a.b == b.d); // Ok\n    static_assert((void*)&a != (void*)&b); // Ok\n}\n```", "```cpp\n#include <chrono>\n#include <iostream>\nint f() { /* ... */ }\nint main() {\n    using std::cout;\n    using namespace std::chrono;\n    auto pre = system_clock::now();\n    int res = f();\n    auto post = system_clock::now();\n    cout << \"Computed \" << res << \" in \"\n        << duration_cast<microseconds>(post - pre);\n}\n```", "```cpp\ntemplate <class ItA, class ItB>\n    bool all_equal(ItA bA, ItA eA, ItB bB, ItB eB) {\n      for(; bA != eA && bB != eB; ++bA, (void) ++bB)\n          if (*bA != bB)\n            return false;\n      return true;\n    }\n```"]