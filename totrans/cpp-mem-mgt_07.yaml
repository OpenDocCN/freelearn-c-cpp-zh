- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Overloading Memory Allocation Operators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载内存分配运算符
- en: Enjoying yourself so far? I hope you are! We are at the point where we hold
    all the keys and can start to do what this book advertises and look in more detail
    at how memory management works in C++. It’s not a simple topic, nor is it something
    trivial, so we needed to make sure we were ready… but we are now, so let’s do
    it!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你过得愉快吗？我希望你是！我们现在已经掌握了所有的钥匙，可以开始做这本书所宣传的事情，更详细地看看C++中内存管理是如何工作的。这不是一个简单的话题，也不是一件微不足道的事情，所以我们需要确保我们已经准备好了……但现在我们已经准备好了，让我们开始吧！
- en: '[*Chapter 5*](B21071_05.xhtml#_idTextAnchor079) and [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096)
    examined the standard tools one can use to ensconce responsibility over dynamically
    allocated resources into the C++ type system through smart pointers, the ones
    provided by the standard as well as those we could write to fill other niches.
    Using smart pointers instead of raw pointers as data members and function return
    types tends to simplify (and clarify) a significant proportion of memory management
    tasks in C++ programs.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第5章*](B21071_05.xhtml#_idTextAnchor079)和[*第6章*](B21071_06.xhtml#_idTextAnchor096)探讨了可以使用标准工具将动态分配资源的责任封装到C++类型系统中的方法，这些工具包括标准提供的以及我们可以编写的以填补其他空白。使用智能指针而不是原始指针作为数据成员和函数返回类型，往往可以简化（并阐明）C++程序中大量内存管理任务。'
- en: Sometimes, we want to work at a lower level than this and take control over
    what happens when someone writes `new X`. The reasons for wanting such control
    are numerous, and we will explore a few in this book, but in this chapter, we
    will focus on the basics of memory management functions and how to take control
    of these mechanisms in C++.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望在这个级别以下工作，并控制当有人编写`new X`时会发生什么。想要这种控制的原因有很多，在这本书中我们将探讨其中的一些，但在这章中，我们将专注于内存管理函数的基本知识以及如何在C++中控制这些机制。
- en: 'After these basics are covered, we will do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些基础知识被覆盖之后，我们将进行以下操作：
- en: See how our knowledge of the memory allocation mechanisms of C++ lets us write
    a simple (yet working) leak detector in [*Chapter 8*](B21071_08.xhtml#_idTextAnchor128)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看我们对C++内存分配机制的了解如何让我们在[*第8章*](B21071_08.xhtml#_idTextAnchor128)中编写一个简单的（但有效的）泄漏检测器
- en: Examine how one can manage atypical (persistent, shared, and so on) memory in
    C++ in [*Chapter 9*](B21071_09.xhtml#_idTextAnchor141)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第9章*](B21071_09.xhtml#_idTextAnchor141)中检查如何在C++中管理典型（持久、共享等）内存
- en: Write arena-based memory allocation in [*Chapter 10*](B21071_10.xhtml#_idTextAnchor153)
    to ensure deterministic time allocation and deallocation, leading to blazingly
    fast implementations of `new` and `delete` when context allows it
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第10章*](B21071_10.xhtml#_idTextAnchor153)中编写基于竞技场的内存分配，以确保确定性的时间分配和释放，当上下文允许时，这将导致`new`和`delete`的快速实现
- en: Later chapters will use the knowledge acquired in this chapter and the ones
    that follow to write efficient containers and deferred reclamation mechanisms
    that resemble a garbage collector. Past that point, we will examine how containers
    can use these facilities, with and without allocators.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将使用本章以及后续章节中获得的知识来编写高效的容器和延迟回收机制，这些机制类似于垃圾回收器。超过这一点，我们将探讨容器如何使用这些设施，包括和不包括分配器的情况。
- en: Why would one overload allocation functions?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么会重载分配函数？
- en: Before we start discussing how to overload memory allocation mechanisms, let’s
    take a step back and examine why one would want to do this. Indeed, most programmers
    (even experienced ones) never end up doing anything of the sort, and we could
    wager that a majority of programmers never thought they had a reason to do so.
    Yet, we will allocate (!) a few chapters to that very topic. There has to be a
    reason…
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论如何重载内存分配机制之前，让我们退一步，看看为什么有人想要这样做。确实，大多数程序员（即使是经验丰富的程序员）最终都没有做过这样的事情，我们可以打赌，大多数程序员从未想过他们有理由这样做。然而，我们将分配（！）几个章节来讨论这个话题。肯定有一个原因……
- en: The thing about memory allocation is that there’s no perfect solution to the
    problem in general; there are many good solutions on average, and there are very
    good solutions to more specialized versions of the problem. What constitutes a
    good solution for a given use case in programming language A might be inappropriate
    for another use case or in programming language B.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内存分配的事情是，在一般情况下，没有完美的解决方案来解决这个问题；平均来说，有许多好的解决方案，对于更专业的问题版本，也有非常好的解决方案。在编程语言A中构成良好解决方案的某个特定用例，可能不适合另一个用例或在编程语言B中。
- en: Take, for example, languages where is it idiomatic to allocate dynamically large
    numbers of small objects, something customary of Java or C#. In such a language,
    one could expect the allocation strategies to be optimized for that usage pattern.
    In a language such as C, where one would tend to allocate when faced with objects
    too large to put on the stack or when using node-based data structures for example,
    the best dynamic memory allocation strategy could be quite different. In [*Chapter
    10*](B21071_10.xhtml#_idTextAnchor153), we will see an example where the allocation
    process benefits from the fact that the allocated objects are all of the same
    size and alignment, another interesting use case.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以例如Java或C#中动态分配大量小对象为习惯的语言为例。在这样的语言中，人们可以期望分配策略针对这种使用模式进行了优化。在C这样的语言中，人们可能会在对象太大而无法放在栈上或使用基于节点的数据结构（例如）时进行分配，最佳的动态内存分配策略可能完全不同。在第[*第10章*](B21071_10.xhtml#_idTextAnchor153)中，我们将看到一个分配过程从分配的对象都是相同大小和对齐的事实中受益的例子，另一个有趣的用例。
- en: 'C++ emphasizes control and provides sophisticated and versatile tools to programmers.
    When facing a situation where we know the context in which allocations will be
    performed, we can sometimes use these tools to do better (even *much* better,
    as we will see in [*Chapter 11*](B21071_11.xhtml#_idTextAnchor163)!) than a default
    implementation would, and for numerous metrics: better execution time, more deterministic
    execution time, reduced memory fragmentation, and so on.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C++强调控制并提供给程序员复杂且多功能的工具。当我们知道分配将在何种上下文中执行时，我们有时可以使用这些工具做得更好（甚至*好得多*，正如我们将在[*第11章*](B21071_11.xhtml#_idTextAnchor163)中看到的那样！）并且对于许多指标：更好的执行时间、更确定的执行时间、减少内存碎片等等。
- en: Brief overview of the C language allocation functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C语言分配函数的简要概述
- en: 'Before we get to the memory allocation mechanisms of C++, let’s first take
    a brief look at the C family of memory allocation functions through its most distinguished
    representatives: `malloc()` and `free()`. There are, of course, many other memory-allocation-related
    functions such as `calloc()`, `realloc()`, and `aligned_alloc()`, not counting
    operating-system-specific services that perform similar tasks for specialized
    use cases, but these will serve our discussion well.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解C++的内存分配机制之前，让我们先简要地看一下C系列内存分配函数，通过其最杰出的代表：`malloc()`和`free()`。当然，还有许多其他与内存分配相关的函数，如`calloc()`、`realloc()`和`aligned_alloc()`，不计操作系统特定的服务，这些服务为特定的用例执行类似任务，但这些都很好地服务于我们的讨论。
- en: Note that since this is a book on memory management with C++, I will use the
    C++ version of these functions (from `<cstdlib>` instead of `<stdlib.h>`), which
    really changes nothing to the code we will write except for the fact that in C++,
    these functions are located in the `std` namespace.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于这是一本关于C++内存管理的书，我将使用这些函数的C++版本（从`<cstdlib>`而不是`<stdlib.h>`），这实际上对我们的代码没有任何影响，除了在C++中，这些函数位于`std`命名空间的事实。
- en: 'The signatures for these two functions are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的签名如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The role of `malloc(n)` is to find a location where there are at least `n` consecutive
    bytes available, potentially marking that location as “taken” and returning an
    abstract pointer (a `void*`) to the beginning of that block of memory. Note that
    the pointer returned has to be aligned for the worst possible natural case in
    a given machine, which means that it has to suit the alignment requirements of
    `std::max_align_t`. On most machines, this type is an alias for `double`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc(n)`的作用是在至少有`n`个连续字节可用的位置找到位置，可能将该位置标记为“已占用”，并返回指向该内存块开始的抽象指针（`void*`）。请注意，返回的指针必须适合给定机器最坏的自然情况，这意味着它必须满足`std::max_align_t`的对齐要求。在大多数机器上，这种类型是`double`的别名。'
- en: 'Interestingly, it is legal to call `malloc()` with `n==0`, but the results
    of such a call are implementation-defined: a call to `malloc(0)` could return
    `nullptr` but it could also return a non-null pointer. Note that the pointer returned
    by `malloc(0)` should not be dereferenced, regardless of whether it is null or
    not.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，调用`malloc()`时`n==0`是合法的，但此类调用的结果由实现定义：对`malloc(0)`的调用可能返回`nullptr`，也可能返回非空指针。请注意，无论指针是否为空，都不应取消引用`malloc(0)`返回的指针。
- en: If `malloc()` fails to allocate memory, it returns `nullptr` since the C language
    does not support exceptions in the C++ sense. In contemporary C (since C11), a
    `malloc()` implementation has to be thread-safe and has to synchronize appropriately
    with other C allocation functions if they are called concurrently, including with
    `free()`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `malloc()` 无法分配内存，它返回 `nullptr`，因为C语言不支持C++意义上的异常。在当代C（自C11起），`malloc()`
    实现必须是线程安全的，并且如果它们被并发调用，包括与 `free()` 一起调用，必须适当地与其他C分配函数同步。
- en: 'The role of `free(p)` is to ensure that the memory pointed to by `p` becomes
    available for further allocation requests, as long as `p` points to a block that
    has been allocated through a memory allocation function such as `malloc()` and
    has not yet been freed. It is `free()` an address that has not been allocated
    through such an allocation function… Don’t do that! Also, know that once the memory
    has been freed, it is no longer considered allocated, so code such as the following
    leads to UB:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`free(p)` 的作用是确保由 `p` 指向的内存变为可用，以便进一步分配请求，只要 `p` 指向的是通过 `malloc()` 等内存分配函数分配的块，并且尚未释放。不要对通过这种分配函数未分配的地址调用
    `free()`… 不要这样做！另外，要知道一旦内存被释放，它就不再被视为已分配，因此以下代码会导致未定义行为（UB）：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As mentioned in the preceding example, `free(nullptr)` does nothing, and has
    been defined as doing nothing for decades as of this writing. If there is code
    in your code base that verifies `p!=nullptr` before calling `free()` – for example,
    `if(p) free(p)` – you can safely get rid of that test.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所述，`free(nullptr)` 不会做任何事情，并且自本文写作以来已经定义为不做任何事情几十年了。如果你的代码库中有在调用 `free()`
    之前验证 `p!=nullptr` 的代码 – 例如，`if(p) free(p)` – 你可以安全地移除那个测试。
- en: We will sometimes (not always) use these C functions to implement our homemade
    C++ allocation functions. They work, they are well understood, and they are low-level
    abstractions we can use to our advantage when building higher-level ones.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '我们有时（不一定总是）会使用这些C函数来实现我们自制的C++分配函数。它们是有效的，它们被很好地理解，并且是我们可以利用来构建高级抽象的低级抽象。 '
- en: Overview of the C++ allocation operators
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++分配运算符概述
- en: 'In C++, there are many (infinitely many!) flavors of memory allocation operators,
    but there are rules to follow when writing your own. The current chapter is mostly
    about those rules; the chapters that follow will explore ways to benefit from
    this freedom C++ gives us:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，内存分配运算符有许多（无限多！）版本，但在编写自己的版本时必须遵循规则。当前章节主要关于这些规则；接下来的章节将探讨利用C++赋予我们的这种自由的方法：
- en: 'C++ lets us overload the `new int` will use our homemade versions. One has
    to be careful here since small mistakes can have a significant impact on code
    execution: if your implementation of `operator new()` is slow, you will slow down
    most memory allocations in your program! We will use this approach when writing
    a simple-yet-working leak detector in [*Chapter 8*](B21071_08.xhtml#_idTextAnchor128).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++允许我们重载 `new int` 将使用我们自制的版本。在这里必须小心，因为小小的错误可能会对代码执行产生重大影响：如果你的 `operator
    new()` 实现很慢，你将减慢程序中大多数内存分配的速度！我们将在[*第8章*](B21071_08.xhtml#_idTextAnchor128)中编写一个简单但有效的内存泄漏检测器时使用这种方法。
- en: C++ lets us overload **member function versions** of the memory allocation operators.
    If we do, then the global versions (overloaded or not) apply in general, but the
    member function versions apply for specific types. This can be useful when we
    have knowledge specific to the usage pattern of some types but not to others.
    We will use that to our advantage in [*Chapter 10*](B21071_10.xhtml#_idTextAnchor153).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++允许我们重载内存分配运算符的**成员函数版本**。如果我们这样做，那么全局版本（重载与否）通常适用，但成员函数版本适用于特定类型。这在我们对某些类型的用法模式有特定知识但不是对其他类型时很有用。我们将在[*第10章*](B21071_10.xhtml#_idTextAnchor153)中利用这一点。
- en: C++ lets us overload `nothrow` version and the (extremely important) **placement
    new**-related versions. We can also use this feature to benefit from “exotic”
    memory such as shared memory or persistent memory, as we will see in [*Chapter
    9*](B21071_09.xhtml#_idTextAnchor141).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++允许我们重载 `nothrow` 版本和（极其重要的）**placement new** 相关的版本。我们还可以利用这个特性来利用“奇异”内存，例如共享内存或持久内存，正如我们将在[*第9章*](B21071_09.xhtml#_idTextAnchor141)中看到的那样。
- en: 'In each case, memory allocation functions come in groups of four: `operator
    new()`, `operator new[]()`, `operator delete()`, and `operator delete[]()`. There
    are some exceptions to this rule, as we will see, but the rule generally holds.
    If we overload at least one of these functions, it’s important that we overload
    all four to keep the behavior of our program consistent. When playing with low-level
    facilities like this, mistakes tend to bite harder than they would otherwise,
    which explains why we took so much care in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027)
    and [*Chapter 3*](B21071_03.xhtml#_idTextAnchor047) explaining ways we could get
    in trouble… and how to play by the rules at the same time.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，内存分配函数都分为四组：`operator new()`、`operator new[]()`、`operator delete()` 和
    `operator delete[]()`。虽然有一些例外，但这个规则通常成立。如果我们至少重载这些函数中的一个，那么重载所有四个以保持程序行为一致是很重要的。当与这种低级设施（如本例所示）玩耍时，错误往往会更加严重，这也解释了为什么我们在
    [*第 2 章*](B21071_02.xhtml#_idTextAnchor027) 和 [*第 3 章*](B21071_03.xhtml#_idTextAnchor047)
    中如此小心地解释了我们可能会遇到麻烦的方式……以及如何同时遵守规则。
- en: Memory allocation interacts closely with the object model (see [*Chapter 1*](B21071_01.xhtml#_idTextAnchor016)
    for the basics) and with exception safety (a topic that’s pervasive throughout
    this book), so make sure to grasp these interactions in the pages and chapters
    that follow. They will help you make the best of what you will read here.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配与对象模型（参见 [*第 1 章*](B21071_01.xhtml#_idTextAnchor016) 中的基础知识）和异常安全性（本书中无处不在的主题）密切相关，所以请确保在接下来的页面和章节中掌握这些交互。它们将帮助您充分利用您在这里阅读的内容。
- en: A word on Heap Allocation Optimization (HALO)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于堆分配优化（HALO）的一个说明
- en: It’s important to know that there are benefits to *not* overloading memory allocation
    operators. One of them is that your library vendor provides very good ones by
    default; another is that if you do not overload the memory allocation operators,
    the compiler can assume that the number of allocations you make is not observable.
    This means that it is allowed to replace *n* calls to `new` with a single call
    that allocates everything at once, and then manages the results as if you had
    performed many allocations. That can lead to some spectacular optimizations in
    practice, including the removal of calls to `new` and `delete` altogether from
    the generated code even when they appear in the source code! If in doubt, please
    make sure that your optimizations provide measurable benefits before committing
    them and using them in production code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点很重要，即不重载内存分配运算符也有好处。其中之一是您的库供应商默认提供了非常好的实现；另一个好处是，如果您不重载内存分配运算符，编译器可以假设您所做的分配数量是不可观察的。这意味着可以替换
    *n* 次对 `new` 的调用，用一个一次性分配所有内容的调用，然后像执行了许多分配一样管理结果。这在实践中可能导致一些惊人的优化，包括从生成的代码中完全移除
    `new` 和 `delete` 调用，即使它们出现在源代码中！如果有疑问，请确保在将优化提交并用于生产代码之前，它们提供了可衡量的好处。
- en: Note that for the allocation operator overloads we will see in this chapter,
    you will want to include the `<new>` header as this is where `std::bad_alloc`
    is declared, among other things, and this is the type that allocation functions
    typically use to report failure to allocate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本章中我们将看到的分配运算符重载，您需要包含 `<new>` 头文件，因为这是 `std::bad_alloc` 被声明的位置，以及其他一些内容，并且这是分配函数通常用来报告分配失败的类型。
- en: Global allocation operators
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局分配运算符
- en: Suppose we want to take control of the global versions of the allocation operators
    in C++. For the sake of exposing how this can work, we will simply use them to
    delegate to `malloc()` and `free()` for now, and show a more elaborate example
    in [*Chapter 8*](B21071_08.xhtml#_idTextAnchor128).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要控制 C++ 中的全局分配运算符版本。为了展示这是如何工作的，我们将简单地使用它们来委托给 `malloc()` 和 `free()`，现在，并在
    [*第 8 章*](B21071_08.xhtml#_idTextAnchor128) 中展示一个更详细的例子。
- en: If we stick to the basic forms of these operators, we will want to overload…
    well, four functions before C++11 or six functions since then. Of course, this
    book supposes that we’re over a decade past C++14, so we will proceed accordingly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们坚持这些运算符的基本形式，我们想要重载……嗯，在 C++11 之前是四个函数，从那时起是六个函数。当然，这本书假设我们已经超过十年没有使用 C++14，所以我们将相应地进行。
- en: 'The signatures we want to overload are the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要重载的签名如下：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s a lot, I agree, but taking control of memory management facilities is
    specialized work. As soon as you write one of these functions, you officially
    replace the ones provided by your standard library for that program and that function
    becomes responsible for the allocation (or deallocation) requests that come through
    that channel. Replacing an allocation function requires you to use the exact same
    signature as the original.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意，这确实很多，但掌握内存管理工具是专业的工作。一旦你编写了这些函数之一，你就正式替换了为你提供的标准库中的那些函数，并且该函数将负责通过该渠道传入的分配（或释放）请求。替换分配函数需要你使用与原始函数完全相同的签名。
- en: The reason why it is important that you overload the whole set of functions
    if you overload at least one of them is that these functions form a consistent
    whole. For example, if you change the way `new` behaves but neglect to change
    the way the standard library-provided `delete` performs its task, it’s essentially
    impossible to predict how much damage your program will incur. As a well-known
    popular comic book hero stated many times, *“with great power comes great responsibility.”*
    Be careful, be rigorous, and follow the rules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你至少重载了一个函数，那么重载整个函数集之所以重要，是因为这些函数形成了一个一致的整体。例如，如果你改变了`new`的行为方式，但忽略了标准库提供的`delete`执行其任务的方式，那么预测你的程序将遭受多少损害基本上是不可能的。正如一位著名的流行漫画书英雄多次所说的，“*权力越大，责任越大。”*要小心，要严谨，并遵循规则。
- en: Pay attention to the signatures of these functions as they provide interesting
    information…
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些函数的签名，因为它们提供了有趣的信息...
- en: On operators new and new[]
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于new和new[]操作符
- en: Functions `operator new()` and `operator new[]()` both take a single `std::size_t`
    object as an argument and both return `void*`. The argument is, in both cases,
    the minimal number of contiguous bytes to allocate. As such, their signatures
    resemble that of `std::malloc()`. That often surprises people; how can the `new
    X` expression create an `X` object if `new` is not a `template` and does not know
    what to create?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`operator new()`和`operator new[]()`都接受一个`std::size_t`对象作为参数，并且都返回`void*`。在两种情况下，参数都是要分配的最小连续字节数。因此，它们的签名类似于`std::malloc()`。这常常让人惊讶；如果`new`不是一个`模板`并且不知道要创建什么，那么`new
    X`表达式是如何创建`X`对象的呢？
- en: 'That’s the thing: `new` does *not* create objects. What `new` does is find
    the location where an object will be constructed. It’s the constructor that turns
    the raw memory found by `new` into an object. In practice, you could write something
    such as the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 事情是这样的：`new`并不创建对象。`new`所做的就是找到将要构造对象的位置。是构造函数将`new`找到的原始内存转换成对象。在实践中，你可以编写如下内容：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What you have written is a two-step operation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你所写的是一个两步操作：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means the constructor is like a coat of paint applied to a block of memory,
    turning that memory into an object. This also means that an expression such as
    `new X` can fail either on `operator new()`, if the allocation request could not
    succeed, or on `X::X()`, because the constructor failed somehow. Only if both
    steps succeed does client code become responsible for the pointed-to object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着构造函数就像是一层涂在内存块上的油漆，将那块内存转换成对象。这也意味着，例如`new X`这样的表达式可能会在`operator new()`失败时失败，如果分配请求无法成功，或者在`X::X()`失败，因为构造函数以某种方式失败了。只有当这两个步骤都成功时，客户端代码才对指向的对象负责。
- en: A note on calling these operators
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些操作符的命名
- en: You might have noticed in the preceding example that we sometimes write `new
    X` and we sometimes write `operator new(sizeof(X))`. The first form – the *operator
    form* – will do the two-step process of allocation followed by construction, whereas
    the second form – the *function form* – directly calls the allocation function
    without invoking a constructor. This distinction also applies to `operator delete()`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在前面的例子中，我们有时写`new X`，有时写`operator new(sizeof(X))`。第一种形式——*操作符形式*——将执行分配后跟构造的两个步骤，而第二种形式——*函数形式*——直接调用分配函数而不调用构造函数。这种区别也适用于`operator
    delete()`。
- en: 'The situation is similar with `operator new[]`: the number of bytes passed
    as argument to the function is the total number of bytes for the array, so the
    allocation function itself knows neither the type of object that will be created
    nor the number of elements or the individual size of the objects. A call to `new
    X[N]` will, in practice, call `operator new[](N*sizeof(X))` to find a place to
    put the array that will be constructed, then call `X::X()` on each of the `N`
    blocks of size `sizeof(X)` in that array. Only when the entire sequence completes
    successfully does client code become responsible for the resulting array.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与`operator new[]`的情况类似：传递给函数的字节数是数组的总字节数，因此分配函数本身并不知道将要创建的对象的类型、元素的数量或对象的单个大小。实际上，对`new
    X[N]`的调用将调用`operator new[](N*sizeof(X))`以找到放置将要构造的数组的空间，然后对数组中每个大小为`sizeof(X)`的`N`个块调用`X::X()`。只有当整个序列成功完成时，客户端代码才负责结果数组。
- en: Failure to allocate a scalar through `operator new` should result in something
    that matches `std::bad_alloc` being thrown. With `operator new[]()`, one can also
    throw `std::bad_array_new_length` (derived from `std::bad_alloc`) if the requested
    size is problematic, typically because it exceeds implementation-defined limits.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`operator new`无法分配标量应该导致抛出与`std::bad_alloc`匹配的东西。对于`operator new[]()`，如果请求的大小有问题，也可以抛出`std::bad_array_new_length`（从`std::bad_alloc`派生），通常是因为它超过了实现定义的限制。
- en: On operators delete and delete[]
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于`delete`和`delete[]`运算符
- en: 'Like the C language’s `free()` function, operators `delete()` and `delete[]()`
    both take a `void*` as argument. This means that they cannot destroy your object…
    When they are called, the object has already been destroyed! Indeed, you could
    write the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与C语言的`free()`函数类似，`delete()`和`delete[]()`运算符都接受一个`void*`作为参数。这意味着它们不能销毁你的对象…当它们被调用时，对象已经被销毁了！实际上，你可以写出以下内容：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is, in practice, a two-step operation that is equivalent to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个两步操作，相当于以下操作：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In C++, neither your destructors nor `operator delete()` should throw exceptions.
    If they do, the program is pretty much terminated, for reasons that will become
    self-evident in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，你的析构函数和`operator delete()`都不应该抛出异常。如果它们抛出异常，程序基本上会被终止，原因将在[*第12章*](B21071_12.xhtml#_idTextAnchor172)中变得显而易见。
- en: The size-aware versions of `operator delete()` and `operator delete[]()` have
    been introduced with C++14 and it is customary to implement them today, in addition
    to the classical versions of these functions. The idea is that `operator new()`
    was informed of the size of the blocks to allocate but `operator delete()` was
    not, which required unneeded acrobatics on the part of implementations that sought
    to do size-related tasks, such as filling the block of memory with some value
    in order to try to obscure what was stored at that location. Contemporary implementations
    of these functions require us to write a version that accepts the size of the
    pointed-to objects in addition to the classical version; if one’s implementation
    does not need that size, one can simply call the classical version from the size-aware
    one and be done with it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator delete()`和`operator delete[]()`的大小感知版本是在C++14中引入的，并且现在通常除了这些函数的经典版本之外，还会实现它们。其想法是`operator
    new()`知道要分配的块的大小，但`operator delete()`不知道，这要求实现方面进行不必要的杂技表演，例如用某个值填充内存块以试图隐藏该位置存储的内容。这些函数的现代实现要求我们编写一个版本，它除了经典版本外还接受指向对象的尺寸；如果实现不需要该尺寸，可以直接从大小感知版本调用经典版本，然后完成。'
- en: A note on sized operator delete[]() overloads
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于大小感知版本的`operator delete[]()`重载的说明
- en: If you trace the execution of your overloads, you might be surprised to see
    that the sized version of `operator delete[]()` is not necessarily called for
    some types. Indeed, if you have an array `arr` of objects of trivially destructible
    types, the standard leaves it unspecified as to which one of the sized and the
    unsized versions of `operator delete[]()` will be used when you write `delete
    [] arr`. It’s not a bug, rest assured.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你追踪你重载的执行过程，你可能会惊讶地发现，对于某些类型，`operator delete[]()`的大小版本并不一定被调用。确实，如果你有一个由平凡可销毁类型对象组成的数组`arr`，标准并未指定在编写`delete
    [] arr`时，将使用`operator delete[]()`的大小版本还是非大小版本。请放心，这并不是一个错误。
- en: 'A full, yet naïve implementation of these functions that essentially delegate
    work to the C allocation functions could be as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的一个完整但简单的实现是将工作委托给 C 分配函数，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As is probably clear by now, the default behavior when `operator new()` and
    `operator new[]()` fail to achieve their postconditions and actually allocate
    the requested amount of memory is to throw `std::bad_alloc` or, when appropriate,
    `std::bad_array_new_length`. Since allocation is followed by construction, client
    code might also face any exception thrown by the constructor. We will look at
    ways to handle these situations when writing custom containers in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如此看来，当 `operator new()` 和 `operator new[]()` 无法满足其后置条件并且实际上分配了请求的内存量时，默认行为是抛出
    `std::bad_alloc` 或者在适当的情况下抛出 `std::bad_array_new_length`。由于分配之后是构造，客户端代码也可能面临构造函数抛出的任何异常。我们将在编写自定义容器时探讨如何处理这些情况，见[*第12章*](B21071_12.xhtml#_idTextAnchor172)。
- en: There are application domains where exceptions are not an option. This can be
    due to memory constraints; most exception handlers make programs slightly bigger,
    which can be unacceptable in domains such as embedded systems. It can also be
    due to speed constraints; the code in `try` blocks is usually fast as these blocks
    represent the “normal” execution paths, but code in `catch` blocks is usually
    seen as the rare (“exceptional”) path and can be significantly slower to execute.
    Of course, some will simply avoid exception usage for philosophical reasons, which
    is fine too.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用领域，异常处理不是一个可选项。这可能是由于内存限制；大多数异常处理器会使程序略微增大，这在嵌入式系统等领域的应用中可能是不被接受的。也可能是由于速度限制；`try`块中的代码通常运行得很快，因为这些块代表“正常”的执行路径，但`catch`块中的代码通常被视为罕见的（“异常”）路径，执行速度可能会显著减慢。当然，有些人可能仅仅出于哲学原因而避免使用异常，这也是可以的。
- en: Luckily, there is a way to perform dynamic memory allocation without resorting
    to exceptions to signal failure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种方法可以在不使用异常来指示失败的情况下执行动态内存分配。
- en: Non-throwing versions of the allocation operators
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非抛出异常的分配操作符版本
- en: 'There are also versions of the allocation operators that do not throw upon
    failure to allocate. The signatures for these functions are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 也有不抛出异常的分配操作符版本。这些函数的签名如下：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: X *p = new (nothrow) X{ /* ... args ... */ };
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: X *p = new (nothrow) X{ /* ... args ... */ };
- en: if(p) {
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: if(p) {
- en: // ... use *p
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: // ... 使用 *p
- en: '// note: this is not the nothrow version of delete'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '// note: 这不是 delete 的 nothrow 版本'
- en: delete p; // would be Ok even if !p
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: delete p; // 即使 !p 也会是正确的
- en: '}'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: // step 1, try to perform the allocation for some T object
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: // 第1步，尝试为某些 T 对象执行分配
- en: p = operator new(n, ... maybe additional arguments ...)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: p = operator new(n, ... maybe additional arguments ...)
- en: // the following line is only for a nothrow new
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: // 以下行仅用于 nothrow new
- en: if(!p) return p
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: if(!p) return p
- en: try {
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: // step 2, construct the object at address p
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: // 第2步，在地址 p 处构造对象
- en: apply the constructor of T at address p // might throw
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在地址 p 处应用 T 的构造函数 // 可能会抛出
- en: '} catch(...) { // construction threw an exception'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch(...) { // 构造函数抛出了异常'
- en: deallocate p // this is what concerns us here
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: deallocate p // 这是我们这里关心的问题
- en: re-throw the exception, whatever it was
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: re-throw the exception, whatever it was
- en: '}'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return p // p points to a fully constructed object
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: return p // p 指向一个完全构造的对象
- en: // only after this point does client code see p
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: // 只有在这一点之后，客户端代码才会看到 p
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#include <iostream>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iostream>'
- en: '#include <cstdlib>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <cstdlib>'
- en: '#include <new>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <new>'
- en: void* operator new(std::size_t n, const std::nothrow_t&) noexcept {
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: void* operator new(std::size_t n, const std::nothrow_t&) noexcept {
- en: return std::malloc(n);
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: return std::malloc(n);
- en: '}'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void* operator new(std::size_t n) {
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: void* operator new(std::size_t n) {
- en: auto p = operator new(n, std::nothrow);
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = operator new(n, std::nothrow);
- en: if (!p) throw std::bad_alloc{};
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: if (!p) throw std::bad_alloc{};
- en: return p;
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: return p;
- en: '}'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void operator delete(void* p, const std::nothrow_t&)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete(void* p, const std::nothrow_t&)
- en: noexcept {
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: noexcept {
- en: std::free(p);
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: std::free(p);
- en: '}'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void operator delete(void* p) noexcept {
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete(void* p) noexcept {
- en: operator delete(p, std::nothrow);
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: operator delete(p, std::nothrow);
- en: '}'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void operator delete(void* p, std::size_t) noexcept {
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete(void* p, std::size_t) noexcept {
- en: operator delete (p, std::nothrow);
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: operator delete (p, std::nothrow);
- en: '}'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void* operator new[](std::size_t n,
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: void* operator new[](std::size_t n,
- en: const std::nothrow_t&) noexcept {
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: const std::nothrow_t&) noexcept {
- en: return std::malloc(n);
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: return std::malloc(n);
- en: '}'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void* operator new[](std::size_t n) {
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: void* operator new[](std::size_t n) {
- en: auto p = operator new[](n, std::nothrow);
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = operator new[](n, std::nothrow);
- en: if (!p) throw std::bad_alloc{};
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: if (!p) throw std::bad_alloc{};
- en: return p;
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: return p;
- en: '}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void operator delete[](void* p, const std::nothrow_t&)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete[](void* p, const std::nothrow_t&)
- en: noexcept {
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: noexcept {
- en: std::free(p);
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: std::free(p);
- en: '}'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void operator delete[](void* p) noexcept {
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete[](void* p) noexcept {
- en: operator delete[](p, std::nothrow);
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: operator delete[](p, std::nothrow);
- en: '}'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void operator delete[](void* p, std::size_t) noexcept {
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete[](void* p, std::size_t) noexcept {
- en: operator delete[](p, std::nothrow);
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: operator delete[](p, std::nothrow);
- en: '}'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int main() {
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: using std::nothrow;
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: using std::nothrow;
- en: auto p = new (nothrow) int{ 3 };
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = new (nothrow) int{ 3 };
- en: delete p;
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: delete p;
- en: p = new (nothrow) int[10];
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: p = new (nothrow) int[10];
- en: delete[]p;
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: delete[]p;
- en: '}'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '// note: these exist, you can use them but you cannot'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '// note: 这些存在，你可以使用它们，但你不能'
- en: // replace them
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: // 替换它们
- en: void *operator new(std::size_t, void *p) { return p; }
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: void *operator new(std::size_t, void *p) { return p; }
- en: void *operator new[](std::size_t, void *p) { return p; }
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: void *operator new[](std::size_t, void *p) { return p; }
- en: void operator delete(void*, void*) noexcept { }
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete(void*, void*) noexcept { }
- en: void operator delete[](void*, void*) noexcept { }
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete[](void*, void*) noexcept { }
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: auto string_length(const char *p) {
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: auto string_length(const char *p) {
- en: return std::string{ p }.size(); // augh! But it works...
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: return std::string{ p }.size(); // 啊！但它有效...
- en: '}'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: auto string_length(const char *p) {
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: auto string_length(const char *p) {
- en: using std::string;
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: using std::string;
- en: // A) make a local buffer of the right size and
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: // A) 制作正确大小的局部缓冲区
- en: // alignment for a string object
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: // 字符串对象的对齐
- en: alignas(string) char buf[sizeof(string)];
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: alignas(string) char buf[sizeof(string)];
- en: // B) "paint" a string object in that buffer
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: // B) 在该缓冲区中“绘制”字符串对象
- en: '// (note: that object might allocate its'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: // (注意：那个对象可能会分配其
- en: // own data externally, but that's not
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用外部数据，但那不是
- en: // our concern here)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: // 我们的关注点在这里)
- en: string *s = new (static_cast<void*>(buf)) string{ p };
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: string *s = new (static_cast<void*>(buf)) string{ p };
- en: // C) use that object to compute the size
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: // C) 使用该对象来计算大小
- en: const auto sz = s->size();
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: const auto sz = s->size();
- en: // D) destroy the object without releasing the memory
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: // D) 销毁对象而不释放内存
- en: // for the buffer (it's not dynamically allocated,
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: // 对于缓冲区（它不是动态分配的，
- en: // it's just local storage)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: // 它只是局部存储)
- en: s->~string(); // yes, you can do this
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: s->~string(); // 是的，你可以这样做
- en: return sz;
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: return sz;
- en: '}'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#include <iostream>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iostream>'
- en: '#include <new>'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <new>'
- en: class X {
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: class X {
- en: // ...
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: 'public:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: X() { std::cout << "X::X()\n"; }
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: X() { std::cout << "X::X()\n"; }
- en: ~X() { std::cout << "X::~X()\n"; }
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ~X() { std::cout << "X::~X()\n"; }
- en: void *operator new(std::size_t);
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: void *operator new(std::size_t);
- en: void *operator new[](std::size_t);
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: void *operator new[](std::size_t);
- en: void operator delete(void*);
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete(void*);
- en: void operator delete[](void*);
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete[](void*);
- en: // ...
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '};'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: // ...
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: void* X::operator new(std::size_t n) {
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: void* X::operator new(std::size_t n) {
- en: std::cout << "Some X::operator new() magic\n";
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << "Some X::operator new() magic\n";
- en: return ::operator new(n);
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: return ::operator new(n);
- en: '}'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void* X::operator new[](std::size_t n) {
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: void* X::operator new[](std::size_t n) {
- en: std::cout << "Some X::operator new[]() magic\n";
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << "Some X::operator new[]() magic\n";
- en: return ::operator new[](n);
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: return ::operator new[](n);
- en: '}'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void X::operator delete(void *p) {
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: void X::operator delete(void *p) {
- en: std::cout << "Some X::operator delete() magic\n";
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << "Some X::operator delete() magic\n";
- en: return ::operator delete(p);
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: return ::operator delete(p);
- en: '}'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void X::operator delete[](void *p) {
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: void X::operator delete[](void *p) {
- en: std::cout << "Some X::operator delete[]() magic\n";
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << "Some X::operator delete[]() magic\n";
- en: return ::operator delete[](p);
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: return ::operator delete[](p);
- en: '}'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int main() {
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: std::cout << "p = new int{3}\n";
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << "p = new int{3}\n";
- en: int *p = new int{ 3 }; // global operator new
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: int *p = new int{ 3 }; // 全局操作符 new
- en: std::cout << "q = new X\n";
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << "q = new X\n";
- en: X *q = new X; // X::operator new
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: X *q = new X; // X::operator new
- en: std::cout << "delete p\n";
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << "delete p\n";
- en: delete p; // global operator delete
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: delete p; // 全局操作符 delete
- en: std::cout << "delete q\n";
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << "delete q\n";
- en: delete q; // X::operator delete
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: delete q; // X::operator delete
- en: '}'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE15]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: struct alignas(16) Float4 { float vals[4]; };
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: struct alignas(16) Float4 { float vals[4]; };
- en: '[PRE16]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#include <iostream>'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iostream>'
- en: '#include <new>'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <new>'
- en: '#include <cstdlib>'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <cstdlib>'
- en: '#include <type_traits>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <type_traits>'
- en: void* operator new(std::size_t n, std::align_val_t al) {
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: void* operator new(std::size_t n, std::align_val_t al) {
- en: 'std::cout << "new(" << n << ", align: "'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'std::cout << "new(" << n << ", align: "'
- en: << static_cast<std::underlying_type_t<
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: << static_cast<std::underlying_type_t<
- en: std::align_val_t
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: std::align_val_t
- en: '>>(al) << ")\n";'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '>>(al) << ")\n";'
- en: return std::aligned_alloc(
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: return std::aligned_alloc(
- en: static_cast<std::size_t>(al), n
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: static_cast<std::size_t>(al), n
- en: );
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // (others omitted for brevity)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: // (其他省略以节省篇幅)
- en: struct alignas(16) Float4 { float vals[4]; };
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: struct alignas(16) Float4 { float vals[4]; };
- en: int main() {
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: auto p = new Float4; // calls operator new(size_t)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = new Float4; // 调用 operator new(size_t)
- en: // calls operator new(size_t, align_val_t)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: // 调用 operator new(size_t, align_val_t)
- en: auto q = new(std::align_val_t{ 16 }) Float4;
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: auto q = new(std::align_val_t{ 16 }) Float4;
- en: // leaks, of course, but that's beside the point
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: // 泄露，当然，但这不是重点
- en: '}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: class X {
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: class X {
- en: // ...
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: 'public:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: void operator delete(X*, std::destroying_delete_t);
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete(X*, std::destroying_delete_t);
- en: // ...
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '};'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE18]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#include <new>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <new>'
- en: '#include <iostream>'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iostream>'
- en: class Wrapper {
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: class Wrapper {
- en: 'public:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: enum class Kind { A, B };
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: enum class Kind { A, B };
- en: 'private:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'private:'
- en: struct Impl {
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: struct Impl {
- en: virtual int f() const = 0;
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: virtual int f() const = 0;
- en: '};'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'struct ImplA final : Impl {'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct ImplA final : Impl {'
- en: int f() const override { return 3; }
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: int f() const override { return 3; }
- en: ~ImplA() { std::cout << "Kind A\n"; }
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ~ImplA() { std::cout << "Kind A\n"; }
- en: '};'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'struct ImplB final : Impl {'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct ImplB final : Impl {'
- en: int f() const override { return 4; }
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: int f() const override { return 4; }
- en: ~ImplB() { std::cout << "Kind B\n"; }
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ~ImplB() { std::cout << "Kind B\n"; }
- en: '};'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: Impl *p;
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Impl *p;
- en: Kind kind;
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Kind kind;
- en: // ...
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE19]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: // ...
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: static Impl *create(Kind kind) {
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: static Impl *create(Kind kind) {
- en: switch(kind) {
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: switch(kind) {
- en: using enum Kind;
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: using enum Kind;
- en: 'case A: return new ImplA;'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 'case A: return new ImplA;'
- en: 'case B: return new ImplB;'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'case B: return new ImplB;'
- en: '}'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: throw 0;
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: throw 0;
- en: '}'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'public:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: Wrapper(Kind kind)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Wrapper(Kind kind)
- en: ': p{ create(kind) }, kind{ kind } {'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ': p{ create(kind) }, kind{ kind } {'
- en: '}'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE20]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: // ...
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: void operator delete(Wrapper *p,
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: void operator delete(Wrapper *p,
- en: std::destroying_delete_t) {
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: std::destroying_delete_t) {
- en: if(p->kind == Kind::A) {
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: if(p->kind == Kind::A) {
- en: delete static_cast<ImplA*>(p->p);
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: delete static_cast<ImplA*>(p->p);
- en: '} else {'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: delete static_cast<ImplB*>(p->p);
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: delete static_cast<ImplB*>(p->p);
- en: '}'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: p->~Wrapper();
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: p->~Wrapper();
- en: ::operator delete(p);
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ::operator delete(p);
- en: '}'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int f() const { return p->f(); }
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: int f() const { return p->f(); }
- en: '};'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE21]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: int main() {
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: using namespace std;
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: using namespace std;
- en: auto p = new Wrapper{ Wrapper::Kind::A };
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = new Wrapper{ Wrapper::Kind::A };
- en: cout << p->f() << endl;
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: cout << p->f() << endl;
- en: delete p;
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 p;
- en: p = new Wrapper{ Wrapper::Kind::B };
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: p = new Wrapper{ Wrapper::Kind::B };
- en: cout << p->f() << endl;
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: cout << p->f() << endl;
- en: delete p;
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 p;
- en: '}'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE22]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
