["```cpp\nsudo make install\n\n```", "```cpp\nnamespace converter\n{\n    constexpr double PIXELS_PER_METERS = 32.0;\n    constexpr double PI = 3.14159265358979323846;\n\n    template<typename T>\n    constexpr  T pixelsToMeters(const T& x){return x/PIXELS_PER_METERS;};\n\n    template<typename T>\n    constexpr T metersToPixels(const T& x){return x*PIXELS_PER_METERS;};\n\n    template<typename T>\n    constexpr T degToRad(const T& x){return PI*x/180.0;};\n\n    template<typename T>\n    constexpr T radToDeg(const T& x){return 180.0*x/PI;}\n}\n```", "```cpp\n    int main(int argc,char* argv[])\n    {\n        sf::RenderWindow window(sf::VideoMode(800, 600, 32), \"04_Basic\");\n        window.setFramerateLimit(60);\n        b2Vec2 gravity(0.f, 9.8f);\n        b2World world(gravity);\n        std::list<b2Body*> bodies;\n        bodies.emplace_back(book::createBox(world,400,590,800,20,b2_staticBody));\n\n        while(window.isOpen()) {\n            sf::Event event;\n            while(window.pollEvent(event)) {\n                if (event.type == sf::Event::Closed)\n                    window.close();\n            }\n            if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {\n                int x = sf::Mouse::getPosition(window).x;\n                int y = sf::Mouse::getPosition(window).y;\n                bodies.emplace_back(book::createBox(world,x,y,32,32));\n            }\n            displayWorld(world,window);\n        }\n\n        for(b2Body* body : bodies) {\n            delete static_cast<sf::RectangleShape*>(body->GetUserData());\n            world.DestroyBody(body);\n        }\n        return 0;\n    }\n    ```", "```cpp\nb2Body* createBox(b2World& world,int pos_x,int pos_y, int size_x,int size_y,b2BodyType type = b2_dynamicBody)\n{\n    b2BodyDef bodyDef;\n    bodyDef.position.Set(converter::pixelsToMeters<double>(pos_x),\n                        converter::pixelsToMeters<double>(pos_y));\n    bodyDef.type = type;                  \n    b2PolygonShape b2shape;\n    b2shape.SetAsBox(converter::pixelsToMeters<double>(size_x/2.0),\n                    converter::pixelsToMeters<double>(size_y/2.0));\n\n    b2FixtureDef fixtureDef;\n    fixtureDef.density = 1.0;\n    fixtureDef.friction = 0.4;\n    fixtureDef.restitution= 0.5;\n    fixtureDef.shape = &b2shape;\n\n    b2Body* res = world.CreateBody(&bodyDef);\n    res->CreateFixture(&fixtureDef);\n\n    sf::Shape* shape = new sf::RectangleShape(sf::Vector2f(size_x,size_y));\n    shape->setOrigin(size_x/2.0,size_y/2.0);\n    shape->setPosition(sf::Vector2f(pos_x,pos_y));\n\n    if(type == b2_dynamicBody)\n        shape->setFillColor(sf::Color::Blue);\n    else\n        shape->setFillColor(sf::Color::White);\n\n    res->SetUserData(shape);\n\n    return res;\n}\n```", "```cpp\nvoid displayWorld(b2World& world,sf::RenderWindow& render)\n{\n    world.Step(1.0/60,int32(8),int32(3));\n    render.clear();\n    for (b2Body* body=world.GetBodyList(); body!=nullptr; body=body->GetNext())\n    {   \n        sf::Shape* shape = static_cast<sf::Shape*>(body->GetUserData());\n        shape->setPosition(converter::metersToPixels(body->GetPosition().x),\n        converter::metersToPixels(body->GetPosition().y));\n        shape->setRotation(converter::radToDeg<double>(body->GetAngle()));\n        render.draw(*shape);\n    }\n    render.display();\n}\n```", "```cpp\nclass Configuration\n{\n    public:\n        Configuration() = delete;\n        Configuration(const Configuration&) = delete;\n        Configuration& operator=(const Configuration&) = delete;\n\n        enum Fonts : int {Gui};\n        static ResourceManager<sf::Font,int> fonts;\n\n        enum PlayerInputs : int { TurnLeft,TurnRight, MoveLeft, MoveRight,HardDrop};\n        static ActionMap<int> playerInputs;\n\n        enum Sounds : int {Spawn,Explosion,LevelUp,};\n        static ResourceManager<sf::SoundBuffer,int> sounds;\n\n        enum Musics : int {Theme};\n        static ResourceManager<sf::Music,int> musics;\n\n        static void initialize();\n\n    private:\n        static void initTextures();\n        static void initFonts();\n        static void initSounds();\n        static void initMusics();\n        static void initPlayerInputs();\n};\n```", "```cpp\nvoid Configuration::initSounds()\n{\n    sounds.load(Sounds::Spawn,\"media/sounds/spawn.flac\");\n    sounds.load(Sounds::Explosion,\"media/sounds/explosion.flac\");\n    sounds.load(Sounds::LevelUp,\"media/sounds/levelup.flac\");\n}\nvoid Configuration::initPlayerInputs()\n{\n    playerInputs.map(PlayerInputs::TurnRight,Action(sf::Keyboard::Up));\n    playerInputs.map(PlayerInputs::TurnLeft,Action(sf::Keyboard::Down));\n    playerInputs.map(PlayerInputs::MoveLeft,Action(sf::Keyboard::Left));\n    playerInputs.map(PlayerInputs::MoveRight,Action(sf::Keyboard::Right));\n    playerInputs.map(PlayerInputs::HardDrop,Action(sf::Keyboard::Space,\n    Action::Type::Released));\n}\n```", "```cpp\nconstexpr int BOOK_BOX_SIZE = 32;\nconstexpr int BOOK_BOX_SIZE_2 = BOOK_BOX_SIZE / 2;\nclass Piece : public sf::Drawable\n{\n    public:\n        Piece(const Piece&) = delete;\n        Piece& operator=(const Piece&) = delete;\n\n        enum TetriminoTypes {O=0,I,S,Z,L,J,T,SIZE}; \n        static const sf::Color TetriminoColors[TetriminoTypes::SIZE];        \n\n        Piece(b2World& world,int pos_x,int pos_y,TetriminoTypes type,float rotation); \n        ~Piece();\n        void update();\n        void rotate(float angle);\n        void moveX(int direction);\n        b2Body* getBody()const;\n\n    private:\n        virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const override;\n        b2Fixture* createPart((int pos_x,int pos_y,TetriminoTypes type); ///< position is relative to the piece int the matrix coordinate (0 to 3)\n        b2Body * _body;\n        b2World& _world;\n};\n```", "```cpp\nPiece::Piece(b2World& world,int pos_x,int pos_y,TetriminoTypes type,float rotation) : _world(world)\n{\n    b2BodyDef bodyDef;\n    bodyDef.position.Set(converter::pixelsToMeters<double>(pos_x),\n    converter::pixelsToMeters<double>(pos_y));\n    bodyDef.type = b2_dynamicBody;\n    bodyDef.angle = converter::degToRad(rotation);\n    _body = world.CreateBody(&bodyDef);\n\n    switch(type)\n    {\n        case TetriminoTypes::O : {\n            createPart((0,0,type); createPart((0,1,type);\n            createPart((1,0,type); createPart((1,1,type);\n        }break;\n        case TetriminoTypes::I : {\n            createPart((0,0,type); createPart((1,0,type);\n            createPart((2,0,type); createPart((3,0,type);\n        }break;\n        case TetriminoTypes::S : {\n            createPart((0,1,type); createPart((1,1,type);\n            createPart((1,0,type); createPart((2,0,type);\n        }break;\n        case TetriminoTypes::Z : {\n            createPart((0,0,type); createPart((1,0,type);\n            createPart((1,1,type); createPart((2,1,type);\n        }break;\n        case TetriminoTypes::L : {\n            createPart((0,1,type); createPart((0,0,type);\n            createPart((1,0,type); createPart((2,0,type);\n        }break;\n        case TetriminoTypes::J : {\n            createPart((0,0,type); createPart((1,0,type);\n            createPart((2,0,type); createPart((2,1,type);\n        }break;\n        case TetriminoTypes::T : {\n            createPart((0,0,type); createPart((1,0,type);\n            createPart((1,1,type); createPart((2,0,type);\n        }break;\n        default:break;\n    }\n    body->SetUserData(this);\n    update();\n}\n```", "```cpp\nPiece::~Piece()\n{\n    for(b2Fixture* fixture=_body->GetFixtureList();fixture!=nullptr;\n    fixture=fixture->GetNext())\n{\n        sf::ConvexShape* shape = static_cast<sf::ConvexShape*>(fixture->GetUserData());\n        fixture->SetUserData(nullptr);\n        delete shape;\n    }\n    _world.DestroyBody(_body);\n}\n```", "```cpp\nb2Fixture* Piece::createPart((int pos_x,int pos_y,TetriminoTypes type)\n{\n    b2PolygonShape b2shape;\n    b2shape.SetAsBox(converter::pixelsToMeters<double>(BOOK_BOX_SIZE_2),\n    converter::pixelsToMeters<double>(BOOK_BOX_SIZE_2)\n    ,b2Vec2(converter::pixelsToMeters<double>(BOOK_BOX_SIZE_2+(pos_x*BOOK_BOX_SIZE)),\nconverter::pixelsToMeters<double>(BOOK_BOX_SIZE_2+(pos_y*BOOK_BOX_SIZE))),0);\n\n    b2FixtureDef fixtureDef;\n    fixtureDef.density = 1.0;\n    fixtureDef.friction = 0.5;\n    fixtureDef.restitution= 0.4;\n    fixtureDef.shape = &b2shape;\n\n    b2Fixture* fixture = _body->CreateFixture(&fixtureDef);\n\n    sf::ConvexShape* shape = new sf::ConvexShape((unsigned int) b2shape.GetVertexCount());\n    shape->setFillColor(TetriminoColors[type]);\n    shape->setOutlineThickness(1.0f);\n    shape->setOutlineColor(sf::Color(128,128,128));\n    fixture->SetUserData(shape);\n\n    return fixture;\n}\n```", "```cpp\nvoid Piece::update()\n{\n    const b2Transform& xf = _body->GetTransform();\n\n    for(b2Fixture* fixture = _body->GetFixtureList(); fixture != nullptr;\n    fixture=fixture->GetNext())\n{\n        sf::ConvexShape* shape = static_cast<sf::ConvexShape*>(fixture->GetUserData());\n        const b2PolygonShape* b2shape = static_cast<b2PolygonShape*>(fixture->GetShape());\n        const uint32 count = b2shape->GetVertexCount();\n        for(uint32 i=0;i<count;++i) \n{\n            b2Vec2 vertex = b2Mul(xf,b2shape->m_vertices[i]);\n            shape->setPoint(i,sf::Vector2f(converter::metersToPixels(vertex.x),\n            converter::metersToPixels(vertex.y)));\n        }\n    }\n}\n```", "```cpp\nvoid Piece::rotate(float angle) {\n    body->ApplyTorque((float32)converter::degToRad(angle),true);\n}\nvoid Piece::moveX(int direction) {\n    body->ApplyForceToCenter(b2Vec2(converter::pixelsToMeters(direction),0),true);\n}\n```", "```cpp\nb2Body* Piece::getBody()const {return _body;}\n\nvoid Piece::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n    for(const b2Fixture* fixture=_body->GetFixtureList();fixture!=nullptr; fixture=fixture->GetNext())\n{\n        sf::ConvexShape* shape = static_cast<sf::ConvexShape*>(fixture->GetUserData());\n        if(shape)\n            target.draw(*shape,states);\n    }\n}\n```", "```cpp\nclass World : public sf::Drawable\n{\n    public:\n        World(const World&) = delete;\n        World& operator=(const World&) = delete;\n\n        World(int size_x,int size_y);\n        ~World();\n        void update(sf::Time deltaTime);\n        void updatePhysics(sf::Time deltaTime);\n        Piece* newPiece();\n        int clearLines(bool& del,const Piece& current);\n        void updateGravity(int level);\n        void add(Configuration::Sounds sound_id);\n        bool isGameOver()const;\n\n    private:\n        virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const override;\n        b2World _physicalWorld;\n        void createWall(int pos_x, int pos_y, int size_x, int size_y);\n        const int _x;\n        const int _y;\n        std::list<std::unique_ptr<sf::Sound>> _sounds;\n};\n```", "```cpp\nWorld::World(int size_x,int size_y) : _physicalWorld(b2Vec2(0.f, 1.5f)),_x(size_x), _y(size_y)\n{\n    createWall(0,0,BOOK_BOX_SIZE,_y*BOOK_BOX_SIZE);\n    createWall(BOOK_BOX_SIZE*(_x+1.2),0,BOOK_BOX_SIZE,_y*BOOK_BOX_SIZE);\n    createWall(0,BOOK_BOX_SIZE*_y,BOOK_BOX_SIZE*(_x+2.2),BOOK_BOX_SIZE);\n}\n```", "```cpp\nWorld::~World()\n{\n    for (b2Body* body=_physicalWorld.GetBodyList(); body!=nullptr;)\n{\n        b2Body* next = body->GetNext();\n        if(body->GetType() == b2_dynamicBody)\n            delete static_cast<Piece*>(body->GetUserData());\n        else\n            delete static_cast<sf::RectangleShape*>(body->GetUserData());\n        body = next;\n    }\n}\n```", "```cpp\nvoid World::update(sf::Time deltaTime)\n{\n    for (b2Body* body=_physicalWorld.GetBodyList(); body!=nullptr;\n    body=body->GetNext())\n{\n        if(body->GetType() == b2_dynamicBody){\n            Piece* piece = static_cast<Piece*>(body->GetUserData());\n            piece->update();\n        }\n    }\n    _sounds.remove_if([](const std::unique_ptr<sf::Sound>& sound) -> bool {\n          return sound->getStatus() != sf::SoundSource::Status::Playing;\n        });\n}\n```", "```cpp\nClass _AABB_callback  : public b2QueryCallback\n{\n    public :\n        std::<b2Fixture*> fixtures;\n\n        virtual bool ReportFixture(b2Fixture* fixture) override {\n            if(fixture->GetBody()->GetType() == b2_dynamicBody)\n                fixtures.emplace_back(fixture);\n            return true;\n        }\n};\n```", "```cpp\nint World::clearLines(bool& del,const Piece& current)\n{\n    int nb_lines = 0;\n    _AABB_callback callback;\n    del = false;\n    for(int y=0;y<=_y;++y) \n{ //loop on Y axies\n        b2AABB aabb; //world query\n        //set the limit of the query\n        aabb.lowerBound = b2Vec2(converter::pixelsToMeters<double>(0),\n        converter::pixelsToMeters<double>((y+0.49)*BOOK_BOX_SIZE));\n        aabb.upperBound = b2Vec2(converter::pixelsToMeters<double>(_x*BOOK_BOX_SIZE),\n             converter::pixelsToMeters<double>((y+0.51)*BOOK_BOX_SIZE));\n        //query the world\n        _physicalWorld.QueryAABB(&callback,aabb);\n\n        if((int)callback.fixtures.size() >= _x) \n{\n            for(b2Fixture* fixture : callback.fixtures) \n{\n                b2Body* body = fixture->GetBody();\n                del |= body == current.getBody();\n\n                if(body->GetFixtureList()->GetNext() != nullptr)\n               {//no more fixture attached to the body\n                    sf::ConvexShape* shape = static_cast<sf::ConvexShape*>(fixture->GetUserData());\n                    body->DestroyFixture(fixture);\n                    delete shape;\n                } else {\n                    Piece* piece = static_cast<Piece*>(body->GetUserData());\n                    delete piece;\n                }\n                fixture = nullptr;\n            }\n            ++nb_lines;\n        }\n        callback.fixtures.clear();\n    }\n    if(nb_lines > 0)\n        add(Configuration::Sounds::Explosion);\n    return nb_lines;\n}\n```", "```cpp\nvoid World::updateGravity(int level) {\n    physical_world.SetGravity(b2Vec2(0,1.5+(level/2.0)));\n}\n```", "```cpp\nvoid World::add(Configuration::Sounds sound_id)\n{\n    std::unique_ptr<sf::Sound> sound(new sf::Sound(Configuration::sounds.get(sound_id)));\n    sound->setAttenuation(0);\n    sound->play();\n    _sounds.emplace_back(std::move(sound));\n}\n```", "```cpp\nbool World::isGameOver()const\n{\n    for (const b2Body* body=_physicalWorld.GetBodyList(); body!=nullptr;\n    body=body->GetNext())\n{\n        if(body->GetType() == b2_staticBody)\n            continue;\n        if(body->GetPosition().y < 0)\n            return true;\n    }\n    return false;\n};\n```", "```cpp\nvoid World::updatePhysics(sf::Time deltaTime)\n{\n    float seconds = deltaTime.asSeconds();  \n    _physicalWorld.Step(seconds,8,3);\n}\n```", "```cpp\nPiece* World::newPiece()\n{\n    add(Configuration::Sounds::Spawn);\n    return new Piece(_physicalWorld,_x/2*BOOK_BOX_SIZE, BOOK_BOX_SIZE,static_cast<Piece::TetriminoTypes>( random(0, Piece::TetriminoTypes::SIZE-1)), random(0.f,360.f));\n}\n```", "```cpp\nvoid World::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n    for (const b2Body* body=_physicalWorld.GetBodyList(); body!=nullptr;body=body->GetNext())\n{\n        if(body->GetType() == b2_dynamicBody){\n            Piece* piece = static_cast<Piece*>(body->GetUserData());\n            target.draw(*piece,states);\n        } else {//static body\n            sf::RectangleShape* shape = static_cast<sf::RectangleShape*>(body->GetUserData());\n            target.draw(*shape,states);\n        }\n    }\n}\n```", "```cpp\nvoid World::creatWeall(int pos_x, int pos_y,int size_x,int size_y)\n{\n    b2BodyDef bodyDef;\n    bodyDef.position.Set(converter::pixelsToMeters<double>(pos_x),\n    converter::pixelsToMeters<double>(pos_y));\n    bodyDef.type = b2_staticBody;\n\n    b2PolygonShape b2shape;\n    double sx = converter::pixelsToMeters<double>(size_x)/2.0;\n    double sy = converter::pixelsToMeters<double>(size_y)/2.0;\n    b2shape.SetAsBox(sx,sy,b2Vec2(sx,sy),0);                \n\n    b2FixtureDef fixtureDef;\n    fixtureDef.density = 1.0;\n    fixtureDef.friction = 0.8;\n    fixtureDef.restitution= 0.1;\n    fixtureDef.shape = &b2shape;\n\n    b2Body* body = _physicalWorld.CreateBody(&bodyDef);\n    body->CreateFixture(&fixtureDef);\n\n    sf::Shape* shape = new sf::RectangleShape(sf::Vector2f(size_x,size_y));\n    shape->setOrigin(size_x/2.0,size_y/2.0);\n    shape->setPosition(sf::Vector2f(pos_x+size_x/2.0,pos_y+size_y/2.0));\n    shape->setFillColor(sf::Color(50,50,50));\n    body->SetUserData(shape);\n}\n```", "```cpp\nclass Game: public ActionTarget<int>\n{\n    public:\n        Game(const Game&) = delete;\n        Game& operator=(const Game&) = delete;\n        Game(int x,int y,int word_x=10,int word_y=20);\n        void run(int minimum_frame_per_seconds=30,int phyiscs_frame_per_seconds=60);\n\n    private:\n        void processEvents();\n        void update(const sf::Time& deltaTime,const sf::Time& timePerFrame);\n        void updatePhysics(const sf::Time& deltaTime,const sf::Time& timePerFrame);\n        void render();\n\n        sf::RenderWindow _window;\n        int _moveDirection;\n        int _rotateDirection;\n        Piece* _currentPiece;\n        World _world;\n        Stats _stats;\n        sf::Time timeSinceLastFall;\n};\n```", "```cpp\nGame::Game(int X, int Y,int word_x,int word_y) : ActionTarget(Configuration::playerInputs), _window(sf::VideoMode(X,Y),\"04_Gravitris\"),_currentPiece(nullptr), _world(word_x,word_y)\n{\n    bind(Configuration::PlayerInputs::HardDrop,[this](const sf::Event&){\n         _currentPiece = _world.newPiece();\n         timeSinceLastFall = sf::Time::Zero;\n    });\n    bind(Configuration::PlayerInputs::TurnLeft,[this](const sf::Event&){\n         _rotateDirection-=1;\n    });\n    bind(Configuration::PlayerInputs::TurnRight,[this](const sf::Event&){\n         _rotateDirection+=1;\n    });\n    bind(Configuration::PlayerInputs::MoveLeft,[this](const sf::Event&){\n         _moveDirection-=1;\n    });\n    bind(Configuration::PlayerInputs::MoveRight,[this](const sf::Event&){\n         _moveDirection+=1;\n    });\n    _stats.setPosition(BOOK_BOX_SIZE*(word_x+3),BOOK_BOX_SIZE);\n    _currentPiece = _world.newPiece();\n}\n```", "```cpp\nvoid Game::run(int minimum_frame_per_seconds, int physics_frame_per_seconds)\n{\n    sf::Clock clock;\n    const sf::Time timePerFrame = sf::seconds(1.f/minimum_frame_per_seconds);\n    const sf::Time timePerFramePhysics = sf::seconds(1.f/physics_frame_per_seconds);\n\n    while (_window.isOpen())\n    {\n        sf::Time time = clock.restart();\n        processEvents();\n        if(not _stats.isGameOver()) \n{\n            updatePhysics(time,timePerFramePhysics);\n            update(time,timePerFrame);\n        }\n        render();\n    }\n}\n```", "```cpp\nvoid Game::update(const sf::Time& deltaTime,const sf::Time& timePerFrame)\n{\n    sf::Time timeSinceLastUpdate = sf::Time::Zero;\n\n    timeSinceLastUpdate+=deltaTime;\n    timeSinceLastFall+=deltaTime;\n    if(timeSinceLastUpdate > timePerFrame)\n    {\n        if(_currentPiece != nullptr)\n        {\n            _currentPiece->rotate(_rotateDirection*3000);\n            _currentPiece->moveX(_moveDirection*5000);\n\n            bool new_piece;\n            int old_level =_stats.getLevel();\n            _stats.addLines(_world.clearLines(new_piece,*_currentPiece));\n            if(_stats.getLevel() != old_level) //add sound\n                _world.add(Configuration::Sounds::LevelUp);\n\n            if(new_piece or timeSinceLastFall.asSeconds() > std::max(1.0,10-_stats.getLevel()*0.2))\n            {//create new piece\n                _currentPiece = _world.newPiece();\n                timeSinceLastFall = sf::Time::Zero;\n            }\n        }\n        _world.update(timePerFrame);\n        _stats.setGameOver(_world.isGameOver());\n        timeSinceLastUpdate = sf::Time::Zero;\n    }\n    _rotateDirection=0;\n    _moveDirection=0;\n}\n```", "```cpp\nvoid Game::updatePhysics(const sf::Time& deltaTime,const sf::Time& timePerFrame)\n{\n    static sf::Time timeSinceLastUpdate = sf::Time::Zero;\n    timeSinceLastUpdate+=deltaTime;\n    _world.updateGravity(_stats.getLevel());\n\n    while (timeSinceLastUpdate > timePerFrame)\n{\n        _world.updatePhysics(timePerFrame);\n        timeSinceLastUpdate -= timePerFrame;\n    }\n}\n```"]