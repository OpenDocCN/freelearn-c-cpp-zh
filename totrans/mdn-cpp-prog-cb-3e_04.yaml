- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Preprocessing and Compilation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理和编译
- en: In C++, compilation is the process by which source code is transformed into
    machine code and organized into object files that are then linked together to
    produce an executable. The compiler actually works on a single file (called a
    translation unit) at a time, produced by the preprocessor (the part of the compiler
    that handles preprocessing directives) from a single source file and all the header
    files that it includes. This is, however, an oversimplification of what happens
    when we compile the code. This chapter addresses topics related to preprocessing
    and compilation, with a focus on various methods to perform conditional compilation,
    but also touches on other modern topics such as using attributes to provide implementation-defined
    language extensions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，编译是将源代码转换为机器代码并组织成对象文件的过程，这些对象文件随后被链接在一起以生成可执行文件。编译器实际上一次只处理一个文件（称为翻译单元），该文件由预处理程序（处理预处理指令的编译器部分）从单个源文件及其包含的所有头文件生成。然而，这只是一个简化的编译代码时发生的事情的描述。本章讨论与预处理和编译相关的话题，重点关注执行条件编译的各种方法，同时也涉及其他现代主题，例如使用属性提供实现定义的语言扩展。
- en: 'The recipes included in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含的食谱如下：
- en: Conditionally compiling your source code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件编译您的源代码
- en: Using the indirection pattern for preprocessor stringification and concatenation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用间接模式进行预处理程序字符串化和连接
- en: Performing compile-time assertion checks with `static_assert`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`static_assert`执行编译时断言检查
- en: Conditionally compiling classes and functions with `enable_if`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`enable_if`条件编译类和函数
- en: Selecting branches at compile time with *constexpr if*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`constexpr if`在编译时选择分支
- en: Providing metadata to the compiler with attributes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性向编译器提供元数据
- en: The recipe that we will start this chapter with addresses a very common problem
    faced by developers, which is compiling only parts of a code base depending on
    various conditions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章开始时讨论的食谱解决的是开发者面临的一个非常普遍的问题，即根据各种条件仅编译代码库的一部分。
- en: Conditionally compiling your source code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件编译您的源代码
- en: Conditional compilation is a simple mechanism that enables developers to maintain
    a single code base, but only consider some parts of the code for compilation to
    produce different executables, usually in order to run on different platforms
    or hardware, or depend on different libraries or library versions. Common examples
    include using or ignoring code based on the compiler, platform (x86, x64, ARM,
    and so on), configuration (debug or release), or any user-defined specific conditions.
    In this recipe, we’ll take a look at how conditional compilation works.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译是一种简单的机制，它使开发者能够维护单个代码库，但只考虑代码的一部分进行编译以生成不同的可执行文件，通常是为了在不同的平台或硬件上运行，或者依赖于不同的库或库版本。常见的例子包括根据编译器、平台（x86、x64、ARM等）、配置（调试或发布）或任何用户定义的特定条件使用或忽略代码。在本食谱中，我们将探讨条件编译是如何工作的。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Conditional compilation is a technique used extensively for many purposes.
    In this recipe, we will look at several examples and explain how they work. This
    technique is not in any way limited to these examples. For the scope of this recipe,
    we will only consider the three major compilers: GCC, Clang, and VC++.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译是一种广泛用于许多目的的技术。在本食谱中，我们将查看几个示例并解释它们是如何工作的。这种技术并不局限于这些示例。对于本食谱的范围，我们只考虑三个主要的编译器：GCC、Clang和VC++。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To conditionally compile portions of code, use the `#if`, `#ifdef`, and `#ifndef`
    directives (with the `#elif`, `#else`, and `#endif` directives). The general form
    for conditional compilation is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要条件编译代码的部分，请使用`#if`、`#ifdef`和`#ifndef`指令（以及`#elif`、`#else`和`#endif`指令）。条件编译的一般形式如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Because the conditions here usually imply checking whether a macro is defined
    or not using the `defined identifier` or `defined (identifier)` syntax, it’s also
    possible to use the following forms:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这里的条件通常意味着使用`defined identifier`或`defined (identifier)`语法检查宏是否已定义，因此也可以使用以下形式：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `#elifdef` and `#elifndef` directives were introduced in C++23.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`#elifdef`和`#elifndef`指令是在C++23中引入的。'
- en: 'To define macros for conditional compilation, you can use either of the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要为条件编译定义宏，您可以使用以下两种方法之一：
- en: 'A `#define` directive in your source code:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的源代码中的`#define`指令：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compiler command-line options that are specific to each compiler. Examples
    for the most widely used compilers are as follows:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Visual C++, use `/Dname` or `/Dname=value` (where `/Dname` is equivalent
    to `/Dname=1`), for example, `cl /DVERBOSITY_LEVEL=5`.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For GCC and Clang, use `-D name` or `-D name=value` (where `-D name` is equivalent
    to `-D name=1`), for example, `gcc -D VERBOSITY_LEVEL=5`.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are typical examples of conditional compilation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Header guards to avoid duplicate definitions (due to multiple inclusions of
    the same header in the same translation unit):'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compiler-specific code for cross-platform applications. The following is an
    example of printing a message to the console with the name of the compiler:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Target-specific code for multiple architectures, for example, for conditionally
    compiling code for multiple compilers and architectures:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Configuration-specific code, for example, for conditionally compiling code
    for debug and release builds:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To check whether a language or library feature is available, use the predefined
    macros `__cpp_xxx` for language features (such as `__cpp_constexpr`, `__cpp_constinit`,
    or `__cpp_modules`) and `__cpp_lib_xxx` for library features (such as `__cpp_lib_concepts`,
    `__cpp_lib_expected`, or `__cpp_lib_jthread`). The library feature macros were
    introduced in C++20 and are available in the `<version>` header:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To check whether a header or source file is available for inclusion, use the
    `__has_include` directive, which is available in C++17\. The following example
    checks whether the `<optional>` header exists:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To check whether an attribute is supported (as well as from what version),
    use the `__has_cpp_attribute` directive, which is available in C++20:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before discussing compilation, we should first clarify a term that we will
    encounter often: **translation unit**. In C++, this is the basic unit of compilation.
    It is the result of putting together the content of a source file (a `.cpp` file)
    and the entire graph of all the header files included directly or indirectly but
    without the text excluded with conditional preprocessing statements, as described
    in this recipe.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use the preprocessing directives `#if`, `#ifndef`, `#ifdef`, `#elif`,
    `#else`, and `#endif`, the compiler will select, at most, one branch whose body
    will be included in the translation unit for compilation. The body of these directives
    can be any text, including other preprocessing directives. The following rules
    apply:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`#if`, `#ifdef`, and `#ifndef` must be matched by an `#endif`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `#if` directive may have multiple `#elif` directives, but only one `#else`,
    which must also be the last one before `#endif`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#if`, `#ifdef`, `#ifndef`, `#elif`, `#else`, and `#endif` can be nested.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `#if` directive requires a constant expression, whereas `#ifdef` and `#ifndef`
    require an identifier.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `defined` operator can be used for preprocessor constant expressions, but
    only in `#if` and `#elif` directives.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defined(identifier)` is considered `true` if `identifier` is defined; otherwise,
    it is considered `false`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `identifier` 被定义，则 `defined(identifier)` 被认为是 `true`；否则，被认为是 `false`。
- en: An identifier defined as an empty text is considered defined.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被定义为空文本的标识符被认为是已定义的。
- en: '`#ifdef identifier` is equivalent to `#if defined(identifier)`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#ifdef identifier` 等同于 `#if defined(identifier)`。'
- en: '`#ifndef identifier` is equivalent to `#if !defined(identifier)`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#ifndef identifier` 等同于 `#if !defined(identifier)`。'
- en: '`defined(identifier)` and `defined identifier` are equivalent.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defined(identifier)` 和 `defined identifier` 是等效的。'
- en: Header guards are one of the most common forms of conditional compilation. This
    technique is used to prevent the content of a header file from being included
    several times in the same translation unit (although the header is still scanned
    every time in order to detect what should be included). Therefore, the code in
    headers is guarded against multiple inclusions in the manner shown in the example
    given in the previous section. The way this works, considering the given example,
    is that if the `UNIQUE_NAME` macro (this is a generic name from the previous section)
    is not defined, then the code after the `#if` directive, until `#endif`, is included
    in the translation unit and compiled. When that happens, the `UNIQUE_NAME` macro
    is defined with the `#define` directive. The next time the header is included
    in the (same) translation unit, the `UNIQUE_NAME` macro is defined and the code
    in the body of the `#if` directive is not included in the translation unit, therefore,
    it avoids duplicates.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件保护是条件编译中最常见的形式之一。这种技术用于防止头文件的内容在同一个翻译单元中被多次包含（尽管每次都会扫描头文件以检测应该包含的内容）。因此，头文件中的代码以示例中所示的方式进行了保护，以防止多次包含。考虑到给定的示例，如果
    `UNIQUE_NAME` 宏（这是上一节中的通用名称）未定义，则 `#if` 指令之后的代码，直到 `#endif`，将被包含在翻译单元中并编译。当这种情况发生时，使用
    `#define` 指令定义 `UNIQUE_NAME` 宏。下次将头文件包含在（相同的）翻译单元中时，`UNIQUE_NAME` 宏已被定义，因此 `#if`
    指令体中的代码不会被包含在翻译单元中，从而避免了重复。
- en: Note that the name of the macro must be unique throughout the application; otherwise,
    only the code from the first header where the macro is used will be compiled.
    Code from other headers using the same name will be ignored. Typically, the name
    of the macro is based on the name of the header file where it is defined.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，宏的名称在整个应用程序中必须是唯一的；否则，只有使用该宏的第一个头文件中的代码将被编译。使用相同名称的其他头文件中的代码将被忽略。通常，宏的名称基于定义它的头文件名称。
- en: Another important example of conditional compilation is cross-platform code,
    which needs to account for different compilers and architectures, usually one
    of Intel x86, AMD64, or ARM. However, the compiler defines its own macros for
    the possible platforms. The samples from the *How to do it...* section show how
    to conditionally compile code for multiple compilers and architectures.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译的另一个重要例子是跨平台代码，它需要考虑不同的编译器和架构，通常是 Intel x86、AMD64 或 ARM。然而，编译器为可能的平台定义了自己的宏。*如何做...*
    部分的示例展示了如何为多个编译器和架构条件编译代码。
- en: Note that in the aforementioned example, we only consider a few architectures.
    In practice, there are multiple macros that can be used to identify the same architecture.
    Ensure that you read the documentation of each compiler before using these types
    of macros in your code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上述示例中，我们只考虑了几个架构。在实际应用中，存在多个宏可以用来识别相同的架构。在使用这些类型的宏之前，请确保您已经阅读了每个编译器的文档。
- en: Configuration-specific code is also handled with macros and conditional compilation.
    Compilers such as GCC and Clang do not define any special macros for debug configurations
    (when the `-g` flag is used). Visual C++ does define `_DEBUG` for a debug configuration,
    which was shown in the last example in the *How to do it...* section. For the
    other compilers, you would have to explicitly define a macro to identify such
    a debug configuration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 特定配置的代码也使用宏和条件编译来处理。例如，GCC 和 Clang 编译器在调试配置（当使用 `-g` 标志时）中不定义任何特殊的宏。Visual C++
    为调试配置定义了 `_DEBUG`，这在上一节的 *如何做...* 部分中已展示。对于其他编译器，您必须显式定义一个宏来识别此类调试配置。
- en: 'Feature testing is an important conditional-compilation use case, especially
    in libraries that provide support for multiple platforms (Windows, Linux, etc.)
    and compiler versions (C++11, C++14, C++17, etc.). Library implementers often
    need to check whether a particular language feature or language attribute is available.
    This is possible with a set of predefined macros that includes the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试是条件编译的重要用例，特别是在为多个平台（Windows、Linux 等）和编译器版本（C++11、C++14、C++17 等）提供支持的库中。库实现者通常需要检查特定语言功能或语言属性是否可用。这可以通过一组预定义的宏来实现，包括以下内容：
- en: '`__cplusplus`: Indicates the version of the C++ standard that is being used.
    It expands to one of the following values: `199711L` for versions before C++11,
    `201103L` for C++11, `201402L` for C++14, `201703L` for C++17, and `202002L` for
    C++20\. At the time of writing the book, the value for C++23 has not been defined.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__cplusplus`: 表示正在使用的 C++ 标准版本。它扩展为以下值之一：`199711L` 用于 C++11 之前的版本，`201103L`
    用于 C++11，`201402L` 用于 C++14，`201703L` 用于 C++17，以及 `202002L` 用于 C++20。在撰写本书时，C++23
    的值尚未定义。'
- en: '`__cpp_xxx` macros, for determining whether a language feature is supported.
    Examples include `__cpp_concepts`, `__cpp_consteval`, `__cpp_modules`, etc.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__cpp_xxx` 宏，用于确定语言功能是否受支持。例如包括 `__cpp_concepts`、`__cpp_consteval`、`__cpp_modules`
    等。'
- en: '`__cpp_lib_xxx` macros, for determining whether a library feature is supported.
    Examples include `__cpp_lib_any`, `__cpp_lib_optional`, `__cpp_lib_constexpr_string`,
    etc. These macros are defined in the `<version>` header that was introduced in
    C++20.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__cpp_lib_xxx` 宏，用于确定库功能是否受支持。例如包括 `__cpp_lib_any`、`__cpp_lib_optional`、`__cpp_lib_constexpr_string`
    等。这些宏定义在 C++20 中引入的 `<version>` 头文件中。'
- en: The set of `__cpp_xxx` language feature macros and the `__cpp_lib_xxx` library
    feature macros are being expanded with new macros as new features are added. The
    entire list of macros is too long to be presented here but can be consulted at
    [https://en.cppreference.com/w/cpp/feature_test](https://en.cppreference.com/w/cpp/feature_test).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++ 中新功能的添加，`__cpp_xxx` 语言功能宏和 `__cpp_lib_xxx` 库功能宏正在通过新宏进行扩展。宏的完整列表太长，无法在此处展示，但可以在
    [https://en.cppreference.com/w/cpp/feature_test](https://en.cppreference.com/w/cpp/feature_test)
    查询。
- en: Apart from these macros, there are two directives, `__has_include` and `__has_cpp_attribute`,
    that can be used in `#if`/`#elif` expressions to determine whether a header or
    source file exists or whether an attribute is supported by the compiler. Together,
    all these macros and directives are useful tools in determining whether a particular
    feature is present. They enable us to write code that is portable across platforms
    and compiler versions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些宏之外，还有两个指令，`__has_include` 和 `__has_cpp_attribute`，可以在 `#if`/`#elif` 表达式中使用，以确定头文件或源文件是否存在，或者编译器是否支持某个属性。所有这些宏和指令都是确定特定功能是否存在的有用工具。它们使我们能够编写跨平台和编译器版本的代码。
- en: There’s more…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Sometimes, when performing conditional compilation, you will want to either
    display a warning or stop the compilation entirely. This is possible with the
    help of two diagnostics macros:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在执行条件编译时，你可能希望显示一个警告或完全停止编译。这可以通过两个诊断宏来实现：
- en: '`#error` displays a message to the console and stops the compilation of the
    program.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#error` 向控制台显示消息并停止程序的编译。'
- en: '`#warning`, available since C++23, displays a message to the console without
    stopping the compilation of the program.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#warning` 自 C++23 起可用，向控制台显示消息而不停止程序的编译。'
- en: 'The following snippet shows an example of using these directives:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用这些指令的示例：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Although `#warning` is only available since C++23, many compilers offer support
    for this directive as an extension.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然仅从 C++23 开始提供 `#warning`，但许多编译器提供对该指令的支持作为扩展。
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using the indirection pattern for preprocessor stringification and concatenation*,
    to learn how to transform identifiers into strings and concatenate identifiers
    together during preprocessing'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用间接模式进行预处理器字符串化和连接*，了解如何将标识符转换为字符串并在预处理期间连接标识符'
- en: Using the indirection pattern for preprocessor stringification and concatenation
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用间接模式进行预处理器字符串化和连接
- en: The C++ preprocessor provides two operators for transforming identifiers into
    strings and concatenating identifiers together. The first one, operator `#`, is
    called the **stringizing operator**, while the second one, operator `##`, is called
    the **token-pasting**, **merging**, or **concatenating operator**. Although their
    use is limited to some particular cases, it is important to understand how they
    work.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 预处理器提供了两个操作符，用于将标识符转换为字符串并将标识符连接在一起。第一个操作符，操作符 `#`，被称为 **字符串化操作符**，而第二个操作符，操作符
    `##`，被称为 **标记粘贴**、**合并**或**连接操作符**。尽管它们的使用仅限于某些特定情况，但理解它们的工作原理是很重要的。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you need to know how to define macros using the preprocessing
    directive `#define`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要知道如何使用预处理指令 `#define` 来定义宏。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a string from an identifier using the preprocessing operator `#`,
    use the following pattern:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预处理操作符 `#` 从标识符创建字符串，请使用以下模式：
- en: 'Define a helper macro taking one argument that expands to `#`, followed by
    the argument:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助宏，它接受一个参数，该参数展开为 `#`，后跟参数：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the macro you want to use, taking one argument that expands to the helper
    macro:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你想要使用的宏，它接受一个参数，该参数展开为辅助宏：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To concatenate identifiers together using the preprocessing operator `##`,
    use the following pattern:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预处理操作符 `##` 将标识符连接在一起，请使用以下模式：
- en: 'Define a helper macro with one or more arguments that use the token-pasting
    operator `##` to concatenate arguments:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助宏，它有一个或多个参数，这些参数使用标记粘贴操作符 `##` 来连接参数：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define the macro you want to use by using the helper macro:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用辅助宏定义你想要使用的宏：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To understand how these work, let’s consider the `MAKE_STR` and `MAKE_STR2`
    macros defined earlier. When used with any text, they will produce a string containing
    that text. The following example shows how both these macros can be used to define
    strings containing the text `"sample"`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这些是如何工作的，让我们考虑之前定义的 `MAKE_STR` 和 `MAKE_STR2` 宏。当与任何文本一起使用时，它们将生成包含该文本的字符串。以下示例展示了这两个宏如何被用来定义包含文本
    `"sample"` 的字符串：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On the other hand, when a macro is passed as an argument, the results are different.
    In the following example, `NUMBER` is a macro that expands to an integer, `42`.
    When used as an argument to `MAKE_STR`, it indeed produces the string `"42"`;
    however, when used as an argument to `MAKE_STR2`, it produces the string `"NUMBER"`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当宏作为参数传递时，结果会有所不同。在以下示例中，`NUMBER` 是一个展开为整数的宏，`42`。当它作为 `MAKE_STR` 的参数使用时，确实生成了字符串
    `"42"`；然而，当它作为 `MAKE_STR2` 的参数使用时，生成了字符串 `"NUMBER"`：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The C++ standard defines the following rules for argument substitution in function-like
    macros (paragraph 15.6.2 from the C++ Standard document number N4917):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准定义了以下规则，用于函数式宏中的参数替换（来自 C++ 标准文档编号 N4917 的第 15.6.2 段）：
- en: 'After the arguments for the invocation of a function-like macro have been identified,
    argument substitution takes place. A parameter in the replacement list, unless
    preceded by a # or ## preprocessing token or followed by a ## preprocessing token
    (see below), is replaced by the corresponding argument after all the macros contained
    therein have been expanded. Before being substituted, each argument’s preprocessing
    tokens are completely macro replaced as if they formed the rest of the preprocessing
    file; no other preprocessing tokens are available.'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '在识别了函数式宏调用的参数之后，就会进行参数替换。替换列表中的参数，除非它前面有一个 # 或 ## 预处理令牌，或者后面有一个 ## 预处理令牌（见下文），否则在展开其中包含的所有宏之后，会被相应的参数替换。在替换之前，每个参数的预处理令牌会被完全宏替换，就像它们构成了预处理文件的其余部分一样；没有其他预处理令牌可用。'
- en: 'What this says is that macro arguments are expanded before they are substituted
    into the macro body, except for the case when the operator `#` or `##` is preceding
    or following a parameter in the macro body. As a result, the following happens:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在将宏参数替换到宏体之前，会先展开这些参数，除了当操作符 `#` 或 `##` 位于宏体中的参数之前或之后的情况。因此，以下情况会发生：
- en: For `MAKE_STR2(NUMBER)`, the `NUMBER` parameter in the replacement list is preceded
    by `#` and, therefore, it is not expanded before substituting the argument in
    the macro body; therefore, after the substitution, we have `#NUMBER`, which becomes
    `"NUMBER"`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `MAKE_STR2(NUMBER)`，替换列表中的 `NUMBER` 参数前面有一个 `#`，因此，在将参数替换到宏体之前不会展开；因此，在替换之后，我们得到
    `#NUMBER`，它变成了 `"NUMBER"`。
- en: For `MAKE_STR(NUMBER)`, the replacement list is `MAKE_STR2(NUMBER)`, which has
    no `#` or `##`; therefore, the `NUMBER` parameter is replaced with its corresponding
    argument, `42`, before being substituted. The result is `MAKE_STR2(42)`, which
    is then scanned again, and, after expansion, it becomes `"42"`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `MAKE_STR(NUMBER)`，替换列表是 `MAKE_STR2(NUMBER)`，它没有 `#` 或 `##`；因此，`NUMBER` 参数在替换之前被替换为其相应的参数，`42`。结果是
    `MAKE_STR2(42)`，然后再次扫描，并在展开后变为 `"42"`。
- en: The same processing rules apply to macros using the token-pasting operator.
    Therefore, in order to make sure that your stringification and concatenation macros
    work for all cases, always apply the indirection pattern described in this recipe.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的处理规则适用于使用标记粘贴运算符的宏。因此，为了确保您的字符串化和连接宏适用于所有情况，始终应用本食谱中描述的间接模式。
- en: 'The token-pasting operator is typically used in macros that factor in repetitive
    code to avoid writing the same thing explicitly over and over again. The following
    simple example shows a practical use of the token-pasting operator; given a set
    of classes, we want to provide factory methods that create an instance of each
    class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 标记粘贴运算符通常用于考虑重复代码的宏中，以避免反复明确地编写相同的内容。以下简单的示例展示了标记粘贴运算符的实际应用；给定一组类，我们希望提供创建每个类实例的工厂方法：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Those familiar with the Windows platform have probably used the `_T` (or `_TEXT`)
    macro for declaring string literals that are either translated to Unicode or ANSI
    strings (both single- and multi-type character strings):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 Windows 平台的人可能已经使用过 `_T`（或 `_TEXT`）宏来声明字符串字面量，这些字符串字面量可以是转换为 Unicode 或 ANSI
    字符串（单字节和多字节字符字符串）：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Windows SDK defines the `_T` macro as follows. Note that when `_UNICODE`
    is defined, the token-pasting operator is defined to concatenate together the
    `L` prefix and the actual string being passed to the macro:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Windows SDK 定义 `_T` 宏如下。注意，当 `_UNICODE` 被定义时，标记粘贴运算符被定义为将 `L` 前缀和实际传递给宏的字符串连接起来：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At first glance, it seems unnecessary to have one macro calling another macro,
    but this level of indirection is key for making the `#` and `##` operators work
    with other macros, as we have seen in this recipe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎没有必要有一个宏调用另一个宏，但这种间接级别对于使 `#` 和 `##` 运算符与其他宏一起工作至关重要，正如我们在本食谱中看到的。
- en: See also
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Conditionally compiling your source code*, to learn how to compile only parts
    of your code, depending on various conditions'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有条件地编译源代码*，了解如何根据各种条件编译代码的某些部分'
- en: Performing compile-time assertion checks with static_assert
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `static_assert` 执行编译时断言检查
- en: In C++, it is possible to perform both runtime and compile-time assertion checks
    to ensure that specific conditions in your code are true. Runtime assertions have
    the disadvantage that they are verified late when the program is running, and
    only if the control flow reaches them. There is no alternative when the condition
    depends on runtime data; however, when that is not the case, compile-time assertion
    checks are to be preferred. With compile-time assertions, the compiler is able
    to notify you early in the development stage with an error that a particular condition
    has not been met. These, however, can only be used when the condition can be evaluated
    at compile time. In C++11, compile-time assertions are performed with `static_assert`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，可以执行运行时和编译时断言检查，以确保代码中的特定条件为真。运行时断言的缺点是它们在程序运行时较晚被验证，并且只有当控制流到达它们时才会验证。当条件依赖于运行时数据时没有替代方案；然而，当这种情况不成立时，应优先考虑编译时断言检查。使用编译时断言，编译器能够在开发早期通过错误通知您特定条件尚未满足。然而，这些只能在条件可以在编译时评估的情况下使用。在
    C++11 中，编译时断言使用 `static_assert` 执行。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The most common use of static assertion checks is with template metaprogramming,
    where they can be used for validating that preconditions on template types are
    met (examples can include whether a type is a POD type, copy-constructible, a
    reference type, and so on). Another typical example is to ensure that types (or
    objects) have an expected size.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 静态断言检查最常见的用途是与模板元编程一起使用，其中它们可以用来验证模板类型的前置条件是否得到满足（示例可以包括类型是否是 POD 类型、可复制构造、引用类型等）。另一个典型示例是确保类型（或对象）具有预期的尺寸。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use `static_assert` declarations to ensure that conditions in different scopes
    are met:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `static_assert` 声明来确保不同作用域中的条件得到满足：
- en: '**Namespace**: In this example, we validate that the size of the class `item`
    is always 16:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**：在这个例子中，我们验证类 `item` 的大小始终为 16：'
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Class**: In this example, we validate that `pod_wrapper` can only be used
    with POD types:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：在这个例子中，我们验证 `pod_wrapper` 只能用于 POD 类型：'
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Block (function)**: In this example, we validate that a function template
    has only arguments of an integral type:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块（函数）**：在这个例子中，我们验证一个函数模板只接受整型类型的参数：'
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`static_assert` is basically a declaration, but it does not introduce a new
    name. These declarations have the following form:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_assert` 实际上是一个声明，但它不会引入新的名称。这些声明具有以下形式：'
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The condition must be convertible to a Boolean value at compile time, and the
    message must be a string literal. As of C++17, the message is optional.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 条件必须在编译时可转换为布尔值，并且消息必须是一个字符串字面量。从 C++17 开始，消息是可选的。
- en: When the condition in a `static_assert` declaration evaluates to `true`, nothing
    happens. When the condition evaluates to `false`, the compiler generates an error
    that contains the specified message, if any.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `static_assert` 声明中的条件评估为 `true` 时，不会发生任何事情。当条件评估为 `false` 时，编译器生成包含指定消息（如果有）的错误。
- en: 'The message argument must be a string literal. However, that changes as of
    C++26, so that it could be an arbitrary constant expression that produces a sequence
    of characters. This helps provide better diagnostic messages for users. For instance,
    assuming there would be a `constexpr` `std::format()` function, one could write
    the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 消息参数必须是一个字符串字面量。然而，从 C++26 开始，它可以是产生字符序列的任意常量表达式。这有助于为用户提供更好的诊断信息。例如，假设会有一个
    `constexpr` `std::format()` 函数，可以编写以下内容：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Conditionally compiling classes and functions with enable_if*, to learn about
    SFINAE and how to use it to specify type constraints for templates'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 enable_if 条件编译类和函数*，了解 SFINAE 以及如何使用它来为模板指定类型约束'
- en: '*Chapter 12*, *Specifying requirements on template arguments with concepts*,
    to learn the fundamentals of C++20 concepts and how to use them to specify constraints
    for template types'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 12 章*，*使用概念指定模板参数的要求*，了解 C++20 概念的基本原理以及如何使用它们来指定模板类型的约束'
- en: '*Selecting branches at compile time with constexpr if*, to learn how to compile
    only parts of your code with *constexpr if* statements'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在编译时使用 constexpr if 选择分支*，了解如何仅使用 *constexpr if* 语句编译代码的一部分'
- en: Conditionally compiling classes and functions with enable_if
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 enable_if 条件编译类和函数
- en: Template metaprogramming is a powerful feature of C++ that enables us to write
    generic classes and functions that work with any type. This is a problem sometimes
    because the language does not define any mechanism for specifying constraints
    on the types that can be substituted for the template parameters. However, we
    can still achieve this using metaprogramming tricks and by leveraging a rule called
    **substitution failure is not an error**, also known as **SFINAE**. This rule
    determines whether the compiler discards, from the overloaded set, a specialization
    when substituting the explicitly specified or deduced type for the template parameter
    when it fails, instead of generating an error. This recipe will focus on implementing
    type constraints for templates.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元编程是 C++ 的一个强大功能，它使我们能够编写通用的类和函数，它们可以与任何类型一起工作。这有时是一个问题，因为语言没有定义任何机制来指定可以替换模板参数的类型约束。然而，我们仍然可以通过元编程技巧和利用一个称为
    **替换失败不是错误** 的规则来实现这一点，也称为 **SFINAE**。该规则确定当在替换模板参数时，如果显式指定的或推导出的类型替换失败，则编译器是否从重载集中丢弃特定化，而不是生成错误。本食谱将专注于实现模板的类型约束。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Developers have used a class template usually called `enable_if` for many years
    in conjunction with SFINAE to implement constraints on template types. The `enable_if`
    family of templates has become part of the C++11 standard and is implemented as
    follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者多年来一直使用与 SFINAE 结合的类模板 `enable_if` 来对模板类型实施约束。`enable_if` 模板系列已成为 C++11 标准的一部分，并如下实现：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To be able to use `std::enable_if`, you must include the `<type_traits>` header.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `std::enable_if`，你必须包含 `<type_traits>` 头文件。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '`std::enable_if` can be used in multiple scopes to achieve different purposes;
    consider the following examples:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::enable_if` 可以在多个作用域中使用以实现不同的目的；考虑以下示例：'
- en: 'On a class template parameter to enable a class template only for types that
    meet a specified condition:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类模板参数上启用类模板，仅对满足指定条件的类型：
- en: '[PRE26]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On a function template parameter, function parameter, or function return type
    to enable a function template only for types that meet a specified condition:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数模板参数、函数参数或函数返回类型上启用函数模板，仅对满足指定条件的类型：
- en: '[PRE27]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To simplify the cluttered code that we end up writing when we use `std::enable_if`,
    we can leverage alias templates and define two aliases, called `EnableIf` and
    `DisableIf`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们使用`std::enable_if`时最终编写的杂乱代码，我们可以利用别名模板并定义两个别名，分别称为`EnableIf`和`DisableIf`：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Based on these alias templates, the following definitions are equivalent to
    the preceding ones:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些别名模板，以下定义与前面的定义等效：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::enable_if` works because the compiler applies the SFINAE rule when performing
    overload resolution. Before we can explain how `std::enable_if` works, we should
    have a quick look at what SFINAE is.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::enable_if`之所以有效，是因为编译器在执行重载解析时应用了SFINAE规则。在我们能够解释`std::enable_if`是如何工作的之前，我们应该快速了解一下SFINAE是什么。'
- en: When the compiler encounters a function call, it needs to build a set of possible
    overloads and select the best match for the call based on the arguments for the
    function call. When building this overload set, the compiler evaluates function
    templates too, and has to perform a substitution for the specified or deduced
    types in the template arguments. According to SFINAE, when the substitution fails,
    instead of yielding an error, the compiler should just remove the function template
    from the overload set and continue.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到函数调用时，它需要构建一组可能的重载并基于函数调用的参数选择最佳匹配。在构建这个重载集时，编译器也会评估函数模板，并必须对模板参数中指定的或推导出的类型进行替换。根据SFINAE（Substitution
    Failure Is Not An Error），当替换失败时，编译器不应产生错误，而应仅从重载集中移除函数模板并继续。
- en: The standard specifies a list of type and expression errors that are also SFINAE
    errors. These include an attempt to create an array of `void` or an array of size
    zero, an attempt to create a reference to `void`, an attempt to create a function
    type with a parameter of type `void`, and an attempt to perform an invalid conversion
    in a template argument expression or in an expression used in a function declaration.
    For the complete list of exceptions, consult the C++ standard or other resources.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 标准指定了一个类型和表达式错误列表，这些也是SFINAE错误。这包括尝试创建`void`数组或大小为零的数组，尝试创建对`void`的引用，尝试创建具有`void`类型参数的函数类型，以及尝试在模板参数表达式中或在函数声明中使用的表达式中执行无效转换。有关异常的完整列表，请参阅C++标准或其他资源。
- en: 'Let’s consider the following two overloads of a function called `func()`. The
    first overload is a function template that has a single argument of type `T::value_type`;
    this means it can only be instantiated with types that have an inner type called
    `value_type`. The second overload is a function that has a single argument of
    type `int`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个名为`func()`的函数的两个重载。第一个重载是一个只有一个`T::value_type`类型参数的函数模板；这意味着它只能用具有名为`value_type`的内部类型的类型实例化。第二个重载是一个只有一个`int`类型参数的函数：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If the compiler encounters a call such as `func(42)`, then it must find an overload
    that can take an `int` argument. When it builds the overload set and substitutes
    the template parameter with the provided template argument, the result, `void
    func(int::value_type const)`, is invalid, because `int` does not have a `value_type`
    member. Due to SFINAE, the compiler will not emit an error and stop but will simply
    ignore the overload and continue. It then finds `void func(int const)`, and that
    will be the best (and only) match that it will call.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器遇到`func(42)`这样的调用，它必须找到一个可以接受`int`参数的重载。当它构建重载集并用提供的模板参数替换模板参数时，结果`void
    func(int::value_type const)`是无效的，因为`int`没有`value_type`成员。由于SFINAE，编译器不会发出错误并停止，而只是忽略该重载并继续。然后它找到`void
    func(int const)`，这将是最合适（也是唯一）的匹配，它将调用。
- en: If the compiler encounters a call such as `func<some_type<int>>(42)`, then it
    builds an overload set containing `void func(some_type<int>::value_type const>`
    and `void func(int const)`, and the best match, in this case, is the first overload;
    no SFINAE is involved this time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器遇到`func<some_type<int>>(42)`这样的调用，它将构建一个包含`void func(some_type<int>::value_type
    const)`和`void func(int const)`的重载集，在这种情况下，最佳匹配是第一个重载；这次没有涉及SFINAE。
- en: On the other hand, if the compiler encounters a call such as `func("string"s)`,
    then it again relies on SFINAE to ignore the function template, because `std::basic_string`
    does not have a `value_type` member either. This time, however, the overload set
    does not contain any match for the string argument; therefore, the program is
    ill-formed and the compiler emits an error and stops.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果编译器遇到 `func("string"s)` 这样的调用，它再次依赖于 SFINAE 来忽略函数模板，因为 `std::basic_string`
    也没有 `value_type` 成员。然而，这次重载集合中不包含任何与字符串参数匹配的项；因此，程序是无效的，编译器发出错误并停止。
- en: The `enable_if<bool, T>` class template does not have any members, but its partial
    specialization, `enable_if<true, T` `>`, does have an inner type called `type`,
    which is a synonym for `T`. When the compile-time expression supplied as the first
    argument to `enable_if` evaluates to `true`, the inner member `type` is available;
    otherwise, it is not.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`enable_if<bool, T>` 类模板没有任何成员，但它的部分特化 `enable_if<true, T>` 有一个内部类型称为 `type`，它是
    `T` 的同义词。当将 `enable_if` 的第一个参数作为编译时表达式评估为 `true` 时，内部成员 `type` 是可用的；否则，它不可用。'
- en: Considering the last definition of the `mul()` function from the *How to do
    it...* section, when the compiler encounters a call such as `mul(1, 2)`, it tries
    to substitute `int` for the template parameter, `T`; since `int` is an integral
    type, `std::is_integral<T>` evaluates to `true` and, therefore, a specialization
    of `enable_if` that defines an inner type called `type` is instantiated. As a
    result, the alias template `EnableIf` becomes a synonym for this type, which is
    `void` (from the expression `typename T = void`). The result is a function template,
    `int mul<int, void>(int a, int b)`, that can be called with the supplied arguments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 *如何做到...* 部分的 `mul()` 函数的最后定义，当编译器遇到 `mul(1, 2)` 这样的调用时，它试图用 `int` 替换模板参数
    `T`；由于 `int` 是一个整型，`std::is_integral<T>` 评估为 `true`，因此，定义了一个内部类型 `type` 的 `enable_if`
    特化被实例化。结果，别名模板 `EnableIf` 成为此类型的同义词，即 `void`（来自表达式 `typename T = void`）。结果是，可以带有提供的参数调用的函数模板
    `int mul<int, void>(int a, int b)`。
- en: On the other hand, when the compiler encounters a call such as `mul(1.0, 2.0)`,
    it tries to substitute `double` for the template parameter, `T`. However, this
    is not an integral type; as a result, the condition in `std::enable_if` evaluates
    to `false` and the class template does not define an inner member `type`. This
    results in a substitution error, but according to SFINAE, the compiler will not
    emit an error but move on. However, since no other overload is found, there will
    be no `mul()` function that can be called. Therefore, the program is considered
    ill-formed and the compiler stops with an error.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当编译器遇到 `mul(1.0, 2.0)` 这样的调用时，它试图用 `double` 替换模板参数 `T`。然而，这并不是一个整型；因此，`std::enable_if`
    中的条件评估为 `false`，类模板没有定义内部成员 `type`。这导致替换错误，但根据 SFINAE，编译器不会发出错误，而是继续进行。然而，由于没有找到其他重载，将没有可以调用的
    `mul()` 函数。因此，程序被认为是无效的，编译器停止并报错。
- en: 'A similar situation is encountered with the class template `pod_wrapper`. It
    has two template type parameters: the first is the actual POD type that is being
    wrapped, while the second is the result of the substitution of `enable_if` and
    `is_standard_layout`. If the type is a POD type (as in `pod_wrapper<int>`), then
    the inner member `type` from `enable_if` exists and it substitutes the second
    template type parameter. However, if the inner member `type` is not a POD type
    (as in `pod_wrapper<std::string>`), then the inner member `type` is not defined,
    and the substitution fails, producing an error such as *too few template arguments*.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `pod_wrapper` 遇到类似的情况。它有两个模板类型参数：第一个是被包装的实际 POD 类型，而第二个是 `enable_if` 和 `is_standard_layout`
    替换的结果。如果类型是 POD 类型（如 `pod_wrapper<int>`），则 `enable_if` 的内部成员 `type` 存在，并替换第二个模板类型参数。然而，如果内部成员
    `type` 不是一个 POD 类型（如 `pod_wrapper<std::string>`），则内部成员 `type` 未定义，替换失败，产生如 *模板参数太少*
    这样的错误。
- en: There’s more...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`static_assert` and `std::enable_if` can be used to achieve the same goals.
    In fact, in the previous recipe, *Performing compile-time assertion checks with
    static_assert*, we defined the same class template, `pod_wrapper`, and function
    template, `mul()`. For these examples, `static_assert` seems like a better solution
    because the compiler emits better error messages (provided that you specify relevant
    messages in the `static_assert` declaration). These two, however, work quite differently
    and are not intended as alternatives.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_assert` 和 `std::enable_if` 可以用来实现相同的目标。实际上，在前面的配方中，*使用 `static_assert`
    进行编译时断言检查*，我们定义了相同的类模板 `pod_wrapper` 和函数模板 `mul()`。对于这些示例，`static_assert` 似乎是一个更好的解决方案，因为编译器会发出更好的错误信息（前提是在
    `static_assert` 声明中指定了相关的消息）。然而，这两个函数的工作方式相当不同，并不打算作为替代品。'
- en: '`static_assert` does not rely on SFINAE and is applied after overload resolution
    is performed. The result of a failed assert is a compiler error. On the other
    hand, `std::enable_if` is used to remove candidates from the overload set and
    does not trigger compiler errors (given that the exceptions the standard specifies
    for SFINAE do not occur). The actual error that can occur after SFINAE is an empty
    overload set that makes a program ill-formed. This is because a particular function
    call cannot be performed.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_assert` 不依赖于 SFINAE，并且在重载解析完成后应用。失败的断言会导致编译器错误。另一方面，`std::enable_if`
    用于从重载集中移除候选者，并且不会触发编译器错误（假设标准中指定的 SFINAE 异常没有发生）。SFINAE 后可能发生的实际错误是一个空的重载集，这会使程序无效。这是因为特定的函数调用无法执行。'
- en: 'To understand the difference between `static_assert` and `std::enable_if` with
    SFINAE, let’s consider a case where we want to have two function overloads: one
    that should be called for arguments of integral types and one for arguments of
    any type other than integral types. With `static_assert`, we can write the following
    (note that the dummy second type parameter on the second overload is necessary
    to define two different overloads; otherwise, we would just have two definitions
    of the same function):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `static_assert` 和 `std::enable_if` 与 SFINAE 之间的区别，让我们考虑一个我们想要有两个函数重载的情况：一个用于整型类型的参数，另一个用于除整型类型之外的所有类型的参数。使用
    `static_assert`，我们可以编写以下内容（注意，第二个重载上的虚拟第二个类型参数是必要的，以便定义两个不同的重载；否则，我们只会有两个相同函数的定义）：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Regardless of how we try to call this function, we end up with an error, because
    the compiler finds two overloads that it could potentially call. This is because
    `static_assert` is only considered after the overload resolution has been resolved,
    which, in this case, builds a set of two possible candidates.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何尝试调用此函数，最终都会出错，因为编译器找到了两个可能调用的重载。这是因为 `static_assert` 仅在重载解析完成后才被考虑，在这种情况下，构建了一个包含两个可能候选者的集合。
- en: 'The solution to this problem is `std::enable_if` and SFINAE. We use `std::enable_if`
    via the alias templates `EnableIf` and `DisableIf` defined previously on a template
    parameter (although we still use the dummy template parameter on the second overload
    to introduce two different definitions). The following example shows the two overloads
    rewritten. The first overload is enabled only for integral types, while the second
    is disabled for integral types:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是 `std::enable_if` 和 SFINAE。我们通过之前定义的别名模板 `EnableIf` 和 `DisableIf`
    在模板参数上使用 `std::enable_if`（尽管我们仍然在第二个重载上使用虚拟模板参数以引入两个不同的定义）。以下示例显示了重载的重新编写。第一个重载仅对整型类型启用，而第二个对整型类型禁用：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With SFINAE at work, when the compiler builds the overload set for either `compute(1,
    2)` or `compute(1.0, 2.0);`, it will simply discard the overload that produces
    a substitution failure and move on, where in each case we’ll end up with an overload
    set containing a single candidate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SFINAE 作用下，当编译器为 `compute(1, 2)` 或 `compute(1.0, 2.0)` 构建重载集时，它将简单地丢弃产生替换失败的过载，并继续进行，在每种情况下，我们最终都会得到一个只包含单个候选者的重载集。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Performing compile-time assertion checks with static_assert*, to learn how
    to define assertions that are verified at compile time'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `static_assert` 进行编译时断言检查*，了解如何定义在编译时验证的断言'
- en: '*Chapter 1*, *Creating type aliases and alias templates*, to learn about aliases
    for types'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*创建类型别名和别名模板*，了解类型别名'
- en: Selecting branches at compile time with constexpr if
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `constexpr if` 在编译时选择分支
- en: In the previous recipes, we saw how we can impose restrictions on types and
    functions using `static_assert` and `std::enable_if` and how these two are different.
    Template metaprogramming can become complicated and cluttered when we use SFINAE
    and `std::enable_if` to define function overloads or when we write variadic function
    templates. A new feature of C++17 is intended to simplify such code; it is called
    *constexpr if*, and it defines an `if` statement with a condition that is evaluated
    at compile time, resulting in the compiler selecting the body of a branch or another
    in the translation unit. Typical usage of *constexpr if* is for simplification
    of variadic templates and `std::enable_if`-based code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们看到了如何使用 `static_assert` 和 `std::enable_if` 对类型和函数施加限制，以及这两个是如何不同的。当我们使用
    SFINAE 和 `std::enable_if` 来定义函数重载或编写变长模板函数时，模板元编程可能会变得复杂和杂乱。C++17 的一个新特性旨在简化此类代码；它被称为
    *constexpr if*，它定义了一个在编译时评估条件的 `if` 语句，从而使得编译器选择翻译单元中某个分支或另一个分支的主体。*constexpr
    if* 的典型用法是简化变长模板和基于 `std::enable_if` 的代码。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will refer to and simplify the code written in two previous
    recipes. Before continuing with this recipe, you should take a moment to go back
    and review the code we have written in the previous recipes, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将参考并简化在前两个菜谱中编写的代码。在继续这个菜谱之前，你应该花点时间回顾一下我们在之前的菜谱中编写的代码，如下所示：
- en: The `compute()` overloads for integral and non-integral types from the *Conditionally
    compiling classes and functions with enable_if* recipe.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 *使用 enable_if 条件编译类和函数* 菜谱的整型和非整型的 `compute()` 重载。
- en: User-defined 8-bit, 16-bit, and 32-bit binary literals from the *Creating raw
    user-defined literals* recipe of *Chapter 2*, *Working with Numbers and Strings*.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 *第2章*，*处理数字和字符串* 的 *创建原始用户定义字面量* 菜谱的用户定义的 8 位、16 位和 32 位二进制字面量。
- en: 'These implementations have several issues:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现有几个问题：
- en: They are hard to read. There is a lot of focus on the template declaration,
    yet the body of the functions is very simple, for instance. The biggest problem,
    though, is that it requires greater attention from developers because it is cluttered
    with complicated declarations, such as `typename = std::enable_if<std::is_integral<T>::value,
    T>::type`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们很难阅读。有很多关注模板声明，而函数的主体却非常简单，例如。然而，最大的问题是它需要开发者更加注意，因为它充满了复杂的声明，如 `typename
    = std::enable_if<std::is_integral<T>::value, T>::type`。
- en: There is too much code. The end purpose of the first example is to have a generic
    function that behaves differently for different types, yet we had to write two
    overloads for the function; moreover, to differentiate the two, we had to use
    an extra, unused, template parameter. In the second example, the purpose was to
    build an integer value out of characters `'0'` and `'1'`, yet we had to write
    one class template and three specializations to make it happen.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码太多。第一个示例的最终目的是拥有一个对不同的类型表现不同的泛型函数，但我们不得不为该函数编写两个重载；此外，为了区分这两个重载，我们不得不使用一个额外的、未使用的模板参数。在第二个示例中，目的是从字符
    `'0'` 和 `'1'` 构建一个整数值，但我们不得不编写一个类模板和三个特化来实现这一点。
- en: It requires advanced template metaprogramming skills, which shouldn’t be necessary
    for doing something this simple.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要高级模板元编程技能，而这对于做这样简单的事情是不必要的。
- en: 'The syntax for *constexpr if* is very similar to regular `if` statements and
    requires the `constexpr` keyword before the condition. The general form is as
    follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*constexpr if* 的语法与常规 `if` 语句非常相似，需要在条件之前使用 `constexpr` 关键字。一般形式如下：'
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that in this form, the `init-statement` is optional.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个形式中，`init-statement` 是可选的。
- en: In the following section, we’ll explore several use cases for conditional compilation
    with *constexpr if*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将探讨使用 *constexpr if* 进行条件编译的几个用例。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use *constexpr if* statements to do the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *constexpr if* 语句来完成以下操作：
- en: 'To avoid using `std::enable_if` and relying on SFINAE to impose restrictions
    on function template types and conditionally compile code:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免使用 `std::enable_if` 并依赖于 SFINAE 对函数模板类型施加限制以及条件编译代码：
- en: '[PRE34]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To simplify writing variadic templates and implement metaprogramming compile-time
    recursion:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化编写变长模板并实现元编程编译时递归：
- en: '[PRE35]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The way *constexpr if* works is relatively simple: the condition in the `if`
    statement must be a compile-time expression that evaluates or is convertible to
    a Boolean. If the condition is `true`, the body of the `if` statement is selected,
    which means it ends up in the translation unit for compilation. If the condition
    is `false`, the `else` branch, if one is defined, is evaluated. Return statements
    in discarded *constexpr if* branches do not contribute to the function return
    type deduction.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr if` 的工作方式相对简单：`if` 语句中的条件必须是一个编译时表达式，该表达式可以评估或转换为布尔值。如果条件为 `true`，则选择
    `if` 语句的主体，这意味着它最终会进入编译单元进行编译。如果条件为 `false`，则评估（如果已定义）`else` 分支。丢弃的 `constexpr
    if` 分支中的返回语句不会对函数返回类型推导做出贡献。'
- en: 'In the first example from the *How to do it...* section, the `value_of()` function
    template has a clean signature. The body is also very simple; if the type that
    is substituted for the template parameter is a pointer type, the compiler will
    select the first branch (that is, `return *value;`) for code generation and discard
    the `else` branch. For non-pointer types, because the condition evaluates to `false`,
    the compiler will select the `else` branch (that is, `return value;`) for code
    generation and discard the rest. This function can be used as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *How to do it...* 部分的第一个示例中，`value_of()` 函数模板有一个干净的签名。其主体也非常简单；如果用于模板参数的类型是指针类型，编译器将选择第一个分支（即
    `return *value;`）进行代码生成并丢弃 `else` 分支。对于非指针类型，因为条件评估为 `false`，编译器将选择 `else` 分支（即
    `return value;`）进行代码生成并丢弃其余部分。此函数可以使用如下方式：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, without the help of *constexpr if*, we could only implement this using
    `std::enable_if`. The following implementation is a more cluttered alternative:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有 `constexpr if` 的帮助，我们只能使用 `std::enable_if` 来实现这一点。以下是一个更杂乱的替代实现：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, the *constexpr if* variant is not only shorter but more expressive
    and easier to read and understand.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`constexpr if` 变体不仅更短，而且更具表达性，更容易阅读和理解。
- en: In the second example from the *How to do it...* section, the internal `binary_eval()`
    helper function is a variadic template function without any parameters; it only
    has template parameters. The function evaluates the first argument and then does
    something with the rest of the arguments in a recursive manner (but remember this
    is not a runtime recursion). When there is a single character left and the size
    of the remaining pack is `0`, we return the decimal value represented by the character
    (`0` for `'0'` and `1` for `'``1'`). If the current first element is a `'0'`,
    we return the value determined by evaluating the rest of the arguments pack, which
    involves a recursive call. If the current first element is a `'1'`, we return
    the value by shifting a `1` to the left a number of positions given by the size
    of the remaining pack bit or the value determined. We do this by evaluating the
    rest of the arguments pack, which again involves a recursive call.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *How to do it...* 部分的第二个示例中，内部的 `binary_eval()` 辅助函数是一个没有任何参数的变长模板函数；它只有模板参数。该函数评估第一个参数，然后以递归方式处理剩余的参数（但请记住，这并不是运行时递归）。当只剩下一个字符并且剩余的包的大小为
    `0` 时，我们返回由字符表示的十进制值（`'0'` 为 `0`，`'1'` 为 `1`）。如果当前第一个元素是 `'0'`，我们通过评估剩余的参数包来确定值，这涉及到递归调用。如果当前第一个元素是
    `'1'`，我们通过将 `1` 左移由剩余包的大小或确定的值指定的位数来返回值。我们通过评估剩余的参数包来完成这项工作，这又涉及到递归调用。
- en: See also
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Conditionally compiling classes and functions with enable_if*, to learn about
    SFINAE and how to use it to specify type constraints for templates'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `enable_if` 条件编译类和函数，了解 SFINAE 以及如何使用它来为模板指定类型约束
- en: Providing metadata to the compiler with attributes
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性向编译器提供元数据
- en: C++ has been very deficient when it comes to features that enable reflection
    or introspection on types of data or standard mechanisms to define language extensions.
    Because of that, compilers have defined their own specific extensions for this
    purpose. Examples include the VC++ `__declspec()` specifier and the GCC `__attribute__((...))`.
    C++11, however, introduced the concept of attributes, which enable compilers to
    implement extensions in a standard way or even embedded domain-specific languages.
    The newer C++ standards define several attributes all compilers should implement,
    and that will be the topic of this recipe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: C++在提供数据类型反射或内省功能以及定义语言扩展的标准机制方面一直存在很大缺陷。正因为如此，编译器为这个目的定义了自己的特定扩展。例如，VC++的`__declspec()`指定符和GCC的`__attribute__((...))`。然而，C++11引入了属性的概念，这使得编译器能够以标准方式或甚至嵌入特定领域的语言来实现扩展。新的C++标准定义了所有编译器都应该实现的几个属性，这将是本菜谱的主题。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use standard attributes to provide hints for the compiler about various design
    goals such as in the scenarios listed here, but not only these:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准属性为编译器提供有关各种设计目标的提示，例如在以下场景中，但不仅限于此：
- en: 'To ensure that the return value from a function cannot be ignored, declare
    the function with the `[[nodiscard]]` attribute. In C++20, you can specify a string
    literal, of the form `[[nodiscard(text)]]`, to explain why the result should not
    be discarded:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保函数的返回值不能被忽略，使用`[[nodiscard]]`属性声明函数。在C++20中，你可以指定一个字符串字面量，形式为`[[nodiscard(text)]]`，来解释为什么结果不应该被丢弃：
- en: '[PRE38]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, you can declare enumerations and classes used as the return
    type of a function with the `[[nodiscard]]` attribute; in this case, the return
    value of any function returning such a type cannot be ignored:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以使用`[[nodiscard]]`属性声明用作函数返回类型的枚举和类；在这种情况下，任何返回此类类型的函数的返回值都不能被忽略：
- en: '[PRE39]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To ensure that the usage of functions or types that are considered deprecated
    is flagged by the compiler with a warning, declare them with the `[[deprecated]]`
    attribute:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保被认为已过时的函数或类型的用法被编译器标记为警告，使用`[[deprecated]]`属性声明它们：
- en: '[PRE40]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To ensure that the compiler does not emit a warning for unused variables, use
    the `[[maybe_unused]]` attribute:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保编译器不对未使用的变量发出警告，使用`[[maybe_unused]]`属性：
- en: '[PRE41]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To ensure that intentional fall-through case labels in a `switch` statement
    are not flagged by the compiler with a warning, use the `[[fallthrough]]` attribute:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保`switch`语句中的有意跳过的情况标签不会被编译器标记为警告，使用`[[fallthrough]]`属性：
- en: '[PRE42]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To help the compiler optimize paths of execution that are more or less likely
    to execute, use the C++20 `[[likely]]` and `[[unlikely]]` attributes:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助编译器优化执行路径，使用C++20的`[[likely]]`和`[[unlikely]]`属性：
- en: '[PRE43]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To help the compiler optimize code based on the user-given assumptions, use
    the C++23 `[[assume]]` attribute:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助编译器根据用户提供的假设优化代码，使用C++23的`[[assume]]`属性：
- en: '[PRE44]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Attributes are a very flexible feature of C++; they can be used almost everywhere,
    but the actual usage is specifically defined for each particular attribute. They
    can be used on types, functions, variables, names, code blocks, or entire translation
    units.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是C++的一个非常灵活的特性；它们几乎可以在任何地方使用，但实际使用是针对每个特定属性具体定义的。它们可以用在类型、函数、变量、名称、代码块或整个翻译单元上。
- en: Attributes are specified between double square brackets (for example, `[[attr1]]`),
    and more than one attribute can be specified in a declaration (for example, `[[attr1,
    attr2, attr3]]`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指定在双方括号之间（例如，`[[attr1]]`），并且在声明中可以指定多个属性（例如，`[[attr1, attr2, attr3]]`）。
- en: 'Attributes can have arguments, for example, `[[mode(greedy)]]`, and can be
    fully qualified, for example, `[[sys::hidden]]` or `[[using sys: visibility(hidden),
    debug]]`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '属性可以有参数，例如`[[mode(greedy)]]`，并且可以是完全限定的，例如`[[sys::hidden]]`或`[[using sys: visibility(hidden),
    debug]]`。'
- en: 'Attributes can appear either before or after the name of the entity on which
    they are applied, or both, in which case they are combined. The following are
    several examples that exemplify this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以出现在它们所应用的实体名称之前或之后，或者两者都出现，在这种情况下它们会被组合。以下是一些示例，说明了这一点：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Attributes cannot appear in a namespace declaration, but they can appear as
    a single-line declaration anywhere in a namespace. In this case, it is specific
    to each attribute whether it applies to the following declaration, to the namespace,
    or to the translation unit:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 属性不能出现在命名空间声明中，但可以作为单行声明出现在命名空间中的任何位置。在这种情况下，是否应用于后续声明、命名空间或翻译单元取决于每个属性：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The standard does define several attributes all compilers must implement, and
    using them can help you write better code. We have seen some of them in the examples
    given in the previous section. These attributes have been defined in different
    versions of the standard:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 标准确实定义了所有编译器都必须实现的几个属性，使用它们可以帮助你编写更好的代码。我们在上一节给出的示例中看到了一些。这些属性已在标准的不同版本中定义：
- en: 'In C++11:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++11 中：
- en: The `[[noreturn]]` attribute indicates that a function does not return.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[noreturn]]` 属性表示函数不会返回。'
- en: The `[[carries_dependency]]` attribute indicates that the dependency chain in
    release-consume `std::memory_order` propagates in and out of the function, which
    allows the compiler to skip unnecessary memory fence instructions.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[carries_dependency]]` 属性表示在发布-消费 `std::memory_order` 中的依赖链在函数中传播进出，这允许编译器跳过不必要的内存栅栏指令。'
- en: 'In C++14:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++14 中：
- en: The `[[deprecated]]` and `[[deprecated("reason")]]` attributes indicate that
    the entity declared with these attributes is considered deprecated and should
    not be used. These attributes can be used with classes, non-static data members,
    typedefs, functions, enumerations, and template specializations. The `"reason"`
    string is an optional parameter.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[deprecated]]` 和 `[[deprecated("reason")]]` 属性表示使用这些属性声明的实体被认为是过时的，不应使用。这些属性可以与类、非静态数据成员、typedefs、函数、枚举和模板特化一起使用。`"reason"`
    字符串是一个可选参数。'
- en: 'In C++17:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++17 中：
- en: The `[[fallthrough]]` attribute indicates that the fall-through between labels
    in a `switch` statement is intentional. The attribute must appear on a line of
    its own immediately before a `case` label.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[fallthrough]]` 属性表示在 `switch` 语句中的标签之间的穿透是故意的。该属性必须单独一行，紧接在 `case` 标签之前。'
- en: The `[[nodiscard]]` attribute indicates that a return value from a function
    cannot be ignored.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[nodiscard]]` 属性表示函数的返回值不能被忽略。'
- en: The `[[maybe_unused]]` attribute indicates that an entity may be unused, but
    the compiler should not emit a warning about that. This attribute can be applied
    to variables, classes, non-static data members, enumerations, enumerators, and
    typedefs.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[maybe_unused]]` 属性表示实体可能未使用，但编译器不应发出有关该问题的警告。此属性可以应用于变量、类、非静态数据成员、枚举、枚举符和
    typedefs。'
- en: 'In C++20:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++20 中：
- en: The `[[nodiscard(text)]]` attribute is an extension of the C++17 `[[nodiscard]]`
    attribute and provides text that describes the reason a result should not be discarded.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[nodiscard(text)]]` 属性是 C++17 的 `[[nodiscard]]` 属性的扩展，并提供描述结果不应被丢弃原因的文本。'
- en: The `[[likely]]` and `[[unlikely]]` attributes provide hints for the compiler
    that a path of execution is more or less likely to execute, therefore allowing
    it to optimize accordingly. They can be applied to statements (but not declarations)
    and labels, but only one of them, as they are mutually exclusive.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[likely]]` 和 `[[unlikely]]` 属性为编译器提供提示，表明执行路径更有可能或不太可能执行，因此允许它相应地进行优化。它们可以应用于语句（但不能是声明）和标签，但只能使用其中一个，因为它们是互斥的。'
- en: The `[[no_unique_address]]` attribute can be applied to non-static data members,
    excluding bitfields, and tells the compiler that the member does not have to have
    a unique address. When applied to a member that has an empty type, the compiler
    can optimize it to occupy no space, as in the case of it being an empty base.
    On the other hand, if the member’s type is not empty, the compiler may reuse any
    ensuing padding to store other data members.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[no_unique_address]]` 属性可以应用于非静态数据成员（排除位域），并告知编译器该成员不必具有唯一的地址。当应用于具有空类型的成员时，编译器可以将其优化为不占用空间，例如，当它是一个空基类时。另一方面，如果成员的类型不为空，编译器可能会重用任何后续的填充来存储其他数据成员。'
- en: 'In C++23:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++23 中：
- en: '`[[assume(expr)]]` indicates that an expression will always evaluate to `true`.
    Its purpose is to enable the compiler to perform code optimizations and not to
    document the preconditions of a function. However, the expression is never evaluated.
    An expression that has undefined behavior or throws an exception is evaluated
    to `false`. An assumption that does not hold causes undefined behavior; therefore,
    assumptions should be used judiciously. On the other hand, compilers may not use
    an assumption at all.'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[assume(expr)]]` 表示一个表达式将始终评估为 `true`。它的目的是让编译器执行代码优化，而不是记录函数的先决条件。然而，表达式永远不会被评估。具有未定义行为或抛出异常的表达式将被评估为
    `false`。不成立的假设会导致未定义行为；因此，假设应该谨慎使用。另一方面，编译器可能根本不会使用假设。'
- en: Attributes are often ignored or briefly mentioned in books and tutorials on
    modern C++ programming, and the reason for that is probably the fact that developers
    cannot actually write attributes, as this language feature is intended for compiler
    implementations. For some compilers, though, it may be possible to define user-provided
    attributes; one such compiler is GCC, which supports plugins that add extra features
    to the compiler, and they can be used for defining new attributes too.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 C++ 编程的书籍和教程中，属性通常被忽略或简略提及，这其中的原因可能是因为开发者实际上无法编写属性，因为这个语言特性是为编译器实现而设计的。然而，对于某些编译器来说，可能可以定义用户提供的属性；GCC
    就是这样一种编译器，它支持插件，这些插件可以为编译器添加额外功能，也可以用来定义新的属性。
- en: See also
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 9*, *Using noexcept for functions that do not throw*, to learn how
    to inform the compiler that a function should not throw exceptions'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 9 章*，*使用 noexcept 处理不抛出异常的函数*，了解如何通知编译器一个函数不应该抛出异常'
- en: Learn more on Discord
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_04.xhtml)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_04.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
