- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preprocessing and Compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, compilation is the process by which source code is transformed into
    machine code and organized into object files that are then linked together to
    produce an executable. The compiler actually works on a single file (called a
    translation unit) at a time, produced by the preprocessor (the part of the compiler
    that handles preprocessing directives) from a single source file and all the header
    files that it includes. This is, however, an oversimplification of what happens
    when we compile the code. This chapter addresses topics related to preprocessing
    and compilation, with a focus on various methods to perform conditional compilation,
    but also touches on other modern topics such as using attributes to provide implementation-defined
    language extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes included in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally compiling your source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the indirection pattern for preprocessor stringification and concatenation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing compile-time assertion checks with `static_assert`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionally compiling classes and functions with `enable_if`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting branches at compile time with *constexpr if*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing metadata to the compiler with attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipe that we will start this chapter with addresses a very common problem
    faced by developers, which is compiling only parts of a code base depending on
    various conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally compiling your source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditional compilation is a simple mechanism that enables developers to maintain
    a single code base, but only consider some parts of the code for compilation to
    produce different executables, usually in order to run on different platforms
    or hardware, or depend on different libraries or library versions. Common examples
    include using or ignoring code based on the compiler, platform (x86, x64, ARM,
    and so on), configuration (debug or release), or any user-defined specific conditions.
    In this recipe, we’ll take a look at how conditional compilation works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conditional compilation is a technique used extensively for many purposes.
    In this recipe, we will look at several examples and explain how they work. This
    technique is not in any way limited to these examples. For the scope of this recipe,
    we will only consider the three major compilers: GCC, Clang, and VC++.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To conditionally compile portions of code, use the `#if`, `#ifdef`, and `#ifndef`
    directives (with the `#elif`, `#else`, and `#endif` directives). The general form
    for conditional compilation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the conditions here usually imply checking whether a macro is defined
    or not using the `defined identifier` or `defined (identifier)` syntax, it’s also
    possible to use the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `#elifdef` and `#elifndef` directives were introduced in C++23.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define macros for conditional compilation, you can use either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `#define` directive in your source code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compiler command-line options that are specific to each compiler. Examples
    for the most widely used compilers are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Visual C++, use `/Dname` or `/Dname=value` (where `/Dname` is equivalent
    to `/Dname=1`), for example, `cl /DVERBOSITY_LEVEL=5`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For GCC and Clang, use `-D name` or `-D name=value` (where `-D name` is equivalent
    to `-D name=1`), for example, `gcc -D VERBOSITY_LEVEL=5`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are typical examples of conditional compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Header guards to avoid duplicate definitions (due to multiple inclusions of
    the same header in the same translation unit):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compiler-specific code for cross-platform applications. The following is an
    example of printing a message to the console with the name of the compiler:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Target-specific code for multiple architectures, for example, for conditionally
    compiling code for multiple compilers and architectures:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configuration-specific code, for example, for conditionally compiling code
    for debug and release builds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether a language or library feature is available, use the predefined
    macros `__cpp_xxx` for language features (such as `__cpp_constexpr`, `__cpp_constinit`,
    or `__cpp_modules`) and `__cpp_lib_xxx` for library features (such as `__cpp_lib_concepts`,
    `__cpp_lib_expected`, or `__cpp_lib_jthread`). The library feature macros were
    introduced in C++20 and are available in the `<version>` header:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether a header or source file is available for inclusion, use the
    `__has_include` directive, which is available in C++17\. The following example
    checks whether the `<optional>` header exists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether an attribute is supported (as well as from what version),
    use the `__has_cpp_attribute` directive, which is available in C++20:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before discussing compilation, we should first clarify a term that we will
    encounter often: **translation unit**. In C++, this is the basic unit of compilation.
    It is the result of putting together the content of a source file (a `.cpp` file)
    and the entire graph of all the header files included directly or indirectly but
    without the text excluded with conditional preprocessing statements, as described
    in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use the preprocessing directives `#if`, `#ifndef`, `#ifdef`, `#elif`,
    `#else`, and `#endif`, the compiler will select, at most, one branch whose body
    will be included in the translation unit for compilation. The body of these directives
    can be any text, including other preprocessing directives. The following rules
    apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#if`, `#ifdef`, and `#ifndef` must be matched by an `#endif`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `#if` directive may have multiple `#elif` directives, but only one `#else`,
    which must also be the last one before `#endif`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#if`, `#ifdef`, `#ifndef`, `#elif`, `#else`, and `#endif` can be nested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `#if` directive requires a constant expression, whereas `#ifdef` and `#ifndef`
    require an identifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `defined` operator can be used for preprocessor constant expressions, but
    only in `#if` and `#elif` directives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defined(identifier)` is considered `true` if `identifier` is defined; otherwise,
    it is considered `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An identifier defined as an empty text is considered defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#ifdef identifier` is equivalent to `#if defined(identifier)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#ifndef identifier` is equivalent to `#if !defined(identifier)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defined(identifier)` and `defined identifier` are equivalent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header guards are one of the most common forms of conditional compilation. This
    technique is used to prevent the content of a header file from being included
    several times in the same translation unit (although the header is still scanned
    every time in order to detect what should be included). Therefore, the code in
    headers is guarded against multiple inclusions in the manner shown in the example
    given in the previous section. The way this works, considering the given example,
    is that if the `UNIQUE_NAME` macro (this is a generic name from the previous section)
    is not defined, then the code after the `#if` directive, until `#endif`, is included
    in the translation unit and compiled. When that happens, the `UNIQUE_NAME` macro
    is defined with the `#define` directive. The next time the header is included
    in the (same) translation unit, the `UNIQUE_NAME` macro is defined and the code
    in the body of the `#if` directive is not included in the translation unit, therefore,
    it avoids duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the name of the macro must be unique throughout the application; otherwise,
    only the code from the first header where the macro is used will be compiled.
    Code from other headers using the same name will be ignored. Typically, the name
    of the macro is based on the name of the header file where it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Another important example of conditional compilation is cross-platform code,
    which needs to account for different compilers and architectures, usually one
    of Intel x86, AMD64, or ARM. However, the compiler defines its own macros for
    the possible platforms. The samples from the *How to do it...* section show how
    to conditionally compile code for multiple compilers and architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the aforementioned example, we only consider a few architectures.
    In practice, there are multiple macros that can be used to identify the same architecture.
    Ensure that you read the documentation of each compiler before using these types
    of macros in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration-specific code is also handled with macros and conditional compilation.
    Compilers such as GCC and Clang do not define any special macros for debug configurations
    (when the `-g` flag is used). Visual C++ does define `_DEBUG` for a debug configuration,
    which was shown in the last example in the *How to do it...* section. For the
    other compilers, you would have to explicitly define a macro to identify such
    a debug configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature testing is an important conditional-compilation use case, especially
    in libraries that provide support for multiple platforms (Windows, Linux, etc.)
    and compiler versions (C++11, C++14, C++17, etc.). Library implementers often
    need to check whether a particular language feature or language attribute is available.
    This is possible with a set of predefined macros that includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__cplusplus`: Indicates the version of the C++ standard that is being used.
    It expands to one of the following values: `199711L` for versions before C++11,
    `201103L` for C++11, `201402L` for C++14, `201703L` for C++17, and `202002L` for
    C++20\. At the time of writing the book, the value for C++23 has not been defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__cpp_xxx` macros, for determining whether a language feature is supported.
    Examples include `__cpp_concepts`, `__cpp_consteval`, `__cpp_modules`, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__cpp_lib_xxx` macros, for determining whether a library feature is supported.
    Examples include `__cpp_lib_any`, `__cpp_lib_optional`, `__cpp_lib_constexpr_string`,
    etc. These macros are defined in the `<version>` header that was introduced in
    C++20.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of `__cpp_xxx` language feature macros and the `__cpp_lib_xxx` library
    feature macros are being expanded with new macros as new features are added. The
    entire list of macros is too long to be presented here but can be consulted at
    [https://en.cppreference.com/w/cpp/feature_test](https://en.cppreference.com/w/cpp/feature_test).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these macros, there are two directives, `__has_include` and `__has_cpp_attribute`,
    that can be used in `#if`/`#elif` expressions to determine whether a header or
    source file exists or whether an attribute is supported by the compiler. Together,
    all these macros and directives are useful tools in determining whether a particular
    feature is present. They enable us to write code that is portable across platforms
    and compiler versions.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, when performing conditional compilation, you will want to either
    display a warning or stop the compilation entirely. This is possible with the
    help of two diagnostics macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#error` displays a message to the console and stops the compilation of the
    program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#warning`, available since C++23, displays a message to the console without
    stopping the compilation of the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet shows an example of using these directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Although `#warning` is only available since C++23, many compilers offer support
    for this directive as an extension.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using the indirection pattern for preprocessor stringification and concatenation*,
    to learn how to transform identifiers into strings and concatenate identifiers
    together during preprocessing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the indirection pattern for preprocessor stringification and concatenation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ preprocessor provides two operators for transforming identifiers into
    strings and concatenating identifiers together. The first one, operator `#`, is
    called the **stringizing operator**, while the second one, operator `##`, is called
    the **token-pasting**, **merging**, or **concatenating operator**. Although their
    use is limited to some particular cases, it is important to understand how they
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you need to know how to define macros using the preprocessing
    directive `#define`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a string from an identifier using the preprocessing operator `#`,
    use the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a helper macro taking one argument that expands to `#`, followed by
    the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the macro you want to use, taking one argument that expands to the helper
    macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To concatenate identifiers together using the preprocessing operator `##`,
    use the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a helper macro with one or more arguments that use the token-pasting
    operator `##` to concatenate arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the macro you want to use by using the helper macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how these work, let’s consider the `MAKE_STR` and `MAKE_STR2`
    macros defined earlier. When used with any text, they will produce a string containing
    that text. The following example shows how both these macros can be used to define
    strings containing the text `"sample"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, when a macro is passed as an argument, the results are different.
    In the following example, `NUMBER` is a macro that expands to an integer, `42`.
    When used as an argument to `MAKE_STR`, it indeed produces the string `"42"`;
    however, when used as an argument to `MAKE_STR2`, it produces the string `"NUMBER"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++ standard defines the following rules for argument substitution in function-like
    macros (paragraph 15.6.2 from the C++ Standard document number N4917):'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the arguments for the invocation of a function-like macro have been identified,
    argument substitution takes place. A parameter in the replacement list, unless
    preceded by a # or ## preprocessing token or followed by a ## preprocessing token
    (see below), is replaced by the corresponding argument after all the macros contained
    therein have been expanded. Before being substituted, each argument’s preprocessing
    tokens are completely macro replaced as if they formed the rest of the preprocessing
    file; no other preprocessing tokens are available.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What this says is that macro arguments are expanded before they are substituted
    into the macro body, except for the case when the operator `#` or `##` is preceding
    or following a parameter in the macro body. As a result, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: For `MAKE_STR2(NUMBER)`, the `NUMBER` parameter in the replacement list is preceded
    by `#` and, therefore, it is not expanded before substituting the argument in
    the macro body; therefore, after the substitution, we have `#NUMBER`, which becomes
    `"NUMBER"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `MAKE_STR(NUMBER)`, the replacement list is `MAKE_STR2(NUMBER)`, which has
    no `#` or `##`; therefore, the `NUMBER` parameter is replaced with its corresponding
    argument, `42`, before being substituted. The result is `MAKE_STR2(42)`, which
    is then scanned again, and, after expansion, it becomes `"42"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same processing rules apply to macros using the token-pasting operator.
    Therefore, in order to make sure that your stringification and concatenation macros
    work for all cases, always apply the indirection pattern described in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The token-pasting operator is typically used in macros that factor in repetitive
    code to avoid writing the same thing explicitly over and over again. The following
    simple example shows a practical use of the token-pasting operator; given a set
    of classes, we want to provide factory methods that create an instance of each
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Those familiar with the Windows platform have probably used the `_T` (or `_TEXT`)
    macro for declaring string literals that are either translated to Unicode or ANSI
    strings (both single- and multi-type character strings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The Windows SDK defines the `_T` macro as follows. Note that when `_UNICODE`
    is defined, the token-pasting operator is defined to concatenate together the
    `L` prefix and the actual string being passed to the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, it seems unnecessary to have one macro calling another macro,
    but this level of indirection is key for making the `#` and `##` operators work
    with other macros, as we have seen in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Conditionally compiling your source code*, to learn how to compile only parts
    of your code, depending on various conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing compile-time assertion checks with static_assert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, it is possible to perform both runtime and compile-time assertion checks
    to ensure that specific conditions in your code are true. Runtime assertions have
    the disadvantage that they are verified late when the program is running, and
    only if the control flow reaches them. There is no alternative when the condition
    depends on runtime data; however, when that is not the case, compile-time assertion
    checks are to be preferred. With compile-time assertions, the compiler is able
    to notify you early in the development stage with an error that a particular condition
    has not been met. These, however, can only be used when the condition can be evaluated
    at compile time. In C++11, compile-time assertions are performed with `static_assert`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common use of static assertion checks is with template metaprogramming,
    where they can be used for validating that preconditions on template types are
    met (examples can include whether a type is a POD type, copy-constructible, a
    reference type, and so on). Another typical example is to ensure that types (or
    objects) have an expected size.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `static_assert` declarations to ensure that conditions in different scopes
    are met:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespace**: In this example, we validate that the size of the class `item`
    is always 16:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Class**: In this example, we validate that `pod_wrapper` can only be used
    with POD types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Block (function)**: In this example, we validate that a function template
    has only arguments of an integral type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`static_assert` is basically a declaration, but it does not introduce a new
    name. These declarations have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The condition must be convertible to a Boolean value at compile time, and the
    message must be a string literal. As of C++17, the message is optional.
  prefs: []
  type: TYPE_NORMAL
- en: When the condition in a `static_assert` declaration evaluates to `true`, nothing
    happens. When the condition evaluates to `false`, the compiler generates an error
    that contains the specified message, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message argument must be a string literal. However, that changes as of
    C++26, so that it could be an arbitrary constant expression that produces a sequence
    of characters. This helps provide better diagnostic messages for users. For instance,
    assuming there would be a `constexpr` `std::format()` function, one could write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Conditionally compiling classes and functions with enable_if*, to learn about
    SFINAE and how to use it to specify type constraints for templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 12*, *Specifying requirements on template arguments with concepts*,
    to learn the fundamentals of C++20 concepts and how to use them to specify constraints
    for template types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Selecting branches at compile time with constexpr if*, to learn how to compile
    only parts of your code with *constexpr if* statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionally compiling classes and functions with enable_if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template metaprogramming is a powerful feature of C++ that enables us to write
    generic classes and functions that work with any type. This is a problem sometimes
    because the language does not define any mechanism for specifying constraints
    on the types that can be substituted for the template parameters. However, we
    can still achieve this using metaprogramming tricks and by leveraging a rule called
    **substitution failure is not an error**, also known as **SFINAE**. This rule
    determines whether the compiler discards, from the overloaded set, a specialization
    when substituting the explicitly specified or deduced type for the template parameter
    when it fails, instead of generating an error. This recipe will focus on implementing
    type constraints for templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developers have used a class template usually called `enable_if` for many years
    in conjunction with SFINAE to implement constraints on template types. The `enable_if`
    family of templates has become part of the C++11 standard and is implemented as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To be able to use `std::enable_if`, you must include the `<type_traits>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::enable_if` can be used in multiple scopes to achieve different purposes;
    consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a class template parameter to enable a class template only for types that
    meet a specified condition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On a function template parameter, function parameter, or function return type
    to enable a function template only for types that meet a specified condition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To simplify the cluttered code that we end up writing when we use `std::enable_if`,
    we can leverage alias templates and define two aliases, called `EnableIf` and
    `DisableIf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on these alias templates, the following definitions are equivalent to
    the preceding ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::enable_if` works because the compiler applies the SFINAE rule when performing
    overload resolution. Before we can explain how `std::enable_if` works, we should
    have a quick look at what SFINAE is.'
  prefs: []
  type: TYPE_NORMAL
- en: When the compiler encounters a function call, it needs to build a set of possible
    overloads and select the best match for the call based on the arguments for the
    function call. When building this overload set, the compiler evaluates function
    templates too, and has to perform a substitution for the specified or deduced
    types in the template arguments. According to SFINAE, when the substitution fails,
    instead of yielding an error, the compiler should just remove the function template
    from the overload set and continue.
  prefs: []
  type: TYPE_NORMAL
- en: The standard specifies a list of type and expression errors that are also SFINAE
    errors. These include an attempt to create an array of `void` or an array of size
    zero, an attempt to create a reference to `void`, an attempt to create a function
    type with a parameter of type `void`, and an attempt to perform an invalid conversion
    in a template argument expression or in an expression used in a function declaration.
    For the complete list of exceptions, consult the C++ standard or other resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following two overloads of a function called `func()`. The
    first overload is a function template that has a single argument of type `T::value_type`;
    this means it can only be instantiated with types that have an inner type called
    `value_type`. The second overload is a function that has a single argument of
    type `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If the compiler encounters a call such as `func(42)`, then it must find an overload
    that can take an `int` argument. When it builds the overload set and substitutes
    the template parameter with the provided template argument, the result, `void
    func(int::value_type const)`, is invalid, because `int` does not have a `value_type`
    member. Due to SFINAE, the compiler will not emit an error and stop but will simply
    ignore the overload and continue. It then finds `void func(int const)`, and that
    will be the best (and only) match that it will call.
  prefs: []
  type: TYPE_NORMAL
- en: If the compiler encounters a call such as `func<some_type<int>>(42)`, then it
    builds an overload set containing `void func(some_type<int>::value_type const>`
    and `void func(int const)`, and the best match, in this case, is the first overload;
    no SFINAE is involved this time.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the compiler encounters a call such as `func("string"s)`,
    then it again relies on SFINAE to ignore the function template, because `std::basic_string`
    does not have a `value_type` member either. This time, however, the overload set
    does not contain any match for the string argument; therefore, the program is
    ill-formed and the compiler emits an error and stops.
  prefs: []
  type: TYPE_NORMAL
- en: The `enable_if<bool, T>` class template does not have any members, but its partial
    specialization, `enable_if<true, T` `>`, does have an inner type called `type`,
    which is a synonym for `T`. When the compile-time expression supplied as the first
    argument to `enable_if` evaluates to `true`, the inner member `type` is available;
    otherwise, it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the last definition of the `mul()` function from the *How to do
    it...* section, when the compiler encounters a call such as `mul(1, 2)`, it tries
    to substitute `int` for the template parameter, `T`; since `int` is an integral
    type, `std::is_integral<T>` evaluates to `true` and, therefore, a specialization
    of `enable_if` that defines an inner type called `type` is instantiated. As a
    result, the alias template `EnableIf` becomes a synonym for this type, which is
    `void` (from the expression `typename T = void`). The result is a function template,
    `int mul<int, void>(int a, int b)`, that can be called with the supplied arguments.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when the compiler encounters a call such as `mul(1.0, 2.0)`,
    it tries to substitute `double` for the template parameter, `T`. However, this
    is not an integral type; as a result, the condition in `std::enable_if` evaluates
    to `false` and the class template does not define an inner member `type`. This
    results in a substitution error, but according to SFINAE, the compiler will not
    emit an error but move on. However, since no other overload is found, there will
    be no `mul()` function that can be called. Therefore, the program is considered
    ill-formed and the compiler stops with an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar situation is encountered with the class template `pod_wrapper`. It
    has two template type parameters: the first is the actual POD type that is being
    wrapped, while the second is the result of the substitution of `enable_if` and
    `is_standard_layout`. If the type is a POD type (as in `pod_wrapper<int>`), then
    the inner member `type` from `enable_if` exists and it substitutes the second
    template type parameter. However, if the inner member `type` is not a POD type
    (as in `pod_wrapper<std::string>`), then the inner member `type` is not defined,
    and the substitution fails, producing an error such as *too few template arguments*.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`static_assert` and `std::enable_if` can be used to achieve the same goals.
    In fact, in the previous recipe, *Performing compile-time assertion checks with
    static_assert*, we defined the same class template, `pod_wrapper`, and function
    template, `mul()`. For these examples, `static_assert` seems like a better solution
    because the compiler emits better error messages (provided that you specify relevant
    messages in the `static_assert` declaration). These two, however, work quite differently
    and are not intended as alternatives.'
  prefs: []
  type: TYPE_NORMAL
- en: '`static_assert` does not rely on SFINAE and is applied after overload resolution
    is performed. The result of a failed assert is a compiler error. On the other
    hand, `std::enable_if` is used to remove candidates from the overload set and
    does not trigger compiler errors (given that the exceptions the standard specifies
    for SFINAE do not occur). The actual error that can occur after SFINAE is an empty
    overload set that makes a program ill-formed. This is because a particular function
    call cannot be performed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the difference between `static_assert` and `std::enable_if` with
    SFINAE, let’s consider a case where we want to have two function overloads: one
    that should be called for arguments of integral types and one for arguments of
    any type other than integral types. With `static_assert`, we can write the following
    (note that the dummy second type parameter on the second overload is necessary
    to define two different overloads; otherwise, we would just have two definitions
    of the same function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of how we try to call this function, we end up with an error, because
    the compiler finds two overloads that it could potentially call. This is because
    `static_assert` is only considered after the overload resolution has been resolved,
    which, in this case, builds a set of two possible candidates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is `std::enable_if` and SFINAE. We use `std::enable_if`
    via the alias templates `EnableIf` and `DisableIf` defined previously on a template
    parameter (although we still use the dummy template parameter on the second overload
    to introduce two different definitions). The following example shows the two overloads
    rewritten. The first overload is enabled only for integral types, while the second
    is disabled for integral types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With SFINAE at work, when the compiler builds the overload set for either `compute(1,
    2)` or `compute(1.0, 2.0);`, it will simply discard the overload that produces
    a substitution failure and move on, where in each case we’ll end up with an overload
    set containing a single candidate.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Performing compile-time assertion checks with static_assert*, to learn how
    to define assertions that are verified at compile time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Creating type aliases and alias templates*, to learn about aliases
    for types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting branches at compile time with constexpr if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we saw how we can impose restrictions on types and
    functions using `static_assert` and `std::enable_if` and how these two are different.
    Template metaprogramming can become complicated and cluttered when we use SFINAE
    and `std::enable_if` to define function overloads or when we write variadic function
    templates. A new feature of C++17 is intended to simplify such code; it is called
    *constexpr if*, and it defines an `if` statement with a condition that is evaluated
    at compile time, resulting in the compiler selecting the body of a branch or another
    in the translation unit. Typical usage of *constexpr if* is for simplification
    of variadic templates and `std::enable_if`-based code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will refer to and simplify the code written in two previous
    recipes. Before continuing with this recipe, you should take a moment to go back
    and review the code we have written in the previous recipes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `compute()` overloads for integral and non-integral types from the *Conditionally
    compiling classes and functions with enable_if* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined 8-bit, 16-bit, and 32-bit binary literals from the *Creating raw
    user-defined literals* recipe of *Chapter 2*, *Working with Numbers and Strings*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These implementations have several issues:'
  prefs: []
  type: TYPE_NORMAL
- en: They are hard to read. There is a lot of focus on the template declaration,
    yet the body of the functions is very simple, for instance. The biggest problem,
    though, is that it requires greater attention from developers because it is cluttered
    with complicated declarations, such as `typename = std::enable_if<std::is_integral<T>::value,
    T>::type`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is too much code. The end purpose of the first example is to have a generic
    function that behaves differently for different types, yet we had to write two
    overloads for the function; moreover, to differentiate the two, we had to use
    an extra, unused, template parameter. In the second example, the purpose was to
    build an integer value out of characters `'0'` and `'1'`, yet we had to write
    one class template and three specializations to make it happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires advanced template metaprogramming skills, which shouldn’t be necessary
    for doing something this simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax for *constexpr if* is very similar to regular `if` statements and
    requires the `constexpr` keyword before the condition. The general form is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in this form, the `init-statement` is optional.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll explore several use cases for conditional compilation
    with *constexpr if*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use *constexpr if* statements to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid using `std::enable_if` and relying on SFINAE to impose restrictions
    on function template types and conditionally compile code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To simplify writing variadic templates and implement metaprogramming compile-time
    recursion:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way *constexpr if* works is relatively simple: the condition in the `if`
    statement must be a compile-time expression that evaluates or is convertible to
    a Boolean. If the condition is `true`, the body of the `if` statement is selected,
    which means it ends up in the translation unit for compilation. If the condition
    is `false`, the `else` branch, if one is defined, is evaluated. Return statements
    in discarded *constexpr if* branches do not contribute to the function return
    type deduction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example from the *How to do it...* section, the `value_of()` function
    template has a clean signature. The body is also very simple; if the type that
    is substituted for the template parameter is a pointer type, the compiler will
    select the first branch (that is, `return *value;`) for code generation and discard
    the `else` branch. For non-pointer types, because the condition evaluates to `false`,
    the compiler will select the `else` branch (that is, `return value;`) for code
    generation and discard the rest. This function can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'However, without the help of *constexpr if*, we could only implement this using
    `std::enable_if`. The following implementation is a more cluttered alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the *constexpr if* variant is not only shorter but more expressive
    and easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example from the *How to do it...* section, the internal `binary_eval()`
    helper function is a variadic template function without any parameters; it only
    has template parameters. The function evaluates the first argument and then does
    something with the rest of the arguments in a recursive manner (but remember this
    is not a runtime recursion). When there is a single character left and the size
    of the remaining pack is `0`, we return the decimal value represented by the character
    (`0` for `'0'` and `1` for `'``1'`). If the current first element is a `'0'`,
    we return the value determined by evaluating the rest of the arguments pack, which
    involves a recursive call. If the current first element is a `'1'`, we return
    the value by shifting a `1` to the left a number of positions given by the size
    of the remaining pack bit or the value determined. We do this by evaluating the
    rest of the arguments pack, which again involves a recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Conditionally compiling classes and functions with enable_if*, to learn about
    SFINAE and how to use it to specify type constraints for templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing metadata to the compiler with attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ has been very deficient when it comes to features that enable reflection
    or introspection on types of data or standard mechanisms to define language extensions.
    Because of that, compilers have defined their own specific extensions for this
    purpose. Examples include the VC++ `__declspec()` specifier and the GCC `__attribute__((...))`.
    C++11, however, introduced the concept of attributes, which enable compilers to
    implement extensions in a standard way or even embedded domain-specific languages.
    The newer C++ standards define several attributes all compilers should implement,
    and that will be the topic of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use standard attributes to provide hints for the compiler about various design
    goals such as in the scenarios listed here, but not only these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the return value from a function cannot be ignored, declare
    the function with the `[[nodiscard]]` attribute. In C++20, you can specify a string
    literal, of the form `[[nodiscard(text)]]`, to explain why the result should not
    be discarded:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you can declare enumerations and classes used as the return
    type of a function with the `[[nodiscard]]` attribute; in this case, the return
    value of any function returning such a type cannot be ignored:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure that the usage of functions or types that are considered deprecated
    is flagged by the compiler with a warning, declare them with the `[[deprecated]]`
    attribute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure that the compiler does not emit a warning for unused variables, use
    the `[[maybe_unused]]` attribute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure that intentional fall-through case labels in a `switch` statement
    are not flagged by the compiler with a warning, use the `[[fallthrough]]` attribute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To help the compiler optimize paths of execution that are more or less likely
    to execute, use the C++20 `[[likely]]` and `[[unlikely]]` attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To help the compiler optimize code based on the user-given assumptions, use
    the C++23 `[[assume]]` attribute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attributes are a very flexible feature of C++; they can be used almost everywhere,
    but the actual usage is specifically defined for each particular attribute. They
    can be used on types, functions, variables, names, code blocks, or entire translation
    units.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes are specified between double square brackets (for example, `[[attr1]]`),
    and more than one attribute can be specified in a declaration (for example, `[[attr1,
    attr2, attr3]]`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes can have arguments, for example, `[[mode(greedy)]]`, and can be
    fully qualified, for example, `[[sys::hidden]]` or `[[using sys: visibility(hidden),
    debug]]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes can appear either before or after the name of the entity on which
    they are applied, or both, in which case they are combined. The following are
    several examples that exemplify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes cannot appear in a namespace declaration, but they can appear as
    a single-line declaration anywhere in a namespace. In this case, it is specific
    to each attribute whether it applies to the following declaration, to the namespace,
    or to the translation unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard does define several attributes all compilers must implement, and
    using them can help you write better code. We have seen some of them in the examples
    given in the previous section. These attributes have been defined in different
    versions of the standard:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++11:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[[noreturn]]` attribute indicates that a function does not return.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[[carries_dependency]]` attribute indicates that the dependency chain in
    release-consume `std::memory_order` propagates in and out of the function, which
    allows the compiler to skip unnecessary memory fence instructions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In C++14:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[[deprecated]]` and `[[deprecated("reason")]]` attributes indicate that
    the entity declared with these attributes is considered deprecated and should
    not be used. These attributes can be used with classes, non-static data members,
    typedefs, functions, enumerations, and template specializations. The `"reason"`
    string is an optional parameter.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In C++17:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[[fallthrough]]` attribute indicates that the fall-through between labels
    in a `switch` statement is intentional. The attribute must appear on a line of
    its own immediately before a `case` label.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[[nodiscard]]` attribute indicates that a return value from a function
    cannot be ignored.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[[maybe_unused]]` attribute indicates that an entity may be unused, but
    the compiler should not emit a warning about that. This attribute can be applied
    to variables, classes, non-static data members, enumerations, enumerators, and
    typedefs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In C++20:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[[nodiscard(text)]]` attribute is an extension of the C++17 `[[nodiscard]]`
    attribute and provides text that describes the reason a result should not be discarded.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[[likely]]` and `[[unlikely]]` attributes provide hints for the compiler
    that a path of execution is more or less likely to execute, therefore allowing
    it to optimize accordingly. They can be applied to statements (but not declarations)
    and labels, but only one of them, as they are mutually exclusive.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[[no_unique_address]]` attribute can be applied to non-static data members,
    excluding bitfields, and tells the compiler that the member does not have to have
    a unique address. When applied to a member that has an empty type, the compiler
    can optimize it to occupy no space, as in the case of it being an empty base.
    On the other hand, if the member’s type is not empty, the compiler may reuse any
    ensuing padding to store other data members.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In C++23:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[assume(expr)]]` indicates that an expression will always evaluate to `true`.
    Its purpose is to enable the compiler to perform code optimizations and not to
    document the preconditions of a function. However, the expression is never evaluated.
    An expression that has undefined behavior or throws an exception is evaluated
    to `false`. An assumption that does not hold causes undefined behavior; therefore,
    assumptions should be used judiciously. On the other hand, compilers may not use
    an assumption at all.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes are often ignored or briefly mentioned in books and tutorials on
    modern C++ programming, and the reason for that is probably the fact that developers
    cannot actually write attributes, as this language feature is intended for compiler
    implementations. For some compilers, though, it may be possible to define user-provided
    attributes; one such compiler is GCC, which supports plugins that add extra features
    to the compiler, and they can be used for defining new attributes too.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 9*, *Using noexcept for functions that do not throw*, to learn how
    to inform the compiler that a function should not throw exceptions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_04.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2659294082093549796.png)'
  prefs: []
  type: TYPE_IMG
