- en: Example - Linux-Based Infotainment System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter provides an example of how to implement an infotainment system
    using a Linux-based **single-board computer** (**SBC**). It also shows how to
    connect to remote devices using Bluetooth, and how to use online streaming services.
    The resulting device will be able to play back audio from a variety of sources
    without a complex UI. In particular, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing for a Linux-based SBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Bluetooth under Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing back audio from a variety of sources and recording audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GPIO for both simple input and voice recognition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to online streaming audio services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One box that does everything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infotainment systems have become a common feature in our daily lives, starting
    with **in-car entertainment** (**ICE**) systems (also known as **In-Vehicle Infotainment** or
    **IVI**), which evolved from the basic radios and cassette players to include
    features such as navigation and connecting to smartphones over Bluetooth for access
    to one's music library, and much more. Another big feature is to provide the driver
    with hands-free functionality so that they can start a phone call and control
    the radio without having to take their eyes off the road or their hands off the
    steering wheel.
  prefs: []
  type: TYPE_NORMAL
- en: As smartphones became more popular, providing their users with constant access
    to news, weather, and entertainment, the arrival of onboard assistants that use
    a voice-driven interface, both on smartphones and ICEs, ultimately led to the
    arrival of speech-driven infotainment systems aimed at in-home use. These usually
    consist of a speaker and microphone, along with the required hardware for the
    voice-driven interface and access to the required internet-based services.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will mostly focus on this type of voice-driven infotainment system.
    In [Chapter 10](c3f58bee-de57-4934-95e8-18c78b667373.xhtml), *Developing Embedded
    Systems with Qt*, we will take an in-depth look at adding a graphical user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals which we want to achieve here are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Play music from a Bluetooth source, such as a smartphone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play music from an online streaming service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play music from the local filesystem, including USB sticks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record an audio clip and repeat it when asked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control all actions with one's voice, with buttons for some actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next sections, we'll look at these goals and how to accomplish them.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project, any SBC that''s capable of running Linux should work. It
    also needs to have the following features for a full implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: An internet connection (wireless or wired) to access online content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bluetooth functionality (built-in or as an add-on module) to allow the system
    to act as a Bluetooth speaker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free GPIO input to allow for buttons to be hooked up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A functioning microphone input and audio output for the voice input and audio
    playback, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SATA connectivity or similar for connecting storage devices like hard-drives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I2C bus peripheral for an I2C display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the example code in this chapter we only require the microphone input and
    audio output, along with some storage for local media files.
  prefs: []
  type: TYPE_NORMAL
- en: To the GPIO pins, we can connect a number of buttons that can be used to control
    the infotainment system without having to use the voice-activated system. This
    is convenient for situations where using the voice-activated system would be awkward,
    such as when pausing or muting music when taking a phone call.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the buttons will not be demonstrated in this example, but an example
    can be found in an earlier project in [Chapter 3](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml),
    *Developing for Embedded Linux and Similar Systems*. There, we used the WiringPi
    library to connect switches to GPIO pins and configured interrupt routines to
    handle changes on these switches.
  prefs: []
  type: TYPE_NORMAL
- en: One could also connect a small display to the system, if one wanted to show
    current information, such as the name of the current song or other relevant status
    information. Cheap displays of 16x2 characters, which can be controlled over an
    I2C interface, are widely available; these, along with a range of OLED and other
    small displays, would be suitable for this purpose thanks to their minimal hardware
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml), *Developing for
    Embedded Linux and Similar Systems*, we had a brief look at what kind of hardware
    one might want to use for an infotainment system such as this, along with a number
    of possible user interfaces and storage options. What the right hardware configuration
    is, of course, depends on one's requirements. If one wants to store a lot of music
    locally for playback, having a large SATA hard drive connected to the system would
    be highly convenient.
  prefs: []
  type: TYPE_NORMAL
- en: For the example in this chapter, however, we will make no such assumptions,
    acting more as an easily extensible starting point. The hardware requirements
    are therefore very minimal, beyond the obvious need for a microphone and an audio
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Software requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, we are assuming that Linux has been installed on the target
    SBC, and that the drivers for the hardware functionality, such as the microphone
    and audio output, have been installed and configured.
  prefs: []
  type: TYPE_NORMAL
- en: Since we use the Qt framework for this project, all dependencies there should
    be met as well. This means that the shared libraries should be present on the
    system on which the resulting binary for the project will be run. The Qt framework
    can be obtained via the package manager of the OS, or via the Qt website at [http://qt.io/](http://qt.io/).
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](c3f58bee-de57-4934-95e8-18c78b667373.xhtml), *Developing Embedded
    Systems with Qt*, we will look at developing on embedded platforms with Qt in
    more detail. This chapter will briefly touch upon the use of Qt APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on whether we want to compile the application directly on the SBC
    or on our development PC, we might have to install the compiler toolchain and
    further dependencies on the SBC, or the cross-compiling toolchain for Linux on
    the target SBC (ARM, x86, or other architecture). In [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml),
    *Testing OS-Based Applications*, we looked at cross-compiling for SBC systems,
    as well as testing the system locally.
  prefs: []
  type: TYPE_NORMAL
- en: As the example project in this chapter doesn't require any special hardware,
    it can be compiled directly on any system that's supported by the Qt framework.
    This is the recommended way to test out the code prior to deploying it on the
    SBC.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth audio sources and sinks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth is unfortunately a technology that, despite being ubiquitous, suffers
    from its proprietary nature. As a result, support for the full range of Bluetooth
    functionality (in the form of profiles) is lacking. The profile that we are interested
    in for this project is called **Advanced Audio Distribution Profile** (**A2DP**).
    This is the profile used by everything from Bluetooth headphones to Bluetooth
    speakers in order to stream audio.
  prefs: []
  type: TYPE_NORMAL
- en: Any device that implements A2DP can stream audio to an A2DP receiver or can
    themselves act as a receiver (depending on the BT stack implementation). Theoretically,
    this would allow someone to connect with a smartphone or similar device to our
    infotainment system and play back music on it, as they would with a standalone
    Bluetooth speaker.
  prefs: []
  type: TYPE_NORMAL
- en: A receiver in the A2DP profile is an A2DP sink, whereas the other side is the
    A2DP source. A Bluetooth headphone or speaker device would always be a sink device
    as they can only consume an audio stream. A PC, SBC, or similar multi-purpose
    device can be configured to act as either a sink or a source.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the complications surrounding the implementation of a
    full Bluetooth stack on mainstream OSes has led to lackluster support for anything
    more than the basic serial communication functionality of Bluetooth.
  prefs: []
  type: TYPE_NORMAL
- en: While FreeBSD, macOS, Windows, and Android all have Bluetooth stacks, they are
    limited in the number of Bluetooth adapters they can support (just one on Windows,
    and only USB adapters), the profiles they support (FreeBSD is data-transfer-only),
    and configurability (Android is essentially only targeted at smartphones).
  prefs: []
  type: TYPE_NORMAL
- en: For Windows 10, A2DP profile support has currently regressed from being functional
    in Windows 7 to not being functional as of the time of writing due to changes
    to its Bluetooth stack. With macOS, its Bluetooth stack added A2DP support with
    version 10.5 of the OS (Leopard, in 2007) and should function.
  prefs: []
  type: TYPE_NORMAL
- en: The BlueZ Bluetooth stack that has become the official Bluetooth stack for Linux
    was originally developed by Qualcomm and is now included with official Linux kernel
    distributions. It's one of the most full-featured Bluetooth stacks.
  prefs: []
  type: TYPE_NORMAL
- en: With the move from BlueZ version 4 to 5, ALSA sound API support was dropped,
    and instead moved to the PulseAudio audio system, along with the renaming of the
    old APIs. This means that applications and code implemented using the old (version
    4) API no longer work. Unfortunately a lot of the example code and tutorials one
    finds online still targets the version 4, which is something to be aware of, as
    they work very differently.
  prefs: []
  type: TYPE_NORMAL
- en: BlueZ is configured via the D-Bus Linux system IPC (interprocess communication)
    system, or by editing configuration files directly. Actually implementing BlueZ
    support in an application like that in this chapter's project to configure it
    programmatically would be fairly complicated however, due to the sheer scope of
    the APIs, as well the limitations in setting configuration options that go beyond
    just the Bluetooth stack and require access to text-based configuration files.
    The application would therefore have to run with the correct permissions to access
    certain properties and files, editing the latter directly or performing those
    steps manually.
  prefs: []
  type: TYPE_NORMAL
- en: Another complication for the infotainment project is setting up an automatic
    pairing mode, as otherwise the remote device (smartphone) would be unable to actually
    connect to the infotainment system. This would require constant interaction with
    the Bluetooth stack as well, to poll it for any new devices that may have connected
    in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: Each new device would have to be checked to see whether it supports the A2DP
    source mode, in which case it would be added to the audio input for the system.
    One could then hook into the audio system to make use of that new input.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the complexity and scope of this implementation, it was left out of the
    example code in this chapter. It could, however, be added to the code. SBCs such
    as the Raspberry Pi 3 come with a built-in Bluetooth adapter. Others can have
    a Bluetooth adapter added using a USB device.
  prefs: []
  type: TYPE_NORMAL
- en: Online streaming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of online streaming services which one could integrate into
    an infotainment system like the type which are looking at in this chapter. All
    of them use a similar streaming API (usually an HTTP-based REST API), which requires
    one to create an account with the service, using which one can obtain an application-specific
    token that gives one access to that API, allowing one to query it for specific
    artists, music tracks, albums, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using an HTTP client, such as the one found in the Qt framework, it would be
    fairly easy to implement the necessary control flow. Due to the requirement of
    having a registered application ID for those streaming services, it was left out
    of the example code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic sequence to stream from a REST API usually looks like this, with
    a simple wrapper class around the HTTP calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Voice-driven user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project employs a user interface that is fully controllable by voice commands.
    For this, it implements a voice-to-text interface powered by the PocketSphinx
    library (see [https://cmusphinx.github.io/](https://cmusphinx.github.io/)) that
    uses both keyword-spotting and a grammar search in order to recognize and interpret
    commands given to it.
  prefs: []
  type: TYPE_NORMAL
- en: We use the default US-English language model that comes with the PocketSphinx
    distribution. This means that any commands spoken should be pronounced with a
    US-English accent in order to be accurately understood. To change this, one can
    load a different language model aimed at different languages and accents. Various
    models are available via the PocketSphinx website, and it is possible to make
    one's own language model with some effort.
  prefs: []
  type: TYPE_NORMAL
- en: Usage scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don't want the infotainment system to be activated every single time that
    the voice user interface recognizes command words when they are not intended as
    such. The common way to prevent this from happening is by having a keyword that
    activates the command interface. If no command is recognized after the keyword
    within a certain amount of time, the system reverts to the keyword-spotting mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example project, we use the keyword `computer`. After the system spots
    this keyword, we can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| Play Bluetooth | Starts playing from any connected A2DP source device (unimplemented).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Stop Bluetooth | Stops playing from any Bluetooth device. |'
  prefs: []
  type: TYPE_TB
- en: '| Play local | Plays the (hardcoded) local music file. |'
  prefs: []
  type: TYPE_TB
- en: '| Stop local | Stops playing the local music file, if currently playing. |'
  prefs: []
  type: TYPE_TB
- en: '| Play remote | Plays from an online streaming service or server (unimplemented).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Stop remote | Stops playing, if active. |'
  prefs: []
  type: TYPE_TB
- en: '| Record message | Records a message. Records until a number of seconds of
    silence occurs. |'
  prefs: []
  type: TYPE_TB
- en: '| Play message | Plays back the recorded message, if any. |'
  prefs: []
  type: TYPE_TB
- en: Source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This application has been implemented using the Qt framework, as a GUI application,
    so that we also get a graphical interface for ease of debugging. This debugging
    UI was designed using the Qt Designer of the Qt Creator IDE as a single UI file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating an instance of the GUI application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This creates an instance of the `MainWindow` class in which we have implemented
    the application, along with an instance of `QApplication`, which is a wrapper
    class used by the Qt framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, this is the `MainWindow` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Its implementation contains most of the core functionality, declaring the audio
    recorder and player instances, with just the voice command processing being handled
    in a separate class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we set up all of the UI connections for the buttons in the
    GUI window that allow us to trigger the application's functionality without having
    to use the voice user interface. This is useful for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we create an instance of the audio recorder and media player, along
    with an audio probe that is linked with the audio recorder, so that we can look
    at the audio samples it's recording and act on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create an instance of the voice input interface class and push
    it onto its own thread before starting it. We connect its signals to specific
    commands, and other events to their respective slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the section on Bluetooth technology, we have left the Bluetooth
    functionality unimplemented for the reasons explained in that section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The same is true for the online streaming functionality. See the section on
    online streaming earlier in this chapter for details on how to implement this
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To play a local file, we expect to find an MP3 file present in the hardcoded
    path. This could, however, also play all of the music in a specific folder with
    just a few modifications by reading in the filenames and playing them back one
    by one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we configured the recorder to record to a file in a sub-folder
    called `message`. This will be overwritten if a new recording is made, allowing
    one to leave a message that can be played back later. The optional display or
    another accessory could be used to indicate when a new recording has been made
    and hasn''t been listened to yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method is called by our audio probe whenever the recorder is active. In
    this function, we calculate the **root-mean square** (**RMS**) value of the audio
    buffer to determine whether it's filled with silence. Here, silence is relative
    and might have to be adjusted depending on the recording environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'After five seconds of silence have been detected, the recording of the message
    is stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The remaining methods handle the reporting of error messages that may be emitted
    elsewhere in the application, as well as terminating the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VoiceInput` class header defines the functionality for the voice input
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As PocketSphinx is a C library, we have to make sure that it is used with C-style
    linkage. Beyond this, we create the class members for the audio input and related
    IO device that the voice input will use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor doesn''t do anything special, as the next method does all of
    the initializing and setting up of the main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of this method sets up the audio interface, configuring it to
    record using the audio format settings PocketSphinx requires: mono, little-endian,
    16-bit signed PCM audio at 16,000 Hertz. After checking that the audio input supports
    this format, we create a new audio input instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up the keyword-spotting and JSGF grammar file that will be used
    during the processing of the audio sample. With the first `ps_set_search()` function
    call, we start the keyword-spotting search. The following loop will keep processing
    samples until the utterance `computer` is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Each cycle, we read in another buffer worth of audio samples, to then have
    PocketSphinx process these samples. It also does silence detection for us to determine
    whether someone has started speaking into the microphone. If someone is speaking
    but we haven''t started interpreting it yet, we start a new utterance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the method checks whether we have a usable hypothesis we can analyze.
    Depending on whether we are in keyword or grammar mode, we check for the detection
    of the keyword in the former case and switch to grammar mode. If we're already
    in grammar mode, we try to narrow the utterance down to a specific command, at
    which point we will emit the relevant signal that will trigger the connected functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A new utterance is started whenever PocketSphinx detects at least one second
    of silence. After executing a command, the system switches back to keyword-spotting
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Building the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build the project, the PocketSphinx project has to be built first. In the
    example project's source code that comes with this chapter, there are two Makefiles
    underneath the `sphinx` folder, one in the `pocketsphinx` folder and one in the
    `sphinxbase` folder. With these, the two libraries that form PocketSphinx will
    be built.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, one can build the Qt project, either from Qt Creator or from the
    command line, by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Extending the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to audio formats, one could also add the ability to play back videos
    and integrate the ability to make and respond to phone calls (using the Bluetooth
    API). One may want to extend the application to make it more flexible and modular,
    so that, for example, one could add a module that would add the voice commands
    and resulting actions.
  prefs: []
  type: TYPE_NORMAL
- en: Having voice output would be convenient as well, making it more aligned with
    the current commercial offerings. For this, one could use the text-to-speech API
    that's available in the Qt framework.
  prefs: []
  type: TYPE_NORMAL
- en: It would also be useful to add more *information* to the infotainment system
    by querying remote APIs for things such as the current weather, news updates,
    and maybe even running updates on a current football game. The voice-based UI
    could be used to set up timers and task reminders, integrate a calendar, and much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as can be seen in this chapter's example code, one cannot specify the
    name of the track that one wants to play, or a specific album or artist name.
    Allowing such freestyle input is incredibly useful, but comes with its own set
    of issues.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem is the recognition rate of a voice-to-text system, especially
    for words it doesn't have in its dictionary. Some of us may already have had the
    pleasure of raising our voice in trying to make a voice-driven user interface
    on the phone, in the car, or on our smartphones understand a certain word.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it's still a big point of research, without a quick and easy
    solution. One could conceivably brute-force such recognition and get much better
    accuracy by using an index of local audio filenames and artists, along with other
    metadata, as part of the dictionary. The same could be done for a remote streaming
    service, through querying its API. This might add considerable latency to the
    recognition effort, however.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how one can fairly easily construct an SBC-based
    infotainment system, using voice-to-text to construct a voice-driven user interface.
    We also looked at ways that we could extend it to add even more functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The reader is expected to be able to implement a similar system at this point,
    and to extend it to connect it to online and network-based services. The reader
    should also read up on the implementation of more advanced voice-driven user interfaces,
    the addition of text-to-speech, and the use of A2DP-based Bluetooth devices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be taking a look at how to implement a building-wide
    monitoring and control system using microcontrollers and the local network.
  prefs: []
  type: TYPE_NORMAL
