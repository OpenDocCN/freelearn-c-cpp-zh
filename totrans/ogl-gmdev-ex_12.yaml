- en: Chapter 12. Conquer the Universe
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 征服宇宙
- en: Congratulations! You have come this far. If you are reading this chapter, then
    you have already created two games—a 2D game and a 3D game. Sure, they aren't
    going to sell and make you a million dollars, but you already completed more games
    than 90 percent of all people who try.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经走到这一步了。如果你正在阅读这一章，那么你已经创建了两个游戏——一个2D游戏和一个3D游戏。当然，它们可能不会卖出去并让你赚一百万美元，但你已经完成了比90%试图玩游戏的人更多的游戏。
- en: There is a lot more to learn, and there is no way that we can cover everything
    in a single book. This chapter will briefly cover a few more topics and hopefully
    give you at least enough information to experiment further after you are done
    with the book. In fact, we are going to set up a framework that will allow you
    to play, so we will call it the playground.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多东西要学习，我们不可能在一本书中涵盖所有内容。本章将简要介绍几个更多的话题，并希望至少为您提供足够的信息，以便在完成本书后进一步实验。实际上，我们将设置一个框架，让您可以玩游戏，所以我们将称之为游乐场。
- en: 'The topics that we will cover include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的主题包括以下内容：
- en: '**The playground**: We will begin by setting up a template that you can use
    over and over again as you experiment with different features. This template will
    also be a good starting ground for any future games that you may want to create.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游乐场**：我们将首先设置一个模板，您可以在尝试不同功能时反复使用。这个模板也将是您想要创建的任何未来游戏的良好起点。'
- en: '**Texture mapping**: So far, we worked with color, not textures. It would be
    pretty difficult to make realistic games with only color. It turns out that we
    can put textures onto our models to make them more realistic. We will learn the
    basics of texture mapping on a simple 3D shape.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理映射**：到目前为止，我们只处理了颜色，而不是纹理。仅使用颜色制作逼真的游戏会相当困难。事实证明，我们可以将纹理应用到我们的模型上，使它们更加逼真。我们将学习在简单的3D形状上进行纹理映射的基本知识。'
- en: '**Lighting**: So far, we used the default lighting that was provided by OpenGL.
    Most of the time, we want more control over the lighting. We will discuss the
    various types of lighting and how they are used.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光照**：到目前为止，我们使用了OpenGL提供的默认光照。大多数时候，我们希望对光照有更多的控制。我们将讨论各种光照类型及其使用方法。'
- en: '**Skyboxes**: The game universe can''t go on forever. We often use a device
    known as a skybox to surround our game world and make it look like it is larger
    than it really is. We will learn how to add a skybox to our space game.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天空盒**：游戏宇宙不可能永远继续下去。我们经常使用一种称为天空盒的设备来包围我们的游戏世界，使其看起来比实际更大。我们将学习如何将天空盒添加到我们的太空游戏中。'
- en: '**Physics**: In the real world, objects bounce, fall, and do other things based
    on the laws of physics. We will discuss how objects interact with each other and
    the rest of the universe.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理**：在现实世界中，物体根据物理定律弹跳、下落并做其他事情。我们将讨论物体如何相互交互以及与宇宙其他部分的关系。'
- en: '**AI**: Many games have enemies or weapons seeking to destroy the player. These
    enemies are usually controlled by some form of **Artificial Intelligence** (**AI**).
    We will discuss some simple forms of AI and learn how the game can control objects
    in the game.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人工智能**：许多游戏都有敌人或武器试图摧毁玩家。这些敌人通常由某种形式的人工智能（AI）控制。我们将讨论一些简单的AI形式，并学习游戏如何控制游戏中的对象。'
- en: '**Where to go from here**: Finally, I''ll give you a few tips on how you can
    continue to improve your skills once you have completed this book. We''ll talk
    about game engines and topics for additional study.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下一步是什么**：最后，我将给你一些建议，告诉你如何在完成这本书后继续提高你的技能。我们将讨论游戏引擎和额外的学习主题。'
- en: A fun framework
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个有趣的框架
- en: 'Now, it''s time to create our playground. Before we start coding, let''s decide
    on the basic features that we want to set up:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建我们的游乐场了。在我们开始编码之前，让我们决定我们想要设置的基本功能：
- en: Visual Studio project
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio项目
- en: Windows environment
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows环境
- en: OpenGL environment
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL环境
- en: Game loop
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏循环
- en: That's all we are going to do for now. The idea is to set up a basic template
    that you can use to start any game or experimental project. We don't want to include
    too much in this basic framework, so we will leave out sound, input, sprite, and
    model loading for now. These can be added in as they are needed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们就要做这些了。我们的想法是设置一个基本的模板，您可以用它来开始任何游戏或实验项目。我们不希望在这个基本框架中包含太多内容，所以现在我们将省略声音、输入、精灵和模型加载。这些可以在需要时添加。
- en: Setting up the Visual Studio project
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Visual Studio项目
- en: 'Start a new blank project and name it `FunWith3D`. Make sure to add the correct
    libraries as we have done before in the project **Properties**, **Configuration
    Properties**, **Linker**, **Input**, **Additional Dependencies** property:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的空白项目，并将其命名为`FunWith3D`。确保在项目的**属性**、**配置属性**、**链接器**、**输入**、**附加依赖项**属性中添加正确的库：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are going to include the SOIL library because it is so useful to load images.
    You will want to copy the following files over from our `SpaceRacer3D.cpp` project
    folder:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将包含SOIL库，因为它在加载图像方面非常有用。你需要从我们的`SpaceRacer3D.cpp`项目文件夹中复制以下文件：
- en: '`glut.h`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glut.h`'
- en: '`glut32.lib`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glut32.lib`'
- en: '`glut32.dll`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glut32.dll`'
- en: '`SOIL.h`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOIL.h`'
- en: '`SOIL.lib`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOIL.lib`'
- en: 'Add the following libraries to Properties, Configuration Properties, Input,
    and Additional Dependencies:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下库添加到**属性**、**配置属性**、**输入**和**附加依赖项**中：
- en: '`glut32.lib`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glut32.lib`'
- en: '`SOIL.lib`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOIL.lib`'
- en: Setting up the Windows environment
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Windows环境
- en: 'Create a new C++ file and name it `FunWith3D.cpp`. Then add the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的C++文件，并将其命名为`FunWith3D.cpp`。然后添加以下代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, open `SpaceRacer3D.cpp` from the previous project and copy the following
    functions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从上一个项目中打开`SpaceRacer3D.cpp`并复制以下函数：
- en: '`WinMain`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WinMain`'
- en: '`WndProc`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WndProc`'
- en: These are the header files and two functions that are required for Windows to
    do its stuff. All of this code has been explained in previous chapters, so I'm
    not going to re-explain it here. In fact, you could save yourself some typing
    and copy this code directly from our previous project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Windows执行其操作所需的头文件和两个函数。所有这些代码在前面的章节中都有解释，所以在这里我不会再重复解释。实际上，你可以节省一些打字时间，直接从我们之前的项目中复制这段代码。
- en: Setting up the OpenGL environment
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置OpenGL环境
- en: 'Now, it is time to set up OpenGL. Copy the following function from SpaceRacer3D
    and add them after the `WndProc` declaration:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候设置OpenGL了。从SpaceRacer3D中复制以下函数，并在`WndProc`声明之后添加它们：
- en: '`ReSizeGLScene`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReSizeGLScene`'
- en: '`InitGL`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InitGL`'
- en: '`KillGLWindow`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KillGLWindow`'
- en: '`CreateGLWindow`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateGLWindow`'
- en: Setting up the game loop
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置游戏循环
- en: 'Now, we add the function that defines our game loop. Add these functions after
    the OpenGL code that you just added:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加定义我们的游戏循环的函数。在刚刚添加的OpenGL代码之后添加这些函数：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to be consistent with some other code that we have written, you need
    to add the following precompile directives in the project **Properties**, **Configuration
    Properties**, **C/C++**, **Preprocessor**, and **Preprocessor Definitions** property:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与其他我们编写的代码保持一致，你需要在项目的**属性**、**配置属性**、**C/C++**、**预处理器**和**预处理器定义**属性中添加以下预编译指令：
- en: '`_USE_MATH_DEFINES`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_USE_MATH_DEFINES`'
- en: '`_CRT_SECURE_NO_WARNINGS`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_CRT_SECURE_NO_WARNINGS`'
- en: Congratulations! You now have a framework that you can use for any future projects
    and experiments. You have also just successfully reviewed the OpenGL and game
    code that we have been working with throughout the entire book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在有一个可以用于任何未来项目和实验的框架。你刚刚也成功回顾了我们整本书中一直在使用的OpenGL和游戏代码。
- en: You will notice that I also left the code in so that you will be able render
    in either 3D or 2D! All together, you now have a small yet effective start for
    your own game engine. I suggest that you save a copy of the folder containing
    this solution and project. Then, when you are ready to start a new project, you
    can simply copy the solution folder, give it another name, and you are ready to
    go. We are going to use this as the basis for any code that we write in this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我还保留了代码，这样你就可以在3D或2D中渲染！总的来说，你现在有一个小而有效的游戏引擎起点。我建议你保存包含此解决方案和项目的文件夹的副本。然后，当你准备好开始一个新项目时，你可以简单地复制解决方案文件夹，给它另一个名字，然后就可以开始了。我们将以此作为本章中编写任何代码的基础。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To save space and keep our little playground simple, I did not include some
    key features, such as input, sprites, models, and sound. If you feel that any
    of these are essential to your playground, then this will be your first exercise.
    In general, you will have to simply copy the relevant files and/or code into your
    project folder from the last version of SpaceRacer3D.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间并使我们的小型游乐场保持简单，我没有包含一些关键特性，例如输入、精灵、模型和声音。如果你觉得这些中的任何一个是你的游乐场中必不可少的，那么这将是你第一次练习。一般来说，你只需将相关文件和/或代码从SpaceRacer3D的最后一个版本复制到你的项目文件夹中。
- en: Texture mapping
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理映射
- en: Until now, all of our shapes and models used color, but a whole new world awaits
    us when we start applying textures to our models. Adding a 2D texture to a 3D
    model is known as **texture mapping**, or in some cases **texture wrapping**.
    Let's see what it takes to add a little texture to our 3D models. We are going
    to start with a simple cube.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的形状和模型都使用了颜色，但当我们开始将纹理应用于模型时，一个全新的世界等待着我们。将 2D 纹理添加到 3D 模型称为 **纹理映射**，在某些情况下也称为
    **纹理包裹**。让我们看看添加一些纹理到我们的 3D 模型需要什么。我们将从一个简单的立方体开始。
- en: 'First, use your favorite image editing software to create a 256 x 256 pixel
    square and give it some kind of texture. I will be using the following one:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用你喜欢的图像编辑软件创建一个 256 x 256 像素的正方形，并给它添加某种纹理。我将使用以下这个：
- en: '![Texture mapping](img/8199OS_12_01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![纹理映射](img/8199OS_12_01.jpg)'
- en: Save this texture as a bitmap (BMP). We are going to use bitmaps, as opposed
    to PNGs, for texture mapping because the internal data structure of a bitmap happens
    to coincide with the data structure that is expected by OpenGL. In other words,
    it is easier!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将此纹理保存为位图（BMP）。我们将使用位图而不是 PNG，因为位图的内部数据结构恰好与 OpenGL 期望的数据结构相匹配。换句话说，这更容易！
- en: I always create a folder called resources for my images. It is also a good idea
    to include these as resources in the Visual Studio project (right-click on the
    **Resources** folder in the **Solution Explorer** panel and choose **Add Existing…**,
    then navigate to the image).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是为我的图片创建一个名为 resources 的文件夹。将它们作为资源包含在 Visual Studio 项目中也是一个好主意（在 **Solution
    Explorer** 面板中右键点击 **Resources** 文件夹，然后选择 **Add Existing…**，然后导航到图片）。
- en: Loading the texture
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载纹理
- en: 'If you recall, we created a sprite class for our previous projects. We use
    the `AddTexture` method of the `Sprite` class to make a call to the SOIL library
    to load the image. We won''t be using the `Sprite` class for these textures. The
    `Sprite` class has a lot of methods and properties that don''t apply to texturing
    3D models, so we are going to write our own texture loader for this use. Add the
    following code somewhere above render functions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们为之前的项目创建了一个精灵类。我们使用 `Sprite` 类的 `AddTexture` 方法来调用 SOIL 库以加载图片。我们不会使用
    `Sprite` 类来处理这些纹理。`Sprite` 类有很多方法和属性，这些并不适用于纹理化 3D 模型，因此我们将为这个用途编写自己的纹理加载器。在渲染函数上方某处添加以下代码：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The purpose of `LoadTexture` is to load a texture into memory, and then set
    it up to be a texture map for a 3D object. In order to accomplish this, we actually
    need to load the texture twice. First, we directly open the file and read it as
    a binary file into a buffer called `data`. We use the `char` datatype because
    we want to store the binary data as unsigned integers and `char` does a really
    great job of this. So, our first few lines of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadTexture` 的目的是将纹理加载到内存中，并将其设置为 3D 对象的纹理映射。为了完成这个任务，我们实际上需要将纹理加载两次。首先，我们直接打开文件，将其作为二进制文件读入名为
    `data` 的缓冲区。我们使用 `char` 数据类型，因为我们想将二进制数据存储为无符号整数，而 `char` 在此方面做得非常好。因此，我们的前几行代码：'
- en: Define the data array
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据数组
- en: Create a file handle
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件句柄
- en: Allocate memory for the data
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为数据分配内存
- en: Read the file into the data buffer
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件读入数据缓冲区
- en: Close the file (but not the buffer)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭文件（但不是缓冲区）
- en: Now, read the image a second time, though this time we use the SOIL library
    to read it as an OpenGL texture and use SOIL to load the texture and assign it
    to the OpenGL referenced by `texture`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次读取图片，但这次我们使用 SOIL 库将其作为 OpenGL 纹理读取，并使用 SOIL 加载纹理并将其分配给由 `texture` 引用的
    OpenGL。
- en: 'Then, we perform some fancy OpenGL operations on it to set it up as a model
    texture:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对其执行一些复杂的 OpenGL 操作，将其设置为模型纹理：
- en: '`GL_BindTexture` simply tells OpenGL that we want this texture to be the current
    texture, to which we will apply the settings that follow.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_BindTexture` 简单地告诉 OpenGL 我们想要这个纹理成为当前纹理，我们将应用随后的设置。'
- en: '`glTexImage2D` tells OpenGL how to interpret the data that we have read in.
    We are telling OpenGL to treat the data as a 2D texture of the type RGB or RGBA
    (controlled by the `colordepth` parameter), and that the data is stored as unsigned
    integers (thus, the `char` data type).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glTexImage2D` 告诉 OpenGL 如何解释我们读取的数据。我们告诉 OpenGL 将数据视为 RGB 或 RGBA 类型的 2D 纹理（由
    `colordepth` 参数控制），并且数据以无符号整数存储（因此，使用 `char` 数据类型）。'
- en: The next two functions, both calls to `glTexParameteri`, tell OpenGL how to
    handle the texture as it gets nearer to or farther away from the camera. They
    are both set up to use linear filtering to handle this level of detail.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下两个函数，都是对`glTexParameteri`的调用，告诉OpenGL如何处理纹理，当它靠近或远离相机时。它们都设置为使用线性过滤来处理这种细节级别。
- en: Finally, we close the data buffer as it is no longer needed.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，由于不再需要，我们关闭数据缓冲区。
- en: 'We have set the `LoadTexture` function up so that you can call it for different
    textures based on your needs. In our case, we are first going to set up a handle
    to this texture. At the top of the code, add this line to the global variables
    section:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了`LoadTexture`函数，以便根据您的需求调用它。在我们的例子中，我们首先将设置一个指向此纹理的句柄。在代码顶部，将此行添加到全局变量部分：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we will place the call to load the texture in the `StartGame` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将加载纹理的调用放置在`StartGame`函数中：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This call tells the program:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用告诉程序：
- en: The location of the file
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的位置
- en: The width and height of the image
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的宽度和高度
- en: The color depth of the image (in this case `4` = RGBA)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的色彩深度（在本例中`4` = RGBA）
- en: The OpenGL texture handle
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL纹理句柄
- en: Rendering the cube
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染立方体
- en: We are all set up now with a texture, but we need a model to texture. To keep
    things simple, we are going to use quads to create a cube and apply the marble
    texture to each face of the cube.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个纹理，但我们需要一个模型来纹理化。为了使事情简单，我们将使用四边形来创建一个立方体，并将大理石纹理应用到立方体的每个面上。
- en: 'Just before we get started, we need to add three variables to track rotation.
    Add these lines to the global variables section:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要添加三个变量来跟踪旋转。将这些行添加到全局变量部分：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, create the following function just below the `LoadTexture` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`LoadTexture`函数下方创建以下函数：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code is very similar to the code that we used to draw a cube in a previous
    chapter. However, when we drew that cube, we applied color to each vertex. Now,
    we will apply our texture to each face. First, we set things up:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们在前一章中用来绘制立方体的代码非常相似。然而，当我们绘制那个立方体时，我们对每个顶点应用了颜色。现在，我们将纹理应用到每个面上。首先，我们设置一些事情：
- en: The first thing that we do is use `glEnable(GL_TEXTURE_2D)` to enable 2D textures.
    In our initial setup, we disabled 2D textures. If we did not enable them here,
    then our texture would not show up!
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用`glEnable(GL_TEXTURE_2D)`来启用2D纹理。在我们的初始设置中，我们禁用了2D纹理。如果我们在这里不启用它们，那么我们的纹理将不会显示出来！
- en: Next, we use `glLoadIdentity()` to initialize the current matrix.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`glLoadIdentity()`来初始化当前矩阵。
- en: We call `glTranslatef(0.0f, 0.0f, -5.0f)` to move the camera back (so that we
    will be outside the cube).
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`glTranslatef(0.0f, 0.0f, -5.0f)`将相机向后移动（这样我们就会在立方体外面）。
- en: Three calls to `glRotate3f` will rotate the cube for us.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三次调用`glRotate3f`将为我们旋转立方体。
- en: Then, we use `glBindTexture(GL_TEXTURE_2D, texMarble)` to inform OpenGL that
    for the next draw operations we will be using the texture referenced by `texMarble`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`glBindTexture(GL_TEXTURE_2D, texMarble)`来通知OpenGL，在接下来的绘制操作中，我们将使用由`texMarble`引用的纹理。
- en: 'With this setup completed, we are ready to get drawing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此设置后，我们就可以开始绘图了：
- en: We start with `glBegin(GL_QUADS)` to tell OpenGL that we will be drawing quads.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`glBegin(GL_QUADS)`开始，告诉OpenGL我们将绘制四边形。
- en: Now, each call comes in a pair. First a call to `glTexCoord2f` is followed by
    a call to `glVertex3f`. The call to `glTexCoord2f` tells OpenGL which part of
    the texture to put at the location specified by `glVertex3f`. In this way, we
    can map any point in the texture to any point in the quad. OpenGL takes care of
    figuring out which parts of the texture go between vertices.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，每个调用都成对出现。首先是一个`glTexCoord2f`的调用，然后是一个`glVertex3f`的调用。`glTexCoord2f`的调用告诉OpenGL将纹理的哪一部分放置在由`glVertex3f`指定的位置。这样，我们可以将纹理中的任何点映射到四边形中的任何点。OpenGL负责确定纹理的哪些部分位于顶点之间。
- en: When we are done drawing the cube, we issue the `glEnd()` command.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们完成立方体的绘制后，我们发出`glEnd()`命令。
- en: The last three lines update the rotation variables.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后三行更新旋转变量。
- en: 'Finally, we have to make a call to `DrawTexturedCube` in the `Render3D` function:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须在`Render3D`函数中调用`DrawTexturedCube`：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program and see the cube in its textured glory!![Rendering the cube](img/8199OS_12_02.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，看看立方体在纹理的华丽中！！[渲染立方体](img/8199OS_12_02.jpg)
- en: Mapping operations
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射操作
- en: 'I owe you a little more explanation as to how texture mapping works. Take a
    look at these four lines of code from `DrawTexturedCube`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要向您解释更多关于纹理映射的工作原理。看看`DrawTexturedCube`中的这四行代码：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These four lines define one quad. Each vertex consists of a texture coordinate
    (`glTexCoord2f`) and a vertex coordinate (`glVertex3f`). When OpenGL looks at
    a texture, here is what it sees:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这四行定义了一个四边形。每个顶点由一个纹理坐标（`glTexCoord2f`）和一个顶点坐标（`glVertex3f`）组成。当 OpenGL 查看纹理时，它看到的是：
- en: '![Mapping operations](img/8199OS_12_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![映射操作](img/8199OS_12_03.jpg)'
- en: No matter how big a texture is in pixels, in texture coordinates, the texture
    is exactly one unit wide and one unit tall. So, the first line of the preceding
    code tells OpenGL to take the point (**0,0**) of the texture (the upper-left corner)
    and map it to the next vertex that is defined (which is the upper-left hand corner
    of the quad, in this example). You will notice that the third line maps the coordinate
    (**1,1**) of the texture to the lower-right corner of the quad. In effect, we
    are stretching the texture across the face of the quad! However, OpenGL also adapts
    the mapping so that the texture doesn't look smeared, so this isn't exactly what
    happens. Instead, you will see some tiling in our case.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不论纹理在像素中有多大，在纹理坐标中，纹理正好是一单位宽和一单位高。所以，前面代码的第一行告诉 OpenGL 将纹理的点（**0,0**）（左上角）映射到定义的下一个顶点（在这个例子中是四边形的左上角）。你会注意到第三行将纹理坐标（**1,1**）映射到四边形的右下角。实际上，我们正在将纹理拉伸到四边形的面上！然而，OpenGL
    也会调整映射，使得纹理看起来不会模糊，所以这并不是真正发生的事情。相反，你将看到一些平铺效果。
- en: Let there be light!
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让有光吧！
- en: Until this point, we haven't worried about lighting. In fact, we just assumed
    that light would be there so that we could see our images. OpenGL has a light
    setting that lights everything equally. This setting is turned on, by default,
    until we tell OpenGL that we would like to handle the lighting.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有担心过光照。实际上，我们只是假设光线会存在，这样我们才能看到我们的图像。OpenGL 有一个光照设置，它会均匀地照亮一切。这个设置默认是开启的，直到我们告诉
    OpenGL 我们想要处理光照。
- en: 'Imagine what our scene would look like if there was no lighting. In fact, this
    is going to happen to you some day. You will have everything set up and ready
    to roll, you''ll run the program, and you''ll get a big, black, nothing! What''s
    wrong? You forgot to turn on the lights! Just as shown in the following image:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下如果没有光照，我们的场景会是什么样子。实际上，这有一天会发生。你将一切设置好并准备就绪，你将运行程序，然后你会得到一个又大又黑的什么都没有！怎么了？你忘记打开灯了！就像下面的图片所示：
- en: '![Let there be light!](img/8199OS_12_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![有光吧！](img/8199OS_12_04.jpg)'
- en: Just like real life, if you don't have a source of light, you aren't going to
    see anything. OpenGL has many types of lights. One common light is **ambient**
    light. Ambient light appears to come from all directions at the same time, similarly
    to how sunlight fills up a room.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像现实生活一样，如果你没有光源，你将什么也看不到。OpenGL 有许多类型的光源。一种常见的光源是**环境光**。环境光似乎同时从所有方向照射过来，就像阳光充满房间一样。
- en: '![Let there be light!](img/8199OS_12_05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![有光吧！](img/8199OS_12_05.jpg)'
- en: Lighting is very important in 3D games, and most games have multiple light sources
    to add realism to the game.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 光照在 3D 游戏中非常重要，大多数游戏都有多个光源来增加游戏的真实感。
- en: Defining a light source
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义光源
- en: 'Let''s take over and define our own light source. Add the following lines of
    code to the top of the `DrawTexturedCube` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接管并定义我们自己的光源。将以下代码行添加到 `DrawTexturedCube` 函数的顶部：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the program, then come back to see what is happening:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，然后回来查看发生了什么：
- en: '`glEnable(GL_LIGHTING)` tells OpenGL that we want to take control of the lighting
    now. Remember: once you enable lighting, it''s up to you. In fact, if you enable
    lighting and don''t define any lights, then you will get a completely black scene.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glEnable(GL_LIGHTING)` 告诉 OpenGL 我们现在想要控制光照。记住：一旦启用光照，就由你来决定了。实际上，如果你启用了光照但没有定义任何光源，那么你将得到一个完全黑色的场景。'
- en: Next, we define a color for our light. In this case, we are creating a blue
    light.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的光源定义一个颜色。在这种情况下，我们正在创建一束蓝色光。
- en: Now we tell OpenGL what type of lighting we would like to use with `glLightModelfv`.
    In this case, we are turning on a blue, ambient light.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们通过 `glLightModelfv` 告诉 OpenGL 我们想要使用哪种类型的光照。在这种情况下，我们正在开启一种蓝色，环境光。
- en: Light has to have a material to reflect from. So, we use `glEnable(GL_COLOR_MATERIAL)`
    to tell OpenGL to use a material that will reflect color.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光需要有材料来反射。因此，我们使用 `glEnable(GL_COLOR_MATERIAL)` 来告诉 OpenGL 使用一个会反射颜色的材料。
- en: The call to `glColorMaterial(GL_FRONT, GL_AMBIENT)` tells OpenGL that the front
    of this material should reflect light as if it was ambient light. Remember, ambient
    light comes from all directions.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`glColorMaterial(GL_FRONT, GL_AMBIENT)`告诉OpenGL，这个材质的前面应该像环境光一样反射光线。记住，环境光来自所有方向。
- en: Of course, you have already seen the result. Our cube is blue! Play around with
    different colors. We only have time to barely scratch the surface on lighting.
    You will also want to learn about diffuse lighting. Diffuse lights fade with distance.
    With a diffuse light, you not only set up the color, but you also place the light
    at a certain location.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你已经看到了结果。我们的立方体是蓝色的！尝试不同的颜色。我们只有时间对光照进行浅尝辄止。你还将想要了解漫反射光照。漫反射光随着距离的增大而减弱。使用漫反射光时，你不仅设置颜色，还要在某个位置放置光源。
- en: The skybox
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 天空盒
- en: While space may be infinite, your computer isn't so there has to be a boundary
    somewhere. This boundary is called the skybox.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然空间可能是无限的，但你的计算机不是，所以必须有一个边界。这个边界被称为天空盒。
- en: 'Imagine that our spaceship is flying through space! Space is big. While we
    may put some planets and asteroids in our universe to give the space ship something
    to interact with, we certainly won''t model every star. Here is what our universe
    looks like:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们的宇宙飞船正在太空中飞行！空间很大。虽然我们可以在我们的宇宙中放置一些行星和小行星，让宇宙飞船有东西可以与之交互，但我们当然不会为每一颗星星建模。这就是我们的宇宙看起来像的：
- en: '![The skybox](img/8199OS_12_06.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![天空盒](img/8199OS_12_06.jpg)'
- en: This is pretty empty, right? You probably already noticed this in our game,
    SpaceRacer3D. Of course, we could add some more objects of our own—more asteroids,
    add a bunch of stars—and in a real game, we would. But, there is always a limit
    to how many objects you can add to the game before you start having performance
    issues.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当空旷，对吧？你可能在我们的游戏SpaceRacer3D中已经注意到了这一点。当然，我们可以添加一些自己的物体——更多的小行星，添加一大堆星星——在一个真正的游戏中，我们会这样做。但是，在开始出现性能问题时，你可以添加到游戏中的物体数量总是有限的。
- en: 'For the really distant objects, such as distant stars, we fake it by using
    2D textures. For example, our game could use a texture of stars to imitate the
    stars and nebula in space, as shown in the following image:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真正遥远的物体，例如遥远的星星，我们通过使用二维纹理来模拟。例如，我们的游戏可以使用星纹理来模拟太空中的星星和星云，如下面的图片所示：
- en: '![The skybox](img/8199OS_12_07.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![天空盒](img/8199OS_12_07.jpg)'
- en: 'Now, as a cube has six sides, what we really want is six textures. A typical
    skybox looks similar to the following image:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于一个立方体有六个面，我们真正想要的是六个纹理。一个典型天空盒看起来类似于以下图片：
- en: '![The skybox](img/8199OS_12_08.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![天空盒](img/8199OS_12_08.jpg)'
- en: 'It doesn''t take too much imagination to see how this texture can be wrapped
    around the cube and cover all size sides. This creates an image that covers all
    of the space encapsulated by the skybox and gives the illusion of being surrounded
    by stars and nebula, as shown in the following image:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 并不需要太多的想象力就能看到这个纹理如何被包裹在立方体上并覆盖所有尺寸的侧面。这创造了一个覆盖天空盒封装的所有空间的图像，给人一种被星星和星云包围的错觉，如下面的图片所示：
- en: '![The skybox](img/8199OS_12_09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![天空盒](img/8199OS_12_09.jpg)'
- en: 'The following illustration shows the skybox in relation to the texture that
    will be applied to it from another perspective:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的插图展示了从另一个角度应用到天空盒上的纹理：
- en: '![The skybox](img/8199OS_12_10.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![天空盒](img/8199OS_12_10.jpg)'
- en: The cube containing the ship and asteroid represents the game world. The ship
    and asteroid are real objects in that world. The image on the left is a texture
    that contains the stars.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 包含飞船和小行星的立方体代表游戏世界。飞船和小行星是这个世界中的真实物体。左边的图像是一个包含星星的纹理。
- en: Now, imagine the star texture being wrapped around the cube, and there is your
    whole universe composed of the stars, the ship, and the asteroid. The star texture
    wrapped around the cube is the skybox.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象星纹理被包裹在立方体上，这就是你的整个宇宙，由星星、飞船和小行星组成。包裹在立方体上的星纹理就是天空盒。
- en: Advanced topics
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题
- en: Unfortunately, for the last two topics, we only have time to give them an honorable
    mention. I included them because you are going to hear about these topics, and
    you need to know what these terms mean.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于最后两个主题，我们只有时间给予它们一个荣誉的提及。我包括它们是因为你将要听到这些主题，你需要知道这些术语的含义。
- en: Game physics
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏物理
- en: '**Game physics** are the rules that define how objects interact with other
    objects inside the game universe. For example, in SpaceRacer3D, the ship simply
    passes through the asteroids. However, there could be many other outcomes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏物理**是定义游戏宇宙内物体如何相互作用的规则。例如，在SpaceRacer3D中，飞船只是简单地穿过小行星。然而，可能会有许多其他结果：'
- en: The ship and asteroid could bounce off of each other (rebound)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 飞船和小行星可能会相互弹跳（反弹）
- en: The ship could be sucked into the asteroid with the force increasing as the
    ship got closer (gravity)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 飞船可能会被小行星吸进去，随着飞船靠近，力量会逐渐增加（重力）
- en: The asteroid could push against the ship the closer the ship got to it (reverse
    gravity)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当飞船靠近小行星时，小行星可能会对飞船产生推力（反向重力）
- en: Each of these effects would be programmed into the game. Each of these effects
    would also create a different kind of gameplay. An entire genre of games known
    as physics-based games simply define the laws of physics for a game universe and
    then let things interact to see what will happen.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些效果都会被编程到游戏中。每个效果也会创造不同类型的游戏体验。一个被称为基于物理的游戏的整个游戏类型，仅仅定义了一个游戏宇宙中的物理定律，然后让事物相互作用，看看会发生什么。
- en: AI
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能
- en: '**AI**, or **artificial intelligence**, is another set of rules that defines
    how characters or objects that are controlled by the compute behave. AI is typically
    applied to enemies and other **Non-player Characters** (**NPCs**) to give them
    a life-like appearance in the game. Some examples of AI include:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**，或**人工智能**，是一套规则，定义了由计算机控制的字符或物体如何行为。人工智能通常应用于敌人和其他**非玩家角色**（**NPC**），以在游戏中赋予它们逼真的外观。人工智能的一些例子包括：'
- en: A mine that automatically detects that the enemy is close and blows up
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个自动检测到敌人靠近并爆炸的雷区
- en: A homing missile that locks onto a space ship and draws closer no matter how
    the ship navigates
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种制导导弹，无论飞船如何导航，都会锁定并靠近太空船
- en: An enemy character who detects that the player coming and hides behind a rock
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个敌人角色检测到玩家靠近并躲在岩石后面
- en: AI is typically considered one of the most difficult areas of game programming.
    Some algorithms are quite easy (for example, the homing missile only needs the
    ships position to know how to track it), while others are very complex (for example,
    hiding behind a rock). Some games even provide an AI opponent for you to play
    against.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能通常被认为是游戏编程中最困难的领域之一。一些算法相当简单（例如，制导导弹只需要知道飞船的位置来追踪它），而其他算法则非常复杂（例如，躲在岩石后面）。有些游戏甚至为你提供了一个AI对手来对抗。
- en: The future
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来
- en: You have, indeed, come a long way. If you are reading these words, and especially
    if you wrote all of the code along the way, then you have achieved a great accomplishment,
    but there is still so much to learn. I encourage you to find other books and never
    stop learning. The only thing that will stop you from becoming a great game programmer
    is you!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你确实已经走了很长的路。如果你在阅读这些文字，尤其是如果你在过程中编写了所有代码，那么你已经取得了巨大的成就，但还有许多东西要学习。我鼓励你找到其他书籍，永远不要停止学习。阻止你成为伟大游戏程序员的唯一因素是你自己！
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As always, we covered a lot of topics in this chapter. You learned how to map
    a texture onto an object, then you learned how to turn the lights on. You learned
    how a skybox can be used to make your world seem larger than it is. And you got
    just a taste of physics and AI, topics which could easily fill entire books on
    their own. Don't stop until you have got every piece of code in this book to work
    for you, and then start changing the code to different and amazing things.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们在本章中涵盖了大量的主题。你学习了如何将纹理映射到物体上，然后你学习了如何打开灯光。你学习了天空盒如何被用来使你的世界看起来比实际更大。你还仅仅尝到了物理和人工智能的滋味，这些主题可以轻易地填满整本书。不要停止，直到你让这本书中的每一行代码为你所用，然后开始改变代码，让它变得不同和令人惊叹。
- en: Good luck!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运！
