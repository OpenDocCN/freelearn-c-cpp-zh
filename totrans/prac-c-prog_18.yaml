- en: Applying Security in Coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While coding, sometimes you may use functions that don't check or constrain
    the data entered by the user. The user either may enter incorrect data or content
    that might be larger than the capacity of the receiving variable. In such a situation,
    a buffer overflow or segmentation fault may occur. Consequently, the program will
    give an erroneous output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the following recipes to see how we can error-proof
    the entering of data in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding buffer overflow while reading strings from the keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing secure code while copying strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding errors while string formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid vulnerabilities while accessing files in C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common vulnerability in C programming is buffer overflows. The buffer,
    as the name suggests, represents a temporary area of memory storage in the RAM
    that a program uses to run itself. Usually, all the variables used in a program
    are assigned temporary buffer storage for keeping the values assigned to them.
    Some functions don't limit the data within the buffer boundaries while assigning
    larger values (larger than the assigned buffer) to the variables, leading to overflowing
    of the buffer. The overflowing data corrupts or overwrites data of other buffers.
  prefs: []
  type: TYPE_NORMAL
- en: These buffer overflows might be used by hackers or malicious users to damage
    files or data or to extract sensitive information. That is, an attacker might
    enter such an input that leads to buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: While assigning values to an array, there are no bounds checks and the code
    might work, whether the memory being accessed belongs to your program or not.
    In most cases, it leads to a segmentation fault, overwriting data in another memory
    region.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using some terms and functions repeatedly in this program. Let's
    do a quick overview of them.
  prefs: []
  type: TYPE_NORMAL
- en: gets()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `gets()` function reads characters from the standard input device and assigns
    them to the specified string. Reading of characters stops when the newline character
    is reached. This function does not check for buffer length and always results
    in a vulnerability. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `str` represents the pointer to the string (array of characters) to which
    the read characters are assigned.
  prefs: []
  type: TYPE_NORMAL
- en: On successful execution, the function returns `str` and `NULL` if any error
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: fgets()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fgets()` function is used for reading a string from the specified source,
    where the source can be any file, keyboard, or another input device. Here is its
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `numb` number of bytes are read from the specified source `src` and assigned
    to the string pointed to by `str`. The function either reads `numb-1` bytes, or
    until a newline (`\n`) is reached, or an end of file is encountered, whichever
    happens first.
  prefs: []
  type: TYPE_NORMAL
- en: The function also appends the null character (`\0`) to the string that is read
    to terminate the string. If executed successfully, the function returns a pointer
    to `str` and returns `NULL` if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: fpurge(stdin)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fpurge(stdin)` function is used to flush or clear out the input buffer
    of the stream. Sometimes, after feeding data for some variables, the data (which
    might be in the form of spaces or a newline character) is left behind in the buffer
    and is not cleared. In such cases, this function is used. If executed successfully,
    the function returns zero, else it returns EOF.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: sprintf()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sprintf()` function is used for assigning formatted text to a string.
    Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `str` is a pointer to the string where the formatted string has to be
    assigned, and `format` is the same as in a `printf` statement, where different
    formatting tags such as `%d` and `%s` can be used to format the content.
  prefs: []
  type: TYPE_NORMAL
- en: snprintf()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `snprintf()` function formats the given content and assigns it to the specified
    string. Only the specified number of bytes will be assigned to the destination
    string. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a breakdown of what the preceding code represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*str`: Represents the pointer that points to the string where formatted content
    will be assigned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numb`: Represents the maximum number of bytes that can be assigned to the
    string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: Like the `printf` statement, several formatting tags such as `%d` and `%s` can
    be used to format the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: `snprintf` automatically appends a null character to the formatted string.'
  prefs: []
  type: TYPE_NORMAL
- en: strcpy()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `strcpy()` function is used for copying the content from one string to
    another. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `src` represents the pointer to the source string from where the content
    has to be copied and `dest` represents the pointer to the destination string to
    which the content has to be copied.
  prefs: []
  type: TYPE_NORMAL
- en: strncpy( )
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `strncpy()` function is used for copying the specified number of bytes
    from one string into another. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a breakdown of what the preceding code represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dest`: Represents the pointer to the destination string to where the bytes
    have to be copied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: Represents the pointer to the source string from where the bytes have
    to be copied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numb`: Represents the number of bytes to be copied from source to the destination
    string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value of the `numb` parameter is larger than the length of the source
    string, the destination string will be padded with null bytes. If the length of
    the destination string is smaller than the `numb` parameter, then the string will
    be truncated to be equal to the length of the destination string.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now begin our journey for secure coding with the first recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how a buffer overflow occurs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to get input from the user and will see the situations
    that lead to a buffer overflow and result in ambiguous output. We will also learn
    the procedure to avoid a buffer overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we will make a structure comprising two members and in one of the
    members, we will deliberately enter text that is larger than its capacity, as
    a result of which a buffer overflow will occur. This will lead to the overwriting
    of the content of another member of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to make a program that will lead to a buffer overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a structure consisting of two members, `name` and `orderid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define two variables of the structure type defined in *step 1*. In one of the
    structure variables, we will deliberately generate a buffer overflow by entering
    a large amount of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prompt the user to enter a value for the `orderid` member for the first structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `fpurge` function to empty out the input stream buffer before invoking
    the `gets` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `gets` function to enter data for the `name` member for the first
    structure. Enter text that is larger than the length of the `name` member.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 3* to *5* to enter data for the `orderid` and `name` members for
    the second structure. This time, enter data within the capacity of the `name`
    member.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display data assigned to the `orderid` and `name` members of the first structure.
    Buffer overflow will occur in the case of the first structure and you will get
    an ambiguous output while displaying the `orderid` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display data assigned to the `orderid` and `name` member of the second structure.
    No buffer overflow takes place in this structure and you get exactly the same
    data that was entered for both the members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following program will take the name and order number values for two structures.
    In one member of the structure, we will enter data that is larger than its capacity
    to generate a buffer overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The program will ask for two pairs of names and order numbers. In the first
    pair, we will deliberately generate a buffer overflow by entering text that is
    longer than the variable size, whereas for the second pair, we will enter the
    data within the specified range. Consequently, the information of the first user
    (pair) will be displayed incorrectly, that is, the data will not appear exactly
    the same as it was entered, whereas that of the second user will appear correctly.
  prefs: []
  type: TYPE_NORMAL
- en: So, we will define a structure called `users` with two fields or members called
    `name` and `orderid`, where `name` is defined as a string of size 10 bytes and
    `orderid` is defined as an int variable of 2 bytes. Then, we will define two variables
    `user1` and `user2` of the `users` structure type; that means both the `user1`
    and `user2` variables will get a `name` and `orderid` member each.
  prefs: []
  type: TYPE_NORMAL
- en: You will be prompted to enter the username and order number twice. The first
    pair of names and the order numbers entered will be assigned to `user1` and the
    second to `user2`. The entered information of the two users is then displayed
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `getsproblem.c` program. If you get no errors
    or warnings, it means the `getsproblem.c` program has compiled into an executable
    file: `getsproblem.exe`. Let''s run this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa9293f3-cf51-44ab-87b7-7c2384259cb4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.1
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the preceding output that because of the buffer overflow made
    by the `name` member in the first structure, the value of the `orderid` member,
    which was `101`, is overwritten. Consequently, we get a garbage value for the
    `orderid` of the first structure. The output of the second structure is correct
    because the value entered for its members is within their capacity.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid overflow while entering data, we simply replace the `gets` function
    with the `fgets` function. With the `fgets` function, we can specify the maximum
    number of characters that can be allowed in the specified string. The extra text
    will be truncated and will not be assigned to the specified string.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to avoid a buffer overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we defined two structure variables because we wanted
    to show that if data entered is larger in size than the member field allows, it
    will result in ambiguous output; and if data is entered within the capacity of
    the receiving variables, it will generate the correct output.
  prefs: []
  type: TYPE_NORMAL
- en: In the following recipe, we don't need two structure variables as we will be
    using the `fgets` function to address our concern. This function never results
    in a buffer overflow.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps for avoiding a buffer overflow using the `fgets` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a structure consisting of two members, `name` and `orderid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a variable of the structure type defined in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prompt the user to enter a value for the `orderid` member of the structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `fpurge` function to empty out the input stream buffer before invoking
    the `fgets` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `fgets` function to enter data for the `name` member of the structure.
    In order to constrain the size of the text to be assigned to `name` member, its
    length is computed by invoking the `sizeof` function and that length of string
    is supplied to the `fgets` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a null character to the string, if one is not already there, to terminate
    the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display data assigned to the `orderid` and `name` members of the structure to
    verify that there is no buffer overflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following program defines a structure consisting of two members and explains
    how a buffer overflow can be avoided while entering data through the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the program, the `fgets` function takes input from the standard input device
    and the maximum number of characters that will be read from the input device will
    be equal to the number of bytes allowed in the `name` variable of the `user1`
    structure. As a result, even if the user enters a larger string, only the specified
    number of bytes from the input will be picked up; that is, only the first 10 characters
    in the input will be picked up and assigned to the `name` member of the `user1`
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: The `fgets` function appends the null character (`\0`) to the string, provided
    the number of characters entered is one less than the maximum length specified
    in the function. But for the string that is larger than the specified length,
    we need to insert the null character at the end of the string. To do so, we need
    to check if the newline character is there as the last character of the string.
    If yes, then we replace the newline character in the string with the null character
    to terminate the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `getssolved.c` program. If you get no errors
    or warnings, it means the `getssolved.c` program has compiled into an executable
    file: `getssolved.exe`. Let''s run this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4374252-eb37-4725-a33a-1db7f9bfb903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.2
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the preceding output that the larger text assigned to the `name`
    member of the structure is truncated as per the member's size, hence no buffer
    overflow occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how a vulnerability occurs while copying strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see the vulnerability that might occur while copying
    a string. We will also see how to avoid that vulnerability. We will first define
    a structure consisting of two members. In one of the members, we will be copying
    a text that is larger than its capacity, which will result in overwriting the
    content of another member.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will learn how to avoid this problem.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to understand how a vulnerability occurs while copying a
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a structure consisting of two members, `name` and `orderid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a variable of the structure type defined in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign any integer value to the `orderid` member of the structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `strcpy` function to assign text to the `name` member of the structure.
    In order to generate a buffer overflow, assign a larger text to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display data assigned to the `orderid` and `name` members of the structure to
    confirm if the ambiguous output is generated, which verifies that a buffer overflow
    has occurred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program that shows a vulnerability when copying a string is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To enter the name and order number of a customer, define a structure called
    users with two members, `name` and `orderid`. The `name` member is a character
    array or string of 10 bytes in length, and the `orderid` member is a variable
    of the `int` data type consisting of 2 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: A variable, `user1`, is defined as the `users` structure type; hence, the `user1`
    structure will get two members, `name` and `orderid`. An integer value 101 is
    assigned to the `orderid` member of `user1` structure. Also, a string, `administrator`,
    is assigned to the `name` member of `user1`. Because the string administrator
    is larger than the size of the `name` member, a buffer overflow will occur, overwriting
    the memory of the next memory location, that is, of the `orderid` member. Consequently,
    while displaying the information of the user, though the data in the `name` member
    may appear correctly, the content of `orderid` member will appear incorrectly,
    as its content is overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `strcpyproblem.c` program. If you get no errors
    or warnings, it means the `strcpyproblem.c` program has compiled into an executable
    file: `strcpyproblem.exe`. Let''s run this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9720450c-8077-47f1-b468-e088eac27fa0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.3
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, you can see that because the `name` member is assigned
    a string that is larger than its size, this results in it overwriting the content
    of another member, `orderid`. The content of the `name` member appears the same
    as entered by the user, whereas that of `orderid` is displayed incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to write secure code while copying strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid the buffer overflow that occurs when using the `strcpy` function, simply
    replace the `strcpy` function with the `strncpy` function. `strncpy` will copy
    only the specified number of bytes into the destination string, hence buffer overflows
    don't occur in this function. Let's see how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to make secure code while copying a string:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a structure consisting of two members, `name` and `orderid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a variable of the structure type defined in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign any integer value to the `orderid` member of the structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the length of the `name` member of the structure to find the maximum
    number of characters that it can accommodate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `strncpy` function for copying a text to the `name` member of the
    structure. Pass the length of the `name` member, too, to the `strncpy` function
    to truncate the text if it is larger than the capacity of the `name` member.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a null character to the string, if it is not there already, to terminate
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display data assigned to the `orderid` and `name` members of the structure to
    verify that a buffer overflow does not occur and the same data is displayed as
    was entered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program that is secure enough for copying strings is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, everything is the same as the previous recipe. The point of
    difference is that we invoke the `strncpy` function. When this function is invoked,
    only the `strsize` number of bytes from the administrator text is assigned to
    the `name` member of the `user1` structure. Because `strsize` contains the maximum
    length of the `name` member, no buffer overflow will occur in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we check if the null character, `\0`, exists as the last character
    in the `name` member. If not, then the null character is added at its end to terminate
    the string. On displaying the information of the user, we see that because the
    length of the `name` member is 10, only the first 9 characters from the text `administrator`
    are assigned to the `name` member, followed by a null character. As a result of
    this, the value of the `orderid` member will also appear correctly, exactly the
    same as was entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `strcpysolved.c` program. If you get no errors
    or warnings, it means the `strcpysolved.c` program has compiled into an executable
    file: `strcpysolved.exe`. Let''s run this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b32d2d3-e0db-4caf-a6ab-119f39ed60e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.4
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the preceding output that whatever value is entered for the two
    members, we get exactly the same output.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the errors that occur while formatting strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will understand what kind of error might occur while formatting
    strings. We will also see how to avoid that error. We will define a structure
    consisting of two members, and to one member, we will be assigning a formatted
    string. Let's see what error we come across.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will see how to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to make a program in which an error occurs due to string
    formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a structure consisting of two members, `name` and `orderid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a variable of the structure type defined in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign any integer value to the `orderid` member of the structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `sprintf` function to assign formatted text to the `name` member
    of the structure. In order to generate a buffer overflow, assign a larger text
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display data assigned to the `orderid` and `name` members of the structure to
    confirm if the ambiguous output is generated to verify whether buffer overflow
    has occurred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the program that generates an erroneous output because of
    applying string formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to enter information about the customer's name and the order placed
    by them. So, we define a structure called `users` with two members, `name` and
    `orderid`, where the `name` member is defined as a character array of length 10
    bytes, and the `orderid` member is defined of the int data type consisting of
    2 bytes. A variable, `user1`, is defined of the `users` structure type, hence
    the `user1` structure will get two members, `name` and `orderid`. An integer of
    value `101` is assigned to the `orderid` member of the `user1` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `sprintf` function, a string, `bintuharwani`, is assigned to the `name`
    member of the `user1` structure. The `bintuharwani` string is larger than the
    `name` member, hence a buffer overflow will occur, overwriting the memory of the
    next memory location, that is, the memory of the `orderid` member. So, while displaying
    the information of the user, the name will appear correctly but you will get a
    different or ambiguous value for the `orderid` member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `sprintfproblem.c` program. If you get no errors
    or warnings, it means the `sprintfproblem.c` program has compiled into an executable
    file: `sprintfproblem.exe`. Let''s run this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18cee49a-1d7f-44c9-9e93-0c6e5f435e65.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.5
  prefs: []
  type: TYPE_NORMAL
- en: In the output, you can see that the order number is displayed incorrectly; that
    is, instead of the assigned value, `101`, it displays the value `0`. This is because
    on assigning the `bintuharwani` string to the `name` member, the fact that the
    string is larger in size than the capacity of the `name` member leads to a buffer
    overflow that overwrites the value of the `orderid` member.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to avoid errors while formatting strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `snprintf` function. The `snprintf` function
    will assign the formatted text to the `name` member but will limit the size of
    the string assigned to it. The difference between the `sprintf` and `snprintf`
    functions is that `sprintf` simply assigns the complete formatted text to the
    destination string no matter what its capacity, whereas `snprintf` allows us to
    specify the maximum length of the text that can be assigned to the destination
    string. Therefore, a buffer overflow will not occur as only the specified size
    of the text is assigned to the destination string.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to make a program in which an error occurs due to string
    formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a structure consisting of two members, `name` and `orderid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a variable of the structure type defined in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign any integer value to the `orderid` member of the structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `snprintf` function to assign formatted text to the `name` member
    of the structure. Pass the length of the `name` member to the `snprintf` function,
    as well, to truncate the text if it is larger than the capacity of the `name`
    member.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display data assigned to the `orderid` and `name` members of the structure to verify
    that a buffer overflow does not occur and the same data is displayed as was entered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following program shows how the error related to string formatting can
    be avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To constrain the size of the content assigned to the `name` member of the `user1`
    structure, we will make use of the `snprintf` function. You can see that through
    the `snprintf` function, only the first 10 characters from the text `bintuharwani`
    are assigned to the `name` member. Because the length of the `name` member is
    10, it is capable of storing 10 characters and hence no buffer overflow occurs
    and the value assigned to the `orderid` member will remain intact and undisturbed.
    On displaying the values of the `orderid` and `name` members, both of their values
    will be displayed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `sprintfsolved.c` program. If you get no errors
    or warnings, it means the `sprintfsolved.c` program has compiled into an executable
    file: `sprintfsolved.exe`. Let''s run this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a61c9e8f-fc93-4768-bd4a-38b57a818263.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.6
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, we can see that the extra formatted text that is assigned
    to the `name` member is truncated, hence the correct output of the `name` and
    `orderid` members is displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how vulnerabilities occur while accessing files in C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that you wrote a program to create a text file named `file1.txt`.
    In such programs, a malicious user or hacker might add some soft links to some
    important or sensitive file in the file that you want to create. As a result,
    it will lead to overwriting of the important file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by assuming that some important file by the name of `file2.txt`
    already exists on your computer and contains some sensitive information. Here
    are the steps that a malicious user or hacker can use in your program to create
    a file to overwrite `file2.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: A file pointer is defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The hacker might create a soft link and attach a sensitive file to the file
    that we want to create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file to which we want to write the content. But in reality, the sensitive
    file that is attached to our file will be opened in write-only mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prompt the user to enter the lines of text to be written into the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the lines entered by the user into the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 4* and *5* until the user enters `stop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the file pointed to by the file pointer, `fp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following is the program that a malicious user can use to link some important
    file to the file that you want to create, and hence can overwrite and destroy
    that important file on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A file pointer is defined by the name `fp`. At this stage, a hacker or malicious
    user might invoke the `symlink` function to create a soft link named `file1.txt`
    to the file named `file2.txt`. In this program, `file2.txt` can be replaced by
    the password file or some other sensitive file that the malicious user may want
    to overwrite or destroy.
  prefs: []
  type: TYPE_NORMAL
- en: Because the program is for creating a new file, the program invokes the `fopen`
    function to open `file1.txt` in write-only mode and the opened file will be pointed
    at by `fp`, the file pointer. But because `file1.txt` and `file2.txt` are linked,
    `file2.txt` will be actually opened instead of `file1.txt`, and in write-only
    mode, and will be pointed at by the file pointer, `fp`. The program will terminate
    if the file cannot be opened in write-only mode or some other error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The user is prompted to enter lines of text for the file. The lines entered
    by the user are assigned to the `str` string. The `fputs` function is invoked
    to write the content assigned to the `str` string into the file pointed at by
    the file pointer, `fp`. Consequently, the sensitive file will be overwritten.
    The user can enter as many lines of text as desired and can enter `stop` when
    they are done. So a `while` loop is set to execute that will keep taking lines
    of text from the user and will keep writing them into the file until `stop` is
    entered. Finally, the file pointed to by the file pointer, `fp`,  is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `fileproblem.c` program as shown in the following
    screenshot. If you get no errors or warnings, it means the `fileproblem.c` program has
    compiled into an executable file: `fileproblem.exe`. Let''s run this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf883cc0-f3ab-4093-bd35-8832b53a9a6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.7
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding text will not go into the desired file, `file1.txt`, but will
    overwrite the sensitive file, `file2.txt`, deleting its earlier content, if any.
    If we look at the content of the `file2.txt` file, we will see the content that
    was supposed to be written into `file1.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96d98c10-a207-4c8f-b8b2-98656963c2df.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.8
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's rewrite the program to remove the file vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to avoid vulnerabilities while writing a file in C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The special care we will take in this recipe is that we will unlink all the
    links (if any) to the file that we are going to create. We will also ensure that
    our program does not overwrite any file if it already exists.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to write a program to avoid vulnerabilities while creating
    a file in C:'
  prefs: []
  type: TYPE_NORMAL
- en: A file pointer is defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The hacker might create a soft link and attach a sensitive file to the file
    that we want to create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the links from the file that you want to write in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file using the flags that check whether the file already exists or
    not. If the file exists, it should be overwritten.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Associate the file descriptor with the file stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prompt the user to enter the lines of text to be written into the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the lines entered by the user into the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 5* and *6* until the user enters `stop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the file pointed to by the file pointer, `fp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the program that removes vulnerabilities while creating a
    text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can see in the program that a file pointer is defined by the name `fp`.
    We are expecting that a hacker or malicious user might have created a soft link called `file1.txt`
    to the existing file, `file2.txt`. `file2.txt` is a sensitive file that we don't
    want to be overwritten or destroyed. To make the program free from any vulnerability,
    the `unlink()` function is invoked to remove any links to the `file1.txt`. This
    will avoid overwriting of any sensitive file that might be linked with `file1.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `open` function is invoked to open the file instead of the traditional
    `fopen` function. The `open` function opens the `file1.txt` file in write-only
    mode with the `O_CREAT` and `O_EXCL` flags, which will fail the `open` function
    if the file already exists. This will ensure that no existing sensitive file will
    be overwritten accidentally in case it is linked to `file1.txt`. The `open` function
    will return a file descriptor for the opened file that will be assigned to the
    `ifp` variable.
  prefs: []
  type: TYPE_NORMAL
- en: To work with the file, we need a file stream. So the `fdopen` function is invoked
    to associate a file stream with the `ifp` file descriptor that is generated through
    the `open` function. The `fdopen` function returns a pointer to the file stream
    that is assigned to the file pointer, `fp`. In addition, the `w` mode is used
    in the `fdopen` function because although it opens the file in write mode, it
    will never cause truncation of the file. This makes the program much safer and
    avoids the accidental deletion of any file.
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, the program is the same as the previous program. It asks the user
    to enter certain lines, which are then written in  `file1.txt`. Finally, the file
    pointed to by the file pointer, `fp`, is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `filesolved.c` program, as shown in the following
    screenshot. If you get no errors or warnings, it means the `filesolved.c` program has
    compiled into an executable file: `filesolved.exe`. Let''s run this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78fb48b4-a144-4251-bc2c-a4f0a8456e13.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.9
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify whether the content entered while running the program has gone
    into `file1.txt` or not. To do so, we will open `file1.txt` to see its contents
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93d61213-b17e-450f-86a0-e6ca54bc1c03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.10
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the content entered by the user has gone into `file1.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of `file2.txt` are intact as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb799e9d-66c3-4c79-88a3-854900d7458a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.11
  prefs: []
  type: TYPE_NORMAL
