<html><head></head><body>
		<div><h1 id="_idParaDest-137" class="chapter-number" lang="en-GB"><a id="_idTextAnchor149"/><a id="_idTextAnchor150"/><a id="_idTextAnchor151"/>15</h1>
			<h1 id="_idParaDest-138" lang="en-GB"><a id="_idTextAnchor152"/>How to Test With Multiple Threads</h1>
			<p lang="en-GB">Multi-threading is one of the most difficult aspects of writing software. Something that’s often overlooked is how we can test multiple threads. And can we use TDD to help design software that uses multiple threads? Yes, TDD can help and you’ll find useful and practical guidance in this chapter that will show you how to use TDD with multiple threads.</p>
			<p lang="en-GB">The main topics in this chapter are as follows:</p>
			<ul>
				<li lang="en-GB">Using multiple threads in tests</li>
				<li lang="en-GB">Making the logging library thread-safe</li>
				<li lang="en-GB">The need to justify multiple threads</li>
				<li lang="en-GB">Changing the service return type</li>
				<li lang="en-GB">Making multiple service calls</li>
				<li lang="en-GB">How to test multiple threads without sleep</li>
				<li lang="en-GB">Fixing one last problem detected with logging</li>
			</ul>
			<p lang="en-GB">First, we’ll examine what problems you’ll find when using multiple threads in your tests. You’ll learn how to use a special helper class in the testing library to simplify the extra steps needed when testing with multiple threads.</p>
			<p lang="en-GB">Once we can use multiple threads inside of a test, we’ll use that ability to call into the logging library from multiple threads at the same time and see what happens. I’ll give you a hint: some changes will need to be made to the logging library to make the library behave well when called from multiple threads.</p>
			<p lang="en-GB">Then, we’ll go back to the simple service we developed in the previous chapter and you’ll learn how to use TDD to design a service that uses multiple threads in a way that can support reliable testing.</p>
			<p lang="en-GB">We’ll be working with each project in turn in this chapter. First, we will be using the testing library project. Then, we’ll switch over to the logging library project. Finally, we’ll use the simple service project.</p>
			<h1 id="_idParaDest-139" lang="en-GB"><a id="_idTextAnchor153"/>Technical requirements</h1>
			<p lang="en-GB">All the code in this chapter uses standard C++, which builds on any modern C++ 20 or later compiler and standard library. The code in this chapter uses all three projects developed in this book: the testing library from <em class="italic" lang="">Part 1</em>, <em class="italic" lang="">Testing MVP</em>, the logging library from <em class="italic" lang="">Part 2</em>, <em class="italic" lang="">Logging Library</em>, and the simple service from the previous chapter.</p>
			<p lang="en-GB">You can find all the code for this chapter in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</a>.</p>
			<h1 id="_idParaDest-140" lang="en-GB"><a id="_idTextAnchor154"/>Using multiple threads in tests</h1>
			<p lang="en-GB">Adding multiple threads to <a id="_idIndexMarker544"/>your tests presents challenges that you need to be aware of. I’m not talking about running the tests themselves in multiple threads. The testing library registers and runs the tests and it will remain single-threaded. What you need to understand are the problems that can arise when multiple threads are created inside of a test.</p>
			<p lang="en-GB">To understand these problems, let’s create a test that uses multiple threads so that you can see exactly what happens. We’ll be working with the unit test library project in this section so, first, add a new test file called <code>Thread.cpp</code>. The project structure should look like this after you’ve added the new file:</p>
			<pre class="source-code" lang="en-GB">
MereTDD project root folder
    Test.h
    tests folder
        main.cpp
        Confirm.cpp
        Creation.cpp
        Hamcrest.cpp
        Setup.cpp
        Thread.cpp</pre>
			<p lang="en-GB">Inside the <code>Thread.cpp</code> file, add the following code:</p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
#include &lt;atomic&gt;
#include &lt;thread&gt;
using namespace MereTDD;
TEST("Test can use additional threads")
{
    std::atomic&lt;int&gt; count {0};
    std::thread t1([&amp;count]()
    {
        for (int i = 0; i &lt; 100'000; ++i)
        {
            ++count;
        }
        CONFIRM_THAT(count, NotEquals(100'001));
    });
    std::thread t2([&amp;count]()
    {
        for (int i = 0; i &lt; 100'000; ++i)
        {
            --count;
        }
        CONFIRM_THAT(count, NotEquals(-100'001));
    });
    t1.join();
    t2.join();
    CONFIRM_THAT(count, Equals(0));
}</pre>
			<p lang="en-GB">The preceding code includes <code>atomic</code> so that we can safely modify a <code>count</code> variable from multiple threads. We need to include <code>thread</code> to bring in the definition of the thread class. The test creates two threads. The first thread increments <code>count</code>, while the second thread decrements the same <code>count</code>. The final result should return <code>count</code> to zero because we<a id="_idIndexMarker545"/> increment and decrement the same number of times.</p>
			<p lang="en-GB">If you build and run the test application, everything will pass. The new test causes no problem at all. Let’s change the third <code>CONFIRM_THAT</code> macro so that we can try to confirm that <code>count</code> is not equal to <code>0</code> at the end of the test, like so:</p>
			<pre class="source-code" lang="en-GB">
    t1.join();
    t2.join();
    CONFIRM_THAT(count, NotEquals(0));</pre>
			<p lang="en-GB">With this change, the test fails with this result:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test can use additional threads</strong>
<strong class="bold" lang="">Failed confirm on line 30</strong>
<strong class="bold" lang="">    Expected: not 0</strong>
<strong class="bold" lang="">    Actual  : 0</strong></pre>
			<p lang="en-GB">So far, we have a test that uses multiple threads and it works as expected. We added some confirmations that can detect and report when a value does not match the expected value. You might be wondering what problems multiple threads can cause when the threads seem to be working okay so far.</p>
			<p lang="en-GB">Here’s the quick answer: creating one or more threads inside of a test causes no problem at all – that is, assuming that the threads are managed correctly such as making sure they are joined before the test ends. Confirmations work as expected from the main test thread itself. You can even have confirmations inside the additional threads. One type of problem <a id="_idIndexMarker546"/>comes when a confirmation inside one of the additional threads fails. To see this, let’s put the final confirmation back to <code>Equals</code> and change the first confirmation to <code>Equals</code> too, like so:</p>
			<pre class="source-code" lang="en-GB">
        for (int i = 0; i &lt; 100'000; ++i)
        {
            ++count;
        }
        CONFIRM_THAT(count, Equals(100'001));</pre>
			<p lang="en-GB"><code>count</code> should never reach <code>100'001</code> because we only increment <code>100'000</code> times. The confirmation always passed before this change, which is why it did not cause a problem. But with this change, the confirmation will fail right away. If this was a confirmation in the main test thread, then the failure would cause the test to fail with a summary message that describes the problem. But we’re not in the main test thread now.</p>
			<p lang="en-GB">Remember that failed confirmations throw exceptions and that an unhandled exception inside of a thread will terminate an application. When we confirm that the count equals <code>100'001</code>, we cause an exception to be thrown. The main test thread is managed by the testing library and the main thread is ready to catch any confirmation exceptions so that they can be reported. However, our additional thread inside the test lambda has no protection against thrown exceptions. So, when we build and run the test application, it terminates like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test can use additional threads</strong>
<strong class="bold" lang="">terminate called after throwing an instance of 'MereTDD::ActualConfirmException'</strong>
<strong class="bold" lang="">Abort trap: 6</strong></pre>
			<p lang="en-GB">You might get a slightly different message, depending on what computer you’re using. What you won’t get is a test application that runs and reports the results of all the tests. The application terminates soon after the confirmation inside the additional thread fails and throws an exception.</p>
			<p lang="en-GB">Other than confirmations inside a thread failing and throwing exceptions, are there any other problems with <a id="_idIndexMarker547"/>using multiple threads inside of a test? Yes. Threads need to be managed properly – that is, we need to make sure they are either joined or detached before going out of scope. You’re unlikely to need to detach a thread that was created in a test, so you’re left with making sure that all the threads created inside of a test are joined before the test ends. Notice that the test we’re using manually joins both threads.</p>
			<p lang="en-GB">If the test has other confirmations, then you need to be sure that a failed confirmation doesn’t cause the test to skip the thread joins. This is because leaving a test without joining will also cause the application to terminate. Let’s see this by putting the first confirmation back to using <code>NotEquals</code> so that it will not cause any problems. Then, we will add a new confirmation that will fail before the joins:</p>
			<pre class="source-code" lang="en-GB">
    CONFIRM_TRUE(false);
    t1.join();
    t2.join();
    CONFIRM_THAT(count, Equals(0));</pre>
			<p lang="en-GB">The confirmations inside the additional threads no longer cause any problems. However, the new <code>CONFIRM_TRUE</code> confirmation will cause the joins to be skipped. The result is another termination:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test can use additional threads</strong>
<strong class="bold" lang="">terminate called without an active exception</strong>
<strong class="bold" lang="">Abort trap: 6</strong></pre>
			<p lang="en-GB">We’re not going to do anything to help solve this second type of termination. You’ll need to make sure that any threads that are created are joined properly. You might want to use the new <em class="italic" lang="">jthread</em> in C++20, which will make sure that the threads are joined. Alternatively, you might just need to be careful about where you put confirmations in the main test thread to make sure that all the joins happen first.</p>
			<p lang="en-GB">We can remove the <code>CONFIRM_TRUE</code> confirmation now so that we can focus on fixing the first problem of confirmations failing inside the threads.</p>
			<p lang="en-GB">What can we do to<a id="_idIndexMarker548"/> fix this problem? We could put a try/catch block in the thread, which would at least stop the termination:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test can use additional threads")
{
    std::atomic&lt;int&gt; count {0};
    std::thread t([&amp;count]()
    {
        try
        {
            for (int i = 0; i &lt; 100'000; ++i)
            {
                ++count;
            }
            CONFIRM_THAT(count, NotEquals(100'001));
        }
        catch (...)
        { }
    });
    t.join();
    CONFIRM_THAT(count, Equals(100'000));
}</pre>
			<p lang="en-GB">To simplify the code, I removed the second thread. The test now uses a single additional thread to increment the count. The result after the thread finishes is that <code>count</code> should be equal to <code>100'000</code>. At no point should <code>count</code> reach <code>100'001</code>, which is confirmed inside the thread. Let’s say we change the confirmation inside the thread so that it will fail:</p>
			<pre class="source-code" lang="en-GB">
            CONFIRM_THAT(count, Equals(100'001));</pre>
			<p lang="en-GB">Here, the exception is caught and the test fails normally and reports the result. Or does it? Building and running this code shows that all the tests pass. The confirmation inside the thread is detecting the mismatched values but the exception has no way to be reported back to the main test thread. We can’t throw anything inside the catch block because that will just terminate the application again.</p>
			<p lang="en-GB">We know that we can avoid the test application terminating by catching the confirmation exception. And we also know from the first threading test that a confirmation that doesn’t throw is also okay. The bigger problem we need to solve is how to let the main test thread know about any confirmation failures in the additional threads that have been created. Maybe we can inform the main thread in the catch block by using a variable passed to the thread.</p>
			<p lang="en-GB">I want to emphasize this point. If you’re creating threads inside of a test simply to divide the work and speed up a test and don’t need to confirm anything inside the threads, then you don’t need to <a id="_idIndexMarker549"/>do anything special. All you need to manage is the normal thread concerns, such as making sure you join all threads before the test ends and that none of the threads have unhandled exceptions. The only reason to use the following guidance is when you want to put confirmations inside of the additional threads.</p>
			<p lang="en-GB">After trying out a few alternatives, here is what I came up with:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test can use additional threads")
{
    ThreadConfirmException threadEx;
    std::atomic&lt;int&gt; count {0};
    std::thread t([&amp;threadEx, &amp;count]()
    {
        try
        {
            for (int i = 0; i &lt; 100'000; ++i)
            {
                ++count;
            }
            CONFIRM_THAT(count, Equals(100'001));
        }
        catch (ConfirmException const &amp; ex)
        {
            threadEx.setFailure(ex.line(), ex.reason());
        }
    });
    t.join();
    threadEx.checkFailure();
    CONFIRM_THAT(count, Equals(100'000));
}</pre>
			<p lang="en-GB">This is the TDD style. Modify the test until you’re happy with the code and then get it working. The test assumes a new exception type called <code>ThreadConfirmException</code> and it creates a local instance called <code>threadEx</code>. The <code>threadEx</code> variable is captured by reference in the thread lambda so that the thread can access <code>threadEx</code>.</p>
			<p lang="en-GB">The thread can use all the normal confirmations it wants, so long as everything is inside a try block with a catch block that is looking for the <code>ConfirmException</code> type. If a confirmation fails, then it will throw an exception that will be caught. We can use the line number and reason to set a failure mode in the <code>threadEx</code> variable.</p>
			<p lang="en-GB">Once the thread has finished and we’re back in the main thread, we can call another method to check for a <a id="_idIndexMarker550"/>failure in the <code>threadEx</code> variable. If a failure was set, then the <code>checkFailure</code> method should throw an exception, just like how a regular confirmation throws an exception. Because we’re back in the main test thread, any confirmation exception that gets thrown will be detected and reported in the test summary report.</p>
			<p lang="en-GB">Now, we need to implement the <code>ThreadConfirmException</code> class in <code>Test.h</code>, which can go right after the <code>ConfirmException</code> base class, like this:</p>
			<pre class="source-code" lang="en-GB">
class ThreadConfirmException : public ConfirmException
{
public:
    ThreadConfirmException ()
    : ConfirmException(0)
    { }
    void setFailure (int line, std::string_view reason)
    {
        mLine = line;
        mReason = reason;
    }
    void checkFailure () const
    {
        if (mLine != 0)
        {
            throw *this;
        }
    }
};</pre>
			<p lang="en-GB">If we build and run now, then the confirmation inside the thread will detect that <code>count</code> does not equal <code>100'001</code> and the failure will be reported in the summary results, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test can use additional threads</strong>
<strong class="bold" lang="">Failed confirm on line 20</strong>
<strong class="bold" lang="">    Expected: 100001</strong>
<strong class="bold" lang="">    Actual  : 100000</strong></pre>
			<p lang="en-GB">The question now is, is<a id="_idIndexMarker551"/> there any way to simplify the test? The current test looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test can use additional threads")
{
    ThreadConfirmException threadEx;
    std::atomic&lt;int&gt; count {0};
    std::thread t([&amp;threadEx, &amp;count]()
    {
        try
        {
            for (int i = 0; i &lt; 100'000; ++i)
            {
                ++count;
            }
            CONFIRM_THAT(count, Equals(100'001));
        }
        catch (ConfirmException const &amp; ex)
        {
            threadEx.setFailure(ex.line(), ex.reason());
        }
    });
    t.join();
    threadEx.checkFailure();
    CONFIRM_THAT(count, Equals(100'000));
}</pre>
			<p lang="en-GB">Here, we have a new <code>ThreadConfirmException</code> type, which is good. However, the test author still needs to pass an instance of this type to the thread function, similar to how <code>threadEx</code> is captured by the lambda. The thread function still needs a try/catch block and needs to call <code>setFailure</code> if an exception is caught. Finally, the test needs to check for a failure once it’s back in the main test thread. All of these steps are shown in the test.</p>
			<p lang="en-GB">We might be able to use a few macros to hide the try/catch block, but this seems fragile. The test author will likely have slightly different needs. For example, let’s go back to two threads and see<a id="_idIndexMarker552"/> what the test will look like with multiple threads. Change the test so that it looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test can use additional threads")
{
    std::vector&lt;ThreadConfirmException&gt; threadExs(2);
    std::atomic&lt;int&gt; count {0};
    std::vector&lt;std::thread&gt; threads;
    for (int c = 0; c &lt; 2; ++c)
    {
        threads.emplace_back(
            [&amp;threadEx = threadExs[c], &amp;count]()
        {
            try
            {
                for (int i = 0; i &lt; 100'000; ++i)
                {
                    ++count;
                }
                CONFIRM_THAT(count, Equals(200'001));
            }
            catch (ConfirmException const &amp; ex)
            {
                threadEx.setFailure(ex.line(), ex.reason());
            }
        });
    }
    for (auto &amp; t : threads)
    {
        t.join();
    }
    for (auto const &amp; ex: threadExs)
    {
        ex.checkFailure();
    }
    CONFIRM_THAT(count, Equals(200'000));
}</pre>
			<p lang="en-GB">This test is different than the original two-thread test at the beginning of this section. I wrote the test differently to show that there are lots of ways to write a multi-threaded test. Because we have more code inside the thread to handle the confirmation exceptions, I made each thread similar. Instead of one thread incrementing the count while another thread decrements, both threads now increment. Also, instead of naming each thread <code>t1</code> and <code>t2</code>, the new test puts the threads in a vector. We also have a vector of <code>ThreadConfirmException</code> with each thread getting a reference to its own <code>ThreadConfirmException</code>.</p>
			<p lang="en-GB">One thing to notice about this solution is that while each thread will fail its confirmation and both <code>ThreadConfirmationException</code> instances will have a failure set, only one failure will be reported. In the loop at the end of the test that goes through the <code>threadExs</code> collection, the moment one <code>ThreadConfirmationException</code> fails the check, an exception will be thrown. I thought about extending the testing library to support multiple failures but decided against the added complexity.</p>
			<p lang="en-GB">If you have a test <a id="_idIndexMarker553"/>with multiple threads, then they will likely be working with different sets of data. If there happens to be an error that causes multiple threads to fail in the same test run, then only one failure will be reported in the test application. Fixing that failure and running again may then report the next failure. It’s a little tedious to fix problems one after another but not a likely scenario that justifies the added complexity to the testing library.</p>
			<p lang="en-GB">The new test structure with two threads highlights the difficulty of creating reasonable macros that can hide all the thread confirmation handling. So far, all three versions of the test have been different. There doesn’t seem to be a common way to write multi-threaded tests that we would be able to wrap up in some macros. I think we’ll stick with what we have now – a <code>ThreadConfirmException</code> type that can be passed to a thread. The thread will need to catch the <code>ConfirmException</code> type and call <code>setFailure</code>. The main test thread can then check each <code>ThreadConfirmException</code>, which will throw if the failure was set. Before we move on, let’s change the confirmation inside the thread lambda so that it tests for a count not equal to <code>200'001</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
                CONFIRM_THAT(count, NotEquals(200'001));</pre>
			<p lang="en-GB">The <code>NotEquals</code> confirmation will let the test pass again.</p>
			<p lang="en-GB">With the understanding you’ve gained from this section, you’ll be able to write tests that use multiple threads inside the test. You can continue to use the same <code>CONFIRM</code> and <code>CONFIRM_THAT</code> macros to verify the results. The next section will use multiple threads to log messages so that we can make sure that the logging library is thread-safe. You’ll also learn what it means for code to be thread-safe.</p>
			<h1 id="_idParaDest-141" lang="en-GB"><a id="_idTextAnchor155"/>Making the logging library thread-safe</h1>
			<p lang="en-GB">We don’t know if a project that uses the<a id="_idIndexMarker554"/> logging library will be trying to log from multiple threads or a single thread. With an application, we’re in full control and can choose to use multiple threads or not. But a library, especially a logging library, often needs to be <em class="italic" lang="">thread-safe</em>. This means that the logging library needs to behave well when an application uses the library from multiple threads. Making code thread-safe adds some extra overhead to the code and is not needed if the library will only be used from a single thread.</p>
			<p lang="en-GB">What we need is a test that calls <code>log</code> from multiple threads that are all running at the same time. Let’s write a test with the code we have now and see what happens. We’re going to be using the logging project in this section and adding a new file to the <code>tests</code> folder called <code>Thread.cpp</code>. The project structure will look like this with the new file added:</p>
			<pre class="source-code" lang="en-GB">
MereMemo project root folder
    MereTDD folder
        Test.h
    MereMemo folder
        Log.h
        tests folder
            main.cpp
            Construction.cpp
            LogTags.h
            Tags.cpp
            Thread.cpp
            Util.cpp
            Util.h</pre>
			<p lang="en-GB">Inside the <code>Thread.cpp</code> file, let’s add a test that calls <code>log</code> from several threads, like so:</p>
			<pre class="source-code" lang="en-GB">
#include "../Log.h"
#include "Util.h"
#include &lt;MereTDD/Test.h&gt;
#include &lt;thread&gt;
TEST("log can be called from multiple threads")
{
    // We'll have 3 threads with 50 messages each.
    std::vector&lt;std::string&gt; messages;
    for (int i = 0; i &lt; 150; ++i)
    {
        std::string message = std::to_string(i);
        message += " thread-safe message ";
        message += Util::randomString();
        messages.push_back(message);
    }
    std::vector&lt;std::thread&gt; threads;
    for (int c = 0; c &lt; 3; ++c)
    {
        threads.emplace_back(
            [c, &amp;messages]()
        {
            int indexStart = c * 50;
            for (int i = 0; i &lt; 50; ++i)
            {
                MereMemo::log() &lt;&lt; messages[indexStart + i];
            }
        });
    }
    for (auto &amp; t : threads)
    {
        t.join();
    }
    for (auto const &amp; message: messages)
    {
        bool result = Util::isTextInFile(message,              "application.log");
        CONFIRM_TRUE(result);
    }
}</pre>
			<p lang="en-GB">This test does three things. First, it creates <code>150</code> messages. We’ll get the messages ready before we start the threads so that the threads will be able to call <code>log</code> as quickly as possible many times in a loop.</p>
			<p lang="en-GB">Once the messages are ready, the test starts <code>3</code> threads, and each thread will log part of the messages that <a id="_idIndexMarker555"/>have already been formatted. The first thread will log messages <code>0</code> to <code>49</code>. The second thread will log messages <code>50</code> to <code>99</code>. Finally, the third thread will log messages <code>100</code> to <code>149</code>. We don’t do any confirmations in the threads.</p>
			<p lang="en-GB">Once everything has been logged and the threads have been joined, then the test confirms that all <code>150</code> messages appear in the log file.</p>
			<p lang="en-GB">Building and running this will almost certainly fail. This type of test goes against one of the points that makes a good test, as explained in <a href="B18567_08.xhtml#_idTextAnchor074"><em class="italic" lang="">Chapter 8</em></a>, <em class="italic" lang="">What Makes A Good Test?</em> The reason this is not the best type of test is that the test is not completely reproducible. Each time the test application is run, you’ll get a slightly different result. You might even find that this test causes other tests to fail!</p>
			<p lang="en-GB">Even though we’re not basing the behavior of the test on random numbers, we’re using threads. And thread scheduling is unpredictable. The only way to make this test mostly reliable is to log many messages like we’re doing already. The test does everything it can to set the threads up for conflicts. This is why the messages are preformatted. I wanted the threads to immediately go into a loop of logging messages and not spend any extra time formatting messages.</p>
			<p lang="en-GB">When the test fails, it’s because the log file is jumbled. One portion of the log file looks like this for one of my test runs:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-08-16T04:54:54.635 100 thread-safe message 4049</strong>
<strong class="bold" lang="">2022-08-16T04:54:54.635 100 thread-safe message 4049</strong>
<strong class="bold" lang="">2022-08-16T04:54:54.635 0 thread-safe message 8866</strong>
<strong class="bold" lang="">2022-08-16T04:54:54.637 101 thread-safe message 8271</strong>
<strong class="bold" lang="">2022-08-16T04:54:54.637 1 thread-safe message 3205</strong>
<strong class="bold" lang="">2022-08-16T04:54:54.637 102 thread-safe message 7514</strong>
<strong class="bold" lang="">2022-08-16T04:54:54.637 51 thread-safe message 7405</strong>
<strong class="bold" lang="">2022-08-16T04:54:54.637 2 thread-safe message 5723</strong>
<strong class="bold" lang="">2022-08-16T04:54:54.637 52 thread-safe message 4468</strong>
<strong class="bold" lang="">2022-08-16T04:54:54.637 52 thread-safe message 4468</strong></pre>
			<p lang="en-GB">I removed the <code>color</code> and <code>log_level</code> tags so that you can see the messages better. The first thing you’ll notice is that some messages are repeated. Number <code>100</code> appears twice, and number <code>50</code> seems to be missing completely.</p>
			<p lang="en-GB">To be honest, I expected the log file to be even more jumbled than it is. The interleaving between message groups <code>0-49</code> and <code>50-99</code> and <code>100-149</code> is to be expected. We do have three threads running at the same time. For example, once message number <code>51</code> is logged, we should expect to have already seen number <code>50</code>.</p>
			<p lang="en-GB">Let’s fix the logging code to get the test to pass. It still won’t be the best test but it will have a good chance of finding a bug if the logging library is not thread-safe.</p>
			<p lang="en-GB">The fix is simple: we <a id="_idIndexMarker556"/>need a mutex and then we need to lock the mutex. First, let’s include the <code>mutex</code> standard header at the top of <code>Log.h</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include &lt;filesystem&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;ostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">Then, we need a place to place a global mutex. Since the logging library is a single header file, we can’t declare a global variable without getting a linker error. We might be able to declare a global mutex as inline. This is a new feature in C++ that I haven’t used that lets you declare inline variables, just like how we can declare inline functions. I’m more comfortable with a function that uses a static variable. Add the following function to the top of <code>Log.h</code>, right after the opening namespace of <code>MereMemo</code>:</p>
			<pre class="source-code" lang="en-GB">
inline std::mutex &amp; getLoggingMutex ()
{
    static std::mutex m;
    return m;
}</pre>
			<p lang="en-GB">Now, we need to lock the mutex at the proper spot. At first, I added a lock to the <code>log</code> function, but that had no effect. This is because the <code>log</code> function returns a <code>LogStream</code> without actually doing any logging. So, the <code>log</code> function obtained the lock and then released the lock before any logging happened. The logging is done in the <code>LogStream</code> destructor, so that’s where we need to put the lock:</p>
			<pre class="source-code" lang="en-GB">
    ~LogStream ()
    {
        if (not mProceed)
        {
            return;
        }
        const std::lock_guard&lt;std::mutex&gt;               lock(getLoggingMutex());
        auto &amp; outputs = getOutputs();
        for (auto const &amp; output: outputs)
        {
            output-&gt;sendLine(this-&gt;str());
        }
    }</pre>
			<p lang="en-GB">The lock tries to obtain the<a id="_idIndexMarker557"/> mutex and will block if another thread already owns the mutex. Only one thread at a time can proceed after the lock and the lock is released after the text is sent to all the outputs.</p>
			<p lang="en-GB">If we build and run, the threading problem will be fixed. However, when I ran the test application, one of the tests failed. At first, I thought there was still a problem with the threads, but the failure was in another test. This is the test that failed:</p>
			<pre class="source-code" lang="en-GB">
TEST("Overridden default tag not used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(), info);
    std::string message = "message ";
    message += Util::randomString();
    MereMemo::log(debug) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
}</pre>
			<p lang="en-GB">This test has nothing to do with the multiple thread test. So, why did it fail? Well, the problem is that this test is confirming that a particular message does not appear in the log file. But the message is just the word <code>"message "</code>, followed by a random number string. We just added an extra 150 logged messages, which all have the same text followed by a random number string.</p>
			<p lang="en-GB">We have a problem with the tests themselves. The tests can sometimes fail due to random numbers. The problem wasn’t noticed when we had a few log messages but it’s more noticeable now that we have many more chances for duplicate random numbers.</p>
			<p lang="en-GB">We could either increase the size of the random number strings added to each log message or make the tests more specific so that they all use a different base message string.</p>
			<p lang="en-GB">At this point, you might be <a id="_idIndexMarker558"/>wondering why my test has a simple base message when we’ve been using unique messages in each test ever since the logging library was first created in <a href="B18567_09.xhtml#_idTextAnchor085"><em class="italic" lang="">Chapter 9</em></a>, <em class="italic" lang="">Using Tests</em>. That’s because the code starting in <a href="B18567_09.xhtml#_idTextAnchor085"><em class="italic" lang="">Chapter 9</em></a>, <em class="italic" lang="">Using Tests</em>, originally did have simple, common log messages. I could have left those common messages as-is and waited until now to have you go back and change all of them. However, I edited the chapters to fix the problem from the beginning. It seems like a waste to go through all the tests now just to change a string. Therefore, I added an explanation to <a href="B18567_09.xhtml#_idTextAnchor085"><em class="italic" lang="">Chapter 9</em></a>, <em class="italic" lang="">Using Tests</em>. We don’t need to change any of the test messages now because they’ve already been fixed.</p>
			<p lang="en-GB">Okay, back to the threading – the new test passes now and the sample from the log file looks much better:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-08-16T06:20:36.807 0 thread-safe message 6269</strong>
<strong class="bold" lang="">2022-08-16T06:20:36.807 50 thread-safe message 1809</strong>
<strong class="bold" lang="">2022-08-16T06:20:36.807 100 thread-safe message 6297</strong>
<strong class="bold" lang="">2022-08-16T06:20:36.808 1 thread-safe message 848</strong>
<strong class="bold" lang="">2022-08-16T06:20:36.808 51 thread-safe message 4103</strong>
<strong class="bold" lang="">2022-08-16T06:20:36.808 101 thread-safe message 5570</strong>
<strong class="bold" lang="">2022-08-16T06:20:36.808 2 thread-safe message 6156</strong>
<strong class="bold" lang="">2022-08-16T06:20:36.809 102 thread-safe message 4213</strong>
<strong class="bold" lang="">2022-08-16T06:20:36.809 3 thread-safe message 6646</strong></pre>
			<p lang="en-GB">Again, this sample has been modified to remove the <code>color</code> and <code>log_level</code> tags. This change makes each line shorter so that you can see the messages better. The messages within each thread are ordered, even though the messages are mixed between threads – that is, message number <code>0</code> is followed at some point by message number <code>1</code> and then by number <code>2</code>; message number <code>50</code> is followed later by number <code>51</code>, and message number <code>100</code> is followed by number <code>101</code>. Each following numbered message might not immediately follow the previous message. This sample looks better because there are no duplicates and no missing messages.</p>
			<p lang="en-GB">One final thought is about the thread-safety of the logging library. We tested that multiple threads <a id="_idIndexMarker559"/>can all safely call <code>log</code> without worrying about problems. But we didn’t test if multiple threads can manage default tags or filtering, or add new outputs. The logging library will likely need more work to be fully thread-safe. It will work for our purposes for now.</p>
			<p lang="en-GB">Now that the logging library is mostly thread-safe, the next section will go back to the <code>SimpleService</code> project and begin exploring how to test code that uses multiple threads.</p>
			<h1 id="_idParaDest-142" lang="en-GB"><a id="_idTextAnchor156"/>The need to justify multiple threads</h1>
			<p lang="en-GB">So far in this chapter, you’ve<a id="_idIndexMarker560"/> learned how to write tests that use multiple threads and how to use these extra threads to test the logging library. The logging library doesn’t use multiple threads itself, but we needed to make sure that the logging library is safe to use with multiple threads.</p>
			<p lang="en-GB">The remainder of this chapter will provide some guidance on how to test code that does use multiple threads. To test multi-threaded code, we need some code that uses multiple threads. For this, we’ll use the <code>SimpleService</code> project from the previous chapter.</p>
			<p lang="en-GB">We need to modify the simple service so that it uses multiple threads. Right now, the simple service is an example of a greeting service that responds to a greeting request with a reply based on the user making the request being identified. There’s not much of a need for multiple threads in a greeting service. We’re going to need something different.</p>
			<p lang="en-GB">This brings us to the first guidance: we need to make sure there is a valid need for multiple threads before we try to add multiple threads. Writing multi-threaded code is hard and should be avoided if only a single thread is needed. If you only need a single thread, then make sure that you follow the advice from the previous section and make your code thread-safe if it will be used by multiple threads.</p>
			<p lang="en-GB">What you want to do is write as much of your code as possible so that it’s single-threaded. If you can identify a particular way to calculate a result that only needs some input data to arrive at an output, then make that a single-threaded calculation if possible. If the amount of input data is large and can be divided and calculated separately, then break up the input and pass smaller pieces to your calculation. Keep the calculation single-threaded and focused on working with the input provided. Then, you can create multiple threads where each thread is given a portion of the input data to calculate. This will separate your multi-threaded code from your calculations.</p>
			<p lang="en-GB">Isolating your single-threaded code will let you design and test the code without you having to worry about thread management. Sure, you might need to make sure the code is thread-safe, but that’s easier when thread-safety is all you need to worry about.</p>
			<p lang="en-GB">Testing multiple<a id="_idIndexMarker561"/> threads is harder because of the randomness of the thread scheduling. If possible, try to avoid clunky methods such as <em class="italic" lang="">sleeping</em> to coordinate tests. You want to avoid putting actual code threads to sleep to coordinate the order between threads. When a thread goes to sleep, it stops running for a while, depending on how long of a delay is specified in the sleep call. Other threads that are not sleeping can then be scheduled to run.</p>
			<p lang="en-GB">We’ll design the code in this chapter to let the test control the thread’s synchronization so that we can remove the randomness and make the tests predictable. Instead of starting this section with a test, let’s look at a modified service that has a reason to use multiple threads. The modified <code>handleRequest</code> method looks like this:</p>
			<pre class="source-code" lang="en-GB">
std::string SimpleService::Service::handleRequest (
    std::string const &amp; user,
    std::string const &amp; path,
    std::string const &amp; request)
{
    MereMemo::log(debug, User(user), LogPath(path))
        &lt;&lt; "Received: " &lt;&lt; Request(request);
    std::string response;
    if (request == "Calculate")
    {
        response = "token";
    }
    if (request == "Status")
    {
        response = "result";
    }
    else
    {
        response = "Unrecognized request.";
    }
    MereMemo::log(debug, User(user), LogPath(path))
        &lt;&lt; "Sending: " &lt;&lt; Response(response);
    return response;
}</pre>
			<p lang="en-GB">When following TDD, you’ll normally want to start with tests first. So, why am I showing you a modified service first? Because our goal is to test multi-threaded code. In your projects, you should avoid the desire to use some technology without having a good reason. Our reason<a id="_idIndexMarker562"/> is that we need an example to learn from. So, we’re starting with a backward need to use multi-threading.</p>
			<p lang="en-GB">I tried to think of a good reason for a greeting service to use multiple threads and nothing came to mind. So, we’re going to change the service to something a little more complicated; I want to explain this new idea before we begin writing tests.</p>
			<p lang="en-GB">The new service is still as simple as I can make it. We’ll continue ignoring all the networking and message routing. We’ll need to change the request and response types to structs and we’ll continue to ignore serializing the data structs for transmission to and from the service.</p>
			<p lang="en-GB">The new service will simulate the calculation of a difficult problem. One valid reason to create a new thread is to let the new thread perform some work while the original thread continues what it was doing. The idea of the new service is that a <code>Calculate</code> request can take a long time to complete and we don’t want the caller to time out while waiting for the result. So, the service will create a new thread to perform the calculation and immediately return a token to the caller. The caller can use this token to call back into the service with a different <code>Status</code> request, which will check on the progress of the calculation that was just begun. If the calculation is not done yet, then the response to the <code>Status</code> request will let the caller know approximately how much has been completed. If the calculation is done, then the response will contain the answer.</p>
			<p lang="en-GB">We now have a justification for multiple threads and can write some tests. Let’s take care of an unrelated test that should have been added already. We want to make sure that anybody calling the service with an unrecognized request will get an unrecognized response. Put the following test in the <code>Message.cpp</code> file in the <code>tests</code> folder of the <code>SimpleService</code> project:</p>
			<pre class="source-code" lang="en-GB">
TEST_SUITE("Unrecognized request is handled properly", "Service 1")
{
    std::string user = "123";
    std::string path = "";
    std::string request = "Hello";
    std::string expectedResponse = "Unrecognized request.";
    std::string response = gService1.service().handleRequest(
        user, path, request);
    CONFIRM_THAT(response, Equals(expectedResponse));
}</pre>
			<p lang="en-GB">I put this test at the top of <code>Message.cpp</code>. All it does is send the previous greeting request but with an unrecognized expected response.</p>
			<p lang="en-GB">Let’s also change the name<a id="_idIndexMarker563"/> of the test suite to <code>"Calculation Service"</code> like this in <code>SetupTeardown.cpp</code>:</p>
			<pre class="source-code" lang="en-GB">
MereTDD::TestSuiteSetupAndTeardown&lt;ServiceSetup&gt;
gService1("Calculation Service", "Service 1");</pre>
			<p lang="en-GB">Now, let’s remove the greeting test and add the following simple test, which makes sure we get something other than the unrecognized response:</p>
			<pre class="source-code" lang="en-GB">
TEST_SUITE("Calculate request can be sent and recognized", "Service 1")
{
    std::string user = "123";
    std::string path = "";
    std::string request = "Calculate";
    std::string unexpectedResponse = "Unrecognized request.";
    std::string response = gService1.service().handleRequest(
        user, path, request);
    CONFIRM_THAT(response, NotEquals(unexpectedResponse));
}</pre>
			<p lang="en-GB">This test is the opposite of the unrecognized test and makes sure that the response is something other than unrecognized. Normally, it’s better to confirm that a result matches what you expect to happen instead of confirming that a result is not what you don’t expect. A double negative is not only harder to think about, but can lead to problems because it’s not possible to catch all the ways something can go wrong. By confirming what you want to happen, you can eliminate all the possible error conditions, which are too many to catch individually.</p>
			<p lang="en-GB">This test is a little<a id="_idIndexMarker564"/> different, though. We’re not interested in the response. The test only intends to confirm that the request was recognized. Confirming that the response is not unrecognized is appropriate, even though it seems similar to the double negative trap we just described.</p>
			<p lang="en-GB">Building and running this code shows that the unrecognized test passes but the <code>Calculate</code> request fails:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Service 1</strong>
<strong class="bold" lang="">------- Setup: Calculation Service</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Unrecognized request is handled properly</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Calculate request can be sent and recognized</strong>
<strong class="bold" lang="">Failed confirm on line 30</strong>
<strong class="bold" lang="">    Expected: not Unrecognized request.</strong>
<strong class="bold" lang="">    Actual  : Unrecognized request.</strong>
<strong class="bold" lang="">------- Teardown: Calculation Service</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 3</strong>
<strong class="bold" lang="">Tests failed: 1</strong></pre>
			<p lang="en-GB">It seems that we’re getting an unrecognized response for a request that should be valid. This is the value of adding simple tests at the beginning of a project. The tests help catch simple errors right away. The problem is in the <code>handleRequest</code> method. I added the second check for a valid request by copying the first check and forgot to change the <code>if</code> statement to an <code>else if</code> statement. The fix for this is as follows:</p>
			<pre class="source-code" lang="en-GB">
    if (request == "Calculate")
    {
        response = "token";
    }
    else if (request == "Status")
    {
        response = "result";
    }
    else
    {
        response = "Unrecognized request.";
    }</pre>
			<p lang="en-GB">To continue further, we’re going to send and receive more than strings. When we send a <code>Calculate</code> request, we should get back a token value that we can pass to the <code>Status</code> request. The <code>Status</code> response should then contain either the answer or an estimate of how much progress has been <a id="_idIndexMarker565"/>made. Let’s take this one step at a time and define the <code>Calculate</code> request and response structures. Add the following two struct definitions to the top of <code>Service.h</code> inside the <code>SimpleService</code> namespace:</p>
			<pre class="source-code" lang="en-GB">
struct CalculateRequest
{
    int mSeed;
};
struct CalculateResponse
{
    std::string mToken;
};</pre>
			<p lang="en-GB">This will let us pass some initial value to be calculated; in return, we will get a token that we can use to eventually get the answer. But we have a problem. If the <code>Calculate</code> request is changed to return a struct, then that will break the existing test, which expects a string. We should change the tests so that they use the structs, but that leads to another problem: most of the time, we need to return the correct response struct. And we need to return an error response for error cases.</p>
			<p lang="en-GB">What we need is a response that can represent both a good response and an error response. Since we’re going to have a response that can serve multiple purposes, why not let it also handle a struct for the <code>Status</code> response? This means we’ll have a single response type that can be either an error response, a calculate response, or a status response. And since we have a multi-purpose response type, why not create a multi-purpose request type? Let’s change the tests.</p>
			<p lang="en-GB">We’re going to use <code>std::variant</code> to hold the different types of requests and responses. We can remove the test that sent a request string that was not valid. We can still get an invalid request but only with mismatched service versions between the caller and the service. That’s a little more involved, so we’ll ignore the possibility that a service can be called with a different idea of what requests are available than the service knows about. If you’re writing a real service, then this is a possibility that needs to be addressed and tested. You’ll probably want to use something different than a variant too. A good choice would be something such as Google’s <em class="italic" lang="">Protocol Buffers</em>, where the service would accept <a id="_idIndexMarker566"/>Protocol Buffer messages. While using Protocol Buffers is a better choice than simple structs, the design is also a lot more complicated and would make this explanation much longer.</p>
			<p lang="en-GB">We’ll have a single test in <code>Message.cpp</code> that will look like this:</p>
			<pre class="source-code" lang="en-GB">
TEST_SUITE("Calculate request can be sent", "Service 1")
{
    std::string user = "123";
    std::string path = "";
    SimpleService::RequestVar request =
        SimpleService::CalculateRequest {
            .mSeed = 5
        };
    std::string emptyResponse = "";
    std::string response = gService1.service().handleRequest(
        user, path, request);
    CONFIRM_THAT(response, NotEquals(emptyResponse));
}</pre>
			<p lang="en-GB">This test focuses on the request type first and leaves the response type as a string. We’ll make the changes one step at a time. This is especially good advice when working with <code>std::variant</code> because it can be challenging if you’re not familiar with variants. We’ll have a variant type called <code>RequestVar</code> that can be initialized with a specific request type. We’re initializing the request with a <code>CalculateRequest</code> and using the <em class="italic" lang="">designated initializer</em> syntax to set the <code>mSeed</code> value. The designated initializer syntax is fairly new to C++. It lets us set data member values based on the name by putting a dot in front of the data member’s name.</p>
			<p lang="en-GB">Now, let’s define the request types in <code>Service.h</code>:</p>
			<pre class="source-code" lang="en-GB">
#ifndef SIMPLESERVICE_SERVICE_H
#define SIMPLESERVICE_SERVICE_H
#include &lt;string&gt;
#include &lt;variant&gt;
namespace SimpleService
{
struct CalculateRequest
{
    int mSeed;
};
struct StatusRequest
{
    std::string mToken;
};
using RequestVar = std::variant&lt;
    CalculateRequest,
    StatusRequest
    &gt;;</pre>
			<p lang="en-GB">Note that we need to include the standard <code>variant</code> header file. The <code>RequestVar</code> type can now only be either a <code>CalculateRequest</code> or a <code>StatusRequest</code>. We need to make one more change in <code>Service.h</code> to the <code>handleRequest</code> method in the <code>Service</code> class:</p>
			<pre class="source-code" lang="en-GB">
class Service
{
public:
    void start ();
    std::string handleRequest (std::string const &amp; user,
        std::string const &amp; path,
        RequestVar const &amp; request);
};</pre>
			<p lang="en-GB">The <code>Service.cpp</code> file <a id="_idIndexMarker567"/>needs to be changed so that it updates the <code>handleRequest</code> method, like this:</p>
			<pre class="source-code" lang="en-GB">
std::string SimpleService::Service::handleRequest (
    std::string const &amp; user,
    std::string const &amp; path,
    RequestVar const &amp; request)
{
    std::string response;
    if (auto const * req = std::get_       if&lt;CalculateRequest&gt;(&amp;request))
    {
        MereMemo::log(debug, User(user), LogPath(path))
            &lt;&lt; "Received Calculate request for: "
            &lt;&lt; std::to_string(req-&gt;mSeed);
        response = "token";
    }
    else if (auto const * req = std::get_            if&lt;StatusRequest&gt;(&amp;request))
    {
        MereMemo::log(debug, User(user), LogPath(path))
            &lt;&lt; "Received Status request for: "
            &lt;&lt; req-&gt;mToken;
        response = "result";
    }
    else
    {
        response = "Unrecognized request.";
    }
    MereMemo::log(debug, User(user), LogPath(path))
        &lt;&lt; "Sending: " &lt;&lt; Response(response);
    return response;
}</pre>
			<p lang="en-GB">The updated <code>handleRequest</code> method continues to check for an unknown request type. All the responses are strings that will need to change. We’re not looking at the seed or token values yet, but <a id="_idIndexMarker568"/>we have enough that can be built and tested.</p>
			<p lang="en-GB">Now that the single test passes, in the next section, we will look at the responses and use structs instead of response strings.</p>
			<h1 id="_idParaDest-143" lang="en-GB"><a id="_idTextAnchor157"/>Changing the service return type</h1>
			<p lang="en-GB">We’ll be making a similar change in<a id="_idIndexMarker569"/> this section to move away from strings and use a struct in the service request handling. The previous section changed the service request type; this section will change the service return type. We need to make these changes so that we can get the service to a level of functionality where it can support the need for an additional thread.</p>
			<p lang="en-GB">The <code>SimpleService</code> project that we’re using started as a greeting service and I could not think of any reason for such a simple service to need another thread. We started adapting the service to a calculation service in the previous section; now, we need to modify the return types that the service returns when handling requests.</p>
			<p lang="en-GB">First, let’s define the return <a id="_idIndexMarker570"/>type structs in <code>Service.h</code>, which come right after the request types. Add the following code to <code>Service.h</code>:</p>
			<pre class="source-code" lang="en-GB">
struct ErrorResponse
{
    std::string mReason;
};
struct CalculateResponse
{
    std::string mToken;
};
struct StatusResponse
{
    bool mComplete;
    int mProgress;
    int mResult;
};
using ResponseVar = std::variant&lt;
    ErrorResponse,
    CalculateResponse,
    StatusResponse
    &gt;;</pre>
			<p lang="en-GB">These structs and the variant are following the same pattern that was used for the requests. One small difference is that we now have an <code>ErrorResponse</code> type, which will be returned for any errors. We can modify the test in <code>Message.cpp</code> so that it looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST_SUITE("Calculate request can be sent", "Service 1")
{
    std::string user = "123";
    std::string path = "";
    SimpleService::RequestVar request =
        SimpleService::CalculateRequest {
            .mSeed = 5
        };
    auto const responseVar = gService1.service().handleRequest(
        user, path, request);
    auto const response =
        std::get_if&lt;SimpleService::CalculateResponse&gt;(&amp;responseVar);
    CONFIRM_TRUE(response != nullptr);
}</pre>
			<p lang="en-GB">This test will call the service as it did previously with a calculate request; the response that comes back is tested to see if it is a calculate response.</p>
			<p lang="en-GB">For the code to compile, we<a id="_idIndexMarker571"/> need to change the <code>handleRequest</code> declaration in <code>Service.h</code> so that it returns the new type, like this:</p>
			<pre class="source-code" lang="en-GB">
class Service
{
public:
    void start ();
    
    ResponseVar handleRequest (std::string const &amp; user,
        std::string const &amp; path,
        RequestVar const &amp; request);
};</pre>
			<p lang="en-GB">Then, we need to change the implementation of <code>handleRequest</code> in <code>Service.cpp</code>:</p>
			<pre class="source-code" lang="en-GB">
SimpleService::ResponseVar SimpleService::Service::handleRequest (
    std::string const &amp; user,
    std::string const &amp; path,
    RequestVar const &amp; request)
{
    ResponseVar response;
    if (auto const * req = std::get_       if&lt;CalculateRequest&gt;(&amp;request))
    {
        MereMemo::log(debug, User(user), LogPath(path))
            &lt;&lt; "Received Calculate request for: "
            &lt;&lt; std::to_string(req-&gt;mSeed);
        response = SimpleService::CalculateResponse {
            .mToken = "token"
        };
    }
    else if (auto const * req = std::get_            if&lt;StatusRequest&gt;(&amp;request))
    {
        MereMemo::log(debug, User(user), LogPath(path))
            &lt;&lt; "Received Status request for: "
            &lt;&lt; req-&gt;mToken;
        response = SimpleService::StatusResponse {
            .mComplete = false,
            .mProgress = 25,
            .mResult = 0
        };
    }
    else
    {
        response = SimpleService::ErrorResponse {
            .mReason = "Unrecognized request."
        };
    }
    return response;
}</pre>
			<p lang="en-GB">The code is getting a little more complicated. I removed the log at the end, which was used to log the response before returning. We could put the log back in but that would require the ability to convert a <code>ResponseVar</code> into a string. Alternatively, we would need to log the response in multiple places like the code does for the request. That’s a detail that we can skip.</p>
			<p lang="en-GB">The new <code>handleRequest</code> method does almost the same things it used to do except that it now initializes a <code>ResponseVar</code> type instead of returning a string. This allows us to return different types with<a id="_idIndexMarker572"/> more detailed information than before when we were returning a string for both the requests and the error.</p>
			<p lang="en-GB">To add a test for an unrecognized request, we would need to add a new request type to <code>RequestVar</code> but ignore the new request type in the <code>if</code> statements inside the <code>handleRequest</code> method. We’re going to skip that test too because we really should be using something other than a <code>std::variant</code>.</p>
			<p lang="en-GB">The only reason we’re using <code>std::variant</code> for this example is to avoid extra complexity. We’re trying to get the code ready to support another thread.</p>
			<p lang="en-GB">In the next section, we will add a test that uses both request types. The first request will begin a calculation, while the <a id="_idIndexMarker573"/>second request will check the status of the calculation and get the result when the calculation is complete.</p>
			<h1 id="_idParaDest-144" lang="en-GB"><a id="_idTextAnchor158"/>Making multiple service calls</h1>
			<p lang="en-GB">If you’re considering using<a id="_idIndexMarker574"/> multiple threads to speed up a calculation, then I recommend that you get the code tested and working with a single thread before taking on the additional complexity of multiple threads.</p>
			<p lang="en-GB">For the service we’re working on, the reason to add a second thread is not to increase the speed of anything. We need to avoid a timeout for a calculation that might take a long time. The additional thread we’re going to add is not designed to make the calculation any faster. Once we get the calculation working with one additional thread, we can consider adding more threads to speed up the calculation.</p>
			<p lang="en-GB">The need to create a thread to do some work while the original thread continues with something else is common. This is not an optimization that should be done later. This is part of the design and the additional thread should be included from the very beginning.</p>
			<p lang="en-GB">Let’s begin by adding a new test to <code>Message.cpp</code> that looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST_SUITE("Status request generates result", "Service 1")
{
    std::string user = "123";
    std::string path = "";
    SimpleService::RequestVar calcRequest =
        SimpleService::CalculateRequest {
            .mSeed = 5
        };
    auto responseVar = gService1.service().handleRequest(
        user, path, calcRequest);
    auto const calcResponse =
        std::get_if&lt;SimpleService::CalculateResponse&gt;        (&amp;responseVar);
    CONFIRM_TRUE(calcResponse != nullptr);
    SimpleService::RequestVar statusRequest =
        SimpleService::StatusRequest {
            .mToken = calcResponse-&gt;mToken
        };
    int result {0};
    for (int i = 0; i &lt; 5; ++i)
    {
        responseVar = gService1.service().handleRequest(
            user, path, statusRequest);
        auto const statusResponse =
            std::get_if&lt;SimpleService::StatusResponse&gt;            (&amp;responseVar);
        CONFIRM_TRUE(statusResponse != nullptr);
        if (statusResponse-&gt;mComplete)
        {
            result = statusResponse-&gt;mResult;
            break;
        }
    }
    CONFIRM_THAT(result, Equals(50));
}</pre>
			<p lang="en-GB">All the code is already in place <a id="_idIndexMarker575"/>for this new test to compile. Now, we can run the tests to see what happens. The test will fail, as follows:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Service 1</strong>
<strong class="bold" lang="">------- Setup: Calculation Service</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Calculate request can be sent</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Status request generates result</strong>
<strong class="bold" lang="">Failed confirm on line 62</strong>
<strong class="bold" lang="">    Expected: 50</strong>
<strong class="bold" lang="">    Actual  : 0</strong>
<strong class="bold" lang="">------- Teardown: Calculation Service</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 3</strong>
<strong class="bold" lang="">Tests failed: 1</strong></pre>
			<p lang="en-GB">What does the test do? First, it creates a calculate request l and gets back a hardcoded token value. There is no calculation for when the service begins yet, so when we make a status request with the token, the service responds with a hardcoded response that says the calculation is not done yet. The test is looking for a status response that says the calculation is complete. The test tries making a status request five times before giving up, which causes the confirmation at the end of the test to fail because we didn’t get the expected result. Note that even trying multiple times is not the best way to proceed. Threads are unpredictable and <a id="_idIndexMarker576"/>your computer may make all five attempts before the service can complete the request. You might need to increase the number of attempts if your test continues to fail or wait for a reasonable amount of time. Our calculation will eventually multiply the seed by <code>10</code>. So, when we give an initial seed of <code>5</code>, we should expect a final result of <code>50</code>.</p>
			<p lang="en-GB">We need to implement the calculation and status request handling in the service so that we can use a thread to get the test to pass. The first thing we need to do is include <code>mutex</code>, <code>thread</code>, and <code>vector</code> at the top of <code>Service.cpp</code>. We also need to add an unnamed namespace, like this:</p>
			<pre class="source-code" lang="en-GB">
#include "Service.h"
#include "LogTags.h"
#include &lt;MereMemo/Log.h&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
namespace
{
}</pre>
			<p lang="en-GB">We’re going to need some locking so that we don’t try to read the calculation status while the status is being updated by a thread. To do the synchronization, we’ll use a mutex and a lock, as we did in the logging library. There are other designs you might want to explore, such as locking data for different calculation requests separately. We’re going to use a simple approach and have a single lock for everything. Add the following function inside the unnamed namespace:</p>
			<pre class="source-code" lang="en-GB">
    std::mutex &amp; getCalcMutex ()
    {
        static std::mutex m;
        return m;
    }</pre>
			<p lang="en-GB">We need something to keep track of the completion status, the progress, and the result for each calculation request. We’ll create a class to hold this information called <code>CalcRecord</code> inside the <a id="_idIndexMarker577"/>unnamed namespace, right after the <code>getCalcMutex</code> function, like this:</p>
			<pre class="source-code" lang="en-GB">
    class CalcRecord
    {
    public:
        CalcRecord ()
        { }
        CalcRecord (CalcRecord const &amp; src)
        {
            const std::lock_guard&lt;std::mutex&gt;                   lock(getCalcMutex());
            mComplete = src.mComplete;
            mProgress = src.mProgress;
            mResult = src.mResult;
        }
        void getData (bool &amp; complete, int &amp; progress, int &amp;                      result)
        {
            const std::lock_guard&lt;std::mutex&gt;                   lock(getCalcMutex());
            complete = mComplete;
            progress = mProgress;
            result = mResult;
        }
        void setData (bool complete, int progress, int result)
        {
            const std::lock_guard&lt;std::mutex&gt;                   lock(getCalcMutex());
            mComplete = complete;
            mProgress = progress;
            mResult = result;
        }
        CalcRecord &amp;
        operator = (CalcRecord const &amp; rhs) = delete;
    private:
        bool mComplete {false};
        int mProgress {0};
        int mResult {0};
    };</pre>
			<p lang="en-GB">It looks like there’s a lot more to this class, but it’s fairly simple. The default constructor doesn’t need to do anything because the data members already define their default values. The only reason we need a default constructor is that we also have a copy constructor. And the only reason we need a copy constructor is so that we can lock the mutex before copying the data members.</p>
			<p lang="en-GB">Then, we have a method to get the data members all at once and another method to set the data members. Both the <a id="_idIndexMarker578"/>getter and the setter need to acquire the lock before proceeding.</p>
			<p lang="en-GB">There should be no need to assign one <code>CalcRecord</code> to another, so the assignment operator has been deleted.</p>
			<p lang="en-GB">The last thing we need in the unnamed namespace is a vector of <code>CalcRecord</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
    std::vector&lt;CalcRecord&gt; calculations;</pre>
			<p lang="en-GB">We’re going to add a <code>CalcRecord</code> to the <code>calculations</code> collection every time a calculation request is made. A real service would want to clean up or reuse <code>CalcRecord</code> entries.</p>
			<p lang="en-GB">We need to modify the request handling in <code>Service.cpp</code> so that a thread gets created to use a new <code>CalcRecord</code> every time we get a calculation request, like this:</p>
			<pre class="source-code" lang="en-GB">
    if (auto const * req = std::get_       if&lt;CalculateRequest&gt;(&amp;request))
    {
        MereMemo::log(debug, User(user), LogPath(path))
            &lt;&lt; "Received Calculate request for: "
            &lt;&lt; std::to_string(req-&gt;mSeed);
        calculations.emplace_back();
        int calcIndex = calculations.size() - 1;
        std::thread calcThread([calcIndex] ()
        {
            calculations[calcIndex].setData(true, 100, 50);
        });
        calcThread.detach();
        response = SimpleService::CalculateResponse {
            .mToken = std::to_string(calcIndex)
        };
    }</pre>
			<p lang="en-GB">What happens when we get a calculation request? First, we add a new <code>CalcRecord</code> to the end of the <code>calculations</code> vector. We’ll use the index of <code>CalcRecord</code> as the token that gets returned in the response. This is the simplest design I could think of to identify a calculation request. A <a id="_idIndexMarker579"/>real service would want to use a more secure token. The request handler then starts a thread to do the calculation and detaches from the thread.</p>
			<p lang="en-GB">Most threading code that you’ll write will create a thread and then join the thread. It’s not very common to create a thread and then detach from the thread. Alternatively, you can use a pool of threads when you want to do some work and not worry about joining. The reason for detaching is that I wanted the most simple example without bringing in thread pools.</p>
			<p lang="en-GB">The thread itself is very simple because it immediately sets <code>CalcRecord</code> to complete with a progress of <code>100</code> and a result of <code>50</code>.</p>
			<p lang="en-GB">We can build and run the test application now, but we will get the same failure we did previously. That’s because the status request handling still returns a hardcoded response. We need to modify the request handler like this for the status request:</p>
			<pre class="source-code" lang="en-GB">
    else if (auto const * req = std::get_            if&lt;StatusRequest&gt;(&amp;request))
    {
        MereMemo::log(debug, User(user), LogPath(path))
            &lt;&lt; "Received Status request for: "
            &lt;&lt; req-&gt;mToken;
        int calcIndex = std::stoi(req-&gt;mToken);
        bool complete;
        int progress;
        int result;
        calculations[calcIndex].getData(complete, progress,                                 result);
        response = SimpleService::StatusResponse {
            .mComplete = complete,
            .mProgress = progress,
            .mResult = result
        };
    }</pre>
			<p lang="en-GB">With this change, the status request converts the token into an index that it uses to find the correct <code>CalcRecord</code>. Then, it gets the current data from <code>CalcRecord</code> to be returned in the response.</p>
			<p lang="en-GB">You may also want to consider adding sleep to the test loop that attempts five service call requests so that the total time given to the service is reasonable. The current test will fail if all five attempts are made quickly before the service has time to complete even a simple calculation.</p>
			<p lang="en-GB">All the tests pass after <a id="_idIndexMarker580"/>building and running the test application. Are we done now? Not yet. All of these changes let the service calculate a result in a separate thread while continuing to handle requests on the main thread. The whole point of adding another thread is to avoid timeouts due to calculations that take a long time. But our calculation is very quick. We need to slow the calculation down so that we can test the service with a reasonable response time.</p>
			<p lang="en-GB">How will we slow down the thread? And what amount of time should the calculation require to complete? These are the questions that we’ve been building code to answer in this chapter. The next section will explain how you can test services that use multiple threads. And now that we have a service that uses another thread for the calculation, we can explore the best way to test this situation.</p>
			<p lang="en-GB">I’d also like to clarify that what the next section does is different than adding a delay to the five service call attempts. A delay in the test loop will improve the reliability of the test we have now. The next section will remove the loop completely and show you how to coordinate a test with another thread so that both the test and the thread proceed together.</p>
			<h1 id="_idParaDest-145" lang="en-GB"><a id="_idTextAnchor159"/>How to test multiple threads without sleep</h1>
			<p lang="en-GB">Earlier in this chapter, in the <em class="italic" lang="">The need to justify multiple threads</em> section, I mentioned that you should try to do as much work as possible with single threads. We’re going to follow this advice now. In the current request handling for the calculate request, the code creates a thread that does a simple calculation, like this:</p>
			<pre class="source-code" lang="en-GB">
        std::thread calcThread([calcIndex] ()
        {
            calculations[calcIndex].setData(true, 100, 50);
        });</pre>
			<p lang="en-GB">Okay, maybe a simple calculation is<a id="_idIndexMarker581"/> the wrong way to describe what the thread does. The thread sets the result to a hardcoded value. We know this is temporary code and that we’ll need to change the code to multiply the seed value by <code>10</code>, which is what the tests expect.</p>
			<p lang="en-GB">Where should the calculation be done? It would be easy to do the calculation in the thread lambda, but that would go against the advice of doing as much work as possible with a single thread.</p>
			<p lang="en-GB">What we want to do is create a calculation function that the thread can call. This will let us test the calculation function separately without worrying about any threading issues and make sure that the calculation is correct.</p>
			<p lang="en-GB">And here’s the really interesting part: creating a function to do the calculation will help us test the thread management too! How? Because we’re going to create two calculation functions.</p>
			<p lang="en-GB">One function will be the real calculation function, which can be tested independently of any threads. For our project, the real calculation will still be simple and fast. We’re not going to try to do a lot of work to slow down the calculation and we’re not going to put the thread to sleep either. And we’re not going to write a bunch of tests to make sure the calculation is correct. This is just an example of a pattern that you can follow in your projects.</p>
			<p lang="en-GB">The other function will be a test calculation function and will do some fake calculations designed to match the real calculation result. The test calculation function will also contain some thread management code designed to coordinate the thread’s activity. We’ll use the thread management code in the test calculation function to slow down the thread so that we can simulate a calculation that takes a long time.</p>
			<p lang="en-GB">What we’re doing is mocking the real calculation with code that is less focused on the calculation and more focused on the thread’s behavior. Any test that wants to test the real calculation can use the real calculation function, while any test that wants to test the thread timing and coordination can use the test calculation function.</p>
			<p lang="en-GB">First, we’ll declare the two functions in <code>Service.h</code> right before the <code>Service</code> class, like this:</p>
			<pre class="source-code" lang="en-GB">
void normalCalc (int seed, int &amp; progress, int &amp; result);
void testCalc (int seed, int &amp; progress, int &amp; result);</pre>
			<p lang="en-GB">You can define your calculation functions in your projects to do whatever you need. Your functions will likely be<a id="_idIndexMarker582"/> different. The main point to understand is that they should have the same signature so that the test function can be substituted for the real function.</p>
			<p lang="en-GB">The <code>Service</code> class needs to be changed so that one of these functions can be injected into the service. We’ll set up the calculation function in the constructor and use the real function as the default, like this:</p>
			<pre class="source-code" lang="en-GB">
class Service
{
public:
    using CalcFunc = void (*) (int, int &amp;, int &amp;);
    Service (CalcFunc f = normalCalc)
    : mCalc(f)
    { }
    void start ();
    ResponseVar handleRequest (std::string const &amp; user,
        std::string const &amp; path,
        RequestVar const &amp; request);
private:
    CalcFunc mCalc;
};</pre>
			<p lang="en-GB">The <code>Service</code> class now has a member function pointer that will point to one of the calculation functions. Which one will be called is determined when the <code>Service</code> class is created.</p>
			<p lang="en-GB">Let’s implement the two functions in <code>Service.cpp</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
void SimpleService::normalCalc (
    int seed, int &amp; progress, int &amp; result)
{
    progress = 100;
    result = seed * 10;
}
void SimpleService::testCalc (
    int seed, int &amp; progress, int &amp; result)
{
    progress = 100;
    result = seed * 10;
}</pre>
			<p lang="en-GB">At the moment, both functions are the same. We’ll take this one step at a time. Each function just sets <code>progress</code> to <code>100</code> and <code>result</code> to <code>seed</code> times <code>10</code>. We’re going to leave the real or <a id="_idIndexMarker583"/>normal function as-is. Eventually, we’ll change the test function so that it controls the thread.</p>
			<p lang="en-GB">Now, we can change the calculate request handler in <code>Service.cpp</code> so that it uses the calculation function, like this:</p>
			<pre class="source-code" lang="en-GB">
    if (auto const * req = std::get_       if&lt;CalculateRequest&gt;(&amp;request))
    {
        MereMemo::log(debug, User(user), LogPath(path))
            &lt;&lt; "Received Calculate request for: "
            &lt;&lt; std::to_string(req-&gt;mSeed);
        calculations.emplace_back();
        int calcIndex = calculations.size() - 1;
        int seed = req-&gt;mSeed;
        std::thread calcThread([this, calcIndex, seed] ()
        {
            int progress;
            int result;
            mCalc(seed, progress, result);
            calculations[calcIndex].setData(true, progress,                                     result);
        });
        calcThread.detach();
        response = SimpleService::CalculateResponse {
            .mToken = std::to_string(calcIndex)
        };
    }</pre>
			<p lang="en-GB">In the thread lambda, we call <code>mCalc</code> instead of setting <code>progress</code> and <code>result</code> to hardcoded values. Which calculation function is called depends on which function <code>mCalc</code> points to.</p>
			<p lang="en-GB">If we build and run the test application, we’ll see that the tests pass. But there’s something wrong with how we’re calling <code>mCalc</code>. We want to get intermediate progress so that a caller can make status requests and see the progress increasing until the calculation is finally complete. By calling <code>mCalc</code> once, we only give the function one chance to do something. We should<a id="_idIndexMarker584"/> be calling the <code>mCalc</code> function in a loop until <code>progress</code> reaches <code>100</code> percent. Let’s change the lambda code:</p>
			<pre class="source-code" lang="en-GB">
        std::thread calcThread([this, calcIndex, seed] ()
        {
            int progress {0};
            int result {0};
            while (true)
            {
                mCalc(seed, progress, result);
                if (progress == 100)
                {
                    calculations[calcIndex].setData(true,                     progress, result);
                    break;
                }
                else
                {
                    calculations[calcIndex].setData(false,                     progress, result);
                }
            }
        });</pre>
			<p lang="en-GB">This change does not affect the tests because the <code>mCalc</code> function currently sets <code>progress</code> to <code>100</code> on the first call; therefore, the while loop will only run once. We don’t want the thread to take too long to run without some synchronization with the tests because we’ll never join with the thread. If this was a real project, we would want to use threads from a thread pool and wait for the threads to complete before stopping the service.</p>
			<p lang="en-GB">Making a change that does not affect the tests is a great way to verify changes. Take small steps instead of trying to do everything in one giant set of changes.</p>
			<p lang="en-GB">Next, we’re going to duplicate the test that generates a result except we will use the test calculation function in the duplicate test. The test will need to be modified slightly so that it can use the test<a id="_idIndexMarker585"/> calculation function. But for the most part, the test should remain almost identical. The new test goes in <code>Message.cpp</code> and looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST_SUITE("Status request to test service generates result", "Service 2")
{
    std::string user = "123";
    std::string path = "";
    SimpleService::RequestVar calcRequest =
        SimpleService::CalculateRequest {
            .mSeed = 5
        };
    auto responseVar = gService2.service().handleRequest(
        user, path, calcRequest);
    auto const calcResponse =
        std::get_if&lt;SimpleService::CalculateResponse&gt;        (&amp;responseVar);
    CONFIRM_TRUE(calcResponse != nullptr);
    SimpleService::RequestVar statusRequest =
        SimpleService::StatusRequest {
            .mToken = calcResponse-&gt;mToken
        };
    int result {0};
    for (int i = 0; i &lt; 5; ++i)
    {
        responseVar = gService2.service().handleRequest(
            user, path, statusRequest);
        auto const statusResponse =
            std::get_if&lt;SimpleService::StatusResponse&gt;            (&amp;responseVar);
        CONFIRM_TRUE(statusResponse != nullptr);
        if (statusResponse-&gt;mComplete)
        {
            result = statusResponse-&gt;mResult;
            break;
        }
    }
    CONFIRM_THAT(result, Equals(40));
}</pre>
			<p lang="en-GB">The only changes are to give the test a different name so that it uses a new test suite called <code>"Service 2"</code>, and then use a different global service called <code>gService2</code>. Here, we expect a slightly different result. We’ll be changing this test soon so that it will eventually contribute more value than it does now, and we’ll be removing the loop that tries to make the request<a id="_idIndexMarker586"/> five times. Making these changes in small steps will let us verify that we don’t break anything major. And expecting a slightly different result will let us verify that we are using a different calculation function.</p>
			<p lang="en-GB">To build the project, we need to define <code>gService2</code>, which will use a new setup and teardown class. Add the following code to <code>SetupTeardown.h</code>:</p>
			<pre class="source-code" lang="en-GB">
class TestServiceSetup
{
public:
    TestServiceSetup ()
    : mService(SimpleService::testCalc)
    { }
    void setup ()
    {
        mService.start();
    }
    void teardown ()
    {
    }
    SimpleService::Service &amp; service ()
    {
        return mService;
    }
private:
    SimpleService::Service mService;
};
extern MereTDD::TestSuiteSetupAndTeardown&lt;TestServiceSetup&gt;
gService2;</pre>
			<p lang="en-GB">The <code>TestServiceSetup</code> class defines a constructor that initializes the <code>mService</code> data member with the <code>testCalc</code> function. The <code>gService2</code> declaration uses <code>TestServiceSetup</code>. We need to make a small change in <code>SetupTeardown.cpp</code> for <code>gService2</code>, like so:</p>
			<pre class="source-code" lang="en-GB">
#include "SetupTeardown.h"
MereTDD::TestSuiteSetupAndTeardown&lt;ServiceSetup&gt;
gService1("Calculation Service", "Service 1");
MereTDD::TestSuiteSetupAndTeardown&lt;TestServiceSetup&gt;
gService2("Calculation Test Service", "Service 2");</pre>
			<p lang="en-GB">The <code>SetupTeardown.cpp</code> file is short and<a id="_idIndexMarker587"/> only needs to define instances of <code>gService1</code> and <code>gService2</code>.</p>
			<p lang="en-GB">We need to change the <code>testCalc</code> function so that it will multiply by <code>8</code> to give an expected result of <code>40</code> instead of <code>50</code>. Here are both calculation functions in <code>Service.cpp</code>:</p>
			<pre class="source-code" lang="en-GB">
void SimpleService::normalCalc (
    int seed, int &amp; progress, int &amp; result)
{
    progress = 100;
    result = seed * 10;
}
void SimpleService::testCalc (
    int seed, int &amp; progress, int &amp; result)
{
    progress = 100;
    result = seed * 8;
}</pre>
			<p lang="en-GB">Building and running the test application shows that all the tests pass. We now have two test suites. The output looks like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 2 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Service 1</strong>
<strong class="bold" lang="">------- Setup: Calculation Service</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Calculate request can be sent</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Status request generates result</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Teardown: Calculation Service</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">--------------- Suite: Service 2</strong>
<strong class="bold" lang="">------- Setup: Calculation Test Service</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Status request to test service generates result</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Teardown: Calculation Test Service</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 7</strong>
<strong class="bold" lang="">Tests failed: 0</strong></pre>
			<p lang="en-GB">Here, we introduced a new service that uses a slightly different calculation function and can use both services in the tests. The tests pass with minimal changes. Now, we’re ready to make more changes to coordinate the threads. This is a better approach than jumping directly into the thread management code and adding the new service and calculation function.</p>
			<p lang="en-GB">When following TDD, the process is always the same: get the tests to pass, make small changes to the tests or add new tests, and get the tests to pass again.</p>
			<p lang="en-GB">The next step will complete this section. We’re going to control the speed at which the <code>testCalc</code> function works so that we can make multiple status requests to get a complete result. We’ll wait inside the test calculation function so that the test has time to verify that the progress<a id="_idIndexMarker588"/> does indeed increase over time until the result is finally calculated once the progress reaches 100%.</p>
			<p lang="en-GB">Let’s start with the test. We’re going to signal the calculation thread from within the test thread so that the calculation thread will progress in-step with the test. This is what I meant by testing multiple threads without using sleep. Sleeping within a thread is not a good solution because it’s not reliable. You might be able to get a test to pass only to have the same test fail later when the timing changes. The solution you’ll learn here can be applied to your testing.</p>
			<p lang="en-GB">All you need to do is create a test version of part of your code that can be substituted for the real code. In our case, we have a <code>testCalc</code> function that can be substituted for the <code>normalCalc</code> function. Then, you can add one or more <em class="italic" lang="">condition variables</em> to your test and wait on those condition variables from within the test version of your code. A condition variable is a standard and supported way in C++ to let one thread wait until a condition is met before proceeding. The test calculation function will wait on the condition variable. The test will notify the condition variable when it’s ready for the calculation to continue. Notifying the condition variable will unblock the waiting calculation thread at<a id="_idIndexMarker589"/> exactly the right time so that the test can verify the proper thread behavior. Then, the test will wait until the calculation has been completed before continuing. We’ll need to include <code>condition_variable</code> at the top of <code>Service.h</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
#ifndef SIMPLESERVICE_SERVICE_H
#define SIMPLESERVICE_SERVICE_H
#include &lt;condition_variable&gt;
#include &lt;string&gt;
#include &lt;variant&gt;</pre>
			<p lang="en-GB">Then, we need to declare a mutex, two condition variables, and two bools in <code>Service.h</code> so that they can be used by the test calculation function and by the test. Let’s declare the mutex, condition variables, and the bools right before the test calculation function, like this:</p>
			<pre class="source-code" lang="en-GB">
void normalCalc (int seed, int &amp; progress, int &amp; result);
extern std::mutex service2Mutex;
extern std::condition_variable testCalcCV;
extern std::condition_variable testCV;
extern bool testCalcReady;
extern bool testReady;
void testCalc (int seed, int &amp; progress, int &amp; result);</pre>
			<p lang="en-GB">Here is the modified test in <code>Message.cpp</code>:</p>
			<pre class="source-code" lang="en-GB">
TEST_SUITE("Status request to test service generates result", "Service 2")
{
    std::string user = "123";
    std::string path = "";
    SimpleService::RequestVar calcRequest =
        SimpleService::CalculateRequest {
            .mSeed = 5
        };
    auto responseVar = gService2.service().handleRequest(
        user, path, calcRequest);
    auto const calcResponse =
        std::get_if&lt;SimpleService::CalculateResponse&gt;        (&amp;responseVar);
    CONFIRM_TRUE(calcResponse != nullptr);
    // Make a status request right away before the service
    // is allowed to do any calculations.
    SimpleService::RequestVar statusRequest =
        SimpleService::StatusRequest {
            .mToken = calcResponse-&gt;mToken
        };
    responseVar = gService2.service().handleRequest(
        user, path, statusRequest);
    auto statusResponse =
        std::get_if&lt;SimpleService::StatusResponse&gt;        (&amp;responseVar);
    CONFIRM_TRUE(statusResponse != nullptr);
    CONFIRM_FALSE(statusResponse-&gt;mComplete);
    CONFIRM_THAT(statusResponse-&gt;mProgress, Equals(0));
    CONFIRM_THAT(statusResponse-&gt;mResult, Equals(0));
    // Notify the service that the test has completed the first
    // confirmation so that the service can proceed with the
    // calculation.
    {
        std::lock_guard&lt;std::mutex&gt;              lock(SimpleService::service2Mutex);
        SimpleService::testReady = true;
    }
    SimpleService::testCV.notify_one();
    // Now wait until the service has completed the calculation.
    {
        std::unique_lock&lt;std::mutex&gt;              lock(SimpleService::service2Mutex);
        SimpleService::testCalcCV.wait(lock, []
        {
            return SimpleService::testCalcReady;
        });
    }
    // Make another status request to get the completed result.
    responseVar = gService2.service().handleRequest(
        user, path, statusRequest);
    statusResponse =
        std::get_if&lt;SimpleService::StatusResponse&gt;        (&amp;responseVar);
    CONFIRM_TRUE(statusResponse != nullptr);
    CONFIRM_TRUE(statusResponse-&gt;mComplete);
    CONFIRM_THAT(statusResponse-&gt;mProgress, Equals(100));
    CONFIRM_THAT(statusResponse-&gt;mResult, Equals(40));
}</pre>
			<p lang="en-GB">The test is a bit longer than it used to be. We’re no longer making status requests in a loop while looking for a completed response. This test takes a more deliberate approach and knows exactly what it expects at each step. The initial calculation request and calculation response are the same. The test knows that the calculation will be paused, so the first status request will return an uncompleted response with zero progress.</p>
			<p lang="en-GB">After the first status request <a id="_idIndexMarker590"/>has been confirmed, the test notifies the calculation thread that it can continue and then the test waits. Once the calculation is complete, the calculation thread will notify the test that the test can continue. At all times, the test and the calculation thread are taking turns, which lets the test confirm each step. There is a small race condition in the test calculation thread that I’ll explain after you’ve seen the code. A race condition is a problem where two or more threads can interfere with each other and the result is not completely predictable.</p>
			<p lang="en-GB">Let’s look at the other half now – the test calculation function. We need to declare the mutex, condition variables, and the bools too. The variables and the test calculation function should look like this:</p>
			<pre class="source-code" lang="en-GB">
std::mutex SimpleService::service2Mutex;
std::condition_variable SimpleService::testCalcCV;
std::condition_variable SimpleService::testCV;
bool SimpleService::testCalcReady {false};
bool SimpleService::testReady {false};
void SimpleService::testCalc (
    int seed, int &amp; progress, int &amp; result)
{
    // Wait until the test has completed the first status request.
    {
        std::unique_lock&lt;std::mutex&gt; lock(service2Mutex);
        testCV.wait(lock, []
        {
            return testReady;
        });
    }
    progress = 100;
    result = seed * 8;
    // Notify the test that the calculation is ready.
    {
        std::lock_guard&lt;std::mutex&gt; lock(service2Mutex);
        testCalcReady = true;
    }
    testCalcCV.notify_one();
}</pre>
			<p lang="en-GB">The first thing that the test calculation function does is wait. No calculation progress will be made until the test has a chance to confirm the initial status. Once the test calculation thread is allowed to proceed, it needs to notify the test before returning so that the test can make <a id="_idIndexMarker591"/>another status request.</p>
			<p lang="en-GB">The most important thing to understand about this process is that the test calculation function should be the only code interacting with the test. You shouldn’t put any waits or notifications in the main service response handler or even in the lambda that is defined in the response handler. Only the test calculation function that gets swapped out for the real calculation function should have any awareness that a test is being run. In other words, you should put all the waiting and condition variable notifications in <code>testCalc</code>. This is the source of the race condition that I mentioned. When the <code>testCalc</code> function notifies the test thread that the calculation is complete, it’s not completely correct. The calculation is only complete when <code>setData</code> finishes updating <code>CalcRecord</code>. However, we don’t want to send the notification after calling <code>setData</code> because that would put the notification outside of the <code>testCalc</code> function.</p>
			<p lang="en-GB">Ideally, we would change the design so that the calculation function is called one additional time after completing the calculation. We could say that this gives the calculation function a chance to clean up any resources used during the calculation. Or maybe we can create another set of functions for cleaning up. One cleanup function could be the normal cleanup, while the other function could be substituted for test cleanup. Either approach would let us notify the test that the calculation has finished, which would eliminate the race condition.</p>
			<p lang="en-GB">Building and running these<a id="_idIndexMarker592"/> tests shows that all the tests continue to pass. We’re almost done. We’ll leave the race condition as-is because fixing it would only add extra complexity to this explanation. The only remaining task is to fix a problem that I noticed in the log file. I’ll explain more about this new problem in the next section.</p>
			<h1 id="_idParaDest-146" lang="en-GB"><a id="_idTextAnchor160"/>Fixing one last problem detected with logging</h1>
			<p lang="en-GB">There’s a big reason why I <a id="_idIndexMarker593"/>choose to build a logging library in <em class="italic" lang="">Part 2</em>, <em class="italic" lang="">Logging Library</em>, of this book. Logging can be a huge help when debugging known problems. Something that’s often overlooked is the benefit that logging provides when looking for bugs that haven’t been detected yet.</p>
			<p lang="en-GB">I’ll often look at the log file after running tests to make sure the messages match what I expect. After making the enhancements in the previous section for the thread coordination between the test and the test calculation thread, I noticed something strange in the log file. The log file looks like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-08-27T05:00:50.409 Service is starting.</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.410 user="123" Received Calculate request for: 5</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.411 user="123" Received Calculate request for: 5</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.411 user="123" Received Status request for: 1</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.411 Service is starting.</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.411 Service is starting.</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.411 user="123" Received Calculate request for: 5</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.411 user="123" Received Calculate request for: 5</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.411 user="123" Received Status request for: 2</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.411 user="123" Received Status request for: 2</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.411 user="123" Received Status request for: 2</strong>
<strong class="bold" lang="">2022-08-27T05:00:50.411 user="123" Received Status request for: 2</strong></pre>
			<p lang="en-GB">I removed the <code>log_level</code> and <code>logpath</code> tags just to shorten the messages so that you can see the important parts better. The first strange thing that I noticed is that the service was started three times. We only have <code>gService1</code> and <code>gService2</code>, so the service should only have been started twice.</p>
			<p lang="en-GB">The first four lines in the log file make sense. We start <code>gService1</code> and then run a simple test that requests a calculation and checks that the response is of the proper type. Then, we run another test that makes a status request up to five times while looking for a complete response. The first status request finds the complete response, so no additional status requests are needed. The token for the first status request is <code>1</code>.</p>
			<p lang="en-GB">Line 5 in the log file, which<a id="_idIndexMarker594"/> is where the service is started for the second time, is where the log file begins to look strange. We should only need to start the second service, make a single additional request, and then make two status requests. It looks like the log file is getting duplicate messages from line 5 until the end.</p>
			<p lang="en-GB">After a little debugging and the hint that we’re duplicating log messages, I found the problem. When I originally designed the service, I configured the logging in the <code>Service::start</code> method. I should have kept the logging configuration in the <code>main</code> function. Everything worked until we needed to create and start a second service so that the second service could be configured to use a test calculation function. Well, the second service was also configuring the logging when it started, and it added another file output. The second file’s output caused all the log messages to be sent to the log file twice. The solution is simple: we need to configure the logging in <code>main</code> like this:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;MereMemo/Log.h&gt;
#include &lt;MereTDD/Test.h&gt;
#include &lt;iostream&gt;
int main ()
{
    MereMemo::FileOutput appFile("logs");
    MereMemo::addLogOutput(appFile);
    return MereTDD::runTests(std::cout);
}</pre>
			<p lang="en-GB">Then, we need to remove the logging configuration from the service <code>start</code> method so that it looks like this:</p>
			<pre class="source-code" lang="en-GB">
void SimpleService::Service::start ()
{
    MereMemo::log(info) &lt;&lt; "Service is starting.";
}</pre>
			<p lang="en-GB">With these changes, the tests still pass and the log file looks better. Again, I removed some tags to shorten the log message lines. Now, the content of the log file is as follows:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-08-27T05:35:30.573 Service is starting.</strong>
<strong class="bold" lang="">2022-08-27T05:35:30.574 user="123" Received Calculate request for: 5</strong>
<strong class="bold" lang="">2022-08-27T05:35:30.574 user="123" Received Calculate request for: 5</strong>
<strong class="bold" lang="">2022-08-27T05:35:30.574 user="123" Received Status request for: 1</strong>
<strong class="bold" lang="">2022-08-27T05:35:30.574 Service is starting.</strong>
<strong class="bold" lang="">2022-08-27T05:35:30.574 user="123" Received Calculate request for: 5</strong>
<strong class="bold" lang="">2022-08-27T05:35:30.574 user="123" Received Status request for: 2</strong>
<strong class="bold" lang="">2022-08-27T05:35:30.575 user="123" Received Status request for: 2</strong></pre>
			<p lang="en-GB">While the problem ended <a id="_idIndexMarker595"/>up being a mistake in how the logging was configured, the point I wanted to make is to remind you to look through the log files periodically and make sure the log messages make sense.</p>
			<h1 id="_idParaDest-147" lang="en-GB"><a id="_idTextAnchor161"/>Summary</h1>
			<p lang="en-GB">This is the last chapter of this book and it explained one of the most confusing and difficult aspects of writing software: how to test multiple threads. You’ll find a lot of books that explain multi-threading but fewer will give you advice and show you effective ways to test multiple threads.</p>
			<p lang="en-GB">Because the target customer of this book is a microservices C++ developer who wants to learn how to use TDD to design better software, this chapter tied everything in this book together to explain how to test multi-threaded services.</p>
			<p lang="en-GB">First, you learned how to use multiple threads in your tests. You need to make sure you handle exceptions inside tests that start additional threads. Exceptions are important because the testing library uses exceptions to handle failed confirmations. You also learned how to use a special helper class to report failed confirmations that arise in additional threads.</p>
			<p lang="en-GB">Threads must also be considered when writing and using libraries. You saw how to test a library to make sure it’s thread-safe.</p>
			<p lang="en-GB">Finally, you learned how to test multi-threaded services in a fast and reliable manner that avoids putting threads to sleep in an attempt to coordinate the actions of multiple threads. You learned how to refactor your code so that you can test as much as possible in a single-threaded manner and then how to substitute the normal code for special test-aware code that works with a test. You can use this technique any time you need a test and multi-threaded code to work together so that the test can take specific and reliable steps and confirm your expectations along the way.</p>
			<p lang="en-GB">Congratulations on reaching the end of this book! This chapter visited all the projects we’ve been working on. We enhanced the unit testing library to help you use multiple threads in your tests. We also made the logging library thread-safe. Finally, we enhanced the service so that it can coordinate multiple threads between the service and the tests. You now have all the skills you’ll need to apply TDD to your projects.</p>
		</div>
	</body></html>