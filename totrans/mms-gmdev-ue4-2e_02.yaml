- en: Inventory and Weapons for the Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to our next chapter. In this chapter, we will build upon the Mastering
    project as it stands so far with a brand new system for handling the inventory
    and changing weapons. Wherever possible, any hardcoded types of systems will also
    be removed at this point, such as referencing assets by name from C++. When making
    such changes, there will typically be an accompanying discussion of why this is
    important to a given project. By the end of this chapter, though, we should be
    referencing all of our classes and assets in an easy-to-modify way, and have a
    very fast iteration time, changing things like adding new weapons and weapon pick-ups.
    In order, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a `Weapon` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory for weapons in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using a `WeaponPickup` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cycling weapons with new control bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All requirements found in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml), *Making
    a C++ Project for a First-Person Shooter*, including its output Mastering project
    or one at a similar point of development, are required for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following our chapter progress branching theme, the GitHub work done in this
    chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-2](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Engine Version used: 4.19.0.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Weapon and Inventory classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal for this section is to add these two new classes to our game and convert
    the hardcoded weapon template made for us into the new weapon class and add it
    to our new inventory class for our player. We will start with the editor running
    and take a moment to examine the existing weapon and see how it was made in the
    template, as a means to gather the information needed for designing and implementing
    this new weapon class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Weapon class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the FPS template gives a great jump-start to a project like this, it's
    very limited in a number of ways. It is intended to be the most minimal and agnostic
    implementation allowing us, the developers, to build in whatever direction is
    needed. As a theme throughout our improvements and expansion of this game project,
    as our needs for new systems and features arise, this is the motivation for our
    work. While the very simple weapon the template implements demonstrates all the
    core pieces of an FPS weapon, it is not at all easily modified, so thus, we need
    a new class. In a typical FPS game you are often switching between multiple unique
    weapons on a character, so we will make that possible step-by-step here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To first see how the existing weapon was made, we need to open up Content |
    FirstPersonCPP | Blueprints | FirstPersonCharacter again in the Content Browser,
    and if you are re-opening it, click on the Open Full Blueprint Editor option again.
    In the main window, click the Viewport tab and as you click on some of these other
    items, you can see how they are shown or represented currently in the blueprint
    as it stands. The first thing to click, however, is in the Components tab, the
    very first item you can select, FirstPersonCharacter(self). This is the overall
    class used for our player currently, and if you picked up where we left off in
    the previous chapter, is currently set to the `StealthCaracter` class, which is
    derived from our `MasteringCharacter` of course. Upon selecting that in the Components
    tab, you can see on the right in the Details tab you can see several variables
    under the Gameplay and Projectile fly-outs that we are going to want to move to
    the new weapon class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d942fe01-f40c-424c-849e-cf19799a4d32.png)'
  prefs: []
  type: TYPE_IMG
- en: The Gun Offset, Fire Sound, Fire Animation, and the Projectile Class should
    all be moved into our new class as, of course, these will naturally vary from
    weapon to weapon. Looking back to the Components tab, you can also see there is
    an FP_Gun (Inherited) component, and under it, an FPMuzzleLocation (Inherited)
    component. These are a Skeletal Mesh Component and simple Scene Component, respectively,
    but also belong with the weapon and not with our character here directly.
  prefs: []
  type: TYPE_NORMAL
- en: So, back to the main editor window and the Content Browser, let's use the shortcut
    mentioned in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml), *Making
    a C++ Project for a First-Person Shooter*, and right-click in the main window
    to get the popup with New C++ Class near the top and add one. In this case, we
    want the parent class to simply be Actor, so for once we don't need to click the
    Show all classes option. Select it and then click Next as before. Here, we'll
    name the class `MasteringWeapon`, and click Create Class. And once more we'll
    get a hot-reload. Once that finishes, it's back to Visual Studio to add all the
    variables mentioned earlier that our new weapons will need.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the existing gun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Opening up `MasteringWeapon.h` and `.cpp`, let''s add some variables as `UPROPERTY`
    items again, and our goal now is to replicate what is currently done in `MasteringCharacter`
    in our weapon and then remove those items from the character class. As a reminder,
    the things our weapon needs to contain are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Gun Offset (`FVector`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fire Sound (`USoundBase`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fire Animation (`UAnimMontage`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projectile Class (`TSubclassOf<class AMasteringProjectile>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weapon Mesh (`USkeletalMeshComponent`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Muzzle Location (`USceneComponent`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, as we have a bit of code work to do and don''t want to be hot-reloading
    a lot, I recommend shutting down the editor until we''re ready to add a new instance
    of `MasteringWeapon` to the game. So, let''s get to adding those variables to
    our new `.h` file. These first four you can literally cut (not copy, as we''re
    removing them) and paste from the `MasteringCharacter.h` file after making a public
    section under `GENERATED_BODY()`, and add the declaration of the constructor while
    we are here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Do note, however, that the `ProjectileClass''` `UPROPERTY` line has been set
    to match the others, and it did not previously in `MasteringCharacter.h`. Now
    all we need is our Skeletal Mesh and Muzzle Location; we''ll add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, keep in mind that we are departing from the template''s hardcore C++ implementation
    of all of these game objects so that we can move to a more logical and helpful
    hybrid using blueprints. So, since all of our weapons will be instances of this
    class, for now let''s just give the `GunOffset` the same default value it currently
    has (this variable is not very important right now) by changing its line in the
    `.h` file to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There will be a more in-depth discussion of the topic of blueprint/C++ balance
    in [Chapter 3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint Review
    and When to Use BP Scripting*, but for now you can always at least think of blueprint
    instances of classes as great containers for data, especially things that will
    be tuned during game design, such as weapon properties here. We now have all the
    variables we will be using in our weapon and could add a blueprint for our new
    gun, but it won't do anything yet, and also, by removing these variables from
    our `MasteringCharacter` class, of course, it won't compile now. Thus, our best
    course is to carry on a bit more and have our code in a better position. Back
    in `MasteringCharacter.h`, find and remove the `FP_Gun` and `FP_MuzzleLocation`
    variables. Then, search and remove all references to them *and*the four variables
    that we migrated to `MasteringWeapon.h` from the `MasteringCharacter.cpp` file.
    We can also remove the `VR_Gun` and `VR_MuzzleLocation` variables now as we'll
    make a whole new project when finally tackling a VR game later, so these are currently
    unimportant (but you can imagine otherwise converting them similarly in such a
    VR game).
  prefs: []
  type: TYPE_NORMAL
- en: As a tip for how I work here, as I know I need to replicate the same functionality
    later in my weapon class that's currently in our character class, I just commented
    out those sections currently used in the character and then will remove them entirely
    as each is now handled by the weapon as we continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now also remove this line from `MasteringCharacter.cpp`, and we can
    be sure that we will need this in `MasteringWeapon.cpp`. Also cut and paste the
    line to there after `MasteringWeapon.h` `include`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to get our components to show up in our blueprint instance, we need to
    add them in the constructor like so in our `.cpp` file (similar to how they were
    made in the character''s constructor), and we also need to add some required headers,
    starting right after the preceding line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our character will be pretty broken if we play the game as they'll
    have no weapon, but as we need to do some editor work (adding a blueprint instance
    and another new class), this is a good time to build the game and start the editor
    back up. At this point, there is an intermediate commit submitted to GitHub's
    `Chapter 2` branch available if you need to check that things match.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an inventory and adding a default gun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in the editor once more, we can work on the two remaining pieces needed
    to get back to the level of weapon functionality we began with, while having abstracted
    out the functionality to the new class: a rudimentary inventory system, and an
    actual blueprint instance of a weapon like the one we just removed from our `MasteringCharacter`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the new `MasteringWeapon` to the Content Browser. Right-click
    in the browser''s main window again and select Blueprint Class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/964a1ada-fa55-442a-a0b3-96b5eac6d9ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Much like when we are creating a new C++ class, here, we need to click the
    All Classes flyout at the bottom and search for and click MasteringWeapon, and
    then the Select button at the bottom. Rename the item in the content browser to
    BallGun and open it in the BP editor. Once again, I find it best here to click
    the full blueprint editor to view the changes in the viewport tab as we edit.
    In the Components tab, select WeaponMesh (Inherited) and in its details, open
    the Weapon Mesh fly-out, go down to the Mesh fly-out, and there the Skeletal Mesh
    variable has a drop-down we can click. There are so few to choose from, so simply
    pick the `SK_FPGun` asset here. Back to the Components tab, select next the MuzzleLocation
    (Inherited) under the WeaponMesh and in the Muzzle Location and Transform flyouts,
    edit the Relative Location vector to be the same values we hardcoded previously:
    `0.2`, `48.4`, `-10.6`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back to the Components tab, and above the two components we were just
    editing, let''s select the base class again, BallGun(self), at the top. On the
    right, we have our Gameplay fly-out with our sound and animation variables. Select
    them from the drop-downs as the only assets we can, FirstPersonTemplateWeaponFire02
    and FirstPersonFire_Montage. Under the Projectile fly-out, select FirstPersonProjectile
    from its drop-down, and building our blueprint for this gun is now done! Click
    on the compile button and then save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41a7955f-4e22-4a16-8259-738d33d1f52d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, we just need to get this very minimal inventory set up and we can return
    to code up the use of our weapon. Right-click in the Content Browser again and
    click New C++ Class. We''ll make this one a very simple `UActorComponent` by choosing ActorComponent for
    the parent class, either in the filtered group or typing into the search in all
    classes. For the name, use MasteringInventory, click Create Class, and we will
    rebuild once more. In `MasteringInventory.h`, first we can this function as it
    will be unused (and remove the implementation in the `.cpp` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need two variables and a couple of functions like so added after `BeginPlay()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice here that our inventory component is only going to be dealing with class
    types, not with actual in-game actors. They will still be spawned by the `MasteringCharacter`
    class as they are equipped. We''ll do that right after the implementations for
    the preceding functions are added to `MasteringInventory.cpp`, beginning directly
    after the `#include MasteringInventory.h` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MasteringCharacter.h`, we need to add three things. In each of the following
    additions, I have also included the line of code that currently exists above where
    I placed the new line, so you can find where to place them. For the first, add
    `UPROPERTY` after `uint32 bUsingMotionControllers : 1`, which already exists in
    the `.h` file. Then, add the `AMasteringWeapon` pointer after `TouchItem`. And
    lastly, add the two function prototypes at the end of the third block after `GetFirstPersonCameraComponent()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `.cpp` file, we''ll need the new headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We need one line added to the bottom of the constructor, and we can now delete
    all the previously commented-out code for equipping and firing the old gun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `BeginPlay()` is now very simple as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`OnFire()` is also much nicer looking; as you can see here, it is very compact
    and readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, at the bottom of the file is the implementation for equipping a
    weapon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that the actual spawn location and rotation are not really significant
    as we immediately attach a successfully spawned weapon to our mesh, but it's usually
    a good idea to have some reasonable defaults there to be safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we return to our `MasteringWeapon` files, first the .h file
    where we add this line near the bottom of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And then implement it like so in the `.cpp` file to do all the work we were
    previously doing in the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, all that's left to do is add a default weapon to our particular player's
    inventory component and we're back in business. Open the FirstPersonCharacter
    BP again in the editor. At the bottom of its Components tab now is our Inventory
    (Inherited). Select it, and in the Details tab, under the Gameplay, Inventory,
    and Mastering Inventory fly-outs, click the Default Weapon drop-down and select
    BallGun. Now, playing the game should have everything looking just like it was
    before, but with a system in place that can accept all manner of new weapons for
    our character, simply by adding more MasteringWeapon blueprint assets and adding
    them to our inventory for selection, which is what our next section focuses on.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great time to take a moment and set some breakpoints in these new
    functions and step through, making sure everything looks right in the debugger.
    Note that if you try to step through some functions and it steps right over them,
    check whether you're building the game in the Development Editor and set it to
    DebugGame Editor instead. Oftentimes, these smaller functions are simply optimized
    away in development.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a WeaponPickup class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a working inventory, if minimal, and a weapon class for creating
    new weapons, we need one more key piece: a way to add these new items to that
    inventory. There are functions now ready to receive this, but how do we get that
    into the game in a meaningful way? Well, there are a number of approaches here
    based on the type of game and its design needs. In the following case, we''ll
    stick to a fairly traditional FPS-style game and add a weapon pickup that can
    be dropped into our game world either during level design or dynamically.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new actor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As noted already, different games have different design needs in this area.
    If your game only ever had, for example, slots for weapon items (as many popular
    3D action games do), then we wouldn't really need an inventory class, nor a weapon
    pickup class. You could save yourself some trouble by just adding a couple of
    `AMasteringWeapon` pointers to your player class and in that weapon, override
    the `AAcotr's Tick(float DeltaSeconds)` function to give it a behavior when on
    the ground, and stop that behavior while it is stored and hidden or shown when
    equipped by the player. In this case, we have a very flexible and open-ended system
    that can be used for a large variety of weapons all being stored at the same time.
    The reason for adding a pick-up here is to demonstrate a different behavior when
    the item is on the ground, and add some additional data that helps us expand the
    usefulness of our inventory. As in many action FPS games, we will give the item
    pickup a visibly noticeable rotation while it sits at the proper height on the
    ground, set up its collision settings so the player can pick it up, and add an
    ammo count and power level to our weapons so that we can automatically equip the
    best item we have when one is available or our equipped one becomes unusable.
    Of course, the pickup item will also reference the MasteringWeapon it represents,
    so we will quickly build a new one here with a new MasteringProjectile to differentiate
    it since we're currently working with limited assets.
  prefs: []
  type: TYPE_NORMAL
- en: For the curious, yes, this book will delve into some of the wonderful, but free,
    UE4 assets from the marketplace in future sections to address advanced visuals
    and give us some variety in the characters and more in our sample game. At the
    moment, however, we will simply work with what we have in the FPS template to
    quickly establish these core game concepts.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, creating a new class is quite familiar, so hopefully we can speed
    through the steps a bit. If anything seems incorrect or not what is expected,
    naturally it is a good idea to skim through the steps previously presented regarding
    making a new class and begin work on its functionality. So, back in the editor,
    let's add yet another new C++ class, with the parent as a simple Actor. We'll
    name it `MasteringWeaponPickup`, and its implementation should actually go rather
    quickly compared to the more complicated classes we have been working on.
  prefs: []
  type: TYPE_NORMAL
- en: We have a decision to make on where the actual pick-up functionality is implemented.
    At this point, let's take a moment to revisit encapsulation. For any readers who
    may have been around to experience Unreal Engine 3, most have a similar story
    about looking at Actor.h and Actor.cpp and thinking their eyes were going to fall
    out. These were, no pun intended, epic files, with tens of thousands of lines
    of code that implemented a myriad of possible in-game behaviors for every single
    actor (no matter how simple) in the game. Those files are still a bit large, but
    thanks to massive efforts by Epic between UE3 and UE4, they managed to move huge
    amounts of specialized code into components and specific plugins, greatly reducing
    the volume of code and number of variables on such a widely used class. The easiest
    way to get this pickup working would be to simply drop it into our `MasteringCharacter`
    class and let our character colliding with a pickup do all the work. However,
    if you begin doing this for all the systems you add to a medium or large project,
    your character class will find itself in a state like UE3's actor files, and new
    team members will have a hard time figuring out where functionality is and will
    have to familiarize themselves often with the entire voluminous class to competently
    make changes. If we encapsulate the functionality needed into the items that generally
    "own" that game behavior, it makes learning the project much easier and modifications
    become less risky and more manageable in scope for newer developers on the team.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in this case, let''s start early with this practice, and put the pickup
    functionality as much as possible into our `MasteringWeaponPickup` class itself.
    Here are the set of functions and variables we will need in the body of the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick note on the `uint8` items at the end: it has been a known issue for
    some time that only this one is supported by classes exposed in blueprint. Adding
    `uint16` and `uint32` types would require a massive amount of work for several
    systems on Epic''s part, so it is not ever a high priority on their list of features
    (the amount of work versus the benefit to developers isn''t very high). In this
    case, it''s no problem, so we can take the benefit of the 8-bit version to force
    all values in our blueprint instances to always be between 0-255\. If you need
    a larger range, you''re forced to use a normal full-sized (but signed) `int` and
    then the burden is on the code side for you to check that designers modifying
    these blueprints don''t enter a value that''s not valid. So, an ongoing theme
    through all the work done in this book will be to tailor your needs to your design.
    Weapon power here is just an arbitrary value, so we can differentiate which weapons
    are better than others. Something this basic and abstract may be perfect for your
    game, depending on the number of weapons, or maybe should be computed from various
    damage and speed types of factors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important part of being a top-level developer is good communication, and
    sitting with a designer to discuss a system, and (depending on the project size)
    putting this into a wiki page or another source of document storage, is key. An
    exaggerated example would be: if we knew with certainty that our game was never
    going to use more than one weapon, all of this inventory and weapon abstraction
    is largely unnecessary. Since I want to demonstrate how we can make it scale to
    a large number of weapons, that is the motivation for getting these systems in
    place early and as encapsulated as possible as we go.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So next, here are the implementations in the pickup''s `.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you can see, it''s fairly simple. Most of what it does is spin around on
    the ground at the speed specified by `RotationSpeed`, allows itself to be picked
    up by a player, and then destroys itself. We''ll talk about its collision filtering
    when we set up an instance, but notice that we cast the OtherActor pointer to
    a mastering character type: this of course works for subtypes (such as our `StealthCharacter`
    class), but any other `Pawn` classes will fail to cast there, returning null,
    so (as seen in that next line) we can ignore them now.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need an actual new weapon. This will be very quick as again, right
    now we have very little to work with in the way of art assets, so we will demonstrate
    things creatively using those same art assets. Right-click on our BallGun weapon
    blueprint and click Duplicate. Rename the duplicated one BigBallGun and do the
    same trick, duplicating the FirstPersonProjectile blueprint and renaming it BigFirstPersonProjectile.
    We'll edit each of these quickly to get them ready to be pickups that can be added
    to our inventory and used by the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open their full blueprints. In the projectile''s components, pick ProjectileMovement
    (Inherited) and on the right you''ll see the Projectile fly-out. Set the speeds
    to about double their current values, so to 6,000 to really give this one some
    punch compared to the other. In its CollisionComp (Inherited) under the Transform
    fly-out, set its scale to 2\. I prefer when possible to click the lock icon on
    the right since we''re doing universal scaling here, so you only have to type
    in the number once rather than in all three components. Then, click on its StaticMesh1
    component under its CollisionComp (Inherited), and here we make one small visual
    change: under its Static Mesh''s Materials fly-out, pick the drop-down and set
    it to M_FPGun. This material''s texture is obviously set up for the gun and not
    a ball, but it makes our new bullet silver to really help differentiate it and
    let us know which gun we''re firing (since the guns themselves otherwise look
    identical at this point). With both of these made, now go back to the BigBallGun
    blueprint''s window and click its class (BigBallGun(self)), under components.
    Now, under the Projectile fly-out, we naturally set it to our new BigFirstPersonProjectile.'
  prefs: []
  type: TYPE_NORMAL
- en: With the weapon and projectile done, now we can finally set up our weapon pickup.
    In the Content Browser, make a new blueprint class, show all classes, and select
    our MasteringWeaponPickup. Name this BigBallGunPickup and double-click it to check
    it out. Click BigBallGunPickup(self), and under Gameplay you're welcome to change
    the rotation speed or amount of ammo in this pickup; however, be sure to at least
    change the weapon power to 1 or greater so it can "sort" above our default gun
    we'll still add from code.
  prefs: []
  type: TYPE_NORMAL
- en: The only components at the moment should be the (self) one and a scene component.
    We'll leave the scene component, and now use a bit of blueprint work directly
    as preparation for further blueprint discussions in the next chapter. We could
    of course add these components that we're about to use in the constructor in C++
    like the template has done to date, but it's much quicker and easier to customize
    here in the blueprint. But again, depending on your project's needs, the C++ way
    might be the better choice. Doing it the way it is done here requires no code,
    but would require adding the components manually every time a new pick-up is made.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is another area of managing a project an expert developer will know how
    to balance: what is the bandwidth of the team compared to the project''s goals?
    If, for example, the game had many systems designers who were comfortable working
    in blueprint, it might make sense to simply allow them to do the duplicated work
    a number of times, adding these components in blueprint and require no coding
    help. On the other hand, if programmers themselves may have to set these up and
    their time is limited (hint: it always is!), it''s probably best to add the components
    into the constructor to reduce the setup time needed to make these pick-ups. Always
    keep in mind your team''s capabilities before committing to a workflow such as
    this.'
  prefs: []
  type: TYPE_NORMAL
- en: Back to the pick-up, I renamed the scene component here so that I know it's
    really only for making an offset from the ground. Click on that scene component
    now (top component) and click the Add Component button at the top. Pick skeletal
    mesh as the type (you can rename it BallGunMesh).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: In all likelihood in a major game, you would have separate art assets
    here, so you would use a static mesh on the pickup that is a simplified version
    and not an animated character such as the gun that is held and equipped; but again,
    we work with what we have.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the mesh''s details pane, find its mesh fly-out and set it to `SK_FPGun`.
    Similarly, set its material to `M_FPGun`. So that when placed on the ground it
    doesn''t actually sit flat on the ground, under its Transformation flyout, set
    the Location to be about 50.0 in Z so that it''s half a meter in the air. Now,
    we need to click the mesh and add a child component to it so that the whole pickup
    can be, well, picked up! Click the green add button again, and this time add a
    Sphere Collision component. We need to change only one thing out of good practice:
    under its Collision fly-out, change its Collision Preset in the drop-down to OverlapOnlyPawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/858d6074-03cb-4503-9d4d-2835aae15a88.png)'
  prefs: []
  type: TYPE_IMG
- en: What this does is allow the collision system to ignore all objects when deciding
    whether one has collided (or, specifically in our case, overlapped, which means
    items can pass through it), but will get this event that overlapping is happening,
    "hit" events are the ones that stop movement. This way, things like our projectiles
    won't have to be considered by the collision system, only pawns walking around,
    which is always important to limit these interactions as much as possible to keep
    performance high. Lastly, click and drag our BigBallGunPickup (the icon in the
    content browser) into the main level editor window where the environment is shown
    (the boxes and walls) and place it on the ground. Place a few if you like, so
    we can walk around and pick them up.
  prefs: []
  type: TYPE_NORMAL
- en: Back to code to finish up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having everything set in the editor and level, we have a few more code changes
    to make. First, we make some changes in `MasteringInventory.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We add this `struct` to the very top of the file, just after the `#include`
    header section. We will use this in the inventory list to reference weapons from
    now on, instead of referencing the `MasteringWeapon` class itself directly (but,
    of course, this is now a member in the `struct` for our use). We use the `struct`
    to track two new properties we associate with weapons: ammo and weapon power.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the `DefaultWeapon` variable, modify the first three functions
    (we remove passing the player for selecting weapons, and add ammo and power to
    the adding of weapons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MasteringInventory.cpp` file, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top, right under our `#include` section, notice the `#define` used to
    show clearly that when we see this, a weapon has unlimited ammo. This is much
    safer than using -1 directly, as new team-members might not understand seeing
    the magical properties of -1 in other areas of the code. In the constructor, notice
    also that we do a trick because we know this object is a component, and thus has
    to have (when used) an owning actor, and we save this as `MyOwner`. If you set
    a breakpoint there, you''ll notice as the level editor starts, you get one instance
    with a null owner. This is the default object being constructed and thus is nothing
    to worry about. However, notice the `check`. It, well, checks for that case, but
    then will assert whether someone tried to add an inventory component to anything
    that isn''t `MasteringCharacter`, just to be safe. This check is done very rarely
    (once each time an inventory is created), so is fine being a normal `check`. Below,
    there''s a `checkSlow` I''ll explain just for contrast. This line of saving a
    pointer already cast to the right type of our owner saves us some time later when
    adding weapons, and then we also don''t have to keep passing a `MasteringCharacter`
    pointer through all these functions since, once again, we know that every player
    has one and only one inventory, and every inventory exists as part of a player.
    We also add the default weapon with unlimited ammo and a weapon power of 0\. After
    this, we basically replace the old `SelectBestWeapon`, `SelectWeapon`, and `AddWeapon`
    so that they now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that changing ammo uses a non-const iterator and a reference to the structs
    it is iterating. This way, we can simply directly modify the ammo count in the
    struct that exists in the array. Always be careful as it's very easy to simply
    use a local variable in the iterator, make a change, and not have that saved as
    you'd like in the array! Also notice `checkSlow`. Adding weapons doesn't happen
    very often either, so it is perfectly fine being a normal `check` for performance.
    I just put it there to remind myself to discuss them. `checkSlow` is only used
    in debug builds, so if content developers use a development build, they would
    never have it assert on them (which can be annoying for artists and designers
    if it were to happen, because it basically causes a crash that they can do nothing
    about). So use these wisely.
  prefs: []
  type: TYPE_NORMAL
- en: In any case where a check is used that could happen in a live build and could
    be very severe, always use the `checkf` variants instead because this will also
    output whatever you format into its string output into the game's .log file. This
    way, if a player with a live version of the game has a problem, or a release build
    crashes, you can look at that log and it may immediately give you a clue as to
    what happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, keeping with our theme of encapsulation, we''ll have the weapon inform
    the inventory as it spends ammo (as the gun does the firing and the inventory
    does the ammo-tracking in our game). When a gun runs out of ammo, the inventory
    will automatically try to pick the next best option, and since our default weapon
    has unlimited ammo, we always know at least something will be available. This,
    of course, can vary wildly in different styles of games, with a "dry fire" sound
    when out of ammo and trying to fire, or switching from a gun to a melee attack
    when out of ammo. Here, we''ll add this parameter to our firing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''ll implement it in the .cpp like so at the bottom of the `Fire` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We can now run around our level, pick up the big gun, and watch its
    projectiles really make those boxes fly... until it's out of ammo and we're back
    to the default gun.
  prefs: []
  type: TYPE_NORMAL
- en: Putting our inventory to use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Don''t worry, all the hard parts are done! But we do still have one last important,
    if less challenging, thing to do to make this more like a viable normal inventory
    in a game: swapping weapons. We''ll need an input for cycling them, and keep in
    mind that we currently auto-equip the best weapon you pick up at the time of pick-up,
    and at the moment have no way to choose anything else.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding controls to cycle weapons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much like before, when we added an input for stealth and bound it to left-shift,
    let's head back to the editor's project properties and engine/input/bindings fly-outs.
    Here, we'll add two Action Mappings with the + button, and name them InventoryUp
    and InventoryDown. I like to bind these to Mouse Wheel Up and Mouse Wheel Down,
    respectively, but you're free to choose any inputs you prefer. We now have our
    means of cycling, and just need to set it up like our stealth mechanic once more
    in our character.
  prefs: []
  type: TYPE_NORMAL
- en: Adding swapping of weapons to our character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to add cycling to our inventory. There are a number of ways
    to do this, and with a plan, you could, for example, simply sort the array based
    on the power of the items going in and store the current weapon''s array entry.
    There are dangers to this, but it would make for very fast and clear switching
    of weapons. The implementation here will be a bit rough, but is not critically
    important. Knowing ahead of time how extensively a system will get used is very
    important to long-term healthy development as well. If a system has a very rough
    but fully functional implementation, and will never likely change or be reused
    by other areas of code in the life of the project, just leave it be. We all want
    to always write perfect code, but code oftentimes comes from outside contributors
    or less experienced developers. While keeping to best practices ourselves is always
    encouraged, it''s also important to know when you don''t need to over-engineer
    something of limited scope or use; just get it working and move on. Game development
    relies on speed, and there is nothing wrong with revisiting code that was written
    under one set of requirements (such as "the game will only ever have at most two
    weapons" changes to "we now need 10 or more weapons for the player!"). Clean up
    and build things the best you can for the job they do. It''s just a classic downfall
    of many developers to not realize when something is good enough, even if it''s
    not perfect or the way we''d ideally like it. So, with that huge disclaimer, here''s
    the rough inventory cycling code to finish up this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the prototypes for the functions to your `.h` file. Then, add these lines
    below all of our previous input binding in `AMasteringCharacter::SetupPlayerInputComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the character, add these functions (with their prototypes near the other
    control handling functions in the header):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And if you were to test things like this, it would look like it's partly working
    and then breaks. Stepping through the code, a line that wasn't important before
    was missing, but seeing that CurrentWeapon was always null, it was very easy to
    add this last line to `SelectWeapon`. It's always great to keep those debugging
    skills up!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Bringing it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, our inventory and pickups are all complete. If you launch the editor, you
    can step through the cycling up and down code to make sure everything is working
    correctly. We redundantly re-equip the default weapon if that's our only one,
    but the real work in the character's `EquipWeapon` already handles trying to switch
    from a weapon to that same weapon class and returns to the top. We now have a
    fully functional inventory that we can use to cycle through our, albeit only two,
    weapons, both up and down. Mission accomplished!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this section with a hardcoded weapon made by bolting some components
    and input onto a character. We now have a system to make infinite unique weapon
    types, make a cool pick-up item for them, add them to the inventory, switch to
    the best weapon, track ammo, switch to another weapon automatically when one runs
    out of ammo, and cycle those weapons as we want with input. This is just one example
    of many game systems that will be implemented over the course of even small game
    projects, but it has shown several fundamentals of design (in the coding sense)
    as well as game design and how they mesh together. Never over-engineer what you
    won't need, but always plan for the future and make sure that your requirements
    are all there. We've also done a bit more work directly with blueprints and its
    editor. In the next chapter, we will go in depth into what blueprints can do and
    understand a bit deeper about how it works. A major point of discussion will be
    how games can (and are!) built only using blueprint scripting and no project C++
    code. This approach has many risks, but for smaller projects or working with limited
    resources to get something demonstrated, it can be a huge benefit, and those benefits
    are there even for a C++ project such as ours if you know when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is there any reasonable way we could have swapped weapons on the character the
    way the template originally set it up?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why move firing functionality out of the character and into our weapon class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we only store actor classes, and not actors, in the inventory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a weapon pickup class? Why not just use the weapon directly
    as the pickup?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantages are there to adding components to a class in code versus adding
    them to an instance in blueprint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between `check`, `checkSlow`, and the `checkf` variants?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which one should always be used for live game builds checking critical code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is finding the current weapon index in its own function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-us/Programming/Assertions](https://docs.unrealengine.com/en-us/Programming/Assertions)'
  prefs: []
  type: TYPE_NORMAL
