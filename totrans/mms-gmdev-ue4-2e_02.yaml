- en: Inventory and Weapons for the Player
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家的库存和武器
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Welcome to our next chapter. In this chapter, we will build upon the Mastering
    project as it stands so far with a brand new system for handling the inventory
    and changing weapons. Wherever possible, any hardcoded types of systems will also
    be removed at this point, such as referencing assets by name from C++. When making
    such changes, there will typically be an accompanying discussion of why this is
    important to a given project. By the end of this chapter, though, we should be
    referencing all of our classes and assets in an easy-to-modify way, and have a
    very fast iteration time, changing things like adding new weapons and weapon pick-ups.
    In order, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们的下一章。在这一章中，我们将基于到目前为止的Mastering项目，引入一个全新的系统来处理库存和更换武器。尽可能的情况下，任何硬编码的系统类型也将在此处被移除，例如从C++中通过名称引用资产。在做出这样的改变时，通常会有一个关于为什么这对特定项目很重要的讨论。然而，到这一章结束时，我们应该能够以易于修改的方式引用所有我们的类和资产，并且拥有非常快的迭代时间，比如添加新的武器和武器拾取。我们将依次介绍以下主题：
- en: Adding a `Weapon` class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`Weapon`类
- en: Inventory for weapons in C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的武器库存
- en: Creating and using a `WeaponPickup` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用`WeaponPickup`类
- en: Cycling weapons with new control bindings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的控制绑定进行自行车武器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All requirements found in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml), *Making
    a C++ Project for a First-Person Shooter*, including its output Mastering project
    or one at a similar point of development, are required for this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml)中找到的所有要求，包括其输出Mastering项目或处于类似开发阶段的任何项目，都是本章所必需的。
- en: 'Following our chapter progress branching theme, the GitHub work done in this
    chapter can be found here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们章节进度分支的主题，本章在GitHub上完成的工作可以在这里找到：
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-2](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-2)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-2](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-2)'
- en: 'Engine Version used: 4.19.0.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的引擎版本：4.19.0。
- en: Adding the Weapon and Inventory classes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加武器和库存类
- en: Our goal for this section is to add these two new classes to our game and convert
    the hardcoded weapon template made for us into the new weapon class and add it
    to our new inventory class for our player. We will start with the editor running
    and take a moment to examine the existing weapon and see how it was made in the
    template, as a means to gather the information needed for designing and implementing
    this new weapon class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本节的目标是将这两个新类添加到我们的游戏中，并将为我们玩家制作的硬编码武器模板转换为新的武器类，并添加到我们新的库存类中。我们将从运行中的编辑器开始，花点时间检查现有的武器，看看它在模板中是如何制作的，以此作为收集设计和新武器类实现所需信息的一种方式。
- en: Creating our Weapon class
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的武器类
- en: While the FPS template gives a great jump-start to a project like this, it's
    very limited in a number of ways. It is intended to be the most minimal and agnostic
    implementation allowing us, the developers, to build in whatever direction is
    needed. As a theme throughout our improvements and expansion of this game project,
    as our needs for new systems and features arise, this is the motivation for our
    work. While the very simple weapon the template implements demonstrates all the
    core pieces of an FPS weapon, it is not at all easily modified, so thus, we need
    a new class. In a typical FPS game you are often switching between multiple unique
    weapons on a character, so we will make that possible step-by-step here.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然FPS模板为类似的项目提供了一个很好的起点，但它从多个方面来看都是非常有限的。它的目的是提供一个最最小化和无差别的实现，使我们，即开发者，能够按照所需的方向构建。作为我们改进和扩展这个游戏项目的主题，随着我们对新系统和功能的需求出现，这也是我们工作的动力。虽然模板实现的非常简单的武器演示了FPS武器的所有核心组件，但它并不容易修改，因此我们需要一个新的类。在一个典型的FPS游戏中，你经常会在一个角色之间切换多个独特的武器，所以我们将逐步实现这一点。
- en: 'To first see how the existing weapon was made, we need to open up Content |
    FirstPersonCPP | Blueprints | FirstPersonCharacter again in the Content Browser,
    and if you are re-opening it, click on the Open Full Blueprint Editor option again.
    In the main window, click the Viewport tab and as you click on some of these other
    items, you can see how they are shown or represented currently in the blueprint
    as it stands. The first thing to click, however, is in the Components tab, the
    very first item you can select, FirstPersonCharacter(self). This is the overall
    class used for our player currently, and if you picked up where we left off in
    the previous chapter, is currently set to the `StealthCaracter` class, which is
    derived from our `MasteringCharacter` of course. Upon selecting that in the Components
    tab, you can see on the right in the Details tab you can see several variables
    under the Gameplay and Projectile fly-outs that we are going to want to move to
    the new weapon class:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要首先了解现有武器的制作方式，我们需要在内容浏览器中再次打开Content | FirstPersonCPP | Blueprints | FirstPersonCharacter，如果你正在重新打开它，请再次单击“打开完整蓝图编辑器”选项。在主窗口中，点击视口选项卡，当你点击这些其他项目时，你可以看到它们在蓝图中的当前显示或表示方式。但是，首先需要点击的是组件选项卡中的第一个可选项，即FirstPersonCharacter(self)。这是我们当前使用的整体类，如果你从上一章的结尾继续，它目前设置为`StealthCaracter`类，当然是从我们的`MasteringCharacter`派生出来的。在组件选项卡中选择它后，你可以在右侧的详细信息选项卡中看到在游戏玩法和弹体飞出下有几个变量，我们希望将它们移动到新的武器类中：
- en: '![](img/d942fe01-f40c-424c-849e-cf19799a4d32.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d942fe01-f40c-424c-849e-cf19799a4d32.png)'
- en: The Gun Offset, Fire Sound, Fire Animation, and the Projectile Class should
    all be moved into our new class as, of course, these will naturally vary from
    weapon to weapon. Looking back to the Components tab, you can also see there is
    an FP_Gun (Inherited) component, and under it, an FPMuzzleLocation (Inherited)
    component. These are a Skeletal Mesh Component and simple Scene Component, respectively,
    but also belong with the weapon and not with our character here directly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 枪偏移、射击声音、射击动画和弹体类都应该移动到我们的新类中，因为这些当然会根据不同的武器而自然变化。回顾一下组件选项卡，你还可以看到有一个FP_Gun（继承）组件，以及其下的FPMuzzleLocation（继承）组件。这些分别是骨骼网格组件和简单的场景组件，但它们也属于武器，而不是直接属于我们的角色。
- en: So, back to the main editor window and the Content Browser, let's use the shortcut
    mentioned in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml), *Making
    a C++ Project for a First-Person Shooter*, and right-click in the main window
    to get the popup with New C++ Class near the top and add one. In this case, we
    want the parent class to simply be Actor, so for once we don't need to click the
    Show all classes option. Select it and then click Next as before. Here, we'll
    name the class `MasteringWeapon`, and click Create Class. And once more we'll
    get a hot-reload. Once that finishes, it's back to Visual Studio to add all the
    variables mentioned earlier that our new weapons will need.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到主编辑窗口和内容浏览器，让我们使用[第1章](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml)中提到的快捷键，*为第一人称射击制作C++项目*，然后在主窗口中右键单击以获取包含“新建C++类”的弹出菜单，并将其添加到顶部。在这种情况下，我们希望父类简单地是Actor，因此我们不需要点击“显示所有类”选项。选择它，然后像之前一样点击“下一步”。在这里，我们将类命名为`MasteringWeapon`，然后点击“创建类”。然后我们还会得到一个热重载。一旦完成，就回到Visual
    Studio中添加之前提到的所有变量，这些变量是我们新武器所需的。
- en: Converting the existing gun
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换现有枪支
- en: 'Opening up `MasteringWeapon.h` and `.cpp`, let''s add some variables as `UPROPERTY`
    items again, and our goal now is to replicate what is currently done in `MasteringCharacter`
    in our weapon and then remove those items from the character class. As a reminder,
    the things our weapon needs to contain are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`MasteringWeapon.h`和`.cpp`文件，让我们再次添加一些变量作为`UPROPERTY`项，我们的目标现在是在我们的武器中复制`MasteringCharacter`中当前所做的操作，然后从角色类中删除这些项。作为提醒，我们的武器需要包含以下内容：
- en: Gun Offset (`FVector`)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枪偏移 (`FVector`)
- en: Fire Sound (`USoundBase`)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击声音 (`USoundBase`)
- en: Fire Animation (`UAnimMontage`)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 火焰动画 (`UAnimMontage`)
- en: Projectile Class (`TSubclassOf<class AMasteringProjectile>`)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹体类 (`TSubclassOf<class AMasteringProjectile>`)
- en: Weapon Mesh (`USkeletalMeshComponent`)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 武器网格 (`USkeletalMeshComponent`)
- en: Muzzle Location (`USceneComponent`)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枪口位置 (`USceneComponent`)
- en: 'At this point, as we have a bit of code work to do and don''t want to be hot-reloading
    a lot, I recommend shutting down the editor until we''re ready to add a new instance
    of `MasteringWeapon` to the game. So, let''s get to adding those variables to
    our new `.h` file. These first four you can literally cut (not copy, as we''re
    removing them) and paste from the `MasteringCharacter.h` file after making a public
    section under `GENERATED_BODY()`, and add the declaration of the constructor while
    we are here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，由于我们有一些代码工作要做，并且不想频繁地热重载，我建议在准备好添加新的 `MasteringWeapon` 实例到游戏之前关闭编辑器。那么，让我们开始将这些变量添加到我们的新
    `.h` 文件中。这前四个变量你可以直接从 `MasteringCharacter.h` 文件中剪切（不是复制，因为我们正在移除它们）并粘贴到在 `GENERATED_BODY()`
    下的公共部分之后，同时在这里添加构造函数的声明：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Do note, however, that the `ProjectileClass''` `UPROPERTY` line has been set
    to match the others, and it did not previously in `MasteringCharacter.h`. Now
    all we need is our Skeletal Mesh and Muzzle Location; we''ll add the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，`ProjectileClass'` 的 `UPROPERTY` 行已经被设置为与其他行匹配，而在 `MasteringCharacter.h`
    中之前并没有这样做。现在我们只需要我们的骨骼网格和喷口位置；我们将添加以下内容：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, keep in mind that we are departing from the template''s hardcore C++ implementation
    of all of these game objects so that we can move to a more logical and helpful
    hybrid using blueprints. So, since all of our weapons will be instances of this
    class, for now let''s just give the `GunOffset` the same default value it currently
    has (this variable is not very important right now) by changing its line in the
    `.h` file to the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请记住，我们正在从模板的硬核 C++ 实现中移除所有这些游戏对象，以便我们可以转向一个更合理且更有帮助的混合使用蓝图。因此，由于我们的所有武器都将是这个类的实例，现在让我们先给
    `GunOffset` 赋予它目前相同的默认值（这个变量现在并不很重要），通过将其在 `.h` 文件中的行更改为以下内容：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There will be a more in-depth discussion of the topic of blueprint/C++ balance
    in [Chapter 3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint Review
    and When to Use BP Scripting*, but for now you can always at least think of blueprint
    instances of classes as great containers for data, especially things that will
    be tuned during game design, such as weapon properties here. We now have all the
    variables we will be using in our weapon and could add a blueprint for our new
    gun, but it won't do anything yet, and also, by removing these variables from
    our `MasteringCharacter` class, of course, it won't compile now. Thus, our best
    course is to carry on a bit more and have our code in a better position. Back
    in `MasteringCharacter.h`, find and remove the `FP_Gun` and `FP_MuzzleLocation`
    variables. Then, search and remove all references to them *and*the four variables
    that we migrated to `MasteringWeapon.h` from the `MasteringCharacter.cpp` file.
    We can also remove the `VR_Gun` and `VR_MuzzleLocation` variables now as we'll
    make a whole new project when finally tackling a VR game later, so these are currently
    unimportant (but you can imagine otherwise converting them similarly in such a
    VR game).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于蓝图/C++ 平衡的话题将在 [第 3 章](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml) 进行更深入的讨论，*蓝图审查和何时使用
    BP 脚本*，但就目前而言，你至少可以认为类蓝图实例是数据的好容器，特别是那些在游戏设计期间将进行调整的事物，例如这里的武器属性。我们现在有了我们将在武器中使用到的所有变量，并且可以为我们的新枪添加蓝图，但到目前为止它不会做任何事情，而且，通过从我们的
    `MasteringCharacter` 类中移除这些变量，当然，现在它将无法编译。因此，我们最好的做法是继续前进，使我们的代码处于更好的位置。回到 `MasteringCharacter.h`，找到并移除
    `FP_Gun` 和 `FP_MuzzleLocation` 变量。然后，搜索并移除所有对这些变量以及我们从 `MasteringCharacter.cpp`
    文件迁移到 `MasteringWeapon.h` 的四个变量的引用。我们还可以现在移除 `VR_Gun` 和 `VR_MuzzleLocation` 变量，因为我们将在最终解决
    VR 游戏时创建一个全新的项目，所以这些目前并不重要（但你可以想象在类似的 VR 游戏中它们可能以其他方式转换）。
- en: As a tip for how I work here, as I know I need to replicate the same functionality
    later in my weapon class that's currently in our character class, I just commented
    out those sections currently used in the character and then will remove them entirely
    as each is now handled by the weapon as we continue.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我在这里工作的小贴士，因为我知道我需要在稍后在我的武器类中复制当前在角色类中使用的相同功能，我只是注释掉了这些当前在角色中使用的部分，然后将在每个部分现在由武器处理时完全移除它们。
- en: 'We can now also remove this line from `MasteringCharacter.cpp`, and we can
    be sure that we will need this in `MasteringWeapon.cpp`. Also cut and paste the
    line to there after `MasteringWeapon.h` `include`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在也可以从 `MasteringCharacter.cpp` 中移除这一行，并且我们可以确信我们将在 `MasteringWeapon.cpp`
    中需要它。同样，在 `MasteringWeapon.h` `include` 之后剪切并粘贴这一行：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, to get our components to show up in our blueprint instance, we need to
    add them in the constructor like so in our `.cpp` file (similar to how they were
    made in the character''s constructor), and we also need to add some required headers,
    starting right after the preceding line:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了让我们的组件显示在我们的蓝图实例中，我们需要在`.cpp`文件中的构造函数中添加它们，就像它们在角色的构造函数中创建的那样，并且我们还需要添加一些必需的头文件，从上一行之后开始：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this point, our character will be pretty broken if we play the game as they'll
    have no weapon, but as we need to do some editor work (adding a blueprint instance
    and another new class), this is a good time to build the game and start the editor
    back up. At this point, there is an intermediate commit submitted to GitHub's
    `Chapter 2` branch available if you need to check that things match.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果我们以这种方式玩游戏，我们的角色将会非常糟糕，因为他们将没有武器，但因为我们需要做一些编辑器工作（添加蓝图实例和另一个新类），这是一个构建游戏并重新启动编辑器的好时机。在此阶段，如果需要检查内容是否匹配，GitHub的`Chapter
    2`分支上有一个中间提交可用。
- en: Creating an inventory and adding a default gun
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建库存并添加默认枪支
- en: 'Back in the editor once more, we can work on the two remaining pieces needed
    to get back to the level of weapon functionality we began with, while having abstracted
    out the functionality to the new class: a rudimentary inventory system, and an
    actual blueprint instance of a weapon like the one we just removed from our `MasteringCharacter`
    class.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到编辑器中，我们可以着手完成剩下的两个部分，以便回到我们开始时的武器功能级别，同时将功能抽象到新类中：一个基本的库存系统，以及一个实际的武器蓝图实例，就像我们从`MasteringCharacter`类中移除的那样。
- en: 'First, let''s add the new `MasteringWeapon` to the Content Browser. Right-click
    in the browser''s main window again and select Blueprint Class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将新的`MasteringWeapon`添加到内容浏览器中。再次在浏览器的主窗口中右键单击并选择蓝图类：
- en: '![](img/964a1ada-fa55-442a-a0b3-96b5eac6d9ff.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/964a1ada-fa55-442a-a0b3-96b5eac6d9ff.png)'
- en: 'Much like when we are creating a new C++ class, here, we need to click the
    All Classes flyout at the bottom and search for and click MasteringWeapon, and
    then the Select button at the bottom. Rename the item in the content browser to
    BallGun and open it in the BP editor. Once again, I find it best here to click
    the full blueprint editor to view the changes in the viewport tab as we edit.
    In the Components tab, select WeaponMesh (Inherited) and in its details, open
    the Weapon Mesh fly-out, go down to the Mesh fly-out, and there the Skeletal Mesh
    variable has a drop-down we can click. There are so few to choose from, so simply
    pick the `SK_FPGun` asset here. Back to the Components tab, select next the MuzzleLocation
    (Inherited) under the WeaponMesh and in the Muzzle Location and Transform flyouts,
    edit the Relative Location vector to be the same values we hardcoded previously:
    `0.2`, `48.4`, `-10.6`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们创建一个新的C++类一样，在这里，我们需要点击底部的所有类展开，搜索并单击MasteringWeapon，然后点击底部的选择按钮。将内容浏览器中的项目重命名为BallGun，并在BP编辑器中打开它。再次，我发现在这里点击完整的蓝图编辑器来查看视口选项卡中的更改是最好的。在“组件”选项卡中，选择WeaponMesh（继承）并在其详细信息中打开武器网格展开，向下到网格展开，在那里骨骼网格变量有一个可以点击的下拉菜单。可供选择的不多，所以在这里简单地选择`SK_FPGun`资产。回到“组件”选项卡，接下来选择WeaponMesh下的MuzzleLocation（继承），在“喷嘴位置和变换”展开中，编辑相对位置向量为我们之前硬编码的相同值：`0.2`，`48.4`，`-10.6`。
- en: 'Now, back to the Components tab, and above the two components we were just
    editing, let''s select the base class again, BallGun(self), at the top. On the
    right, we have our Gameplay fly-out with our sound and animation variables. Select
    them from the drop-downs as the only assets we can, FirstPersonTemplateWeaponFire02
    and FirstPersonFire_Montage. Under the Projectile fly-out, select FirstPersonProjectile
    from its drop-down, and building our blueprint for this gun is now done! Click
    on the compile button and then save it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到“组件”选项卡，在我们刚刚编辑的两个组件上方，再次选择基类，即顶部的BallGun(self)。在右侧，我们有游戏玩法展开，其中包含我们的声音和动画变量。从下拉菜单中选择它们作为我们唯一可以使用的资产，即FirstPersonTemplateWeaponFire02和FirstPersonFire_Montage。在“弹道”展开中，从下拉菜单中选择FirstPersonProjectile，并为这把枪构建蓝图现在完成！点击编译按钮，然后保存：
- en: '![](img/41a7955f-4e22-4a16-8259-738d33d1f52d.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41a7955f-4e22-4a16-8259-738d33d1f52d.png)'
- en: 'Lastly, we just need to get this very minimal inventory set up and we can return
    to code up the use of our weapon. Right-click in the Content Browser again and
    click New C++ Class. We''ll make this one a very simple `UActorComponent` by choosing ActorComponent for
    the parent class, either in the filtered group or typing into the search in all
    classes. For the name, use MasteringInventory, click Create Class, and we will
    rebuild once more. In `MasteringInventory.h`, first we can this function as it
    will be unused (and remove the implementation in the `.cpp` file):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要设置这个非常基础的库存，然后我们可以回到编写武器使用的代码。再次在内容浏览器中右键单击并点击新建C++类。我们将通过选择父类为ActorComponent来创建一个非常简单的`UActorComponent`，无论是在过滤组中还是在所有类中搜索中输入。对于名称，使用MasteringInventory，点击创建类，然后我们再次重建。在`MasteringInventory.h`中，首先我们可以将此函数标记为未使用（并在`.cpp`文件中删除实现）：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will need two variables and a couple of functions like so added after `BeginPlay()`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加两个变量和一些函数，就像在`BeginPlay()`之后添加的那样：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice here that our inventory component is only going to be dealing with class
    types, not with actual in-game actors. They will still be spawned by the `MasteringCharacter`
    class as they are equipped. We''ll do that right after the implementations for
    the preceding functions are added to `MasteringInventory.cpp`, beginning directly
    after the `#include MasteringInventory.h` line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，我们的库存组件将只处理类类型，而不是实际的游戏角色。它们将由`MasteringCharacter`类在装备时生成。我们将在前述函数的实现被添加到`MasteringInventory.cpp`之后立即这样做，直接在`#include
    MasteringInventory.h`行之后：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `MasteringCharacter.h`, we need to add three things. In each of the following
    additions, I have also included the line of code that currently exists above where
    I placed the new line, so you can find where to place them. For the first, add
    `UPROPERTY` after `uint32 bUsingMotionControllers : 1`, which already exists in
    the `.h` file. Then, add the `AMasteringWeapon` pointer after `TouchItem`. And
    lastly, add the two function prototypes at the end of the third block after `GetFirstPersonCameraComponent()`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '在`MasteringCharacter.h`中，我们需要添加三件事。在每个以下添加中，我还在放置新行上方现有的代码行中包含了代码，这样你可以找到放置它们的位置。对于第一个，在`uint32
    bUsingMotionControllers : 1`之后添加`UPROPERTY`，这个已经在`.h`文件中存在。然后，在`TouchItem`之后添加`AMasteringWeapon`指针。最后，在`GetFirstPersonCameraComponent()`之后的第三个块的末尾添加两个函数原型：'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, in the `.cpp` file, we''ll need the new headers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`.cpp`文件中，我们需要新的头文件：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We need one line added to the bottom of the constructor, and we can now delete
    all the previously commented-out code for equipping and firing the old gun:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在构造函数的底部添加一行，现在我们可以删除之前注释掉的装备和射击旧枪的代码：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our `BeginPlay()` is now very simple as well:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`BeginPlay()`现在也非常简单：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`OnFire()` is also much nicer looking; as you can see here, it is very compact
    and readable:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnFire()`看起来也更简洁；如你所见，它非常紧凑且易于阅读：'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And lastly, at the bottom of the file is the implementation for equipping a
    weapon:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在文件底部是装备武器的实现：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the actual spawn location and rotation are not really significant
    as we immediately attach a successfully spawned weapon to our mesh, but it's usually
    a good idea to have some reasonable defaults there to be safe.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实际的生成位置和旋转实际上并不重要，因为我们立即将成功生成的武器附加到我们的网格上，但通常有一个合理的默认值是安全的。
- en: 'At this point, we return to our `MasteringWeapon` files, first the .h file
    where we add this line near the bottom of the class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们回到`MasteringWeapon`文件，首先是.h文件，我们在类底部附近添加这一行：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then implement it like so in the `.cpp` file to do all the work we were
    previously doing in the character:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`.cpp`文件中按照如下方式实现，以完成我们之前在角色中做的所有工作：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, all that's left to do is add a default weapon to our particular player's
    inventory component and we're back in business. Open the FirstPersonCharacter
    BP again in the editor. At the bottom of its Components tab now is our Inventory
    (Inherited). Select it, and in the Details tab, under the Gameplay, Inventory,
    and Mastering Inventory fly-outs, click the Default Weapon drop-down and select
    BallGun. Now, playing the game should have everything looking just like it was
    before, but with a system in place that can accept all manner of new weapons for
    our character, simply by adding more MasteringWeapon blueprint assets and adding
    them to our inventory for selection, which is what our next section focuses on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只剩下添加一个默认武器到我们特定玩家的库存组件中，这样我们就可以重新开始工作了。在编辑器中再次打开FirstPersonCharacter BP。在其组件选项卡的底部现在是我们继承的Inventory（库存）。选择它，在细节选项卡下，在游戏玩法、库存和Mastering
    Inventory展开项下，点击默认武器下拉菜单并选择BallGun。现在，玩游戏应该看起来和之前一样，但是有一个可以接受各种新武器的系统，只需通过添加更多的MasteringWeapon蓝图资产并将它们添加到我们的库存中进行选择即可，这正是我们下一节要关注的内容。
- en: This is a great time to take a moment and set some breakpoints in these new
    functions and step through, making sure everything looks right in the debugger.
    Note that if you try to step through some functions and it steps right over them,
    check whether you're building the game in the Development Editor and set it to
    DebugGame Editor instead. Oftentimes, these smaller functions are simply optimized
    away in development.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个很好的时机，花点时间在这些新函数中设置一些断点并逐步执行，确保在调试器中一切看起来都正确。注意，如果你尝试逐步执行一些函数，它却直接跳过了它们，检查你是否在开发编辑器中构建游戏，并将其设置为DebugGame编辑器。通常，这些较小的函数在开发过程中会被优化掉。
- en: Adding a WeaponPickup class
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个WeaponPickup类
- en: 'Now that we have a working inventory, if minimal, and a weapon class for creating
    new weapons, we need one more key piece: a way to add these new items to that
    inventory. There are functions now ready to receive this, but how do we get that
    into the game in a meaningful way? Well, there are a number of approaches here
    based on the type of game and its design needs. In the following case, we''ll
    stick to a fairly traditional FPS-style game and add a weapon pickup that can
    be dropped into our game world either during level design or dynamically.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个工作状态的库存（即使是最基本的），以及一个用于创建新武器的武器类，我们还需要一个关键的部分：一种将这些新物品添加到库存中的方法。目前已经有函数准备好接收这些内容，但如何以有意义的方式将这些内容引入游戏呢？嗯，根据游戏类型和设计需求，这里有多种方法。在以下情况下，我们将坚持一种相当传统的FPS风格游戏，并添加一个可以在关卡设计期间或动态地添加到我们的游戏世界中的武器拾取。
- en: Creating a new actor class
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的actor类
- en: As noted already, different games have different design needs in this area.
    If your game only ever had, for example, slots for weapon items (as many popular
    3D action games do), then we wouldn't really need an inventory class, nor a weapon
    pickup class. You could save yourself some trouble by just adding a couple of
    `AMasteringWeapon` pointers to your player class and in that weapon, override
    the `AAcotr's Tick(float DeltaSeconds)` function to give it a behavior when on
    the ground, and stop that behavior while it is stored and hidden or shown when
    equipped by the player. In this case, we have a very flexible and open-ended system
    that can be used for a large variety of weapons all being stored at the same time.
    The reason for adding a pick-up here is to demonstrate a different behavior when
    the item is on the ground, and add some additional data that helps us expand the
    usefulness of our inventory. As in many action FPS games, we will give the item
    pickup a visibly noticeable rotation while it sits at the proper height on the
    ground, set up its collision settings so the player can pick it up, and add an
    ammo count and power level to our weapons so that we can automatically equip the
    best item we have when one is available or our equipped one becomes unusable.
    Of course, the pickup item will also reference the MasteringWeapon it represents,
    so we will quickly build a new one here with a new MasteringProjectile to differentiate
    it since we're currently working with limited assets.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，不同游戏在这个领域有不同的设计需求。如果你的游戏，例如，只有武器物品的槽位（许多流行的3D动作游戏就是这样），那么我们实际上并不需要一个库存类，也不需要一个武器拾取类。你可以通过在你的玩家类中添加几个`AMasteringWeapon`指针来节省一些麻烦，并在那个武器中重写`AAcotr的Tick(float
    DeltaSeconds)`函数，以赋予它在地面上的行为，并在它被存储和隐藏或被玩家装备时停止该行为。在这种情况下，我们有一个非常灵活和开放的系统，可以用于同时存储大量不同类型的武器。在这里添加拾取的原因是为了展示当物品在地面上的不同行为，并添加一些有助于扩展我们库存有用性的额外数据。正如许多动作FPS游戏一样，我们将给拾取物品一个在地面适当高度上的可见旋转，设置其碰撞设置以便玩家可以拾取它，并给我们的武器添加弹药计数和功率级别，这样我们就可以在可用时自动装备最好的物品，或者当装备的物品变得不可用时。当然，拾取物品也会引用它所代表的MasteringWeapon，所以我们将快速构建一个新的，使用一个新的MasteringProjectile来区分它，因为我们目前正在处理有限的资源。
- en: For the curious, yes, this book will delve into some of the wonderful, but free,
    UE4 assets from the marketplace in future sections to address advanced visuals
    and give us some variety in the characters and more in our sample game. At the
    moment, however, we will simply work with what we have in the FPS template to
    quickly establish these core game concepts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的人来说，是的，这本书将在未来的章节中深入探讨一些来自市场的一些奇妙但免费的UE4资源，以解决高级视觉效果，并在我们的样本游戏中为角色提供一些多样性。然而，目前，我们只是简单地使用FPS模板中已有的资源，快速建立这些核心游戏概念。
- en: At this point, creating a new class is quite familiar, so hopefully we can speed
    through the steps a bit. If anything seems incorrect or not what is expected,
    naturally it is a good idea to skim through the steps previously presented regarding
    making a new class and begin work on its functionality. So, back in the editor,
    let's add yet another new C++ class, with the parent as a simple Actor. We'll
    name it `MasteringWeaponPickup`, and its implementation should actually go rather
    quickly compared to the more complicated classes we have been working on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，创建一个新的类已经相当熟悉了，所以希望我们可以稍微加快步伐。如果任何内容看起来不正确或者不符合预期，自然地，快速浏览一下之前关于创建新类的步骤，然后开始着手其功能性的开发是个好主意。因此，回到编辑器中，让我们再添加一个新的C++类，以简单的Actor作为父类。我们将它命名为`MasteringWeaponPickup`，与之前我们处理过的更复杂的类相比，其实施应该会相当迅速。
- en: We have a decision to make on where the actual pick-up functionality is implemented.
    At this point, let's take a moment to revisit encapsulation. For any readers who
    may have been around to experience Unreal Engine 3, most have a similar story
    about looking at Actor.h and Actor.cpp and thinking their eyes were going to fall
    out. These were, no pun intended, epic files, with tens of thousands of lines
    of code that implemented a myriad of possible in-game behaviors for every single
    actor (no matter how simple) in the game. Those files are still a bit large, but
    thanks to massive efforts by Epic between UE3 and UE4, they managed to move huge
    amounts of specialized code into components and specific plugins, greatly reducing
    the volume of code and number of variables on such a widely used class. The easiest
    way to get this pickup working would be to simply drop it into our `MasteringCharacter`
    class and let our character colliding with a pickup do all the work. However,
    if you begin doing this for all the systems you add to a medium or large project,
    your character class will find itself in a state like UE3's actor files, and new
    team members will have a hard time figuring out where functionality is and will
    have to familiarize themselves often with the entire voluminous class to competently
    make changes. If we encapsulate the functionality needed into the items that generally
    "own" that game behavior, it makes learning the project much easier and modifications
    become less risky and more manageable in scope for newer developers on the team.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要决定实际拾取功能在哪里实现。在这个阶段，让我们花点时间回顾一下封装的概念。对于可能经历过Unreal Engine 3的读者来说，大多数人都有类似的经历，就是查看Actor.h和Actor.cpp文件，觉得自己的眼睛都要看花了。这些文件，无意中提到的，是史诗级的文件，包含成千上万行代码，为游戏中的每个演员（无论多么简单）实现了无数可能的在游戏中的行为。这些文件仍然有点大，但多亏了Epic在UE3和UE4之间所做的巨大努力，他们成功地将大量专用代码移动到组件和特定插件中，大大减少了此类广泛使用的类的代码量和变量数。让拾取功能工作最简单的方法就是将其直接放入我们的`MasteringCharacter`类中，并让我们的角色与拾取物碰撞来完成所有工作。然而，如果你开始为添加到中型或大型项目中的所有系统这样做，你的角色类就会发现自己处于UE3的actor文件那样的状态，新团队成员将很难弄清楚功能在哪里，并且经常需要熟悉整个庞大的类才能熟练地进行修改。如果我们把需要的功能封装到通常“拥有”那种游戏行为的物品中，那么学习项目会容易得多，修改的风险也会降低，对于团队中的新开发者来说，范围管理也会更加容易。
- en: 'So in this case, let''s start early with this practice, and put the pickup
    functionality as much as possible into our `MasteringWeaponPickup` class itself.
    Here are the set of functions and variables we will need in the body of the header:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，让我们早点开始这种做法，尽可能地将拾取功能放入我们的`MasteringWeaponPickup`类本身。以下是我们在头文件主体中需要的函数和变量集：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A quick note on the `uint8` items at the end: it has been a known issue for
    some time that only this one is supported by classes exposed in blueprint. Adding
    `uint16` and `uint32` types would require a massive amount of work for several
    systems on Epic''s part, so it is not ever a high priority on their list of features
    (the amount of work versus the benefit to developers isn''t very high). In this
    case, it''s no problem, so we can take the benefit of the 8-bit version to force
    all values in our blueprint instances to always be between 0-255\. If you need
    a larger range, you''re forced to use a normal full-sized (but signed) `int` and
    then the burden is on the code side for you to check that designers modifying
    these blueprints don''t enter a value that''s not valid. So, an ongoing theme
    through all the work done in this book will be to tailor your needs to your design.
    Weapon power here is just an arbitrary value, so we can differentiate which weapons
    are better than others. Something this basic and abstract may be perfect for your
    game, depending on the number of weapons, or maybe should be computed from various
    damage and speed types of factors.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于末尾的`uint8`项的快速说明：长期以来，已知只有这一种类型被蓝图中的公开类所支持。添加`uint16`和`uint32`类型将需要Epic在多个系统上做大量的工作，因此这从来不是他们功能列表中的高优先级（工作量与对开发者的好处不成比例）。在这种情况下，这没有问题，因此我们可以利用8位版本的优势，强制所有蓝图实例中的值始终在0-255之间。如果你需要一个更大的范围，你被迫使用正常大小的（但带符号的）`int`，然后检查这些蓝图的设计师是否输入了无效值的负担就落在了代码的一边。因此，本书中完成的所有工作中将贯穿的一个主题是，根据你的设计调整你的需求。这里的武器功率只是一个任意值，因此我们可以区分哪些武器比其他武器更好。根据武器的数量，这样的基本和抽象的东西可能非常适合你的游戏，或者可能应该从各种伤害和速度等因素计算得出。
- en: 'An important part of being a top-level developer is good communication, and
    sitting with a designer to discuss a system, and (depending on the project size)
    putting this into a wiki page or another source of document storage, is key. An
    exaggerated example would be: if we knew with certainty that our game was never
    going to use more than one weapon, all of this inventory and weapon abstraction
    is largely unnecessary. Since I want to demonstrate how we can make it scale to
    a large number of weapons, that is the motivation for getting these systems in
    place early and as encapsulated as possible as we go.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为顶级开发者，良好的沟通能力至关重要，与设计师一起讨论一个系统，并且（根据项目规模）将这些内容放入维基页面或其他文档存储源中，这是关键。一个夸张的例子是：如果我们确信我们的游戏永远不会使用超过一种武器，那么所有这些库存和武器抽象在很大程度上都是不必要的。由于我想展示我们如何使其能够扩展到大量武器，这就是我们尽早并尽可能封装地设置这些系统的动机。
- en: 'So next, here are the implementations in the pickup''s `.cpp` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来，这里是在拾取项的`.cpp`文件中的实现：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, you can see, it''s fairly simple. Most of what it does is spin around on
    the ground at the speed specified by `RotationSpeed`, allows itself to be picked
    up by a player, and then destroys itself. We''ll talk about its collision filtering
    when we set up an instance, but notice that we cast the OtherActor pointer to
    a mastering character type: this of course works for subtypes (such as our `StealthCharacter`
    class), but any other `Pawn` classes will fail to cast there, returning null,
    so (as seen in that next line) we can ignore them now.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这相当简单。它的大部分功能是在地面上以由`RotationSpeed`指定的速度旋转，允许玩家拾取，然后自行销毁。我们将在设置实例时讨论其碰撞过滤，但请注意，我们将OtherActor指针强制转换为mastering
    character类型：这当然适用于子类型（例如我们的`StealthCharacter`类），但任何其他`Pawn`类将无法进行转换，返回null，因此（如下一行所示）我们现在可以忽略它们。
- en: Setting up our blueprints
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的蓝图
- en: Next, we need an actual new weapon. This will be very quick as again, right
    now we have very little to work with in the way of art assets, so we will demonstrate
    things creatively using those same art assets. Right-click on our BallGun weapon
    blueprint and click Duplicate. Rename the duplicated one BigBallGun and do the
    same trick, duplicating the FirstPersonProjectile blueprint and renaming it BigFirstPersonProjectile.
    We'll edit each of these quickly to get them ready to be pickups that can be added
    to our inventory and used by the player.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个全新的武器。由于同样地，目前我们在艺术资产方面几乎没有什么可以利用的，所以我们将使用那些相同的艺术资产进行创造性的展示。在“BallGun”武器蓝图上右键点击并选择“Duplicate”（复制）。将复制的副本重命名为“BigBallGun”，然后重复同样的操作，复制“FirstPersonProjectile”蓝图并将其重命名为“BigFirstPersonProjectile”。我们将快速编辑这些蓝图，使它们准备好可以被添加到玩家的库存中并使用。
- en: 'Open their full blueprints. In the projectile''s components, pick ProjectileMovement
    (Inherited) and on the right you''ll see the Projectile fly-out. Set the speeds
    to about double their current values, so to 6,000 to really give this one some
    punch compared to the other. In its CollisionComp (Inherited) under the Transform
    fly-out, set its scale to 2\. I prefer when possible to click the lock icon on
    the right since we''re doing universal scaling here, so you only have to type
    in the number once rather than in all three components. Then, click on its StaticMesh1
    component under its CollisionComp (Inherited), and here we make one small visual
    change: under its Static Mesh''s Materials fly-out, pick the drop-down and set
    it to M_FPGun. This material''s texture is obviously set up for the gun and not
    a ball, but it makes our new bullet silver to really help differentiate it and
    let us know which gun we''re firing (since the guns themselves otherwise look
    identical at this point). With both of these made, now go back to the BigBallGun
    blueprint''s window and click its class (BigBallGun(self)), under components.
    Now, under the Projectile fly-out, we naturally set it to our new BigFirstPersonProjectile.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 打开它们的完整蓝图。在投射物的组件中，选择“投射物移动”（继承），在右侧你会看到投射物飞出。将速度设置为大约是其当前值的两倍，即6,000，以便与其它投射物相比，真正给这个投射物一些冲击力。在其“碰撞组件”（继承）下的“变换飞出”中，将其比例设置为2。我更喜欢尽可能点击右侧的锁定图标，因为我们在这里进行的是通用缩放，所以你只需要输入一次数字，而不是在所有三个组件中输入。然后，点击其“碰撞组件”（继承）下的“StaticMesh1”组件，在这里我们进行一个小小的视觉更改：在其“静态网格材质”（飞出）下，选择下拉菜单并将其设置为M_FPGun。这种材质的纹理显然是为枪支设置的，而不是球体，但它使我们的新子弹变成银色，真正有助于区分它，并让我们知道我们正在发射哪种枪（因为在这个阶段，枪支本身看起来是相同的）。这两个组件都设置好后，现在回到BigBallGun蓝图窗口，点击其类（BigBallGun(self)），在组件下。现在，在“投射物飞出”下，我们自然将其设置为我们的新BigFirstPersonProjectile。
- en: With the weapon and projectile done, now we can finally set up our weapon pickup.
    In the Content Browser, make a new blueprint class, show all classes, and select
    our MasteringWeaponPickup. Name this BigBallGunPickup and double-click it to check
    it out. Click BigBallGunPickup(self), and under Gameplay you're welcome to change
    the rotation speed or amount of ammo in this pickup; however, be sure to at least
    change the weapon power to 1 or greater so it can "sort" above our default gun
    we'll still add from code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 武器和投射物设置好后，现在我们终于可以设置我们的武器拾取了。在内容浏览器中，创建一个新的蓝图类，显示所有类，并选择我们的MasteringWeaponPickup。将其命名为BigBallGunPickup，双击它进行检查。点击BigBallGunPickup(self)，在游戏玩法下，你可以随意更改这个拾取的旋转速度或弹药数量；然而，请确保至少将武器功率更改为1或更大，以便它可以在代码中添加的默认枪支之上“排序”。
- en: The only components at the moment should be the (self) one and a scene component.
    We'll leave the scene component, and now use a bit of blueprint work directly
    as preparation for further blueprint discussions in the next chapter. We could
    of course add these components that we're about to use in the constructor in C++
    like the template has done to date, but it's much quicker and easier to customize
    here in the blueprint. But again, depending on your project's needs, the C++ way
    might be the better choice. Doing it the way it is done here requires no code,
    but would require adding the components manually every time a new pick-up is made.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 目前应该只包含（自我）组件和一个场景组件。我们将保留场景组件，现在直接使用一些蓝图工作作为下一章进一步蓝图讨论的准备。当然，我们可以像模板至今所做的那样，在构造函数中添加我们即将使用的这些组件，但在这里在蓝图中进行定制要快得多也容易得多。但再次强调，根据您项目的需求，C++的方式可能是一个更好的选择。按照这里的方式操作不需要编写代码，但每次创建新的拾取时，都需要手动添加这些组件。
- en: 'This is another area of managing a project an expert developer will know how
    to balance: what is the bandwidth of the team compared to the project''s goals?
    If, for example, the game had many systems designers who were comfortable working
    in blueprint, it might make sense to simply allow them to do the duplicated work
    a number of times, adding these components in blueprint and require no coding
    help. On the other hand, if programmers themselves may have to set these up and
    their time is limited (hint: it always is!), it''s probably best to add the components
    into the constructor to reduce the setup time needed to make these pick-ups. Always
    keep in mind your team''s capabilities before committing to a workflow such as
    this.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是项目管理中专家开发者会知道如何平衡的另一个领域：团队的工作带宽与项目目标相比如何？例如，如果游戏有许多系统设计师，他们舒适地在蓝图上工作，那么简单地允许他们多次执行重复工作，在蓝图添加这些组件，而不需要编码帮助，可能是有意义的。另一方面，如果程序员自己可能需要设置这些组件，且他们的时间有限（提示：总是如此！），那么最好将这些组件添加到构造函数中，以减少制作这些拾取所需的设置时间。在承诺此类工作流程之前，始终牢记您团队的能力。
- en: Back to the pick-up, I renamed the scene component here so that I know it's
    really only for making an offset from the ground. Click on that scene component
    now (top component) and click the Add Component button at the top. Pick skeletal
    mesh as the type (you can rename it BallGunMesh).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 回到拾取，我已在此处重命名场景组件，以便我知道它实际上只是为了从地面创建偏移。现在单击那个场景组件（顶部组件）并单击顶部的添加组件按钮。选择骨骼网格作为类型（您可以将其重命名为BallGunMesh）。
- en: 'Note: In all likelihood in a major game, you would have separate art assets
    here, so you would use a static mesh on the pickup that is a simplified version
    and not an animated character such as the gun that is held and equipped; but again,
    we work with what we have.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在大型游戏中，很可能会在这里使用单独的艺术资产，因此您会在拾取上使用静态网格，这是一个简化版本，而不是手持和装备的动画角色，例如枪；但再次强调，我们使用我们拥有的。
- en: 'On the mesh''s details pane, find its mesh fly-out and set it to `SK_FPGun`.
    Similarly, set its material to `M_FPGun`. So that when placed on the ground it
    doesn''t actually sit flat on the ground, under its Transformation flyout, set
    the Location to be about 50.0 in Z so that it''s half a meter in the air. Now,
    we need to click the mesh and add a child component to it so that the whole pickup
    can be, well, picked up! Click the green add button again, and this time add a
    Sphere Collision component. We need to change only one thing out of good practice:
    under its Collision fly-out, change its Collision Preset in the drop-down to OverlapOnlyPawn:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在网格的详细信息面板中，找到网格展开项并将其设置为`SK_FPGun`。同样，将其材质设置为`M_FPGun`。这样，当放置在地面上时，它实际上不会完全平放在地面上，在其变换展开项下，将位置设置为大约50.0个Z单位，这样它就离地面半米高。现在，我们需要单击网格并为其添加一个子组件，以便整个拾取可以被，嗯，拾取！再次单击绿色的添加按钮，这次添加一个球体碰撞组件。出于良好的实践，我们只需更改其中的一件事：在其碰撞展开项下，将下拉菜单中的碰撞预设更改为OverlapOnlyPawn：
- en: '![](img/858d6074-03cb-4503-9d4d-2835aae15a88.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/858d6074-03cb-4503-9d4d-2835aae15a88.png)'
- en: What this does is allow the collision system to ignore all objects when deciding
    whether one has collided (or, specifically in our case, overlapped, which means
    items can pass through it), but will get this event that overlapping is happening,
    "hit" events are the ones that stop movement. This way, things like our projectiles
    won't have to be considered by the collision system, only pawns walking around,
    which is always important to limit these interactions as much as possible to keep
    performance high. Lastly, click and drag our BigBallGunPickup (the icon in the
    content browser) into the main level editor window where the environment is shown
    (the boxes and walls) and place it on the ground. Place a few if you like, so
    we can walk around and pick them up.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做允许碰撞系统在决定是否发生碰撞（或，具体到我们的案例，重叠，这意味着物品可以穿过它）时忽略所有对象，但会接收到重叠发生的事件，"击中"事件是阻止移动的事件。这样，像我们的投射物这样的东西就不必由碰撞系统考虑，只需考虑四处走动的NPC，这始终非常重要，尽可能限制这些交互以保持性能。最后，将我们的BigBallGunPickup（内容浏览器中的图标）拖放到主级别编辑器窗口中，其中显示环境（箱子墙壁）并将它放在地面上。如果您喜欢，可以放置几个，这样我们就可以四处走动并拾取它们。
- en: Back to code to finish up
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到代码以完成
- en: 'Having everything set in the editor and level, we have a few more code changes
    to make. First, we make some changes in `MasteringInventory.h`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器和级别中设置好一切后，我们还需要进行一些代码更改。首先，我们在`MasteringInventory.h`中做一些更改：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We add this `struct` to the very top of the file, just after the `#include`
    header section. We will use this in the inventory list to reference weapons from
    now on, instead of referencing the `MasteringWeapon` class itself directly (but,
    of course, this is now a member in the `struct` for our use). We use the `struct`
    to track two new properties we associate with weapons: ammo and weapon power.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个 `struct` 添加到文件的顶部，紧接在 `#include` 头部部分之后。我们将从现在开始使用这个 `struct` 在库存列表中引用武器，而不是直接引用
    `MasteringWeapon` 类（但，当然，现在它是 `struct` 中的一个成员，供我们使用）。我们使用 `struct` 来跟踪与武器相关联的两个新属性：弹药和武器功率。
- en: 'Next, after the `DefaultWeapon` variable, modify the first three functions
    (we remove passing the player for selecting weapons, and add ammo and power to
    the adding of weapons):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `DefaultWeapon` 变量之后，修改前三个函数（我们移除了传递玩家以选择武器的操作，并在添加武器时添加了弹药和功率）：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `MasteringInventory.cpp` file, add this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MasteringInventory.cpp` 文件中，添加以下内容：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At the top, right under our `#include` section, notice the `#define` used to
    show clearly that when we see this, a weapon has unlimited ammo. This is much
    safer than using -1 directly, as new team-members might not understand seeing
    the magical properties of -1 in other areas of the code. In the constructor, notice
    also that we do a trick because we know this object is a component, and thus has
    to have (when used) an owning actor, and we save this as `MyOwner`. If you set
    a breakpoint there, you''ll notice as the level editor starts, you get one instance
    with a null owner. This is the default object being constructed and thus is nothing
    to worry about. However, notice the `check`. It, well, checks for that case, but
    then will assert whether someone tried to add an inventory component to anything
    that isn''t `MasteringCharacter`, just to be safe. This check is done very rarely
    (once each time an inventory is created), so is fine being a normal `check`. Below,
    there''s a `checkSlow` I''ll explain just for contrast. This line of saving a
    pointer already cast to the right type of our owner saves us some time later when
    adding weapons, and then we also don''t have to keep passing a `MasteringCharacter`
    pointer through all these functions since, once again, we know that every player
    has one and only one inventory, and every inventory exists as part of a player.
    We also add the default weapon with unlimited ammo and a weapon power of 0\. After
    this, we basically replace the old `SelectBestWeapon`, `SelectWeapon`, and `AddWeapon`
    so that they now look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，紧接我们的 `#include` 部分下方，注意这里使用的 `#define`，它清楚地表明当我们看到这个定义时，一个武器具有无限弹药。这比直接使用
    -1 更安全，因为新团队成员可能不理解在其他代码区域看到 -1 的神奇属性。在构造函数中，你还会注意到我们进行了一个小技巧，因为我们知道这个对象是一个组件，因此在使用时必须有一个拥有者（actor），我们将这个拥有者保存为
    `MyOwner`。如果你在那里设置一个断点，你会注意到当关卡编辑器启动时，你会得到一个拥有空拥有者的实例。这是正在构建的默认对象，因此无需担心。然而，请注意
    `check`。它，嗯，检查那个情况，但随后会断言是否有人试图将库存组件添加到不是 `MasteringCharacter` 的任何东西上，只是为了确保安全。这个检查非常少（每次创建库存时只进行一次），所以作为一个普通的
    `check` 是可以的。下面，有一个 `checkSlow`，我将仅为了对比进行解释。这行代码保存了一个已经转换为正确类型的拥有者指针，这在我们稍后添加武器时节省了一些时间，并且我们也不必将这些函数中的
    `MasteringCharacter` 指针传递来传递去，因为，再次强调，我们知道每个玩家只有一个库存，每个库存都是玩家的一部分。我们还添加了默认武器，具有无限弹药和0的武器功率。在此之后，我们基本上替换了旧的
    `SelectBestWeapon`、`SelectWeapon` 和 `AddWeapon`，使它们现在看起来像这样：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that changing ammo uses a non-const iterator and a reference to the structs
    it is iterating. This way, we can simply directly modify the ammo count in the
    struct that exists in the array. Always be careful as it's very easy to simply
    use a local variable in the iterator, make a change, and not have that saved as
    you'd like in the array! Also notice `checkSlow`. Adding weapons doesn't happen
    very often either, so it is perfectly fine being a normal `check` for performance.
    I just put it there to remind myself to discuss them. `checkSlow` is only used
    in debug builds, so if content developers use a development build, they would
    never have it assert on them (which can be annoying for artists and designers
    if it were to happen, because it basically causes a crash that they can do nothing
    about). So use these wisely.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，更改弹药使用的是非 const 迭代器和它迭代的结构的引用。这样，我们就可以直接修改数组中存在的结构中的弹药计数。始终要小心，因为它很容易简单地使用迭代器中的局部变量，进行更改，但不会像你希望的那样在数组中保存！也请注意
    `checkSlow`。添加武器并不经常发生，所以它完全可以用作正常的 `check` 以提高性能。我只是把它放在那里提醒自己讨论它们。`checkSlow`
    只在调试构建中使用，所以如果内容开发者使用开发构建，它们永远不会断言（如果发生，可能会让艺术家和设计师感到烦恼，因为它基本上会导致崩溃，他们对此无能为力）。所以请明智地使用它们。
- en: In any case where a check is used that could happen in a live build and could
    be very severe, always use the `checkf` variants instead because this will also
    output whatever you format into its string output into the game's .log file. This
    way, if a player with a live version of the game has a problem, or a release build
    crashes, you can look at that log and it may immediately give you a clue as to
    what happened.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何可能发生在实际构建中并且可能非常严重的检查情况下，始终使用 `checkf` 变体，因为这将也将你格式化到其字符串输出的任何内容输出到游戏的 .log
    文件中。这样，如果一个玩家有游戏的实际版本并且遇到问题，或者发布构建崩溃，你可以查看那个日志，它可能会立即给你一个关于发生了什么的线索。
- en: 'Lastly, keeping with our theme of encapsulation, we''ll have the weapon inform
    the inventory as it spends ammo (as the gun does the firing and the inventory
    does the ammo-tracking in our game). When a gun runs out of ammo, the inventory
    will automatically try to pick the next best option, and since our default weapon
    has unlimited ammo, we always know at least something will be available. This,
    of course, can vary wildly in different styles of games, with a "dry fire" sound
    when out of ammo and trying to fire, or switching from a gun to a melee attack
    when out of ammo. Here, we''ll add this parameter to our firing function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，继续我们的封装主题，当武器消耗弹药时（正如枪支在射击时，我们的游戏中的库存负责跟踪弹药），我们将让武器通知库存。当枪支耗尽弹药时，库存将自动尝试选择下一个最佳选项，由于我们的默认武器弹药无限，我们总是知道至少有一样东西可用。当然，这在不同类型的游戏中可能会有很大的不同，当弹药耗尽并尝试射击时会有“干火”声音，或者当弹药耗尽时从枪支切换到近战攻击。在这里，我们将添加这个参数到我们的射击函数中：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And we''ll implement it in the .cpp like so at the bottom of the `Fire` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `Fire` 函数的底部按照如下方式在 .cpp 中实现它：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That's it! We can now run around our level, pick up the big gun, and watch its
    projectiles really make those boxes fly... until it's out of ammo and we're back
    to the default gun.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在可以在我们的关卡中四处走动，捡起大枪，并看着它的弹丸真的让那些箱子飞起来...直到它耗尽弹药，我们回到默认枪支。
- en: Putting our inventory to use
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用我们的库存
- en: 'Don''t worry, all the hard parts are done! But we do still have one last important,
    if less challenging, thing to do to make this more like a viable normal inventory
    in a game: swapping weapons. We''ll need an input for cycling them, and keep in
    mind that we currently auto-equip the best weapon you pick up at the time of pick-up,
    and at the moment have no way to choose anything else.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，所有困难的部分都已经完成了！但我们仍然有一个最后的重要任务，虽然挑战性不大，那就是让这个库存更像游戏中可行的普通库存：交换武器。我们需要一个输入来循环切换它们，记住我们目前会在拾取时自动装备你当时拾取的最佳武器，目前还没有选择其他武器的办法。
- en: Adding controls to cycle weapons
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加控制以循环切换武器
- en: Much like before, when we added an input for stealth and bound it to left-shift,
    let's head back to the editor's project properties and engine/input/bindings fly-outs.
    Here, we'll add two Action Mappings with the + button, and name them InventoryUp
    and InventoryDown. I like to bind these to Mouse Wheel Up and Mouse Wheel Down,
    respectively, but you're free to choose any inputs you prefer. We now have our
    means of cycling, and just need to set it up like our stealth mechanic once more
    in our character.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前添加潜行输入并将其绑定到左 Shift 键时一样，让我们回到编辑器的项目属性和引擎/输入/绑定飞出菜单。在这里，我们将使用 + 按钮添加两个动作映射，并将它们命名为
    InventoryUp 和 InventoryDown。我喜欢将它们分别绑定到鼠标滚轮向上和向下，但您可以选择任何您喜欢的输入。我们现在有了循环的手段，只需要像我们的潜行机制一样在我们的角色中再次设置它。
- en: Adding swapping of weapons to our character
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的角色添加武器交换功能
- en: 'First, we need to add cycling to our inventory. There are a number of ways
    to do this, and with a plan, you could, for example, simply sort the array based
    on the power of the items going in and store the current weapon''s array entry.
    There are dangers to this, but it would make for very fast and clear switching
    of weapons. The implementation here will be a bit rough, but is not critically
    important. Knowing ahead of time how extensively a system will get used is very
    important to long-term healthy development as well. If a system has a very rough
    but fully functional implementation, and will never likely change or be reused
    by other areas of code in the life of the project, just leave it be. We all want
    to always write perfect code, but code oftentimes comes from outside contributors
    or less experienced developers. While keeping to best practices ourselves is always
    encouraged, it''s also important to know when you don''t need to over-engineer
    something of limited scope or use; just get it working and move on. Game development
    relies on speed, and there is nothing wrong with revisiting code that was written
    under one set of requirements (such as "the game will only ever have at most two
    weapons" changes to "we now need 10 or more weapons for the player!"). Clean up
    and build things the best you can for the job they do. It''s just a classic downfall
    of many developers to not realize when something is good enough, even if it''s
    not perfect or the way we''d ideally like it. So, with that huge disclaimer, here''s
    the rough inventory cycling code to finish up this section:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的库存中添加循环功能。有几种方法可以实现这一点，例如，您可以根据物品进入时的功率对数组进行排序并存储当前武器的数组条目。这样做存在一些风险，但会使武器切换非常快速且清晰。这里的实现可能有些粗糙，但并不是至关重要的。提前了解系统将被广泛使用对于长期健康发展非常重要。如果一个系统有一个非常粗糙但完全功能性的实现，并且不太可能在整个项目生命周期中被其他代码区域更改或重用，那么就让它保持原样。我们都希望始终编写完美的代码，但代码往往来自外部贡献者或经验较少的开发者。虽然坚持最佳实践始终是鼓励的，但了解何时不需要过度设计有限范围或用途的东西也很重要；只需让它工作并继续前进。游戏开发依赖于速度，而且没有问题，可以回顾在特定要求（例如“游戏将只会有最多两把武器”）下编写的代码（改为“我们现在需要为玩家提供10把或更多的武器！”）。尽可能地为它们所做的工作进行清理和构建。这正是许多开发者常见的经典缺陷，即没有意识到某些东西已经足够好，即使它不是完美的，或者不是我们理想中的样子。所以，有了这个巨大的免责声明，以下是本节结束时的粗糙库存循环代码：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the prototypes for the functions to your `.h` file. Then, add these lines
    below all of our previous input binding in `AMasteringCharacter::SetupPlayerInputComponent`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能的原型添加到您的 `.h` 文件中。然后，在 `AMasteringCharacter::SetupPlayerInputComponent` 中的所有先前输入绑定下方添加以下这些行：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And in the character, add these functions (with their prototypes near the other
    control handling functions in the header):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在角色中添加以下这些函数（它们的原型靠近其他控制处理函数在头文件中）：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And if you were to test things like this, it would look like it's partly working
    and then breaks. Stepping through the code, a line that wasn't important before
    was missing, but seeing that CurrentWeapon was always null, it was very easy to
    add this last line to `SelectWeapon`. It's always great to keep those debugging
    skills up!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要测试类似的事情，它看起来部分工作然后又失败了。在代码中逐步执行，之前不重要的某一行缺失了，但看到 CurrentWeapon 总是 null，很容易在
    `SelectWeapon` 中添加最后一行。保持这些调试技能始终处于良好状态总是很棒的！
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Bringing it all together
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: Now, our inventory and pickups are all complete. If you launch the editor, you
    can step through the cycling up and down code to make sure everything is working
    correctly. We redundantly re-equip the default weapon if that's our only one,
    but the real work in the character's `EquipWeapon` already handles trying to switch
    from a weapon to that same weapon class and returns to the top. We now have a
    fully functional inventory that we can use to cycle through our, albeit only two,
    weapons, both up and down. Mission accomplished!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this section with a hardcoded weapon made by bolting some components
    and input onto a character. We now have a system to make infinite unique weapon
    types, make a cool pick-up item for them, add them to the inventory, switch to
    the best weapon, track ammo, switch to another weapon automatically when one runs
    out of ammo, and cycle those weapons as we want with input. This is just one example
    of many game systems that will be implemented over the course of even small game
    projects, but it has shown several fundamentals of design (in the coding sense)
    as well as game design and how they mesh together. Never over-engineer what you
    won't need, but always plan for the future and make sure that your requirements
    are all there. We've also done a bit more work directly with blueprints and its
    editor. In the next chapter, we will go in depth into what blueprints can do and
    understand a bit deeper about how it works. A major point of discussion will be
    how games can (and are!) built only using blueprint scripting and no project C++
    code. This approach has many risks, but for smaller projects or working with limited
    resources to get something demonstrated, it can be a huge benefit, and those benefits
    are there even for a C++ project such as ours if you know when to use them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is there any reasonable way we could have swapped weapons on the character the
    way the template originally set it up?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why move firing functionality out of the character and into our weapon class?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we only store actor classes, and not actors, in the inventory?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a weapon pickup class? Why not just use the weapon directly
    as the pickup?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantages are there to adding components to a class in code versus adding
    them to an instance in blueprint?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between `check`, `checkSlow`, and the `checkf` variants?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which one should always be used for live game builds checking critical code?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is finding the current weapon index in its own function?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-us/Programming/Assertions](https://docs.unrealengine.com/en-us/Programming/Assertions)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
