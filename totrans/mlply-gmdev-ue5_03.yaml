- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing the Multiplayer System with a Project Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how networks work and how computers communicate remotely,
    it’s time to test some of the basic functionalities of the Unreal Engine networking
    framework. The best way to understand how different elements interact within the
    UE environment is by using one of the available project templates and enabling
    its multiplayer capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of this chapter is to serve as a gentle introduction to the main
    UE multiplayer framework features and how to test them on a single device, such
    as your computer. By the end, you will have created your first multiplayer prototype
    and will be ready for the next step, which is creating a fully working networked
    game from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, through the next few sections, I will present you with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multiplayer game prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a multiplayer game locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating properties over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing functions over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this first prototype, you will just need UE 5 to be installed. For this
    chapter, you won’t be programming in C++, as the prototype will be Blueprints
    only.
  prefs: []
  type: TYPE_NORMAL
- en: To make things more interesting, I’ll be using some assets from Quixel Megascans
    by using the integrated plugin, but this is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished project can be found in this book’s project template on GitHub,
    in the [*Chapter 3*](B18203_03.xhtml#_idTextAnchor065) section: [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Starting from this chapter, I will use the terms “Blueprint” and “Blueprint
    Class” interchangeably. If a distinction needs to be made, I will use the appropriate
    term, such as “Anim Blueprint.”
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multiplayer game prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project, gameplay will not be the primary focus; I want you to concentrate
    on the core components of the multiplayer framework. Accordingly, the game will
    be quite simple and abide by the following basic rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Each player should control their character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server will spawn item pickups at random positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Players will capture pickups and gain points from that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game will go on indefinitely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a pre-made project such as a template is a great opportunity for you to
    gain hands-on experience with the main multiplayer capabilities in UE without
    having to waste time creating a project from scratch. Here, you’ll start by creating
    your own multiplayer game prototype by using the **TopDown** template.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project from a template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are ready, launch UE 5 from the Epic Games Launcher. Then, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Games** | **TopDown** from the available templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the project to **Blueprint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your project (for instance, `TopDown_Multiplayer`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the other settings as their default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 3**.1* shows the finished settings for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Project setup](img/Figure_03_01_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Project setup
  prefs: []
  type: TYPE_NORMAL
- en: Once the project has been created, you are ready to import some content.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Quixel Megascans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, I want to use something a bit crazy for my pickups: I am going
    to choose some fruit and vegetables from the Quixel Megascans library ([https://quixel.com/megascans](https://quixel.com/megascans))!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quixel Megascans** is a free library that contains high-resolution 3D scans:
    it is fully integrated with UE; you will just need to use your Epic Games account.
    To access the models from UE, you will need to use Quixel Bridge, a plugin that’s
    already installed in the Unreal Engine Editor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add some Megascans to the project, just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Quixel Bridge by clicking **Quickly add to the project** | **Quixel Bridge**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **3D Assets** section, look for some fruit or vegetables – or anything
    that will spark your imagination!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the assets and add them to your project by clicking the **Download**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 3**.2* depicts Quixel Bridge with some of my selected models during
    the download phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Quixel Bridge](img/Figure_03_02_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Quixel Bridge
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have obtained your assets, they will likely be of various sizes. However,
    you will need to resize them to create a visually appealing and functional pickup.
    To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, create an empty level by selecting `Content` | `Characters`
    | `Mannequins` | `Meshes` folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your models next to the reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale them so that they are about a third of the size of the reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 3**.3* shows the models once they have been resized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The resized models](img/Figure_03_03_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The resized models
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the pickups will be created from a common Blueprint parent, the best
    thing to do is to set the scale of the models to 1, which we can achieve through
    the **Modeling Tools** available in UE. Open the **Modeling Tools** panel by selecting
    it from the **Mode Selection** dropdown in the **Main Toolbar** area, as shown
    in *Figure 3**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Activating the Modeling Tools panel](img/Figure_03_04_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Activating the Modeling Tools panel
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the **Modeling Tools** panel has been enabled, execute the following steps
    for each of the models:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Transform** | **BakeRS** to activate the **Rotation and Scale** baking
    tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **New Asset Location** drop-down menu at the bottom of the tool, select
    **AutoGen** **Folder (Global)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the blue **Accept** button to start the baking process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 3**.5* depicts the **BakeRS** tool open and ready to process a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The BakeRS tool](img/Figure_03_05_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – The BakeRS tool
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this process, all three models will be of equal size, but each
    scaled to a value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing you must do is generate a collision for each of the models:'
  prefs: []
  type: TYPE_NORMAL
- en: Open each of the static meshes in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Collision** drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Add 26DOP Simplified Collision** to add a collision area to the mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the modified assets to apply the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This scene can be safely closed as you won’t be using it anymore. Open `Content`
    | `TopDown` | `Maps` folder. By doing this, your assets will be ready to use as
    pickups in the game.
  prefs: []
  type: TYPE_NORMAL
- en: The next step will be to modify the Player Controller so that you can handle
    the Pawn movement.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Player Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Player Controller from the template is already operational and works properly,
    but to make the game a bit more exciting (it’s a multiplayer game, after all!),
    you’ll need to make some minor adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, character movement is controlled by a single click on a point
    on the map. However, we want players to be able to move their character by keeping
    the mouse button pressed and moving it around the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to modify the Player Controller Blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Content** | **TopDown** | **Blueprints** and open the **BP_TopDownController**
    Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, open the Event Graph by clicking the **Event** **Graph** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the **Set Destination Input – Touch** group as you won’t be using it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Set Destination Input – Gamepad and Mouse** group, delete all the nodes
    connected to the **Canceled** and **Completed** execution pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Ongoing** execution pin to the same **Branch** node as the **Triggered**
    execution pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The modified graph should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The modified graph for the Player Controller](img/Figure_03_06_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The modified graph for the Player Controller
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Player Controller has been modified, if you try playing the game
    as is, you should be able to move your character around whenever you keep the
    left mouse button pressed. This is the normal behavior you would expect when playing
    a standalone game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn how to set up UE so that it simulates a multiplayer
    session on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a multiplayer game locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing a multiplayer game can pose a problem as it requires the game to be
    available across multiple devices. Luckily, UE allows you to simulate this scenario
    on a single computer, making it much easier for developers to create and test
    multiplayer games. In this section, you will learn how to use your editor as a
    server and launch other game instances locally.
  prefs: []
  type: TYPE_NORMAL
- en: Playing as a Listen Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s time to start testing how the game works in a multiplayer environment.
    You’ll be doing this by using UE’s **Net** **Mode** feature:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Change Play Mode and Play Settings** menu by clicking the hamburger
    button next to the **Play** button, as shown in *Figure 3**.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The hamburger button](img/Figure_03_07_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The hamburger button
  prefs: []
  type: TYPE_NORMAL
- en: In the `3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select **Net Mode** | **Play As Listen Server**, as shown in *Figure
    3**.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The Net Mode settings](img/Figure_03_08_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – The Net Mode settings
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you are testing a game in the Editor as a **Listen Server**, the Editor
    acts as a server and a client. Depending on the number of players selected, additional
    instances will be opened for testing purposes. As a side note, launching the game
    in **New Editor Window (PIE)** mode will designate one of the screens as the server
    and the other screens as clients. This distinction can be identified by examining
    the title bar of the launched windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now click the **Play** button, after which the Editor will open one
    window for each additional player, as depicted in *Figure 3**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Testing the game as a Listen Server](img/Figure_03_09_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Testing the game as a Listen Server
  prefs: []
  type: TYPE_NORMAL
- en: Focusing on each window will let you play each independent character.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you check the **Outliner** window while in Play Mode, you will notice that
    there are three **BP_TopDownCharacter** instances (one for each player), but just
    one **BP_TopDownController** – this is the one you will need for the local player.
  prefs: []
  type: TYPE_NORMAL
- en: Updating over the network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you may be wondering how characters can be synchronized across
    different clients, given that we have not done anything related to the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is **replication**, which I explained in the previous chapter, and
    is demonstrated in this prototype: Character Actors are replication-enabled, so
    some of their properties, such as **Location** and **Rotation**, are updated across
    clients during gameplay.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see whether an Actor replicates, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **BP_TopDownCharacter** Blueprint by going to **Content** | **TopDown**
    | **Blueprints**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Details** panel by clicking the **Class** **Defaults** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the **Replication** category and notice that the **Replicates** attribute
    has been selected. Additionally, notice that **Replicate Movement** is selected,
    as depicted in *Figure 3**.10*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The Replication category](img/Figure_03_10_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – The Replication category
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the best parts of activating the **Replicates** attribute is that properties
    will be updated automatically over the network: you won’t need to do anything
    else. Later, you will learn how to execute functions by calling them over the
    network.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional character spawn points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may have noticed, the three players have been spawned next to each other:
    this is because we have a single Player Start Actor in the level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix things up, you will be adding some more spawn points:'
  prefs: []
  type: TYPE_NORMAL
- en: Add several **Player Start** objects, up to the number of players you want to
    test – you can do this by clicking the **Quickly Add To The Project** button,
    then selecting **Basic** | **Player Start**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place them anywhere on the map that you deem suitable for your game. In *Figure
    3**.11*, you can see my choice for the three spawn points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Adding more spawn points](img/Figure_03_11_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Adding more spawn points
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test your game at this point, you will notice that players are now randomly
    spawning at the **Player Start** positions, but sometimes, two or more characters
    still end up at the same spawn point. This can easily be fixed by checking positions
    that have already been taken and excluding them from the selection when a new
    player joins the session. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **BP_TopDownGameMode** Blueprint by going to **Content** | **Topdown**
    | **Blueprints**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, open the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **My Blueprints** | **Functions**, add an override to the **ChoosePlayerStart**
    function by clicking the **Override** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Get All Actors Of Class** node and connect its incoming execution pin
    to the execution pin of the **Choose Player Start** node. Then, set the **Actor
    Class** drop-down attribute to **Player Start**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **For Each Loop** node to cycle through all the **Out Actor** properties
    you found in the previous node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Loop Body** execution pin to a **Branch** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the **Array Element** pin for the loop to get a **Player
    Start Tag** node and connect its outgoing pin to a not equal (**!=**) node. Assign
    the comparison value of this node to **Used**. Connect the outcome of this check
    to the **Condition** pin of the **Branch** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **True** execution pin of the **Branch** node to a **Set Player
    Start** **Tag** nodewith a value equal to **Used**. The **Target** pin should
    be connected to the **Array Element** area of the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of the **Set** node to the graph’s **Return
    Node**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Return Value** pin of **Return Node** should be set to the **Array Element**
    property of the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resulting Blueprint is shown in *Figure 3**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The Game Mode graph](img/Figure_03_12_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – The Game Mode graph
  prefs: []
  type: TYPE_NORMAL
- en: What this graph does is cycle through all of the **Player Start** objects in
    the level and look for one that has not been tagged as **Used** (that is, it has
    not been taken already). Once a good candidate has been found, it is tagged as
    **Used** and its value is returned, ready to be used as a spawn point for the
    character.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game – each character should now be spawned at unique locations. With
    that, your players are now ready to interact with the level!
  prefs: []
  type: TYPE_NORMAL
- en: 'Play around and test your game: check that everything runs as expected and
    that players are correctly synchronized over all clients.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to update attributes across multiple
    clients by adding some pickups and assigning points to the characters as they
    get them.
  prefs: []
  type: TYPE_NORMAL
- en: Updating properties over the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it’s time to add some gameplay and properly synchronize elements at runtime.
    In the next few subsections, you’ll work on the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the pickup Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding pickup variants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a points counter to the characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s add these features now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the pickup Blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we are going to create is a pickable item that will grant points
    to the character that picks it up by sending them a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this type of communication, you’ll need to create an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `Blueprint` folder, right-click and select **Blueprints** | **Blueprint
    Interface**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the interface `PointsAdder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Blueprint Interface**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the default function `AddPoints`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `Value` that’s of the **Integer** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The interface you have just created should be the same as the one shown in
    *Figure 3**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The PointsAdder interface with the AddPoints declaration](img/Figure_03_13_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – The PointsAdder interface with the AddPoints declaration
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the interface is ready, you’ll need to create the pickup Blueprint that
    will use it:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `Blueprints` folder, add a Blueprint Class that inherits from `BP_BasePickup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Blueprint. Then, select the **Class Defaults** tab and add a mesh of
    your choice to the **Static** **Mesh** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Physics** section, enable the **Simulate Physics** attribute and check
    that the **Enable Gravity** attribute has been enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **SphereCollision** component to the Blueprint components hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the component `Trigger` and ensure that the **Generate Overlap Events**
    attribute has been enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Sphere Radius** attribute of the **SphereCollision** component to
    a value that is a little bigger than the static meshes you’ll be using (for instance,
    **50**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you need to add some code logic to the Blueprint. First, let’s add a points
    value for the picking character:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a variable of the `Points`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make it **Instance Editable** by clicking the eye button next to the variable
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After compiling, set the variable's **Default Value** to **1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Blueprint Viewport should look the same as what’s shown in *Figure 3**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – The pickup Viewport](img/Figure_03_14_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – The pickup Viewport
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to set the overlap event behavior for the Blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the **Event BeginPlay** and **Event Tick** nodes as you won’t be using
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Cast To Character** node and connect its incoming execution pin to the
    outgoing pin of **Event ActorBeginOverlap**, to check that the actor is of the
    required type (that is, a Character).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the check succeeds, then add an **AddPoints (Message)** node: this is the
    function you previously declared in the interface.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **As Character** pin of the cast to the **Target** pin of the function
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Get Points** node to the graph and connect the pin to the **Value**
    pin of the **Add Points** function node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the outgoing execution pin of the **Add Points** node to a
    **Destroy Actor** node to remove the pickup once it has been taken.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final graph should be similar to the one shown in *Figure 3**.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – The pickup Event Graph](img/Figure_03_15_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – The pickup Event Graph
  prefs: []
  type: TYPE_NORMAL
- en: 'What this graph does is pretty straightforward: whenever an actor overlaps
    with the pickup, the pickup will send an **AddPoints** message through the interface
    and then destroy itself. If the overlapping actor won’t implement the interface,
    the message will simply be lost without dispatching any errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to take the most crucial step in the process: enabling replication.
    To do this, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Components** tab, select the **BP_BasePickup (****self)** element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the **Details** panel, look for the **Replication** category and enable
    the **Replicates** attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have a base pickup, you can create variants, ready to be used in-game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding pickup variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a variant for the pickup Blueprint is quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your **BP_BasePickup** item in the Content Browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Create Child Blueprint Class**, give your new pickup a name, and open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Class Defaults** tab. Then, assign a mesh to the **Static Mesh**
    field (in my case, a fruit Megascan).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign a value of your choice to the **Points** attribute, as shown in *Figure
    3**.16*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The settings for the orange pickup](img/Figure_03_16_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – The settings for the orange pickup
  prefs: []
  type: TYPE_NORMAL
- en: Repeat these steps for each of your pickups and you’ll be ready to go!
  prefs: []
  type: TYPE_NORMAL
- en: Before you implement the **AddPoints** interface for the Blueprint character,
    you are free to add some of the brand-new pickups and test the game as a listen
    server multiplayer game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If your pickups seem to have different rotations through the clients, this means
    that you probably didn’t enable replication. Please make sure that the **Replicates**
    and **Replicate Movement** fields are checked for your Blueprints!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a points counter to the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to replicate Actors across the network, it is time to
    learn how to replicate single variables and how to intercept changes at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll be doing this by keeping track of the points that have been gained by
    each player by displaying them next to the gaming Actor. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Blueprints` project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Points** variable of the **Integer** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel of the **Points** property, look for the **Replication**
    field and, from the drop-down menu, select **RepNotify**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that, once the **RepNotify** field has been selected, a function
    named **OnRep_Points** has been added to your Blueprint – this function will be
    called on the clients every time the variable is updated by the authoritative
    Actor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the **RepNotify** and **Replicated** values is that in
    the second case, the variable will be updated over the network without executing
    any notification function. It should also be noted that the **OnRep_XXX** function
    is called from the server on each client, and will not be executed on the server
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are now going to add a text component to the character to display the points
    they have gained during the match:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `PointsLabel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the component anywhere you deem appropriate. I opted for these **Transform**
    values: **Location (-120, 0, -80)** and **Rotation (0,** **90, 180)**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enhance the characteristics of the components according to your wishes. I opted
    for the settings shown in *Figure 3**.17*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.17 – The PointsLabel component](img/Figure_03_17_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – The PointsLabel component
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s finally time to let pickups communicate with the character. We will do
    this by implementing the interface we defined some time ago:'
  prefs: []
  type: TYPE_NORMAL
- en: With **BP_TopDownCharacter** open, select the **Class** **Settings** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, click the **Add** drop-down button on the **Implemented
    Interfaces** field and select the **PointsAdded** interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new function named **AddPoints** will be added to the **Interfaces** section
    of the **MyBlueprint** tab. Right-click on the function’s name and select **Implement
    Event** – this will add the corresponding node to the Event Graph and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Points** variable into the Event Graph and select the **Set** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Points** variable again, this time selecting the **Get** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the outgoing **Value** pin from the event to the **Get Points** node by
    using an **Add** (**+**) node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the execution pin of the **Event** node to the **Set** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the result pin of the **Add** node to the **Points** pin of the set
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that both the **Set** and **Get** nodes you added to your graph
    now have an icon in the top-right corner. In addition, the **Set** node is decorated
    with text stating **w/Notify**: this means that the **Points** variable is replicated
    with a function notification.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.18* shows the final graph for the **AddPoints** event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – The AddPoints event](img/Figure_03_18_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – The AddPoints event
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is implement the notification function so that
    we can update the points that are displayed to the character:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the **OnRep_Points** function to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Get** node from the **PointsLabel** component in the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From its outgoing pin, add a **Set Text** node, and connect its incoming execution
    pin to the outgoing execution pin of the **On Rep** **Points** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Get** node from the **Points** variable in the Event Graph and connect
    its pin to the **Value** pin of the **Set Text** node. Unreal will automatically
    add a **To Text** conversion node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final graph should be pretty similar to the one depicted in *Figure 3**.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – The On Rep Points graph](img/Figure_03_19_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – The On Rep Points graph
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you test the game, you should be able to see all the clients update
    whenever a player gets a pickup in the level.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve learned about how objects are updated during a multiplayer
    session. Specifically, you gained insight into how Actors are replicated and how
    to detect changes in variables through replication notifications. In the next
    section, you will work on enhancing your prototype by adding a spawn area for
    your pickups and making some aesthetic improvements to your characters so that
    they can easily be identified. You will achieve this by calling functions over
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: Executing functions over the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to properly call functions over the network
    and what the word “authority” really means for the UE multiplayer system. In particular,
    you will get some insight into which entity should execute a function when it
    has been called: a client or the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Spawning Actors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is time to start adding pickups at runtime. You are going to achieve this
    by adding a spawn area Blueprint to the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Blueprint should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose a random position every time it spawns something
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn random pickups at predefined intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And obviously... behave correctly over the network!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a random spawn position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by creating the Blueprint and setting its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Actor Blueprint and call it `BP_Spawner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `SpawnArea`, and make it the **Scene Root** component by dragging it onto
    the default one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `SpawnableObjects`, making it **Instance Editable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have compiled and saved the Blueprint, open its Event Graph. Then,
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function named `Spawn` and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the execution node of the function to a **SpawnActor from** **Class**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Get** node for the **SpawnableObjects** variable and connect its outgoing
    pin to a **Random Array** **Item** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing **Actor Class Reference** pin of **Random Node** to the
    **Class** pin of the **Spawn** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get a position for the spawned item, we will get a random location inside
    the **Box** **Collision** component:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the **Spawn Transform** pin of the **SpawnActor** node and select
    **Split** **Struct Pin**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **SpawnArea** component into the function graph and connect its pin
    to a **Get Scaled Box** **Extent** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Get Actor Location** node and connect its outgoing pin to a **Random
    Point in Bounding** **Box** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing pin of the **Get Scaled Box Extent** node to the **Half
    Size** pin of the **Random Point in Bounding** **Box** one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Return Value** pin of the **Random Point in Bounding Box** node
    to the **Spawn Transform Location** pin of the **SpawnActor** one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final graph can be seen in *Figure 3**.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – The Spawn function graph](img/Figure_03_20_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – The Spawn function graph
  prefs: []
  type: TYPE_NORMAL
- en: The **Spawn** function selects a random Blueprint Class from a given list of
    elements and generates an instance of it at a random position within a defined
    area.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning random pickups at predefined intervals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You are now going to add a timer to spawn pickups at predefined intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Event Graph section of the Blueprint and delete the **Actor BeginOverlap**
    and **Tick** events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Set Timer by Event** node and connect its incoming execution pin to
    the outgoing one of the **BeginPlay** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Time** value equal to **1** and check the box in **Looping**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the `OnTimer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the execution pin of the custom event to the **Spawn** function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What you have just done may seem pretty straightforward and correct, but it
    is actually wrong... or, at least, it’s missing something: the code will behave
    differently on each client. Bear with me for a minute while we test this wrong
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete all the pickups you may have previously added to your game level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance of **BP_Spawner** to the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the instance approximately at the center of the scene and change the **Box
    Extent** values of the **SpawnArea** component so that the box will cover the
    entire play area; if you are using the default scene, something such as **(1300,
    1600, 32)** should be fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the **SpawnArea** component above the ground – pickups should be dropped
    from above and fall to the ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add all the pickups you have created to the **Spawnable** **Objects** array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the multiplayer simulation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice that things will seem totally out of sync between clients:
    in particular, the UE instance (that is, the server) will spawn a single pickup
    at each interval, while the additional client will be spawning two.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What did we do wrong? Put simply, at the moment, every spawner in every client
    is spawning items, but only the server (the one who has the authority) is spawning
    items across the network. This means that the server will get only one pickup
    at a time, but the clients will get two: one spawned by the server, and one created
    by themselves for which the server has no knowledge at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Actor authority to correctly spawn pickups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To fix the spawning issue, we just have to tell the spawner to generate pickups
    only if they have the authority to do so (that is, that it is the server):'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Switch Has Authority** node in between the execution pin of the **BeginPlay**
    event and **Set Timer** **by Event**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Authority** execution pin to the incoming pin of the **Timer**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The corrected graph is shown in *Figure 3**.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – The spawn timer graph](img/Figure_03_21_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – The spawn timer graph
  prefs: []
  type: TYPE_NORMAL
- en: 'When you test the game now, it should behave correctly: the same object should
    be spawned at the same time in each client instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The prototype is almost finished, but I want you to create one last networked
    feature: a personalized skin for your characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Skinning characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playing the game with two or more identical characters may soon become very
    confusing. The best option for a prototype is to quickly create some colorized
    materials and assign them to the characters as soon as they are spawned. We will
    do this in a networked environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating some material instances:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Content Browser, navigate to **Content** | **Characters** | **Mannequins**
    | **Materials** | **Instances** | **Manny**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate **MI_Manny_01** several times to equal the number of connections you
    set in the **Play as a Listen Server** section (that is, **3**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new materials with your own preferred conventions; I used `MI_Manny_01_[ColorName]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open each new instance and change the **Tint** property to a color that you
    like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save all the material instances and close them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s open the character Blueprint and add another replicated variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **BP_TopDownCharacter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new variable called **SkinMaterial** of the **Material Interface Object
    Reference** type and make it **Instance Editable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the drop-down menu for the **Replication** field to **RepNotify**. This
    will create a function called **OnRep_SkinMaterial**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open the **OnRep_SkinMaterial** function to add the skin change logic.
    Then, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a reference for **Mesh** from the **Components** panel in the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Get** node for the **SkinMaterial** variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the function execution pin to a **Set** **Material** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Mesh** reference to the **Target** pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **SkinMaterial** reference to the **Material** pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The graph for this function is shown in *Figure 3**.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – The function for the replicated SkinMaterial variable](img/Figure_03_22_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – The function for the replicated SkinMaterial variable
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the **SkinMaterial** variable is changed, **OnRep_SkinMaterial** will
    take care of assigning it to the first material of the character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you need to change the material for each character once it has been added
    to the level:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Blueprints` folder, open **BP_TopDownGameMode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `SkinMaterials`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have compiled the Blueprint, add all the materials you previously created
    to the **Default Value** field in the **Details** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a variable of the `SkinCount`; this variable will be used as an index counter
    for selecting the skins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may have noticed that we are not replicating the **SkinCount** variable;
    in this case, we don’t need to do this as this variable only exists in the server
    and it is used to handle the skin of the character as soon as they are spawned
    in the game. Knowing what variables to replicate and when is a topic I’ll cover
    in *Chapter 6*, *Replicating Properties* *O**ver* *the Network*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you must get a count of the used skins. Then, every time a new connection
    is created, you will assign the next available skin to the character. To achieve
    this, you’ll be using an event named *OnRestartPlayer* that is executed every
    time a player is restarted (including when it is spawned for the first time):'
  prefs: []
  type: TYPE_NORMAL
- en: In the Event Graph, add an **Event** **OnRestartPlayer** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From **New Player**, connect a **Get Controlled** **Pawn** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cast its outgoing pin to a **BP_TopDownCharacter** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the event execution pin to the **Cast** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing **As BP Top Down Character** to a **Set Skin Material**
    node (note the **w/Notify** label that was added to indicate the notification
    call when the value is changed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the successful execution pin of the cast node to the **Set Skin** **Material**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Get** node for the **SkinMaterials** array and a **Get** node for the
    **SkinCount** variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing **Skin Materials** pin to the **Get (a** **copy)** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Skin Count** pin to the **Get** index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing pin of the **Get** node to the **Skin Material** pin of
    the **Set Skin** **Material** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the outgoing execution pin of **Set Skin Material** to an **Increment
    (++)** node. The **Skin Count x** variable should be incremented; this will keep
    track of the selected skin in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 3**.23* depicts the Game Mode graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – The Game Mode graph](img/Figure_03_23_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – The Game Mode graph
  prefs: []
  type: TYPE_NORMAL
- en: Now that the prototype has been created, it’s time to test (and play) it!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the game as a listen server – each character should have its colorized
    skin synchronized across the network and the points gained for each player should
    be correctly displayed on the character itself. *Figure 3**.24* shows the game
    prototype in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Testing the game prototype](img/Figure_03.24_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 – Testing the game prototype
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you’ve finally tested your multiplayer game prototype: players can run
    around and get the falling pickups, ready to gain points. As funny as it seems,
    this is just the beginning of multiplayer game development!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created a prototype of your first multiplayer game and
    gained knowledge about synchronizing Actors and variables across the network.
    Moreover, you started testing the prototype through the UE system, which emulates
    multiple connections concurrently, and achieved all this through the use of Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: However, moving forward, you will transition to using the C++ programming language,
    which may seem a little daunting, but I assure you that I will strive to make
    this shift as effortless as possible!
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to leave your prototype to its destiny... we have more important things
    to do! In the next chapter, you’ll start creating a game from scratch. You will
    develop it in C++ with all the advantages that come with this kind of development.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2:Networking and Multiplayer Games in Unreal Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the second part of this book, you will lay the foundation for a complete
    multiplayer project using Unreal Engine. From there, you will delve into the essential
    features of the Unreal Engine Gameplay Framework, as well as how they are implemented
    within a multiplayer context.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18203_04.xhtml#_idTextAnchor086), *Setting Up Your First Multiplayer
    Environment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18203_05.xhtml#_idTextAnchor107), *Managing Actors in a Multiplayer
    Environment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties* *O**ver
    the Network*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18203_07.xhtml#_idTextAnchor147), *Using Remote Procedure Calls
    (RPCs)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
