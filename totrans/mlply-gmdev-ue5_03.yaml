- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Testing the Multiplayer System with a Project Prototype
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用项目原型测试多人系统
- en: Now that you know how networks work and how computers communicate remotely,
    it’s time to test some of the basic functionalities of the Unreal Engine networking
    framework. The best way to understand how different elements interact within the
    UE environment is by using one of the available project templates and enabling
    its multiplayer capabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了网络的工作原理以及计算机如何远程通信，是时候测试Unreal Engine网络框架的一些基本功能了。了解UE环境中不同元素如何交互的最好方法是通过使用可用的项目模板并启用其多人功能。
- en: The main goal of this chapter is to serve as a gentle introduction to the main
    UE multiplayer framework features and how to test them on a single device, such
    as your computer. By the end, you will have created your first multiplayer prototype
    and will be ready for the next step, which is creating a fully working networked
    game from scratch.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是作为对UE主要多人框架功能和如何在单个设备（如您的电脑）上测试它们的温和介绍。到结束时，你将创建你的第一个多人原型，并准备好进行下一步，即从头开始创建一个完整工作的网络游戏。
- en: 'So, through the next few sections, I will present you with the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在接下来的几节中，我将向您介绍以下主题：
- en: Creating a multiplayer game prototype
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多人游戏原型
- en: Testing a multiplayer game locally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地测试多人游戏
- en: Updating properties over the network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上更新属性
- en: Executing functions over the network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上执行函数
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this first prototype, you will just need UE 5 to be installed. For this
    chapter, you won’t be programming in C++, as the prototype will be Blueprints
    only.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个原型，你只需要安装UE 5。对于本章，你不需要用C++编程，因为原型将是蓝图。
- en: To make things more interesting, I’ll be using some assets from Quixel Megascans
    by using the integrated plugin, but this is not mandatory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更有趣，我将使用集成插件中的Quixel Megascans的一些资源，但这不是强制性的。
- en: 'The finished project can be found in this book’s project template on GitHub,
    in the [*Chapter 3*](B18203_03.xhtml#_idTextAnchor065) section: [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的项目可以在本书的GitHub项目模板中找到，在[*第3章*](B18203_03.xhtml#_idTextAnchor065)部分：[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Starting from this chapter, I will use the terms “Blueprint” and “Blueprint
    Class” interchangeably. If a distinction needs to be made, I will use the appropriate
    term, such as “Anim Blueprint.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我将交替使用“蓝图”和“蓝图类”这两个术语。如果需要区分，我将使用适当的术语，例如“动画蓝图”。
- en: Creating a multiplayer game prototype
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多人游戏原型
- en: 'For this project, gameplay will not be the primary focus; I want you to concentrate
    on the core components of the multiplayer framework. Accordingly, the game will
    be quite simple and abide by the following basic rules:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，游戏玩法将不是主要焦点；我希望你专注于多人框架的核心组件。因此，游戏将非常简单，并遵循以下基本规则：
- en: Each player should control their character
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个玩家应该控制他们的角色
- en: The server will spawn item pickups at random positions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器将在随机位置生成物品拾取
- en: Players will capture pickups and gain points from that
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家将捕获拾取并获得分数
- en: The game will go on indefinitely
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏将无限进行
- en: Using a pre-made project such as a template is a great opportunity for you to
    gain hands-on experience with the main multiplayer capabilities in UE without
    having to waste time creating a project from scratch. Here, you’ll start by creating
    your own multiplayer game prototype by using the **TopDown** template.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预制的项目，如模板，是您获得UE主要多人功能实战经验的好机会，而无需花费时间从头创建项目。在这里，你将使用**俯视角**模板创建自己的多人游戏原型。
- en: Setting up the project from a template
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从模板设置项目
- en: 'When you are ready, launch UE 5 from the Epic Games Launcher. Then, follow
    these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，从Epic Games Launcher启动UE 5。然后，按照以下步骤操作：
- en: Select **Games** | **TopDown** from the available templates.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用的模板中选择**游戏** | **俯视角**。
- en: Set the project to **Blueprint**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目设置为**蓝图**。
- en: Name your project (for instance, `TopDown_Multiplayer`).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的项目命名（例如，`TopDown_Multiplayer`）。
- en: Leave the other settings as their default values.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他设置保留为默认值。
- en: Click the **Create** button.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮。
- en: '*Figure 3**.1* shows the finished settings for the project:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3**.1*显示了项目的完成设置：'
- en: '![Figure 3.1 – Project setup](img/Figure_03_01_B18203.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 项目设置](img/Figure_03_01_B18203.jpg)'
- en: Figure 3.1 – Project setup
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 项目设置
- en: Once the project has been created, you are ready to import some content.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建项目，你就可以导入一些内容了。
- en: Adding Quixel Megascans
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Quixel Megascans
- en: 'In this project, I want to use something a bit crazy for my pickups: I am going
    to choose some fruit and vegetables from the Quixel Megascans library ([https://quixel.com/megascans](https://quixel.com/megascans))!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我想为我的拾取使用一些疯狂的东西：我将从 Quixel Megascans 库中选择一些水果和蔬菜（[https://quixel.com/megascans](https://quixel.com/megascans)）！
- en: '**Quixel Megascans** is a free library that contains high-resolution 3D scans:
    it is fully integrated with UE; you will just need to use your Epic Games account.
    To access the models from UE, you will need to use Quixel Bridge, a plugin that’s
    already installed in the Unreal Engine Editor.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quixel Megascans** 是一个包含高分辨率 3D 扫描的免费库：它与 UE 完全集成；你只需使用你的 Epic Games 账户。要从
    UE 访问模型，你需要使用 Quixel Bridge，这是一个已安装在 Unreal Engine 编辑器中的插件。'
- en: 'To add some Megascans to the project, just do this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一些 Megascans 添加到项目中，只需这样做：
- en: Open Quixel Bridge by clicking **Quickly add to the project** | **Quixel Bridge**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **快速添加到项目** | **Quixel Bridge** 打开 Quixel Bridge。
- en: From the **3D Assets** section, look for some fruit or vegetables – or anything
    that will spark your imagination!
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **3D 资产** 部分中，寻找一些水果或蔬菜——或者任何能激发你想象力的东西！
- en: Download the assets and add them to your project by clicking the **Download**
    button.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下载** 按钮下载资产并将它们添加到你的项目中。
- en: '*Figure 3**.2* depicts Quixel Bridge with some of my selected models during
    the download phase:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.2* 展示了在下载阶段，Quixel Bridge 中的一些我选定的模型：'
- en: '![Figure 3.2 – Quixel Bridge](img/Figure_03_02_B18203.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – Quixel Bridge](img/Figure_03_02_B18203.jpg)'
- en: Figure 3.2 – Quixel Bridge
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – Quixel Bridge
- en: 'Once you have obtained your assets, they will likely be of various sizes. However,
    you will need to resize them to create a visually appealing and functional pickup.
    To do so, follow these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了你的资产，它们可能大小不一。然而，你需要调整它们的大小以创建一个视觉上吸引人且功能性的拾取。为此，请按照以下步骤操作：
- en: From the main menu, create an empty level by selecting `Content` | `Characters`
    | `Mannequins` | `Meshes` folder).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中，通过选择 `内容` | `角色` | `人体模型` | `网格` 文件夹创建一个空关卡。
- en: Add your models next to the reference.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的模型放在参考旁边。
- en: Scale them so that they are about a third of the size of the reference.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们调整到大约是参考大小的三分之一。
- en: '*Figure 3**.3* shows the models once they have been resized:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.3* 展示了调整大小后的模型：'
- en: '![Figure 3.3 – The resized models](img/Figure_03_03_B18203.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 调整大小的模型](img/Figure_03_03_B18203.jpg)'
- en: Figure 3.3 – The resized models
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 调整大小的模型
- en: 'Since the pickups will be created from a common Blueprint parent, the best
    thing to do is to set the scale of the models to 1, which we can achieve through
    the **Modeling Tools** available in UE. Open the **Modeling Tools** panel by selecting
    it from the **Mode Selection** dropdown in the **Main Toolbar** area, as shown
    in *Figure 3**.4*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于拾取将从一个共同的蓝图父级创建，最好的做法是将模型的比例设置为 1，这可以通过 UE 中的 **模型工具** 实现。通过在 **主工具栏** 区域的
    **模式选择** 下拉菜单中选择它来打开 **模型工具** 面板，如图 *图 3**.4* 所示：
- en: '![Figure 3.4 – Activating the Modeling Tools panel](img/Figure_03_04_B18203.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 激活模型工具面板](img/Figure_03_04_B18203.jpg)'
- en: Figure 3.4 – Activating the Modeling Tools panel
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 激活模型工具面板
- en: 'Once the **Modeling Tools** panel has been enabled, execute the following steps
    for each of the models:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用 **模型工具** 面板，为每个模型执行以下步骤：
- en: Select the model.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模型。
- en: Select **Transform** | **BakeRS** to activate the **Rotation and Scale** baking
    tool.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **变换** | **BakeRS** 以激活 **旋转和缩放** 烘焙工具。
- en: In the **New Asset Location** drop-down menu at the bottom of the tool, select
    **AutoGen** **Folder (Global)**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具底部的 **新资产位置** 下拉菜单中，选择 **AutoGen** **文件夹（全局）**。
- en: Click the blue **Accept** button to start the baking process.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色 **接受** 按钮以开始烘焙过程。
- en: '*Figure 3**.5* depicts the **BakeRS** tool open and ready to process a model:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.5* 展示了 BakeRS 工具已打开并准备好处理模型：'
- en: '![Figure 3.5 – The BakeRS tool](img/Figure_03_05_B18203.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – BakeRS 工具](img/Figure_03_05_B18203.jpg)'
- en: Figure 3.5 – The BakeRS tool
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – BakeRS 工具
- en: At the end of this process, all three models will be of equal size, but each
    scaled to a value of 1.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程结束时，所有三个模型将具有相同的大小，但每个都缩放到 1 的值。
- en: 'The last thing you must do is generate a collision for each of the models:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须做的最后一件事是为每个模型生成碰撞：
- en: Open each of the static meshes in the project.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目中的每个静态网格。
- en: Open the **Collision** drop-down menu.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**碰撞**下拉菜单。
- en: Select **Add 26DOP Simplified Collision** to add a collision area to the mesh.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加26DOP简化碰撞**以向网格添加碰撞区域。
- en: Save the modified assets to apply the changes.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存修改后的资产以应用更改。
- en: This scene can be safely closed as you won’t be using it anymore. Open `Content`
    | `TopDown` | `Maps` folder. By doing this, your assets will be ready to use as
    pickups in the game.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景可以安全关闭，因为你不会再使用它。打开`内容` | `TopDown` | `Maps`文件夹。通过这样做，你的资产将准备好在游戏中作为拾取物品使用。
- en: The next step will be to modify the Player Controller so that you can handle
    the Pawn movement.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是修改玩家控制器，以便你可以处理Pawn的移动。
- en: Modifying the Player Controller
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改玩家控制器
- en: The Player Controller from the template is already operational and works properly,
    but to make the game a bit more exciting (it’s a multiplayer game, after all!),
    you’ll need to make some minor adjustments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的玩家控制器已经可以正常工作，但为了使游戏更有趣（毕竟这是一个多人游戏！），你需要做一些小的调整。
- en: At the moment, character movement is controlled by a single click on a point
    on the map. However, we want players to be able to move their character by keeping
    the mouse button pressed and moving it around the level.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，角色移动是通过在地图上的一个点上单击来控制的。然而，我们希望玩家能够通过按住鼠标按钮并在关卡周围移动来移动他们的角色。
- en: 'Follow these steps to modify the Player Controller Blueprint:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤修改玩家控制器蓝图：
- en: Navigate to **Content** | **TopDown** | **Blueprints** and open the **BP_TopDownController**
    Blueprint.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**内容** | **TopDown** | **蓝图**，并打开**BP_TopDownController**蓝图。
- en: Then, open the Event Graph by clicking the **Event** **Graph** tab.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过单击**事件****图**选项卡打开事件图。
- en: Delete the **Set Destination Input – Touch** group as you won’t be using it.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**设置目的地输入 – 触摸**组，因为你不会使用它。
- en: In the **Set Destination Input – Gamepad and Mouse** group, delete all the nodes
    connected to the **Canceled** and **Completed** execution pins.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置目的地输入 – 游戏手柄和鼠标**组中，删除连接到**已取消**和**完成**执行引脚的所有节点。
- en: Connect the **Ongoing** execution pin to the same **Branch** node as the **Triggered**
    execution pin.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Ongoing**执行引脚连接到与**Triggered**执行引脚相同的**Branch**节点。
- en: 'The modified graph should look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的图应如下所示：
- en: '![Figure 3.6 – The modified graph for the Player Controller](img/Figure_03_06_B18203.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 玩家控制器修改后的图](img/Figure_03_06_B18203.jpg)'
- en: Figure 3.6 – The modified graph for the Player Controller
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 玩家控制器修改后的图
- en: Now that the Player Controller has been modified, if you try playing the game
    as is, you should be able to move your character around whenever you keep the
    left mouse button pressed. This is the normal behavior you would expect when playing
    a standalone game.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家控制器已经被修改，如果你尝试以当前状态玩游戏，你应该能够在按住左鼠标按钮时移动你的角色。这是在玩独立游戏时预期的正常行为。
- en: In the next section, you’ll learn how to set up UE so that it simulates a multiplayer
    session on your computer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何设置 UE，使其在计算机上模拟一个多人游戏会话。
- en: Testing a multiplayer game locally
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地测试多人游戏
- en: Testing a multiplayer game can pose a problem as it requires the game to be
    available across multiple devices. Luckily, UE allows you to simulate this scenario
    on a single computer, making it much easier for developers to create and test
    multiplayer games. In this section, you will learn how to use your editor as a
    server and launch other game instances locally.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 测试多人游戏可能会遇到问题，因为它需要在多个设备上提供游戏。幸运的是，UE 允许你在单个计算机上模拟这种场景，这使得开发者创建和测试多人游戏变得更加容易。在本节中，你将学习如何将你的编辑器用作服务器并在本地启动其他游戏实例。
- en: Playing as a Listen Server
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为监听服务器玩游戏
- en: 'It’s time to start testing how the game works in a multiplayer environment.
    You’ll be doing this by using UE’s **Net** **Mode** feature:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始测试游戏在多人环境中的工作了。你将通过使用 UE 的**网络****模式**功能来完成这项工作：
- en: 'Open the **Change Play Mode and Play Settings** menu by clicking the hamburger
    button next to the **Play** button, as shown in *Figure 3**.7*:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**播放**按钮旁边的汉堡按钮打开**更改播放模式和播放设置**菜单，如图**3.7**所示：
- en: '![Figure 3.7 – The hamburger button](img/Figure_03_07_B18203.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 汉堡按钮](img/Figure_03_07_B18203.jpg)'
- en: Figure 3.7 – The hamburger button
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 汉堡按钮
- en: In the `3`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`3`。
- en: 'Then, select **Net Mode** | **Play As Listen Server**, as shown in *Figure
    3**.8*:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**Net Mode** | **Play As Listen Server**，如图**3.8**所示：
- en: '![Figure 3.8 – The Net Mode settings](img/Figure_03_08_B18203.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 网络模式设置](img/Figure_03_08_B18203.jpg)'
- en: Figure 3.8 – The Net Mode settings
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 网络模式设置
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When you are testing a game in the Editor as a **Listen Server**, the Editor
    acts as a server and a client. Depending on the number of players selected, additional
    instances will be opened for testing purposes. As a side note, launching the game
    in **New Editor Window (PIE)** mode will designate one of the screens as the server
    and the other screens as clients. This distinction can be identified by examining
    the title bar of the launched windows.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编辑器中以 **监听服务器** 方式测试游戏时，编辑器充当服务器和客户端。根据所选玩家的数量，将打开额外的实例进行测试。作为旁注，以 **新编辑器窗口（PIE）**
    模式启动游戏将指定一个屏幕作为服务器，其他屏幕作为客户端。这种区别可以通过检查启动窗口的标题栏来识别。
- en: 'You can now click the **Play** button, after which the Editor will open one
    window for each additional player, as depicted in *Figure 3**.9*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以点击 **播放** 按钮，之后编辑器将为每个额外的玩家打开一个窗口，如图 *图 3*.9* 所示：
- en: '![Figure 3.9 – Testing the game as a Listen Server](img/Figure_03_09_B18203.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 以监听服务器方式测试游戏](img/Figure_03_09_B18203.jpg)'
- en: Figure 3.9 – Testing the game as a Listen Server
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 以监听服务器方式测试游戏
- en: Focusing on each window will let you play each independent character.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将焦点放在每个窗口上，你可以玩每个独立的角色。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you check the **Outliner** window while in Play Mode, you will notice that
    there are three **BP_TopDownCharacter** instances (one for each player), but just
    one **BP_TopDownController** – this is the one you will need for the local player.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在播放模式下检查 **大纲** 窗口，你会注意到有三个 **BP_TopDownCharacter** 实例（每个玩家一个），但只有一个 **BP_TopDownController**
    – 这是你为本地玩家需要的那个。
- en: Updating over the network
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过网络更新
- en: At this point, you may be wondering how characters can be synchronized across
    different clients, given that we have not done anything related to the network.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道在没有做任何与网络相关的事情的情况下，如何在不同客户端之间同步角色。
- en: 'The answer is **replication**, which I explained in the previous chapter, and
    is demonstrated in this prototype: Character Actors are replication-enabled, so
    some of their properties, such as **Location** and **Rotation**, are updated across
    clients during gameplay.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 **复制**，我在上一章中解释了它，并在本原型中演示了它：角色演员是启用了复制的，因此在游戏过程中，它们的一些属性，如 **位置** 和 **旋转**，将在客户端之间更新。
- en: 'To see whether an Actor replicates, do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看一个演员是否复制，请执行以下操作：
- en: Open the **BP_TopDownCharacter** Blueprint by going to **Content** | **TopDown**
    | **Blueprints**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 **内容** | **自顶向下** | **蓝图** 来打开 **BP_TopDownCharacter** 蓝图。
- en: Open the **Details** panel by clicking the **Class** **Defaults** tab.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **类默认** 选项卡来打开 **详情** 面板。
- en: 'Find the **Replication** category and notice that the **Replicates** attribute
    has been selected. Additionally, notice that **Replicate Movement** is selected,
    as depicted in *Figure 3**.10*:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 **复制** 类别，并注意 **复制** 属性已被选中。此外，注意 **复制移动** 已被选中，如图 *图 3*.10* 所示：
- en: '![Figure 3.10 – The Replication category](img/Figure_03_10_B18203.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 复制类别](img/Figure_03_10_B18203.jpg)'
- en: Figure 3.10 – The Replication category
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 复制类别
- en: 'One of the best parts of activating the **Replicates** attribute is that properties
    will be updated automatically over the network: you won’t need to do anything
    else. Later, you will learn how to execute functions by calling them over the
    network.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 激活 **复制** 属性的最好部分之一是属性将在网络上自动更新：你不需要做任何事情。稍后，你将学习如何通过网络调用执行函数。
- en: Adding additional character spawn points
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加额外的角色生成点
- en: 'As you may have noticed, the three players have been spawned next to each other:
    this is because we have a single Player Start Actor in the level.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，三个玩家被生成在彼此旁边：这是因为我们在关卡中有一个单独的玩家开始演员。
- en: 'To fix things up, you will be adding some more spawn points:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题，你将添加更多的生成点：
- en: Add several **Player Start** objects, up to the number of players you want to
    test – you can do this by clicking the **Quickly Add To The Project** button,
    then selecting **Basic** | **Player Start**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加几个 **玩家开始** 对象，数量最多为你要测试的玩家数量 – 你可以通过点击 **快速添加到项目** 按钮，然后选择 **基本** | **玩家开始**
    来完成此操作。
- en: 'Place them anywhere on the map that you deem suitable for your game. In *Figure
    3**.11*, you can see my choice for the three spawn points:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们放置在地图上的任何你认为适合你游戏的位置。在 *图 3*.11* 中，你可以看到我为三个生成点所做的选择：
- en: '![Figure 3.11 – Adding more spawn points](img/Figure_03_11_B18203.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 添加更多生成点](img/Figure_03_11_B18203.jpg)'
- en: Figure 3.11 – Adding more spawn points
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 添加更多生成点
- en: 'If you test your game at this point, you will notice that players are now randomly
    spawning at the **Player Start** positions, but sometimes, two or more characters
    still end up at the same spawn point. This can easily be fixed by checking positions
    that have already been taken and excluding them from the selection when a new
    player joins the session. To do this, follow these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你此时测试你的游戏，你会注意到玩家现在会在**Player Start**位置随机生成，但有时，两个或更多角色仍然会出现在同一个生成点上。这可以通过检查已经被占用的位置并在新玩家加入会话时从选择中排除它们来轻松解决。为此，请按照以下步骤操作：
- en: Open the **BP_TopDownGameMode** Blueprint by going to **Content** | **Topdown**
    | **Blueprints**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**Content** | **Topdown** | **Blueprints**打开**BP_TopDownGameMode**蓝图。
- en: Then, open the Event Graph.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开事件图。
- en: In **My Blueprints** | **Functions**, add an override to the **ChoosePlayerStart**
    function by clicking the **Override** option.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**我的蓝图** | **函数**中，通过点击**覆盖**选项为**ChoosePlayerStart**函数添加一个覆盖。
- en: Add a **Get All Actors Of Class** node and connect its incoming execution pin
    to the execution pin of the **Choose Player Start** node. Then, set the **Actor
    Class** drop-down attribute to **Player Start**.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**获取所有类别的演员**节点，并将其输入执行引脚连接到**Choose Player Start**节点的执行引脚。然后，将**演员类别**下拉属性设置为**Player
    Start**。
- en: Add a **For Each Loop** node to cycle through all the **Out Actor** properties
    you found in the previous node.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**For Each Loop**节点来遍历你在上一个节点中找到的所有**Out Actor**属性。
- en: Connect the **Loop Body** execution pin to a **Branch** node.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Loop Body**执行引脚连接到一个**分支**节点。
- en: Click and drag from the **Array Element** pin for the loop to get a **Player
    Start Tag** node and connect its outgoing pin to a not equal (**!=**) node. Assign
    the comparison value of this node to **Used**. Connect the outcome of this check
    to the **Condition** pin of the **Branch** node.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从循环的**Array Element**引脚点击并拖动以获取一个**Player Start Tag**节点，并将其输出引脚连接到一个不等于（**!=**）节点。将此节点的比较值设置为**Used**。将此检查的结果连接到**Branch**节点的**Condition**引脚。
- en: Connect the **True** execution pin of the **Branch** node to a **Set Player
    Start** **Tag** nodewith a value equal to **Used**. The **Target** pin should
    be connected to the **Array Element** area of the loop.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Branch**节点的**True**执行引脚连接到一个值为**Used**的**Set Player Start** **Tag**节点。**目标**引脚应连接到循环的**Array
    Element**区域。
- en: Connect the outgoing execution pin of the **Set** node to the graph’s **Return
    Node**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Set**节点的输出执行引脚连接到图的**返回节点**。
- en: The **Return Value** pin of **Return Node** should be set to the **Array Element**
    property of the loop.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Return Node**的**Return Value**引脚应设置为循环的**Array Element**属性。'
- en: 'The resulting Blueprint is shown in *Figure 3**.12*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的蓝图如*图3.12*所示：
- en: '![Figure 3.12 – The Game Mode graph](img/Figure_03_12_B18203.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – 游戏模式图](img/Figure_03_12_B18203.jpg)'
- en: Figure 3.12 – The Game Mode graph
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 游戏模式图
- en: What this graph does is cycle through all of the **Player Start** objects in
    the level and look for one that has not been tagged as **Used** (that is, it has
    not been taken already). Once a good candidate has been found, it is tagged as
    **Used** and its value is returned, ready to be used as a spawn point for the
    character.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此图的作用是遍历关卡中的所有**Player Start**对象，并寻找一个尚未标记为**Used**（即尚未被占用）的对象。一旦找到一个合适的候选对象，它就会被标记为**Used**，其值将被返回，准备好用作角色的生成点。
- en: Run the game – each character should now be spawned at unique locations. With
    that, your players are now ready to interact with the level!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏 – 每个角色现在应该会在独特的位置生成。有了这个，你的玩家现在可以与关卡进行交互了！
- en: 'Play around and test your game: check that everything runs as expected and
    that players are correctly synchronized over all clients.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 试试玩并测试你的游戏：确保一切按预期运行，并且玩家在所有客户端上正确同步。
- en: In the next section, you will learn how to update attributes across multiple
    clients by adding some pickups and assigning points to the characters as they
    get them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何通过添加一些拾取物并将分数分配给角色来更新多个客户端的属性。
- en: Updating properties over the network
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上更新属性
- en: 'Now, it’s time to add some gameplay and properly synchronize elements at runtime.
    In the next few subsections, you’ll work on the following features:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候添加一些游戏玩法并在运行时正确同步元素了。在接下来的几个小节中，你将致力于以下功能：
- en: Creating the pickup Blueprint
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建拾取物蓝图
- en: Adding pickup variants
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加拾取物变体
- en: Adding a points counter to the characters
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为角色添加一个点计数器
- en: Let’s add these features now.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加这些功能。
- en: Creating the pickup Blueprint
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建拾取蓝图
- en: The first thing we are going to create is a pickable item that will grant points
    to the character that picks it up by sending them a message.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的第一个东西是一个可拾取的项目，它将通过发送消息授予拾取它的角色的点数。
- en: 'To create this type of communication, you’ll need to create an interface:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此类通信，您需要创建一个接口：
- en: In your `Blueprint` folder, right-click and select **Blueprints** | **Blueprint
    Interface**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Blueprint`文件夹中，右键单击并选择**蓝图** | **蓝图接口**。
- en: Name the interface `PointsAdder`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接口命名为`PointsAdder`。
- en: Open the **Blueprint Interface**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**蓝图接口**。
- en: Rename the default function `AddPoints`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认函数重命名为`AddPoints`。
- en: Add an `Value` that’s of the **Integer** type.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**整数**类型的`Value`。
- en: 'The interface you have just created should be the same as the one shown in
    *Figure 3**.13*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建的接口应该与*图3.13*中显示的相同：
- en: '![Figure 3.13 – The PointsAdder interface with the AddPoints declaration](img/Figure_03_13_B18203.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13 – PointsAdder接口与AddPoints声明](img/Figure_03_13_B18203.jpg)'
- en: Figure 3.13 – The PointsAdder interface with the AddPoints declaration
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – PointsAdder接口与AddPoints声明
- en: 'Once the interface is ready, you’ll need to create the pickup Blueprint that
    will use it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦界面准备就绪，您需要创建一个将使用它的拾取蓝图：
- en: In your `Blueprints` folder, add a Blueprint Class that inherits from `BP_BasePickup`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Blueprints`文件夹中，添加一个继承自`BP_BasePickup`的蓝图类。
- en: Open the Blueprint. Then, select the **Class Defaults** tab and add a mesh of
    your choice to the **Static** **Mesh** field.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图。然后，选择**类默认值**选项卡，并将你选择的网格添加到**静态网格**字段中。
- en: In the **Physics** section, enable the **Simulate Physics** attribute and check
    that the **Enable Gravity** attribute has been enabled.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**物理**部分，启用**模拟物理**属性，并检查**启用重力**属性是否已启用。
- en: Add a **SphereCollision** component to the Blueprint components hierarchy.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**SphereCollision**组件添加到蓝图组件层次结构中。
- en: Name the component `Trigger` and ensure that the **Generate Overlap Events**
    attribute has been enabled.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件命名为`Trigger`，并确保**生成重叠事件**属性已被启用。
- en: Set the **Sphere Radius** attribute of the **SphereCollision** component to
    a value that is a little bigger than the static meshes you’ll be using (for instance,
    **50**).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**SphereCollision**组件的**球体半径**属性设置为比您将要使用的静态网格稍大的值（例如，**50**）。
- en: 'Now, you need to add some code logic to the Blueprint. First, let’s add a points
    value for the picking character:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要将一些代码逻辑添加到蓝图。首先，让我们为拾取角色添加一个点值：
- en: Open the Event Graph.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开事件图。
- en: Add a variable of the `Points`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Points`类型的变量。
- en: Make it **Instance Editable** by clicking the eye button next to the variable
    type.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击变量类型旁边的眼睛按钮将其设置为**实例可编辑**。
- en: After compiling, set the variable's **Default Value** to **1**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译后，将变量的**默认值**设置为**1**。
- en: 'The Blueprint Viewport should look the same as what’s shown in *Figure 3**.14*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图视口应该看起来与*图3.14*中显示的相同：
- en: '![Figure 3.14 – The pickup Viewport](img/Figure_03_14_B18203.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – 拾取视口](img/Figure_03_14_B18203.jpg)'
- en: Figure 3.14 – The pickup Viewport
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 拾取视口
- en: 'Now, it’s time to set the overlap event behavior for the Blueprint:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为蓝图设置重叠事件行为：
- en: Delete the **Event BeginPlay** and **Event Tick** nodes as you won’t be using
    them.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**Event BeginPlay**和**Event Tick**节点，因为您不会使用它们。
- en: Add a **Cast To Character** node and connect its incoming execution pin to the
    outgoing pin of **Event ActorBeginOverlap**, to check that the actor is of the
    required type (that is, a Character).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Cast To Character**节点，并将其输入执行引脚连接到**Event ActorBeginOverlap**的输出引脚，以检查演员是否为所需的类型（即，角色）。
- en: 'If the check succeeds, then add an **AddPoints (Message)** node: this is the
    function you previously declared in the interface.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果检查成功，则添加一个**AddPoints (消息)**节点：这是您之前在接口中声明的函数。
- en: Connect the **As Character** pin of the cast to the **Target** pin of the function
    node.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**As Character**引脚连接到函数节点的**目标**引脚。
- en: Add a **Get Points** node to the graph and connect the pin to the **Value**
    pin of the **Add Points** function node.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中添加一个**获取点**节点，并将引脚连接到**添加点**函数节点的**Value**引脚。
- en: Finally, connect the outgoing execution pin of the **Add Points** node to a
    **Destroy Actor** node to remove the pickup once it has been taken.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**添加点**节点的输出执行引脚连接到**销毁演员**节点，以便在拾取后删除拾取物。
- en: 'The final graph should be similar to the one shown in *Figure 3**.15*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – The pickup Event Graph](img/Figure_03_15_B18203.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – The pickup Event Graph
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'What this graph does is pretty straightforward: whenever an actor overlaps
    with the pickup, the pickup will send an **AddPoints** message through the interface
    and then destroy itself. If the overlapping actor won’t implement the interface,
    the message will simply be lost without dispatching any errors.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to take the most crucial step in the process: enabling replication.
    To do this, do the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In the **Components** tab, select the **BP_BasePickup (****self)** element.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the **Details** panel, look for the **Replication** category and enable
    the **Replicates** attribute.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have a base pickup, you can create variants, ready to be used in-game.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Adding pickup variants
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a variant for the pickup Blueprint is quite easy:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your **BP_BasePickup** item in the Content Browser.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Create Child Blueprint Class**, give your new pickup a name, and open
    it.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Class Defaults** tab. Then, assign a mesh to the **Static Mesh**
    field (in my case, a fruit Megascan).
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign a value of your choice to the **Points** attribute, as shown in *Figure
    3**.16*:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The settings for the orange pickup](img/Figure_03_16_B18203.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – The settings for the orange pickup
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Repeat these steps for each of your pickups and you’ll be ready to go!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Before you implement the **AddPoints** interface for the Blueprint character,
    you are free to add some of the brand-new pickups and test the game as a listen
    server multiplayer game.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: If your pickups seem to have different rotations through the clients, this means
    that you probably didn’t enable replication. Please make sure that the **Replicates**
    and **Replicate Movement** fields are checked for your Blueprints!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Adding a points counter to the character
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to replicate Actors across the network, it is time to
    learn how to replicate single variables and how to intercept changes at runtime.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll be doing this by keeping track of the points that have been gained by
    each player by displaying them next to the gaming Actor. Follow these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Open `Blueprints` project folder.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Points** variable of the **Integer** type.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel of the **Points** property, look for the **Replication**
    field and, from the drop-down menu, select **RepNotify**.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that, once the **RepNotify** field has been selected, a function
    named **OnRep_Points** has been added to your Blueprint – this function will be
    called on the clients every time the variable is updated by the authoritative
    Actor.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the **RepNotify** and **Replicated** values is that in
    the second case, the variable will be updated over the network without executing
    any notification function. It should also be noted that the **OnRep_XXX** function
    is called from the server on each client, and will not be executed on the server
    itself.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**RepNotify**和**Replicated**值之间的区别在于，在第二种情况下，变量将在网络上更新，而无需执行任何通知函数。还应注意的是，**OnRep_XXX**函数在每个客户端由服务器调用，而不会在服务器本身上执行。'
- en: 'You are now going to add a text component to the character to display the points
    they have gained during the match:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在将向角色添加一个文本组件，以显示他们在比赛中获得的分数：
- en: Add a `PointsLabel`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`PointsLabel`。
- en: 'Place the component anywhere you deem appropriate. I opted for these **Transform**
    values: **Location (-120, 0, -80)** and **Rotation (0,** **90, 180)**.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件放置在您认为合适的位置。我选择了这些**变换**值：**位置 (-120, 0, -80)**和**旋转 (0, 90, 180)**。
- en: 'Enhance the characteristics of the components according to your wishes. I opted
    for the settings shown in *Figure 3**.17*:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的意愿增强组件的特性。我选择了*图3.17*中显示的设置：
- en: '![Figure 3.17 – The PointsLabel component](img/Figure_03_17_B18203.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17 – PointsLabel组件](img/Figure_03_17_B18203.jpg)'
- en: Figure 3.17 – The PointsLabel component
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – PointsLabel组件
- en: 'It’s finally time to let pickups communicate with the character. We will do
    this by implementing the interface we defined some time ago:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让拾取物与角色进行通信了。我们将通过实现我们之前定义的接口来完成此操作：
- en: With **BP_TopDownCharacter** open, select the **Class** **Settings** tab.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**BP_TopDownCharacter**打开的情况下，选择**类** **设置**标签页。
- en: In the **Details** panel, click the **Add** drop-down button on the **Implemented
    Interfaces** field and select the **PointsAdded** interface.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，单击**实现接口**字段上的**添加**下拉按钮并选择**PointsAdded**接口。
- en: A new function named **AddPoints** will be added to the **Interfaces** section
    of the **MyBlueprint** tab. Right-click on the function’s name and select **Implement
    Event** – this will add the corresponding node to the Event Graph and select it.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为**AddPoints**的新函数添加到**MyBlueprint**标签页的**接口**部分。右键单击函数名称并选择**实现事件** – 这将在事件图中添加相应的节点并选择它。
- en: Drag the **Points** variable into the Event Graph and select the **Set** option.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Points**变量拖入事件图，并选择**设置**选项。
- en: Drag the **Points** variable again, this time selecting the **Get** option.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次拖动**Points**变量，这次选择**获取**选项。
- en: Add the outgoing **Value** pin from the event to the **Get Points** node by
    using an **Add** (**+**) node.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**添加**（**+**）节点将事件的输出**值**引脚添加到**获取点**节点。
- en: Connect the execution pin of the **Event** node to the **Set** node.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**事件**节点的执行引脚连接到**设置**节点。
- en: Connect the result pin of the **Add** node to the **Points** pin of the set
    node.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**添加**节点的结果引脚连接到设置节点的**Points**引脚。
- en: Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will notice that both the **Set** and **Get** nodes you added to your graph
    now have an icon in the top-right corner. In addition, the **Set** node is decorated
    with text stating **w/Notify**: this means that the **Points** variable is replicated
    with a function notification.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，您添加到图中的**设置**和**获取**节点现在在右上角都有一个图标。此外，**设置**节点上还装饰有表示**带有通知**的文本：这意味着**Points**变量是通过带有函数通知进行复制的。
- en: '*Figure 3**.18* shows the final graph for the **AddPoints** event:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.18*显示了**AddPoints**事件的最终图：'
- en: '![Figure 3.18 – The AddPoints event](img/Figure_03_18_B18203.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图3.18 – 添加点事件](img/Figure_03_18_B18203.jpg)'
- en: Figure 3.18 – The AddPoints event
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 添加点事件
- en: 'The last thing we need to do is implement the notification function so that
    we can update the points that are displayed to the character:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是实现通知函数，以便我们可以更新显示给角色的分数：
- en: Double-click on the **OnRep_Points** function to open it.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**OnRep_Points**函数以打开它。
- en: Drag a **Get** node from the **PointsLabel** component in the Event Graph.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从事件图中的**PointsLabel**组件拖动一个**获取**节点。
- en: From its outgoing pin, add a **Set Text** node, and connect its incoming execution
    pin to the outgoing execution pin of the **On Rep** **Points** node.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其输出引脚添加一个**设置文本**节点，并将其输入执行引脚连接到**On Rep** **Points**节点的输出执行引脚。
- en: Drag a **Get** node from the **Points** variable in the Event Graph and connect
    its pin to the **Value** pin of the **Set Text** node. Unreal will automatically
    add a **To Text** conversion node.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从事件图中的**Points**变量拖动一个**获取**节点，并将其引脚连接到**设置文本**节点的**值**引脚。Unreal将自动添加一个**转换为文本**转换节点。
- en: 'The final graph should be pretty similar to the one depicted in *Figure 3**.19*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的图应该与图 *3.19* 中描述的非常相似：
- en: '![Figure 3.19 – The On Rep Points graph](img/Figure_03_19_B18203.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图3.19 – On Rep Points 图](img/Figure_03_19_B18203.jpg)'
- en: Figure 3.19 – The On Rep Points graph
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – On Rep Points 图
- en: Now, if you test the game, you should be able to see all the clients update
    whenever a player gets a pickup in the level.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你测试游戏，你应该能看到每当玩家在关卡中获得拾取物时，所有客户端都会更新。
- en: With that, you’ve learned about how objects are updated during a multiplayer
    session. Specifically, you gained insight into how Actors are replicated and how
    to detect changes in variables through replication notifications. In the next
    section, you will work on enhancing your prototype by adding a spawn area for
    your pickups and making some aesthetic improvements to your characters so that
    they can easily be identified. You will achieve this by calling functions over
    the network.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经了解了在多人游戏会话期间对象是如何更新的。具体来说，你获得了关于演员是如何复制的以及如何通过复制通知检测变量变化的见解。在下一节中，你将通过添加拾取物的生成区域并对你的人物进行一些美学改进来增强你的原型，以便它们可以轻松识别。你将通过在网络上调用函数来实现这一点。
- en: Executing functions over the network
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上执行函数
- en: 'In this section, you will learn how to properly call functions over the network
    and what the word “authority” really means for the UE multiplayer system. In particular,
    you will get some insight into which entity should execute a function when it
    has been called: a client or the server.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何正确地在网络上调用函数，以及“权限”一词对 UE 多人游戏系统真正意味着什么。特别是，你将了解在函数被调用时，哪个实体应该执行函数：客户端或服务器。
- en: Spawning Actors
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成演员
- en: It is time to start adding pickups at runtime. You are going to achieve this
    by adding a spawn area Blueprint to the level.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在运行时开始添加拾取物了。你将通过向关卡中添加一个生成区域蓝图来实现这一点。
- en: 'This Blueprint should be able to do the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此蓝图应该能够做到以下几点：
- en: Choose a random position every time it spawns something
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次生成东西时都选择一个随机位置
- en: Spawn random pickups at predefined intervals
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在预定义的时间间隔内随机生成拾取物
- en: And obviously... behave correctly over the network!
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且显然...在网络上的行为要正确！
- en: Let’s get started.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Choosing a random spawn position
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择一个随机的生成位置
- en: 'Let’s start by creating the Blueprint and setting its parameters:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建蓝图并设置其参数开始：
- en: Create a new Actor Blueprint and call it `BP_Spawner`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的演员蓝图，并将其命名为 `BP_Spawner`。
- en: Add a `SpawnArea`, and make it the **Scene Root** component by dragging it onto
    the default one.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `SpawnArea`，并通过将其拖放到默认的 **Scene Root** 组件上，使其成为 **Scene Root** 组件。
- en: Add an `SpawnableObjects`, making it **Instance Editable**.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `SpawnableObjects`，使其成为 **Instance Editable**。
- en: 'Once you have compiled and saved the Blueprint, open its Event Graph. Then,
    do the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译并保存了蓝图，打开其事件图。然后，执行以下操作：
- en: Create a function named `Spawn` and open it.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Spawn` 的函数并打开它。
- en: Connect the execution node of the function to a **SpawnActor from** **Class**
    node.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数的执行节点连接到 **SpawnActor from** **Class** 节点。
- en: Add a **Get** node for the **SpawnableObjects** variable and connect its outgoing
    pin to a **Random Array** **Item** node.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 **SpawnableObjects** 变量添加一个 **Get** 节点，并将其输出引脚连接到 **Random Array** **Item**
    节点。
- en: Connect the outgoing **Actor Class Reference** pin of **Random Node** to the
    **Class** pin of the **Spawn** node.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Random Node** 的输出 **Actor Class Reference** 引脚连接到 **Spawn** 节点的 **Class**
    引脚。
- en: 'To get a position for the spawned item, we will get a random location inside
    the **Box** **Collision** component:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要为生成的物品获取位置，我们将从 **Box** **Collision** 组件内部获取一个随机位置：
- en: Right-click on the **Spawn Transform** pin of the **SpawnActor** node and select
    **Split** **Struct Pin**.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 **SpawnActor** 节点的 **Spawn Transform** 引脚，并选择 **Split** **Struct Pin**。
- en: Drag the **SpawnArea** component into the function graph and connect its pin
    to a **Get Scaled Box** **Extent** node.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **SpawnArea** 组件拖入函数图，并将其引脚连接到 **Get Scaled Box** **Extent** 节点。
- en: Add a **Get Actor Location** node and connect its outgoing pin to a **Random
    Point in Bounding** **Box** node.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **Get Actor Location** 节点，并将其输出引脚连接到 **Random Point in Bounding** **Box**
    节点。
- en: Connect the outgoing pin of the **Get Scaled Box Extent** node to the **Half
    Size** pin of the **Random Point in Bounding** **Box** one.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Get Scaled Box Extent** 节点的输出引脚连接到 **Random Point in Bounding** **Box**
    中的一个 **Half Size** 引脚。
- en: Connect the **Return Value** pin of the **Random Point in Bounding Box** node
    to the **Spawn Transform Location** pin of the **SpawnActor** one.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Random Point in Bounding Box** 节点的 **Return Value** 引脚连接到 **SpawnActor**
    的 **Spawn Transform Location** 引脚。
- en: 'The final graph can be seen in *Figure 3**.20*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的图示可以在*图3.20*中看到：
- en: '![Figure 3.20 – The Spawn function graph](img/Figure_03_20_B18203.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图3.20 – 生成函数图](img/Figure_03_20_B18203.jpg)'
- en: Figure 3.20 – The Spawn function graph
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 – **生成函数**图
- en: The **Spawn** function selects a random Blueprint Class from a given list of
    elements and generates an instance of it at a random position within a defined
    area.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成**函数从给定元素列表中选择一个随机的蓝图类，并在定义区域内随机位置生成其实例。'
- en: Spawning random pickups at predefined intervals
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在预定间隔随机生成拾取器
- en: 'You are now going to add a timer to spawn pickups at predefined intervals:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将要添加一个计时器，以预定间隔生成拾取器：
- en: Open the Event Graph section of the Blueprint and delete the **Actor BeginOverlap**
    and **Tick** events.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图的事件图部分并删除**Actor BeginOverlap**和**Tick**事件。
- en: Add a **Set Timer by Event** node and connect its incoming execution pin to
    the outgoing one of the **BeginPlay** event.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**通过事件设置计时器**节点，并将其输入执行引脚连接到**BeginPlay**事件的输出引脚。
- en: Set the **Time** value equal to **1** and check the box in **Looping**.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**时间**值设置为**1**并勾选**循环**框。
- en: Connect the `OnTimer`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接`OnTimer`。
- en: Connect the execution pin of the custom event to the **Spawn** function.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自定义事件的执行引脚连接到**生成**函数。
- en: 'What you have just done may seem pretty straightforward and correct, but it
    is actually wrong... or, at least, it’s missing something: the code will behave
    differently on each client. Bear with me for a minute while we test this wrong
    behavior:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才所做的一切可能看起来非常直接且正确，但实际上是错误的...或者至少，它遗漏了一些东西：代码在每个客户端上的行为将不同。请稍等片刻，让我们测试一下这种错误行为：
- en: Delete all the pickups you may have previously added to your game level.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除你之前可能添加到游戏关卡中的所有拾取器。
- en: Add an instance of **BP_Spawner** to the level.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**BP_Spawner**实例添加到关卡中。
- en: Place the instance approximately at the center of the scene and change the **Box
    Extent** values of the **SpawnArea** component so that the box will cover the
    entire play area; if you are using the default scene, something such as **(1300,
    1600, 32)** should be fine.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实例放置在大约场景中心，并更改**生成区域**组件的**Box Extent**值，以便盒子将覆盖整个游戏区域；如果你使用的是默认场景，则类似于**（1300，1600，32）**应该就足够了。
- en: Place the **SpawnArea** component above the ground – pickups should be dropped
    from above and fall to the ground.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**生成区域**组件放置在地面上方 – 拾取器应该从上方掉落并落到地面上。
- en: Add all the pickups you have created to the **Spawnable** **Objects** array.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你创建的所有拾取器添加到**可生成** **对象**数组中。
- en: Run the multiplayer simulation.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行多人模拟。
- en: 'You will notice that things will seem totally out of sync between clients:
    in particular, the UE instance (that is, the server) will spawn a single pickup
    at each interval, while the additional client will be spawning two.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到客户端之间的事物看起来完全不同步：特别是，UE实例（即服务器）将在每个间隔生成一个拾取器，而额外的客户端将生成两个。
- en: 'What did we do wrong? Put simply, at the moment, every spawner in every client
    is spawning items, but only the server (the one who has the authority) is spawning
    items across the network. This means that the server will get only one pickup
    at a time, but the clients will get two: one spawned by the server, and one created
    by themselves for which the server has no knowledge at all.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做错了什么？简单来说，目前每个客户端中的每个生成器都在生成物品，但只有服务器（拥有权限的那个）在网络上生成物品。这意味着服务器每次只会得到一个拾取器，但客户端会得到两个：一个由服务器生成，另一个由客户端自己创建，而服务器对此一无所知。
- en: Using Actor authority to correctly spawn pickups
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用演员权限正确生成拾取器
- en: 'To fix the spawning issue, we just have to tell the spawner to generate pickups
    only if they have the authority to do so (that is, that it is the server):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复生成问题，我们只需告诉生成器只有在它们有权限这样做时才生成拾取器（即，它是服务器）：
- en: Add a **Switch Has Authority** node in between the execution pin of the **BeginPlay**
    event and **Set Timer** **by Event**.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**BeginPlay**事件的执行引脚和**通过事件设置计时器** **by Event**之间添加一个**Switch Has Authority**节点。
- en: Connect the **Authority** execution pin to the incoming pin of the **Timer**
    node.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**权限**执行引脚连接到**计时器**节点的输入引脚。
- en: 'The corrected graph is shown in *Figure 3**.21*:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 修正后的图示在*图3.21*中：
- en: '![Figure 3.21 – The spawn timer graph](img/Figure_03_21_B18203.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图3.21 – 生成计时器图](img/Figure_03_21_B18203.jpg)'
- en: Figure 3.21 – The spawn timer graph
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 – 生成计时器图
- en: 'When you test the game now, it should behave correctly: the same object should
    be spawned at the same time in each client instance.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在测试游戏时，它应该表现正确：相同的对象应该在每个客户端实例中同时生成。
- en: 'The prototype is almost finished, but I want you to create one last networked
    feature: a personalized skin for your characters.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 原型几乎完成了，但我希望你在创建一个最后的网络功能：为你的角色创建一个个性化皮肤。
- en: Skinning characters
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色皮肤化
- en: Playing the game with two or more identical characters may soon become very
    confusing. The best option for a prototype is to quickly create some colorized
    materials and assign them to the characters as soon as they are spawned. We will
    do this in a networked environment.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个或更多相同角色的游戏可能会很快变得非常混乱。对于原型，最佳选项是快速创建一些彩色材料，并在角色被生成时立即分配给它们。我们将在网络环境中这样做。
- en: 'Let’s start by creating some material instances:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一些材料实例：
- en: In the Content Browser, navigate to **Content** | **Characters** | **Mannequins**
    | **Materials** | **Instances** | **Manny**.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中，导航到 **Content** | **Characters** | **Mannequins** | **Materials** |
    **Instances** | **Manny**。
- en: Duplicate **MI_Manny_01** several times to equal the number of connections you
    set in the **Play as a Listen Server** section (that is, **3**).
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **MI_Manny_01** 重复几次，以等于你在 **Play as a Listen Server** 部分设置的连接数（即，**3**）。
- en: Name the new materials with your own preferred conventions; I used `MI_Manny_01_[ColorName]`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你自己的首选约定命名新材料；我使用了 `MI_Manny_01_[ColorName]`。
- en: Open each new instance and change the **Tint** property to a color that you
    like.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开每个新实例，并将 **Tint** 属性更改为你喜欢的颜色。
- en: Save all the material instances and close them.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有材料实例并关闭它们。
- en: 'Now, let’s open the character Blueprint and add another replicated variable:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开角色蓝图并添加另一个复制的变量：
- en: Open **BP_TopDownCharacter**.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **BP_TopDownCharacter**。
- en: Add a new variable called **SkinMaterial** of the **Material Interface Object
    Reference** type and make it **Instance Editable**.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 **SkinMaterial** 的新变量，其类型为 **Material Interface Object Reference**，并使其
    **Instance Editable**。
- en: Set the drop-down menu for the **Replication** field to **RepNotify**. This
    will create a function called **OnRep_SkinMaterial**.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Replication** 字段的下拉菜单设置为 **RepNotify**。这将创建一个名为 **OnRep_SkinMaterial** 的函数。
- en: 'Next, open the **OnRep_SkinMaterial** function to add the skin change logic.
    Then, do the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 **OnRep_SkinMaterial** 函数以添加皮肤更改逻辑。然后，执行以下操作：
- en: Drag a reference for **Mesh** from the **Components** panel in the Event Graph.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从事件图中拖动 **Mesh** 参考到 **Components** 面板。
- en: Drag a **Get** node for the **SkinMaterial** variable.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动一个用于 **SkinMaterial** 变量的 **Get** 节点。
- en: Connect the function execution pin to a **Set** **Material** node.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数执行插针连接到 **Set Material** 节点。
- en: Connect the **Mesh** reference to the **Target** pin.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Mesh** 参考连接到 **Target** 插针。
- en: Connect the **SkinMaterial** reference to the **Material** pin.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **SkinMaterial** 参考连接到 **Material** 插针。
- en: 'The graph for this function is shown in *Figure 3**.22*:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的图示见 *图 3.22*：
- en: '![Figure 3.22 – The function for the replicated SkinMaterial variable](img/Figure_03_22_B18203.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.22 – 复制的 SkinMaterial 变量的函数](img/Figure_03_22_B18203.jpg)'
- en: Figure 3.22 – The function for the replicated SkinMaterial variable
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – 复制的 SkinMaterial 变量的函数
- en: Whenever the **SkinMaterial** variable is changed, **OnRep_SkinMaterial** will
    take care of assigning it to the first material of the character.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当 **SkinMaterial** 变量更改时，**OnRep_SkinMaterial** 将负责将其分配给角色的第一个材料。
- en: 'Now, you need to change the material for each character once it has been added
    to the level:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要更改每个角色在添加到关卡后的材料：
- en: In the `Blueprints` folder, open **BP_TopDownGameMode**.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Blueprints` 文件夹中，打开 **BP_TopDownGameMode**。
- en: Add an `SkinMaterials`.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `SkinMaterials`。
- en: Once you have compiled the Blueprint, add all the materials you previously created
    to the **Default Value** field in the **Details** panel.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦编译了蓝图，将之前创建的所有材料添加到 **Details** 面板中的 **Default Value** 字段。
- en: Add a variable of the `SkinCount`; this variable will be used as an index counter
    for selecting the skins.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `SkinCount` 变量；这个变量将用作选择皮肤的索引计数器。
- en: You may have noticed that we are not replicating the **SkinCount** variable;
    in this case, we don’t need to do this as this variable only exists in the server
    and it is used to handle the skin of the character as soon as they are spawned
    in the game. Knowing what variables to replicate and when is a topic I’ll cover
    in *Chapter 6*, *Replicating Properties* *O**ver* *the Network*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们没有复制 **SkinCount** 变量；在这种情况下，我们不需要这样做，因为这个变量只存在于服务器上，并且用于在游戏角色被生成时立即处理角色的皮肤。了解何时以及复制哪些变量是一个我将在
    *第 6 章*，*通过网络复制属性* 中讨论的主题。
- en: 'Next, you must get a count of the used skins. Then, every time a new connection
    is created, you will assign the next available skin to the character. To achieve
    this, you’ll be using an event named *OnRestartPlayer* that is executed every
    time a player is restarted (including when it is spawned for the first time):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须获取已使用皮肤的计数。然后，每次创建新的连接时，你将分配下一个可用的皮肤给角色。为了实现这一点，你将使用一个名为*OnRestartPlayer*的事件，该事件在每次玩家重新启动时执行（包括第一次生成时）：
- en: In the Event Graph, add an **Event** **OnRestartPlayer** node.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中添加一个**Event OnRestartPlayer**节点。
- en: From **New Player**, connect a **Get Controlled** **Pawn** node.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**New Player**连接一个**Get Controlled Pawn**节点。
- en: Cast its outgoing pin to a **BP_TopDownCharacter** node.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其输出的引脚连接到**BP_TopDownCharacter**节点。
- en: Connect the event execution pin to the **Cast** node.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件执行引脚连接到**Cast**节点。
- en: Connect the outgoing **As BP Top Down Character** to a **Set Skin Material**
    node (note the **w/Notify** label that was added to indicate the notification
    call when the value is changed).
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出的**As BP Top Down Character**连接到一个**Set Skin Material**节点（注意添加的**w/Notify**标签，以指示值更改时的通知调用）。
- en: Connect the successful execution pin of the cast node to the **Set Skin** **Material**
    node.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将转换节点的成功执行引脚连接到**Set Skin Material**节点。
- en: Add a **Get** node for the **SkinMaterials** array and a **Get** node for the
    **SkinCount** variable.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**SkinMaterials**数组添加一个**Get**节点，并为**SkinCount**变量添加一个**Get**节点。
- en: Connect the outgoing **Skin Materials** pin to the **Get (a** **copy)** node.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出的**Skin Materials**引脚连接到**Get (a copy)**节点。
- en: Connect the **Skin Count** pin to the **Get** index.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Skin Count**引脚连接到**Get**索引。
- en: Connect the outgoing pin of the **Get** node to the **Skin Material** pin of
    the **Set Skin** **Material** node.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Get**节点的输出引脚连接到**Set Skin Material**节点的**Skin Material**引脚。
- en: Finally, connect the outgoing execution pin of **Set Skin Material** to an **Increment
    (++)** node. The **Skin Count x** variable should be incremented; this will keep
    track of the selected skin in the array.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**Set Skin Material**的输出执行引脚连接到一个**Increment (++)**节点。**Skin Count x**变量应该增加；这将跟踪数组中选定的皮肤。
- en: '*Figure 3**.23* depicts the Game Mode graph:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3*.23描述了游戏模式图：'
- en: '![Figure 3.23 – The Game Mode graph](img/Figure_03_23_B18203.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图3.23 – 游戏模式图](img/Figure_03_23_B18203.jpg)'
- en: Figure 3.23 – The Game Mode graph
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 – 游戏模式图
- en: Now that the prototype has been created, it’s time to test (and play) it!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在原型已经创建，是时候测试（并玩）它了！
- en: Testing the game
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试游戏
- en: 'Run the game as a listen server – each character should have its colorized
    skin synchronized across the network and the points gained for each player should
    be correctly displayed on the character itself. *Figure 3**.24* shows the game
    prototype in action:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以监听服务器运行游戏 – 每个角色应该在其网络中同步其彩色皮肤，并且每个玩家的得分应该正确显示在角色本身上。*图3*.24显示了游戏原型的实际运行情况：
- en: '![Figure 3.24 – Testing the game prototype](img/Figure_03.24_B18203.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图3.24 – 测试游戏原型](img/Figure_03.24_B18203.jpg)'
- en: Figure 3.24 – Testing the game prototype
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 – 测试游戏原型
- en: 'So, you’ve finally tested your multiplayer game prototype: players can run
    around and get the falling pickups, ready to gain points. As funny as it seems,
    this is just the beginning of multiplayer game development!'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你最终测试了你的多人游戏原型：玩家可以四处奔跑并拾取下落的物品，准备获得分数。虽然看起来很有趣，但这只是多人游戏开发的开始！
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you created a prototype of your first multiplayer game and
    gained knowledge about synchronizing Actors and variables across the network.
    Moreover, you started testing the prototype through the UE system, which emulates
    multiple connections concurrently, and achieved all this through the use of Blueprints.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你创建了你的第一个多人游戏的原型，并了解了如何在网络上同步Actors和变量。此外，你开始通过UE系统测试原型，该系统并发模拟多个连接，所有这些通过使用Blueprints实现。
- en: However, moving forward, you will transition to using the C++ programming language,
    which may seem a little daunting, but I assure you that I will strive to make
    this shift as effortless as possible!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，向前推进，你将过渡到使用C++编程语言，这可能看起来有点令人畏惧，但我向你保证，我会努力使这种转变尽可能轻松！
- en: It’s time to leave your prototype to its destiny... we have more important things
    to do! In the next chapter, you’ll start creating a game from scratch. You will
    develop it in C++ with all the advantages that come with this kind of development.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让你的原型走向它的命运了...我们还有更重要的事情要做！在下一章中，你将从头开始创建一个游戏。你将使用C++来开发它，并利用这种开发方式的所有优势。
- en: Part 2:Networking and Multiplayer Games in Unreal Engine
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：虚幻引擎中的网络和多人游戏
- en: In the second part of this book, you will lay the foundation for a complete
    multiplayer project using Unreal Engine. From there, you will delve into the essential
    features of the Unreal Engine Gameplay Framework, as well as how they are implemented
    within a multiplayer context.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第二部分，你将为使用虚幻引擎的完整多人项目打下基础。从那里，你将深入研究虚幻引擎游戏框架的基本功能，以及它们如何在多人环境中实现。
- en: 'This part includes the following chapters:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 4*](B18203_04.xhtml#_idTextAnchor086), *Setting Up Your First Multiplayer
    Environment*'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B18203_04.xhtml#_idTextAnchor086)，*设置您的第一个多人环境*'
- en: '[*Chapter 5*](B18203_05.xhtml#_idTextAnchor107), *Managing Actors in a Multiplayer
    Environment*'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18203_05.xhtml#_idTextAnchor107)，*在多人环境中管理演员*'
- en: '[*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties* *O**ver
    the Network*'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18203_06.xhtml#_idTextAnchor125)，*在网络中复制属性* *O**ver the Network*'
- en: '[*Chapter 7*](B18203_07.xhtml#_idTextAnchor147), *Using Remote Procedure Calls
    (RPCs)*'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18203_07.xhtml#_idTextAnchor147)，*使用远程过程调用 (RPCs)*'
