- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond Classes – Fundamental C++ Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, C++ started as C with classes, making classes one of the first
    concepts for developers with a C background to learn. In the previous chapter,
    we covered classes in detail, and before proceeding with more advanced concepts,
    we will cover other fundamental C++ concepts that make it so much more than C
    with classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to more advanced topics, it’s important to explore other
    fundamental concepts that make C++ distinct. In this chapter, we’re going to cover
    the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability with C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard library containers and algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using modern C++ features make sure to select C++23 standard, by adding
    `-std=c++23` in compiler options box.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly. The examples are available
    at GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter06](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter06)).
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Namespaces** in C++ are used as scope specifiers for accessing type names,
    functions, variables, and so on. They allow us to more easily differentiate types
    and function names in large code bases that use many software components and where
    there are often similar identifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In C, we usually add a prefix to types and functions to make it easier to differentiate,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++, we can use namespaces instead of C-style identifier prefixes to organize
    code in logical groups, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'All members of the `hal` namespace are accessible unqualified from within the
    namespace. To access identifiers from the `hal` namespace, in code outside of
    it, we use the namespace as a qualifier followed by scope resolution operator
    (`::`), as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, beside the `hal` namespace, we also see the `std` namespace,
    which we used in previous examples. C++ standard library types and functions are
    declared in the `std` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `using` directive to access an identifier without qualifiers,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `using` directive can also be used for the entire namespace, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended to use `using` directive sparingly, especially with `std`,
    using it for a limited scope, or even better, to bring in individual identifiers
    only.
  prefs: []
  type: TYPE_NORMAL
- en: The same namespace can be used across different header files to declare identifiers.
    For example, `std::vector` is declared in `vector.h`, and `std::array` is declared
    in `array.h` header files. This allows us to organize code from different headers
    that logically belong to the same group in a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions and types that are not declared within an explicit namespace are
    part of a global namespace. It is a good practice to organize all code in namespaces.
    The only function that can’t be declared within a namespace and must be in a global
    namespace is `main`. To access the identifier from the global namespace, we use
    the scope resolution operator, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The line `return ::ret_val;` uses the scope resolution operator, `::`, without
    specifying a namespace. This means it refers to the global namespace. So, `::ret_val`
    accesses the `ret_val` variable defined outside of any function or class—that
    is, at the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: Unnamed namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A namespace can be declared without the name qualifier. This allows us to declare
    functions and types that are local to the translation unit they are declared in.
    In the following example, we can see an example of an unnamed namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we have an unnamed namespace with a few variables declared in it.
    They have **internal linkage**, meaning they cannot be accessed by code from other
    translation units. We can achieve the same effect both in C and C++ by using the
    `static` storage specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Nested namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Namespaces can also be nested. We can have a namespace within a namespace,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have organized sensors in namespaces. We have a top-level
    namespace, `sensors`, which has two namespaces: `environmental` and `indoor_air_quality`.
    C++17 standard allows us to write namespaces, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Namespaces are a good way to make the code more readable, as they allow us to
    keep identifiers short, without C-style prefixes.
  prefs: []
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, when we discussed inheritance, we mentioned **static
    binding**. We saw that we can have the same function names for functions that
    belong to different classes. However, we can also have the same function names
    for different function parameters, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have two `print` functions. One of them has an `int` as
    a parameter and the second one has a `float`. On the call site, the compiler will
    pick a `print` function based on the arguments passed to the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with the same names within the same scope are called **overloaded
    functions**. Instead of having two different names, such as `print_int` and `print_float`,
    we can use the same name for both these functions and let the compiler decide
    which function to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To distinguish between the two overloaded `print` functions – one accepting
    an `int` parameter and the other a `float` – the compiler employs a technique
    called **name mangling**. Name mangling modifies function names by encoding additional
    information, such as parameter types, into them. This ensures that each overloaded
    function has a unique symbol in the compiled code. If we examine the assembly
    output of the previous example, we can observe these mangled names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We see that the compiler assigned `_Z5printi` and `_Z5printf` labels to `print`
    functions with `int` and `float` parameters respectively. This allows it to dispatch
    function calls according to argument matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overloaded functions can have a different number of arguments. Return types
    cannot be used for function overloading. Two functions with the same name and
    same arguments cannot have different return types. The following code would result
    in a compile error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code would be treated by the compiler as a function redeclaration and would
    result in an error.
  prefs: []
  type: TYPE_NORMAL
- en: Function overloading is a basic but powerful feature of C++ that provides a
    mechanism for compile-time or static polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability with C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code examples from previous chapters that you were able to run in a Renode simulator
    are using both C++ and C code. We used vendor provided HAL library and **Common
    Microcontroller Software Interface Standard** (**CMSIS**) by Arm, both written
    in C and contained in the `platform` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the `CMakeLists.txt` file and the `add_executable` function
    in it, you will see listed C files from the `platform` folder and just a few C++
    files. Building a project will provide the following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Every C and C++ file is treated as a translation unit and built separately by
    C and C++ compilers respectively. After compilation, both C and C++ object files
    are linked into a single ELF file.
  prefs: []
  type: TYPE_NORMAL
- en: External and Language Linkage in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables and functions that can be referred to from other translation units
    have **external linkage**. This allows them to be linked with code in other files
    provided that the compiler has access to declarations. They also have a property
    called **language linkage**. This property allows linking C++ with C code. C language
    linkage in C++ is declared using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Declaration with C language linkage will be linked according to C language linkage
    conventions, preventing name mangling (among other things) to ensure proper linking
    with code compiled within a C translation unit.
  prefs: []
  type: TYPE_NORMAL
- en: C standard library in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ wraps the C standard library and provides header files with the same name
    as the C language version but with a `c` prefix and no extension. For example,
    the C++ equivalent for the C language header file `<stdlib.h>` is `<cstdlib>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In GCC, implementation C++ wrappers include C standard library headers; for
    example, `<cstdio>` includes `<stdio.h>`. If you dive into `<stdio.h>`, you can
    see that it guards function declarations with `__BEGIN_DECLS` and `__END_DECLS`
    macros. Here’s the definition of these macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that standard C library headers take care of C++ compatibility
    by adding a language linkage specifier if a C++ compiler is used. This practice
    is also used in many HAL implementations provided by microcontroller vendors.
    If you open any C header file in `platform/STM32F0xx_HAL_Driver/Inc`, you will
    see that declarations are guarded with a C language linkage specifier when they
    are accessed by the C++ compiler, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'C libraries are often used by C++ programs, especially in the embedded domain,
    so it is always a good idea to guard them with a language linkage specifier. If
    we are using a C library in a C++ program in which headers are not guarded internally,
    we can guard the headers at the `include` site, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The language linkage specifier for C language ensures proper linking of C++
    code that is using C code, which is often a case in embedded projects.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we briefly mentioned references without explaining
    them in detail. References are object aliases; that is, they refer to objects
    and as such they must be immediately initialized. They are not objects, so there
    are no pointers to references or arrays of references.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different types of references in C++: **lvalue** and **rvalue**
    references.'
  prefs: []
  type: TYPE_NORMAL
- en: Value categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ expressions have either lvalue or rvalue value categories. There is a more
    detailed division of value categories, but we will stay with this simple one which
    has a historical origin.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lvalues** usually appear on the left side of the assignment expression, but
    this is not always the case. Lvalues have an address that the program can access.
    Here are some examples of lvalues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Rvalues** usually appear on the right side of the assignment expression.
    Examples are literals, function calls that do not return references, and built-in
    operator calls. We can think of them as temporary values. Some rvalues are shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another, full example to help you better understand rvalues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we can see the `my_struct()` rvalue expression on
    the left side of the assignment operator. The output of the example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first `printf` call, we make a call to the constructor of `my_struct`,
    which returns a temporary object, and we access the `a_` member. In the next line,
    we have the following expression: `my_struct()=my_struct(16)`. On the left side
    of this expression, we have a call to the default constructor, which returns a
    temporary object. Then we assign the result of the call to a constructor that
    accepts `int` to a temporary object on the left side, which will copy one temporary
    object to the other one.'
  prefs: []
  type: TYPE_NORMAL
- en: Lvalue references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Lvalue references** are used as aliases for existing objects. They can also
    be const-qualified. We declare them by adding `&` to type names. The following
    code demonstrates the usage of lvalue references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the example, we can manipulate the object using the reference. In
    the case of a constant reference, any attempts to change the value will result
    in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Rvalue references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Rvalue references** are used to extend the lifetime of temporary rvalues.
    We declare them using `&&` next to the type name. Here are example usages of rvalue
    references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Rvalue references cannot be bound to lvalues. Attempting to do so will result
    in a compiler error. Rvalue references are important for resource management,
    and they are used in move semantics, which allow resources to be moved from one
    object to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the documentation for the `push_back` method of `std::vector`,
    we will see two declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first declaration is used to initialize a new vector member by copying
    `value`. The second declaration with rvalue reference will move `value`, meaning
    that a new vector member will take ownership of dynamically allocated resources
    from the `value` object. Let’s take a look at the following example to understand
    the basics of move semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have two calls to the `push_back` method of `std::vector<std::string>`.
    The first call, `v.push_back(str);`, performs a copy of `str` into the vector.
    After this operation, the original str remains unchanged, which is confirmed by
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The second call, `v.push_back(std::move(str));`, uses `std::move` to cast `str`
    to an rvalue reference. This signals to the compiler that the resources of `str`
    can be moved rather than copied. As a result, the internal data of `str` is transferred
    to the new string in the vector, and `str` is left in a valid but unspecified
    state, often becoming empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, we are also printing addresses of the string’s underlying
    character arrays using `s.data()` and `str.data()`.Here’s what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: The original `str` has its data at address `0x84c2b0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After copying str into the vector, the first element, `v[0]`, has its own copy
    of the data at a different address (`0x84d330`), confirming that a deep copy was
    made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the move, the second element, `v[1]`, in the vector now points to the
    original data address, `0x84c2b0`. This indicates that the internal data of `str`
    was moved into `v[1]` without copying. This is just a glimpse into move semantics;
    there is much more to it, but as it is used mostly for managing dynamically allocated
    resources, we will not cover it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Standard library containers and algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed some of the containers from the C++ library, such
    as `std::vector` and `std::array`, in previous chapters. As `std::vector` relies
    on dynamic memory allocation, `std::array` is usually the container of choice
    in embedded applications.
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays from the standard library allocate a contiguous block of memory on the
    stack. We can consider an array as a simple wrapper of a C-style array that contains
    the size of the array inside the type. It is a templated type that is instantiated
    with an underlying data type and size.
  prefs: []
  type: TYPE_NORMAL
- en: We can access members of the array using a method that will throw an exception
    if indexed with an out-of-bounds index. This makes it a safer option than a C-style
    array as it allows us to catch out-of-bounds access runtime errors and handle
    them. If exceptions are disabled, we can set a global terminate handler with our
    functionality. We had the opportunity to see this in [*Chapter 2*](Chapter_02.xhtml)
    of this book when we were discussing exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `std:array` to create a vector-like container that we can use with
    container adaptors such as `std::stack` or a `std::priority` queue. We will call
    our new type `fixed_vector`. It will inherit from `std::array` and implement the
    `push_back`, `pop_back`, `empty`, and `end` methods. Here is an implementation
    of our new type using an array from the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Our new type, `fixed_vector`, exploits the underlying `std::array` and implements
    the `push_back` function to add elements at the end of the array. If we want to
    add more elements than is possible, it will fail silently. This behavior can be
    adjusted as per the application’s requirements. It also implements the `back`
    method, which returns an lvalue reference to the last element, and `pop_back`,
    which decrements the private member, `cnt_`, used to keep track of the number
    of elements stored in the container.
  prefs: []
  type: TYPE_NORMAL
- en: We can use our new container type, `fixed_vector`, as an underlying container
    type for container adaptors such as stacks and priority queues.
  prefs: []
  type: TYPE_NORMAL
- en: Container adaptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stack is a simple **Last In-First Out** (**LIFO**) container adaptor, and the
    priority queue will sort the elements when inserting them. We can see how to use
    them with `fixed_vector` in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are using `fixed_vector` to instantiate `std::stack` and
    `std::priority_queue` templated types. If we run this program, we will get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, elements in the priority queue are sorted, and
    those in the stack are popped by the LIFO principle.
  prefs: []
  type: TYPE_NORMAL
- en: The standard library provides a variety of containers, and we have just scratched
    the surface of the possibilities that it provides. It also provides algorithms
    that operate on containers.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ standard library offers a huge set of templated algorithm functions contained
    in the `algorithm` header that play well with different container types. We will
    go through some of them now.
  prefs: []
  type: TYPE_NORMAL
- en: std::copy and std::copy_if
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::copy` and `std::copy_if` are used to copy elements from one container
    to another. `std::copy_if` also accepts a predicate function that controls whether
    a member is copied or not, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `std::iota` from the numeric header to initialize the
    `src` array with incrementing values, starting with `0`. Then, we copy all elements
    from the `src` array to the `dst` array that are larger than 3 using `std::copy_if`.
  prefs: []
  type: TYPE_NORMAL
- en: std::sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::sort` is used to sort elements in a container. In the following example,
    we will generate elements randomly and sort them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we populate the `src` array using `std::transform`, which
    applies a `rand` lambda to every member of the `src` array. We used types from
    the `random` header to generate random numbers between 1 and 6\. After we populate
    the array with random numbers, we sort it using `std::sort`. A possible output
    of this program is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We first see values in the array before sorting and then applying `std::sort`.
    We could have populated the initial array in a `for` loop, but we used the opportunity
    to demonstrate `std:transform` here.
  prefs: []
  type: TYPE_NORMAL
- en: These were some of the algorithms from the C++ standard library; there are many
    more that can be used to effectively solve common tasks in containers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered C++ fundamentals such as namespaces, function overloading,
    references, and standard library containers and algorithms. We also learned how
    C interoperability is implemented and used in C++ programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about error-handling mechanisms in C++.
  prefs: []
  type: TYPE_NORMAL
