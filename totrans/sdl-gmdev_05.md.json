["```cpp\nenum game_states\n{\n  MENU = 0,\n  PLAY = 1,\n  GAMEOVER = 2\n};\n```", "```cpp\n// create menu objects\nm_pMenuObj1 = new MenuObject();\nm_pMenuObj1 = new MenuObject();\n\n// create play objects\nm_pPlayer = new Player();\nm_pEnemy = new Enemy();\n\n// create game over objects…\n```", "```cpp\nm_currentGameState = MENU;\n```", "```cpp\nvoid Game::update()\n{\n  switch(m_currentGameState)\n  {\n    case MENU:\n      m_menuObj1->update();\n      m_menuObj2->update();\n      break;\n\n    case PLAY:\n      m_pPlayer->update();\n      m_pEnemy->update();\n\n    case GAMEOVER:\n      // do game over stuff…\n  }\n}\n```", "```cpp\n#include<string>\nclass GameState\n{\npublic:\n  virtual void update() = 0;\n  virtual void render() = 0;\n\n  virtual bool onEnter() = 0;\n  virtual bool onExit() = 0;\n\n  virtual std::string getStateID() const = 0;\n};\n```", "```cpp\n#include\"GameState.h\"\n\nclass MenuState : public GameState\n{\npublic:\n\n  virtual void update();\n  virtual void render();\n\n  virtual bool onEnter();\n  virtual bool onExit();\n\n  virtual std::string getStateID() const { return s_menuID; }\n\nprivate:\n\n  static const std::string s_menuID;\n};\n```", "```cpp\n#include \"MenuState.h\"\n\nconst std::string MenuState::s_menuID = \"MENU\";\n\nvoid MenuState::update()\n{\n  // nothing for now\n}\n\nvoid MenuState::render()\n{\n  // nothing for now\n}\n\nbool MenuState::onEnter()\n{\n  std::cout << \"entering MenuState\\n\";\n  return true;\n}\n\nbool MenuState::onExit()\n{\n  std::cout << \"exiting MenuState\\n\";\n  return true;\n}\n```", "```cpp\n#include \"GameState.h\"\n\nclass PlayState : public GameState\n{\npublic:\n\n  virtual void update();\n  virtual void render();\n\n  virtual bool onEnter();\n  virtual bool onExit();\n\n  virtual std::string getStateID() const { return s_playID; }\n\nprivate:\n\n  static const std::string s_playID;\n};\n```", "```cpp\n#include \"PlayState.h\"\n\nconst std::string PlayState::s_playID = \"PLAY\";\n\nvoid PlayState::update()\n{\n  // nothing for now\n}\n\nvoid PlayState::render()\n{\n  // nothing for now\n}\n\nbool PlayState::onEnter()\n{\n  std::cout << \"entering PlayState\\n\";\n  return true;\n}\n\nbool PlayState::onExit()\n{\n  std::cout << \"exiting PlayState\\n\";\n  return true;\n}\n```", "```cpp\n#include \"GameState.h\"\n\nclass GameStateMachine\n{\npublic:\n\n  void pushState(GameState* pState);\n  void changeState(GameState* pState);\n  void popState();\n};\n```", "```cpp\nprivate:\n\nstd::vector<GameState*> m_gameStates;\n```", "```cpp\nvoid GameStateMachine::pushState(GameState *pState)\n{\n  m_gameStates.push_back(pState);\n  m_gameStates.back()->onEnter();\n}\n```", "```cpp\nvoid GameStateMachine::popState()\n{\n  if(!m_gameStates.empty())\n  {\n    if(m_gameStates.back()->onExit())\n    {\n      delete m_gamestates.back();\n      m_gameStates.pop_back();\n    }\n  }\n}\n```", "```cpp\nvoid GameStateMachine::changeState(GameState *pState)\n{\n  if(!m_gameStates.empty())\n  {\n    if(m_gameStates.back()->getStateID() == pState->getStateID())\n    {\n      return; // do nothing\n    }\n\n    if(m_gameStates.back()->onExit())\n    {\n      delete m_gamestates.back();\n      m_gameStates.pop_back();\n    }\n  }\n\n  // push back our new state\n  m_gameStates.push_back(pState);\n\n  // initialise it\n  m_gameStates.back()->onEnter();\n}\n```", "```cpp\nGameStateMachine* m_pGameStateMachine;\n```", "```cpp\nm_pGameStateMachine = new GameStateMachine();\nm_pGameStateMachine->changeState(new MenuState());\n```", "```cpp\nvoid Game::handleEvents()\n{\n  TheInputHandler::Instance()->update();\n\n  if(TheInputHandler::Instance()->isKeyDown(SDL_SCANCODE_RETURN))\n  {\n    m_pGameStateMachine->changeState(new PlayState());\n  }\n}\n```", "```cpp\nentering MenuState\nexiting MenuState\nentering PlayState\n```", "```cpp\nvoid update();\nvoid render();\n```", "```cpp\nvoid GameStateMachine::update()\n{\n  if(!m_gameStates.empty())\n  {\n    m_gameStates.back()->update();\n  }\n}\n\nvoid GameStateMachine::render()\n{\n  if(!m_gameStates.empty())\n  {\n    m_gameStates.back()->render();\n  }\n}\n```", "```cpp\nvoid Game::render()\n{\n  SDL_RenderClear(m_pRenderer); \n\n  m_pGameStateMachine->render();\n\n  SDL_RenderPresent(m_pRenderer); \n}\n\nvoid Game::update()\n{\n  m_pGameStateMachine->update();\n}\n```", "```cpp\nclass MenuButton : public SDLGameObject\n{\npublic:\n\n  MenuButton(const LoaderParams* pParams);\n\n  virtual void draw();\n  virtual void update();\n  virtual void clean();\n};\n```", "```cpp\nenum button_state\n{\n  MOUSE_OUT = 0,\n  MOUSE_OVER = 1,\n  CLICKED = 2\n};\n```", "```cpp\nMenuButton::MenuButton(const LoaderParams* pParams) : SDLGameObject(pParams)\n{\n  m_currentFrame = MOUSE_OUT; // start at frame 0\n}\n\nvoid MenuButton::draw()\n{\n  SDLGameObject::draw(); // use the base class drawing\n}\n\nvoid MenuButton::update()\n{\n  Vector2D* pMousePos = TheInputHandler::Instance()\n  ->getMousePosition();\n\n  if(pMousePos->getX() < (m_position.getX() + m_width) \n  && pMousePos->getX() > m_position.getX()\n  && pMousePos->getY() < (m_position.getY() + m_height) \n  && pMousePos->getY() > m_position.getY())\n  {\n    m_currentFrame = MOUSE_OVER;\n\n    if(TheInputHandler::Instance()->getMouseButtonState(LEFT))\n    {\n      m_currentFrame = CLICKED;\n    }\n  }\n  else\n  {\n    m_currentFrame = MOUSE_OUT;\n  }\n}\n\nvoid MenuButton::clean()\n{\n  SDLGameObject::clean();\n}\n```", "```cpp\n    Vector2D* pMousePos = TheInputHandler::Instance()->getMousePosition();\n    ```", "```cpp\n    if(pMousePos->getX() < (m_position.getX() + m_width) \n    && pMousePos->getX() > m_position.getX()\n    && pMousePos->getY() < (m_position.getY() + m_height) \n    && pMousePos->getY() > m_position.getY())\n    ```", "```cpp\n    m_currentFrame = MOUSE_OVER;\n    ```", "```cpp\n    if(TheInputHandler::Instance()->getMouseButtonState(LEFT))\n    {\n      m_currentFrame = CLICKED;\n    }\n    ```", "```cpp\n    else\n    {\n      m_currentFrame = MOUSE_OUT;\n    }\n    ```", "```cpp\nstd::vector<GameObject*> m_gameObjects;\n```", "```cpp\nvoid MenuState::update()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->update();\n  }\n}\nvoid MenuState::render()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->draw();\n  }\n}\n```", "```cpp\nbool MenuState::onEnter()\n{\n  if(!TheTextureManager::Instance()->load(\"assets/button.png\", \n  \"playbutton\", TheGame::Instance()->getRenderer()))\n  {\n    return false;\n  }\n\n  if(!TheTextureManager::Instance()->load(\"assets/exit.png\", \n  \"exitbutton\", TheGame::Instance()->getRenderer()))\n  {\n    return false;\n  }\n\n  GameObject* button1 = new MenuButton(new LoaderParams(100, 100, \n  400, 100, \"playbutton\"));\n  GameObject* button2 = new MenuButton(new LoaderParams(100, 300, \n  400, 100, \"exitbutton\"));\n\n  m_gameObjects.push_back(button1);\n  m_gameObjects.push_back(button2);\n\n  std::cout << \"entering MenuState\\n\";\n  return true;\n}\n\nbool MenuState::onExit()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->clean();\n  }\n  m_gameObjects.clear();\n  TheTextureManager::Instance()\n  ->clearFromTextureMap(\"playbutton\");\n  TheTextureManager::Instance()\n  ->clearFromTextureMap(\"exitbutton\");\n\n  std::cout << \"exiting MenuState\\n\";\n  return true;\n}\n```", "```cpp\nvoid TextureManager::clearFromTextureMap(std::string id)\n{\n  m_textureMap.erase(id);\n}\n```", "```cpp\nreturnType (*functionName)(parameters);\n```", "```cpp\nvoid (*m_callback)();\n```", "```cpp\nbool m_bReleased;\n```", "```cpp\nMenuButton(const LoaderParams* pParams, void (*callback)());\n```", "```cpp\nMenuButton::MenuButton(const LoaderParams* pParams, void (*callback)() ) : SDLGameObject(pParams), m_callback(callback)\n```", "```cpp\nvoid MenuButton::update()\n{\n  Vector2D* pMousePos = TheInputHandler::Instance()\n  ->getMousePosition();\n\n  if(pMousePos->getX() < (m_position.getX() + m_width) \n  && pMousePos->getX() > m_position.getX()\n  && pMousePos->getY() < (m_position.getY() + m_height) \n  && pMousePos->getY() > m_position.getY())\n  {\n    if(TheInputHandler::Instance()->getMouseButtonState(LEFT) \n    && m_bReleased)\n    {\n      m_currentFrame = CLICKED;\n\n      m_callback(); // call our callback function\n\n      m_bReleased = false;\n    }\n    else if(!TheInputHandler::Instance()\n    ->getMouseButtonState(LEFT))\n    {\n      m_bReleased = true;\n      m_currentFrame = MOUSE_OVER;\n    }\n  }\n  else\n  {\n    m_currentFrame = MOUSE_OUT;\n  }\n}\n```", "```cpp\nprivate:\n// call back functions for menu items\nstatic void s_menuToPlay();\nstatic void s_exitFromMenu();\n```", "```cpp\nvoid MenuState::s_menuToPlay()\n{\n  std::cout << \"Play button clicked\\n\";\n}\n\nvoid MenuState::s_exitFromMenu()\n{\n  std::cout << \"Exit button clicked\\n\";\n}\n```", "```cpp\nGameObject* button1 = new MenuButton(new LoaderParams(100, 100, 400, 100, \"playbutton\"), s_menuToPlay);\nGameObject* button2 = new MenuButton(new LoaderParams(100, 300, 400, 100, \"exitbutton\"), s_exitFromMenu);\n```", "```cpp\nvoid MenuState::s_exitFromMenu()\n{\n  TheGame::Instance()->quit();\n}\n```", "```cpp\nGameStateMachine* getStateMachine(){ return m_pGameStateMachine; }\n```", "```cpp\nvoid MenuState::s_menuToPlay()\n{\n  TheGame::Instance()->getStateMachine()->changeState(new \n  PlayState());\n}\n```", "```cpp\nvoid Player::handleInput()\n{\n  Vector2D* target = TheInputHandler::Instance()\n  ->getMousePosition();\n\n  m_velocity = *target - m_position;\n\n  m_velocity /= 50;\n}\n```", "```cpp\nclass GameObject;\n\nclass PlayState : public GameState\n{\npublic:\n\n  virtual void update();\n  virtual void render();\n\n  virtual bool onEnter();\n  virtual bool onExit();\n\n  virtual std::string getStateID() const { return s_playID; }\n\nprivate:\n\n  static const std::string s_playID;\n\n  std::vector<GameObject*> m_gameObjects;\n};\n```", "```cpp\nconst std::string PlayState::s_playID = \"PLAY\";\n\nvoid PlayState::update()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->update();\n  }\n}\n\nvoid PlayState::render()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->draw();\n  }\n}\n\nbool PlayState::onEnter()\n{\n  if(!TheTextureManager::Instance()->load(\"assets/helicopter.png\", \n  \"helicopter\", TheGame::Instance()->getRenderer()))\n  {\n    return false;\n  }\n\n  GameObject* player = new Player(new LoaderParams(100, 100, 128, \n  55, \"helicopter\");\n\n  m_gameObjects.push_back(player);\n\n  std::cout << \"entering PlayState\\n\";\n  return true;\n}\n\nbool PlayState::onExit()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->clean();\n  }\n  m_gameObjects.clear();\n  TheTextureManager::Instance()\n  ->clearFromTextureMap(\"helicopter\");\n\n  std::cout << \"exiting PlayState\\n\";\n  return true;\n}\n```", "```cpp\nvoid SDLGameObject::draw()\n{\n  if(m_velocity.getX() > 0)\n  {\n    TextureManager::Instance()->drawFrame(m_textureID, \n    (Uint32)m_position.getX(), (Uint32)m_position.getY(),\n    m_width, m_height, m_currentRow, m_currentFrame, \n    TheGame::Instance()->getRenderer(),SDL_FLIP_HORIZONTAL);\n  }\n  else\n  {\n    TextureManager::Instance()->drawFrame(m_textureID, \n    (Uint32)m_position.getX(), (Uint32)m_position.getY(),\n    m_width, m_height, m_currentRow, m_currentFrame, \n    TheGame::Instance()->getRenderer());\n  }\n}\n```", "```cpp\nclass GameObject;\n\nclass PauseState : public GameState\n{\npublic:\n\n  virtual void update();\n  virtual void render();\n\n  virtual bool onEnter();\n  virtual bool onExit();\n\n  virtual std::string getStateID() const { return s_pauseID; }\n\nprivate:\n\n  static void s_pauseToMain();\n  static void s_resumePlay();\n\n  static const std::string s_pauseID;\n\n  std::vector<GameObject*> m_gameObjects;\n};\n```", "```cpp\nconst std::string PauseState::s_pauseID = \"PAUSE\";\n\nvoid PauseState::s_pauseToMain()\n{\n  TheGame::Instance()->getStateMachine()->changeState(new \n  MenuState());\n}\n\nvoid PauseState::s_resumePlay()\n{\n  TheGame::Instance()->getStateMachine()->popState();\n}\n\nvoid PauseState::update()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->update();\n  }\n}\n\nvoid PauseState::render()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->draw();\n  }\n}\n\nbool PauseState::onEnter()\n{\n  if(!TheTextureManager::Instance()->load(\"assets/resume.png\", \n  \"resumebutton\", TheGame::Instance()->getRenderer()))\n  {\n    return false;\n  }\n\n  if(!TheTextureManager::Instance()->load(\"assets/main.png\", \n  \"mainbutton\", TheGame::Instance()->getRenderer()))\n  {\n    return false;\n  }\n\n  GameObject* button1 = new MenuButton(new LoaderParams(200, 100, \n  200, 80, \"mainbutton\"), s_pauseToMain);\n  GameObject* button2 = new MenuButton(new LoaderParams(200, 300, \n  200, 80, \"resumebutton\"), s_resumePlay);\n\n  m_gameObjects.push_back(button1);\n  m_gameObjects.push_back(button2);\n\n  std::cout << \"entering PauseState\\n\";\n  return true;\n}\n\nbool PauseState::onExit()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->clean();\n  }\n  m_gameObjects.clear();\n  TheTextureManager::Instance()\n  ->clearFromTextureMap(\"resumebutton\");\n  TheTextureManager::Instance()\n  ->clearFromTextureMap(\"mainbutton\");\n  // reset the mouse button states to false\n  TheInputHandler::Instance()->reset();\n\n  std::cout << \"exiting PauseState\\n\";\n  return true;\n}\n```", "```cpp\nvoid PlayState::update()\n{\n  if(TheInputHandler::Instance()->isKeyDown(SDL_SCANCODE_ESCAPE))\n  {\n    TheGame::Instance()->getStateMachine()->pushState(new \n    PauseState());\n  }\n\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->update();\n  }\n}\n```", "```cpp\nvoid PauseState::s_resumePlay()\n{\n  TheGame::Instance()->getStateMachine()->popState();\n}\n```", "```cpp\nvoid PauseState::s_pauseToMain()\n{\n  TheGame::Instance()->getStateMachine()->changeState(new \n  MenuState());\n}\n```", "```cpp\nEnemy::Enemy(const LoaderParams* pParams) : SDLGameObject(pParams)\n{\n  m_velocity.setY(2);\n  m_velocity.setX(0.001);\n}\n\nvoid Enemy::draw()\n{\n  SDLGameObject::draw();\n}\n\nvoid Enemy::update()\n{\n  m_currentFrame = int(((SDL_GetTicks() / 100) % m_numFrames));\n\n  if(m_position.getY() < 0)\n  {\n    m_velocity.setY(2);\n  }\n  else if(m_position.getY() > 400)\n  {\n    m_velocity.setY(-2);\n  }\n\n  SDLGameObject::update();\n}\n```", "```cpp\nbool PlayState::onEnter()\n{\n  if(!TheTextureManager::Instance()->load(\"assets/helicopter.png\", \n  \"helicopter\", TheGame::Instance()->getRenderer()))\n  {\n    return false;\n  }\n\n  if(!TheTextureManager::Instance()\n  ->load(\"assets/helicopter2.png\", \"helicopter2\", \n  TheGame::Instance()->getRenderer()))\n  {\n    return false;\n  }\n\n  GameObject* player = new Player(new LoaderParams(500, 100, 128, \n  55, \"helicopter\"));\n  GameObject* enemy = new Enemy(new LoaderParams(100, 100, 128, \n  55, \"helicopter2\"));\n\n  m_gameObjects.push_back(player);\n  m_gameObjects.push_back(enemy);\n\n  std::cout << \"entering PlayState\\n\";\n  return true;\n}\n```", "```cpp\nAnimatedGraphic::AnimatedGraphic(const LoaderParams* pParams, int animSpeed) : SDLGameObject(pParams), m_animSpeed(animSpeed)\n{\n\n}\n```", "```cpp\nvoid AnimatedGraphic::update()\n{\n  m_currentFrame = int(((SDL_GetTicks() / (1000 / m_animSpeed)) % \n  m_numFrames));\n}\n```", "```cpp\nclass GameObject;\n\nclass GameOverState : public GameState\n{\npublic:\n\n  virtual void update();\n  virtual void render();\n\n  virtual bool onEnter();\n  virtual bool onExit();\n\n  virtual std::string getStateID() const {return s_gameOverID;}\n\nprivate:\n\n  static void s_gameOverToMain();\n  static void s_restartPlay();\n\n  static const std::string s_gameOverID;\n\n  std::vector<GameObject*> m_gameObjects;\n};\n```", "```cpp\nconst std::string GameOverState::s_gameOverID = \"GAMEOVER\";\n\nvoid GameOverState::s_gameOverToMain()\n{\n  TheGame::Instance()->getStateMachine()->changeState(new \n  MenuState());\n}\n\nvoid GameOverState::s_restartPlay()\n{\n  TheGame::Instance()->getStateMachine()->changeState(new \n  PlayState());\n}\n```", "```cpp\nbool GameOverState::onEnter()\n{\n  if(!TheTextureManager::Instance()->load(\"assets/gameover.png\", \n  \"gameovertext\", TheGame::Instance()->getRenderer()))\n  {\n    return false;\n  }\n\n  if(!TheTextureManager::Instance()->load(\"assets/main.png\", \n  \"mainbutton\", TheGame::Instance()->getRenderer()))\n  {\n    return false;\n  }\n\n  if(!TheTextureManager::Instance()->load(\"assets/restart.png\", \n  \"restartbutton\", TheGame::Instance()->getRenderer()))\n  {\n    return false;\n  }\n\n  GameObject* gameOverText = new AnimatedGraphic(new \n  LoaderParams(200, 100, 190, 30, \"gameovertext\", 2), 2);\n  GameObject* button1 = new MenuButton(new LoaderParams(200, 200, \n  200, 80, \"mainbutton\"), s_gameOverToMain);\n  GameObject* button2 = new MenuButton(new LoaderParams(200, 300, \n  200, 80, \"restartbutton\"), s_restartPlay);\n\n  m_gameObjects.push_back(gameOverText);\n  m_gameObjects.push_back(button1);\n  m_gameObjects.push_back(button2);\n\n  std::cout << \"entering PauseState\\n\";\n  return true;\n}\n```", "```cpp\nbool checkCollision(SDLGameObject* p1, SDLGameObject* p2);\n```", "```cpp\nbool PlayState::checkCollision(SDLGameObject* p1, SDLGameObject* \np2)\n{\n  int leftA, leftB;\n  int rightA, rightB;\n  int topA, topB;\n  int bottomA, bottomB;\n\n  leftA = p1->getPosition().getX();\n  rightA = p1->getPosition().getX() + p1->getWidth();\n  topA = p1->getPosition().getY();\n  bottomA = p1->getPosition().getY() + p1->getHeight();\n\n  //Calculate the sides of rect B\n  leftB = p2->getPosition().getX();\n  rightB = p2->getPosition().getX() + p2->getWidth();\n  topB = p2->getPosition().getY();\n  bottomB = p2->getPosition().getY() + p2->getHeight();\n\n  //If any of the sides from A are outside of B\n  if( bottomA <= topB ){return false;} \n  if( topA >= bottomB ){return false; }\n  if( rightA <= leftB ){return false; }\n  if( leftA >= rightB ){return false;}\n\n  return true;\n}\n```", "```cpp\nVector2D& getPosition() { return m_position; }\nint getWidth() { return m_width; }\nint getHeight() { return m_height; }\n```", "```cpp\nvoid PlayState::update()\n{\n  if(TheInputHandler::Instance()->isKeyDown(SDL_SCANCODE_ESCAPE))\n  {\n    TheGame::Instance()->getStateMachine()->pushState(new \n    PauseState());\n  }\n\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->update();\n  }\n\n  if(checkCollision(dynamic_cast<SDLGameObject*>\n  (m_gameObjects[0]), dynamic_cast<SDLGameObject*>\n  (m_gameObjects[1])))\n  {\n    TheGame::Instance()->getStateMachine()->pushState(new \n    GameOverState());\n  }\n}\n```"]