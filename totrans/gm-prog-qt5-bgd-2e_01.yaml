- en: Introduction to Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn what Qt is and how it evolved. We will describe
    the structure of the Qt framework and the differences between its versions. Finally,
    you will learn how to decide which Qt licensing scheme is right for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics covered in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Qt history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure of the Qt framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt licenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A journey through time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development of Qt started in 1991 by two Norwegians—Eirik Chambe-Eng and
    Haavard Nord—who were looking to create a cross-platform GUI programming toolkit.
    The first commercial client of Trolltech (the company that created the Qt toolkit)
    was the European Space Agency. The commercial use of Qt helped Trolltech sustain
    further development. At that time, Qt was available for two platforms—Unix/X11
    and Windows—however, developing with Qt for Windows required buying a proprietary
    license, which was a significant drawback in porting the existing Unix/Qt applications.
  prefs: []
  type: TYPE_NORMAL
- en: A major step forward was the release of Qt Version 3.0 in 2001, which saw the
    initial support for Mac as well as an option to use Qt for Unix and Mac under
    a liberal GPL license. Still, Qt for Windows was only available under a paid license.
    Nevertheless, at that time, Qt had support for all the important players in the
    market—Windows, Mac, and Unix desktops, with Trolltech's mainstream product and
    Qt for embedded Linux.
  prefs: []
  type: TYPE_NORMAL
- en: In 2005, Qt 4.0 was released, which was a real breakthrough for a number of
    reasons. First, the Qt API was completely redesigned, which made it cleaner and
    more coherent. Unfortunately, at the same time, it made the existing Qt-based
    code incompatible with 4.0, and many applications needed to be rewritten from
    scratch or required much effort to be adapted to the new API. It was a difficult
    decision, but from the time perspective, we can see it was worth it. Difficulties
    caused by changes in the API were well countered by the fact that Qt for Windows
    was finally released under GPL. Many optimizations were introduced that made Qt
    significantly faster. Lastly, Qt, which was a single library until now, was divided
    into a number of modules. This allowed programmers to only link to the functionality
    that they used in their applications, reducing the memory footprint and the dependencies
    of their software.
  prefs: []
  type: TYPE_NORMAL
- en: In 2008, Trolltech was sold to Nokia, which at that time was looking for a software
    framework to help it expand and replace its Symbian platform in the future. The
    Qt community became divided; some people were thrilled, others were worried after
    seeing Qt's development get transferred to Nokia. Either way, new funds were pumped
    into Qt, speeding up its progress and opening it for mobile platforms—Symbian
    and then Maemo and MeeGo.
  prefs: []
  type: TYPE_NORMAL
- en: For Nokia, Qt was not considered a product of its own, but rather a tool. Therefore,
    Nokia decided to introduce Qt to more developers by adding a very liberal **Lesser
    General Public License** (**LGPL**) that allowed the usage of the framework for
    both open and closed source development.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing Qt to new platforms and less powerful hardware required a new approach
    to create user interfaces and to make them more lightweight, fluid, and attractive.
    Nokia engineers working on Qt came up with a new declarative language to develop
    such interfaces—the **Qt Modeling Language** (**QML**) and a Qt runtime for it
    called **Qt Quick**.
  prefs: []
  type: TYPE_NORMAL
- en: The latter became the primary focus of the further development of Qt, practically
    stalling all non-mobile-related work, channeling all efforts to make Qt Quick
    faster, easier, and more widespread. Qt 4 was already in the market for seven
    years, and it became obvious that another major version of Qt had to be released.
    It was decided to bring more engineers to Qt by allowing anyone to contribute
    to the project. The Qt Project founded by Nokia in 2011 provided an infrastructure
    for code review and introduced an open governance model, allowing outside developers
    to participate in decision making.
  prefs: []
  type: TYPE_NORMAL
- en: Nokia did not manage to finish working on Qt 5.0\. As a result of an unexpected
    turnover of Nokia toward different technology in 2011, the Qt division was sold
    in mid 2012 to the Finnish company Digia that managed to complete the effort and
    release Qt 5.0, a completely restructured framework, in December of the same year.
    While Qt 5.0 introduced a lot of new features, it was mostly compatible with Qt
    4 and allowed developers to seamlessly migrate to the new major version.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, Digia formed the Qt Company that is now responsible for Qt development,
    commercialization, and licensing. All Qt-related web resources scattered across
    Qt Project and Digia websites were eventually unified at [https://www.qt.io/](https://www.qt.io/).
    Qt continues to receive bug fixes, new features, and new platform support. This
    book is based on Qt 5.9, which was released in 2017.
  prefs: []
  type: TYPE_NORMAL
- en: The cross-platform programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt is an application-programming framework that is used to develop cross-platform
    applications. What this means is that software written for one platform can be
    ported and executed on another platform with little or no effort. This is obtained
    by limiting the application source code to a set of calls to routines and libraries
    available to all the supported platforms, and by delegating all tasks that may
    differ between platforms (such as drawing on the screen and accessing system data
    or hardware) to Qt. This effectively creates a layered environment (as shown in
    the following diagram), where Qt hides all platform-dependent aspects from the
    application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38e091d7-0475-4051-9142-4d9fc1c14a04.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, at times, we need to use some functionality that Qt doesn't provide.
    In such situations, it is important to use a conditional compilation for platform-specific
    code. Qt provides a wide set of macros specifying the current platform. We will
    return to this topic in [Chapter 6](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml),
    *Qt Core Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: Supported platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The framework is available for a number of platforms, ranging from classical
    desktop environments through embedded systems to mobile devices. Qt 5.9 supports
    the following platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Desktop platforms: Windows, Linux, and macOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mobile platforms: UWP, Android, and iOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Embedded platforms: VxWorks, INTEGRITY, QNX, and Embedded Linux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is likely that the list of supported platforms will change in future Qt versions.
    You should refer to the Supported Platforms documentation page for your Qt version
    for detailed information about supported versions of operating systems and compilers.
  prefs: []
  type: TYPE_NORMAL
- en: GUI scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the most part of the history of desktop application development, specifying
    sizes of GUI elements in pixels was the common practice. While most operating
    systems had **dots per inch** (**DPI**) settings and APIs for taking it into account
    for a long time, the majority of existing displays had approximately the same
    DPI, so applications without high DPI support were common.
  prefs: []
  type: TYPE_NORMAL
- en: The situation changed when high-DPI displays became more common in the market—most
    notably in mobile phones and tablets, but also in laptops and desktops. Now, even
    if you only target desktop platforms, you should think about supporting different
    DPI settings. When you target mobile devices, this becomes mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Qt Widgets or Qt Quick, you often don't need to specify pixel
    sizes at all. Standard widgets and controls will use fonts, margins, and offsets
    defined by the style. If layouts are used, Qt will determine positions and sizes
    of all GUI items automatically. Avoid specifying constant sizes for GUI elements
    when possible. You may use sizes related to sizes of other GUI elements, the window,
    or the screen. Qt also provides an API for querying screen DPI, GUI style metrics,
    and font metrics, which should help to determine the optimal size for the current
    device.
  prefs: []
  type: TYPE_NORMAL
- en: On macOS and iOS, Qt Widgets and Qt Quick applications are scaled automatically
    using a virtual coordinate system. Pixel values in the application remain the
    same, but the GUI will scale according to the DPI of the current display. For
    example, if the pixel ratio is set to 2 (a common value for retina displays),
    creating a widget with 100 "pixels" width will produce a widget with 200 physical
    pixels. That means that the application doesn't have to be highly aware of DPI
    variations. However, this scaling does not apply to OpenGL, which always uses
    physical pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Qt versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each Qt version number (for example, 5.9.2) consists of major, minor, and patch
    components. Qt pays special attention to forwards and backwards compatibility
    between different versions. Small changes which are both forwards and backwards
    compatible (typically bug fixes without changing any API) are indicated by changing
    only the patch version. New minor versions usually bring in new API and features,
    so they are not forwards compatible. However, all minor versions are backwards
    binary and source compatible. This means that if you're transitioning to a newer
    minor version (for example, from 5.8 to 5.9), you should always be able to rebuild
    your project without changes. You can even transition to a new minor version without
    rebuilding, by only updating shared Qt libraries (or letting the package manager
    of the OS do that). Major releases indicate big changes and may break backwards
    compatibility. However, the latest major release (5.0) was mostly source compatible
    with the previous version.
  prefs: []
  type: TYPE_NORMAL
- en: Qt declares **Long Term Support** (**LTS**) for certain versions. LTS versions
    receive patch-level releases with bug fixes and security fixes for three years.
    Commercial support is available for even longer periods. Current LTS releases
    at the time of writing are 5.6 and 5.9.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of Qt framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Qt expanded over time, its structure evolved. At first, it was just a single
    library, then a set of libraries. When it became harder to maintain and update
    for the growing number of platforms that it supported, a decision was made to
    split the framework into much smaller modules contained in two module groups—Qt
    Essentials and Qt Add-ons. A major decision relating to the split was that each
    module could now have its own independent release schedule.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Essentials group contains modules that are mandatory to implement for every
    supported platform. This implies that if you are implementing your system using
    modules from this group only, you can be sure that it can be easily ported to
    any other platform that Qt supports. The most important relations between Qt Essentials
    modules are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79abeacb-c7bb-4486-a20e-de558d8e5e3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the modules are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Qt Core** module contains the most basic Qt functionality that all other
    modules rely on. It provides support for event processing, meta-objects, data
    I/O, text processing, and threading. It also brings a number of frameworks, such
    as the Animation framework, the State Machine framework, and the Plugin framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Qt GUI** module provides basic cross-platform support to build user interfaces.
    It contains the common functionality required by more high-level GUI modules (Qt
    Widgets and Qt Quick). Qt GUI contains classes that are used to manipulate windows
    that can be rendered using either the raster engine or OpenGL. Qt supports desktop
    OpenGL as well as OpenGL ES 1.1 and 2.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Widgets** extends the GUI module with the ability to create a user interface
    using widgets, such as buttons, edit boxes, labels, data views, dialog boxes,
    menus, and toolbars, which are arranged using a special layout engine. Qt Widgets
    utilizes Qt''s event system to handle input events in a cross-platform way. This
    module also contains the implementation of an object-oriented 2D graphics canvas
    called Graphics View.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Quick** is an extension of Qt GUI, which provides a means to create lightweight
    fluid user interfaces using QML. It is described in more detail later in this
    chapter, as well as in [Chapter 11](b81d9c47-58fa-49dd-931a-864c7be05840.xhtml)*,
    Introduction to Qt Quick*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt QML** is an implementation of the QML language used in Qt Quick. It also
    provides API to integrate custom C++ types into QML''s JavaScript engine and to
    integrate QML code with C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Network** brings support for IPv4 and IPv6 networking using TCP and UDP.
    It also contains HTTP, HTTPS, FTP clients, and it extends support for DNS lookups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Multimedia** allows programmers to access audio and video hardware (including
    cameras and FM radio) to record and play multimedia content. It also features
    3D positional audio support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt SQL** brings a framework that is used to manipulate SQL databases in an
    abstract way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also other modules in this group, but we will not focus on them in
    this book. If you want to learn more about them, you can look them up in the Qt
    reference manual.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Add-ons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This group contains modules that are optional for any platform. This means
    that if a particular functionality is not available on some platform or there
    is nobody willing to spend time working on this functionality for a platform,
    it will not prevent Qt from supporting this platform. We''ll mention some of the
    most important modules here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Qt Concurrent**: This handles multi-threaded processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt 3D**: This provides high-level OpenGL building blocks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Gamepad**: This enables applications to support gamepad hardware'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt D-Bus**: This allows your application to communicate with others via the
    D-Bus mechanism'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt XML Patterns**: This helps us to access XML data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many other modules are also available, but we will not cover them here.
  prefs: []
  type: TYPE_NORMAL
- en: qmake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some Qt features require additional build steps during the compilation and linking
    of the project. For example, **Meta-Object Compiler** (**moc**), **User Interface
    Compiler** (**uic**), and **Resource Compiler** (**rcc**) may need to be executed
    to handle Qt's C++ extensions and features. For convenience, Qt provides the **qmake**
    executable that manages your Qt project and generates files required for building
    it on the current platform (such as Makefile for the make utility). qmake reads
    the project's configuration from a project file with the `.pro` extension. Qt
    Creator (the IDE that comes with Qt) automatically creates and updates that file,
    but it can be edited manually to alter the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, CMake can be used to organize and build the project. Qt provides
    CMake plugins for performing all the necessary build actions. Qt Creator also
    has fairly good support for CMake projects. CMake is more advanced and powerful
    than qmake, but it's probably not needed for projects with a simple build process.
  prefs: []
  type: TYPE_NORMAL
- en: Modern C++ standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use modern C++ in your Qt projects. Qt's build tool (qmake) allows you
    to specify the C++ standard you want to target. Qt itself introduces an improved
    and extended API by using new C++ features when possible. For example, it uses
    ref-qualified member functions and introduces methods accepting initializer lists
    and rvalue references. It also introduces new macros that help you deal with compilers
    that may or may not support new standards.
  prefs: []
  type: TYPE_NORMAL
- en: If you use a recent C++ revision, you have to pay attention to the compiler
    versions you use across the target platforms because older compilers may not support
    the new standard. In this book, we will assume C++11 support, as it is widely
    available already. Thus, we'll use C++11 features in our code, such as range-based
    `for` loops, scoped enumerations, and lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right license
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is available under two different licensing schemes—you can choose between
    a commercial license and an open source one. We will discuss both here to make
    it easier for you to choose. If you have any doubts regarding whether a particular
    licensing scheme applies to your use case, you better consult a professional lawyer.
  prefs: []
  type: TYPE_NORMAL
- en: An open source license
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advantage of open source licenses is that we don't have to pay anyone to
    use Qt; however, the downside is that there are some limitations imposed on how
    it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: When choosing the open source edition, we have to choose between GPL 3.0 and
    LGPL 3\. Since LGPL is more liberal, in this chapter we will focus on it. Choosing
    LGPL allows you to use Qt to implement systems that are either open source or
    closed source—you don't have to reveal the sources of your application to anyone
    if you don't want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a number of restrictions you need to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: Any modifications that you make to Qt itself need to be made public, for example,
    by distributing source code patches alongside your application binary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LGPL requires that users of your application must be able to replace Qt libraries
    that you provide them with other libraries with the same functionality (for example,
    a different version of Qt). This usually means that you have to dynamically link
    your application against Qt so that the user can simply replace Qt libraries with
    his own. You should be aware that such substitutions can decrease the security
    of your system; thus, if you need it to be very secure, open source may not be
    the option for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LGPL is incompatible with a number of licenses, especially proprietary ones,
    so it is possible that you won't be able to use Qt with some commercial components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some Qt modules may have different licensing restrictions. For example, Qt Charts,
    Qt Data Visualization, and Qt Virtual Keyboard modules are not available under
    LGPL and can only be used under GPL or the commercial license.
  prefs: []
  type: TYPE_NORMAL
- en: The open source edition of Qt can be downloaded directly from [https://www.qt.io](https://www.qt.io).
  prefs: []
  type: TYPE_NORMAL
- en: A commercial license
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the restrictions are lifted if you decide to buy a commercial license
    for Qt. This allows you to keep the entire source code a secret, including any
    changes you may want to incorporate into Qt. You can freely link your application
    statically against Qt, which means fewer dependencies, a smaller deployment bundle
    size, and a faster startup. It also increases the security of your application,
    as end users cannot inject their own code into the application by replacing a
    dynamically loaded library with their own.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the architecture of Qt. We saw how it evolved
    over time and we had a brief overview of what it looks like now. Qt is a complex
    framework and we will not manage to cover it all, as some parts of its functionality
    are more important for game programming than others that you can learn on your
    own in case you ever need them. Now that you know what Qt is, we can proceed with
    the next chapter, where you will learn how to install Qt on to your development
    machine.
  prefs: []
  type: TYPE_NORMAL
