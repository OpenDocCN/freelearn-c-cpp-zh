["```cpp\n    class Person  // base class\n    {\n    private:\n        string name;\n        string title;\n    public:\n        // constructors/destructor (will soon be virtual), \n        // public access functions, public interface etc.\n        virtual void Print() const\n        {\n            cout << title << \" \" << name << endl;\n        }\n    }; \n    ```", "```cpp\n    class Student: public Person  // derived class\n    {\n    private:\n        float gpa = 0.0;  // in-class initialization\n    public:\n        // constructors, destructor specific to Student,\n        // public access functions, public interface, etc.\n        void Print() const override \n        {\n            Person::Print(); // call base class fn to help\n            cout << \" is a student. GPA: \" << gpa << endl;\n        }\n    }; \n    ```", "```cpp\n#include <iostream>\n#include <iomanip>\nusing std::cout;    //preferred to: using namespace std;\nusing std::endl;\nusing std::setprecision;\nusing std::string;\nusing std::to_string;\nconstexpr int MAX = 5;\nclass Person\n{\nprivate: \n    string firstName;\n    string lastName;\n    char middleInitial = '\\0';  // in-class initialization\n    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.\nprotected:\n    void ModifyTitle(const string &); \npublic:\n    Person() = default;   // default constructor\n    Person(const string &, const string &, char, \n           const string &); \n    // copy constructor =default prototype not needed; we\n    // get the default version w/o the =default prototype\n    // Person(const Person &) = default;  // copy const.\n    virtual ~Person();  // virtual destructor\n    const string &GetFirstName() const \n        { return firstName; } \n    const string &GetLastName() const { return lastName; }\n    const string &GetTitle() const { return title; } \n    char GetMiddleInitial() const { return middleInitial; }\n    virtual void Print() const;\n    virtual void IsA() const;  \n    virtual void Greeting(const string &) const;\n};\n```", "```cpp\n// With in-class initialization, writing the default\n// constructor is no longer necessary. \n// Also, remember that strings are member objects and will \n// be default constructed as empty.\n// alternate constructor\nPerson::Person(const string &fn, const string &ln, char mi,\n               const string &t): firstName(fn),\n               lastName(ln), middleInitial(mi), title(t)\n{\n    // dynamically allocate memory for any ptr data members \n}\n// We are choosing to utilize the default copy constructor. \n// If we wanted to prototype/define it, here's the method:\n// Person::Person(const Person &p):\n//          firstName(p.firstName), lastName(p.lastName),\n//          middleInitial(p.middleInitial), title(p.title)\n// { \n    // deep copy any pointer data members here\n// }\nPerson::~Person()\n{\n    // release memory for any dynamically alloc. data mbrs.\n    cout << \"Person destructor <\" << firstName << \" \" \n         << lastName << \">\" << endl;\n}\nvoid Person::ModifyTitle(const string &newTitle)\n{   // assignment between strings ensures a deep assignment\n    title = newTitle;     \n}\nvoid Person::Print() const\n{\n    cout << title << \" \" << firstName << \" \";\n    cout << middleInitial << \". \" << lastName << endl;\n}\nvoid Person::IsA() const\n{\n    cout << \"Person\" << endl;\n}\nvoid Person::Greeting(const string &msg) const\n{\n    cout << msg << endl;\n}\n```", "```cpp\nclass Student: public Person\n{\nprivate: \n    float gpa = 0.0;   // in-class initialization\n    string currentCourse;\n    const string studentId; \n    static int numStudents;  // static data member\npublic:\n    Student();  // default constructor\n    Student(const string &, const string &, char, \n            const string &, float, const string &, \n            const string &); \n    Student(const Student &);  // copy constructor\n    ~Student() override;  // virtual destructor\n    void EarnPhD();  \n    // inline function definitions\n    float GetGpa() const { return gpa; }\n    const string &GetCurrentCourse() const\n        { return currentCourse; }\n    const string &GetStudentId() const \n        { return studentId; }\n    void SetCurrentCourse(const string &); // proto. only\n\n    // In the derived class, keyword virtual is optional, \n    // and not currently recommended. Use override instead.\n    void Print() const final override;\n    void IsA() const override;\n    // note: we choose not to redefine \n    // Person::Greeting(const string &) const\n    static int GetNumberStudents(); // static mbr. function\n};\n// definition for static data member \nint Student::numStudents = 0;  // notice initial value of 0\ninline void Student::SetCurrentCourse(const string &c)\n{\n    currentCourse = c;\n}\n// Definition for static member function (it's also inline)\ninline int Student::GetNumberStudents()\n{\n    return numStudents;\n}\n```", "```cpp\nStudent::Student(): studentId(to_string(numStudents + 100) \n                                        + \"Id\")\n{\n   // studentId is const; we need to set at construction. \n   // We're using member init list with a unique id based\n   // on numStudents + 100), concatenated with string \"Id\".\n   // Remember, string member currentCourse will be default\n   // const. with an empty string (it's a member object)\n   numStudents++;     // set static data member\n}\n// Alternate constructor member function definition\nStudent::Student(const string &fn, const string &ln, \n                 char mi, const string &t, float avg, \n                 const string &course, const string &id):\n                 Person(fn, ln, mi, t), gpa(avg),\n                 currentCourse(course), studentId(id)\n{\n   // dynamically alloc memory for any pointer data members\n   numStudents++;\n}\n// Copy constructor definition\nStudent::Student(const Student &s) : Person(s),\n                gpa(s.gpa), currentCourse(s.currentCourse),\n                studentId(s.studentId)\n{\n   // deep copy any pointer data mbrs of derived class here\n   numStudents++;\n}\n\n// destructor definition\nStudent::~Student()\n{\n    // release memory for any dynamically alloc. data mbrs\n    cout << \"Student destructor <\" << GetFirstName() << \" \"\n         << GetLastName() << \">\" << endl;\n}\nvoid Student::EarnPhD()\n{\n    ModifyTitle(\"Dr.\");  \n}\nvoid Student::Print() const\n{   // need to use access functions as these data members \n    // are defined in Person as private\n    cout << GetTitle() << \" \" << GetFirstName() << \" \";\n    cout << GetMiddleInitial() << \". \" << GetLastName();\n    cout << \" with id: \" << studentId << \" GPA: \";\n    cout << setprecision(3) <<  \" \" << gpa;\n    cout << \" Course: \" << currentCourse << endl;\n}\nvoid Student::IsA() const\n{\n    cout << \"Student\" << endl;\n}\n```", "```cpp\nint main()\n{\n    Person *people[MAX] = { }; // initialize with nullptrs\n    people[0] = new Person(\"Juliet\", \"Martinez\", 'M',\n                           \"Ms.\");\n    people[1] = new Student(\"Hana\", \"Sato\", 'U', \"Dr.\",\n                            3.8, \"C++\", \"178PSU\"); \n    people[2] = new Student(\"Sara\", \"Kato\", 'B', \"Dr.\",\n                            3.9, \"C++\", \"272PSU\"); \n    people[3] = new Person(\"Giselle\", \"LeBrun\", 'R',\n                           \"Miss\");\n    people[4] = new Person(\"Linus\", \"Van Pelt\", 'S',\n                           \"Mr.\");\n    // We will soon see a safer and more modern way to loop\n    // using a range for loop (starting in Chp. 8). \n    // Meanwhile, let's notice mechanics for accessing \n    // each element.\n    for (int i = 0; i < MAX; i++)   \n    {\n       people[i]->IsA();\n       cout << \"  \";\n       people[i]->Print();\n    } \n    for (int i = 0; i < MAX; i++)\n       delete people[i];   // engage virtual dest. sequence\n    return 0;\n}\n```", "```cpp\nPerson\n  Ms. Juliet M. Martinez\nStudent\n  Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++\nStudent\n  Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++\nPerson\n  Miss Giselle R. LeBrun\nPerson\n  Mr. Linus S. Van Pelt\nPerson destructor <Juliet Martinez>\nStudent destructor <Hana Sato>\nPerson destructor <Hana Sato>\nStudent destructor <Sara Kato>\nPerson destructor <Sara Kato>\nPerson destructor <Giselle LeBrun>\nPerson destructor <Linus Van Pelt>\n```", "```cpp\n    class Person  // base class\n    {\n        // data members\n    public:  // member functions, etc. \n        virtual void Print() const;  \n    };\n    class Student: public Person\n    {\n        // data members\n    public:  // member functions, etc.\n        // Newly introduced virtual fn. -- \n        // Not a redefinition of Person::Print()\n        virtual void Print(const string &) const;\n    };\n    ```", "```cpp\n    constexpr int MAX = 2;\n    int main()\n    { \n        Person *people[MAX] = { }; // init. with nullptrs\n        people[0] = new Person(\"Jim\", \"Black\", 'M',\n                               \"Mr.\");\n        people[1] = new Student(\"Kim\", \"Lin\", 'Q', \"Dr.\",\n                                3.55, \"C++\", \"334UD\"); \n        people[1]->Print(); // ok, Person::Print() defined\n        // people[1]->Print(\"Go Team!\"); // error!\n        // explicit downcast to derived type assumes you\n        // correctly recall what the object is\n        (dynamic_cast<Student *> (people[1]))->\n                                 Print(\"I have to study\");\n        // Student stored in its own type\n        Student s1(\"Jafari\", \"Kanumba\", 'B', \"Dr.\", 3.9,\n                   \"C++\", \"845BU\"); \n        // s1.Print(); // error, base class version hidden\n        s1.Print(\"I got an A!\"); // works for type Student\n        s1.Person::Print(); // works using scope \n                          // resolution to base class type\n        return 0;\n    }\n    ```", "```cpp\n    class Person  // base class\n    {\n        // data members\n    public:  // member functions, etc.\n        virtual void Print() const;\n    };\n    class Student: public Person\n    {\n        // data members\n    public:  // member functions, etc.\n        // Override the base class method so that this\n        // interface is not hidden by overloaded fn. below\n        void Print() const override; \n        // add the additional interface \n        // (which is overloaded)\n        // Note: this additional Print() is virtual\n        // from this point forward in the hierarchy\n        virtual void Print(const string &) const; \n    };\n    int main()\n    {\n        Student s1(\"Zack\", \"Doone\", 'A', \"Dr.\", 3.9,\n                   \"C++\", \"769UMD\"); \n        s1.Print();  // this version is no longer hidden.\n        s1.Print(\"I got an A!\"); // also works\n        s1.Person::Print(); // this is no longer necessary\n    }\n    ```", "```cpp\n    class Person\n    {\n    private:   // data members will be as before\n    protected: // assume all member funcs. are as before,\n    public:  // but we will show only virtual funcs. here\n        virtual ~Person();       // 4 virt fns introduced \n        virtual void Print() const;  // in Person class\n        virtual void IsA() const;  \n        virtual void Greeting(const string &) const;\n    };\n    class Student: public Person\n    {\n    private:  // data members will be as before\n    public:   // assume all member funcs. are as before, \n        // but we will show only virtual functions here\n        ~Student() override;  // 3 virt fns are overridden\n        void Print() const override;\n        void IsA() const override;\n    };\n    ```", "```cpp\n    constexpr int MAX = 3;\n    int main()\n    {\n        Person *people[MAX] = { }; // init. with nullptrs\n        people[0] = new Person(\"Joy\", \"Lin\", 'M', \"Ms.\");\n        people[1] = new Student(\"Renee\", \"Alexander\", 'Z',\n                        \"Dr.\", 3.95, \"C++\", \"21-MIT\"); \n        people[2] = new Student(\"Gabby\", \"Doone\", 'A', \n                        \"Ms.\", 3.95, \"C++\", \"18-GWU\"); \n        // In Chp. 8, we'll upgrade to a range for loop\n        for (int i = 0; i < MAX; i++)\n        {                 // at compile time, modified to:\n            people[i]->IsA();  // *(people[i]->vptr[2])()\n            people[i]->Print();\n            people[i]->Greeting(\"Hello\");\n            delete people[i];\n        }\n        return 0;\n    }\n    ```"]