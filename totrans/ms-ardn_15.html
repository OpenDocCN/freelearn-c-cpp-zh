<html><head></head><body>
        

                            
                    <h1 class="header-title">DC Motors and Motor Controllers</h1>
                
            
            
                
<p>So far, in this book, all of the projects have been stationary projects. By stationary projects I mean the projects had no way to move on their own. In this chapter, we will look at how we can add DC motors to any project, giving it the ability to move on its own. When using DC motors, I would recommend using a motor controller to control them. Motor controllers enable us to very easily connect an external power supply to the motor and control the direction and speed of the motor.</p>
<p>In this chapter, you will learn:</p>
<ul>
<li>How a brushed DC motor works</li>
<li>How an H-bridge works</li>
<li>How to use the L298 and L293D motor controllers</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>A DC motor is a class of rotary electrical device that converts electrical energy into physical motion. There are numerous types of DC motors; however, in this chapter, we will look at one specific type, which is the <strong>brushed DC motor</strong>.</p>
<p>Brushed DC motors are used in a wide variety of applications, ranging from toys and robotics to powered windows and power tools. Some advantages of brushed DC motors are their initial low cost, simple control, and low-speed torque. The disadvantages of these motors are their high maintenance costs and low lifespan in high-intensity environments. For the prototyping and robotic projects that we normally do with the Arduino, the disadvantages of the brushed DC motors are normally not a concern.</p>
<p>At the center of a brushed DC motor is a spinning armature, which contains an electromagnet. To the outside of the spinning armature is a permanent, stationary magnet. When the electromagnet in the armature is powered, a magnetic field is created that attracts and repels the permanent stationary magnets. This causes the armature to begin spinning.</p>
<p>To keep the armature spinning, the polarity of the electromagnet needs to be reversed. To do this a segmented copper sleeve called a <strong>commutator</strong> is used, which resides on the axle of the motor. As the motor turns, brushes slide over the commutator, coming in to contact with different parts of the commutator, causing the polarity of the magnet to switch.</p>
<p>The following diagram illustrates the parts of the brushed DC motor:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4c071ff2-14a0-4960-bf0b-d20fe10d6f18.png" style="width:13.42em;height:13.92em;"/></p>
<p>Brushed DC motors come in numerous shapes and sizes. Some of these motors have built-in gearboxes that can change the torque and speed that the motor will spin at. The following photograph shows some examples of brushed DC motors:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9f38db2a-1e24-463b-bc03-3725bf6ddc0e.png" style="width:29.92em;height:17.25em;"/></p>
<p>Powering a DC motor directly from the Arduino for anything other than demonstration purposes, is usually not a good idea because the voltage and current provided from the pin headers are pretty limited. We can use a motor controller to control the direction and speed of a DC motor from the Arduino while still providing an external power source to power it. In this chapter, we will look at how we can use the L298 dual H-bridge motor driver, shown in the following photograph, and also how to use the L293D chip:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b123636d-dada-4d2c-badb-a4cef320a8e0.png" style="width:20.67em;height:18.92em;"/></p>
<p>The L298 motor driver enables us to control the direction and speed of two motors. This driver allows us to control motors from 5V all the way up to 35V with a maximum current of 2A. If the supply voltage is 12V or less, we can also use the 5V output to power the Arduino. The L298 motor driver has several inputs, outputs and power connectors that are labeled. These inputs from left to right are:</p>
<ul>
<li><strong>ENA</strong>: Enables motor A and controls the speed of the motor</li>
<li><strong>IN1 and IN2</strong>: Controls the direction of motor A</li>
<li><strong>IN3 and IN4</strong>: Controls the direction of motor B</li>
<li><strong>ENB</strong>: Enables motor B and controls the speed of the motor</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>ENA and ENB normally have jumpers across the pins. In order to control brushed DC motors, we will need to remove these jumpers and connect the pin to a PWM port. The outputs are:</p>
<ul>
<li><strong>OUT1 and OUT2</strong>: Output power to motor A</li>
<li><strong>OUT3 and OUT4</strong>: Output power to motor B</li>
</ul>
<p>The power inputs, from left to right, are:</p>
<ul>
<li><strong>Vmotor</strong>: Power from an external source that will be used to power the motors</li>
<li><strong>GND</strong>: Ground</li>
<li><strong>Vout</strong>: 5V output that can be used to power the Arduino</li>
</ul>
<p>If we are building a project where we have limited space, rather than using a motor controller such as the L298 dual H-bridge motor driver, we can use an integrated chip such as the <strong>L293D H-bridge IC</strong>. The L293D chip can drive two motors, similar, to the L298 motor driver, and can power motors up to 35V with 600mA of steady current with a maximum of 1.2A. The following diagram shows the pinout for the L293D IC:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e4aebe63-a6fb-4da4-8a6e-3e715188a2d5.png" style="width:15.75em;height:16.17em;"/></p>
<p>Both the L298 motor controller and the L293D chip are H-bridges. Let's take a quick look at how an H-bridge works. An H-bridge is an electric circuit that allows us to apply a voltage to our motors in either direction allowing the motor to run forwards or backwards. The term H-bridge comes from the typical graphic representation of the circuit, which looks like a capital H. The following diagram shows how an H-bridge works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4985c326-ff2e-4764-8d90-173757e2c94f.png" style="width:22.42em;height:12.67em;"/></p>
<p class="mce-root"/>
<p>An H-bridge is usually built with four solid state switches. As we see in the preceding image, when switches 1 and 3 (<strong>I1</strong> and <strong>I3</strong>) are open and switches 2 and 4 (<strong>I2</strong> and <strong>I4</strong>) are closed, the right side of the motor is connected to the power supply while the left side is connected to ground, spinning the motor in one direction. If switches 1 and 3 (<strong>I1</strong> and <strong>I3</strong>) are closed and switches 2 and 4 (<strong>I2</strong> and <strong>I4</strong>) are open, then the left side of the motor is connected to the power supply while the right side is connected to ground, spinning the motor in the other direction.</p>
<p>Let's look at the parts that we will need for our projects in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Components needed</h1>
                
            
            
                
<p>In this chapter, you will need the following components.</p>
<ul>
<li>One Arduino Uno or compatible board</li>
<li>One L298 motor driver</li>
<li>One L293D H-bridge chip</li>
<li>Two brushed DC motors</li>
<li>One external 12V battery (or other external DC power source such as a 9V battery)</li>
<li>Jumper wires</li>
<li>One breadboard</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Circuit diagrams</h1>
                
            
            
                
<p>In this chapter, we will create two projects. The first project will use the L298 motor driver to control a single motor and the second project will use the L293D chip to control a single motor. Here is the circuit diagram for the L298 motor driver project:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/885bf7d0-5c9a-411f-a751-385e84cbc5cd.png" style="width:33.50em;height:25.33em;"/></p>
<p>Before we explain this diagram, let's look at the circuit diagram for the L293D chip circuit as well because there are a lot of similarities between these two diagrams:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c0c8c36d-14ce-4cc5-90b5-e201c3690dbd.png" style="width:35.33em;height:25.17em;"/></p>
<p>The first thing to note with these two diagrams is the circuits contain a common ground. What this means is the ground connectors on the Arduino, battery and the motor controllers (both the L298 and L293D) are all connected together. In projects like these, which include multiple power sources, we must have a common ground between all devices and power sources.</p>
<p>In both circuits, the PWM out of 10 pins on the Arduino are connected to the enable pin on the motor controller. Also, in both circuits, the digital 2 and 3 pins are connected to the IN1 and IN2 pins on the motor controllers. This enables us to use the same code for both projects.</p>
<p>Now let's look at the code for these projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code</h1>
                
            
            
                
<p>The code to control the motors only needs to use the standard <kbd>digitalWrite()</kbd> and <kbd>analogWrite()</kbd> functions from the Arduino standard library, so no external libraries are needed for this code. Therefore, our code will start off by defining the pins on the Arduino that are connected to the motor controllers. This following code does this:</p>
<pre>#define MC_IN_1 3
#define MC_IN_2 2
#define MC_ENABLE 10</pre>
<p>Now we will need to configure the pins for output in the <kbd>setup()</kbd> function as shown in the following code:</p>
<pre>void setup() {
  pinMode(MC_ENABLE, OUTPUT);
  pinMode(MC_IN_1, OUTPUT);
  pinMode(MC_IN_2, OUTPUT);
}</pre>
<p>Now we are ready to power the motors. Let's put the following code into the <kbd>loop()</kbd> function:</p>
<pre>void loop() {
  digitalWrite(MC_IN_1, HIGH);
  digitalWrite(MC_IN_2, LOW);
  analogWrite(MC_ENABLE, 250);
  delay(2000);
  analogWrite(MC_ENABLE, 0);
  delay(1000);
  digitalWrite(MC_IN_1, LOW);
  digitalWrite(MC_IN_2, HIGH);
  analogWrite(MC_ENABLE, 125);
  delay(2000);
  analogWrite(MC_ENABLE, 0);
  delay(1000);
}</pre>
<p>The <kbd>loop()</kbd> function starts off by using the <kbd>digitalWrite()</kbd> function to set input <kbd>1</kbd> on the motor controller to <kbd>HIGH</kbd> and input <kbd>2</kbd> to <kbd>LOW</kbd>. The <kbd>analogWrite()</kbd> function is then used to create a duty cycle of 250 to the enable pin on the motor controller. Remember the PWM pins have a maximum duty cycle of 255; therefore, once the <kbd>analogWrite()</kbd> function is performed, the motor should start spinning at almost full speed.</p>
<p>In order for a brushed DC motor to spin, one input must be HIGH, and the other must be LOW. If the inputs are both HIGH, both LOW or the duty cycle on the enable pin is 0, the motor will not spin. The following chart shows this:</p>
<table border="1" class="MsoTableGrid" style="width: 510px">
<tbody>
<tr>
<td style="width: 45px">
<p>IN1</p>
</td>
<td style="width: 45px">
<p>IN2</p>
</td>
<td style="width: 159px">
<p>Enable Duty Cycle</p>
</td>
<td style="width: 235px">
<p>Result</p>
</td>
</tr>
<tr>
<td style="width: 45px">
<p>HIGH</p>
</td>
<td style="width: 45px">
<p>LOW</p>
</td>
<td style="width: 159px">
<p>&gt;0</p>
</td>
<td style="width: 235px">
<p>Motor spins on direction</p>
</td>
</tr>
<tr>
<td style="width: 45px">
<p>LOW</p>
</td>
<td style="width: 45px">
<p>HIGH</p>
</td>
<td style="width: 159px">
<p>&gt;0</p>
</td>
<td style="width: 235px">
<p>The motor spins other direction</p>
</td>
</tr>
<tr>
<td style="width: 45px">
<p>HIGH</p>
</td>
<td style="width: 45px">
<p>HIGH</p>
</td>
<td style="width: 159px"/>
<td style="width: 235px">
<p>Motor stopped</p>
</td>
</tr>
<tr>
<td style="width: 45px">
<p>LOW</p>
</td>
<td style="width: 45px">
<p>LOW</p>
</td>
<td style="width: 159px"/>
<td style="width: 235px">
<p>Motor stopped</p>
</td>
</tr>
<tr>
<td style="width: 45px"/>
<td style="width: 45px"/>
<td style="width: 159px">
<p>0</p>
</td>
<td style="width: 235px">
<p>Motor stopped</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>After the <kbd>analogWrite()</kbd> function is called, the <kbd>delay</kbd> function is used to pause the execution of the application for two seconds to let the motor run. The <kbd>analogWrite()</kbd> function is then called again to set the duty cycle to 0, which will stop the motor from spinning and delay for one second to give the motor a chance to stop.</p>
<p>The <kbd>digitalWrite()</kbd> functions are then used to input 1 pin <kbd>LOW</kbd> and the input 2 pin <kbd>HIGH</kbd> which is the opposite of how they were originally set which will spin the motor in the opposite direction. The <kbd>analogWrite()</kbd> function is then called to set the duty cycle to 125, which will start spinning the motor at half speed. The <kbd>delay</kbd> function is then used to pause the execution of the application for two seconds, and then we stop the motor again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the project</h1>
                
            
            
                
<p>When this code is run, the motor should spin in one direction for two seconds, stop for one second, spin in the other direction for two seconds, stop for one second and then start over.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Challenge</h1>
                
            
            
                
<p>For this chapter's challenge, try to add second motors to both projects and then change the code so both motors will spin at the same time. You could also try to wire the motors so they will spin in the same direction if you apply a <kbd>HIGH</kbd> value to the IN1 and IN3 pins with a <kbd>LOW</kbd> value to the IN2 and IN4 pins.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned the basics of how a brushed DC motor works and how we can use both the L298 motor driver and the L293D chip to control a brushed DC motor. We also learned how an H-bridge works.</p>
<p>In the next chapter, we will look at a different kind of DC motor. This motor is called a servo motor and is used in projects where precise positioning is needed, such as with robotic arms.</p>


            

            
        
    </body></html>