- en: Applying Immutable State to the Function
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将不可变状态应用于函数
- en: 'After discussing the first-class function and pure function in the previous
    chapter, now let''s talk about a mutable and immutable object. As you have learned,
    we have to be able to pass a function to another function in a first-class function
    and ensure that the function returns the same value if we pass the same argument
    as well. The immutable object, which we will discuss, can help us make these two
    functional programming concepts available in our code. The topics we will discuss
    in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章讨论了一等函数和纯函数之后，现在让我们谈谈可变和不可变对象。正如你所学的，我们必须能够将一个函数传递给另一个函数，并在传递相同的参数时确保函数返回相同的值。我们将讨论的不可变对象可以帮助我们在代码中实现这两个函数式编程概念。本章我们将讨论以下主题：
- en: Modifying the variable in a functional programming approach
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以函数式编程方法修改变量
- en: Demonstrating the use of `const` keyword to avoid value modification
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示使用`const`关键字避免值修改
- en: Applying first-class and pure functions to immutable objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一等函数和纯函数应用于不可变对象
- en: Refactoring the mutable object into an immutable object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可变对象重构为不可变对象
- en: The benefit of an immutable object over a mutable one
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变对象相对于可变对象的优点
- en: Understanding the essential part from immutable object
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不可变对象的核心部分
- en: In object-oriented programming, we usually manipulate the variable objects many
    times, even inside the class itself, which we usually describe as the attributes.
    Also, we sometimes change the global variable from the specific function. However,
    to gain the immutability feature in functional programming, there are two rules
    we have to obey. First, we are not allowed to change the local variable. Second,
    we have to avoid the involvement of the global variable in the function since
    it will affect the function result.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，我们通常多次操作变量对象，甚至在类内部，我们通常将其描述为属性。此外，我们有时会从特定的函数中更改全局变量。然而，为了在函数式编程中获得不可变特性，我们必须遵守两条规则。首先，我们不允许更改局部变量。其次，我们必须避免函数中全局变量的参与，因为它会影响函数结果。
- en: Modifying a local variable
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改局部变量
- en: 'When we talk about a variable, we are talking about a container to store our
    data. In our daily programming, we usually reuse the variable we have created.
    To make it clear, let''s take a look at the `mutable_1.cpp` code. We have the
    `mutableVar` variable and store `100` to it. We then manipulate its value for
    the `i` variable iteration. The code is written as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论变量时，我们是在谈论一个用于存储我们数据的容器。在我们的日常编程中，我们通常重用我们创建的变量。为了使其更清晰，让我们看一下`mutable_1.cpp`代码。我们有`mutableVar`变量，并将其存储为`100`。然后我们通过`i`变量迭代来操作其值。代码如下：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result we should see on the screen will be like the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上应该显示的结果如下截图所示：
- en: '![](img/7afd04cb-5f89-48eb-b264-e8687a17bda1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7afd04cb-5f89-48eb-b264-e8687a17bda1.png)'
- en: 'As we can see, we have successfully manipulated the `mutableVar` variable.
    However, we treat the `mutableVar` variable as a mutable object. It''s because
    we reuse the `mutableVar` variable many times. In other words, we have broken
    the immutable rule we discussed earlier. We can, if we want, refactor the `mutable_1.cpp`
    code to be the immutable one. Let''s analyze the `immutable_1.cpp` code. Here,
    we will create a new local variable each time we intend to change the previous
    variable. The code is written as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已经成功操作了`mutableVar`变量。然而，我们将`mutableVar`变量视为可变对象。这是因为我们多次重用了`mutableVar`变量。换句话说，我们已经违反了我们之前讨论的不可变规则。如果我们愿意，我们可以重构`mutable_1.cpp`代码，使其成为不可变版本。让我们分析`immutable_1.cpp`代码。在这里，每次我们打算更改之前的变量时，我们都会创建一个新的局部变量。代码如下：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see, to avoid changing the local variable, `mutableVar`, we create
    the other ten local variables. The result is stored in the `mutableVar10` variable.
    We then show the result to the console. Indeed, it''s uncommon in our programming
    activities habit. However, this is the way we can do to get the immutable object.
    By doing this immutable approach, we never miss the previous state since we have
    all states. Also, the output we get by running `immutable_1.cpp` is completely
    the same as the output from the `mutable_1.cpp` code, as we can see in the following
    screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，为了避免更改局部变量`mutableVar`，我们创建了其他十个局部变量。结果存储在`mutableVar10`变量中。然后我们将结果显示到控制台。这在我们编程活动的习惯中确实不常见。然而，这正是我们可以用来获取不可变对象的方法。通过这种不可变方法，我们永远不会错过之前的状态，因为我们有所有状态。而且，运行`immutable_1.cpp`得到的输出与`mutable_1.cpp`代码的输出完全相同，正如以下截图所示：
- en: '![](img/7fd867be-dd5e-4fa2-9b1f-e652f6ca741e.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fd867be-dd5e-4fa2-9b1f-e652f6ca741e.png)'
- en: However, since we have more code lines in `immutable_1.cpp` compared to the
    `mutable_1.cpp` code, the performance of the `immutable_1.cpp` code will be slower
    than the `mutable_1.cpp` code. In addition, of course, the `mutable_1.cpp` code
    is more efficient than the `immutable_1.cpp` code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`immutable_1.cpp`中的代码行数比`mutable_1.cpp`多，因此`immutable_1.cpp`代码的性能将比`mutable_1.cpp`代码慢。此外，当然，`mutable_1.cpp`代码比`immutable_1.cpp`代码更高效。
- en: Modifying a variable passed into a function
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改传递给函数的变量
- en: 'Now, we will talk about modifying the variable when it is passed to a function.
    Let''s suppose we have a variable named `n` that contains a string data. We then
    pass it as a parameter to a function named `Modify()`. Inside the function, we
    manipulate the name variable. Let''s take a look at the following `immutable_2.cpp`
    code and analyze it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论当变量被传递到函数中时的修改。假设我们有一个名为`n`的变量，它包含一个字符串数据。然后我们将它作为参数传递给名为`Modify()`的函数。在函数内部，我们操作名字变量。让我们看一下以下`immutable_2.cpp`代码并分析它：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From the preceding code, we see that we store `Frankie Kaur` as the initial
    value of the `n` variable, then modify into `Alexis Andrews` inside the `Modify()`
    function. Now, let''s see the output on the screen when we run the preceding code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到我们将`Frankie Kaur`存储为`n`变量的初始值，然后在`Modify()`函数内将其修改为`Alexis Andrews`。现在，让我们看看运行前面代码时的屏幕输出：
- en: '![](img/c35acf8e-d920-473a-9b15-c35a7f4b7f59.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c35acf8e-d920-473a-9b15-c35a7f4b7f59.png)'
- en: 'As we can see from the preceding screenshot, the name variable still contains
    `Frankie Kaur` as its value, although we have modified it inside the `Modify()`
    function. It''s because we pass the `n` variable in the `main()` function and
    the `Modify()` function receives a copy of the value stored in the `name` variable
    so that the name variable remains unchanged and contains the original value. We
    can mutate the `n` variable if we pass it as the reference, as we can see in the
    following `mutable_2.cpp` code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，尽管我们在`Modify()`函数内修改了它，但名字变量仍然包含`Frankie Kaur`作为其值。这是因为我们在`main()`函数中传递了`n`变量，而`Modify()`函数接收的是`name`变量中存储的值的副本，因此名字变量保持不变，并包含原始值。如果我们以引用的形式传递`n`变量，我们就可以修改它，正如以下`mutable_2.cpp`代码所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Just adding the ampersand symbol (`&`) to the argument of the `Modify()` function
    now passes the parameter as a reference. The output on the screen will be like
    the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需在`Modify()`函数的参数中添加符号`&`，就可以将参数作为引用传递。屏幕上的输出将如下截图所示：
- en: '![](img/e2ffb9ca-57f6-4a70-83f2-ed28d0965f01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2ffb9ca-57f6-4a70-83f2-ed28d0965f01.png)'
- en: 'Based on the preceding screenshot, the `n` variable has now been changed successfully
    in the `Modify()` function since we pass by the reference of the `n` variable,
    not a value itself. There is also another best approach to mutate the variable
    using struct or class type, as we can see in the following `mutable_2a.cpp` code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的截图，`n`变量现在已经在`Modify()`函数中被成功更改，因为我们传递的是`n`变量的引用，而不是其本身。还有另一种最佳方法可以通过结构体或类类型来修改变量，正如我们可以在以下`mutable_2a.cpp`代码中看到：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see in the preceding code, we have a class named `Name` that contains
    a string variable on it. At the beginning, we instance the `Name` class with an
    initial value. We then modify the `str` value inside the class. If we run the
    code, we will get the exact same output comparing with the `mutable_2.cpp` code.
    However, we see that although the `n` variable didn't change, `name.str` did.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们有一个名为`Name`的类，其中包含一个字符串变量。一开始，我们用初始值实例化`Name`类。然后我们修改类内的`str`值。如果我们运行代码，我们将得到与`mutable_2.cpp`代码完全相同的输出。然而，我们注意到尽管`n`变量没有改变，`name.str`却改变了。
- en: Preventing the modification of a value
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止值修改
- en: 'The essential point of immutability is preventing value modification. In C++
    programming language, there is a keyword to prevent the code modifying a value.
    The keyword is `const` and we are going to use it in the `const.cpp` code. We
    have a class named `MyAge` which contains a public field named `age` and we set
    it as `const`. We will play with this `const` field and the code will look like
    following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性的基本点是防止值修改。在C++编程语言中，有一个关键字可以防止代码修改值。这个关键字是`const`，我们将在`const.cpp`代码中使用它。我们有一个名为`MyAge`的类，它包含一个名为`age`的公共字段，并将其设置为`const`。我们将玩转这个`const`字段，代码看起来如下：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see in the preceding code, we instantiate two `MyAge` class; they
    are `AgeNow` and `AgeLater`. For `AgeNow`, we use the initial value for age, while,
    for `AgeLater`, we give `8` to the `age` field. The output on the console will
    be as follow:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们实例化了两个`MyAge`类；它们是`AgeNow`和`AgeLater`。对于`AgeNow`，我们使用年龄的初始值，而对于`AgeLater`，我们将`8`赋给`age`字段。控制台上的输出将如下所示：
- en: '![](img/ea608d37-968f-4063-8110-67ff692584e3.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/ea608d37-968f-4063-8110-67ff692584e3.png)'
- en: 'However, it''s impossible to insert the assignment to age field. The following
    `const_error.cpp` code will not be run since the compiler will refuse it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无法向`age`字段插入赋值。以下`const_error.cpp`代码将无法运行，因为编译器将拒绝它：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see, we modify the `age` value to `10`. The compiler will refuse
    to run since the `age` is set as `const` and will display the following error:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们将`age`值修改为`10`。由于`age`被设置为`const`，编译器将拒绝运行并显示以下错误：
- en: '![](img/ce1c13f3-673b-4574-9687-2f511443d3cc.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/ce1c13f3-673b-4574-9687-2f511443d3cc.png)'
- en: Thus, we have successfully created an immutable object by adding the `const`
    keyword.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过添加`const`关键字成功地创建了一个不可变对象。
- en: Applying the first-class function and the pure function to the immutable object
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一等函数和纯函数应用于不可变对象
- en: 'We gained an introduction to the immutable object from the preceding discussion.
    As you learned in the previous chapter, we can take advantage of the first-class
    function and pure function to create an immutable programming approach. Let''s
    borrow the code from [Chapter *2*](a1baf007-8f40-4616-8718-9887f95120b0.xhtml),
    *Manipulating Functions in Functional Programming*, that is `first_class_1.cpp`.
    We will have the `addition()`, `subtraction()`, `multiplication()`, and `division()`
    methods in our following `first_class_pure_immutable.cpp` code. We will then invoke
    the pure function on the class and assign the result to the variable. The code
    is written as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的讨论中，我们了解了不可变对象。正如你在上一章所学，我们可以利用一等函数和纯函数来创建不可变的编程方法。让我们从[第 *2* 章](a1baf007-8f40-4616-8718-9887f95120b0.xhtml)，“函数式编程中的函数操作”，即`first_class_1.cpp`中的代码借用。在我们的下一个`first_class_pure_immutable.cpp`代码中，我们将有`addition()`、`subtraction()`、`multiplication()`和`division()`方法。然后我们将对类调用纯函数并将结果赋给变量。代码如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we can see in the preceding code, the `addition()`, `subtraction()`, `multiplication()`,
    and `division()` methods are a pure function as they produce the same output as
    long as they receive the same input. We also make a class named `MyValue` and
    set it as `const` to make it immutable. Then, to make our function become the
    first-class function, we wrap each method in the `MyFunction` class using the
    `mem_fn()` function. Afterward, we assign four variables with the function wrapper
    we''ve got. The output on the screen should look like the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`addition()`、`subtraction()`、`multiplication()`和`division()`方法都是纯函数，因为只要它们接收到相同的输入，就会产生相同的输出。我们还创建了一个名为`MyValue`的类，并将其设置为`const`以使其不可变。然后，为了使我们的函数成为一等函数，我们使用`mem_fn()`函数将每个方法包装在`MyFunction`类中。之后，我们用我们得到的函数包装器分配了四个变量。屏幕上的输出应该看起来像以下截图：
- en: '![](img/e8a3cb17-011e-4742-ac95-dd0c36683a35.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e8a3cb17-011e-4742-ac95-dd0c36683a35.png)'
- en: Developing the immutable object
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发不可变对象
- en: After we discuss the concept of immutability, now let's develop the immutable
    object. We will start with the mutable object first, then refactor it into an
    immutable one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论了不可变性的概念之后，现在让我们来开发一个不可变对象。我们将首先从可变对象开始，然后将其重构为一个不可变对象。
- en: Starting with a mutable object
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个可变对象开始
- en: 'Now, let''s go further. We will create another class to design an immutable
    object. First, we will create a mutable class named `MutableEmployee`. We have
    some fields and methods in that class. The header of the class will be like the
    following piece of code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更进一步。我们将创建另一个类来设计一个不可变对象。首先，我们将创建一个名为`MutableEmployee`的可变类。在这个类中我们有一些字段和方法。类的头部代码如下：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see, we have four fields--`m_id`, `m_firstName`, `m_lastName`, and
    `m_salary`. We also have the definition of four methods to store any value to
    those fields. The implementation of those methods is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们有四个字段--`m_id`、`m_firstName`、`m_lastName`和`m_salary`。我们还有四个方法的定义，用于将这些值存储到这些字段中。这些方法的实现如下：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we can see in the preceding code, we have a good OOP code in which the members
    are private; however, we can access them through setters and getters. In other
    words, any code can change any value so that it is mutable. Now, let''s consume
    the preceding class using this coming `mutable_3.cpp` code. We will instance the
    class with the initial value and try to mutate them. The code will look as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，我们有一个很好的面向对象代码，其中成员是私有的；然而，我们可以通过设置器和获取器来访问它们。换句话说，任何代码都可以更改任何值，使其可变。现在，让我们使用即将到来的`mutable_3.cpp`代码来消费前面的类。我们将使用初始值实例化该类并尝试修改它们。代码如下：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we can see in the preceding code, we have the initial value stored in three
    variables--`first`, `last`, and `d`. We will then successfully mutate the instance
    using the setter. The output should be as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，我们有三个变量存储初始值--`first`、`last`和`d`。然后我们将成功地使用设置器修改实例。输出应该如下所示：
- en: '![](img/50a47674-e3af-4527-b437-7c12d7e567d3.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50a47674-e3af-4527-b437-7c12d7e567d3.png)'
- en: The preceding screenshot shows us the mutation result of the `MutableEmployee`
    class. Since we need to avoid the side effect by avoiding the mutate state, we
    have to refactor the class to an immutable class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了`MutableEmployee`类的修改结果。由于我们需要通过避免修改状态来避免副作用，我们必须将类重构为不可变类。
- en: Refactoring a mutable object into an immutable one
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将可变对象重构为不可变对象
- en: 'As we discussed earlier, to avoid side effects, we have to design our class
    to be an immutable object. We will refactor the previous `MutableEmployee` class.
    Let''s take a look at the following header class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，为了避免副作用，我们必须设计我们的类成为一个不可变对象。我们将重构之前的`MutableEmployee`类。让我们看看以下头类：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can see in the preceding header code, we removed the setters from the
    previous `MutableEmployee` class. We did that to make the `ImmutableEmployee`
    class immutable. The implementation of the header can be found in the following
    code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的头代码中看到的，我们从之前的`MutableEmployee`类中移除了设置器。我们这样做是为了使`ImmutableEmployee`类不可变。头部的实现可以在以下代码中找到：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s analyze the `ImmutableEmployee` class and compare it with the `MutableEmployee`
    class. The following is what we should obtain:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析`ImmutableEmployee`类并与`MutableEmployee`类进行比较。以下是我们应该获得的结果：
- en: We now set all member variables to `const`, which means the variables can be
    initialized in the constructor only. This would be the best approach in creating
    an immutable object. However, the `const` members prevent making a move operation
    to other members, which is a neat C++11 optimization.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在将所有成员变量设置为`const`，这意味着变量只能在构造函数中初始化。这将是在创建不可变对象中的最佳方法。然而，`const`成员变量阻止了对其他成员的移动操作，这是一个整洁的C++11优化。
- en: The getter methods now return the `const` reference instead of the value. Since
    the immutable object cannot modify the value, it's better to return the reference
    to them.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器方法现在返回`const`引用而不是值。由于不可变对象不能修改值，因此返回它们的引用更好。
- en: The getters now return the `const` value to avoid the result to be modified
    by other statements. It also prevents some common errors, like the use of `=`
    rather than `==` in comparison. It declares the fact that we use an immutable
    type.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器现在返回`const`值，以避免结果被其他语句修改。它还防止了一些常见的错误，比如在比较时使用`=`而不是`==`。它声明了我们使用不可变类型。
- en: 'The problem occurs if we want to change the `m_firstName` or `m_salary` fields,
    for instance. To solve this problem, we can add the setter to the `ImmutableEmployee`
    class. However, it now returns the `ImmutableEmployee` instance instead of mutating
    the field target. The `immutableemployee.h` code will be as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更改`m_firstName`或`m_salary`字段，例如，问题就会出现。为了解决这个问题，我们可以在`ImmutableEmployee`类中添加setter。然而，现在它返回`ImmutableEmployee`实例而不是修改字段目标。`immutableemployee.h`代码将如下所示：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see, now, in the `immutableemployee.h` file, we have four setters.
    They are `SetId`, `SetFirstName`, `SetLastName`, and `SetSalary`. Although the
    name of setter in the `ImmutableEmployee` class is completely the same as the
    `MutableEmployee` class, in the `ImmutableEmployee` class, the setters return
    the instance of the class, as we discussed earlier. By using this `ImmutableEmployee`
    class, we have to adopt the functional approach since the class is the immutable
    object. The following code is `immutable_3.cpp`, which we refactor from the `mutable_3.cpp`
    file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，现在在`immutableemployee.h`文件中，我们有四个setter。它们是`SetId`、`SetFirstName`、`SetLastName`和`SetSalary`。尽管`ImmutableEmployee`类中的setter名称与`MutableEmployee`类完全相同，但在`ImmutableEmployee`类中，setter返回类的实例，正如我们之前讨论的那样。通过使用这个`ImmutableEmployee`类，我们必须采用函数式方法，因为该类是不可变对象。以下代码是`immutable_3.cpp`，我们从`mutable_3.cpp`文件重构而来：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we see in the preceding code, we modify the content by instancing four other
    `ImmutableEmployee` classes--`me2`, `me3`, `me4`, and `me5`. This resembles what
    we did in `immutable_1.cpp`. However, we now deal with a class. The output of
    the preceding code should look like the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所见，我们通过实例化四个其他的`ImmutableEmployee`类来修改内容--`me2`、`me3`、`me4`和`me5`。这类似于我们在`immutable_1.cpp`中所做的。然而，我们现在处理的是一个类。前面代码的输出应该看起来像以下截图：
- en: '![](img/a09d9280-17e5-4508-bcc2-af9cafd1a3eb.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a09d9280-17e5-4508-bcc2-af9cafd1a3eb.png)'
- en: By obtaining the preceding output, we can say that we have successfully modified
    the instance of the `ImmutableEmployee` class without mutating it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过获得前面的输出，我们可以说我们已经成功修改了`ImmutableEmployee`类的实例，而没有对其进行修改。
- en: Enumerating the benefits of being immutable
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列举不可变性的好处
- en: 'After our discussion, we now know that an immutable object is an essential
    part of the functional programming. The following are the benefits we can get
    from the immutable object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 经过我们的讨论，我们现在知道不可变对象是函数式编程的一个基本组成部分。以下是我们可以从不可变对象中获得的好处：
- en: We won't deal with the side effect. It's because we have ensured that no outside
    state is modified. We also create a new object every time we intend to change
    the value inside the object.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不会处理副作用。这是因为我们已经确保没有外部状态被修改。每次我们打算更改对象内部的价值时，我们都会创建一个新的对象。
- en: There is no invalid object's state. It's because we will always be in an inconsistent
    state. If we forget to invoke a particular method, we will definitely get the
    correct state since there is no connection between methods.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有无效的对象状态。这是因为我们总是处于不一致的状态。如果我们忘记调用特定的方法，我们肯定会得到正确状态，因为没有方法之间有连接。
- en: It will be thread-safe since we can run many methods together with no need to
    lock the first method that is run in the pool. In other words, we will never face
    any synchronization issues.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将是线程安全的，因为我们可以在不需要锁定池中运行的第一个方法的情况下一起运行许多方法。换句话说，我们永远不会面临任何同步问题。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: First, in this chapter, we tried to modify a local variable in a functional
    way. We cannot reuse the variable we created; instead, we have to create another
    one when we need to modify it. We also discussed the technique to modify the variable
    we passed to another function. Instead of passing the argument by value, we have
    to pass it by reference to make it change.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在本章中，我们试图以函数式的方式修改一个局部变量。我们不能重用我们创建的变量；相反，当我们需要修改它时，我们必须创建另一个变量。我们还讨论了修改传递给另一个函数的变量的技术。我们不是通过值传递参数，而是必须通过引用传递以使其改变。
- en: Then, we dug the use of the `const` keyword to provide the immutable behavior
    to the function. By using this keyword, we can ensure that the variable inside
    the class cannot be modified. Another discussion was about applying the first-class
    and pure functions--things you learned in the previous chapter--to gain the power
    of immutability.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了使用`const`关键字为函数提供不可变行为。通过使用此关键字，我们可以确保类内部的变量不能被修改。另一个讨论是将上一章中学到的第一类和纯函数应用于获得不可变性的力量。
- en: We also created the mutable class and then refactored it into an immutable class.
    We are now able to distinguish the mutable and immutable object and can apply
    it in our functional code. Lastly, in this chapter, we enumerated the benefit
    of the immutable object, so we are confident to use it in our daily code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个可变类，并将其重构为不可变类。现在我们能够区分可变和不可变对象，并能在我们的函数式代码中应用它。最后，在这一章中，我们列举了不可变对象的优点，因此我们有信心在日常代码中使用它。
- en: Another question may appear in our minds now. How do we run the recursion if
    we have to deal with the immutable object? We cannot even modify a single variable
    in the method. In the next chapter, we will sort this problem out by discussing
    recursion in functional programming.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能又会有一个问题出现在我们的脑海中。如果我们必须处理不可变对象，我们该如何运行递归？我们甚至无法在方法中修改单个变量。在下一章中，我们将通过讨论函数式编程中的递归来解决这个问题。
