- en: Applying Immutable State to the Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After discussing the first-class function and pure function in the previous
    chapter, now let''s talk about a mutable and immutable object. As you have learned,
    we have to be able to pass a function to another function in a first-class function
    and ensure that the function returns the same value if we pass the same argument
    as well. The immutable object, which we will discuss, can help us make these two
    functional programming concepts available in our code. The topics we will discuss
    in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the variable in a functional programming approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrating the use of `const` keyword to avoid value modification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying first-class and pure functions to immutable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring the mutable object into an immutable object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefit of an immutable object over a mutable one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the essential part from immutable object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented programming, we usually manipulate the variable objects many
    times, even inside the class itself, which we usually describe as the attributes.
    Also, we sometimes change the global variable from the specific function. However,
    to gain the immutability feature in functional programming, there are two rules
    we have to obey. First, we are not allowed to change the local variable. Second,
    we have to avoid the involvement of the global variable in the function since
    it will affect the function result.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a local variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we talk about a variable, we are talking about a container to store our
    data. In our daily programming, we usually reuse the variable we have created.
    To make it clear, let''s take a look at the `mutable_1.cpp` code. We have the
    `mutableVar` variable and store `100` to it. We then manipulate its value for
    the `i` variable iteration. The code is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result we should see on the screen will be like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7afd04cb-5f89-48eb-b264-e8687a17bda1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, we have successfully manipulated the `mutableVar` variable.
    However, we treat the `mutableVar` variable as a mutable object. It''s because
    we reuse the `mutableVar` variable many times. In other words, we have broken
    the immutable rule we discussed earlier. We can, if we want, refactor the `mutable_1.cpp`
    code to be the immutable one. Let''s analyze the `immutable_1.cpp` code. Here,
    we will create a new local variable each time we intend to change the previous
    variable. The code is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, to avoid changing the local variable, `mutableVar`, we create
    the other ten local variables. The result is stored in the `mutableVar10` variable.
    We then show the result to the console. Indeed, it''s uncommon in our programming
    activities habit. However, this is the way we can do to get the immutable object.
    By doing this immutable approach, we never miss the previous state since we have
    all states. Also, the output we get by running `immutable_1.cpp` is completely
    the same as the output from the `mutable_1.cpp` code, as we can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fd867be-dd5e-4fa2-9b1f-e652f6ca741e.png)'
  prefs: []
  type: TYPE_IMG
- en: However, since we have more code lines in `immutable_1.cpp` compared to the
    `mutable_1.cpp` code, the performance of the `immutable_1.cpp` code will be slower
    than the `mutable_1.cpp` code. In addition, of course, the `mutable_1.cpp` code
    is more efficient than the `immutable_1.cpp` code.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a variable passed into a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will talk about modifying the variable when it is passed to a function.
    Let''s suppose we have a variable named `n` that contains a string data. We then
    pass it as a parameter to a function named `Modify()`. Inside the function, we
    manipulate the name variable. Let''s take a look at the following `immutable_2.cpp`
    code and analyze it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we see that we store `Frankie Kaur` as the initial
    value of the `n` variable, then modify into `Alexis Andrews` inside the `Modify()`
    function. Now, let''s see the output on the screen when we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c35acf8e-d920-473a-9b15-c35a7f4b7f59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the preceding screenshot, the name variable still contains
    `Frankie Kaur` as its value, although we have modified it inside the `Modify()`
    function. It''s because we pass the `n` variable in the `main()` function and
    the `Modify()` function receives a copy of the value stored in the `name` variable
    so that the name variable remains unchanged and contains the original value. We
    can mutate the `n` variable if we pass it as the reference, as we can see in the
    following `mutable_2.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Just adding the ampersand symbol (`&`) to the argument of the `Modify()` function
    now passes the parameter as a reference. The output on the screen will be like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2ffb9ca-57f6-4a70-83f2-ed28d0965f01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the preceding screenshot, the `n` variable has now been changed successfully
    in the `Modify()` function since we pass by the reference of the `n` variable,
    not a value itself. There is also another best approach to mutate the variable
    using struct or class type, as we can see in the following `mutable_2a.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, we have a class named `Name` that contains
    a string variable on it. At the beginning, we instance the `Name` class with an
    initial value. We then modify the `str` value inside the class. If we run the
    code, we will get the exact same output comparing with the `mutable_2.cpp` code.
    However, we see that although the `n` variable didn't change, `name.str` did.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing the modification of a value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The essential point of immutability is preventing value modification. In C++
    programming language, there is a keyword to prevent the code modifying a value.
    The keyword is `const` and we are going to use it in the `const.cpp` code. We
    have a class named `MyAge` which contains a public field named `age` and we set
    it as `const`. We will play with this `const` field and the code will look like
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we instantiate two `MyAge` class; they
    are `AgeNow` and `AgeLater`. For `AgeNow`, we use the initial value for age, while,
    for `AgeLater`, we give `8` to the `age` field. The output on the console will
    be as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea608d37-968f-4063-8110-67ff692584e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, it''s impossible to insert the assignment to age field. The following
    `const_error.cpp` code will not be run since the compiler will refuse it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we modify the `age` value to `10`. The compiler will refuse
    to run since the `age` is set as `const` and will display the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce1c13f3-673b-4574-9687-2f511443d3cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, we have successfully created an immutable object by adding the `const`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the first-class function and the pure function to the immutable object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We gained an introduction to the immutable object from the preceding discussion.
    As you learned in the previous chapter, we can take advantage of the first-class
    function and pure function to create an immutable programming approach. Let''s
    borrow the code from [Chapter *2*](a1baf007-8f40-4616-8718-9887f95120b0.xhtml),
    *Manipulating Functions in Functional Programming*, that is `first_class_1.cpp`.
    We will have the `addition()`, `subtraction()`, `multiplication()`, and `division()`
    methods in our following `first_class_pure_immutable.cpp` code. We will then invoke
    the pure function on the class and assign the result to the variable. The code
    is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, the `addition()`, `subtraction()`, `multiplication()`,
    and `division()` methods are a pure function as they produce the same output as
    long as they receive the same input. We also make a class named `MyValue` and
    set it as `const` to make it immutable. Then, to make our function become the
    first-class function, we wrap each method in the `MyFunction` class using the
    `mem_fn()` function. Afterward, we assign four variables with the function wrapper
    we''ve got. The output on the screen should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8a3cb17-011e-4742-ac95-dd0c36683a35.png)'
  prefs: []
  type: TYPE_IMG
- en: Developing the immutable object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we discuss the concept of immutability, now let's develop the immutable
    object. We will start with the mutable object first, then refactor it into an
    immutable one.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a mutable object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s go further. We will create another class to design an immutable
    object. First, we will create a mutable class named `MutableEmployee`. We have
    some fields and methods in that class. The header of the class will be like the
    following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we have four fields--`m_id`, `m_firstName`, `m_lastName`, and
    `m_salary`. We also have the definition of four methods to store any value to
    those fields. The implementation of those methods is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we have a good OOP code in which the members
    are private; however, we can access them through setters and getters. In other
    words, any code can change any value so that it is mutable. Now, let''s consume
    the preceding class using this coming `mutable_3.cpp` code. We will instance the
    class with the initial value and try to mutate them. The code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we have the initial value stored in three
    variables--`first`, `last`, and `d`. We will then successfully mutate the instance
    using the setter. The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50a47674-e3af-4527-b437-7c12d7e567d3.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows us the mutation result of the `MutableEmployee`
    class. Since we need to avoid the side effect by avoiding the mutate state, we
    have to refactor the class to an immutable class.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring a mutable object into an immutable one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier, to avoid side effects, we have to design our class
    to be an immutable object. We will refactor the previous `MutableEmployee` class.
    Let''s take a look at the following header class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding header code, we removed the setters from the
    previous `MutableEmployee` class. We did that to make the `ImmutableEmployee`
    class immutable. The implementation of the header can be found in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s analyze the `ImmutableEmployee` class and compare it with the `MutableEmployee`
    class. The following is what we should obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: We now set all member variables to `const`, which means the variables can be
    initialized in the constructor only. This would be the best approach in creating
    an immutable object. However, the `const` members prevent making a move operation
    to other members, which is a neat C++11 optimization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The getter methods now return the `const` reference instead of the value. Since
    the immutable object cannot modify the value, it's better to return the reference
    to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The getters now return the `const` value to avoid the result to be modified
    by other statements. It also prevents some common errors, like the use of `=`
    rather than `==` in comparison. It declares the fact that we use an immutable
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The problem occurs if we want to change the `m_firstName` or `m_salary` fields,
    for instance. To solve this problem, we can add the setter to the `ImmutableEmployee`
    class. However, it now returns the `ImmutableEmployee` instance instead of mutating
    the field target. The `immutableemployee.h` code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, now, in the `immutableemployee.h` file, we have four setters.
    They are `SetId`, `SetFirstName`, `SetLastName`, and `SetSalary`. Although the
    name of setter in the `ImmutableEmployee` class is completely the same as the
    `MutableEmployee` class, in the `ImmutableEmployee` class, the setters return
    the instance of the class, as we discussed earlier. By using this `ImmutableEmployee`
    class, we have to adopt the functional approach since the class is the immutable
    object. The following code is `immutable_3.cpp`, which we refactor from the `mutable_3.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we see in the preceding code, we modify the content by instancing four other
    `ImmutableEmployee` classes--`me2`, `me3`, `me4`, and `me5`. This resembles what
    we did in `immutable_1.cpp`. However, we now deal with a class. The output of
    the preceding code should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a09d9280-17e5-4508-bcc2-af9cafd1a3eb.png)'
  prefs: []
  type: TYPE_IMG
- en: By obtaining the preceding output, we can say that we have successfully modified
    the instance of the `ImmutableEmployee` class without mutating it.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating the benefits of being immutable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After our discussion, we now know that an immutable object is an essential
    part of the functional programming. The following are the benefits we can get
    from the immutable object:'
  prefs: []
  type: TYPE_NORMAL
- en: We won't deal with the side effect. It's because we have ensured that no outside
    state is modified. We also create a new object every time we intend to change
    the value inside the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no invalid object's state. It's because we will always be in an inconsistent
    state. If we forget to invoke a particular method, we will definitely get the
    correct state since there is no connection between methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be thread-safe since we can run many methods together with no need to
    lock the first method that is run in the pool. In other words, we will never face
    any synchronization issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, in this chapter, we tried to modify a local variable in a functional
    way. We cannot reuse the variable we created; instead, we have to create another
    one when we need to modify it. We also discussed the technique to modify the variable
    we passed to another function. Instead of passing the argument by value, we have
    to pass it by reference to make it change.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we dug the use of the `const` keyword to provide the immutable behavior
    to the function. By using this keyword, we can ensure that the variable inside
    the class cannot be modified. Another discussion was about applying the first-class
    and pure functions--things you learned in the previous chapter--to gain the power
    of immutability.
  prefs: []
  type: TYPE_NORMAL
- en: We also created the mutable class and then refactored it into an immutable class.
    We are now able to distinguish the mutable and immutable object and can apply
    it in our functional code. Lastly, in this chapter, we enumerated the benefit
    of the immutable object, so we are confident to use it in our daily code.
  prefs: []
  type: TYPE_NORMAL
- en: Another question may appear in our minds now. How do we run the recursion if
    we have to deal with the immutable object? We cannot even modify a single variable
    in the method. In the next chapter, we will sort this problem out by discussing
    recursion in functional programming.
  prefs: []
  type: TYPE_NORMAL
