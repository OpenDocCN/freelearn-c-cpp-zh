- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Insights into the Arduino IoT Cloud Platform and Web Editor
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting started with any development or cloud platform, it’s important
    to get a broad idea about the platform’s functionality, including its functions,
    controls, widgets, and so on. These platforms are like a kitchen full of spices,
    vegetables, meat, and other ingredients. To cook a good meal in a new kitchen,
    you need to get an idea about what’s in the kitchen – what types of tools, ingredients,
    spices, and other stuff are available. Product development is just like cooking
    a meal – if you have a good idea about what the platform provides, then you will
    be able to develop an awesome project. Another benefit of getting an overview
    of a platform is that it will save your time in the long run and give you confidence
    in your product design, because you already have a good understanding of the platform
    and can combine different things logically to develop something new according
    to your requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: So, in this chapter, we will first cover the main ingredients of the **Arduino
    IoT Cloud** in detail, namely **Things**, **devices**, **dashboards**, **integrations**,
    and **templates**. In the next part, we will take a look at all the **dashboard
    input**/**output widgets** and will see in detail what their purposes are, where
    to use them, and what type of variables they support. We will also have a brief
    comparison between some different control widgets that resemble each other.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In the last part, we will cover the complete **Arduino Web Editor** functionality,
    learning how to import new libraries, what the Web Editor storage and memory limits
    are, how to share your code with others, and how to debug code with the **cloud-based**
    **Serial Monitor**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Arduino IoT Cloud interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input controls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output controls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Arduino Web Editor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An assignment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter only, Arduino IoT Cloud access is required to explore the different
    functionalities and dashboard control widgets we’ll cover in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Arduino IoT Cloud interface
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud’s main interface is composed of five primary components
    – Things, devices, dashboards, integrations, and templates, as shown in *Figure
    3**.1*. Each component has its own properties, which will be discussed in detail
    in this section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Arduino IoT Cloud components](img/B19752_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Arduino IoT Cloud components
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Things, devices, and dashboards are highly coupled with each other in every
    project. For example, for even a small project, we require a Thing and a device
    to get onboard the cloud platform. Is it enough to just configure a Thing and
    a device? No – a dashboard is also mandatory, from which the user can give input
    to the Thing and over which the system can show Thing data for user visualization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: However, integrations are a more optional component, with use cases varying
    from project to project and only being used by developers when they want to connect
    any non-compatible device to the Arduino IoT Cloud, build a custom interface to
    fetch data from the Arduino IoT Cloud, or integrate with third-party services
    such as **Zapier** and **AWS services**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Templates are good for beginners as well as geeks, providing ready-made generic
    projects, including documentation, code, cloud templates, and a list of the hardware
    used in a given project. By using these templates, you can expose yourself to
    new things, which is good for learning purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have discussed the Arduino IoT Cloud’s key interface components. In
    the following section, we will discuss all the components in detail step by step.
    This chapter is very important with respect to all Arduino IoT Cloud features.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Devices and things
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 2*, we explored a *hello world* example, where we used devices,
    Things, and other stuff to complete the example. In this section, we will discuss
    in more detail about devices and Things.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: A device is a **Wi-Fi**/**LoRa-enabled microcontroller** that acts as a bridge
    between the Arduino IoT Cloud and sensors. The Arduino IoT Cloud has a very specific
    list of compatible development boards. Follow [https://support.arduino.cc/hc/en-us/articles/360016077320-What-devices-can-be-used-with-Arduino-IoT-Cloud](https://support.arduino.cc/hc/en-us/articles/360016077320-What-devices-can-be-used-with-Arduino-IoT-Cloud)
    to see the complete list of compatible boards. Besides these official boards,
    the **ESP8266** and **ESP32** boards are also compatible with the IoT Cloud and
    are very low-cost and widely used development boards. There is good news for **LoRaWAN**
    geeks – any brand of LoRaWAN node is compatible with the Arduino IoT Cloud.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to look at the device page. Click on the **Device** menu in the
    dashboard. On this page, we have three main things. The first is the search bar,
    where we can search for devices by name as well as using the four device filters
    available – **Device Type**, **Serial Number**, **Device Status**, or **Thing**.
    The search filters offer awesome functionality for those scenarios where we have
    dozens of devices connected to the platform. The second notable thing on this
    page is the **ADD** button, with which we will attach new devices to the Arduino
    IoT Cloud. The third is the device list table, which shows a complete list of
    the devices connected to the Arduino IoT Cloud along with their statuses, either
    online or offline.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: From the device list table, we can see the relationship between a given device
    and a Thing. The device is either attached to a Thing or is still available to
    join with another Thing. One device is only able to connect with one Thing at
    a time. Besides all of this, the device list shows other important properties
    that can be shown/hidden via the **Table Settings** icon, according to your requirements.
    When set to be shown, you can see a lot of new properties under the table settings,
    such as the ID, type, **Fully Qualified Board Name** (**FQBN**), serial number,
    connectivity module firmware, last activity, and device addition date.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: You can also get all the device properties by clicking on the device. Of all
    the aforementioned device properties, **Last Activity** is one of the most important,
    as it helps to measure device downtime. You can delete devices one by one, or
    you can use the checkbox option to bulk-delete devices. There is another **Update**
    icon below the **Table Settings** icon, which is used to refresh the device table
    list.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: A device is only attachable to one Thing in a one-to-one relationship. If you
    want to use a device associated with any other Thing, then it’s mandatory to detach
    the device from the previously associated Thing before associating it with a new
    Thing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a Thing is a bit like a dish containing pieces of steak, veggies,
    mashed potato, and so on. A Thing holds cloud variables, network connectivity,
    and the device, and is it responsible for managing code and metadata, such as
    the device time zone and the **meta tags** for the Thing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to explore Things more closely in the Arduino IoT Cloud. The
    following diagram summarizes the whole Thing interface:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19752_03_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The Thing interface
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by exploring the Thing main page (shown in *Figure 2**.4* in [*Chapter
    2*](B19752_02.xhtml#_idTextAnchor038)) by clicking on **Thing** menu, which is
    very similar to the menu for devices but with a few differences in the **Search**
    and **Thing** table list. We can see a **CREATE** button for Thing creation, instead
    of **ADD** as there is for devices. The search functionality for Things has totally
    different filters compared to those for devices, allowing us to filter Things
    by **Device**, **Device Type**, and **Time Zone**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: As the relationship between devices and Things is a one-to-one relationship,
    it will show you only one Thing, but **Device Type** is a good feature to show
    a whole bunch of Things with a particular device type. For example, let’s say
    we have deployed two different projects, and each project contains 25 nodes. One
    project was developed by **MKR Wi-Fi 1010**, while the other was developed by
    **ESP32**. The **Device Type** filter provides you with the option to filter down
    the Things to just those using the ESP32 board type. The third filter is **Time
    Zone**, which is very beneficial if you have projects deployed in different regions
    across the world. To return the devices in specific regions, you can simply use
    this **Time** **Zone** filter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设备和Things之间是一对一的关系，它只会显示一个Things，但**设备类型**是一个很好的功能，可以显示具有特定设备类型的所有Things。例如，假设我们部署了两个不同的项目，每个项目包含25个节点。一个项目是由**MKR
    Wi-Fi 1010**开发的，而另一个是由**ESP32**开发的。**设备类型**过滤器为您提供选项，仅筛选使用ESP32板型的Things。第三个过滤器是**时区**，如果您在世界不同地区部署了项目，这将非常有用。要返回特定地区的设备，您只需使用这个**时区**过滤器即可。
- en: By default, the Thing list table provides us with a list of Things with their
    **Device**, **Variables**, and **Last Modified** properties. We can rearrange
    the list by any property in ascending or descending order by clicking on the property
    column. The Thing **option** menu provides us options to delete the Thing. In
    the device property, it shows either the associated device or gives you the option
    to associate a device. The **Last modified** property is good for auditing purposes
    and indicates the last time your Thing was modified.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Things列表表为我们提供了一个包含**设备**、**变量**和**最后修改**属性的Things列表。我们可以通过点击属性列按任何属性以升序或降序重新排列列表。Things**选项**菜单提供了删除Things的选项。在设备属性中，它显示关联的设备或为您提供关联设备的选项。**最后修改**属性对于审计目的很有用，指示您的Things上次修改的时间。
- en: Besides all of these properties, we have some hidden properties, **Creation
    Date** and **Time Zone**, that can be enabled via the **Table Settings** icon,
    located on the right side of the page. If we add meta tags to the Thing, then
    this will also appear under **Table Settings**. Meta tags will be covered in more
    detail in the following few paragraphs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些属性之外，我们还有一些隐藏的属性，**创建日期**和**时区**，可以通过页面右侧的**表格设置**图标启用。如果我们为Things添加元标签，那么它也会出现在**表格设置**下。元标签将在接下来的几段中详细介绍。
- en: It’s time to explore the internal options for Things (*Figure 2**.5* from [*Chapter
    2*](B19752_02.xhtml#_idTextAnchor038)). Click on the **CREATE** button or click
    on any Thing from the table. On the page that appears, you will see three different
    tabs, **Setup**, **Sketch**, and **Metadata**, along with the Thing name in bold
    font. You can also modify the Thing name by clicking on it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候探索Things的内部选项了（*图2.5*来自[*第2章*](B19752_02.xhtml#_idTextAnchor038)）。点击**创建**按钮或点击表格中的任何Things。在出现的页面上，您将看到三个不同的标签，**设置**、**草图**和**元数据**，以及以粗体字显示的Things名称。您也可以通过点击它来修改Things的名称。
- en: The **Setup** tab is used for cloud variable creation and associating devices
    with Things (if not already linked). The **Change/Detach Device** option is available
    for devices associated with the Thing. Finally, there is the option to configure
    the Wi-Fi network settings for the development board.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置**标签用于创建云变量并将设备与Things关联（如果尚未链接）。对于与Things关联的设备，有**更改/断开设备**选项。最后，还有配置开发板Wi-Fi网络设置的选项。'
- en: The second tab is **Sketch**, which provides a mini version of the Arduino Web
    Editor, from where we can write/modify code as well as verify and upload it to
    the associated device. I like the **Sketch** option for Things, as it helps us
    to maintain the code for each device within a separate Thing container, with no
    need for local backups or code management. The mini cloud editor also provides
    the option to open the full editor. Beside that is the search icon, which opens
    the web-based Serial Monitor to verify whether your device is working.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个标签是**草图**，它提供了一个Arduino Web编辑器的迷你版本，从这里我们可以编写/修改代码，以及验证和上传到相关设备。我喜欢**草图**选项用于Things，因为它帮助我们为每个设备在单独的Thing容器中维护代码，无需进行本地备份或代码管理。迷你云编辑器还提供了打开完整编辑器的选项。旁边是搜索图标，它打开基于Web的串行监视器以验证您的设备是否正常工作。
- en: The third tab is for Thing metadata. Normally, people don’t concern themselves
    with these settings, but they are used to classify and provide ease of management
    when you have dozens of Things. Here, we can add tags to classify our Things.
    **Tags** also appear in the Thing table list, as well as in the search bar as
    a filter option. So, let’s see how tags work. A tag consists of two parts – one
    is the key and the other is a value. The key is used in search filters. For example,
    if you have dozens of devices for different organizations and each organization
    contains multiple devices, then how you can filter the specific organization devices?
    The answer is by tag; you create a tag, where the key will be the organization
    name and the value will be the type of device. When you type the organization
    name in the search bar, you will see all the devices that are associated with
    these meta tags. The next option is the time zone, which is the perfect option
    to get Thing data according to the time zone of its native region. By default,
    it shows the time zone according to your location, but you can manually override
    the time zone. Resetting it will show some details regarding the Thing, such as
    **Thing ID**, **Last Modified**, **Last Sync**, and **Created At**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the following question arises: *What is the difference between
    Last Modified and* *Last Sync?*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you have a think and find a solution to it before you proceed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine you have written the code for a Thing and it is associated with
    an MKR Wi-Fi 1010 device, but you have changed the association of the device to
    **Arduino Nano RP2040** or any other development board. In this scenario, you
    will get the prewritten code for the RP2040\. You will get this code, as the code
    belongs to the Thing, not the device. However, it may require some minor modifications
    in code, as pins and libraries vary from development board to development board.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the device and Thing pages in detail, regarding
    search options, creations, and other options on the pages. Now, we will discuss
    *dashboards*, which will help us to create beautiful graphical user interfaces
    to control and display device data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Dashboards
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Arduino IoT Cloud offers very versatile dashboards with lots of options,
    providing an awesome experience for users. **Dashboards** consist of different
    features, including widgets, which are categorized into input and output, responsive
    design options for mobile and web, and lots of other features. The following figure
    summarizes all the features of a dashboard, which will be discussed in detail
    step by step in the following sections:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.3 – A\uFEFFn Arduino IoT Cloud dashboard](img/B19752_03_03.jpg)"
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – An Arduino IoT Cloud dashboard
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard interface is very similar to Thing and device interfaces, but
    it’s simpler in terms of search and tables. Let’s now examine input/output widgets
    in the context of the IoT Cloud but not in terms of devices (although devices
    are relevant, as if we provide input to the IoT cloud, it will, in turn, provide
    input to the Thing, and if a device sends output data to the IoT cloud, it will
    be displayed on the dashboard).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘界面与物和设备界面非常相似，但在搜索和表格方面更简单。现在让我们在物联网云的背景下检查输入/输出小部件，而不是从设备的角度来看（尽管设备是相关的，因为如果我们向物联网云提供输入，它将反过来向物提供输入，如果设备向物联网云发送输出数据，它将在仪表盘上显示）。
- en: Arduino IoT dashboards provide a wide variety of widget controls for input/output.
    We will examine all of the widgets in detail later, while here, we will discuss
    some other major features, such as *responsive design* and *sharing and* *downloading
    data*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino物联网仪表盘提供了丰富的输入/输出小部件控制。我们将在稍后详细检查所有的小部件，而在这里，我们将讨论一些其他主要功能，例如*响应式设计*和*数据共享和下载*。
- en: Dashboards provide a responsive grid design system for both mobile/web. To enter
    into editing mode, firstly click on the **Edit** icon on the **Dashboard** page
    (*Figure 2**.15* in [*Chapter 2*](B19752_02.xhtml#_idTextAnchor038)) and then
    on the **Navigation** icon, which is also known as *Arrange Widgets*. You can
    modify the design by making widgets larger or smaller, or by dragging them to
    any location on the canvas. You should see the **Lock** icon on every widget control
    as well, which lets you fix their locations. After placing the widget at the appropriate
    location, click on that lock to fix the position. In the top menu near the **Add**
    button, there is an icon for mobile/desktop mode to align the widgets.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘为移动端和网页端提供响应式网格设计系统。要进入编辑模式，首先在**仪表盘**页面点击**编辑**图标（见[*第2章*](B19752_02.xhtml#_idTextAnchor038)中的*图2.15*），然后点击**导航**图标，也称为*排列小部件*。你可以通过调整小部件的大小或拖动它们到画布上的任何位置来修改设计。你还会在每个小部件控制上看到**锁定**图标，它允许你固定它们的位置。将小部件放置在适当的位置后，点击该锁定图标以固定位置。在靠近**添加**按钮的顶部菜单中，有一个用于移动/桌面模式的图标，用于对齐小部件。
- en: There will come a time when you need to share these dashboards with your stakeholders
    so that they can monitor their systems easily. The Arduino IoT Cloud provides
    a secure way to share your dashboard with others. Just click on the **Sharing**
    icon – from there, we can share our dashboard with other users (although note
    that it’s mandatory that all users’ emails need to be registered with the Arduino
    IoT Cloud to take part in sharing).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将来会有需要与利益相关者共享这些仪表盘的时候，以便他们可以轻松地监控系统。Arduino物联网云提供了一个安全的方式来与他人共享你的仪表盘。只需点击**共享**图标
    - 从那里，我们可以与其他用户共享我们的仪表盘（尽管请注意，所有用户的电子邮件必须注册到Arduino物联网云才能参与共享）。
- en: Getting sensor data from the cloud is an essential element of IoT cloud platforms,
    as researchers use data in a variety of applications, including training **Machine
    Learning**/**Artificial Intelligence** (**ML**/**AI**) models or visualizing data
    on different platforms, such as **Google Looker** and **Tableau**. Arduino provides
    a vast functionality wizard to download all data or the specific data of a given
    cloud variable. Click on the **Download** icon, and you will get a lot of options.
    From there, you can select the variables (either single, multiple, or all, according
    to your requirements) and provide the date range. Arduino will then process the
    data according to your query and share it with you in the CSV format at your registered
    email.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从云中获取传感器数据是物联网云平台的一个基本要素，因为研究人员在多种应用中使用数据，包括训练**机器学习**/**人工智能**（**ML**/**AI**）模型或在不同的平台上可视化数据，例如**Google
    Looker**和**Tableau**。Arduino提供了一个功能强大的向导，可以下载所有数据或特定云变量的数据。点击**下载**图标，你会得到很多选项。从那里，你可以选择变量（根据你的需求，可以是单个、多个或全部）并指定日期范围。Arduino将根据你的查询处理数据，并以CSV格式通过你注册的电子邮件与你共享。
- en: Here, we have talked about different features of dashboards, such as the alignment
    of widgets, responsive design for mobile and web dashboards, and how to download
    sensor data. In the following section, we will cover integrations and templates.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们讨论了仪表盘的不同功能，例如小部件的对齐、移动和网页仪表盘的响应式设计，以及如何下载传感器数据。在下一节中，我们将介绍集成和模板。
- en: Integrations and templates
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成和模板
- en: '**Templates** page contains example projects for learning and practice purpose
    and are great for beginners to try different projects, from the beginner’s level
    all the way up to advanced level. Each project is properly documented with a project
    description, hardware list, code, and imported cloud template. On the **Templates**
    page, you will initially see a very small list of projects, but more can be found
    at [https://projecthub.arduino.cc/](https://projecthub.arduino.cc/), where makers/professionals
    around the globe upload the projects they’ve created with full documentation.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrations** provide interoperability to link the Arduino IoT Cloud with
    other third-party services, as well as custom-developed applications. Arduino
    provides three ways to interact with different platforms, **Application Programming
    Interface** (**APIs**), **Webhooks**, and **Software Development Kits** (**SDKs**),
    as shown in the following figure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Arduino IoT cloud integrations](img/B19752_03_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Arduino IoT cloud integrations
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s talk about APIs, as this technique is widely used by developers
    to interact with different platforms. In the Arduino IoT Cloud, APIs are used
    for two purposes – the first purpose is to set up a non-compatible device with
    the IoT Cloud, including **Raspberry Pi** and **Beagle Bone**, while the second
    purpose is to fetch data from the IoT Cloud using different predefined APIs. These
    APIs will be discussed in detail in [*Chapter 8*](B19752_08.xhtml#_idTextAnchor158).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Webhooks are used as triggers when a specified event happens in a Thing, such
    as an update in the cloud variables. To set up a Webhook, you need to visit the
    specific Thing’s page, click on `JSON` format with lots of details, which will
    be discussed further in [*Chapter 12*](B19752_12.xhtml#_idTextAnchor251).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: It’s very important to understand the concepts behind APIs and Webhooks. Third-party
    applications use an API’s interface to request data from the cloud, but with Webhooks,
    the Arduino IoT Cloud sends the data to a specific platform when any predetermined
    event happens within the Thing. So, if you develop an alert system, then Webhooks
    are the preferred choice, as they send data instantly when any change is detected
    within the Thing. Conversely, if you develop an application where you only need
    data periodically, then APIs are the best solution. To put it simply, Webhooks
    work like **push requests** and APIs work like **pull requests**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud team has also released official SDKs for different programming
    languages, such as **JavaScript** (**Node.js**), **Python**, and **GoLang**. SDKs
    make development easy for developers by allowing them to use predefined functions
    to get data from the cloud, instead of playing with raw APIs. For authentication
    purposes, SDKs use API keys for access and authentication. The Node.js SDK will
    be discussed in detail in [*Chapter 8*](B19752_08.xhtml#_idTextAnchor158).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed APIs, SDKs, and Webhooks. Now, we will explore
    a dashboard’s widget controls. We have divided Arduino Dashboard widget controls
    into two categories, *input* and *output*. In the following section, we will first
    explore the complete range of input controls, and in the subsequent section, we
    will explore the complete range of output controls.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Exploring input controls
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Input controls** are very important in IoT product development, where users
    control the flow of operations according to metrics. The latest trends and technologies
    in the **User Interface**/**User Experience** (**UI**/**UX**) field bring lots
    of different input controls that vary in size, shape, and design, providing a
    better end user experience.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud team has taken account of the latest trends in the market
    and provided nine different, stunning input widgets, each of which provides users
    the ability to give input to Things in various ways. Each widget is linked to
    a single cloud variable; you can link multiple widgets to a single cloud variable,
    but the data type must be the one specified by the widget control. In the following
    subsections, I have categorized the input widgets into various groups, based on
    their resemblance with each other.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Switch, push button, slider, and stepper
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the very basic input control widgets – **switch**, **push
    button**, **slider**, and **stepper**. These widgets allow users to control their
    Things in an effective and efficient manner. All the widgets are shown in *Figure
    3**.5*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19752_03_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Switch, Push Button, Slider, and Stepper
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`on`/`off`) and consume the `Boolean` type cloud variable. The only difference
    between these two controls is the UI/UX design. When the user clicks the switch
    control, it slides on/off and stays in the same state until clicked again. **Push
    Button** also retains its state but is *pressed* in or out to change between on/off
    states.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: To understand the proper working of **Switch** and **Push Button**, just place
    both controls on a dashboard and link them to the same cloud variable. Afterward,
    click on **Push Button** and release it, and then try clicking on the switch.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The `integer` or `float`-type cloud variables. These controls are useful to
    control stepper motor angles, the speed of motors, and light intensity, or even
    to set the threshold for an alert system for temperature and humidity monitoring.
    For example, say you want to set an alarm threshold for temperature and humidity
    values, and also the weather. These controls will help you to get values from
    the stakeholder via the dashboard and process them in the Thing, without needing
    to modify the Thing code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Here, we explored four different input widget controls, **Switch**, **Push Button**,
    **Slider**, and **Stepper**, and their uses in detail. Now, we are going to cover
    input widget controls related to light control.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Color, dimmed light, and colored light
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arduino has introduced three new widgets specific to light color and intensity
    control, which developers can use when building real-world products for smart
    homes. *Figure 3**.6* shows these three widgets, which help you to control your
    smart bulb/light solutions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Color and light widgets](img/B19752_03_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Color and light widgets
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have seen all the widget controls regarding light/bulb control; now,
    we will discuss all the widgets, step by step, in the upcoming subsections. First,
    we will start with the **Color** widget control.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Color
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first widget here is the `Color` type cloud variable, for which we fetch
    the **Red Green Blue** (**RGB**) color values with Arduino code for the final
    device input. The color widget provides an RGB slider to adjust the color, or
    the desired value can be directly entered in the RGB or hex formats. This widget
    is very useful to control RGB LED colors, RGB lamps, and the **WS18B20** module.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet for the Arduino IDE or the Web Editor shows how
    to convert the color type cloud variable into RGB variables:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`RGBVariable` is a cloud variable of the `Color` type. We have to use the RGB
    format to input our color codes into RGB LEDs, and for that reason, we will declare
    three integer type variables, `red`, `green`, and `blue`, and use `RGBVariable.getValue().getRGB(red,
    green, blue);` to convert our single cloud variable value into the `RGB` format.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Dimmed light
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Dimmed Light` cloud variable, which contains the switch status and brightness
    values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving to the code, we first need to understand what values are required
    by the development board. Two values are required here – the on/off status and
    the light brightness level. The following code shows how we get the brightness
    level and on/off status from the `Dimmed Light` cloud variable:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To get the brightness, we need to transform the `dimmedLightVariable` brightness
    property value into the `0`–`255` range, using the `map` function. Then, we need
    to get the on/off status by calling the `getSwitch` property of that cloud variable.
    If it’s on, then we will use the `analogWrite` function on *Pin #5* to adjust
    the brightness; if the switch is off, the LED/lamp will be turned off.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Colored light
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, it’s time to play with colorful strips with the `Colored Light` cloud
    variable type.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code for the Arduino IDE/Web Editor fetches values from the `Colored
    Light` variable type. Before diving into the code, note that we need to get three
    values from that cloud variable – the RGB color, brightness level, and on/off
    status:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Firstly, we fetch the RGB color value in the `int` format by using the `ColoredLightVariable.getValue().getRGB`
    method. Second, we fetch the brightness using the `ColoredLightVariable.getBrightness()`
    method and transform the values with the `map` method. Finally, we fetch the on/off
    status with the `ColoredLightVariable.getSwitch()` method. All the values are
    stored in three different variables that could be used to control LED/lamp or
    RGB strip functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Here, we discussed in detail smart light/bulb controls, which contain **Color**,
    **Dimmed** **light**, and **Colored light** widget controls, including their code
    to fetch and set the values from them. Now, we will discuss another important
    input control, time picker, which is used for configuration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Time picker (configuration)
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **time picker** widget is a very important configuration widget control
    used to set/get the time on a device without modifying the code on the device.
    With this feature, it’s easy to maintain the device time without a **Real-Time
    Clock** (**RTC**) module. Whenever a Thing is turned on, it will automatically
    sync the device time with the time cloud variable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the **Time Picker** widget with the date and
    time, and you have the option to set the date, the time, or both. The widget also
    gives you the ability to change the date and time format according to your region.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The Time Picker widget](img/B19752_03_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The Time Picker widget
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The time picker widget is linked to the `Time` type cloud variable and stores
    all date and time data in the seconds format. The following code takes the local
    time from Arduino Cloud and stores it in a variable:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After fetching the local time, you can use `CloudTimeVariable` to sync your
    Thing operations. Use the preceding code in the `setup` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the time picker widget, including how to set the
    time for this widget control by using the `Time` cloud variable type. Now, we
    will discuss another configuration widget control, the Scheduler Widget control,
    which helps you set the time to automate your operations on IoT devices.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Scheduler (configuration)
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scheduler** is another important utility in Arduino IoT Cloud to automate
    a process. With this widget, we can automate lots of operations without human
    intervention, just like a **cron job** that executes processes/methods at a specific
    time.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: So, where we can use this Scheduler feature in our IoT solutions? There are
    many use cases, including outdoor light automation, watering systems in agriculture,
    and animal feeders for poultry farms.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot of the **Scheduler** widget shows the many options
    to schedule our processes/methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The Scheduler Widget](img/B19752_03_08.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – The Scheduler Widget
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The Scheduler Widget uses the `Schedule` cloud variable type. When configuring
    it, we specify at what time and on which day we want the process to start and
    end.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is very simple, using a `true`/`false` interface
    to start/stop operations, respectively, instead of going into complex stuff:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can get the active/not active status of every `Schedule` cloud variable by
    accessing its `isActive()` method. Use the aforementioned code in a device loop
    – if the `Schedule` cloud variable is active, then execute the given processes/methods;
    otherwise, stop them. Why do we need to execute the preceding code snippet in
    a loop? Because the `loop()` method is the main method in Arduino, which always
    executes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed Scheduler in detail, what type of cloud variable
    is used by this widget, and how to access the Scheduler status to perform a specific
    job. This is the last control in input widgets. Now, we will look at the output
    control widgets. In the following section, all the output controls will be discussed
    in detail to give you a better understanding of how to implement these controls
    in your professional projects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Delving into output controls
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we discussed input widget controls. Arduino IoT Cloud
    dashboards also feature stunning output controls. There are nine widgets here
    (although two are **non-device widgets** – **messenger** and **sticky note**).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Value, status, gauge, percentage, and LED
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the basic output widgets commonly used by developers in almost
    every solution. These output widgets are used to display a single value either
    in numerical or graphical format. *Figure 3**.9* shows all the main and basic
    output control widgets:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The Value, Status, LED, Gauge, and Percentage widgets](img/B19752_03_09.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – The Value, Status, LED, Gauge, and Percentage widgets
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss in detail five different output widget controls
    in separate sections. First, we will start with the value widget control.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Value
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `integer` type variables, but I also tested it with the `time` variable,
    and it worked fine, as the `time` variable stores all information in seconds.
    You can also use the value widget control to set thresholds for sensors, automating
    the process flow.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The following simple code snippet takes the value from analog pin #0 and stores
    it in `valueCloudVariable`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we discussed the value widget control, which is used for both input and
    output purposes. Now, we will explore the status and LED control widgets.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Status and LED
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next widgets are `true` or `false`. These widgets only display the state;
    they don’t provide any option to control them, and they both work with the `bool`
    type cloud variable. Use cases for these widgets include indicating the Thing
    status (on/off) – for example, a water pump’s status in smart agriculture, or
    whether a door is open or closed in a smart home. Just assign `true`/`false` to
    the `bool` cloud variable type, which is linked to the status widget after performing
    a specific task.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code demonstrates how we can change the value of `statusCloudVariable`
    to change the status/LED widgets’ appearance:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码演示了如何更改 `statusCloudVariable` 的值以更改状态/LED 小部件的外观：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code shows how, after performing the `digitalWrite` operation,
    we change the value of `statusCloudVariable` according to the current condition
    to update the status widget.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码展示了在执行 `digitalWrite` 操作后，我们如何根据当前条件更改 `statusCloudVariable` 的值以更新状态小部件。
- en: Gauge and percentage
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪表和百分比
- en: Finally, we have the `integer` or `float` cloud variable types. Comparing the
    gauge and percentage widgets, we can see a clear difference in UI/UX design –
    gauge uses a half-circle to display a sensor reading, while the percentage widget
    uses a full circle featuring icons, for which you can specify the color if a value
    goes below or above a given threshold. However, the working of both widgets is
    essentially the same. Gauge can be used to display gas-related readings, such
    as air quality, carbon dioxide levels, and temperature, while the percentage widget
    is best for displaying humidity, battery level, **Light-Dependent Resistor** (**LDR**)
    values, and so on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `整数` 或 `浮点` 云变量类型。比较仪表和百分比小部件，我们可以看到 UI/UX 设计上的明显差异 – 仪表使用半圆来显示传感器读数，而百分比小部件使用带有图标的完整圆圈，你可以指定当值低于或高于给定阈值时的颜色。然而，这两个小部件的工作原理本质上是一样的。仪表可以用来显示与气体相关的读数，例如空气质量、二氧化碳水平、温度等，而百分比小部件最适合显示湿度、电池水平、**光敏电阻**
    (**LDR**) 值等。
- en: Here, I haven’t provided the sample code for the gauge and percentage widgets,
    as it’s very similar to the preceding example – just assign the values of the
    sensors to the gauge- and percentage-linked cloud variables.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我没有提供仪表和百分比小部件的示例代码，因为它们与前面的例子非常相似 – 只需将传感器的值分配给仪表和百分比关联的云变量。
- en: Important note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As a little exercise, create an integer type variable named `MultiDimmVariable`,
    and drop a gauge, percentage, and slider widget on the dashboard. Link these three
    widgets with the same `MultiDimmVariable` cloud variable you created. Now, you
    can have a bit of fun; just change the slider position and see how the gauge and
    percentage widgets react.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小练习，创建一个名为 `MultiDimmVariable` 的整型变量，并在仪表板上放置一个仪表、百分比和滑动条小部件。将这些三个小部件与您创建的相同
    `MultiDimmVariable` 云变量链接。现在，您可以有点乐趣；只需改变滑动条的位置，看看仪表和百分比小部件如何反应。
- en: In this section, we discussed all the major output controls, which include value,
    status, gauge, percentage, and LED, step by step, and their usage and code. Now,
    we will look at maps and charts widgets, which are the most important widgets
    to display for location and time-series data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们逐步讨论了所有主要输出控制，包括值、状态、仪表、百分比和 LED，以及它们的用法和代码。现在，我们将查看地图和图表小部件，这些是显示位置和时间序列数据最重要的两个小部件。
- en: Maps and charts
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图和图表
- en: Our next two widgets are very interesting – one is used to display maps with
    specific coordinates, and the other is used to display the `integer`/`float` type
    sensor readings in graph format. *Figure 3**.10* shows the **Map** and **Chart**
    widget controls. The map widget is used to display the location of a device using
    coordinates, and the chart widget is used to display the values in a time-series
    manner.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的两个小部件非常有趣 – 一个用于显示具有特定坐标的地图，另一个用于以图表格式显示 `整数`/`浮点` 类型传感器的读数。*图 3.10* 展示了
    **地图** 和 **图表** 小部件的控制界面。地图小部件用于使用坐标显示设备的位置，而图表小部件用于以时间序列方式显示数值。
- en: '![Figure 3.10 – The Map and Chart widgets](img/B19752_03_10.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 地图和图表小部件](img/B19752_03_10.jpg)'
- en: Figure 3.10 – The Map and Chart widgets
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 地图和图表小部件
- en: First, we will start with the map widget, where we will discuss how we can display
    the location, and then, we will explore the chart widget to display the historical
    data of a sensor.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从地图小部件开始，讨论如何显示位置，然后我们将探索图表小部件来显示传感器的历史数据。
- en: Map
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地图
- en: There are many use cases where we need to display the current location of an
    object on a map, which is much easier to understand visually than simple coordinate
    values. The Arduino IoT Cloud provides us with a `location` cloud variable type,
    which consists of latitude and longitude values. The object could be anything
    from a child or animal to a delivery bike, a courier truck, or even food/vegetable
    parcels.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how you can assign the latitude and longitude
    values to the `location` cloud variable:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code is used to assign a location whenever your device receives
    data from a **GPS module**. This map widget is only capable of showing one location
    at a time. If you have multiple objects for which you want to display tracking,
    then each object will need its own map widget.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Chart
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, we can use the gauge or percentage widgets to display the current value
    of a sensor, but what if we want to display the current value as well as historical
    data? For this, **chart** is your best option, which is used to display current
    readings alongside historical readings for better visualization and comparison.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The `integer` or `float` cloud variable types, which as discussed previously
    are appropriate to monitor temperature, humidity, air quality, and so on. Just
    link any cloud variable with the chart widget for data visualization. Other use
    cases include light levels, energy consumption, and levels of different gases
    in industry.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: For quick testing, just drop the slider and chart widgets on a dashboard and
    link both of them with the same `integer` cloud variable type. After that, just
    change the value of the slider, and you can observe how charts work.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Here, we discussed both the map and chart widget controls in detail. Now, we
    will explore messenger and sticky note controls.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Messenger and sticky notes
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our last two widgets are **messenger** and **sticky notes**. Both widgets are
    non-essential elements but do help you to make your dashboard interactive. *Figure
    3**.11* shows both the widget controls:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The Messenger and sticky note widgets](img/B19752_03_11.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – The Messenger and sticky note widgets
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, the first widget is **Messenger**, and the second widget is sticky
    notes. Both widgets will be discussed in the following sections.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Messenger
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **messenger** widget works like any traditional messenger app. But the question
    arises, why would we need this widget on a dashboard? In my opinion, it’s simply
    not essential on any dashboard currently, but in the future, it could become an
    awesome widget and inspire people to develop products where you communicate textually
    with Things, just as we already have the **Amazon Echo Dot** and **Google Assistant**
    devices that users interact with verbally, where you ask questions to the device
    and it responds audibly.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the future, you may see many messenger applications linked to your Things,
    where you ask questions such as, *where is my child?*, and the Thing connected
    to your child will respond to you with their exact location. Alternatively, you
    could ask a question about the temperature/humidity conditions in your room, and
    the Thing would respond with the required answer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: You could also use the messenger widget to create some sort of small search
    engine for your Thing that understands some keywords and responds to users’ queries.
    Remember, the early bird catches the worm.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The messenger widget works with the `string` cloud variable type. The following
    simple code snippet demonstrates how you can write to the messenger widget from
    the device end:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you assign a new value to the string variable, messenger will append the
    new content to the widget. The following code is used to clear the whole widget
    at the device end:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can also integrate the messenger widget with third-party tools such as **Slack**
    and **Discord**, via either an API or Zapier integration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Sticky notes
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sticky note widget works just like simple Windows OS Sticky Notes. It helps
    you to write down your project progress, or you can write anything on a sticky
    note to maintain your dashboards. It helps you in a situation where you have dozens
    of dashboards and you want to add some comments about specific dashboards.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: For the latest updates and details about dashboard widget controls, please visit
    [https://docs.arduino.cc/arduino-cloud/getting-started/dashboard-widgets](https://docs.arduino.cc/arduino-cloud/getting-started/dashboard-widgets).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed both the messenger and sticky note widgets. Sticky
    notes make it easy to maintain projects and write down comments about project
    progress or maintenance, while messenger has a broader use. We also discussed
    how sensor data is related to AI. We have now completed all of our input and output
    widget controls, Now, we will dive deep into the Arduino Web Editor, where we
    will explore all the options step by step.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Arduino Web Editor
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arduino has also launched a web-based editor that is independent of Arduino
    IoT Cloud and the desktop IDE. It works with any board compatible with the Arduino
    IDE without needing to install boards via the board manager. The Web Editor is
    compatible with a majority of web browsers, including Chrome, Firefox, Microsoft
    Edge, and Safari. To work with the Web Editor, your machine should have the **Arduino
    Create Agent**, which acts as a bridge between the device and the Web Editor.
    All code is stored on the cloud, so there is no risk of losing code or any need
    to make backups.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'To visit the Arduino Web Editor, go to [https://create.arduino.cc/editor](https://create.arduino.cc/editor),
    where you will see something like the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The Arduino Web Editor](img/B19752_03_12.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – The Arduino Web Editor
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers in the preceding screenshot correspond to the following elements
    of the Web Editor:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: This is the main menu of the Web Editor, where you will find all the navigation
    links, such as **Sketchbook**, **Examples**, **Libraries**, and **Monitor**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This tab is a sub-menu, displaying options/content according to the current
    main menu selection. In the screenshot, this tab shows content related to the
    sketchbook.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This area is the coding/sketch area, where you can find all the options to work
    with code, such as code verification/uploads, board selection, and the code editor.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This tab is the output terminal, which provides you with information regarding
    code upload status, any errors found in your code, and so on.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we discussed the Arduino Web Editor interface. Now, we will discuss **Sketchbook**,
    **Examples**, **Libraries**, **Monitor**, **References**, and **Help**, as well
    as the **Preferences** and **Features** menus in detail. We will discuss all the
    options in depth so you will get a broader overview of the Arduino Web Editor,
    allowing you to utilize its features fully during your development.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Sketchbook
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This menu option is responsible for sketch organization, creation, code download
    and upload, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The Arduino Web Editor sketchbook](img/B19752_03_13.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – The Arduino Web Editor sketchbook
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers in the preceding screenshot correspond to the following elements
    of the sketchbook screen:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The **NEW SKETCH** button is used to initialize a new set of files for a new
    project. To the right of this button are two icons – the first is used to create
    a folder for project organization, and the second is used to import any existing
    Arduino IDE code/libraries into the Web Editor if required.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is where you will find all of your sketches/folders, and you can also search
    your sketchbooks with the help of the search bar.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tick icon is used to verify the code, while the arrow icon is used to upload
    the code to the development board. From the dropdown to the right of these icons,
    you can select the development board and port. Finally, the ellipsesbutton contains
    a range of options regarding sketches, such as **Save**, **Save as**, **Rename
    Sketch**, and **Download Sketch**.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This area is a playground for developers to write code for their devices. Here,
    you will find two icons to the right of the screen, the first of which is used
    to make the code editor full-screen, while the second is used for code indentation.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the output terminal where you can get all the information about code
    compilation progress and any errors found in your code.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examples
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the top features of Arduino IDE is **Examples**, which is a great resource
    for beginners, who can benefit from examples provided by library and sensor developers.
    This is presented as a separate menu in the Arduino Web Editor. *Figure 3**.14*
    shows the **Example** menu with two different tabs. The first tab shows the **BUILT
    IN** examples, while the second tab shows the **FROM** **LIBRARIES** examples.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – The Arduino Web Editor examples](img/B19752_03_14.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – The Arduino Web Editor examples
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: When you click on the **Examples** menu, the next tab will be displayed, showing
    options for examples either built-in or from libraries. All the examples are organized
    in different categories, just as in the Arduino IDE. You can also use the search
    bar to find examples from a specific library. By default, the Arduino Web Editor
    only displays development board-specific examples and libraries. The preceding
    screenshot only shows examples compatible with MKR Wi-Fi 1010, but you can click
    on the **MKR WIFI 1010** link and shift to **ALL Boards**, and vice versa.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Libraries and the Library Manager
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are thousands of libraries for the Arduino platform, developed by developers
    and sensor and module manufacturers around the world. Libraries provide vast integration
    possibilities for sensors/modules in the Arduino IDE as well as, by default, example
    code. Libraries are the main source of learning for beginners and professional
    developers. *Figure 3**.15* shows the **Libraries** menu with different options,
    such as **LIBRARY MANAGER**, which helps us to install the libraries, and the
    **DEFAULT**, **FAVORITES**, and **CUSTOM** tabs are also shown, which will be
    discussed in detail step by step:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – The Arduino Web Editor libraries](img/B19752_03_15.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – The Arduino Web Editor libraries
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In the Arduino Web Editor, we have access to a vast collection of pre-installed
    libraries, and we can mark libraries as favorites and include them in our code.
    When we open the **Libraries** menu option, we will see the aforementioned three
    main tabs – **DEFAULT**, **FAVORITES**, and **CUSTOM**. The **DEFAULT** tab displays
    all the libraries developed by the Arduino team and verified partners. The **FAVORITES**
    tab contains the libraries that you have favorited in the Library Manager. If
    you can’t find a library specific to your work, then you can import your own library
    into the Arduino Web Editor by clicking on the **CUSTOM** tab.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The Library Manager contains a complete list of libraries from all around the
    world. To add a library to your project that you can’t find in the **DEFAULT**
    tab, just click on **LIBRARY MANAGER**, and a new popup will appear, where you
    can search for a library by its name or company name. When found, mark it as a
    favorite by clicking on the star icon.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Monitor AKA the Serial Monitor
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Serial Monitor** plays a vital role in the verification of **process execution**,
    **sensor testing**, and **code debugging**. It works similarly to a console in
    a web browser, where developers print messages for process verification according
    to their requirements. In the Arduino Web Editor, it has been renamed **Monitor**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The Arduino Web Editor | Monitor](img/B19752_03_16.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – The Arduino Web Editor | Monitor
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the **Monitor** link will only activate the Monitor when there is
    a board connected to the system. Make sure your Arduino Create Agent is running
    in the background as well. At the top of the **Monitor** screen, you will see
    the name of the development board and the port name/number to which it’s connected.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the `Serial.begin()` method. Developers mostly use 9,600 baud rates
    for serial communication. The large text area in the bottom half of the Monitor
    shows all communication between the device and the developer. By default, **AUTOSCROLL**
    is enabled in this window, so new messages will automatically be shown.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Reference, help, and preferences
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Delay` function; just find and click on the `Delay()` method, and it will
    show you a description, with example syntax and code for better understanding.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The **Help** menu provides lots of new information about product updates and
    much more. Information is divided into three tabs, **INFO**, **TUTORIALS**, and
    **GLOSSARY**. The **INFO** tab provides all the latest updates regarding versions,
    compatibility, and bug fixes. The **TUTORIALS** tab contains links to small projects
    that help beginners to learn new stuff. **GLOSSARY** is just like a glossary in
    a book, but here, you will get a specific list related to Arduino, electronics,
    sensors, and so on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we arrive at the **Preferences** menu, from where we can modify the
    Web Editor’s theme and font size, show/hide the output panel, and set code to
    auto-save or be manually saved.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Arduino IoT Web Editor features
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Arduino IDE, we don’t have any restrictions regarding sketch creation,
    compilation, or storage, but in the Arduino Web Editor, we do encounter some restrictions.
    This is because, with Arduino IDE on desktop machines, we use our own resources,
    but everything involved with the Web Editor is hosted on the cloud. On the cloud,
    everything has to be paid for, including storage, processor, and memory usage
    for code verification and compilation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, the Arduino Web Editor has some restrictions and limitations
    on storage size, sketches, and compilations. Arduino has different resource allowances
    for different types of subscribers, which should be compared with other plans
    before purchase. Visit [https://cloud.arduino.cc/plans](https://cloud.arduino.cc/plans)
    for complete details and a comparison of the plans.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – The Arduino Web Editor limits and usage](img/B19752_03_17.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – The Arduino Web Editor limits and usage
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot displays stats regarding the Web Editor features. Firstly,
    we can see how much storage space has been used from the total made available
    as part of the subscription plan. I have 1,000 MB of storage in total with my
    Maker Pro plan. The screenshot also shows how many sketches can be created, and
    finally, how many compilations are allowed. In my case, I have unlimited, but
    the Free plan only had 100 MB of space allowed for sketch storage and limits of
    25 compilations per day.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了Web Editor功能的相关统计数据。首先，我们可以看到从订阅计划中提供的总存储空间中使用了多少。我的Maker Pro计划总共有1,000
    MB的存储空间。截图还显示了可以创建多少个草图，以及最后允许进行多少次编译。在我的情况下，我拥有无限量，但免费计划只允许每天存储100 MB的草图空间，并且每天限制25次编译。
- en: Important note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The Arduino Web Editor features are subject to change over time, so please
    visit the official page for up-to-date information: [https://cloud.arduino.cc/plans](https://cloud.arduino.cc/plans).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Web Editor的功能可能会随时间而变化，请访问官方网站获取最新信息：[https://cloud.arduino.cc/plans](https://cloud.arduino.cc/plans)。
- en: Here, we successfully discussed the different options in the new Arduino Web
    Editor in depth, which will help you to use the Editor effectively and efficiently
    in your development projects, helping you to boost your productivity. The following
    section, *Assignments*, cover different questions for you, which will help to
    test out what you have learned in this chapter and through internet searches,
    helping you to utilize your new skills effectively.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们深入讨论了新Arduino Web Editor中的不同选项，这将帮助您在开发项目中有效地使用编辑器，提高您的生产力。接下来的“任务”部分涵盖了不同的问题，这将帮助您测试在本章和通过互联网搜索中学到的知识，并帮助您有效地利用您的新技能。
- en: Assignments
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: This chapter is longer in length than the previous ones, as we want to give
    you an in-depth overview of Arduino IoT Cloud and its main pillars, which include
    Things, devices, dashboards, integrations and templates, progressing to further
    chapters. In this chapter, we have discussed dashboards, input and output widget
    controls, as well as the Arduino Web Editor in detail. To consolidate what you
    have learned in this chapter, we have created three different assignments for
    you. These assignments will help you to understand the core concepts necessary
    to proceed with the book, as well as in your professional projects.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章相比，本章篇幅更长，因为我们希望为您提供Arduino IoT Cloud及其主要支柱的深入概述，包括事物、设备、仪表板、集成和模板，进而过渡到后续章节。在本章中，我们详细讨论了仪表板、输入和输出控件以及Arduino
    Web Editor。为了巩固您在本章学到的知识，我们为您创建了三个不同的任务。这些任务将帮助您理解继续阅读本书以及您在专业项目中所需的核心理念。
- en: Make sure to attempt all the assignments given ahead.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 确保尝试所有给出的任务。
- en: Assignment 1
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务1
- en: 'ASNA Group is a leading ISO-certified salt supplier organization in Pakistan.
    The organization processes salt according to international standards, but they
    are facing issues in warehouse monitoring, where they want to maintain the temperature/humidity
    in line with the standards, to avoid issues with the finished product. Right now,
    they have five warehouses to monitor. They want multiple views for data monitoring
    and analysis. You need to keep the following questions in mind while developing
    a solution for ASNA Group:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ASNA集团是巴基斯坦领先的ISO认证盐供应商组织。该组织根据国际标准加工盐，但他们面临着仓库监控的问题，他们希望保持温度/湿度符合标准，以避免成品出现质量问题。目前，他们有五个仓库需要监控。他们希望有多个视图进行数据监控和分析。在为ASNA集团开发解决方案时，您需要牢记以下问题：
- en: Firstly, identify what type of industrial-grade sensors/development boards are
    required for this monitoring scenario.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确定需要哪些类型的工业级传感器/开发板来满足这种监控场景。
- en: Is there any calibration required for the sensors? If so, how will you calibrate
    the sensors? If not, provide a reason why it’s not mandatory.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否需要对传感器进行校准？如果是，您将如何校准传感器？如果不是，请提供不强制校准的理由。
- en: What type of widgets are required to visualize the information on a dashboard?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要哪些类型的控件来在仪表板上可视化信息？
- en: How you could visualize readings from five warehouses on one dashboard?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何在一个仪表板上可视化五个仓库的读数？
- en: What type of widgets will be used on the dashboard to allow users to analyze
    readings covering a long period of time?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仪表板上，将使用哪些类型的控件来允许用户分析覆盖长时间段的读数？
- en: By what means will you give the company access to the dashboard?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将通过什么方式为公司提供对仪表板的访问？
- en: Assignment 2
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务2
- en: 'Imzlab Technologies Private Limited is a leading smart agriculture solution
    provider. The company has deployed custom-designed sensors in the field, using
    ESP32 and the Arduino IoT Cloud, to measure soil moisture, soil temperature, and
    outdoor temperature/humidity. On the dashboard, they have different widgets for
    data visualization. They now have a new requirement from a customer to integrate
    a water pump control and display its status history (on/off). The customer also
    requires that on Monday and Thursday, the water pump will run from 5:00 p.m. to
    7:00 p.m., and on Sunday, from 4:00 a.m. to 6:00 a.m., in the GMT+5 time zone.
    On other days, the pump status will be controlled manually. You need to keep the
    following questions in mind while developing a solution for Imzlab Technologies
    Private Limited:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Imzlab Technologies Private Limited 是一家领先的智能农业解决方案提供商。该公司已在田间部署了定制设计的传感器，使用
    ESP32 和 Arduino IoT Cloud 来测量土壤湿度、土壤温度和室外温度/湿度。在仪表板上，他们有不同的数据可视化小部件。他们现在有一个新的客户需求，需要集成水泵控制和显示其状态历史（开启/关闭）。客户还要求在星期一和星期四，水泵将在下午
    5:00 到 7:00 之间运行，在星期日，从凌晨 4:00 到 6:00，在 GMT+5 时区。在其他日子里，水泵状态将由人工控制。在为 Imzlab Technologies
    Private Limited 开发解决方案时，你需要牢记以下问题：
- en: What type of control widgets are required to display and control the water pump
    status?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要哪些控制小部件来显示和控制水泵状态？
- en: How can you provide a solution for automatic pump control on specific days and
    at specific times?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何为特定日期和特定时间提供自动泵控制解决方案？
- en: Is it possible to visualize the water pump on/off status history using charts?
    If so, how? If it’s not possible, provide an alternative solution to meet the
    customer’s requirements.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以使用图表可视化水泵的开启/关闭状态历史？如果是这样，如何？如果不是，请提供一个替代方案以满足客户的需求。
- en: Assignment 3
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作业 3
- en: A group of researchers at Imzlab Technologies Private Limited is working on
    a monitoring system to monitor carbon dioxide levels. They are using MKR 1010
    and the Arduino IoT Cloud, but they are trying to use a custom sensor developed
    by Tingstack LLC. In the Arduino Web Editor, there is no library for this sensor,
    but Tingstack LLC has developed an in-house library for the Arduino platform.
    The researchers also want to share their code with the Tingstack LLC team for
    review.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Imzlab Technologies Private Limited 的一组研究人员正在开发一个监控系统来监测二氧化碳水平。他们正在使用 MKR 1010
    和 Arduino IoT Cloud，但他们正在尝试使用由 Tingstack LLC 开发的定制传感器。在 Arduino Web 编辑器中，没有这个传感器的库，但
    Tingstack LLC 为 Arduino 平台开发了一个内部库。研究人员还希望与 Tingstack LLC 团队分享他们的代码以供审查。
- en: Identify the problems from the preceding paragraph, and write down their solutions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一段中识别问题，并写下它们的解决方案。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was just like understanding the ingredients and kitchen tools we
    have before we start cooking. Firstly, we learned about how the Arduino IoT Cloud
    components work, including Things, devices, dashboards, integrations, and templates.
    Then, we studied all the input/output widget controls to get a proper idea of
    their potential usage, including some example code and the cloud variable types.
    In the following section, we examined what the Arduino Web Editor is and how its
    different features work, including examples, libraries, and the Serial Monitor.
    You should now have a good understanding of all the different ingredients of the
    Arduino IoT Cloud and the Web Editor and how to employ them appropriately.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章就像在我们开始烹饪之前理解我们拥有的成分和厨房工具一样。首先，我们学习了 Arduino IoT Cloud 组件的工作原理，包括事物、设备、仪表板、集成和模板。然后，我们研究了所有输入/输出小部件控制，以获得它们潜在用法的适当概念，包括一些示例代码和云变量类型。在下一节中，我们检查了
    Arduino Web 编辑器是什么以及其不同功能的工作方式，包括示例、库和串行监视器。你现在应该对 Arduino IoT Cloud 和 Web 编辑器的所有不同成分以及如何适当使用它们有一个很好的理解。
- en: This chapter was most important before starting the next chapters, as it gives
    you an in-depth overview of all the main pillars of the Arduino IoT Cloud and
    how they work in real time, which will help you to understand how the Arduino
    IoT Cloud works. Arduino dashboard widgets are also very important to us, as we
    will use different widgets in different projects throughout the book, so giving
    you an overview here has prepared you for upcoming chapters, helping you to understand
    what types of things are mandatory for professional projects and what type of
    controls make your project more robust and professional.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始下一章之前，这一章非常重要，因为它为你提供了Arduino IoT Cloud所有主要支柱的深入概述以及它们如何实时工作，这将帮助你理解Arduino
    IoT Cloud是如何工作的。Arduino仪表板小部件对我们来说也非常重要，因为我们将在这本书的不同项目中使用不同的小部件，所以在这里提供一个概述已经为你即将到来的章节做好了准备，帮助你了解专业项目中哪些类型的事物是强制性的，以及哪些类型的控制可以使你的项目更加稳健和专业。
- en: In the following chapter, we will start work on our first project, where we
    will build an air-quality monitoring system from scratch to deployment. You will
    learn why air-quality monitoring is necessary and what types of development boards/sensors
    are required. We will also use a **Printed Circuit Board** (**PCB**) for proper
    deployment, which will be explained in depth. After a section on the necessary
    hardware, we will set up Things, cloud variables, devices, and network configurations
    and coding for a device, as well as a dashboard for proper data visualization.
    So, gear up for the upcoming chapter, which will be fun for all of you.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始我们的第一个项目，我们将从头开始构建一个空气质量监控系统，直到部署。你将了解为什么空气质量监测是必要的，以及需要哪些类型的开发板/传感器。我们还将使用一个**印刷电路板**（**PCB**）进行适当的部署，这将在深度解释。在必要的硬件部分之后，我们将设置Things、云变量、设备和网络配置以及为设备编写代码，以及用于适当数据可视化的仪表板。所以，准备好即将到来的章节，这将让你们所有人都感到有趣。
- en: 'Part 2: Getting Hands-On with Different Communication Technologies'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：亲身体验不同的通信技术
- en: The second part of the book describes the different communication technologies
    involved in IoT projects and provides four different practical projects to demonstrate
    their usage and how third-party components can be adopted in combination with
    the Arduino IoT Cloud.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 书的第二部分描述了物联网项目中涉及的不同通信技术，并提供了四个不同的实际项目来展示它们的用法以及如何结合Arduino IoT Cloud采用第三方组件。
- en: 'This part has the following chapters:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 4*](B19752_04.xhtml#_idTextAnchor085), *Project #1 – A Smarter Setup
    for Sensing the Environment*'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B19752_04.xhtml#_idTextAnchor085)，*项目#1 – 为环境感知创建一个更智能的设置*'
- en: '[*Chapter 5*](B19752_05.xhtml#_idTextAnchor101), *Project #2 – Creating a Portable
    Thing Tracker Using MKR GSM 1400*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19752_05.xhtml#_idTextAnchor101)，*项目#2 – 使用MKR GSM 1400创建一个便携式物品追踪器*'
- en: '[*Chapter 6*](B19752_06.xhtml#_idTextAnchor120), *Project #3 – A Remote Alarming
    Application with LoRaWAN*'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19752_06.xhtml#_idTextAnchor120)，*项目#3 – 使用LoRaWAN的远程警报应用*'
