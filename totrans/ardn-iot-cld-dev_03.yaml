- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Insights into the Arduino IoT Cloud Platform and Web Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting started with any development or cloud platform, it’s important
    to get a broad idea about the platform’s functionality, including its functions,
    controls, widgets, and so on. These platforms are like a kitchen full of spices,
    vegetables, meat, and other ingredients. To cook a good meal in a new kitchen,
    you need to get an idea about what’s in the kitchen – what types of tools, ingredients,
    spices, and other stuff are available. Product development is just like cooking
    a meal – if you have a good idea about what the platform provides, then you will
    be able to develop an awesome project. Another benefit of getting an overview
    of a platform is that it will save your time in the long run and give you confidence
    in your product design, because you already have a good understanding of the platform
    and can combine different things logically to develop something new according
    to your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this chapter, we will first cover the main ingredients of the **Arduino
    IoT Cloud** in detail, namely **Things**, **devices**, **dashboards**, **integrations**,
    and **templates**. In the next part, we will take a look at all the **dashboard
    input**/**output widgets** and will see in detail what their purposes are, where
    to use them, and what type of variables they support. We will also have a brief
    comparison between some different control widgets that resemble each other.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part, we will cover the complete **Arduino Web Editor** functionality,
    learning how to import new libraries, what the Web Editor storage and memory limits
    are, how to share your code with others, and how to debug code with the **cloud-based**
    **Serial Monitor**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Arduino IoT Cloud interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Arduino Web Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter only, Arduino IoT Cloud access is required to explore the different
    functionalities and dashboard control widgets we’ll cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Arduino IoT Cloud interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud’s main interface is composed of five primary components
    – Things, devices, dashboards, integrations, and templates, as shown in *Figure
    3**.1*. Each component has its own properties, which will be discussed in detail
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Arduino IoT Cloud components](img/B19752_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Arduino IoT Cloud components
  prefs: []
  type: TYPE_NORMAL
- en: Things, devices, and dashboards are highly coupled with each other in every
    project. For example, for even a small project, we require a Thing and a device
    to get onboard the cloud platform. Is it enough to just configure a Thing and
    a device? No – a dashboard is also mandatory, from which the user can give input
    to the Thing and over which the system can show Thing data for user visualization.
  prefs: []
  type: TYPE_NORMAL
- en: However, integrations are a more optional component, with use cases varying
    from project to project and only being used by developers when they want to connect
    any non-compatible device to the Arduino IoT Cloud, build a custom interface to
    fetch data from the Arduino IoT Cloud, or integrate with third-party services
    such as **Zapier** and **AWS services**.
  prefs: []
  type: TYPE_NORMAL
- en: Templates are good for beginners as well as geeks, providing ready-made generic
    projects, including documentation, code, cloud templates, and a list of the hardware
    used in a given project. By using these templates, you can expose yourself to
    new things, which is good for learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have discussed the Arduino IoT Cloud’s key interface components. In
    the following section, we will discuss all the components in detail step by step.
    This chapter is very important with respect to all Arduino IoT Cloud features.
  prefs: []
  type: TYPE_NORMAL
- en: Devices and things
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 2*, we explored a *hello world* example, where we used devices,
    Things, and other stuff to complete the example. In this section, we will discuss
    in more detail about devices and Things.
  prefs: []
  type: TYPE_NORMAL
- en: A device is a **Wi-Fi**/**LoRa-enabled microcontroller** that acts as a bridge
    between the Arduino IoT Cloud and sensors. The Arduino IoT Cloud has a very specific
    list of compatible development boards. Follow [https://support.arduino.cc/hc/en-us/articles/360016077320-What-devices-can-be-used-with-Arduino-IoT-Cloud](https://support.arduino.cc/hc/en-us/articles/360016077320-What-devices-can-be-used-with-Arduino-IoT-Cloud)
    to see the complete list of compatible boards. Besides these official boards,
    the **ESP8266** and **ESP32** boards are also compatible with the IoT Cloud and
    are very low-cost and widely used development boards. There is good news for **LoRaWAN**
    geeks – any brand of LoRaWAN node is compatible with the Arduino IoT Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to look at the device page. Click on the **Device** menu in the
    dashboard. On this page, we have three main things. The first is the search bar,
    where we can search for devices by name as well as using the four device filters
    available – **Device Type**, **Serial Number**, **Device Status**, or **Thing**.
    The search filters offer awesome functionality for those scenarios where we have
    dozens of devices connected to the platform. The second notable thing on this
    page is the **ADD** button, with which we will attach new devices to the Arduino
    IoT Cloud. The third is the device list table, which shows a complete list of
    the devices connected to the Arduino IoT Cloud along with their statuses, either
    online or offline.
  prefs: []
  type: TYPE_NORMAL
- en: From the device list table, we can see the relationship between a given device
    and a Thing. The device is either attached to a Thing or is still available to
    join with another Thing. One device is only able to connect with one Thing at
    a time. Besides all of this, the device list shows other important properties
    that can be shown/hidden via the **Table Settings** icon, according to your requirements.
    When set to be shown, you can see a lot of new properties under the table settings,
    such as the ID, type, **Fully Qualified Board Name** (**FQBN**), serial number,
    connectivity module firmware, last activity, and device addition date.
  prefs: []
  type: TYPE_NORMAL
- en: You can also get all the device properties by clicking on the device. Of all
    the aforementioned device properties, **Last Activity** is one of the most important,
    as it helps to measure device downtime. You can delete devices one by one, or
    you can use the checkbox option to bulk-delete devices. There is another **Update**
    icon below the **Table Settings** icon, which is used to refresh the device table
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A device is only attachable to one Thing in a one-to-one relationship. If you
    want to use a device associated with any other Thing, then it’s mandatory to detach
    the device from the previously associated Thing before associating it with a new
    Thing.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a Thing is a bit like a dish containing pieces of steak, veggies,
    mashed potato, and so on. A Thing holds cloud variables, network connectivity,
    and the device, and is it responsible for managing code and metadata, such as
    the device time zone and the **meta tags** for the Thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to explore Things more closely in the Arduino IoT Cloud. The
    following diagram summarizes the whole Thing interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19752_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The Thing interface
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by exploring the Thing main page (shown in *Figure 2**.4* in [*Chapter
    2*](B19752_02.xhtml#_idTextAnchor038)) by clicking on **Thing** menu, which is
    very similar to the menu for devices but with a few differences in the **Search**
    and **Thing** table list. We can see a **CREATE** button for Thing creation, instead
    of **ADD** as there is for devices. The search functionality for Things has totally
    different filters compared to those for devices, allowing us to filter Things
    by **Device**, **Device Type**, and **Time Zone**.
  prefs: []
  type: TYPE_NORMAL
- en: As the relationship between devices and Things is a one-to-one relationship,
    it will show you only one Thing, but **Device Type** is a good feature to show
    a whole bunch of Things with a particular device type. For example, let’s say
    we have deployed two different projects, and each project contains 25 nodes. One
    project was developed by **MKR Wi-Fi 1010**, while the other was developed by
    **ESP32**. The **Device Type** filter provides you with the option to filter down
    the Things to just those using the ESP32 board type. The third filter is **Time
    Zone**, which is very beneficial if you have projects deployed in different regions
    across the world. To return the devices in specific regions, you can simply use
    this **Time** **Zone** filter.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Thing list table provides us with a list of Things with their
    **Device**, **Variables**, and **Last Modified** properties. We can rearrange
    the list by any property in ascending or descending order by clicking on the property
    column. The Thing **option** menu provides us options to delete the Thing. In
    the device property, it shows either the associated device or gives you the option
    to associate a device. The **Last modified** property is good for auditing purposes
    and indicates the last time your Thing was modified.
  prefs: []
  type: TYPE_NORMAL
- en: Besides all of these properties, we have some hidden properties, **Creation
    Date** and **Time Zone**, that can be enabled via the **Table Settings** icon,
    located on the right side of the page. If we add meta tags to the Thing, then
    this will also appear under **Table Settings**. Meta tags will be covered in more
    detail in the following few paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to explore the internal options for Things (*Figure 2**.5* from [*Chapter
    2*](B19752_02.xhtml#_idTextAnchor038)). Click on the **CREATE** button or click
    on any Thing from the table. On the page that appears, you will see three different
    tabs, **Setup**, **Sketch**, and **Metadata**, along with the Thing name in bold
    font. You can also modify the Thing name by clicking on it.
  prefs: []
  type: TYPE_NORMAL
- en: The **Setup** tab is used for cloud variable creation and associating devices
    with Things (if not already linked). The **Change/Detach Device** option is available
    for devices associated with the Thing. Finally, there is the option to configure
    the Wi-Fi network settings for the development board.
  prefs: []
  type: TYPE_NORMAL
- en: The second tab is **Sketch**, which provides a mini version of the Arduino Web
    Editor, from where we can write/modify code as well as verify and upload it to
    the associated device. I like the **Sketch** option for Things, as it helps us
    to maintain the code for each device within a separate Thing container, with no
    need for local backups or code management. The mini cloud editor also provides
    the option to open the full editor. Beside that is the search icon, which opens
    the web-based Serial Monitor to verify whether your device is working.
  prefs: []
  type: TYPE_NORMAL
- en: The third tab is for Thing metadata. Normally, people don’t concern themselves
    with these settings, but they are used to classify and provide ease of management
    when you have dozens of Things. Here, we can add tags to classify our Things.
    **Tags** also appear in the Thing table list, as well as in the search bar as
    a filter option. So, let’s see how tags work. A tag consists of two parts – one
    is the key and the other is a value. The key is used in search filters. For example,
    if you have dozens of devices for different organizations and each organization
    contains multiple devices, then how you can filter the specific organization devices?
    The answer is by tag; you create a tag, where the key will be the organization
    name and the value will be the type of device. When you type the organization
    name in the search bar, you will see all the devices that are associated with
    these meta tags. The next option is the time zone, which is the perfect option
    to get Thing data according to the time zone of its native region. By default,
    it shows the time zone according to your location, but you can manually override
    the time zone. Resetting it will show some details regarding the Thing, such as
    **Thing ID**, **Last Modified**, **Last Sync**, and **Created At**.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the following question arises: *What is the difference between
    Last Modified and* *Last Sync?*'
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you have a think and find a solution to it before you proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine you have written the code for a Thing and it is associated with
    an MKR Wi-Fi 1010 device, but you have changed the association of the device to
    **Arduino Nano RP2040** or any other development board. In this scenario, you
    will get the prewritten code for the RP2040\. You will get this code, as the code
    belongs to the Thing, not the device. However, it may require some minor modifications
    in code, as pins and libraries vary from development board to development board.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the device and Thing pages in detail, regarding
    search options, creations, and other options on the pages. Now, we will discuss
    *dashboards*, which will help us to create beautiful graphical user interfaces
    to control and display device data.
  prefs: []
  type: TYPE_NORMAL
- en: Dashboards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Arduino IoT Cloud offers very versatile dashboards with lots of options,
    providing an awesome experience for users. **Dashboards** consist of different
    features, including widgets, which are categorized into input and output, responsive
    design options for mobile and web, and lots of other features. The following figure
    summarizes all the features of a dashboard, which will be discussed in detail
    step by step in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.3 – A\uFEFFn Arduino IoT Cloud dashboard](img/B19752_03_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – An Arduino IoT Cloud dashboard
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard interface is very similar to Thing and device interfaces, but
    it’s simpler in terms of search and tables. Let’s now examine input/output widgets
    in the context of the IoT Cloud but not in terms of devices (although devices
    are relevant, as if we provide input to the IoT cloud, it will, in turn, provide
    input to the Thing, and if a device sends output data to the IoT cloud, it will
    be displayed on the dashboard).
  prefs: []
  type: TYPE_NORMAL
- en: Arduino IoT dashboards provide a wide variety of widget controls for input/output.
    We will examine all of the widgets in detail later, while here, we will discuss
    some other major features, such as *responsive design* and *sharing and* *downloading
    data*.
  prefs: []
  type: TYPE_NORMAL
- en: Dashboards provide a responsive grid design system for both mobile/web. To enter
    into editing mode, firstly click on the **Edit** icon on the **Dashboard** page
    (*Figure 2**.15* in [*Chapter 2*](B19752_02.xhtml#_idTextAnchor038)) and then
    on the **Navigation** icon, which is also known as *Arrange Widgets*. You can
    modify the design by making widgets larger or smaller, or by dragging them to
    any location on the canvas. You should see the **Lock** icon on every widget control
    as well, which lets you fix their locations. After placing the widget at the appropriate
    location, click on that lock to fix the position. In the top menu near the **Add**
    button, there is an icon for mobile/desktop mode to align the widgets.
  prefs: []
  type: TYPE_NORMAL
- en: There will come a time when you need to share these dashboards with your stakeholders
    so that they can monitor their systems easily. The Arduino IoT Cloud provides
    a secure way to share your dashboard with others. Just click on the **Sharing**
    icon – from there, we can share our dashboard with other users (although note
    that it’s mandatory that all users’ emails need to be registered with the Arduino
    IoT Cloud to take part in sharing).
  prefs: []
  type: TYPE_NORMAL
- en: Getting sensor data from the cloud is an essential element of IoT cloud platforms,
    as researchers use data in a variety of applications, including training **Machine
    Learning**/**Artificial Intelligence** (**ML**/**AI**) models or visualizing data
    on different platforms, such as **Google Looker** and **Tableau**. Arduino provides
    a vast functionality wizard to download all data or the specific data of a given
    cloud variable. Click on the **Download** icon, and you will get a lot of options.
    From there, you can select the variables (either single, multiple, or all, according
    to your requirements) and provide the date range. Arduino will then process the
    data according to your query and share it with you in the CSV format at your registered
    email.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have talked about different features of dashboards, such as the alignment
    of widgets, responsive design for mobile and web dashboards, and how to download
    sensor data. In the following section, we will cover integrations and templates.
  prefs: []
  type: TYPE_NORMAL
- en: Integrations and templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Templates** page contains example projects for learning and practice purpose
    and are great for beginners to try different projects, from the beginner’s level
    all the way up to advanced level. Each project is properly documented with a project
    description, hardware list, code, and imported cloud template. On the **Templates**
    page, you will initially see a very small list of projects, but more can be found
    at [https://projecthub.arduino.cc/](https://projecthub.arduino.cc/), where makers/professionals
    around the globe upload the projects they’ve created with full documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrations** provide interoperability to link the Arduino IoT Cloud with
    other third-party services, as well as custom-developed applications. Arduino
    provides three ways to interact with different platforms, **Application Programming
    Interface** (**APIs**), **Webhooks**, and **Software Development Kits** (**SDKs**),
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Arduino IoT cloud integrations](img/B19752_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Arduino IoT cloud integrations
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s talk about APIs, as this technique is widely used by developers
    to interact with different platforms. In the Arduino IoT Cloud, APIs are used
    for two purposes – the first purpose is to set up a non-compatible device with
    the IoT Cloud, including **Raspberry Pi** and **Beagle Bone**, while the second
    purpose is to fetch data from the IoT Cloud using different predefined APIs. These
    APIs will be discussed in detail in [*Chapter 8*](B19752_08.xhtml#_idTextAnchor158).
  prefs: []
  type: TYPE_NORMAL
- en: Webhooks are used as triggers when a specified event happens in a Thing, such
    as an update in the cloud variables. To set up a Webhook, you need to visit the
    specific Thing’s page, click on `JSON` format with lots of details, which will
    be discussed further in [*Chapter 12*](B19752_12.xhtml#_idTextAnchor251).
  prefs: []
  type: TYPE_NORMAL
- en: It’s very important to understand the concepts behind APIs and Webhooks. Third-party
    applications use an API’s interface to request data from the cloud, but with Webhooks,
    the Arduino IoT Cloud sends the data to a specific platform when any predetermined
    event happens within the Thing. So, if you develop an alert system, then Webhooks
    are the preferred choice, as they send data instantly when any change is detected
    within the Thing. Conversely, if you develop an application where you only need
    data periodically, then APIs are the best solution. To put it simply, Webhooks
    work like **push requests** and APIs work like **pull requests**.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud team has also released official SDKs for different programming
    languages, such as **JavaScript** (**Node.js**), **Python**, and **GoLang**. SDKs
    make development easy for developers by allowing them to use predefined functions
    to get data from the cloud, instead of playing with raw APIs. For authentication
    purposes, SDKs use API keys for access and authentication. The Node.js SDK will
    be discussed in detail in [*Chapter 8*](B19752_08.xhtml#_idTextAnchor158).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed APIs, SDKs, and Webhooks. Now, we will explore
    a dashboard’s widget controls. We have divided Arduino Dashboard widget controls
    into two categories, *input* and *output*. In the following section, we will first
    explore the complete range of input controls, and in the subsequent section, we
    will explore the complete range of output controls.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring input controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Input controls** are very important in IoT product development, where users
    control the flow of operations according to metrics. The latest trends and technologies
    in the **User Interface**/**User Experience** (**UI**/**UX**) field bring lots
    of different input controls that vary in size, shape, and design, providing a
    better end user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud team has taken account of the latest trends in the market
    and provided nine different, stunning input widgets, each of which provides users
    the ability to give input to Things in various ways. Each widget is linked to
    a single cloud variable; you can link multiple widgets to a single cloud variable,
    but the data type must be the one specified by the widget control. In the following
    subsections, I have categorized the input widgets into various groups, based on
    their resemblance with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Switch, push button, slider, and stepper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the very basic input control widgets – **switch**, **push
    button**, **slider**, and **stepper**. These widgets allow users to control their
    Things in an effective and efficient manner. All the widgets are shown in *Figure
    3**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19752_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Switch, Push Button, Slider, and Stepper
  prefs: []
  type: TYPE_NORMAL
- en: '`on`/`off`) and consume the `Boolean` type cloud variable. The only difference
    between these two controls is the UI/UX design. When the user clicks the switch
    control, it slides on/off and stays in the same state until clicked again. **Push
    Button** also retains its state but is *pressed* in or out to change between on/off
    states.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To understand the proper working of **Switch** and **Push Button**, just place
    both controls on a dashboard and link them to the same cloud variable. Afterward,
    click on **Push Button** and release it, and then try clicking on the switch.
  prefs: []
  type: TYPE_NORMAL
- en: The `integer` or `float`-type cloud variables. These controls are useful to
    control stepper motor angles, the speed of motors, and light intensity, or even
    to set the threshold for an alert system for temperature and humidity monitoring.
    For example, say you want to set an alarm threshold for temperature and humidity
    values, and also the weather. These controls will help you to get values from
    the stakeholder via the dashboard and process them in the Thing, without needing
    to modify the Thing code.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we explored four different input widget controls, **Switch**, **Push Button**,
    **Slider**, and **Stepper**, and their uses in detail. Now, we are going to cover
    input widget controls related to light control.
  prefs: []
  type: TYPE_NORMAL
- en: Color, dimmed light, and colored light
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arduino has introduced three new widgets specific to light color and intensity
    control, which developers can use when building real-world products for smart
    homes. *Figure 3**.6* shows these three widgets, which help you to control your
    smart bulb/light solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Color and light widgets](img/B19752_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Color and light widgets
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have seen all the widget controls regarding light/bulb control; now,
    we will discuss all the widgets, step by step, in the upcoming subsections. First,
    we will start with the **Color** widget control.
  prefs: []
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first widget here is the `Color` type cloud variable, for which we fetch
    the **Red Green Blue** (**RGB**) color values with Arduino code for the final
    device input. The color widget provides an RGB slider to adjust the color, or
    the desired value can be directly entered in the RGB or hex formats. This widget
    is very useful to control RGB LED colors, RGB lamps, and the **WS18B20** module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet for the Arduino IDE or the Web Editor shows how
    to convert the color type cloud variable into RGB variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`RGBVariable` is a cloud variable of the `Color` type. We have to use the RGB
    format to input our color codes into RGB LEDs, and for that reason, we will declare
    three integer type variables, `red`, `green`, and `blue`, and use `RGBVariable.getValue().getRGB(red,
    green, blue);` to convert our single cloud variable value into the `RGB` format.'
  prefs: []
  type: TYPE_NORMAL
- en: Dimmed light
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Dimmed Light` cloud variable, which contains the switch status and brightness
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving to the code, we first need to understand what values are required
    by the development board. Two values are required here – the on/off status and
    the light brightness level. The following code shows how we get the brightness
    level and on/off status from the `Dimmed Light` cloud variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the brightness, we need to transform the `dimmedLightVariable` brightness
    property value into the `0`–`255` range, using the `map` function. Then, we need
    to get the on/off status by calling the `getSwitch` property of that cloud variable.
    If it’s on, then we will use the `analogWrite` function on *Pin #5* to adjust
    the brightness; if the switch is off, the LED/lamp will be turned off.'
  prefs: []
  type: TYPE_NORMAL
- en: Colored light
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, it’s time to play with colorful strips with the `Colored Light` cloud
    variable type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code for the Arduino IDE/Web Editor fetches values from the `Colored
    Light` variable type. Before diving into the code, note that we need to get three
    values from that cloud variable – the RGB color, brightness level, and on/off
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we fetch the RGB color value in the `int` format by using the `ColoredLightVariable.getValue().getRGB`
    method. Second, we fetch the brightness using the `ColoredLightVariable.getBrightness()`
    method and transform the values with the `map` method. Finally, we fetch the on/off
    status with the `ColoredLightVariable.getSwitch()` method. All the values are
    stored in three different variables that could be used to control LED/lamp or
    RGB strip functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we discussed in detail smart light/bulb controls, which contain **Color**,
    **Dimmed** **light**, and **Colored light** widget controls, including their code
    to fetch and set the values from them. Now, we will discuss another important
    input control, time picker, which is used for configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Time picker (configuration)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **time picker** widget is a very important configuration widget control
    used to set/get the time on a device without modifying the code on the device.
    With this feature, it’s easy to maintain the device time without a **Real-Time
    Clock** (**RTC**) module. Whenever a Thing is turned on, it will automatically
    sync the device time with the time cloud variable.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the **Time Picker** widget with the date and
    time, and you have the option to set the date, the time, or both. The widget also
    gives you the ability to change the date and time format according to your region.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The Time Picker widget](img/B19752_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The Time Picker widget
  prefs: []
  type: TYPE_NORMAL
- en: 'The time picker widget is linked to the `Time` type cloud variable and stores
    all date and time data in the seconds format. The following code takes the local
    time from Arduino Cloud and stores it in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After fetching the local time, you can use `CloudTimeVariable` to sync your
    Thing operations. Use the preceding code in the `setup` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the time picker widget, including how to set the
    time for this widget control by using the `Time` cloud variable type. Now, we
    will discuss another configuration widget control, the Scheduler Widget control,
    which helps you set the time to automate your operations on IoT devices.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduler (configuration)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scheduler** is another important utility in Arduino IoT Cloud to automate
    a process. With this widget, we can automate lots of operations without human
    intervention, just like a **cron job** that executes processes/methods at a specific
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: So, where we can use this Scheduler feature in our IoT solutions? There are
    many use cases, including outdoor light automation, watering systems in agriculture,
    and animal feeders for poultry farms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot of the **Scheduler** widget shows the many options
    to schedule our processes/methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The Scheduler Widget](img/B19752_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – The Scheduler Widget
  prefs: []
  type: TYPE_NORMAL
- en: The Scheduler Widget uses the `Schedule` cloud variable type. When configuring
    it, we specify at what time and on which day we want the process to start and
    end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is very simple, using a `true`/`false` interface
    to start/stop operations, respectively, instead of going into complex stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can get the active/not active status of every `Schedule` cloud variable by
    accessing its `isActive()` method. Use the aforementioned code in a device loop
    – if the `Schedule` cloud variable is active, then execute the given processes/methods;
    otherwise, stop them. Why do we need to execute the preceding code snippet in
    a loop? Because the `loop()` method is the main method in Arduino, which always
    executes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed Scheduler in detail, what type of cloud variable
    is used by this widget, and how to access the Scheduler status to perform a specific
    job. This is the last control in input widgets. Now, we will look at the output
    control widgets. In the following section, all the output controls will be discussed
    in detail to give you a better understanding of how to implement these controls
    in your professional projects.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into output controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we discussed input widget controls. Arduino IoT Cloud
    dashboards also feature stunning output controls. There are nine widgets here
    (although two are **non-device widgets** – **messenger** and **sticky note**).
  prefs: []
  type: TYPE_NORMAL
- en: Value, status, gauge, percentage, and LED
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the basic output widgets commonly used by developers in almost
    every solution. These output widgets are used to display a single value either
    in numerical or graphical format. *Figure 3**.9* shows all the main and basic
    output control widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The Value, Status, LED, Gauge, and Percentage widgets](img/B19752_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – The Value, Status, LED, Gauge, and Percentage widgets
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss in detail five different output widget controls
    in separate sections. First, we will start with the value widget control.
  prefs: []
  type: TYPE_NORMAL
- en: Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `integer` type variables, but I also tested it with the `time` variable,
    and it worked fine, as the `time` variable stores all information in seconds.
    You can also use the value widget control to set thresholds for sensors, automating
    the process flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following simple code snippet takes the value from analog pin #0 and stores
    it in `valueCloudVariable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we discussed the value widget control, which is used for both input and
    output purposes. Now, we will explore the status and LED control widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Status and LED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next widgets are `true` or `false`. These widgets only display the state;
    they don’t provide any option to control them, and they both work with the `bool`
    type cloud variable. Use cases for these widgets include indicating the Thing
    status (on/off) – for example, a water pump’s status in smart agriculture, or
    whether a door is open or closed in a smart home. Just assign `true`/`false` to
    the `bool` cloud variable type, which is linked to the status widget after performing
    a specific task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code demonstrates how we can change the value of `statusCloudVariable`
    to change the status/LED widgets’ appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how, after performing the `digitalWrite` operation,
    we change the value of `statusCloudVariable` according to the current condition
    to update the status widget.
  prefs: []
  type: TYPE_NORMAL
- en: Gauge and percentage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we have the `integer` or `float` cloud variable types. Comparing the
    gauge and percentage widgets, we can see a clear difference in UI/UX design –
    gauge uses a half-circle to display a sensor reading, while the percentage widget
    uses a full circle featuring icons, for which you can specify the color if a value
    goes below or above a given threshold. However, the working of both widgets is
    essentially the same. Gauge can be used to display gas-related readings, such
    as air quality, carbon dioxide levels, and temperature, while the percentage widget
    is best for displaying humidity, battery level, **Light-Dependent Resistor** (**LDR**)
    values, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I haven’t provided the sample code for the gauge and percentage widgets,
    as it’s very similar to the preceding example – just assign the values of the
    sensors to the gauge- and percentage-linked cloud variables.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As a little exercise, create an integer type variable named `MultiDimmVariable`,
    and drop a gauge, percentage, and slider widget on the dashboard. Link these three
    widgets with the same `MultiDimmVariable` cloud variable you created. Now, you
    can have a bit of fun; just change the slider position and see how the gauge and
    percentage widgets react.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed all the major output controls, which include value,
    status, gauge, percentage, and LED, step by step, and their usage and code. Now,
    we will look at maps and charts widgets, which are the most important widgets
    to display for location and time-series data.
  prefs: []
  type: TYPE_NORMAL
- en: Maps and charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next two widgets are very interesting – one is used to display maps with
    specific coordinates, and the other is used to display the `integer`/`float` type
    sensor readings in graph format. *Figure 3**.10* shows the **Map** and **Chart**
    widget controls. The map widget is used to display the location of a device using
    coordinates, and the chart widget is used to display the values in a time-series
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The Map and Chart widgets](img/B19752_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – The Map and Chart widgets
  prefs: []
  type: TYPE_NORMAL
- en: First, we will start with the map widget, where we will discuss how we can display
    the location, and then, we will explore the chart widget to display the historical
    data of a sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many use cases where we need to display the current location of an
    object on a map, which is much easier to understand visually than simple coordinate
    values. The Arduino IoT Cloud provides us with a `location` cloud variable type,
    which consists of latitude and longitude values. The object could be anything
    from a child or animal to a delivery bike, a courier truck, or even food/vegetable
    parcels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how you can assign the latitude and longitude
    values to the `location` cloud variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is used to assign a location whenever your device receives
    data from a **GPS module**. This map widget is only capable of showing one location
    at a time. If you have multiple objects for which you want to display tracking,
    then each object will need its own map widget.
  prefs: []
  type: TYPE_NORMAL
- en: Chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, we can use the gauge or percentage widgets to display the current value
    of a sensor, but what if we want to display the current value as well as historical
    data? For this, **chart** is your best option, which is used to display current
    readings alongside historical readings for better visualization and comparison.
  prefs: []
  type: TYPE_NORMAL
- en: The `integer` or `float` cloud variable types, which as discussed previously
    are appropriate to monitor temperature, humidity, air quality, and so on. Just
    link any cloud variable with the chart widget for data visualization. Other use
    cases include light levels, energy consumption, and levels of different gases
    in industry.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For quick testing, just drop the slider and chart widgets on a dashboard and
    link both of them with the same `integer` cloud variable type. After that, just
    change the value of the slider, and you can observe how charts work.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we discussed both the map and chart widget controls in detail. Now, we
    will explore messenger and sticky note controls.
  prefs: []
  type: TYPE_NORMAL
- en: Messenger and sticky notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our last two widgets are **messenger** and **sticky notes**. Both widgets are
    non-essential elements but do help you to make your dashboard interactive. *Figure
    3**.11* shows both the widget controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The Messenger and sticky note widgets](img/B19752_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – The Messenger and sticky note widgets
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, the first widget is **Messenger**, and the second widget is sticky
    notes. Both widgets will be discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Messenger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **messenger** widget works like any traditional messenger app. But the question
    arises, why would we need this widget on a dashboard? In my opinion, it’s simply
    not essential on any dashboard currently, but in the future, it could become an
    awesome widget and inspire people to develop products where you communicate textually
    with Things, just as we already have the **Amazon Echo Dot** and **Google Assistant**
    devices that users interact with verbally, where you ask questions to the device
    and it responds audibly.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, you may see many messenger applications linked to your Things,
    where you ask questions such as, *where is my child?*, and the Thing connected
    to your child will respond to you with their exact location. Alternatively, you
    could ask a question about the temperature/humidity conditions in your room, and
    the Thing would respond with the required answer.
  prefs: []
  type: TYPE_NORMAL
- en: You could also use the messenger widget to create some sort of small search
    engine for your Thing that understands some keywords and responds to users’ queries.
    Remember, the early bird catches the worm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The messenger widget works with the `string` cloud variable type. The following
    simple code snippet demonstrates how you can write to the messenger widget from
    the device end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you assign a new value to the string variable, messenger will append the
    new content to the widget. The following code is used to clear the whole widget
    at the device end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can also integrate the messenger widget with third-party tools such as **Slack**
    and **Discord**, via either an API or Zapier integration.
  prefs: []
  type: TYPE_NORMAL
- en: Sticky notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sticky note widget works just like simple Windows OS Sticky Notes. It helps
    you to write down your project progress, or you can write anything on a sticky
    note to maintain your dashboards. It helps you in a situation where you have dozens
    of dashboards and you want to add some comments about specific dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: For the latest updates and details about dashboard widget controls, please visit
    [https://docs.arduino.cc/arduino-cloud/getting-started/dashboard-widgets](https://docs.arduino.cc/arduino-cloud/getting-started/dashboard-widgets).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed both the messenger and sticky note widgets. Sticky
    notes make it easy to maintain projects and write down comments about project
    progress or maintenance, while messenger has a broader use. We also discussed
    how sensor data is related to AI. We have now completed all of our input and output
    widget controls, Now, we will dive deep into the Arduino Web Editor, where we
    will explore all the options step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Arduino Web Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arduino has also launched a web-based editor that is independent of Arduino
    IoT Cloud and the desktop IDE. It works with any board compatible with the Arduino
    IDE without needing to install boards via the board manager. The Web Editor is
    compatible with a majority of web browsers, including Chrome, Firefox, Microsoft
    Edge, and Safari. To work with the Web Editor, your machine should have the **Arduino
    Create Agent**, which acts as a bridge between the device and the Web Editor.
    All code is stored on the cloud, so there is no risk of losing code or any need
    to make backups.
  prefs: []
  type: TYPE_NORMAL
- en: 'To visit the Arduino Web Editor, go to [https://create.arduino.cc/editor](https://create.arduino.cc/editor),
    where you will see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The Arduino Web Editor](img/B19752_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – The Arduino Web Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers in the preceding screenshot correspond to the following elements
    of the Web Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the main menu of the Web Editor, where you will find all the navigation
    links, such as **Sketchbook**, **Examples**, **Libraries**, and **Monitor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This tab is a sub-menu, displaying options/content according to the current
    main menu selection. In the screenshot, this tab shows content related to the
    sketchbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This area is the coding/sketch area, where you can find all the options to work
    with code, such as code verification/uploads, board selection, and the code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This tab is the output terminal, which provides you with information regarding
    code upload status, any errors found in your code, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we discussed the Arduino Web Editor interface. Now, we will discuss **Sketchbook**,
    **Examples**, **Libraries**, **Monitor**, **References**, and **Help**, as well
    as the **Preferences** and **Features** menus in detail. We will discuss all the
    options in depth so you will get a broader overview of the Arduino Web Editor,
    allowing you to utilize its features fully during your development.
  prefs: []
  type: TYPE_NORMAL
- en: Sketchbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This menu option is responsible for sketch organization, creation, code download
    and upload, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The Arduino Web Editor sketchbook](img/B19752_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – The Arduino Web Editor sketchbook
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers in the preceding screenshot correspond to the following elements
    of the sketchbook screen:'
  prefs: []
  type: TYPE_NORMAL
- en: The **NEW SKETCH** button is used to initialize a new set of files for a new
    project. To the right of this button are two icons – the first is used to create
    a folder for project organization, and the second is used to import any existing
    Arduino IDE code/libraries into the Web Editor if required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is where you will find all of your sketches/folders, and you can also search
    your sketchbooks with the help of the search bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tick icon is used to verify the code, while the arrow icon is used to upload
    the code to the development board. From the dropdown to the right of these icons,
    you can select the development board and port. Finally, the ellipsesbutton contains
    a range of options regarding sketches, such as **Save**, **Save as**, **Rename
    Sketch**, and **Download Sketch**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This area is a playground for developers to write code for their devices. Here,
    you will find two icons to the right of the screen, the first of which is used
    to make the code editor full-screen, while the second is used for code indentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the output terminal where you can get all the information about code
    compilation progress and any errors found in your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the top features of Arduino IDE is **Examples**, which is a great resource
    for beginners, who can benefit from examples provided by library and sensor developers.
    This is presented as a separate menu in the Arduino Web Editor. *Figure 3**.14*
    shows the **Example** menu with two different tabs. The first tab shows the **BUILT
    IN** examples, while the second tab shows the **FROM** **LIBRARIES** examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – The Arduino Web Editor examples](img/B19752_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – The Arduino Web Editor examples
  prefs: []
  type: TYPE_NORMAL
- en: When you click on the **Examples** menu, the next tab will be displayed, showing
    options for examples either built-in or from libraries. All the examples are organized
    in different categories, just as in the Arduino IDE. You can also use the search
    bar to find examples from a specific library. By default, the Arduino Web Editor
    only displays development board-specific examples and libraries. The preceding
    screenshot only shows examples compatible with MKR Wi-Fi 1010, but you can click
    on the **MKR WIFI 1010** link and shift to **ALL Boards**, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries and the Library Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are thousands of libraries for the Arduino platform, developed by developers
    and sensor and module manufacturers around the world. Libraries provide vast integration
    possibilities for sensors/modules in the Arduino IDE as well as, by default, example
    code. Libraries are the main source of learning for beginners and professional
    developers. *Figure 3**.15* shows the **Libraries** menu with different options,
    such as **LIBRARY MANAGER**, which helps us to install the libraries, and the
    **DEFAULT**, **FAVORITES**, and **CUSTOM** tabs are also shown, which will be
    discussed in detail step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – The Arduino Web Editor libraries](img/B19752_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – The Arduino Web Editor libraries
  prefs: []
  type: TYPE_NORMAL
- en: In the Arduino Web Editor, we have access to a vast collection of pre-installed
    libraries, and we can mark libraries as favorites and include them in our code.
    When we open the **Libraries** menu option, we will see the aforementioned three
    main tabs – **DEFAULT**, **FAVORITES**, and **CUSTOM**. The **DEFAULT** tab displays
    all the libraries developed by the Arduino team and verified partners. The **FAVORITES**
    tab contains the libraries that you have favorited in the Library Manager. If
    you can’t find a library specific to your work, then you can import your own library
    into the Arduino Web Editor by clicking on the **CUSTOM** tab.
  prefs: []
  type: TYPE_NORMAL
- en: The Library Manager contains a complete list of libraries from all around the
    world. To add a library to your project that you can’t find in the **DEFAULT**
    tab, just click on **LIBRARY MANAGER**, and a new popup will appear, where you
    can search for a library by its name or company name. When found, mark it as a
    favorite by clicking on the star icon.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor AKA the Serial Monitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Serial Monitor** plays a vital role in the verification of **process execution**,
    **sensor testing**, and **code debugging**. It works similarly to a console in
    a web browser, where developers print messages for process verification according
    to their requirements. In the Arduino Web Editor, it has been renamed **Monitor**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The Arduino Web Editor | Monitor](img/B19752_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – The Arduino Web Editor | Monitor
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the **Monitor** link will only activate the Monitor when there is
    a board connected to the system. Make sure your Arduino Create Agent is running
    in the background as well. At the top of the **Monitor** screen, you will see
    the name of the development board and the port name/number to which it’s connected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the `Serial.begin()` method. Developers mostly use 9,600 baud rates
    for serial communication. The large text area in the bottom half of the Monitor
    shows all communication between the device and the developer. By default, **AUTOSCROLL**
    is enabled in this window, so new messages will automatically be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Reference, help, and preferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Delay` function; just find and click on the `Delay()` method, and it will
    show you a description, with example syntax and code for better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: The **Help** menu provides lots of new information about product updates and
    much more. Information is divided into three tabs, **INFO**, **TUTORIALS**, and
    **GLOSSARY**. The **INFO** tab provides all the latest updates regarding versions,
    compatibility, and bug fixes. The **TUTORIALS** tab contains links to small projects
    that help beginners to learn new stuff. **GLOSSARY** is just like a glossary in
    a book, but here, you will get a specific list related to Arduino, electronics,
    sensors, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we arrive at the **Preferences** menu, from where we can modify the
    Web Editor’s theme and font size, show/hide the output panel, and set code to
    auto-save or be manually saved.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino IoT Web Editor features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Arduino IDE, we don’t have any restrictions regarding sketch creation,
    compilation, or storage, but in the Arduino Web Editor, we do encounter some restrictions.
    This is because, with Arduino IDE on desktop machines, we use our own resources,
    but everything involved with the Web Editor is hosted on the cloud. On the cloud,
    everything has to be paid for, including storage, processor, and memory usage
    for code verification and compilation.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, the Arduino Web Editor has some restrictions and limitations
    on storage size, sketches, and compilations. Arduino has different resource allowances
    for different types of subscribers, which should be compared with other plans
    before purchase. Visit [https://cloud.arduino.cc/plans](https://cloud.arduino.cc/plans)
    for complete details and a comparison of the plans.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – The Arduino Web Editor limits and usage](img/B19752_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – The Arduino Web Editor limits and usage
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot displays stats regarding the Web Editor features. Firstly,
    we can see how much storage space has been used from the total made available
    as part of the subscription plan. I have 1,000 MB of storage in total with my
    Maker Pro plan. The screenshot also shows how many sketches can be created, and
    finally, how many compilations are allowed. In my case, I have unlimited, but
    the Free plan only had 100 MB of space allowed for sketch storage and limits of
    25 compilations per day.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The Arduino Web Editor features are subject to change over time, so please
    visit the official page for up-to-date information: [https://cloud.arduino.cc/plans](https://cloud.arduino.cc/plans).'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we successfully discussed the different options in the new Arduino Web
    Editor in depth, which will help you to use the Editor effectively and efficiently
    in your development projects, helping you to boost your productivity. The following
    section, *Assignments*, cover different questions for you, which will help to
    test out what you have learned in this chapter and through internet searches,
    helping you to utilize your new skills effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Assignments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is longer in length than the previous ones, as we want to give
    you an in-depth overview of Arduino IoT Cloud and its main pillars, which include
    Things, devices, dashboards, integrations and templates, progressing to further
    chapters. In this chapter, we have discussed dashboards, input and output widget
    controls, as well as the Arduino Web Editor in detail. To consolidate what you
    have learned in this chapter, we have created three different assignments for
    you. These assignments will help you to understand the core concepts necessary
    to proceed with the book, as well as in your professional projects.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to attempt all the assignments given ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASNA Group is a leading ISO-certified salt supplier organization in Pakistan.
    The organization processes salt according to international standards, but they
    are facing issues in warehouse monitoring, where they want to maintain the temperature/humidity
    in line with the standards, to avoid issues with the finished product. Right now,
    they have five warehouses to monitor. They want multiple views for data monitoring
    and analysis. You need to keep the following questions in mind while developing
    a solution for ASNA Group:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, identify what type of industrial-grade sensors/development boards are
    required for this monitoring scenario.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there any calibration required for the sensors? If so, how will you calibrate
    the sensors? If not, provide a reason why it’s not mandatory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of widgets are required to visualize the information on a dashboard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How you could visualize readings from five warehouses on one dashboard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of widgets will be used on the dashboard to allow users to analyze
    readings covering a long period of time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By what means will you give the company access to the dashboard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assignment 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imzlab Technologies Private Limited is a leading smart agriculture solution
    provider. The company has deployed custom-designed sensors in the field, using
    ESP32 and the Arduino IoT Cloud, to measure soil moisture, soil temperature, and
    outdoor temperature/humidity. On the dashboard, they have different widgets for
    data visualization. They now have a new requirement from a customer to integrate
    a water pump control and display its status history (on/off). The customer also
    requires that on Monday and Thursday, the water pump will run from 5:00 p.m. to
    7:00 p.m., and on Sunday, from 4:00 a.m. to 6:00 a.m., in the GMT+5 time zone.
    On other days, the pump status will be controlled manually. You need to keep the
    following questions in mind while developing a solution for Imzlab Technologies
    Private Limited:'
  prefs: []
  type: TYPE_NORMAL
- en: What type of control widgets are required to display and control the water pump
    status?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you provide a solution for automatic pump control on specific days and
    at specific times?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to visualize the water pump on/off status history using charts?
    If so, how? If it’s not possible, provide an alternative solution to meet the
    customer’s requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assignment 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A group of researchers at Imzlab Technologies Private Limited is working on
    a monitoring system to monitor carbon dioxide levels. They are using MKR 1010
    and the Arduino IoT Cloud, but they are trying to use a custom sensor developed
    by Tingstack LLC. In the Arduino Web Editor, there is no library for this sensor,
    but Tingstack LLC has developed an in-house library for the Arduino platform.
    The researchers also want to share their code with the Tingstack LLC team for
    review.
  prefs: []
  type: TYPE_NORMAL
- en: Identify the problems from the preceding paragraph, and write down their solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was just like understanding the ingredients and kitchen tools we
    have before we start cooking. Firstly, we learned about how the Arduino IoT Cloud
    components work, including Things, devices, dashboards, integrations, and templates.
    Then, we studied all the input/output widget controls to get a proper idea of
    their potential usage, including some example code and the cloud variable types.
    In the following section, we examined what the Arduino Web Editor is and how its
    different features work, including examples, libraries, and the Serial Monitor.
    You should now have a good understanding of all the different ingredients of the
    Arduino IoT Cloud and the Web Editor and how to employ them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was most important before starting the next chapters, as it gives
    you an in-depth overview of all the main pillars of the Arduino IoT Cloud and
    how they work in real time, which will help you to understand how the Arduino
    IoT Cloud works. Arduino dashboard widgets are also very important to us, as we
    will use different widgets in different projects throughout the book, so giving
    you an overview here has prepared you for upcoming chapters, helping you to understand
    what types of things are mandatory for professional projects and what type of
    controls make your project more robust and professional.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will start work on our first project, where we
    will build an air-quality monitoring system from scratch to deployment. You will
    learn why air-quality monitoring is necessary and what types of development boards/sensors
    are required. We will also use a **Printed Circuit Board** (**PCB**) for proper
    deployment, which will be explained in depth. After a section on the necessary
    hardware, we will set up Things, cloud variables, devices, and network configurations
    and coding for a device, as well as a dashboard for proper data visualization.
    So, gear up for the upcoming chapter, which will be fun for all of you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Getting Hands-On with Different Communication Technologies'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second part of the book describes the different communication technologies
    involved in IoT projects and provides four different practical projects to demonstrate
    their usage and how third-party components can be adopted in combination with
    the Arduino IoT Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B19752_04.xhtml#_idTextAnchor085), *Project #1 – A Smarter Setup
    for Sensing the Environment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19752_05.xhtml#_idTextAnchor101), *Project #2 – Creating a Portable
    Thing Tracker Using MKR GSM 1400*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19752_06.xhtml#_idTextAnchor120), *Project #3 – A Remote Alarming
    Application with LoRaWAN*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
