- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to Call C++ from Lua
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three chapters, we focused on learning how to call Lua from
    C++. In this chapter, we will start to learn how to call C++ from Lua. This is
    important for your applications because although Lua scripts can extend your C++
    applications, they can also benefit from the functions provided by your native
    C++ code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This also means we will learn more concepts and piece different things together
    to make it work. Although the chapters are laid out in a way that they extend
    the previous chapter in a seamless flow, you may need a different pace to absorb
    the new concepts. Do read the sections more times if you need practice with coding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: How to register C++ functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to override Lua library functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to register C++ modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the technical requirements for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: You can access the source code for this chapter at [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the learnings from the last chapter, you should now be confident in
    adding code to our Lua executor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will introduce many new concepts and Lua library APIs. You can
    cross-check the Lua reference manual online to reinforce the learning: [https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: How to register C++ functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lua is written in C, so it cannot access your C++ classes directly. The only
    way to call C++ code from Lua is to make it call C++ functions – that is, plain
    C functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: How to declare C++ functions for Lua
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To register a function to Lua, it must conform to the following prototype:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function receives only one argument, which is a Lua state. It needs to return
    an integer value indicating how many return values it produces. The Lua state
    is private to the function call, and its stack holds the arguments passed from
    the Lua code when calling the C++ function. The C++ function needs to push its
    return values onto the stack.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: We will first implement a simple function and export it to Lua. Then, we’ll
    see more complex examples to understand more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Implementing your first C++ function for Lua
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us add a simple but useful capability to our Lua executor. It will provide
    a function to check its version code so that the Lua code it executes can query
    it. In `LuaExecutor.cc`, right below the `#include` directives, add the following
    function implementation that conforms to `lua_CFunction`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The function pushes a `LuaExecutor::versionCode` integer constant to its private
    stack and returns `1` to indicate that it returns one value. We can define this
    constant in `LuaExecutor.h` as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will use the value `6` for *Chapter 6*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the function is inside an anonymous namespace. This
    is to make sure that it cannot be accessed outside the file of `LuaExecutor.cc`.
    This also helps with logical code grouping.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us make this function available to Lua.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: How to register C++ functions to Lua
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few ways to register C++ functions to Lua. We will look at the
    simplest way here to register a C++ function in the Lua global table. Later in
    this chapter when learning C++ modules, we will learn a more proper way to register
    C++ functions in their own table. You already know how to do this from *Chapter
    3*. I only need to point it out with the following code, which you should add
    to the same anonymous namespace you have just written:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Yes—we simply need to set it as a Lua global variable! We use `lua_pushcfunction`
    to push the `lua_CFunction` type onto the stack. Then, we assign it to a global
    variable named `host_version`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Using a global variable for the host executor version sounds very reasonable.
    But you should not abuse Lua global variables by using them too much. Now, let
    us try it out.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to modify three places to test our progress so far. You can start your
    work with the `begin` folder from the source code of this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Call `registerHostFunctions` from the constructor of our Lua executor, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This registers our function to Lua.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the content of `script.lua` as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This calls our C++ function from Lua and prints out the result.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the content of `main.cpp` with the following test code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This resets the test code to simply create a Lua executor and runs `scripts.lua`.
    Run the project, and if you have done everything correctly, you should see the
    following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Congratulations! You have called your first C++ function from Lua code. Based
    on this learning, let us find out how to override Lua library functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: How to override Lua library functions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why would you want to override Lua library functions? First, it helps to learn
    more about calling C++ functions from Lua in a progressive way, before moving
    on to C++ modules. Second, but more importantly, it is a frequent requirement
    for real-life projects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are working on a game where assets are packed inside a private archive
    and your Lua scripts need to access them. Overriding the Lua `io` and `file` libraries
    can provide a seamless experience for your fellow Lua developers and enforce security
    at the same time. You can make sure Lua scripts can only access assets you want
    them to, but nothing else on the host filesystem. This is even more important
    when your users can change the Lua scripts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Let us implement a more trivial case. We use the Lua `print` function to output
    debug information. We want to merge the Lua debug output with C++ output so that
    we get all our logs in the same place ordered by the time they are printed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing the Lua print function
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the Lua `print` function takes a variable number of arguments, we need
    to take this into consideration in our implementation. In `LuaExecutor.cc`, below
    the namespace from the previous section, add *another* namespace as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `luaPrintOverride` C++ function would eventually get called when you invoke
    the `print` function in Lua. It takes `lua_State` as a single argument, whose
    associated Lua stack is used to pass the real arguments from the Lua call site.
    To understand what is happening, see the following diagram:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Overriding the Lua print function](img/B20927_06_01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Overriding the Lua print function
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The Lua `print` function will push its arguments onto the private Lua stack
    for the call. The C++ function first checks the number of arguments the Lua call
    site has passed with `lua_gettop`. Then, it prints out `"[Lua]"`to indicate that
    the print comes from Lua instead of C++. Next, it loops through each argument
    and prints them out, separated by a space. Finally, it returns `0` to tell the
    Lua library that it has no value to return to the call site.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: To reinforce
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The Lua state and the Lua stack for each `lua_CFunction` call are private to
    the call. So, everything in the stack is made up of the arguments passed from
    the Lua call site. You do not need to remove them from the stack before pushing
    your return values because you are already telling the Lua library how many values
    are pushed onto the stack as the C++ function return value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us see how we can override the Lua `print` function with the C++ version
    we just implemented.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the Lua print function
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will first look at the code and then delve into our explanation of
    it. In the same anonymous namespace, add the following function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The process of overriding library functions includes the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Getting the library table
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reassigning the functions of interest to your new implementations
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each line of the code is doing the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: It defines an array of `luaL_Reg`, which is a structure representing a name
    and `lua_CFunction` pair. We set the name as `"print"`, the same as the function
    name we want to override. We set the function as our new implementation. The last
    entry in the array must be `{NULL, NULL}` to mark the end of the definition.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gets the `_G` Lua table onto the stack, because the `print` function is a
    global variable and the `_G` table holds all global variables.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets our list of functions from *step 1* to the `_G` table with `luaL_setfuncs`.
    You can ignore the last parameter for now; we will learn about it in the next
    section.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It pops the `_G` table from the stack to maintain a balanced stack.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, `luaL_Reg` is defined in the Lua library as follows:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Overriding the Lua library functions is really as simple as reassigning some
    table keys to different values! Now, let us see if it works.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the previous section, call `overrideLuaFunctions` from the constructor
    of our Lua executor, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You do not need to change anything else. With the same `main.cpp` and `script.lua`
    files, run the project. If you have followed everything correctly, you should
    see the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is now a `[Lua]` prefix in the output, proving it is printed from our
    C++ override, not the Lua library function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us learn about C++ modules, which is the preferred way to add your
    C++ functionalities to Lua.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: How to register C++ modules
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will export a C++ class instance to Lua. You probably have
    used or even implemented Lua modules before, the ones that the Lua interpreter
    can find and load automatically and return via Lua’s `require` function. Here,
    the focus is integrating Lua into C++, and in such use cases, things are initiated
    from a C++ executor to benefit from the rest of your C++ application. So, there
    is a difference if you have used standalone Lua modules before.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented a Lua class called `Destinations` to
    keep track of places we want to go. Let us reimplement it in C++ so that we can
    export it to Lua.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a C++ class
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create two source files, `Destinations.h` and `Destinations.cc`. Remember to
    add `Destinations.cc` to the `Makefile`. Write the header file as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We use a `map` variable to keep a list of places and whether we have visited
    them and have a `name` member variable to identify the instance. The member functions
    are named and work the same as the Lua version, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '`wish` adds a list of places to the wish list as `unvisited`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`went` marks a list of places as `visited`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listVisited` returns visited places'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listUnvisited` returns unvisited places'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let us implement the member functions in `Destinations.cc`. They are plain
    C++ functions without using any Lua features. So, we will just list the code without
    much explanation. First, let us implement the constructor:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This initializes the `wishlist` as an empty map.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, write the `wish` function as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, implement the `went` function as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `wish` function and the `went` function are quite similar and mark places
    as visited or unvisited.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, implement the query functions. Write the `listVisited` function as
    follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, write the `listUnvisited` function as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With a C++ class ready, our next task is to export it to Lua.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: What to export to Lua
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exporting a C++ class to Lua is really exporting its instances to Lua. Sometimes,
    only one instance is exported and the C++ class works as a utility library, similar
    to the Lua `string` library. Sometimes, many instances are exported and Lua extends
    C++’s **object-oriented** **programming** (**OOP**).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that no matter how many instances you want to export,
    the process is the same. When overriding Lua library functions, we retrieve an
    existing table and set some of its functions to our implementation. To export
    a C++ class instance, similarly, we need to do the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Create a new table
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the functions we want to export to the table
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you recall that we can only export functions of the `lua_CFunction` prototype
    to Lua, you will clearly see that we cannot export our public member functions
    to Lua directly. We need some wrapper functions. Let us first write some stubs.
    Below the `#include` directives in `Destinations.cc`, add the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We defined four wrapper functions of the `lua_CFunction` prototype and a list
    of `luaL_Reg` instances. We are using `vector` instead of `array` because in C++
    we prefer vectors unless we have to use an array.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us design a reusable mechanism to export our wrappers to Lua.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Designing a reusable exporting mechanism
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways to do this. We choose a way to work with our Lua executor
    and let it register our C++ modules. First, let us define an abstract class to
    represent C++ modules. Create a new file named `LuaModule.h` and write its content
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `LuaModule` abstract class defines two abstract methods to provide data
    needed to register a C++ module to Lua. `luaName` returns a name for the module
    instance; we will use it as the Lua table name. `luaRegs` returns a list of functions
    to be exported along with their names in Lua.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us extend our `Destinations` C++ class to conform to this protocol. Change
    its declaration as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After this, add the following implementation to `Destinations.cc`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code simply returns the instance name as `luaName` and the `REGS` we just
    defined for our stubs as `luaRegs`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the time to finally register our C++ class to Lua. In `LuaExecutor.h`,
    add a function declaration as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `registerModule` function registers an instance of `LuaModule` to the Lua
    state that the executor holds.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, implement it in `LuaExecutor.cc`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This needs some explanation. Let us explore what each line of the code here
    is doing in sequence:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: It creates a table with `lua_createtable`. This library function will push the
    table onto the stack. The second parameter hints at how many elements in the table
    will be used as a sequence. We have none, so we pass `0`. The third parameter
    hints at how many elements in the table will be used as a map. All our functions
    are used this way, so we pass the count of our vector minus the ending marker.
    The hints help with memory allocation in Lua, as Lua will be responsible for creating
    a properly sized table to avoid unnecessary reallocations to increase the capacity
    of the table later.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets our functions to the table with `luaL_setfuncs`. This works exactly
    the same as when we overrode Lua library functions. Ignore the third parameter
    for now as well. `module.luaRegs().data()` returns our function list as an array
    instead of a vector. `std::vector::data` is a C++ feature.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It assigns the table just created to a global variable using the name returned
    from `module.luaName()`. From now on, our C++ module can be accessed from this
    table.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exporting a C++ module to Lua may sound heavy and glorious. But there is actually
    not much gluing code involved. Compare what we have just done with overriding
    Lua library functions. Take a moment, then we will test our mechanism to see if
    it works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Testing our mechanism
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a few lines of code to `main.cpp` so that it looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We create an instance of the `Destinations` class and give it the name `"destinations"`.
    Then, we register it with our Lua executor.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to `script.lua`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is doing the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: It adds London, Paris, and Amsterdam to the wish list.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It marks Paris as visited.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints the visited cities.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints the unvisited cities.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the project, and if you have followed all the steps correctly, you should
    see the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There should be no errors, and since our wrapper functions are only stubs, it
    will not return anything useful. Hence, this is how we laid out the architectural
    foundation. Next, we will focus our efforts on making it work at the ground level.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the C++ class instance
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our wrapper functions are of type `lua_CFunction`. They are essentially C++
    static methods not associated with any class. How can we access the correct class
    instance? We must do some bookkeeping.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Lua provides a mechanism to keep data for the registered C++ functions.
    It is called an **upvalue**. Upvalues can only be accessed by the associated function
    in C/C++ code and are shared across different function calls. We can save the
    pointer to the class instance in an upvalue.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Why is it called an upvalue? At this stage, it is easier to understand when
    not explained, in the same spirit as why a variable is called a variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: From the previous description, an upvalue behaves like a C++ static variable
    in the function scope. Then, why do we use an upvalue instead of a static variable?
    Because an upvalue is associated with a C++ function in the Lua library. This
    way, we can use the same C++ function with different upvalues.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Which Lua data type can be used to save a C++ pointer? We can use **userdata**.
    This type is used to store arbitrary C/C++ data. Especially, for our case, we
    need to use **light userdata**, whose purpose is to store a C/C++ pointer. It
    is a perfect match for us.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, we need to save the class instance’s `this` pointer as *light
    userdata* in an *upvalue* for the `lua_CFunction` implementation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have involved two new Lua concepts. They are exclusively used to work
    with C/C++ code, so chances are that you are not very familiar with them from
    Lua programming. Let us see the code in action to help with the understanding.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: How to provide upvalues
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will only look at the case for registering C++ modules. So far, we have ignored
    the third parameter to `luaL_setfuncs` and always passed `0`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: What does this third parameter mean? It is the count for the upvalues that will
    be available to all functions in the list provided in the second parameter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: How do you provide upvalues? Of course—you push them onto the stack!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us rewrite the function to register C++ modules as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are only two changes. First, we want another function yet to be implemented
    in `LuaModule` to push upvalues onto the stack and return to us how many upvalues
    have been pushed. Then, we pass the upvalue count as the third parameter to `luaL_setfuncs`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to add `pushLuaUpvalues` to `LuaModule.h`, like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have provided a default implementation that pushes `this` as an upvalue.
    In derived classes, they can override this function and push more upvalues.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us see how we can access this upvalue.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: How to access upvalues
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lua upvalues are accessed as if they were in the stack, while they are not really
    in the stack. So, a magic stack index, `LUA_REGISTRYINDEX`, is used to mark the
    start of the upvalue pseudo-region. Lua provides a `lua_upvalueindex` macro to
    locate the indices of your upvalues, so you do not really need to deal with this
    magic number.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can access our C++ class instance stored as an upvalue. In `Destinations.cc`,
    add the following function to the anonymous namespace:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can use this helper function to get a pointer to the instance. It uses `lua_touserdata`
    to get our light userdata from the stack with the pseudo-index. This helper will
    be called from the stubs we registered.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: To reinforce
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The Lua state and stack passed to a `lua_CFunction` function are private to
    each call to that function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have figured out how to access the class instance, we can complete
    our stubs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Completing our stubs
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write `luaWish` as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It first gets the class instance with the `getObj` helper function we just implemented.
    Then, it puts all arguments from the Lua call site into a vector. Finally, it
    calls the real object method, `obj->wish`. This is what a wrapper does – it routes
    the call to the real object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `luaWent` is similar, as we can see here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The only difference is that it calls `obj->went` instead.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, implement the query functions as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These functions use the object functions to get a list of places and then push
    the list onto the stack to return the results to the Lua call site.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have implemented everything, and we can test it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do not need to modify any test code because we have already used the functions
    to test our stubs. Now, recompile and run the project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the Lua test code looks like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you have done everything correctly, you should see the following output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Congratulations on making it work!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is quite a change of mindset from the previous chapters. Take a
    moment to reflect if you need to.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to call C++ code from Lua. We first learned
    how to register a simple C++ function to Lua. All registered functions must conform
    to `lua_CFunction`. Then, we found out how to override Lua library functions.
    Finally, we implemented a C++ class and exported it to Lua. We also came across
    the concepts of *upvalue* and *light userdata* along the way.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 Lua 中调用 C++ 代码。我们首先学习了如何将一个简单的 C++ 函数注册到 Lua 中。所有注册的函数都必须符合 `lua_CFunction`。然后，我们发现了如何覆盖
    Lua 库函数。最后，我们实现了一个 C++ 类并将其导出到 Lua。在过程中，我们还遇到了 *upvalue* 和 *light userdata* 的概念。
- en: In the next chapter, we will continue our journey with more details on user-defined
    data in C++ and more data-exchanging mechanisms.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的旅程，更详细地介绍 C++ 中的用户定义数据以及更多的数据交换机制。
- en: Exercises
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In the `Destinations` class, we only used one upvalue. Add another upvalue and
    play around with it. Which upvalue is at which pseudo-index?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Destinations` 类中，我们只使用了其中一个 upvalue。添加另一个 upvalue 并对其进行实验。哪个 upvalue 对应哪个伪索引？
- en: Try to modify the second upvalue in a function and see if the value is persisted
    the next time the function is called. How about when it is accessed in another
    function?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试修改函数中的第二个 upvalue，看看下次函数被调用时值是否被保留。当它在另一个函数中被访问时又会怎样呢？
- en: In `LuaType.hpp`, add `LuaType::lightuserdata` and implement a structure for
    it, named `LuaLightUserData`. Support this case in the executor and helper functions.
    You do not need to support this type when popping values from the Lua stack.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LuaType.hpp` 中，添加 `LuaType::lightuserdata` 并为其实现一个结构体，命名为 `LuaLightUserData`。在执行器和辅助函数中支持这个情况。当从
    Lua 栈中弹出值时，你不需要支持这个类型。
