- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to Call C++ from Lua
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three chapters, we focused on learning how to call Lua from
    C++. In this chapter, we will start to learn how to call C++ from Lua. This is
    important for your applications because although Lua scripts can extend your C++
    applications, they can also benefit from the functions provided by your native
    C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: This also means we will learn more concepts and piece different things together
    to make it work. Although the chapters are laid out in a way that they extend
    the previous chapter in a seamless flow, you may need a different pace to absorb
    the new concepts. Do read the sections more times if you need practice with coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to register C++ functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to override Lua library functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to register C++ modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You can access the source code for this chapter at [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the learnings from the last chapter, you should now be confident in
    adding code to our Lua executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will introduce many new concepts and Lua library APIs. You can
    cross-check the Lua reference manual online to reinforce the learning: [https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/).'
  prefs: []
  type: TYPE_NORMAL
- en: How to register C++ functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lua is written in C, so it cannot access your C++ classes directly. The only
    way to call C++ code from Lua is to make it call C++ functions – that is, plain
    C functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to declare C++ functions for Lua
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To register a function to Lua, it must conform to the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The function receives only one argument, which is a Lua state. It needs to return
    an integer value indicating how many return values it produces. The Lua state
    is private to the function call, and its stack holds the arguments passed from
    the Lua code when calling the C++ function. The C++ function needs to push its
    return values onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: We will first implement a simple function and export it to Lua. Then, we’ll
    see more complex examples to understand more.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing your first C++ function for Lua
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us add a simple but useful capability to our Lua executor. It will provide
    a function to check its version code so that the Lua code it executes can query
    it. In `LuaExecutor.cc`, right below the `#include` directives, add the following
    function implementation that conforms to `lua_CFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The function pushes a `LuaExecutor::versionCode` integer constant to its private
    stack and returns `1` to indicate that it returns one value. We can define this
    constant in `LuaExecutor.h` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will use the value `6` for *Chapter 6*.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the function is inside an anonymous namespace. This
    is to make sure that it cannot be accessed outside the file of `LuaExecutor.cc`.
    This also helps with logical code grouping.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us make this function available to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: How to register C++ functions to Lua
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few ways to register C++ functions to Lua. We will look at the
    simplest way here to register a C++ function in the Lua global table. Later in
    this chapter when learning C++ modules, we will learn a more proper way to register
    C++ functions in their own table. You already know how to do this from *Chapter
    3*. I only need to point it out with the following code, which you should add
    to the same anonymous namespace you have just written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Yes—we simply need to set it as a Lua global variable! We use `lua_pushcfunction`
    to push the `lua_CFunction` type onto the stack. Then, we assign it to a global
    variable named `host_version`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a global variable for the host executor version sounds very reasonable.
    But you should not abuse Lua global variables by using them too much. Now, let
    us try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to modify three places to test our progress so far. You can start your
    work with the `begin` folder from the source code of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call `registerHostFunctions` from the constructor of our Lua executor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This registers our function to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the content of `script.lua` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This calls our C++ function from Lua and prints out the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the content of `main.cpp` with the following test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This resets the test code to simply create a Lua executor and runs `scripts.lua`.
    Run the project, and if you have done everything correctly, you should see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have called your first C++ function from Lua code. Based
    on this learning, let us find out how to override Lua library functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to override Lua library functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why would you want to override Lua library functions? First, it helps to learn
    more about calling C++ functions from Lua in a progressive way, before moving
    on to C++ modules. Second, but more importantly, it is a frequent requirement
    for real-life projects.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are working on a game where assets are packed inside a private archive
    and your Lua scripts need to access them. Overriding the Lua `io` and `file` libraries
    can provide a seamless experience for your fellow Lua developers and enforce security
    at the same time. You can make sure Lua scripts can only access assets you want
    them to, but nothing else on the host filesystem. This is even more important
    when your users can change the Lua scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Let us implement a more trivial case. We use the Lua `print` function to output
    debug information. We want to merge the Lua debug output with C++ output so that
    we get all our logs in the same place ordered by the time they are printed.
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing the Lua print function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the Lua `print` function takes a variable number of arguments, we need
    to take this into consideration in our implementation. In `LuaExecutor.cc`, below
    the namespace from the previous section, add *another* namespace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `luaPrintOverride` C++ function would eventually get called when you invoke
    the `print` function in Lua. It takes `lua_State` as a single argument, whose
    associated Lua stack is used to pass the real arguments from the Lua call site.
    To understand what is happening, see the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Overriding the Lua print function](img/B20927_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Overriding the Lua print function
  prefs: []
  type: TYPE_NORMAL
- en: The Lua `print` function will push its arguments onto the private Lua stack
    for the call. The C++ function first checks the number of arguments the Lua call
    site has passed with `lua_gettop`. Then, it prints out `"[Lua]"`to indicate that
    the print comes from Lua instead of C++. Next, it loops through each argument
    and prints them out, separated by a space. Finally, it returns `0` to tell the
    Lua library that it has no value to return to the call site.
  prefs: []
  type: TYPE_NORMAL
- en: To reinforce
  prefs: []
  type: TYPE_NORMAL
- en: The Lua state and the Lua stack for each `lua_CFunction` call are private to
    the call. So, everything in the stack is made up of the arguments passed from
    the Lua call site. You do not need to remove them from the stack before pushing
    your return values because you are already telling the Lua library how many values
    are pushed onto the stack as the C++ function return value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us see how we can override the Lua `print` function with the C++ version
    we just implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the Lua print function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will first look at the code and then delve into our explanation of
    it. In the same anonymous namespace, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of overriding library functions includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the library table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reassigning the functions of interest to your new implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each line of the code is doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines an array of `luaL_Reg`, which is a structure representing a name
    and `lua_CFunction` pair. We set the name as `"print"`, the same as the function
    name we want to override. We set the function as our new implementation. The last
    entry in the array must be `{NULL, NULL}` to mark the end of the definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gets the `_G` Lua table onto the stack, because the `print` function is a
    global variable and the `_G` table holds all global variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets our list of functions from *step 1* to the `_G` table with `luaL_setfuncs`.
    You can ignore the last parameter for now; we will learn about it in the next
    section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It pops the `_G` table from the stack to maintain a balanced stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, `luaL_Reg` is defined in the Lua library as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Overriding the Lua library functions is really as simple as reassigning some
    table keys to different values! Now, let us see if it works.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the previous section, call `overrideLuaFunctions` from the constructor
    of our Lua executor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You do not need to change anything else. With the same `main.cpp` and `script.lua`
    files, run the project. If you have followed everything correctly, you should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There is now a `[Lua]` prefix in the output, proving it is printed from our
    C++ override, not the Lua library function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us learn about C++ modules, which is the preferred way to add your
    C++ functionalities to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: How to register C++ modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will export a C++ class instance to Lua. You probably have
    used or even implemented Lua modules before, the ones that the Lua interpreter
    can find and load automatically and return via Lua’s `require` function. Here,
    the focus is integrating Lua into C++, and in such use cases, things are initiated
    from a C++ executor to benefit from the rest of your C++ application. So, there
    is a difference if you have used standalone Lua modules before.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented a Lua class called `Destinations` to
    keep track of places we want to go. Let us reimplement it in C++ so that we can
    export it to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a C++ class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create two source files, `Destinations.h` and `Destinations.cc`. Remember to
    add `Destinations.cc` to the `Makefile`. Write the header file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a `map` variable to keep a list of places and whether we have visited
    them and have a `name` member variable to identify the instance. The member functions
    are named and work the same as the Lua version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wish` adds a list of places to the wish list as `unvisited`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`went` marks a list of places as `visited`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listVisited` returns visited places'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listUnvisited` returns unvisited places'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let us implement the member functions in `Destinations.cc`. They are plain
    C++ functions without using any Lua features. So, we will just list the code without
    much explanation. First, let us implement the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This initializes the `wishlist` as an empty map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, write the `wish` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the `went` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `wish` function and the `went` function are quite similar and mark places
    as visited or unvisited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, implement the query functions. Write the `listVisited` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write the `listUnvisited` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With a C++ class ready, our next task is to export it to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: What to export to Lua
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exporting a C++ class to Lua is really exporting its instances to Lua. Sometimes,
    only one instance is exported and the C++ class works as a utility library, similar
    to the Lua `string` library. Sometimes, many instances are exported and Lua extends
    C++’s **object-oriented** **programming** (**OOP**).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that no matter how many instances you want to export,
    the process is the same. When overriding Lua library functions, we retrieve an
    existing table and set some of its functions to our implementation. To export
    a C++ class instance, similarly, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the functions we want to export to the table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you recall that we can only export functions of the `lua_CFunction` prototype
    to Lua, you will clearly see that we cannot export our public member functions
    to Lua directly. We need some wrapper functions. Let us first write some stubs.
    Below the `#include` directives in `Destinations.cc`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We defined four wrapper functions of the `lua_CFunction` prototype and a list
    of `luaL_Reg` instances. We are using `vector` instead of `array` because in C++
    we prefer vectors unless we have to use an array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us design a reusable mechanism to export our wrappers to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a reusable exporting mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways to do this. We choose a way to work with our Lua executor
    and let it register our C++ modules. First, let us define an abstract class to
    represent C++ modules. Create a new file named `LuaModule.h` and write its content
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `LuaModule` abstract class defines two abstract methods to provide data
    needed to register a C++ module to Lua. `luaName` returns a name for the module
    instance; we will use it as the Lua table name. `luaRegs` returns a list of functions
    to be exported along with their names in Lua.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us extend our `Destinations` C++ class to conform to this protocol. Change
    its declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, add the following implementation to `Destinations.cc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code simply returns the instance name as `luaName` and the `REGS` we just
    defined for our stubs as `luaRegs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the time to finally register our C++ class to Lua. In `LuaExecutor.h`,
    add a function declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `registerModule` function registers an instance of `LuaModule` to the Lua
    state that the executor holds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, implement it in `LuaExecutor.cc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This needs some explanation. Let us explore what each line of the code here
    is doing in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a table with `lua_createtable`. This library function will push the
    table onto the stack. The second parameter hints at how many elements in the table
    will be used as a sequence. We have none, so we pass `0`. The third parameter
    hints at how many elements in the table will be used as a map. All our functions
    are used this way, so we pass the count of our vector minus the ending marker.
    The hints help with memory allocation in Lua, as Lua will be responsible for creating
    a properly sized table to avoid unnecessary reallocations to increase the capacity
    of the table later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets our functions to the table with `luaL_setfuncs`. This works exactly
    the same as when we overrode Lua library functions. Ignore the third parameter
    for now as well. `module.luaRegs().data()` returns our function list as an array
    instead of a vector. `std::vector::data` is a C++ feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It assigns the table just created to a global variable using the name returned
    from `module.luaName()`. From now on, our C++ module can be accessed from this
    table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exporting a C++ module to Lua may sound heavy and glorious. But there is actually
    not much gluing code involved. Compare what we have just done with overriding
    Lua library functions. Take a moment, then we will test our mechanism to see if
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a few lines of code to `main.cpp` so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of the `Destinations` class and give it the name `"destinations"`.
    Then, we register it with our Lua executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to `script.lua`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It adds London, Paris, and Amsterdam to the wish list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It marks Paris as visited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints the visited cities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints the unvisited cities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the project, and if you have followed all the steps correctly, you should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There should be no errors, and since our wrapper functions are only stubs, it
    will not return anything useful. Hence, this is how we laid out the architectural
    foundation. Next, we will focus our efforts on making it work at the ground level.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the C++ class instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our wrapper functions are of type `lua_CFunction`. They are essentially C++
    static methods not associated with any class. How can we access the correct class
    instance? We must do some bookkeeping.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Lua provides a mechanism to keep data for the registered C++ functions.
    It is called an **upvalue**. Upvalues can only be accessed by the associated function
    in C/C++ code and are shared across different function calls. We can save the
    pointer to the class instance in an upvalue.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it called an upvalue? At this stage, it is easier to understand when
    not explained, in the same spirit as why a variable is called a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed?
  prefs: []
  type: TYPE_NORMAL
- en: From the previous description, an upvalue behaves like a C++ static variable
    in the function scope. Then, why do we use an upvalue instead of a static variable?
    Because an upvalue is associated with a C++ function in the Lua library. This
    way, we can use the same C++ function with different upvalues.
  prefs: []
  type: TYPE_NORMAL
- en: Which Lua data type can be used to save a C++ pointer? We can use **userdata**.
    This type is used to store arbitrary C/C++ data. Especially, for our case, we
    need to use **light userdata**, whose purpose is to store a C/C++ pointer. It
    is a perfect match for us.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, we need to save the class instance’s `this` pointer as *light
    userdata* in an *upvalue* for the `lua_CFunction` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have involved two new Lua concepts. They are exclusively used to work
    with C/C++ code, so chances are that you are not very familiar with them from
    Lua programming. Let us see the code in action to help with the understanding.
  prefs: []
  type: TYPE_NORMAL
- en: How to provide upvalues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will only look at the case for registering C++ modules. So far, we have ignored
    the third parameter to `luaL_setfuncs` and always passed `0`.
  prefs: []
  type: TYPE_NORMAL
- en: What does this third parameter mean? It is the count for the upvalues that will
    be available to all functions in the list provided in the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: How do you provide upvalues? Of course—you push them onto the stack!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us rewrite the function to register C++ modules as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are only two changes. First, we want another function yet to be implemented
    in `LuaModule` to push upvalues onto the stack and return to us how many upvalues
    have been pushed. Then, we pass the upvalue count as the third parameter to `luaL_setfuncs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to add `pushLuaUpvalues` to `LuaModule.h`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have provided a default implementation that pushes `this` as an upvalue.
    In derived classes, they can override this function and push more upvalues.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us see how we can access this upvalue.
  prefs: []
  type: TYPE_NORMAL
- en: How to access upvalues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lua upvalues are accessed as if they were in the stack, while they are not really
    in the stack. So, a magic stack index, `LUA_REGISTRYINDEX`, is used to mark the
    start of the upvalue pseudo-region. Lua provides a `lua_upvalueindex` macro to
    locate the indices of your upvalues, so you do not really need to deal with this
    magic number.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can access our C++ class instance stored as an upvalue. In `Destinations.cc`,
    add the following function to the anonymous namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can use this helper function to get a pointer to the instance. It uses `lua_touserdata`
    to get our light userdata from the stack with the pseudo-index. This helper will
    be called from the stubs we registered.
  prefs: []
  type: TYPE_NORMAL
- en: To reinforce
  prefs: []
  type: TYPE_NORMAL
- en: The Lua state and stack passed to a `lua_CFunction` function are private to
    each call to that function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have figured out how to access the class instance, we can complete
    our stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Completing our stubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write `luaWish` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It first gets the class instance with the `getObj` helper function we just implemented.
    Then, it puts all arguments from the Lua call site into a vector. Finally, it
    calls the real object method, `obj->wish`. This is what a wrapper does – it routes
    the call to the real object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `luaWent` is similar, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that it calls `obj->went` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, implement the query functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These functions use the object functions to get a list of places and then push
    the list onto the stack to return the results to the Lua call site.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have implemented everything, and we can test it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do not need to modify any test code because we have already used the functions
    to test our stubs. Now, recompile and run the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the Lua test code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have done everything correctly, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations on making it work!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is quite a change of mindset from the previous chapters. Take a
    moment to reflect if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to call C++ code from Lua. We first learned
    how to register a simple C++ function to Lua. All registered functions must conform
    to `lua_CFunction`. Then, we found out how to override Lua library functions.
    Finally, we implemented a C++ class and exported it to Lua. We also came across
    the concepts of *upvalue* and *light userdata* along the way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our journey with more details on user-defined
    data in C++ and more data-exchanging mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `Destinations` class, we only used one upvalue. Add another upvalue and
    play around with it. Which upvalue is at which pseudo-index?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to modify the second upvalue in a function and see if the value is persisted
    the next time the function is called. How about when it is accessed in another
    function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `LuaType.hpp`, add `LuaType::lightuserdata` and implement a structure for
    it, named `LuaLightUserData`. Support this case in the executor and helper functions.
    You do not need to support this type when popping values from the Lua stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
