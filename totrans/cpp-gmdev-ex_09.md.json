["```cpp\n#include <GL/glew.h> \n#include <GLFW/glfw3.h> \n\nThen create a main function and add the following to it. \n\nint main(int argc, char **argv) \n{ \n\n   glfwInit(); \n\n   GLFWwindow* window = glfwCreateWindow(800, 600,\n    \" Hello OpenGL \", NULL, NULL); \n\n   return 0; \n} \n```", "```cpp\nglfwMakeContextCurrent(window);     \n```", "```cpp\n   while (!glfwWindowShouldClose(window)){ \n\n               // render our scene \n\n         glfwSwapBuffers(window); \n         glfwPollEvents(); \n   } \n\n         glfwTerminate();\n```", "```cpp\nvoid renderScene(){ \n\n   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); \n   glClearColor(1.0, 0.0, 0.0, 1.0);//clear yellow \n\n   // Draw game objects here \n}\n```", "```cpp\n#include <vector> \n#include \"Dependencies/glm/glm/glm.hpp\" \n\nenum MeshType { \n\n   kTriangle = 0, \n   kQuad = 1, \n   kCube = 2, \n   kSphere = 3 \n\n}; \n\nstruct Vertex { \n\n   glm::vec3 pos; \n   glm::vec3 normal; \n   glm::vec3 color; \n   glm::vec2 texCoords; \n\n}; \n\nclass Mesh { \n\npublic: \n   static void setTriData(std::vector<Vertex>& vertices, \n     std::vector<uint32_t>&indices); \n   static void setQuadData(std::vector<Vertex>& vertices,    \n     std::vector<uint32_t>&indices); \n   static void setCubeData(std::vector<Vertex>& vertices, \n     std::vector<uint32_t>&indices); \n   static void setSphereData(std::vector<Vertex>& vertices, \n     std::vector<uint32_t>&indices); \n\n};\n```", "```cpp\n#include \"Mesh.h\" \n\nvoid Mesh::setTriData(std::vector<Vertex>& vertices, std::vector<uint32_t>& indices) { \n\n   std::vector<Vertex> _vertices = { \n\n{ { 0.0f, -1.0f, 0.0f },          // Position \n{ 0.0f, 0.0f, 1.0 },              // Normal \n{ 1.0f, 0.0f, 0.0 },              // Color \n{ 0.0, 1.0 }                      // Texture Coordinate \n},                                // 0 \n\n         { { 1.0f, 1.0f, 0.0f },{ 0.0f, 0.0f, 1.0 },{ 0.0f, 1.0f, \n          0.0 },{ 0.0, 0.0 } }, // 1 \n\n         { { -1.0f, 1.0f, 0.0f },{ 0.0f, 0.0f, 1.0 },{ 0.0f, 0.0f, \n          1.0 },{ 1.0, 0.0 } }, // 2 \n   }; \n\n   std::vector<uint32_t> _indices = { \n         0, 1, 2, \n   }; \n\n   vertices.clear(); indices.clear(); \n\n   vertices = _vertices; \n   indices = _indices; \n} \n```", "```cpp\n#include <GL/glew.h> \n\n#include \"Dependencies/glm/glm/glm.hpp\" \n#include \"Dependencies/glm/glm/gtc/matrix_transform.hpp\" \n\n```", "```cpp\nclass Camera \n{ \npublic: \n\n   Camera(GLfloat FOV, GLfloat width, GLfloat height, GLfloat \n     nearPlane, GLfloat farPlane, glm::vec3 camPos); \n   ~Camera(); \n\n   glm::mat4 getViewMatrix(); \n   glm::mat4 getProjectionMatrix(); \n   glm::vec3 getCameraPosition(); \n\nprivate: \n\n   glm::mat4 viewMatrix; \n   glm::mat4 projectionMatrix; \n   glm::vec3 cameraPos; \n\n};\n```", "```cpp\n#include \"Camera.h\" \n\nCamera::Camera(GLfloat FOV, GLfloat width, GLfloat height, GLfloat nearPlane, GLfloat farPlane, glm::vec3 camPos){ \n\n   cameraPos = camPos; \n   glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, 0.0f); \n   glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f); \n\n   viewMatrix = glm::lookAt(cameraPos, cameraFront, cameraUp); \n   projectionMatrix = glm::perspective(FOV, width /height, \n                      nearPlane, farPlane); \n} \n```", "```cpp\nglm::mat4 Camera::getViewMatrix() { \n\n   return viewMatrix; \n} \nglm::mat4 Camera::getProjectionMatrix() { \n\n   return projectionMatrix; \n} \n\nglm::vec3 Camera::getCameraPosition() { \n\n   return cameraPos; \n} \n```", "```cpp\n#include <GL/glew.h> \n\nclass ShaderLoader { \n\n   public: \n\n         GLuint CreateProgram(const char* vertexShaderFilename, \n           const char* fragmentShaderFilename); \n\n   private: \n\n         std::string readShader(const char *filename); \n         GLuint createShader(GLenum shaderType, std::string source, \n           const char* shaderName); \n};\n```", "```cpp\n#include \"ShaderLoader.h\"  \n\n#include<iostream> \n#include<fstream> \n#include<vector>\n```", "```cpp\nstd::string ShaderLoader::readShader(const char *filename) \n{ \n   std::string shaderCode; \n   std::ifstream file(filename, std::ios::in); \n\n   if (!file.good()){ \n         std::cout << \"Can't read file \" << filename << std::endl; \n         std::terminate(); \n   } \n\n   file.seekg(0, std::ios::end); \n   shaderCode.resize((unsigned int)file.tellg()); \n   file.seekg(0, std::ios::beg); \n   file.read(&shaderCode[0], shaderCode.size()); \n   file.close(); \n   return shaderCode; \n} \n\n```", "```cpp\nGLuint ShaderLoader::createShader(GLenum shaderType, std::string source, const char* shaderName) \n{ \n\n   int compile_result = 0; \n\n   GLuint shader = glCreateShader(shaderType); \n   const char *shader_code_ptr = source.c_str(); \n   const int shader_code_size = source.size(); \n\n   glShaderSource(shader, 1, &shader_code_ptr, \n     &shader_code_size); \n   glCompileShader(shader); \n   glGetShaderiv(shader, GL_COMPILE_STATUS, \n     &compile_result); \n\n   //check for errors \n\n   if (compile_result == GL_FALSE) \n   { \n\n         int info_log_length = 0; \n         glGetShaderiv(shader, GL_INFO_LOG_LENGTH, \n           &info_log_length); \n\n         std::vector<char> shader_log(info_log_length); \n\n         glGetShaderInfoLog(shader, info_log_length, NULL, \n           &shader_log[0]); \n         std::cout << \"ERROR compiling shader: \" << \n          shaderName << std::endl <<&shader_log[0] <<\n          std::endl; \n         return 0; \n   } \n   return shader; \n}  \n```", "```cpp\nGLuint ShaderLoader::createProgram (const char* vertexShaderFilename, const char* fragmentShaderFilename){\n\n  std::string vertex_shader_code = readShader \n                                   (vertexShaderFilename);\n\n  std::string fragment_shader_code = readShader \n                                     (fragmentShaderFilename);\n\n  GLuint vertex_shader = createShader (GL_VERTEX_SHADER, \n                         vertex_shader_code,\n                         “vertex shader” );\n\n  GLuint fragment_shader = createShader (GL_FRAGMENT_SHADER, \n                           fragment_shader_code,\n                           “fragment shader”);\n\n  int link_result = 0;\n  //create the program handle, attach the shaders and link it\n  GLuint program = glCreateProgram();\n  glAttachShader(program, vertex_shader);\n  glAttachShader(program, fragment_shader);\n\n  glLinkProgram(program);\n  glGetProgramiv(program, GL_LINK_STATUS, &link_result);\n  //check for link errors\n  if (link_result == GL_FALSE) {\n\n    int info_log_length = 0;\n    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);\n\n    std::vector<char> program_log(info_log_length);\n\n    glGetProgramInfoLog(program, info_log_length, NULL, \n      &program_log[0]);\n    std::cout << “Shader Loader : LINK ERROR” << std::endl \n      <<&program_log[0] << std::endl;\n\n    return 0;\n  }\n  return program;\n}\n```", "```cpp\n#include <GL/glew.h> \n\n#include \"Dependencies/glm/glm/glm.hpp\" \n#include \"Dependencies/glm/glm/gtc/type_ptr.hpp\" \n\n#include \"Mesh.h\" \n#include \"ShaderLoader.h\"; \n#include \"Camera.h\"  \n```", "```cpp\nclass LightRenderer \n{ \n\n}; \n```", "```cpp\npublic: \n   LightRenderer(MeshType meshType, Camera* camera); \n   ~LightRenderer(); \n\n   void draw(); \n\n   void setPosition(glm::vec3 _position); \n   void setColor(glm::vec3 _color); \n   void setProgram(GLuint program); \n\n   glm::vec3 getPosition(); \n   glm::vec3 getColor(); \n\n```", "```cpp\nprivate: \n\n   Camera* camera; \n\n   std::vector<Vertex>vertices; \n   std::vector<GLuint>indices; \n\nglm::vec3 position, color; \n\nGLuint vbo, ebo, vao, program;  \n```", "```cpp\nLightRenderer::LightRenderer(MeshType meshType, Camera* camera) { \n\n} \n```", "```cpp\nthis->camera = camera; \n```", "```cpp\n   switch (modelType) { \n\n         case kTriangle: Mesh::setTriData(vertices, indices); \n           break; \n         case kQuad: Mesh::setQuadData(vertices, indices); break; \n         case kCube: Mesh::setCubeData(vertices, indices); break; \n         case kSphere: Mesh::setSphereData(vertices, indices); \n           break; \n   }  \n```", "```cpp\nglGenVertexArrays(1, &vao); \nglBindVertexArray(vao); \n\n```", "```cpp\nglGenBuffers(1, &vbo);  \n```", "```cpp\nglBindBuffer(GL_ARRAY_BUFFER, vbo);\n```", "```cpp\nglBufferData(GL_ARRAY_BUFFER,  \nsizeof(Vertex) * vertices.size(),  \n&vertices[0],  \nGL_STATIC_DRAW); \n```", "```cpp\nglEnableVertexAttribArray(0);   \n```", "```cpp\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)0);\n```", "```cpp\nglEnableVertexAttribArray(1); \nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(offsetof(Vertex, Vertex::color))); \n\n```", "```cpp\nglGenBuffers(1, &ebo); \nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo); \n\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLuint) * indices.size(), &indices[0], GL_STATIC_DRAW); \n```", "```cpp\nglBindBuffer(GL_ARRAY_BUFFER, 0); \nglBindVertexArray(0);\n```", "```cpp\nvoid LightRenderer::draw() { \n\n}\n```", "```cpp\nglm::mat4 model = glm::mat4(1.0f); \n\n   model = glm::translate(glm::mat4(1.0),position); \n```", "```cpp\nglUseProgram(this->program); \n```", "```cpp\n   GLint modelLoc = glGetUniformLocation(program, \"model\"); \n```", "```cpp\nglUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));\n```", "```cpp\n   glm::mat4 view = camera->getViewMatrix(); \n   GLint vLoc = glGetUniformLocation(program, \"view\"); \n   glUniformMatrix4fv(vLoc, 1, GL_FALSE, glm::value_ptr(view)); \n\n   glm::mat4 proj = camera->getprojectionMatrix(); \n   GLint pLoc = glGetUniformLocation(program, \"projection\"); \n   glUniformMatrix4fv(pLoc, 1, GL_FALSE, glm::value_ptr(proj)); \n```", "```cpp\nglBindVertexArray(vao); \nglDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0); \n```", "```cpp\nglBindVertexArray(0); \nglUseProgram(0); \n\n```", "```cpp\nLightRenderer::~LightRenderer() { \n\n} \n\nvoid LightRenderer::setPosition(glm::vec3 _position) { \n\n   position = _position; \n} \n\nvoid LightRenderer::setColor(glm::vec3 _color) { \n\n   this->color = _color; \n} \n\nvoid LightRenderer::setProgram(GLuint _program) { \n\n   this->program = _program; \n} \n\n//getters \nglm::vec3 LightRenderer::getPosition() { \n\n   return position; \n} \n\nglm::vec3 LightRenderer::getColor() { \n\n   return color; \n} \n\n```", "```cpp\n#include \"ShaderLoader.h\" \n#include \"Camera.h\" \n#include \"LightRenderer.h\" \nCamera* camera; \nLightRenderer* light;\n```", "```cpp\n void initGame(){ \n... \n\n}  \n```", "```cpp\n   glEnable(GL_DEPTH_TEST); \n```", "```cpp\nShaderLoader shader; \n\nGLuint flatShaderProgram = shader.createProgram(\"Assets/Shaders/FlatModel.vs\", \"Assets/Shaders/FlatModel.fs\"); \n```", "```cpp\n#version 450 core \n\nlayout (location = 0) in vec3 Position; \nlayout (location = 1) in vec3 Color; \n\nuniform mat4 projection; \nuniform mat4 view; \nuniform mat4 model; \n\nout vec3 outColor; \n\nvoid main(){ \n\n   gl_Position = projection * view * model * vec4(Position, 1.0); \n\n   outColor = Color; \n}\n```", "```cpp\n#version 450 core \n\nin vec3 outColor; \n\nout vec4 color; \n\nvoid main(){ \n\n   color = vec4(outColor, 1.0f); \n\n} \n\n```", "```cpp\ncamera = new Camera(45.0f, 800, 600, 0.1f, 100.0f, glm::vec3(0.0f, \n         4.0f, 6.0f)); \n```", "```cpp\nlight = new LightRenderer(MeshType::kTriangle, camera); \nlight->setProgram(flatShaderProgram); \nlight->setPosition(glm::vec3(0.0f, 0.0f, 0.0f)); \n```", "```cpp\nvoid renderScene(){ \n\n   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); \n   glClearColor(1.0, 1.0, 0.0, 1.0);//clear yellow  \n   light->draw(); \n\n}\n```", "```cpp\nint main(int argc, char **argv) \n{ \n\n   glfwInit(); \n\n   GLFWwindow* window = glfwCreateWindow(800, 600, \n                        \" Hello OpenGL \", NULL, NULL); \n\n   glfwMakeContextCurrent(window); \n\n   glewInit(); \n\n   initGame(); \n\n   while (!glfwWindowShouldClose(window)){ \n\n         renderScene(); \n\n         glfwSwapBuffers(window); \n         glfwPollEvents(); \n   } \n\n   glfwTerminate(); \n\n   delete camera; \n   delete light; \n\n   return 0; \n}\n```", "```cpp\nstatic void glfwError(int id, const char* description)\n{\n  std::cout << description << std::endl;\n}\n\nint main(int argc, char **argv)\n{\n\n  glfwSetErrorCallback(&glfwError);\n\n  glfwInit();\n\n  GLFWwindow* window = glfwCreateWindow(800, 600, \" Hello OpenGL \", \n                       NULL, NULL);\n\n  glfwMakeContextCurrent(window);\n\n  glewInit();\n\n  initGame();\n\n  while (!glfwWindowShouldClose(window)){\n\n    renderScene();\n\n    glfwSwapBuffers(window);\n    glfwPollEvents();\n  }\n\n  glfwTerminate();\n\n  delete camera;\n  delete light;\n\n  return 0;\n}\n```"]