- en: Chapter 3. Your First Game – Air Hockey
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。你的第一个游戏 – 桌面冰球
- en: '*We are going to build an Air Hockey game to introduce you to all the main
    aspects of building a project with Cocos2d-x. These include setting up the project''s
    configuration, loading images, loading sounds, building a game for more than one
    screen resolution, and managing touch events.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将构建一个桌面冰球游戏，以介绍使用Cocos2d-x构建项目的所有主要方面。这包括设置项目的配置、加载图像、加载声音、为多个屏幕分辨率构建游戏以及管理触摸事件。*'
- en: '*Oh, and you will need to call a friend. This is a two player game. Go on,
    I''ll wait here.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*哦，你还需要叫一个朋友。这是一个双人游戏。继续吧，我在这里等你。*'
- en: 'By the end of this chapter, you will know:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道：
- en: How to build an iPad-only game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建仅适用于iPad的游戏
- en: How to enable multitouch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何启用多点触控
- en: How to support both retina and non-retina displays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何支持视网膜和非视网膜显示屏
- en: How to load images and sounds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何加载图像和声音
- en: How to play sound effects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何播放音效
- en: How to create sprites
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建精灵
- en: How to extend the Cocos2d-x `Sprite` class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何扩展Cocos2d-x的`Sprite`类
- en: How to create labels and update them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建标签并更新它们
- en: Without further ado...let's begin.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延...让我们开始吧。
- en: Game configurations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏配置
- en: 'The game will have the following characteristics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将具有以下特点：
- en: It must support multitouch since it's a two player game
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于是双人游戏，它必须支持多点触控
- en: It must be played on large screens since it's a two player game
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于是双人游戏，它必须在大型屏幕上玩
- en: It must support retina displays because we want to cash in on that
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们想利用这一点，它必须支持视网膜显示屏
- en: It must be played only in portrait mode because I built the art in portrait
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我是在纵向模式下构建的艺术品，它必须仅在纵向模式下播放
- en: So let's create our project!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们创建我们的项目！
- en: Time for action – creating your game project
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建你的游戏项目
- en: 'I''ll build the game first in Xcode and then show how to take the project to
    Eclipse, but the folder structure remains the same, so you can work with any IDE
    you wish and the instructions here will be the same:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先在Xcode中构建游戏，然后展示如何将项目带到Eclipse，但文件夹结构保持不变，所以你可以使用任何你想要的IDE，这里的说明将是相同的：
- en: 'Open the terminal and create a new Cocos2d-x project called `AirHockey` that
    uses C++ as its main language. I saved mine on the desktop, so the command I had
    to enter looks like this:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，创建一个名为`AirHockey`的新Cocos2d-x项目，使用C++作为其主要语言。我把我的保存在桌面上，所以我要输入的命令看起来像这样：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the project is created, navigate to its `proj.ios_mac` folder and double-click
    on the `AirHockey.xcodeproj` file. (For Eclipse, you can follow the same steps
    we did when we created the `HelloWorld` project to import the project.)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建项目，导航到其`proj.ios_mac`文件夹，双击`AirHockey.xcodeproj`文件。（对于Eclipse，你可以遵循我们创建`HelloWorld`项目时采取的相同步骤来导入项目。）
- en: Select the top item in **Project Navigator** and making sure the **iOS** target
    is selected, edit the information by navigating to **General** | **Deployment
    info**, setting the target device to **iPad** and **Device Orientation** to **Portrait**
    and **Upside Down**.![Time for action – creating your game project](img/00007.jpeg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目导航器**中选择顶部项目，并确保选择了**iOS**目标，通过导航到**通用** | **部署信息**，设置目标设备为**iPad**，并将**设备方向**设置为**纵向**和**颠倒**。![行动时间
    – 创建你的游戏项目](img/00007.jpeg)
- en: Save your project changes.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目更改。
- en: '*What just happened?*'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You created a Cocos2d-x project targeting iPads, and you are ready to set it
    up with the rest of the configurations I described earlier.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个针对iPad的Cocos2d-x项目，你现在可以设置它，使用我之前描述的其余配置。
- en: So let's do that now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们现在就来做。
- en: Time for action – laying down the rules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 制定规则
- en: We'll update the `RootViewController.mm` file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`RootViewController.mm`文件。
- en: 'Go to `RootViewController.mm` inside the `ios` folder and look for the `shouldAutorotateToInterfaceOrientation`
    method. Change the line inside the method to read:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`ios`文件夹中的`RootViewController.mm`，查找`shouldAutorotateToInterfaceOrientation`方法。将方法内的行更改为：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And a few lines below in the `supportedInterfaceOrientations` method, change
    the line inside the conditional `to`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`supportedInterfaceOrientations`方法下方几行，更改条件`to`内的行：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*What just happened?*'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just told `RootViewController` we want our application to play in any of
    the two supported portrait modes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚告诉`RootViewController`，我们希望我们的应用程序在任何两种支持的纵向模式中运行。
- en: Supporting retina displays
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持视网膜显示屏
- en: Now let's add the images to our project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将图像添加到我们的项目中。
- en: Time for action – adding the image files
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加图像文件
- en: First, we download the resources for this project, and then we add them in Xcode.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们下载这个项目的资源，然后我们在 Xcode 中添加它们。
- en: Go to this book's **Support** page ([www.packtpub.com/support](http://www.packtpub.com/support))
    and download the `4198_03_RESOURCES.zip` file. Inside it, you should find three
    folders called `hd`, `sd`, and `fonts`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往本书的 **支持** 页面 ([www.packtpub.com/support](http://www.packtpub.com/support))
    并下载 `4198_03_RESOURCES.zip` 文件。在里面，您应该找到三个名为 `hd`、`sd` 和 `fonts` 的文件夹。
- en: Go to your `Project` folder, the actual folder in your system. Drag the three
    folders to the `Resources` folder inside your project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您的 `Project` 文件夹，即您系统中的实际文件夹。将三个文件夹拖到项目中的 `Resources` 文件夹内。
- en: Go back to Xcode. Select the `Resources` folder in your project navigation panel.
    Then go to **File** | **Add Files to AirHockey**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Xcode。在项目导航面板中选择 `Resources` 文件夹。然后转到 **文件** | **将文件添加到 AirHockey**。
- en: In the **File** window, navigate to the `Resources` folder and select the `sd`,
    `hd`, and `fonts` folders.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **文件** 窗口中，导航到 `Resources` 文件夹并选择 `sd`、`hd` 和 `fonts` 文件夹。
- en: 'This is very important: make sure **Create folder references for any added
    folders** is selected. Also make sure you selected **AirHockey** as the target.
    It wouldn''t hurt to make sure **Copy items to destination...** is also selected.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这非常重要：确保 **为任何添加的文件夹创建文件夹引用** 已选中。同时确保您已选择 **AirHockey** 作为目标。确保 **复制项目到目标...**
    也已选中。
- en: Click on **Add**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加**。
- en: '*What just happened?*'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'You added the necessary image files for your Air Hockey game. These come in
    two versions: one for retina displays (high definition) and one for non-retina
    displays (standard definition). It is very important that references are added
    to the actual folders, only this way Xcode will be able to have two files with
    the same name inside the project and still keep them apart; one in each folder.
    We also added the font we''ll be using in the game.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您已添加了您 Air Hockey 游戏所需的必要图像文件。它们有两种版本：一种是针对视网膜显示屏（高清）的，另一种是针对非视网膜显示屏（标准定义）的。确保只添加到实际文件夹的引用非常重要；这样，Xcode
    才能将两个具有相同名称的文件分别放在项目的每个文件夹中；每个文件夹一个。我们还添加了游戏中将使用的字体。
- en: Now let's tell Cocos2d-x where to look for the correct files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们告诉 Cocos2d-x 去哪里查找正确的文件。
- en: Time for action – adding retina support
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候添加视网膜支持了
- en: 'This time we''ll work with the class `AppDelegate.cpp`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将处理 `AppDelegate.cpp` 类：
- en: 'Go to `AppDelegate.cpp` (you''ll find it in the `Classes` folder). Inside the
    `applicationDidFinishLaunching` method, and below the `director->setAnimationInterval(1.0
    / 60)` line, add the following lines:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `AppDelegate.cpp` (您可以在 `Classes` 文件夹中找到它)。在 `applicationDidFinishLaunching`
    方法中，在 `director->setAnimationInterval(1.0 / 60)` 行下面，添加以下行：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the file.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: '*What just happened?*'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'An entire book could be written about this topic, although in this first example,
    we have a very simple implementation on how to support multiple screen sizes since
    we are only targeting iPads. Here we are saying: "Hey `AppDelegate`, I designed
    this game for a 768 x 1024 screen."'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以写一本关于这个主题的整本书，尽管在这个第一个例子中，我们有一个非常简单的实现，说明如何支持多个屏幕尺寸，因为我们只针对 iPad。这里我们说的是：“嘿
    `AppDelegate`，我为 768 x 1024 屏幕设计了这款游戏。”
- en: All the values for positioning and font size were chosen for that screen size.
    If the screen is larger, make sure you grab the files from the `hd` folder and
    change the scale by which you will multiply all my positioning and font sizes.
    If the screen has the same size I designed the game for, use the files in the
    `sd` folder and set the scale to 1\. (Android adds even more complexity to this,
    but we'll tackle that in later in the book.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于定位和字体大小的值都是针对该屏幕尺寸选择的。如果屏幕更大，请确保您从 `hd` 文件夹中获取文件，并更改您将乘以所有定位和字体大小的比例。如果屏幕大小与我为游戏设计的相同，请使用
    `sd` 文件夹中的文件，并将比例设置为 1。 (Android 为此增加了更多的复杂性，但我们在本书的后面会处理这个问题。)
- en: '`FileUtils` will look for every file you load for your game first inside `Resources`
    | `sd` (or `hd`). If it doesn''t find them there, it will try to find them in
    `Resources`. This is a good thing because files shared by both versions may be
    added only once to the project, inside `Resources`. That is what we''ll do now
    with the sound files.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileUtils` 将首先在 `Resources` | `sd` (或 `hd`) 中查找您为游戏加载的每个文件。如果在那里找不到，它将尝试在
    `Resources` 中查找它们。这是一件好事，因为两个版本共享的文件可能只添加到项目中的 `Resources` 里面一次。我们现在就会这样做，添加声音文件。'
- en: Adding sound effects
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加声音效果
- en: This game has two files for sound effects. You will find them in the same `.zip`
    file you downloaded previously.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏有两个声音效果文件。您可以在之前下载的相同 `.zip` 文件中找到它们。
- en: Time for action – adding the sound files
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 添加声音文件
- en: Assuming you have the sound files from the downloaded resources, let's add them
    to the project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经有从下载的资源中获取的声音文件，让我们将它们添加到项目中。
- en: Drag both the `.wav` files to the `Resources` folder inside your `Project` folder.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个`.wav`文件拖到你的`Project`文件夹内的`Resources`文件夹中。
- en: Then go to Xcode, select the `Resources` folder in the file navigation panel
    and select **File** | **Add Files to AirHockey**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后转到Xcode，在文件导航面板中选择`Resources`文件夹，并选择**文件** | **将文件添加到AirHockey**。
- en: Make sure the **AirHockey** target is selected.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择了**AirHockey**目标。
- en: 'Go to `AppDelegate.cpp` again. At the top, add this `include` statement:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次转到`AppDelegate.cpp`。在顶部，添加以下`include`语句：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then below the `USING_NS_CC` macro (for `using namespace cocos2d`), add:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在`USING_NS_CC`宏（用于`using namespace cocos2d`）下方添加：
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then just below the lines you added in the previous section, inside `applicationDidFinishLaunching`,
    add the following lines:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在上一节中添加的行下面，在`applicationDidFinishLaunching`中添加以下行：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*What just happened?*'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: With the `preloadEffect` method from `CocosDenshion`, you manage to preload
    the files as well as instantiate and initialize `SimpleAudioEngine`. This step
    will always take a toll on your application's processing power, so it's best to
    do it early on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`CocosDenshion`的`preloadEffect`方法，你成功预加载了文件以及实例化和初始化`SimpleAudioEngine`。这一步总是会消耗你的应用程序的处理能力，因此最好尽早完成。
- en: 'By now, the folder structure for your game should look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你的游戏文件夹结构应该看起来像这样：
- en: '![What just happened?](img/00008.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/00008.jpeg)'
- en: Extending Sprite
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Sprite
- en: No, there is nothing wrong with `Sprite`. I just picked a game where we need
    a bit more information from some of its sprites. In this case, we want to store
    where a sprite is and where it will be once the current iteration of the game
    is completed. We will also need a helper method to get the sprite's radius.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不，`Sprite`没有问题。我只是选择了一个需要从其一些精灵中获取更多信息的游戏。在这种情况下，我们想要存储精灵的位置以及游戏当前迭代完成后它将去的位置。我们还需要一个辅助方法来获取精灵的半径。
- en: So let's create our `GameSprite` class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们创建我们的`GameSprite`类。
- en: Time for action – adding GameSprite.cpp
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 添加GameSprite.cpp
- en: From here on, we'll create any new classes inside Xcode, but you could do it
    just as easily in Eclipse if you remember to update the `Make` file. I'll show
    you how to do that later in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将在Xcode中创建任何新的类，但如果你记得更新`Make`文件，你同样可以在Eclipse中轻松完成。我将在本章后面展示如何做到这一点。
- en: In Xcode, select the `Classes` folder and then go to **File** | **New** | **File**
    and navigate to **iOS** | **Source** select **C++ File**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xcode中，选择`Classes`文件夹，然后转到**文件** | **新建** | **文件**，导航到**iOS** | **源**选择**C++
    文件**。
- en: Call it `GameSprite` and make sure the **Also create a header file** option
    is selected.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为`GameSprite`并确保选择了**也创建一个头文件**选项。
- en: 'Select the new `GameSprite.h` interface file and replace the code there with
    this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新的`GameSprite.h`接口文件，并用以下代码替换那里的代码：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In the interface, we declare the class to be a subclass of the public `Sprite`
    class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中，我们声明该类是公共`Sprite`类的子类。
- en: Then we add three synthesized properties. In Cocos2d-x, these are macros to
    create getters and setters. You declare the type, the protected variable name,
    and the words that will be appended to the `get` and `set` methods. So in the
    first `CC_SYNTHESIZE` method, the `getNextPosition` and `setNextPosition` method
    will be created to deal with the `Point` value inside the `_nextPosition` protected
    variable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了三个合成属性。在Cocos2d-x中，这些是用于创建获取器和设置器的宏。你声明类型、受保护的变量名以及将附加到`get`和`set`方法的单词。因此，在第一个`CC_SYNTHESIZE`方法中，将创建`getNextPosition`和`setNextPosition`方法来处理`_nextPosition`受保护变量中的`Point`值。
- en: We also add the constructor and destructor for our class, and the ubiquitous
    static method for instantiation. This receives as a parameter, the image filename
    used by the sprite. We finish off by overriding `setPosition` from `Sprite` and
    adding the declaration for our helper method radius.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为我们的类添加了构造函数和析构函数，以及实例化的通用静态方法。这个方法接收一个参数，即精灵使用的图像文件名。我们通过覆盖`Sprite`中的`setPosition`并添加我们的辅助方法半径的声明来完成。
- en: The next step then is to implement our new class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现我们的新类。
- en: Time for action – implementing GameSprite
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 实现GameSprite
- en: With the header out of the way, all we need to do is implement our methods.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件处理完毕后，我们只需要实现我们的方法。
- en: 'Select the `GameSprite.cpp` file and let''s start on the instantiation logic
    of the class:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`GameSprite.cpp`文件，让我们开始类的实例化逻辑：
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next we need to override the `Node` method `setPosition`. We need to make sure
    that whenever we change the position of the sprite, the new value is also used
    by `_nextPosition`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要重写`Node`方法的`setPosition`。我们需要确保每次更改精灵的位置时，新的值也会被`_nextPosition`使用：
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And finally, we implement our new method to retrieve the radius of our sprite,
    which we determine to be half its texture''s width:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现了我们的新方法来检索精灵的半径，我们将其确定为纹理宽度的一半：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*What just happened?*'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Things only begin happening in the static method. We create a new `GameSprite`
    class, then we call `initWithFile` on it. This is a `GameSprite` method inherited
    from its super class; it returns a Boolean value for whether that operation succeeded.
    The static method ends by returning an `autorelease` version of the `GameSprite`
    object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 事情只在静态方法中开始。我们创建一个新的`GameSprite`类，然后调用其上的`initWithFile`。这是从其超类继承的`GameSprite`方法；它返回一个布尔值，表示该操作是否成功。静态方法通过返回`autorelease`版本的`GameSprite`对象结束。
- en: The `setPosition` override makes sure `_nextPosition` receives the position
    information whenever the sprite is placed somewhere. And the helper `radius` method
    returns half of the sprite's texture width.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPosition`的重写确保当精灵被放置在某个位置时，`_nextPosition`也会接收到位置信息。并且辅助的`radius`方法返回精灵纹理宽度的二分之一。'
- en: Have a go hero
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下，英雄
- en: Change the radius method to an inline method in the interface and remove it
    from the implementation file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将半径方法更改为接口中的内联方法，并从实现文件中删除它。
- en: The actual game scene
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际的游戏场景
- en: Finally, we'll get to see all our work and have some fun with it. But first,
    let's delete the `HelloWorldScene` class (both header and implementation files).
    You'll get a few errors in the project so let's fix these.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到我们的所有工作，并从中获得一些乐趣。但首先，让我们删除`HelloWorldScene`类（包括头文件和实现文件）。你会在项目中遇到一些错误，所以让我们修复这些错误。
- en: References to the class must be changed at two lines in `AppDelegate.cpp`. Go
    ahead and change the references to a `GameLayer` class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppDelegate.cpp`中的两行必须更改对类的引用。继续将引用更改为`GameLayer`类。
- en: We'll create that class next.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建那个类。
- en: Time for action – coding the GameLayer interface
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 编码GameLayer接口
- en: '`GameLayer` is the main container in our game.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameLayer`是我们游戏中的主要容器。'
- en: Follow the steps to add a new file to your `Classes` folder. This is a C++ file
    called `GameLayer`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照步骤将新文件添加到你的`Classes`文件夹中。这是一个名为`GameLayer`的C++文件。
- en: 'Select your `GameLayer.h`. Just below the first `define` preprocessor command,
    add:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的`GameLayer.h`。在第一个`define`预处理器命令下方，添加：
- en: '[PRE11]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We define the width of the goals in pixels.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了球门的宽度（以像素为单位）。
- en: 'Next, add the declarations for our sprites and our score text labels:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加我们的精灵和得分文本标签的声明：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have the `GameSprite` objects for two players (the weird looking things called
    mallets), and the ball (called a puck). We'll store the two players in a Cocos2d-x
    `Vector`. We also have two text labels to display the score for each player.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有两个玩家的`GameSprite`对象（看起来奇怪的称为mallets），以及球（称为puck）。我们将两个玩家存储在Cocos2d-x的`Vector`中。我们还有两个文本标签来显示每个玩家的得分。
- en: 'Declare a variable to store the screen size. We''ll use this a lot for positioning:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个变量来存储屏幕大小。我们将大量使用它进行定位：
- en: '[PRE13]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add variables to store the score information and a method to update these scores
    on screen:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加变量以存储得分信息，并添加一个方法来更新屏幕上的这些得分：
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, let''s add our methods:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加我们的方法：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are constructor and destructor methods, then the `Layer init` methods,
    and finally the event handlers for the touch events and our loop method called
    `update`. These touch event handlers will be added to our class to handle when
    users' touches begin, when they move across the screen, and when they end.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有构造函数和析构函数方法，然后是`Layer init`方法，最后是触摸事件处理程序和我们的循环方法`update`。这些触摸事件处理程序将被添加到我们的类中，以处理用户触摸开始、在屏幕上移动以及结束时的情况。
- en: '*What just happened?*'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: '`GameLayer` is our game. It contains references to all the sprites we need
    to control and update, as well as all game data.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameLayer`是我们的游戏。它包含我们需要控制和更新的所有精灵的引用，以及所有游戏数据。'
- en: In the class implementation, all the logic starts inside the `init` method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在类实现中，所有逻辑都开始于`init`方法内部。
- en: Time for action – implementing init()
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 实现init()
- en: 'Inside `init()`, we''ll build the game screen, bringing in all the sprites
    and labels we''ll need for the game:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init()`内部，我们将构建游戏屏幕，引入游戏所需的全部精灵和标签：
- en: 'So right after the `if` statement where we call the super `Layer::init` method,
    we add:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在调用超类`Layer::init`方法的`if`语句之后，我们添加：
- en: '[PRE16]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We create the vector where we''ll store both players, initialize the score
    values, and grab the screen size from the singleton, all-knowing `Director`. We''ll
    use the screen size to position all sprites relatively. Next we will create our
    first sprite. It is created with an image filename, which `FileUtils` will take
    care of loading from the correct folder:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个向量来存储两个玩家，初始化得分值，并从单例、无所不知的`Director`中获取屏幕大小。我们将使用屏幕大小来相对定位所有精灵。接下来，我们将创建第一个精灵。它使用图像文件名创建，`FileUtils`将负责从正确的文件夹中加载：
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Get into the habit of positioning sprites with relative values, and not absolute
    ones, so we can support more screen sizes. And say hello to the `Vec2` type definition
    used to create points; you'll be seeing it a lot in Cocos2d-x.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 习惯使用相对值定位精灵，而不是绝对值，这样我们可以支持更多的屏幕尺寸。并且，欢迎`Vec2`类型定义，它用于创建点；你将在Cocos2d-x中经常看到它。
- en: We finish by adding the sprite as a child to our `GameLayer` (the court sprite
    does not need to be a `GameSprite`).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将精灵作为子节点添加到我们的`GameLayer`（球场精灵不需要是`GameSprite`）来完成。
- en: 'Next we will use our spanking new `GameSprite` class, carefully positioning
    the objects on screen:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们全新的`GameSprite`类，仔细地在屏幕上定位对象：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will create TTF labels with the `Label` class `createWithTTF` static method,
    passing as parameters the initial string value (`0`), and the path to the font
    file. We will then position and rotate the labels:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`Label`类的`createWithTTF`静态方法创建TTF标签，传递初始字符串值（`0`）和字体文件路径。然后我们将定位和旋转标签：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we turn `GameLayer` into a multitouch event listener and tell the `Director`
    event dispatcher that `GameLayer` wishes to listen to those events. And we finish
    by scheduling the game''s main loop as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`GameLayer`变成一个多点触摸事件监听器，并告诉`Director`事件分发器`GameLayer`希望监听这些事件。最后，我们按照以下方式安排游戏的主循环：
- en: '[PRE20]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*What just happened?*'
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'You created the game screen for Air Hockey, with your own sprites and labels.
    The game screen, once all elements are added, should look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你为冰球游戏创建了游戏屏幕，使用你自己的精灵和标签。一旦所有元素都添加完毕，游戏屏幕应该看起来像这样：
- en: '![What just happened?](img/00009.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/00009.jpeg)'
- en: And now we're ready to handle the player's screen touches.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好处理玩家的屏幕触摸了。
- en: Time for action – handling multitouches
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 处理多点触摸
- en: 'There are three methods we need to implement in this game to handle touches.
    Each method receives, as one of its parameters, a vector of `Touch` objects:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们需要实现三种方法来处理触摸事件。每个方法都接收一个参数，即一个`Touch`对象的向量：
- en: 'So add our `onTouchesBegan` method:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，添加我们的`onTouchesBegan`方法：
- en: '[PRE21]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each `GameSprite`, if you recall, has a `_touch` property.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你还记得，每个`GameSprite`都有一个`_touch`属性。
- en: So we iterate through the touches, grab their location on screen, loop through
    the players in the vector, and determine if the touch lands on one of the players.
    If so, we store the touch inside the player's `_touch` property (from the `GameSprite`
    class).
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们遍历触摸事件，获取它们在屏幕上的位置，遍历向量中的玩家，并确定触摸是否落在某个玩家身上。如果是，我们将触摸存储在玩家的`_touch`属性中（来自`GameSprite`类）。
- en: A similar process is repeated for `onTouchesMoved` and `onTouchesEnded`, so
    you can copy and paste the code and just replace what goes on inside the `_players`
    array for loop.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`onTouchesMoved`和`onTouchesEnded`，也会重复类似的过程，所以你可以复制粘贴代码，只需替换`_players`数组循环内的内容即可。
- en: 'In `TouchesMoved`, when we loop through the players, we do this:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TouchesMoved`中，当我们遍历玩家时，我们这样做：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We check to see if the `_touch` property stored inside the player is the being
    moved now. If so, we update the player''s position with the touch''s current position,
    but we check to see if the new position is valid: a player cannot move outside
    the screen and cannot enter its opponent''s court. We also update the player''s
    vector of movement; we''ll need this when we collide the player with the puck.
    The vector is based on the player''s displacement.'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们检查存储在玩家中的`_touch`属性是否是当前正在移动的。如果是，我们使用触摸的当前位置更新玩家的位置，但我们会检查新位置是否有效：玩家不能移动到屏幕外，也不能进入对手的球场。我们还更新玩家的移动向量；当我们将玩家与冰球碰撞时，我们需要这个向量。该向量基于玩家的位移。
- en: 'In `onTouchesEnded,` we add this:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onTouchesEnded`中，我们添加以下内容：
- en: '[PRE23]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We clear the `_touch` property stored inside the player if this touch is the
    one just ending. The player also stops moving, so its vector is set to `0`. Notice
    that we don't need the location of the touch anymore; so in `TouchesEnded` you
    can skip that bit of logic.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个触摸是刚刚结束的，我们清除玩家内部存储的 `_touch` 属性。玩家也会停止移动，因此其向量被设置为 `0`。注意，我们不再需要触摸的位置；所以在
    `TouchesEnded` 中可以跳过这部分逻辑。
- en: '*What just happened?*'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'When you implement logic for multitouch this is pretty much what you will have
    to do: store the individual touches inside either an array or individual sprites,
    so you can keep tracking these touches.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现多触控逻辑时，这基本上是你必须做的：将单个触摸存储在数组或单个精灵中，这样你可以继续跟踪这些触摸。
- en: Now, for the heart and soul of the game—the main loop.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于游戏的核心和灵魂——主循环。
- en: Time for action – adding our main loop
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候添加我们的主循环了
- en: 'This is the heart of our game—the `update` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的游戏的核心——`update` 方法：
- en: 'We will update the puck''s velocity with a little friction applied to its vector
    (`0.98f`). We will store what its next position will be at the end of the iteration,
    if no collision occurred:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一点摩擦力更新冰球的速率（`0.98f`）。如果没有发生碰撞，我们将存储迭代结束时冰球的下一个位置：
- en: '[PRE24]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next comes the collision. We will check collisions with each player sprite
    and the ball:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是碰撞。我们将检查每个球员精灵和球之间的碰撞：
- en: '[PRE25]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Collisions are checked through the distance between ball and players. Two conditions
    will flag a collision, as illustrated in the following diagram:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过球和球员之间的距离来检查碰撞。以下图示说明了两个条件将触发碰撞：
- en: '![Time for action – adding our main loop](img/00010.jpeg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![是时候添加我们的主循环了](img/00010.jpeg)'
- en: 'If the distance between ball and player equals the sum of the radii of both
    sprites, or is less than the sum of the radii of both sprites, we have a collision:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果球和球员之间的距离等于两个精灵半径之和，或者小于两个精灵半径之和，则存在碰撞：
- en: '[PRE26]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use the squared radii values so we don't need to use costly square root calculations
    to get the values for distance. So all values in the previous conditional statement
    are squared, including the distances.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用平方半径值，这样我们就不需要使用昂贵的平方根计算来获取距离值。所以前一个条件语句中的所有值都是平方的，包括距离。
- en: These conditions are checked both with the player's current position and its
    next position, so there is less risk of the ball moving "through" the player sprite
    between iterations.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些条件既检查球员的当前位置也检查其下一个位置，这样球在迭代之间“穿过”球员精灵的风险就小了。
- en: 'If there is a collision, we grab the magnitudes of both the ball''s vector
    and the player''s vector, and make the force with which the ball will be pushed
    away. We update the ball''s next position in that case, and play a nice sound
    effect through the `SimpleAudioEngine` singleton (don''t forget to include the
    `SimpleAudioEngine.h` header file and declare we''re using the `CocosDenshion`
    namespace):'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生碰撞，我们获取球和球员的向量的幅度，并使用这个力将球推开。在这种情况下，我们更新球的下一个位置，并通过 `SimpleAudioEngine`
    单例播放一个好听的声音效果（别忘了包含 `SimpleAudioEngine.h` 头文件并声明我们使用 `CocosDenshion` 命名空间）：
- en: '[PRE27]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we will check the collision between the ball and screen sides. If so,
    we will move the ball back to the court and play our sound effect here as well:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查球和屏幕边缘之间的碰撞。如果是这样，我们将球移回球场，并在这里播放我们的音效：
- en: '[PRE28]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At the top and bottom sides of the court, we check to see whether the ball
    has not moved through one of the goals through our previously defined `GOAL_WIDTH`
    property as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在球场的顶部和底部两侧，我们检查球是否通过我们之前定义的 `GOAL_WIDTH` 属性没有穿过任何一个球门，如下所示：
- en: '[PRE29]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We finally update the ball information, and if the ball has passed through
    the goal posts (drum roll):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最终更新球的信息，如果球穿过了球门（鼓声响起）：
- en: '[PRE30]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We call our helper method to score a point and we finish the update with the
    placement of all the elements, now that we know where the `nextPosition` value
    is for each one of the elements in the game:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用我们的辅助方法来得分，并且现在我们知道游戏中每个元素 `nextPosition` 的值，我们完成更新，放置所有元素：
- en: '[PRE31]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*What just happened?*'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We have just built the game's main loop. Whenever your gameplay depends on precise
    collision detection, you will undoubtedly apply a similar logic of position now,
    position next, collision checks, and adjustments to position next, if a collision
    has occurred. And we finish the game with our helper method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了游戏的主循环。每当你的游戏玩法依赖于精确的碰撞检测时，你无疑会应用类似的逻辑：现在的位置，下一个位置，碰撞检查，如果发生碰撞，则调整下一个位置。然后我们使用我们的辅助方法完成游戏。
- en: All that's left to do now is update the scores.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是更新分数。
- en: Time for action – updating scores
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动——更新分数
- en: Time to type the last method in the game.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在游戏中输入最后一个方法了。
- en: 'We start by playing a nice effect for a goal and stopping our ball:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先播放一个漂亮的进球效果，并停止我们的球：
- en: '[PRE32]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we update the score for the scoring player, updating the score label in
    the process. And the ball moves to the court of the player against whom a point
    was just scored:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们更新得分的玩家的分数，在这个过程中更新分数标签。并且球移动到刚刚得分的玩家的球场：
- en: '[PRE33]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The players are moved to their original position and their `_touch` properties
    are cleared:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 玩家被移动到他们的原始位置，并且他们的 `_touch` 属性被清除：
- en: '[PRE34]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*What just happened?*'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Well, guess what! You just finished your first game in Cocos2d-x. We charged
    forward at a brisk pace for our first game, but we managed to touch on almost
    every area of game development with Cocos2d-x in the process.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，猜猜看！你刚刚完成了你的第一个 Cocos2d-x 游戏。我们以快速的速度完成了第一个游戏，但我们在过程中几乎触及了 Cocos2d-x 游戏开发的每一个领域。
- en: If you click **Run** now, you should be able to play the game. In the source
    code for this chapter, you should also find the complete version of the game if
    you run into any problems.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在点击 **运行**，你应该能够玩游戏。如果你在运行本章的源代码时遇到任何问题，你也应该找到游戏的完整版本。
- en: Time to take this to Android!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将这个游戏带到 Android 平台上了！
- en: Time for action – running the game in Android
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动——在 Android 上运行游戏
- en: Time to deploy the game to Android.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将游戏部署到 Android 平台上了。
- en: Follow the instructions from the `HelloWorld` example to import the game into
    Eclipse.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照从 `HelloWorld` 示例中的说明来将游戏导入到 Eclipse 中。
- en: Navigate to the `proj.android` folder and open the `AndroidManifest.xml` file
    in a text editor. Then, go to the `jni` folder and open the `Android.mk` file
    in a text editor.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `proj.android` 文件夹，在文本编辑器中打开 `AndroidManifest.xml` 文件。然后，转到 `jni` 文件夹，在文本编辑器中打开
    `Android.mk` 文件。
- en: 'In the `AndroidManifest.xml` file, edit the following line in the `activity`
    tag:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AndroidManifest.xml` 文件中，编辑 `activity` 标签中的以下行：
- en: '[PRE35]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And it''s possible to target only tablets by adding these lines in the `supports-screens`
    tag:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `supports-screens` 标签中添加这些行，你可以仅针对平板电脑进行目标定位：
- en: '[PRE36]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Although if you want to target only tablets, you might also wish to target
    the later versions of SDK, like this:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然如果你只想针对平板电脑，你可能还希望针对 SDK 的后续版本，如下所示：
- en: '[PRE37]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, let''s edit the make file, so open the `Android.mk` file and edit the
    lines in `LOCAL_SRC_FILES` to read:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们编辑 make 文件，所以打开 `Android.mk` 文件，并编辑 `LOCAL_SRC_FILES` 中的行，使其读取：
- en: '[PRE38]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Save it and run your application (don't forget to connect an Android device,
    in this case, a tablet if you used the settings as explained here).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存它并运行你的应用程序（别忘了连接一个 Android 设备，在这种情况下，如果你使用了这里解释的设置，那么是一个平板电脑）。
- en: '*What just happened?*'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: And that's it! You can edit these files inside Eclipse as well.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你还可以在 Eclipse 中编辑这些文件。
- en: When you build a Cocos2d-x project in the command line, you see a message saying
    that the `hellocpp` target is being renamed. But I think this is still a bug in
    the build script and usually correcting that in the make file and the folder structure
    creates a much bigger headache. So for now, stick to the strangely named `hellocpp`
    in `Android.mk`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在命令行中构建 Cocos2d-x 项目时，你会看到一个消息说 `hellocpp` 目标正在重命名。但我认为这仍然是构建脚本中的错误，通常在 make
    文件和文件夹结构中纠正它会带来更大的麻烦。所以现在，坚持使用 `Android.mk` 中的奇怪命名的 `hellocpp`。
- en: Have a go hero
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄，试试看
- en: Make any changes to the code. For instance, add an extra label and then publish
    again from Eclipse. You may find that working with the project in this IDE is
    faster than Xcode.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对代码进行任何修改。例如，添加一个额外的标签，然后从 Eclipse 重新发布。你可能发现在这个 IDE 中与项目一起工作比 Xcode 快。
- en: Sadly, sooner or later, Eclipse will throw one of its infamous tantrums. A common
    problem that occurs if you have many projects open in your navigator is for one
    or many of the projects to report an error like **Cannot find the class file for
    java.lang.Object** or **The type java.lang.Object cannot be resolved**. Get into
    the habit of cleaning your project and building it as soon as you open Eclipse
    and keeping only active projects opened, but even that might fail you. The solution?
    Restart Eclipse, or better yet, delete the project from the navigator (but not
    from the disk!) and reimport it. Yeah, I know. Welcome to Eclipse!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，迟早，Eclipse 会抛出它臭名昭著的脾气。如果你在导航器中打开了多个项目，常见的问题之一是其中一个或多个项目报告错误，例如**找不到java.lang.Object类文件**或**无法解析java.lang.Object类型**。养成在打开
    Eclipse 后立即清理项目并构建它的习惯，只保留打开的活动项目，但即使这样也可能失败。解决方案？重启 Eclipse，或者更好的方法是，从导航器（但不是从磁盘！）中删除项目，然后重新导入它。是的，我知道。欢迎来到
    Eclipse！
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You now know how to add sprites and labels, and how to add support for two screen
    resolutions as well as support for multitouch. There are quite a few ways to create
    sprites other than by passing it an image filename, and I'll show examples of
    these in the games to come.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道了如何添加精灵和标签，以及如何添加对两种屏幕分辨率的支持以及多点触控的支持。除了传递一个图像文件名之外，还有许多创建精灵的方法，我将在接下来的游戏中展示这些示例。
- en: '`LabelTTF` won''t be used as much in this book. Generally, they are good for
    large chunks of text and text that is not updated too frequently; we''ll use bitmap
    fonts from now on.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，`LabelTTF` 将不会使用得太多。通常，它们适用于大量文本和不太频繁更新的文本；从现在起，我们将使用位图字体。
- en: So, let's move on to the next game and animations. I promise I won't make you
    type as much. You should get your friend to do it for you!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们继续进行下一款游戏和动画。我保证不会让你打太多字。你应该让你的朋友帮你打字！
