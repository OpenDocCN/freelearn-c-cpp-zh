- en: Domain-Specific Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we developed the games Othello and Noughts and Crosses
    with the Qt library. In this chapter, we will start to develop a **Domain-Specific
    Language** (**DSL**), which is a language intended for a specific domain. More
    specifically, we will develop a language for writing graphical objects in a Qt
    widget. The language allows us to draw lines, rectangles, ellipses, and to write
    text. Moreover, it does allow us to choose color as well as pen and brush style
    for the graphical objects. It also allows us to choose font and alignment for
    the text.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics we will cover in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: First, we will informally look into the source code of our DSL by looking at
    an example. We will draw graphical objects and set their color, style, and font.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will formally define our language with grammar.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have defined the grammar, we write the scanner. The scanner reads the
    source code and recognizes meaningful sequences of characters, called **tokens**.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have written the scanner, we write the parser. The parser can be considered
    the heart of our DSL. It requests new tokens from the scanner, when needed. It
    checks that the source code complies with the grammar, and it generates a sequence
    of actions. Each action holds an instruction, such as setting the color or drawing
    a line.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we write a viewer that reads the action sequence generated by the parser
    and displays the graphical objects in a Qt widget.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the source language – a simple example
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source language of our DSL is made up by a sequence of instructions. There
    are instructions for drawing graphical objects such as lines, rectangles, ellipses,
    and text. We also have instructions for setting the color and style of the objects
    as well as font and alignment of the text. Finally, there is instruction for assigning
    values to a name.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example. The following code draws a rectangle and writes
    text. Note that the language is not case-sensitive, that is, it does not matter
    whether we use small or capital letters in our code. We start by defining the
    top-left corner of a rectangle:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use the coordinate operators to extract the *x* and *y* coordinates of the
    top-left point and define the bottom-right corner:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We use the predefined values `DashLine` and `CrossPatterns` to set the style
    of the pen and brush:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We use the predefined color `Black` for the pen and create our own color `Purple`
    for the brush. We can create a new color with three values corresponding to their
    red, green, and blue components. Each component can hold a value between 0 and
    255, inclusive:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We continue to add a text, with font and alignment. We choose `12` point `Times
    New Roman` with left horizontal alignment and top vertical alignment:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The instructions of this example will be divided into meaningful parts by the
    scanner; the parser will check that the instructions comply with the grammar and
    generate a sequence of actions read by the viewer and display the following Qt
    widget:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30203c62-df0f-49a5-9e2a-e676d1dafdbf.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: The grammar of the source language
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source language of our DSL needs to be exactly defined. We do that by defining grammarfor
    the language. Grammar is made up by rules (in *italic* style), keywords (in **bold**
    style), separations, and punctuations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The `program` rule is the start rule. The arrow (`->`) means that a program
    is made up by an instructions list. The arrow can be read as:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the grammar, an asterisk (`*`) means **zero** or **more**. Hence, an instruction
    list is made up by zero or more instructions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The assignment instruction takes a name followed by the assignment operator
    (`=`), an expression, and a semicolon. The instructions for setting the pen and
    brush color and style take one expression, so do the settings of the font and
    alignment. The instructions for drawing lines, rectangles, and text take two expressions.
    Note that every instruction is terminated by a semicolon (`;`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertical bar (`|`) can be read as **or**. An instruction is an assignment
    orthe setting of the pen color orthe setting of the brush color, and so on:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next part of the parser to define is the expressions. First, we look at
    the operators of the expressions. We also have to look into the priority of the
    operators. For instance, multiplication and division have higher priority than
    addition and subtraction. The operators of the grammar have the following priorities:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Operator** | **Priority** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| Addition Subtraction | `+ -` | Lowest |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| Multiplication Division | `* /` |  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| Primary | `point``xCoordinate``yCoordinate``color``font``(expression)``name``value`
    | Highest |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: 'We define two rules each for addition and subtraction, as well as for multiplication
    and division. We start with the lowest priority level, which is addition and subtraction.
    In the `expression` rule we call the `mulDivExpression` rule, which handles multiplication
    and division expressions, and we call the `expressionRest` rule to examine the
    rest of the expression:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `expressionRest` rule we look into the next token. If it is a plus or
    a minus, we have an addition or subtraction expression. We call `mulDivExpression`
    to handle expressions of higher priority. Finally, we call the `expressionRest`
    rule again in case of another plus or minus. However, if the first token is neither
    a plus nor a minus,  we do nothing:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`mulDivExpression` and `mulDivExpressionRest` work in the same way as `expression`
    and `expressionRest` shown previously:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The primary expression is a point, an *x* or *y* coordinate, a color, a font,
    a name, or a value. A point is made up by two expressions holding the *x* and
    *y* coordinate of the point. A coordinate takes an expression holding a point
    and gives it an *x* or *y* coordinate:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A color expression is made up by its red, green, and blue components, while
    a font expression is made up by the name and size of the font:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An expression can be enclosed in parentheses in order to change the priority
    of the expression. For instance, in the expression 2 + 3 x 4, multiplication takes
    precedence over addition, but in the expression (2 + 3) x 4, addition takes precedence
    over multiplication:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, an expression can be a name earlier associated with a value, or simply
    a value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The target language
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The target language is defined by a sequence of actions. Informally, the actions
    correspond to the instructions of the grammar. We have actions for setting the
    color or style of a pen or a brush, and for setting the horizontal or vertical
    alignment of the text, as well as actually drawing the lines, rectangles, ellipses,
    and text of the drawing. Later in this chapter, we will write a parser that generates
    a sequence of actions, and a viewer that reads the actions and displays graphical
    objects in a Qt widget.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: An `Action` object holds the identity of the action (which is defined by the
    `TokenId` enumeration in the `Token` class, as follows) together with, at most,
    two values.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**Action.h:**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Action.cpp` file holds the definitions of the methods of the `Action` class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**Action.cpp:**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The constructor takes the action identity and at most two values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The colors
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When setting the color of the pen or brush, we need to submit the color with
    the instruction. We can use the color rule in the preceding grammar to create
    our own color. However, there is a set of predefined colors of the Qt class `QColor`.
    The following scanner defines a set of predefined `QColor` objects (`Aqua`, `Black`,
    ...) and maps them to their names. For instance, the user can write the following
    instruction in the source code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In that case, since the name `Aqua` is associated with the `QColor` object `Aqua`,
    the pen color is set to `Aqua`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**Colors.h:**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Colors.cpp` file holds the definitions of the colors in the `Colors.h`
    file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '**Colors.cpp:**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each color is defined by its red, green, and blue component. Each component
    holds a value from 0 to 255, inclusive. For instance, the `Blue` color holds the
    full value of the blue component and zero of the other components, while `Yellow`
    is a blend of red and green:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Error handling
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some functions for error handling: `check` checks whether a condition
    is true and reports an error if it is not. The `syntaxError` and `semanticError`
    functions report a syntactic and semantic error, while `error` throws an exception
    that is caught and reported by the `main` function.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**Error.h:**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Error.cpp` file holds the definitions of the `Error.h` file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**Error.cpp:**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We use the C++ `stringstream` standard class to compound the error message:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `str` method returns an object of the C++ `string` standard class, and
    `c_str` returns a character pointer that is converted to a `QString` object in
    the `error` call:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A syntax error occurs when the scanner finds a character sequence that does
    not constitute a token, or when the parser detects that the token sequence does
    not comply with the grammar. We will cover the topic soon; for now, just remember
    that a scanner can report errors too:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A semantic error occurs when an unknown name is found, or when the types of
    an expression do not comply:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `check` method has a similar effect to the `assert` macro. It checks whether
    the condition is true. If it is not true, `semanticError` is called, which eventually
    throws an error exception:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The value
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several kinds of values in the language, which are used to set the
    color or style of the pen or brush, or to set the end-points of a line, or to
    set the name of the font, or the alignment of the text: numerical (`double`),
    string (`QString`), color (`QColor`), font (`QFont`), point (`QPoint`), pen style
    (`Qt::PenStyle`), brush style (`Qt`::`BrushStyle`), and horizontal or vertical
    alignment (`Qt`::`AlignmentFlag`).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '**Value.h:**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Value.cpp` file holds the definitions of the methods of the `Value` class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**Value.cpp:**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The non-default constructors initialize the `Value` object with appropriate
    values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The scanner
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **scanner** is a part of the application that accepts the source code and
    generates a sequence of tokens. A **token** is the smallest meaningful part of
    the source code. For instance, the characters **f**, **o**, **n**, and **t** make
    up the keyword **font**, and the characters **1**, **2**, and **3** constitute
    the numerical value **123**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: However, first we need the `Token` class to keep track of the tokens. The `m_tokenId`
    field is set to a value of the enumeration `TokenId`. In the case of a name, the
    `m_name` field holds the name, and in the case of a value, the `m_value` field
    holds the value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**Token.h:**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `TokenId` enumeration holds all the tokens of the scanner. They are divided
    into keywords, operators, punctuation, and separators, as well as names and values.
    In order to avoid converting between different enumerations, the `TokenId` enumeration
    is used by the scanner, parser, and viewer. The `TokenId` enumeration is used
    by the scanner to distinguish between the different tokens by the parser when
    type checking and evaluating expressions, and by the `Action` class to distinguish
    between different actions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part (`ColorId` to `YCoordinateId`) is keywords of the language:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The second part (`AddId` to `DivideId`) is operators:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next part is parentheses, assignment (`=`), comma, and semicolon:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, the last part is the name, value, and end-of-file marking:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Each token can be annotated with a name or a value:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Token.cpp` file holds the definitions of the methods of the `Token` class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '**Token.cpp:**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The default token is initialized with an end-of-file token:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Most tokens hold only a value of the `TokenId` enumeration:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Tokens can also hold a name or a value:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Scanner` class takes the source code and divides it into tokens. A token
    can also be associated by a name or a value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**Scanner.h:**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `init` method initializes the names of the keywords and operators:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `nextToken` method scans the buffer and returns the next token. If there
    is no recognizable token, an error exception is thrown that is later caught by
    the `main` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `m_buffer` field holds the source code; `m_bufferIndex` holds the index
    of the next character in the buffer to be examined (the index is initialized to
    zero); `m_keywordMap` holds the names of the keywords; `m_valueMap` holds a map
    of color, alignment, and pen and brush style values, and `m_operatorList` hold
    a list of operators:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In previous chapters, we have used the C++ standard classes `map`, `set`, `list`,
    `vector`, and `stack`. In this chapter, we will use the Qt classes `QMap`, `QSet`,
    `QList`, `QVector`, and `QStack` instead. They work approximately in the same
    way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Scanner.cpp` file holds the definitions of the methods of the `Scanner`
    class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**Scanner.cpp:**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `g_lineNo` global field keeps track of the current line in the source code,
    in order for the error messages to state the line number:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `ADD_TO_OPERATOR_LIST` macro adds a token to the operator list. For instance,
    `ADD_TO_OPERATOR_LIST("+", AddId)` adds the pair of `"+"` and `AddId` to the list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `ADD_TO_KEYWORD_MAP` macro adds a keyword to the keyword map. For instance,
    `ADD_TO_KEYWORD_MAP(ColorId)` adds the pair of `Color` and `ColorId` to the map.
    Note that the `Id` part of the keyword (the last two characters) text is removed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `ADD_TO_VALUE_MAP` macro adds a value to the value map. For instance, `ADD_TO_VALUE_MAP(Aqua)`
    adds the pair of aqua and the `QColor` object Aqua to the map. Note that the text
    is converted to lower case. Also note that only the last part after the last potential
    pair of colons (`::`) is included:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`ADD_TO_VALUE_MAP(Qt::AlignLeft)` adds the pair of align left and the `Qt::PenStyle`
    value to the map. Again, note that only the last segment of the value''s name
    is stored as text:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the constructor, we load the buffer into the `m_buffer` field. We also add
    the null-character (`''''`) in order to find the end of the buffer in an easier
    way:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `nextToken` method scans the buffer and returns the token found. First,
    we iterate as long as we find new-line, white-space, or line comment. In case
    of a new line, we increase the line count:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A white-space is regular space, a horizontal or vertical tabulator, a return
    character, or new line. We use the `isSpace` method to check whether the character
    is a white-space:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we encounter the beginning of a line comment (`//`), we continue until we
    find the end of the line (`''n''`) or the end of the buffer (`''''`):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If we do not find a new line, white-space, or line comment, we break the iteration
    and continue looking for the next token:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When we have scanned through the potential white-spaces and comments, we start
    looking for the real tokens. We start by checking if the next character in the
    buffer is a null character (`''''`). If it is a null character, we have found
    the end of the source code and return end-of-file. Remember that we added a null
    character at the end of the buffer in the constructor, just to be able to recognize
    the end of the file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the next token is not end-of-file, we check if it is an operator. We iterate
    through the operator list and check if the buffer begins with any of the operator''s
    text. For instance, the add operator holds the text `+`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When we have found the operator, we increment the buffer index, and return
    the token:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If the buffer does not begin with an operator, we look after a name representing
    a keyword, a value, or simply a name. We start by checking if the buffer begins
    with a letter or the underscore character (`''_''`), since a name is allowed to
    start with a letter or an underscore. However, the remaining characters can be
    digits besides the letters and underscores:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We iterate until we find a character that is not a letter, digit, or underscore:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We extract the text and increase the buffer index:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The text can hold a keyword, a value, or a name. First, we check whether the
    text is present in the keyword map. If it is present, we just return the token
    associated with the keyword text:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We then check whether the text is present in the value map. If it is present,
    we return a value token with the value annotated to the token. The value can later
    be obtained by the parser:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If the text is neither a keyword nor a value, we assume that it is a name and
    return a name token with the name annotated to the token. The name can later be
    obtained by the parser:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When we have looked for a name without finding it, we start looking for a string
    instead. A string is a text enclosed by double quotes (`''"''`). If the next character
    in the buffer is a double quote, it is the beginning of a text. We remove the
    double quote from the buffer and iterate until we find the end quote of the text:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we find a null character before the end of the text, a syntax error is reported
    since we have found the end of the file inside the text:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When we have found the end quote, we increase the buffer index and return a
    value token with the text as its annotated value. The text can later be obtained
    by the parser:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If the next character in the buffer is a digit, we have found a numerical value,
    with or without decimals. First, we iterate as long as we find digits in the buffer:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When we no longer find any digits, we check whether the next character in the
    buffer is a dot (`''.''`). If it is a dot, we continue to iterate as long as we
    find digits:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When we no longer find any digits, we increase the buffer index and return
    a value token with the annotated value. The value can later be obtained by the
    parser:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, if none of the preceding cases apply, the source code is syntactically
    incorrect, and we report a syntax error:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We return an end-of-file token, simply because we have to return a value. However,
    we will never reach this point of the code since the `syntaxError` call caused
    an exception to be thrown:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now that we have looked at the scanner, we will continue to look at the parser
    in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Building the parser
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have looked into the scanner, it is time to move on to the parser.
    The parser checks that the source code complies with the grammar. It also performs
    type checking and generates the action list, which is later displayed by the viewer,
    as follows. The `Parser` class mirrors the grammar in that way the it holds one
    method for each grammar rule.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**Parser.h:**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The constructor takes a grammar object and the action list, which is empty
    at the beginning. The parser calls the scanner each time it needs a new token:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `match` method checks whether the given token equals the next token obtained
    by the scanner. If it does not, a syntax error is reported:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The remaining methods of the `Parser` class are divided into methods for instructions
    and expressions in the grammar, as well as methods for type checking and evaluation
    of expressions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We also add a method to the parser for each expression rule in the grammar:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'When evaluating the values of expressions, we need to check the types of the
    values. For instance, when adding two values, both of the operands shall have
    numerical values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `m_lookAhead` field holds the next token obtained by the scanner, and `m_scanner`
    holds the scanner itself. The `m_actionList` field holds a reference to the action
    list given in the constructor. Finally, `m_assignMap` holds a map for the names
    assigned to values by the assignment rule:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `Parser.cpp` file holds the definitions of the methods of the `Parser` class.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**Parser.cpp:**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The constructor initializes the references to the scanner and the action list,
    and sets the `m_lookAHead` field to the first token obtained by the scanner. Then
    the parsing process begins by calling `instructionList`. When the instruction
    list has been parsed, the only remaining token shall be the end-of-file token:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `g_lineNo` field keeps track of the current line of the source code so
    that a syntax error can be reported with the correct line number:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `instructionList` method keeps iterating until it encounters the end-of-file
    token:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `match` method compares the next token obtained by the scanner with the
    given token. If they do not comply, a syntax error is reported. If they do comply,
    the next token is obtained by the scanner:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Parsing the instructions of the language
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `instruction` method holds a sequence of switch cases, one case for each
    category of instructions. We will look into the next token obtained by the scanner:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In the case of a name, we parse the name, assignment (`=`), the following expression,
    and a semicolon:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If the name is already associated with a value, a semantic error is reported:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The settings of pen and brush colors and styles, as well as fonts and alignments,
    are a little bit more complicated. We call `expression` to parse and evaluate
    the value of an expression. The type of the expression is checked, and an `Action`
    object is added to the action list:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The drawing of lines, rectangles, ellipses, and text takes two expressions,
    whose values are evaluated and type checked:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'If none of the preceding tokens apply, a syntax error is reported:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Parsing the expressions of the language
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An expression, at its lowest priority level, is made up by two multiplication
    or division expressions. First, we call `mulDivExpression`, which is the next
    expression in increasing priority order, to obtain the left value of a possible
    addition or subtraction expression, and then `expressionRest`, which checks if
    there actually is such an expression:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `expressionRest` method checks whether the next token is a plus or a minus.
    In that case, we have an addition or subtraction expression, the token is matched,
    the left and right values are type checked, and the resulting expression is evaluated
    and returned:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `mulDivExpression` method works in a way similar to `expression` shown
    previously. It calls `primaryExpression` and `mulDivExpressionRest`, which look
    for multiplication and division. Multiplication and division have higher priority
    than addition and subtraction. As stated in *The grammar of source language* section
    previously, we need a new pair of rules in the grammar, with two pairs of methods
    in the parser for the addition/subtraction and multiplication/division expressions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Finally, the primary expression is made up by a point, coordinate, color, or
    font expression. It can also be made up by an expression enclosed in parentheses,
    a name (in which case we look up its value), or a value:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The coordinate expression takes a point and returns its x or y coordinate.
    We match the keyword and the parentheses and call expressions in between. We then
    check that the value of the expression is a point, and finally call `evaluate`
    to extract the *x* or *y* coordinate:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'A point expression is made up by the keyword `point` and two numerical expressions:
    the *x* and *y* coordinate:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'A color expression is made up by the keyword `color` and three numerical expressions:
    the red, green, and blue components:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'A font expression is made up by the keyword `font` and two expressions: the
    name of the font (string) and its size (numerical):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'An expression can be enclosed by parentheses. In that case, we match the parentheses
    and call `expression` in between to obtain the value of the expression:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In case of a name, we look up its value in the assignment map and return the
    value. If there is no value, a semantic error is reported:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In the case of a value, we simply return the value:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In any other case, a syntax error is reported:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Type checking the expression
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first `checkType` method checks the type of an expression with one value.
    When setting a pen or brush style, the type must be a pen or brush style, respectively:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'When setting a color or a font, the value must be a color or a font, respectively:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'When setting an alignment, the value must be an alignment:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When extracting the *x* or *y* coordinate from a point, the value must be a
    point:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The second `checkType` method takes two values. The drawing instructions must
    take two points:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The drawing of text instructions must take a point and a string:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Evaluating the values of the expressions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first `evaluate` method returns the value of an expression with one value.
    The *x* and *y* coordinate operators return the *x* or *y* coordinate of the point:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The assertion is for debugging purposes only, and we return false simply because
    the method has to return a value:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Finally, the second `evaluate` method evaluates the value of expressions with
    two values. First, we extract numerical values and evaluate the arithmetic expressions:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In case of division by zero, a semantic error is reported:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Finally, in the point expression, we return a point value holding the two numerical
    values holding its *x* and *y* coordinates:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'As in the first evaluate case previously, the assertion is for debugging purposes
    only, and we return false simply because the method has to return a value:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The viewer
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, it is time to write the viewer, the last part of our DSL. The viewer
    iterates through the actions and displays the graphical objects. The `ViewerWidget`
    class inherits the Qt class `QWidget`, which displays a widget on the screen.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**ViewerWidget.h:**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The constructor calls the constructor of the base class `QWidget` and stores
    a reference to the action list:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The main part of the class is the `paintEvent` method. It gets called every
    time the widget needs to be repainted and iterates through the actions list:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The default constructor of `QFont` is called, which initializes the font to
    an appropriate system font. Both the horizontal and vertical alignment is centered.
    Finally, `m_actionList` holds a reference to the action list generated by the
    parser:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The `ViewerWidget.cpp` file holds the definitions of the methods of the `ViewerWidget`
    class.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '**ViewerWidget.cpp:**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The constructor calls the constructor of the base class `QWidget` with the
    parent widget, initializes the `m_actionList` reference, sets the title of the
    widget, and sets an appropriate size:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The `paintEvent` method is called every time the widget needs to be repainted.
    First, the `QPainter` object `painter` is defined, we then iterate through the
    action list:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `SetPenColor` action creates a new pen with the new color and current style,
    which is added to `painter`. In the same way, the `SetPenStyle` action creates
    a pen with the new style and the current color:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We set the color and style of the brush in the same way as we set the pen previously.
    The only difference is that we create a brush instead of a pen:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In the case of the font, we call `setFont` on `painter`. Thereafter, the font
    is associated to `painter`, and will be used when writing text:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The horizontal and vertical alignment are stored in `m_horizontalAlignment`
    and `m_verticalAlignment`, which are values that are later used when writing text:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, it is time to actually draw some graphical objects. A line is simply drawn
    between two points, while a rectangle or ellipse has top-left and bottom-right
    corners, which are placed in a rectangle that is used as a parameter to the calls
    to `drawRect` and `drawEllipse`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Finally, we write text. We start by extracting the point to center the text
    around and the text to draw. We then obtain the size of the text (in pixels) with
    the Qt `QFontMetrics` class:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'In the case of left horizontal alignment, the left side of the text is the
    *x* coordinate of the point. In the case of center alignment, the left side of
    the text is moved to the left with half the text width, and in the case of right
    alignment, the left side is moved to the left with the whole text width:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'In the same way: in the case of top vertical alignment, the top side of the
    text is the *y* coordinate of the point. In the case of center alignment, the
    top side of the text is moved upwards with half of the text height, and in the
    case of bottom alignment, the top side is moved upwards with the whole text height:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The main function
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, the main function calls the `init` static method on the scanner in
    order to initialize its tokens, keywords, and values. A `QApplication` object
    is created, the source code is read and parsed, and the viewer widget is created.
    It executes the action list and displays the graphical objects. The application
    executes until the user presses the close button in the top-right corner.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'In the case of a syntactic or semantic error, its message is displayed in a
    message box:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started to develop a DSL that generates a sequence of actions
    creating graphical objects, which are viewed in a widget. Our DSL supports instructions
    for drawing graphical objects such as lines, rectangles, ellipses, and text, and
    for setting the color, style, and alignment of the objects. It also supports expressions
    with arithmetic operators.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The language of our DSL is defined by grammar and is made up by a scanner that
    scans the text for meaningful parts, the parser checks that the source code complies
    with the grammar and generates a sequence of actions, which is read and executed
    by the viewer.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们领域特定语言（DSL）的语法由语法规则定义，并由一个扫描器组成，该扫描器扫描文本以查找有意义的部分，解析器检查源代码是否符合语法，并生成一系列动作，这些动作由查看器读取并执行。
- en: In the next chapter, we will continue to develop our DSL. The DSL of this chapter
    only supports code executed in straight sequence. However, in the next chapter,
    we will add function calls as well as selection and iteration (the `if` and `while`
    instructions).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续开发我们的DSL。本章的DSL仅支持按顺序执行的代码。然而，在下一章中，我们将添加函数调用以及选择和迭代（`if`和`while`指令）。
