- en: Domain-Specific Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we developed the games Othello and Noughts and Crosses
    with the Qt library. In this chapter, we will start to develop a **Domain-Specific
    Language** (**DSL**), which is a language intended for a specific domain. More
    specifically, we will develop a language for writing graphical objects in a Qt
    widget. The language allows us to draw lines, rectangles, ellipses, and to write
    text. Moreover, it does allow us to choose color as well as pen and brush style
    for the graphical objects. It also allows us to choose font and alignment for
    the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will informally look into the source code of our DSL by looking at
    an example. We will draw graphical objects and set their color, style, and font.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will formally define our language with grammar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have defined the grammar, we write the scanner. The scanner reads the
    source code and recognizes meaningful sequences of characters, called **tokens**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have written the scanner, we write the parser. The parser can be considered
    the heart of our DSL. It requests new tokens from the scanner, when needed. It
    checks that the source code complies with the grammar, and it generates a sequence
    of actions. Each action holds an instruction, such as setting the color or drawing
    a line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we write a viewer that reads the action sequence generated by the parser
    and displays the graphical objects in a Qt widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the source language – a simple example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source language of our DSL is made up by a sequence of instructions. There
    are instructions for drawing graphical objects such as lines, rectangles, ellipses,
    and text. We also have instructions for setting the color and style of the objects
    as well as font and alignment of the text. Finally, there is instruction for assigning
    values to a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example. The following code draws a rectangle and writes
    text. Note that the language is not case-sensitive, that is, it does not matter
    whether we use small or capital letters in our code. We start by defining the
    top-left corner of a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the coordinate operators to extract the *x* and *y* coordinates of the
    top-left point and define the bottom-right corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the predefined values `DashLine` and `CrossPatterns` to set the style
    of the pen and brush:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the predefined color `Black` for the pen and create our own color `Purple`
    for the brush. We can create a new color with three values corresponding to their
    red, green, and blue components. Each component can hold a value between 0 and
    255, inclusive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue to add a text, with font and alignment. We choose `12` point `Times
    New Roman` with left horizontal alignment and top vertical alignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The instructions of this example will be divided into meaningful parts by the
    scanner; the parser will check that the instructions comply with the grammar and
    generate a sequence of actions read by the viewer and display the following Qt
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30203c62-df0f-49a5-9e2a-e676d1dafdbf.png)'
  prefs: []
  type: TYPE_IMG
- en: The grammar of the source language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source language of our DSL needs to be exactly defined. We do that by defining grammarfor
    the language. Grammar is made up by rules (in *italic* style), keywords (in **bold**
    style), separations, and punctuations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `program` rule is the start rule. The arrow (`->`) means that a program
    is made up by an instructions list. The arrow can be read as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the grammar, an asterisk (`*`) means **zero** or **more**. Hence, an instruction
    list is made up by zero or more instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The assignment instruction takes a name followed by the assignment operator
    (`=`), an expression, and a semicolon. The instructions for setting the pen and
    brush color and style take one expression, so do the settings of the font and
    alignment. The instructions for drawing lines, rectangles, and text take two expressions.
    Note that every instruction is terminated by a semicolon (`;`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertical bar (`|`) can be read as **or**. An instruction is an assignment
    orthe setting of the pen color orthe setting of the brush color, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the parser to define is the expressions. First, we look at
    the operators of the expressions. We also have to look into the priority of the
    operators. For instance, multiplication and division have higher priority than
    addition and subtraction. The operators of the grammar have the following priorities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Operator** | **Priority** |'
  prefs: []
  type: TYPE_TB
- en: '| Addition Subtraction | `+ -` | Lowest |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplication Division | `* /` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Primary | `point``xCoordinate``yCoordinate``color``font``(expression)``name``value`
    | Highest |'
  prefs: []
  type: TYPE_TB
- en: 'We define two rules each for addition and subtraction, as well as for multiplication
    and division. We start with the lowest priority level, which is addition and subtraction.
    In the `expression` rule we call the `mulDivExpression` rule, which handles multiplication
    and division expressions, and we call the `expressionRest` rule to examine the
    rest of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `expressionRest` rule we look into the next token. If it is a plus or
    a minus, we have an addition or subtraction expression. We call `mulDivExpression`
    to handle expressions of higher priority. Finally, we call the `expressionRest`
    rule again in case of another plus or minus. However, if the first token is neither
    a plus nor a minus,  we do nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`mulDivExpression` and `mulDivExpressionRest` work in the same way as `expression`
    and `expressionRest` shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary expression is a point, an *x* or *y* coordinate, a color, a font,
    a name, or a value. A point is made up by two expressions holding the *x* and
    *y* coordinate of the point. A coordinate takes an expression holding a point
    and gives it an *x* or *y* coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A color expression is made up by its red, green, and blue components, while
    a font expression is made up by the name and size of the font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'An expression can be enclosed in parentheses in order to change the priority
    of the expression. For instance, in the expression 2 + 3 x 4, multiplication takes
    precedence over addition, but in the expression (2 + 3) x 4, addition takes precedence
    over multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, an expression can be a name earlier associated with a value, or simply
    a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The target language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The target language is defined by a sequence of actions. Informally, the actions
    correspond to the instructions of the grammar. We have actions for setting the
    color or style of a pen or a brush, and for setting the horizontal or vertical
    alignment of the text, as well as actually drawing the lines, rectangles, ellipses,
    and text of the drawing. Later in this chapter, we will write a parser that generates
    a sequence of actions, and a viewer that reads the actions and displays graphical
    objects in a Qt widget.
  prefs: []
  type: TYPE_NORMAL
- en: An `Action` object holds the identity of the action (which is defined by the
    `TokenId` enumeration in the `Token` class, as follows) together with, at most,
    two values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Action.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Action.cpp` file holds the definitions of the methods of the `Action` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Action.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor takes the action identity and at most two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When setting the color of the pen or brush, we need to submit the color with
    the instruction. We can use the color rule in the preceding grammar to create
    our own color. However, there is a set of predefined colors of the Qt class `QColor`.
    The following scanner defines a set of predefined `QColor` objects (`Aqua`, `Black`,
    ...) and maps them to their names. For instance, the user can write the following
    instruction in the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In that case, since the name `Aqua` is associated with the `QColor` object `Aqua`,
    the pen color is set to `Aqua`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Colors.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Colors.cpp` file holds the definitions of the colors in the `Colors.h`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Colors.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Each color is defined by its red, green, and blue component. Each component
    holds a value from 0 to 255, inclusive. For instance, the `Blue` color holds the
    full value of the blue component and zero of the other components, while `Yellow`
    is a blend of red and green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some functions for error handling: `check` checks whether a condition
    is true and reports an error if it is not. The `syntaxError` and `semanticError`
    functions report a syntactic and semantic error, while `error` throws an exception
    that is caught and reported by the `main` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `Error.cpp` file holds the definitions of the `Error.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Error.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the C++ `stringstream` standard class to compound the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `str` method returns an object of the C++ `string` standard class, and
    `c_str` returns a character pointer that is converted to a `QString` object in
    the `error` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A syntax error occurs when the scanner finds a character sequence that does
    not constitute a token, or when the parser detects that the token sequence does
    not comply with the grammar. We will cover the topic soon; for now, just remember
    that a scanner can report errors too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A semantic error occurs when an unknown name is found, or when the types of
    an expression do not comply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `check` method has a similar effect to the `assert` macro. It checks whether
    the condition is true. If it is not true, `semanticError` is called, which eventually
    throws an error exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several kinds of values in the language, which are used to set the
    color or style of the pen or brush, or to set the end-points of a line, or to
    set the name of the font, or the alignment of the text: numerical (`double`),
    string (`QString`), color (`QColor`), font (`QFont`), point (`QPoint`), pen style
    (`Qt::PenStyle`), brush style (`Qt`::`BrushStyle`), and horizontal or vertical
    alignment (`Qt`::`AlignmentFlag`).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `Value.cpp` file holds the definitions of the methods of the `Value` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Value.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-default constructors initialize the `Value` object with appropriate
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **scanner** is a part of the application that accepts the source code and
    generates a sequence of tokens. A **token** is the smallest meaningful part of
    the source code. For instance, the characters **f**, **o**, **n**, and **t** make
    up the keyword **font**, and the characters **1**, **2**, and **3** constitute
    the numerical value **123**.
  prefs: []
  type: TYPE_NORMAL
- en: However, first we need the `Token` class to keep track of the tokens. The `m_tokenId`
    field is set to a value of the enumeration `TokenId`. In the case of a name, the
    `m_name` field holds the name, and in the case of a value, the `m_value` field
    holds the value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Token.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `TokenId` enumeration holds all the tokens of the scanner. They are divided
    into keywords, operators, punctuation, and separators, as well as names and values.
    In order to avoid converting between different enumerations, the `TokenId` enumeration
    is used by the scanner, parser, and viewer. The `TokenId` enumeration is used
    by the scanner to distinguish between the different tokens by the parser when
    type checking and evaluating expressions, and by the `Action` class to distinguish
    between different actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part (`ColorId` to `YCoordinateId`) is keywords of the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part (`AddId` to `DivideId`) is operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part is parentheses, assignment (`=`), comma, and semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last part is the name, value, and end-of-file marking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Each token can be annotated with a name or a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `Token.cpp` file holds the definitions of the methods of the `Token` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Token.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The default token is initialized with an end-of-file token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Most tokens hold only a value of the `TokenId` enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Tokens can also hold a name or a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `Scanner` class takes the source code and divides it into tokens. A token
    can also be associated by a name or a value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scanner.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init` method initializes the names of the keywords and operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nextToken` method scans the buffer and returns the next token. If there
    is no recognizable token, an error exception is thrown that is later caught by
    the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_buffer` field holds the source code; `m_bufferIndex` holds the index
    of the next character in the buffer to be examined (the index is initialized to
    zero); `m_keywordMap` holds the names of the keywords; `m_valueMap` holds a map
    of color, alignment, and pen and brush style values, and `m_operatorList` hold
    a list of operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In previous chapters, we have used the C++ standard classes `map`, `set`, `list`,
    `vector`, and `stack`. In this chapter, we will use the Qt classes `QMap`, `QSet`,
    `QList`, `QVector`, and `QStack` instead. They work approximately in the same
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `Scanner.cpp` file holds the definitions of the methods of the `Scanner`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scanner.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `g_lineNo` global field keeps track of the current line in the source code,
    in order for the error messages to state the line number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ADD_TO_OPERATOR_LIST` macro adds a token to the operator list. For instance,
    `ADD_TO_OPERATOR_LIST("+", AddId)` adds the pair of `"+"` and `AddId` to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ADD_TO_KEYWORD_MAP` macro adds a keyword to the keyword map. For instance,
    `ADD_TO_KEYWORD_MAP(ColorId)` adds the pair of `Color` and `ColorId` to the map.
    Note that the `Id` part of the keyword (the last two characters) text is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ADD_TO_VALUE_MAP` macro adds a value to the value map. For instance, `ADD_TO_VALUE_MAP(Aqua)`
    adds the pair of aqua and the `QColor` object Aqua to the map. Note that the text
    is converted to lower case. Also note that only the last part after the last potential
    pair of colons (`::`) is included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`ADD_TO_VALUE_MAP(Qt::AlignLeft)` adds the pair of align left and the `Qt::PenStyle`
    value to the map. Again, note that only the last segment of the value''s name
    is stored as text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we load the buffer into the `m_buffer` field. We also add
    the null-character (`''''`) in order to find the end of the buffer in an easier
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nextToken` method scans the buffer and returns the token found. First,
    we iterate as long as we find new-line, white-space, or line comment. In case
    of a new line, we increase the line count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'A white-space is regular space, a horizontal or vertical tabulator, a return
    character, or new line. We use the `isSpace` method to check whether the character
    is a white-space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If we encounter the beginning of a line comment (`//`), we continue until we
    find the end of the line (`''n''`) or the end of the buffer (`''''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not find a new line, white-space, or line comment, we break the iteration
    and continue looking for the next token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have scanned through the potential white-spaces and comments, we start
    looking for the real tokens. We start by checking if the next character in the
    buffer is a null character (`''''`). If it is a null character, we have found
    the end of the source code and return end-of-file. Remember that we added a null
    character at the end of the buffer in the constructor, just to be able to recognize
    the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If the next token is not end-of-file, we check if it is an operator. We iterate
    through the operator list and check if the buffer begins with any of the operator''s
    text. For instance, the add operator holds the text `+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have found the operator, we increment the buffer index, and return
    the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If the buffer does not begin with an operator, we look after a name representing
    a keyword, a value, or simply a name. We start by checking if the buffer begins
    with a letter or the underscore character (`''_''`), since a name is allowed to
    start with a letter or an underscore. However, the remaining characters can be
    digits besides the letters and underscores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate until we find a character that is not a letter, digit, or underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We extract the text and increase the buffer index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The text can hold a keyword, a value, or a name. First, we check whether the
    text is present in the keyword map. If it is present, we just return the token
    associated with the keyword text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check whether the text is present in the value map. If it is present,
    we return a value token with the value annotated to the token. The value can later
    be obtained by the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If the text is neither a keyword nor a value, we assume that it is a name and
    return a name token with the name annotated to the token. The name can later be
    obtained by the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have looked for a name without finding it, we start looking for a string
    instead. A string is a text enclosed by double quotes (`''"''`). If the next character
    in the buffer is a double quote, it is the beginning of a text. We remove the
    double quote from the buffer and iterate until we find the end quote of the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find a null character before the end of the text, a syntax error is reported
    since we have found the end of the file inside the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have found the end quote, we increase the buffer index and return a
    value token with the text as its annotated value. The text can later be obtained
    by the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If the next character in the buffer is a digit, we have found a numerical value,
    with or without decimals. First, we iterate as long as we find digits in the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'When we no longer find any digits, we check whether the next character in the
    buffer is a dot (`''.''`). If it is a dot, we continue to iterate as long as we
    find digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'When we no longer find any digits, we increase the buffer index and return
    a value token with the annotated value. The value can later be obtained by the
    parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if none of the preceding cases apply, the source code is syntactically
    incorrect, and we report a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We return an end-of-file token, simply because we have to return a value. However,
    we will never reach this point of the code since the `syntaxError` call caused
    an exception to be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have looked at the scanner, we will continue to look at the parser
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building the parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have looked into the scanner, it is time to move on to the parser.
    The parser checks that the source code complies with the grammar. It also performs
    type checking and generates the action list, which is later displayed by the viewer,
    as follows. The `Parser` class mirrors the grammar in that way the it holds one
    method for each grammar rule.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parser.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor takes a grammar object and the action list, which is empty
    at the beginning. The parser calls the scanner each time it needs a new token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `match` method checks whether the given token equals the next token obtained
    by the scanner. If it does not, a syntax error is reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining methods of the `Parser` class are divided into methods for instructions
    and expressions in the grammar, as well as methods for type checking and evaluation
    of expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add a method to the parser for each expression rule in the grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'When evaluating the values of expressions, we need to check the types of the
    values. For instance, when adding two values, both of the operands shall have
    numerical values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_lookAhead` field holds the next token obtained by the scanner, and `m_scanner`
    holds the scanner itself. The `m_actionList` field holds a reference to the action
    list given in the constructor. Finally, `m_assignMap` holds a map for the names
    assigned to values by the assignment rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `Parser.cpp` file holds the definitions of the methods of the `Parser` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parser.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes the references to the scanner and the action list,
    and sets the `m_lookAHead` field to the first token obtained by the scanner. Then
    the parsing process begins by calling `instructionList`. When the instruction
    list has been parsed, the only remaining token shall be the end-of-file token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `g_lineNo` field keeps track of the current line of the source code so
    that a syntax error can be reported with the correct line number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `instructionList` method keeps iterating until it encounters the end-of-file
    token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The `match` method compares the next token obtained by the scanner with the
    given token. If they do not comply, a syntax error is reported. If they do comply,
    the next token is obtained by the scanner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Parsing the instructions of the language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `instruction` method holds a sequence of switch cases, one case for each
    category of instructions. We will look into the next token obtained by the scanner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a name, we parse the name, assignment (`=`), the following expression,
    and a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If the name is already associated with a value, a semantic error is reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The settings of pen and brush colors and styles, as well as fonts and alignments,
    are a little bit more complicated. We call `expression` to parse and evaluate
    the value of an expression. The type of the expression is checked, and an `Action`
    object is added to the action list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The drawing of lines, rectangles, ellipses, and text takes two expressions,
    whose values are evaluated and type checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'If none of the preceding tokens apply, a syntax error is reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Parsing the expressions of the language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An expression, at its lowest priority level, is made up by two multiplication
    or division expressions. First, we call `mulDivExpression`, which is the next
    expression in increasing priority order, to obtain the left value of a possible
    addition or subtraction expression, and then `expressionRest`, which checks if
    there actually is such an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The `expressionRest` method checks whether the next token is a plus or a minus.
    In that case, we have an addition or subtraction expression, the token is matched,
    the left and right values are type checked, and the resulting expression is evaluated
    and returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mulDivExpression` method works in a way similar to `expression` shown
    previously. It calls `primaryExpression` and `mulDivExpressionRest`, which look
    for multiplication and division. Multiplication and division have higher priority
    than addition and subtraction. As stated in *The grammar of source language* section
    previously, we need a new pair of rules in the grammar, with two pairs of methods
    in the parser for the addition/subtraction and multiplication/division expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the primary expression is made up by a point, coordinate, color, or
    font expression. It can also be made up by an expression enclosed in parentheses,
    a name (in which case we look up its value), or a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The coordinate expression takes a point and returns its x or y coordinate.
    We match the keyword and the parentheses and call expressions in between. We then
    check that the value of the expression is a point, and finally call `evaluate`
    to extract the *x* or *y* coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'A point expression is made up by the keyword `point` and two numerical expressions:
    the *x* and *y* coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'A color expression is made up by the keyword `color` and three numerical expressions:
    the red, green, and blue components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'A font expression is made up by the keyword `font` and two expressions: the
    name of the font (string) and its size (numerical):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'An expression can be enclosed by parentheses. In that case, we match the parentheses
    and call `expression` in between to obtain the value of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of a name, we look up its value in the assignment map and return the
    value. If there is no value, a semantic error is reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a value, we simply return the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'In any other case, a syntax error is reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Type checking the expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first `checkType` method checks the type of an expression with one value.
    When setting a pen or brush style, the type must be a pen or brush style, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'When setting a color or a font, the value must be a color or a font, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'When setting an alignment, the value must be an alignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'When extracting the *x* or *y* coordinate from a point, the value must be a
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `checkType` method takes two values. The drawing instructions must
    take two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The drawing of text instructions must take a point and a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating the values of the expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first `evaluate` method returns the value of an expression with one value.
    The *x* and *y* coordinate operators return the *x* or *y* coordinate of the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The assertion is for debugging purposes only, and we return false simply because
    the method has to return a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the second `evaluate` method evaluates the value of expressions with
    two values. First, we extract numerical values and evaluate the arithmetic expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of division by zero, a semantic error is reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the point expression, we return a point value holding the two numerical
    values holding its *x* and *y* coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the first evaluate case previously, the assertion is for debugging purposes
    only, and we return false simply because the method has to return a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The viewer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, it is time to write the viewer, the last part of our DSL. The viewer
    iterates through the actions and displays the graphical objects. The `ViewerWidget`
    class inherits the Qt class `QWidget`, which displays a widget on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**ViewerWidget.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor calls the constructor of the base class `QWidget` and stores
    a reference to the action list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The main part of the class is the `paintEvent` method. It gets called every
    time the widget needs to be repainted and iterates through the actions list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor of `QFont` is called, which initializes the font to
    an appropriate system font. Both the horizontal and vertical alignment is centered.
    Finally, `m_actionList` holds a reference to the action list generated by the
    parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The `ViewerWidget.cpp` file holds the definitions of the methods of the `ViewerWidget`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '**ViewerWidget.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor calls the constructor of the base class `QWidget` with the
    parent widget, initializes the `m_actionList` reference, sets the title of the
    widget, and sets an appropriate size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paintEvent` method is called every time the widget needs to be repainted.
    First, the `QPainter` object `painter` is defined, we then iterate through the
    action list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetPenColor` action creates a new pen with the new color and current style,
    which is added to `painter`. In the same way, the `SetPenStyle` action creates
    a pen with the new style and the current color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the color and style of the brush in the same way as we set the pen previously.
    The only difference is that we create a brush instead of a pen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the font, we call `setFont` on `painter`. Thereafter, the font
    is associated to `painter`, and will be used when writing text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The horizontal and vertical alignment are stored in `m_horizontalAlignment`
    and `m_verticalAlignment`, which are values that are later used when writing text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is time to actually draw some graphical objects. A line is simply drawn
    between two points, while a rectangle or ellipse has top-left and bottom-right
    corners, which are placed in a rectangle that is used as a parameter to the calls
    to `drawRect` and `drawEllipse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we write text. We start by extracting the point to center the text
    around and the text to draw. We then obtain the size of the text (in pixels) with
    the Qt `QFontMetrics` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of left horizontal alignment, the left side of the text is the
    *x* coordinate of the point. In the case of center alignment, the left side of
    the text is moved to the left with half the text width, and in the case of right
    alignment, the left side is moved to the left with the whole text width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way: in the case of top vertical alignment, the top side of the
    text is the *y* coordinate of the point. In the case of center alignment, the
    top side of the text is moved upwards with half of the text height, and in the
    case of bottom alignment, the top side is moved upwards with the whole text height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, the main function calls the `init` static method on the scanner in
    order to initialize its tokens, keywords, and values. A `QApplication` object
    is created, the source code is read and parsed, and the viewer widget is created.
    It executes the action list and displays the graphical objects. The application
    executes until the user presses the close button in the top-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a syntactic or semantic error, its message is displayed in a
    message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started to develop a DSL that generates a sequence of actions
    creating graphical objects, which are viewed in a widget. Our DSL supports instructions
    for drawing graphical objects such as lines, rectangles, ellipses, and text, and
    for setting the color, style, and alignment of the objects. It also supports expressions
    with arithmetic operators.
  prefs: []
  type: TYPE_NORMAL
- en: The language of our DSL is defined by grammar and is made up by a scanner that
    scans the text for meaningful parts, the parser checks that the source code complies
    with the grammar and generates a sequence of actions, which is read and executed
    by the viewer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to develop our DSL. The DSL of this chapter
    only supports code executed in straight sequence. However, in the next chapter,
    we will add function calls as well as selection and iteration (the `if` and `while`
    instructions).
  prefs: []
  type: TYPE_NORMAL
