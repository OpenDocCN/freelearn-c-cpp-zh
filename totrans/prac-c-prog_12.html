<html><head></head><body>
        

                            
                    <h1 class="header-title">Creativity with Graphics</h1>
                
            
            
                
<p><strong>OpenGL</strong> (short for <strong>Open Graphics Library</strong>) is a cross-platform <strong>application program interface</strong> (<strong>API</strong>) used for rendering two- and three-dimensional graphics; it works independently of operating systems. It provides several built-in routines for displaying graphics and for applying special effects, anti-aliasing, and different transformations.</p>
<p>OpenGL had a library called the <strong>OpenGL Utility Toolkit</strong> (<strong>GLUT</strong>), but it has not been supported for several years. FreeGLUT, a free, open source piece of software, is used as an alternative in its place. GLUT was very popularly used in graphics applications as it is highly portable and is very simple to use. It has a large library of functions for creating windows, different graphical shapes, event handling, and more. If FreeGLUT is not installed on your computer and you have Windows OS on your computer, you can download <kbd>freeglut 3.0.0</kbd> for MinGW and extract it. On Ubuntu, you need to give the following command to install FreeGLUT:</p>
<pre><strong>sudo apt-get install freeglut3-dev</strong></pre>
<p>In this chapter, we will learn to do the following recipes:</p>
<ul>
<li>Drawing four graphical shapes</li>
<li>Drawing a circle</li>
<li>Drawing a line between two mouse clicks</li>
<li>Making a bar graph of the supplied values</li>
<li>Making an animated bouncing ball</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">List of OpenGL functions</h1>
                
            
            
                
<p>Before we delve into the recipes, let's have a quick overview of some OpenGL functions that we will be using in this chapter. The following are some of the most frequently used OpenGL functions:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Function</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>glutInit</kbd></td>
<td>Used to initialize GLUT.</td>
</tr>
<tr>
<td><kbd>glutCreateWindow</kbd></td>
<td>Used for creating a top-level window. You can supply the window name as a label while creating the window.</td>
</tr>
<tr>
<td><kbd>glutInitWindowSize</kbd></td>
<td>Used to define the window size. The width and height of the window are specified in pixels while defining the window size.</td>
</tr>
<tr>
<td><kbd>void glutInitWindowPosition</kbd></td>
<td>Used to set the initial window position. The window's <em>x</em> and <em>y</em> locations are specified in terms of pixels.</td>
</tr>
<tr>
<td><kbd>glutDisplayFunc</kbd></td>
<td>Used to specify the callback function to be executed to display graphics in the current window. For redisplaying the content in the window too, the specified callback function is executed.</td>
</tr>
<tr>
<td><kbd>glutMainLoop</kbd></td>
<td>This is an entry point for the GLUT event processing loop.</td>
</tr>
<tr>
<td><kbd>glClearColor</kbd></td>
<td>Used to specify clear values for the color buffers. You need to specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.</td>
</tr>
<tr>
<td><kbd>glClear</kbd></td>
<td>Used to clear the buffers to preset values. Certain masks can be used to specify the buffers to be cleared. The following are three masks that can be used.</td>
</tr>
<tr>
<td><kbd>GL_COLOR_BUFFER_BIT</kbd></td>
<td>This mask represents the buffers that are currently being used for applying colors.</td>
</tr>
<tr>
<td><kbd>GL_DEPTH_BUFFER_BIT</kbd></td>
<td>This mask represents the depth buffer.</td>
</tr>
<tr>
<td><kbd>GL_STENCIL_BUFFER_BIT</kbd></td>
<td>This mask represents the stencil buffer.</td>
</tr>
<tr>
<td><kbd>glBegin</kbd></td>
<td>Used for grouping statements that lead to a specific shape. You can create different shapes such as points, lines, triangles, rectangles, and more, by grouping the required vertices within this grouping statement. The shape that you want to create can be specified by specifying any of the modes: <kbd>GL_POINTS</kbd>, <kbd>GL_LINES</kbd>, <kbd>GL_LINE_STRIP</kbd>, <kbd>GL_LINE_LOOP</kbd>, <kbd>GL_TRIANGLES</kbd>, <kbd>GL_TRIANGLE_STRIP</kbd>, <kbd>GL_TRIANGLE_FAN</kbd>, <kbd>GL_QUADS</kbd>, <kbd>GL_QUAD_STRIP</kbd>, and <kbd>GL_POLYGON</kbd>.</td>
</tr>
<tr>
<td><kbd>glEnd</kbd></td>
<td>Used to end the group of statements.</td>
</tr>
<tr>
<td><kbd>glColor3f</kbd></td>
<td>Used to set the current color for drawing graphics. The values for the red, green, and blue colors (in this strict sequence) can be specified to set the color. The values of these colors can be between 0 and 1, where 0 is the lowest intensity and 1 is the highest intensity of the color.</td>
</tr>
<tr>
<td><kbd>glVertex</kbd></td>
<td>Used to specify coordinates for the point, line, and polygon vertices. This function has to be enclosed between a <kbd>glBegin</kbd>/<kbd>glEnd</kbd> pair. There might be a suffix of 2, 3, or 4 after <kbd>glVertex</kbd>, depending on the number of coordinates required for defining the vertex. For example, if two coordinates, <em>x</em> and <em>y</em>, are required to specify the vertex, then a value of 2 will be added as a suffix to <kbd>glVertex</kbd> making it <kbd>glVertex2</kbd>. Similarly, 3 and 4 can be suffixed if the coordinates required for specifying the vertex are 3 and 4, respectively. Also, one more suffix can be added, such as <kbd>s</kbd>, <kbd>i</kbd>, <kbd>f</kbd>, or <kbd>d</kbd> if the vertex coordinates are of the <kbd>short</kbd>, <kbd>int</kbd>, <kbd>float</kbd> or <kbd>double</kbd> data types respectively. For example, <kbd>glVertex2f()</kbd> can be used to specify the vertex with <em>x</em> and <em>y</em> coordinates, and the coordinate values will be of the <kbd>float</kbd> data type.</td>
</tr>
<tr>
<td><kbd>glLineWidth</kbd></td>
<td>Used to specify the width of the line to be drawn. The width of the line can be specified in terms of pixels. The default width is 1.</td>
</tr>
<tr>
<td><kbd>glPointSize</kbd></td>
<td>Used to specify the diameter of rasterized points. The default diameter is 1.</td>
</tr>
<tr>
<td><kbd>glFlush</kbd></td>
<td>The commands sometimes get buffered depending on the resource utilization and networking situation. The <kbd>glFlush</kbd> function empties all the buffers and ensures that the commands are executed as early as possible.</td>
</tr>
<tr>
<td><kbd>glutSwapBuffers</kbd></td>
<td>This function is used for swapping the front buffer with the back buffer. The front buffer displays the image or frame on the screen and the back buffer is where the image (or frame) hasn't yet been rendered. Once the image or frame is rendered in the back buffer, then this function swaps the front and back buffers, displaying the image that is now ready in the back buffer.</td>
</tr>
<tr>
<td><kbd>glutReshapeFunc</kbd></td>
<td>Used for specifying the reshape callback function for the current window. The function is invoked automatically during these situations: when a window is reshaped, before a window's first display callback, and after a window is created.</td>
</tr>
<tr>
<td><kbd>glViewport</kbd></td>
<td>Used to set the viewport, that is, the vicinity of the window in which we want the rendered image to appear. Four arguments are passed to the function. The first two arguments represent the lower-left corner of the viewport rectangle in terms of pixels. The third and fourth arguments represent the width and height of the viewport. The width and height of the viewport are usually set to be equal to the dimensions of the window or less in size.</td>
</tr>
<tr>
<td><kbd>glMatrixMode</kbd></td>
<td>Used to specify which matrix is the current matrix. The vertices are rendered on the basis of the current state of the matrix, so a matrix must be chosen so that it serves our needs. The following are the two main options.</td>
</tr>
<tr>
<td><kbd>GL_MODELVIEW</kbd></td>
<td>This is the default matrix option. This option is used when the user wants to perform translation, rotation, or similar operations.</td>
</tr>
<tr>
<td><kbd>GL_PROJECTION</kbd></td>
<td>This option is used when the user wants to perform parallel projection, perspective projection, and so on.</td>
</tr>
<tr>
<td><kbd>glLoadIdentity</kbd></td>
<td>Used to replace the current matrix with the identity matrix.</td>
</tr>
<tr>
<td><kbd>gluOrtho2D</kbd></td>
<td>Used to set up a two-dimensional orthographic viewing region. Four arguments are passed to this function. The first two coordinates represent the left and right vertical clipping planes. The last two specify the coordinates for the bottom and top horizontal clipping planes.</td>
</tr>
<tr>
<td><kbd>glutMouseFunc</kbd></td>
<td>Used to set the mouse callback function for the current window. That is, whenever the mouse button is pressed or released, each action invokes the mouse callback function. In the callback function, the following three arguments are automatically passed.</td>
</tr>
<tr>
<td><kbd>button</kbd></td>
<td>It represents any of the three buttons, <kbd>GLUT_LEFT_BUTTON</kbd>, <kbd>GLUT_MIDDLE_BUTTON</kbd>, or <kbd>GLUT_RIGHT_BUTTON</kbd>, depending on which of the mouse buttons is pressed.</td>
</tr>
<tr>
<td><kbd>state</kbd></td>
<td>The state can be either <kbd>GLUT_UP</kbd> or <kbd>GLUT_DOWN</kbd> depending on whether the callback was invoked because of the mouse release or mouse press, respectively.</td>
</tr>
<tr>
<td><kbd>x</kbd> and <kbd>y</kbd></td>
<td>Represents the window's relative coordinates when the mouse button state changes.</td>
</tr>
<tr>
<td><kbd>glutIdleFunc</kbd></td>
<td>Used to set the global idle callback, mainly used for performing background processing tasks. The idle callback is continuously called even if no event is occurring. The <kbd>NULL</kbd> parameter is sent to this function to disable the generation of the idle callback.</td>
</tr>
</tbody>
</table>
<p>You need to initialize the <strong>X Window System</strong> (<strong>X11</strong>) for working with graphics. X11 provides a GUI environment, that is, it enables the displaying of windows and graphics, and provides an environment for interacting with a mouse and keyboard. The command used for starting the X11 is the <kbd>xinit</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing four graphical shapes</h1>
                
            
            
                
<p>In this recipe, we will learn to draw four different shapes: a square, a triangle, points, and a line.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The following are the steps to make different graphical shapes:</p>
<ol>
<li>Initialize GLUT, define the window size, create the window, and set the position of the window.</li>
<li>Define the callback function that will be automatically invoked after displaying the window.</li>
<li>To draw a square, first, define its color.</li>
<li>Draw a square by defining its four vertices and enclosing them within <kbd>glBegin</kbd> and <kbd>glEnd</kbd> statements along with the <kbd>GL_QUADS</kbd> keyword.</li>
<li>To draw a line, set the width and color of the line.</li>
<li>Group a pair of vertices within <kbd>glBegin</kbd> and <kbd>glEnd</kbd> with the <kbd>GL_LINES</kbd> keyword to draw a line.</li>
<li>To draw the points, set the point size to 3 px and also set their color.</li>
<li>The vertices are where the points have to be displayed. Group them into a pair of <kbd>glBegin</kbd> and <kbd>glEnd</kbd> with the <kbd>GL_POINTS</kbd> keyword.</li>
<li>To draw a triangle, group three vertices into <kbd>glBegin</kbd> and <kbd>glEnd</kbd> statements along with the <kbd>GL_TRIANGLES</kbd> keyword.</li>
<li>The <kbd>glFlush</kbd> function is invoked to empty all the buffered statements and get the shapes drawn quickly.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The program for drawing the preceding four shapes is as follows:</p>
<pre>//<strong>opengldrawshapes.c</strong><br/><br/>#include &lt;GL/glut.h&gt;<br/><br/>void drawshapes() {<br/>  glClearColor(0.0 f, 0.0 f, 0.0 f, 1.0 f);<br/>  /* Making background color black as first <br/>   All the 3 arguments R, G, B are 0.0 */<br/>  glClear(GL_COLOR_BUFFER_BIT);<br/>  glBegin(GL_QUADS);<br/>  glColor3f(0.0 f, 0.0 f, 1.0 f);<br/>  /* Making picture color blue (in RGB mode), as third argument is 1. */<br/>  glVertex2f(0.0 f, 0.0 f);<br/>  glVertex2f(0.0 f, .75 f);<br/>  glVertex2f(-.75 f, .75 f);<br/>  glVertex2f(-.75 f, 0.0 f);<br/>  glEnd();<br/>  glLineWidth(2.0);<br/>  glColor3f(1.0, 0.0, 0.0);<br/>  glBegin(GL_LINES);<br/>  glVertex2f(-0.5, -0.5);<br/>  glVertex2f(0.5, -0.5);<br/>  glEnd();<br/>  glColor3f(1.0, 0.0, 0.0);<br/>  glPointSize(3.0);<br/>  /* Width of point size is set to 3 pixel */<br/>  glBegin(GL_POINTS);<br/>  glVertex2f(-.25 f, -0.25 f);<br/>  glVertex2f(0.25 f, -0.25 f);<br/>  glEnd();<br/>  glBegin(GL_TRIANGLES);<br/>  glColor3f(0, 1, 0);<br/>  glVertex2f(0, 0);<br/>  glVertex2f(.5, .5);<br/>  glVertex2f(1, 0);<br/>  glEnd();<br/>  glFlush();<br/>}<br/><br/>int main(int argc, char ** argv) {<br/>  glutInit( &amp; argc, argv);<br/>  glutCreateWindow("Drawing some shapes");<br/>  /* Giving title to the window */<br/>  glutInitWindowSize(1500, 1500);<br/>  /* Defining the window size that is width and height of window */<br/>  glutInitWindowPosition(0, 0);<br/>  glutDisplayFunc(drawshapes);<br/>  glutMainLoop();<br/>  return 0;<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The first step, as expected, is that GLUT is initialized, followed by creating a top-level window, and the label supplied for the window is <kbd>Drawing some shapes</kbd>. However, you can give it any label. The window is defined with a width of 1,500 px and height of 1,500 px. The initial position of the window is set at 0,0, that is, at the coordinates of <em>x=0</em> and <em>y=0</em>. The <kbd>drawshapes</kbd> callback function is invoked for displaying different shapes in the window.</p>
<p>In the <kbd>drawshapes</kbd> function, the values of the color buffers are cleared, followed by clearing the buffers to preset values.</p>
<p>The first shape that we are drawing is a square, so a group of statements for drawing a square are enclosed within <kbd>glBegin</kbd> and <kbd>glEnd</kbd> statements. The <kbd>GL_QUADS</kbd> keyword is supplied with the <kbd>glBegin</kbd> statement because a quad refers to any shape that comprises 4 vertices. The <kbd>glColor3f</kbd> function is invoked to create a square filled with the color blue. The four sets of vertices are supplied to make a square. A vertex comprises <em>x</em> and <em>y</em> coordinates.</p>
<p>Next, we will draw lines. The <kbd>glLineWidth</kbd> function is invoked to specify the width of the lines to be drawn as 2 px wide. The <kbd>glColor3f</kbd> function is invoked to make the lines appear in the color red. Two vertices are grouped within <kbd>glBegin</kbd> and <kbd>glEnd</kbd> with the <kbd>GL_LINES</kbd> keyword to draw a line.</p>
<p>Next, we will draw two points. To make the points clearly visible, the point size is set to 3 px, and the color in which the points will be drawn is set to red (or any color except black). The two vertices where we want the points to be displayed are supplied after being grouped into a pair of <kbd>glBegin</kbd> and <kbd>glEnd</kbd> statements. The <kbd>GL_POINTS</kbd> keyword is supplied with the <kbd>glBegin</kbd> statement to draw the points.</p>
<p>Finally, we draw a triangle by grouping three triangle vertices into <kbd>glBegin</kbd> and <kbd>glEnd</kbd> statements. The <kbd>GL_TRIANGLES</kbd> keyword is supplied with <kbd>glBegin</kbd> to indicate that the vertices that are specified in the group are meant for drawing a triangle. <kbd>glColor3f</kbd> is invoked to make sure the triangle will be filled with the color green.</p>
<p>Finally, the <kbd>glFlush</kbd> function is invoked to empty all the buffered statements and get them executed quickly to display the desired shapes.</p>
<p>To compile the program, we need to open the Command Prompt and change the directory to the folder where the program is saved. Then, we execute the <kbd>xinit</kbd> command at the command prompt to start the X server (X11).</p>
<p>Once X server starts, give the following command to compile the program. Remember that the program has to be linked with <kbd>-lGL -lGLU -lglut</kbd> while compiling the program.</p>
<p class="mce-root">The syntax is as follows:</p>
<pre class="mce-root"><strong>gcc filename.c -lGL -lGLU -lglut</strong> </pre>
<p class="mce-root">Here, <kbd>filename.c</kbd> is the name of the file.</p>
<p class="mce-root">We will use the following command to compile our program:</p>
<pre><strong>gcc opengldrawshapes.c -lGL -lGLU -lglut -lm -o opengldrawshapes</strong></pre>
<p>If no error appears, this means the <kbd>opengldrawshapes.c</kbd> program has successfully been compiled into an executable file: <kbd>opengldrawshapes.exe</kbd>. This file is executed using the following command:</p>
<pre><strong>$./opengldrawshapes</strong></pre>
<p>We will get the output as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/893ec14f-dd2a-48e1-ba9f-86b7a51ecea1.png" style="width:22.00em;height:19.08em;"/></p>
<p>Figure 12.1</p>
<p class="mce-root"/>
<p>Voilà! We have successfully drawn four different graphical shapes: a square, triangle, points, and a line. Now let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing a circle</h1>
                
            
            
                
<p>The procedure for drawing a circle is completely different from the other graphical shapes, hence it gets its own dedicated recipe. It needs a <kbd>for</kbd> loop to draw small points or lines at 0 to 360 degrees. So, let's learn to draw a circle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The following are the steps for drawing a circle:</p>
<ol>
<li>Initialize GLUT, define the size of a top-level window, and create it. Also, set the initial position of the window for displaying our circle.</li>
<li>Define a callback function that is auto-invoked after creating the window.</li>
<li>In the callback function, color buffers are cleared and the color for displaying the circle is set.</li>
<li>The statements for drawing a circle are grouped within a pair of <kbd>glBegin</kbd> and <kbd>glEnd</kbd> functions along with the <kbd>GL_LINE_LOOP</kbd> keyword.</li>
<li>Use a <kbd>for</kbd> loop to draw small lines from 0 to 360 to give the shape of a circle.</li>
</ol>
<p>The program for drawing a circle is as follows:</p>
<pre>//<strong>opengldrawshapes2.c</strong><br/><br/>#include &lt;GL/glut.h&gt; <br/>#include&lt;math.h&gt; <br/>#define pi 3.142857 <br/><br/>void drawshapes() { <br/>    glClearColor(0.0f, 0.0f, 0.0f, 1.0f); <br/>    glClear(GL_COLOR_BUFFER_BIT);  <br/>    glColor3f(0.0f, 1.0f, 0.0f); <br/>    glBegin(GL_LINE_LOOP); <br/>        for (int i=0; i &lt;360; i++) <br/>        { <br/>            float angle = i*pi/180; <br/>            glVertex2f(cos(angle)*0.5,sin(angle)*0.5);                                              }<br/>    glEnd();<br/>    glFlush(); <br/>} <br/><br/>int main(int argc, char** argv) {<br/>    glutInit(&amp;argc, argv);    <br/>    glutCreateWindow("Drawing some shapes"); <br/>    glutInitWindowSize(1500, 1500);  <br/>    glutInitWindowPosition(0, 0);<br/>    glutDisplayFunc(drawshapes); <br/>    glutMainLoop();     <br/>    return 0; <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>GLUT is initialized and a top-level window is created with the label, <kbd>Drawing some shapes</kbd>. The size of the window is defined as 1,500 px wide and 1,500 px in height. The initial position of the window is set at 0, 0, that is, at the <em>x=0</em> and <em>y=0</em> coordinate location. The <kbd>drawshapes</kbd> callback function is invoked for drawing a circle in the window.</p>
<p>In the <kbd>drawshapes</kbd> function, the values of the color buffers are cleared, followed by clearing the buffers to preset values. The <kbd>glColor3f</kbd> function is invoked to set the color in which we want to draw the circle. I have set the color to green to draw the circle but you can choose any color. A group of statements meant for drawing a circle is collected within a pair of <kbd>glBegin</kbd> and <kbd>glEnd</kbd> functions. The <kbd>glBegin</kbd> function is supplied to the <kbd>GL_LINE_LOOP</kbd> keyword to indicate that the circle that we are going to draw will be made up of several small lines.</p>
<p>Within the <kbd>glBegin</kbd> and <kbd>glEnd</kbd> functions, a <kbd>for</kbd> loop is used that executes from value 0 to 360; that is, a very small line will be drawn at every degree from 0 until 360 to give it the shape of a circle. The degree is first converted into radians and the line is drawn at the vertex location, <em>cos(angle) * radius, sin(angle)* radius</em>. When such small lines are drawn at every degree, it will give it the appearance of a circle on the screen.</p>
<p>To compile the program, start the X server and give the following command to compile the program:</p>
<pre><strong>gcc opengldrawshapes2.c -lGL -lGLU -lglut -lm -o opengldrawshapes2</strong></pre>
<p>If no error appears, that means the <kbd>opengldrawshapes2.c</kbd> program has successfully compiled into an executable file: <kbd>opengldrawshapes2.exe</kbd>. This file is executed using the following command:</p>
<pre><strong>$./opengldrawshapes2</strong></pre>
<p>We will get the output as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f2da366c-7cad-4c0f-a71d-0a79a25a9d78.png" style="width:19.00em;height:19.25em;"/></p>
<p>Figure 12.2</p>
<p>Voilà! We have successfully learned how to draw a circle. Now let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing a line between two mouse clicks</h1>
                
            
            
                
<p>In this recipe, we will learn to draw a line between two mouse clicks. A mouse click is considered a procedure of pressing the mouse button and releasing it. You can draw as many lines as you want between a pair of mouse press and release events.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The following are the steps to draw a line between two mouse clicks:</p>
<ol>
<li>Initialize GLUT, define the size of the top-level window, and display the window.</li>
</ol>
<ol start="2">
<li>Define a <kbd>drawLine</kbd> callback function that draws a line if any mouse click event occurs.</li>
<li>In the <kbd>drawLine</kbd> function, the clear values for the clear buffers are specified.</li>
<li>The <kbd>glutSwapBuffers()</kbd> function is invoked to swap the front and back buffers to display any frame that is rendered in the back buffer and is ready to be displayed.</li>
<li>The <kbd>glutReshapeFunc</kbd> function is invoked to specify the reshape callback function that will be auto-invoked whenever the window is reshaped to redraw the lines.</li>
<li>Because the vertices of the line are rendered on the basis of the current state of the matrix, a matrix is set as the current matrix for the viewing and modeling transformations.</li>
<li>A two-dimensional orthographic viewing region is also set up.</li>
<li>A mouse callback function is set up with the name <kbd>mouseEvents</kbd>. The callback is invoked whenever the mouse button is pressed or released.</li>
<li>As per the coordinates where the mouse button is pressed and released, the <kbd>drawLine</kbd> function will be invoked to draw the lines between the two coordinates.</li>
</ol>
<p>The program for drawing a line between two mouse clicks is as follows:</p>
<pre>//<strong>openglmouseclick.c</strong><br/><br/>#include &lt;GL/glut.h&gt; <br/><br/>int noOfClicks = 0; <br/>int coord[2][2]; <br/>int leftPressed = 0; <br/> <br/>void drawLine(void) <br/>{ <br/>    glClearColor(0.0, 0.0, 0.0, 1.0);  <br/>    glClear(GL_COLOR_BUFFER_BIT); <br/>    glBegin(GL_LINES); <br/>        for(int i=0; i&lt;noOfClicks; i++) {<br/>            glVertex2f(coord[i][0],coord[i][1]); <br/>        } <br/>    glEnd(); <br/>    glutSwapBuffers(); <br/>}  <br/><br/>void projection(int width, int height) <br/>{ <br/>    glViewport(0, 0, width, height); <br/>    glMatrixMode(GL_PROJECTION); <br/>    glLoadIdentity(); <br/>    gluOrtho2D(0, width, height, 0); <br/>    glMatrixMode(GL_MODELVIEW); <br/>} <br/><br/>void mouseEvents(int button, int state, int x, int y) <br/>{ <br/>    switch (button) {<br/>        case GLUT_LEFT_BUTTON:<br/>            if (state == GLUT_DOWN) {<br/>                leftPressed = 1;<br/>            }<br/>            if (state == GLUT_UP) { <br/>                if(leftPressed) {                                                                                                                        coord[noOfClicks][0]=x;                                                                                                     coord[noOfClicks][1]=y;                                                                                                     noOfClicks++;                                                                                                     leftPressed = 0;                                                                                 }                                                                                 glutIdleFunc(NULL);                                                <br/>            }  <br/>            break;                                 <br/>        default:                                                 <br/>            break;                 <br/>    } <br/>    drawLine(); <br/>} <br/><br/>int main(int argc, char **argv) <br/>{ <br/>    glutInit(&amp;argc, argv); <br/>    glutInitWindowSize(1000, 1000); <br/>    glutCreateWindow("Displaying lines between two mouse clicks"); <br/>    glutDisplayFunc(drawLine); <br/>    glutReshapeFunc(projection); <br/>    glutMouseFunc(mouseEvents); <br/>    glutMainLoop(); <br/>    return 0;            <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>GLUT is initialized and a top-level window is created with the label, <kbd>Displaying lines between two mouse clicks</kbd>. The window size is specified as 1,000 px wide and 1,000 px in height. The <kbd>drawLine</kbd> callback function is invoked for drawing lines if any mouse click event has occurred.</p>
<p>In the <kbd>drawLine</kbd> function, the clear values for the clear buffers are specified. Also, the buffers are cleared to preset values so that colors can be applied to them. Because no mouse click has occurred yet, the value of <kbd>noOfClicks</kbd> global variable is 0, and hence no line will be drawn at the moment.</p>
<p>The <kbd>glutSwapBuffers()</kbd> function is invoked to swap the front and back buffers to display any frame that is rendered in the back buffer and is ready to be displayed. Because no mouse click has been made yet, nothing will happen with this function.</p>
<p>Then, the <kbd>glutReshapeFunc</kbd> function is invoked to specify the reshape callback function for the current window. The callback function projection will be invoked automatically whenever the window is reshaped, before the window's first display callback and after the window is created. In the projection callback, a viewport is set to define the vicinity in which we want the lines to be drawn. Thereafter, a matrix is set as the current matrix for the viewing and modeling transformations. Also, the vertices are rendered on the basis of the current state of the matrix, so the matrix is chosen accordingly.</p>
<p>Besides this, a two-dimensional orthographic viewing region is also set up. The mouse callback function is set up with the name <kbd>mouseEvents</kbd>, so whenever a mouse button is pressed or released, the <kbd>mouseEvents</kbd> callback function will be automatically invoked. In the callback function, the information about which mouse button is pressed and whether the mouse button is pressed or released is passed. Also, the <em>x</em> and <em>y</em> coordinates where the mouse action takes place are also passed to the <kbd>mouseEvents</kbd> callback function.</p>
<p>In the <kbd>mouseEvents</kbd> function, first, it checks whether the left mouse button is pressed. If yes, then the location where the mouse button is released, that location's <em>x</em> and <em>y</em> coordinates are picked up and assigned to the <kbd>coord</kbd> array. Basically, the mouse button has to be pressed and then released to store the coordinate values. When two mouse clicks and releases are observed, the <kbd>drawLine</kbd> function is invoked to draw the lines between the two coordinates.</p>
<p class="mce-root"/>
<p>To compile the program, start the X server and give the following command to compile the program:</p>
<pre><strong>gcc openglmouseclick.c -lGL -lGLU -lglut -lm -o openglmouseclick</strong></pre>
<p>If no error appears, that means the <kbd>openglmouseclick.c</kbd> program has successfully compiled into an executable file: <kbd>openglmouseclick.exe</kbd>. This file is executed using the following command:</p>
<pre><strong>$./openglmouseclick</strong></pre>
<p>We will get the output as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f60dee79-2a14-4177-bcc0-67bbce7dba6e.png" style="width:32.75em;height:32.83em;"/></p>
<p>Figure 12.3</p>
<p>Once you implement this functionality, you can draw as many lines as you want.</p>
<p>Now let's move on to the next recipe!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Making a bar graph of the supplied values</h1>
                
            
            
                
<p>In this recipe, we will learn to draw bar charts. Let's assume we have data about the percentage of profit growth of a company for the last three years. We will assign that percentage of profit growth to an array, and on the basis of the values in the array, we will draw a bar chart with three bars on the screen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The following are the steps for drawing a bar chart with the values defined in an array:</p>
<ol>
<li>Initialize GLUT, define the size of the top-level window, set its initial position for display, and display the window on the screen.</li>
<li>Define the callback function that is auto-invoked after creating a window for drawing the bar chart.</li>
<li>An array is defined in the callback that defines the height of the bar chart. The width of the bar chart is fixed at 2 px.</li>
<li>A two-dimensional orthographic viewing region is set up, that is, coordinates are set up for horizontal and vertical clipping planes.</li>
<li>To display the horizontal and vertical <em>x</em> and <em>y</em> axes, the vertices for the two lines are grouped in a <kbd>glBegin</kbd> and <kbd>glEnd</kbd> pair with the <kbd>GL_LINES</kbd> keyword.</li>
<li>In order to display three bars, a <kbd>for</kbd> loop is set to execute three times. To display bars one beside the other, the <em>x</em> axis of the next bar is computed. The height of each bar is computed on the basis of the array defined in <em>step 3</em>.</li>
<li>The bar chart is displayed using the four vertices that are grouped in the <kbd>glBegin</kbd> and <kbd>glEnd</kbd> pair with the <kbd>GL_POLYGON</kbd> keyword.</li>
</ol>
<p>The program for drawing a bar chart on the basis of values in an array is as follows:</p>
<pre>//<strong>opengldrawbar.c</strong><br/><br/>#include &lt;GL/glut.h&gt; <br/><br/>void display(){ <br/>    float x,y,width, result[] = {10.0, 15.0, 5.0};<br/>    int i, barCount = 3;<br/>    x=1.0; <br/>    y = 0.0; <br/>    width = 2.0; <br/>    glColor3f(1.0, 0.0, 0.0); <br/>    glClearColor(1.0, 1.0, 1.0, 1.0); <br/>    gluOrtho2D(-5, 20, -5, 20); <br/>    glBegin(GL_LINES);<br/>        glVertex2f(-30, 0.0);       <br/>        glVertex2f(30, 0.0); <br/>        glVertex2f(0.0, -30);<br/>        glVertex2f(0.0, 30); <br/>    glEnd(); <br/>    for(i=0; i&lt;barCount; i++){ <br/>        x = (i * width) + i + 1; <br/>        glBegin(GL_POLYGON); <br/>            glVertex2f(x, y); <br/>            glVertex2f(x, y+result[i]); <br/>            glVertex2f(x+width, y+result[i]); <br/>            glVertex2f(x+width, y); <br/>        glEnd(); <br/>    } <br/>    glFlush(); <br/>} <br/><br/>int main(int argc, char *argv[]){ <br/>    glutInit(&amp;argc, argv); <br/>    glutInitWindowPosition(0, 0); <br/>    glutInitWindowSize(500, 500); <br/>    glutCreateWindow("Drawing Bar Chart"); <br/>    glutDisplayFunc(display); <br/>    glutMainLoop(); <br/>    return 0; <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>GLUT is initialized and a top-level window is created with the label, <kbd>Displaying Bar Chart</kbd>. The initial position of the window is set at 0,0, that is, at the <em>x=0</em> and <em>y=0</em> coordinate location. The window size is specified as 500 px in width and 500 px in height. The <kbd>display</kbd> callback function is invoked for drawing the bar chart.</p>
<p>In the display callback, a result array is initialized to three values. Basically, the values in the resulting array represent the growth in profit percentage of the company in the last three years. Let's assume the growth in the profit percentage of the company in 2019, 2018, and 2017 was 10%, 15%, and 5%, respectively. We want the three bars corresponding to this data to rest on the <em>x</em> axis, so the <em>y</em> coordinate is set to 0. To make the first bar appear after some space, the <em>x</em> coordinate value is set to 1. The width of each bar is set to 2. The color for the bar chart is set to red.</p>
<p>A two-dimensional orthographic viewing region is set up, that is, coordinates are set up for the horizontal and vertical clipping planes. Before drawing the bar chart, the horizontal and vertical <em>x</em> and <em>y</em> axes have to be drawn, so vertices for two lines are grouped in the <kbd>glBegin</kbd> and <kbd>glEnd</kbd> pair with the <kbd>GL_LINES</kbd> keyword.</p>
<p>After drawing the <em>x</em> and <em>y</em> axes, a <kbd>for</kbd> loop is set to execute three times because we need to draw three bars. Within the <kbd>for</kbd> loop, the bars are given a fixed width of 2 px, and, after every bar chart, the <em>x</em> axis of the next bar is computed. Also, the height of the bar – that is, the <em>y</em> coordinate – is computed on the basis of the profit percentage mentioned in each result array. The bar chart is displayed using the four vertices that are grouped in the <kbd>glBegin</kbd> and <kbd>glEnd</kbd> pair with the <kbd>GL_POLYGON</kbd> keyword.</p>
<p>To compile the program, start the X server and give the following command to compile the program:</p>
<pre><strong>gcc opengldrawbar.c -lGL -lGLU -lglut -lm -o opengldrawbar</strong></pre>
<p>If no error appears, that means the <kbd>opengldrawbar.c</kbd> program has successfully compiled into an executable file: <kbd>opengldrawbar.exe</kbd>. This file is executed using the following command:</p>
<pre><strong>$./opengldrawbar</strong></pre>
<p>We will get the output as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f79d0021-098e-4f4a-b6be-7647cc1b6029.png" style="width:27.17em;height:25.42em;"/></p>
<p>Figure 12.4</p>
<p>Voilà! We have successfully created a bar chart using data entered in an array. Now let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making an animated bouncing ball</h1>
                
            
            
                
<p>In this recipe, we will learn to create an animation of a bouncing ball. The ball will be made to appear as if it is falling on the floor and then bouncing back up. To make the ball appear as falling to the floor, the ball is displayed at certain <em>x, y</em> coordinates; after drawing the ball, it is cleared from its current place and redrawn just below its original location. This process of drawing of the ball, erasing it, and redrawing at a lower <em>y</em> coordinate location in quick succession will make the ball appear as if it is falling to the ground. The reverse procedure can be used to show the ball bouncing back up.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The following are the steps to make a small animation of a bouncing ball:</p>
<ol>
<li>GLUT is initialized, the top-level window is defined as being of a specific size, its position is set, and, finally, the top-level window is created.</li>
<li>The callback function is invoked to display a bouncing ball.</li>
<li>In the callback function, the color buffers are cleared and the color of the bouncing ball is set to green.</li>
<li>The <kbd>glPointSize</kbd> is set to 1 px because the circle will be drawn with the help of small points or dots.</li>
<li>The <kbd>GL_PROJECTION</kbd> is set as the current matrix in order to enable parallel and perspective projections. Also, a two-dimensional orthographic viewing region is set up.</li>
<li>To make the falling section of the animation, a ball is drawn at some <em>x, y</em> coordinate. After drawing that ball, the screen is cleared, and the ball is redrawn at a lower location (at a lower <em>y</em> coordinate).</li>
<li>The preceding step is repeated in quick succession to give the appearance of a falling ball.</li>
<li>To make the ball bounce back up, the ball is drawn, then the screen is cleared, and the ball is redrawn at a higher <em>y</em> coordinate that is just above the <em>ground</em> location.</li>
</ol>
<p>The program for making an animated bouncing ball is as follows:</p>
<pre>//<strong>ballanim.c</strong><br/><br/>#include&lt;stdio.h&gt; <br/>#include&lt;GL/glut.h&gt; <br/>#include&lt;math.h&gt; <br/>#define pi 3.142857 <br/><br/>void animball (void) <br/>{ <br/>    int x,y; <br/>    glClearColor(0.0, 0.0, 0.0, 1.0); <br/>    glColor3f(0.0, 1.0, 0.0); <br/>    glPointSize(1.0); <br/>    glMatrixMode(GL_PROJECTION); <br/>    glLoadIdentity(); <br/>    gluOrtho2D(-350, 350, -350, 350); <br/>    for (float j = 0; j &lt; 1000; j += 0.01) <br/>    { <br/>        glClear(GL_COLOR_BUFFER_BIT); <br/>        glBegin(GL_POINTS);      <br/>            for (int i=0; i &lt;360; i++) <br/>            { <br/>                x = 100 * cos(i); <br/>                y = 100 * sin(i); <br/>                /* If 100 is radius of circle, then circle is defined as <br/>                x=100*cos(i) and y=100*sin(i) */<br/>                glVertex2i(x / 2 - 1 * cos(j), y / 2 - 150* sin(j));<br/>            }<br/>        glEnd(); <br/>        glFlush(); <br/>    } <br/>} <br/><br/>int main (int argc, char** argv) <br/>{ <br/>    glutInit(&amp;argc, argv); <br/>    glutCreateWindow("Animating a ball"); <br/>    glutInitWindowSize(1000, 1000); <br/>    glutInitWindowPosition(0, 0); <br/>    glutDisplayFunc(animball); <br/>    glutMainLoop(); <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>GLUT is initialized and a top-level window is created with the label, <kbd>Animating a ball</kbd>. The initial position of the window is set at <em>0,0</em>, that is, at <em>x=0</em> and <em>y=0</em> coordinate location. The window size is specified with 1,000 px of width and 1,000 px of height. The callback function, <kbd>animball</kbd>, is invoked to display a bouncing ball.</p>
<p>In the <kbd>animball</kbd> callback function, the values of the color buffers are cleared. The color for drawing the bouncing ball is set to green. Because the ball will be drawn using small points or dots, the <kbd>glPointSize</kbd> is set to 1 px.</p>
<p>The <kbd>GL_PROJECTION</kbd> is set as the current matrix in order to enable parallel and perspective projections. Also, a two-dimensional orthographic viewing region is set up, defining the left and right vertical clipping planes and the bottom and top horizontal clipping planes.</p>
<p class="mce-root"/>
<p>To display a bouncing ball, we first make the ball drop down on the floor and then bounce back up. To make the falling ball, we draw a ball at some <em>x, y</em> coordinate. After drawing that ball, we clear the screen and redraw the ball just below the original coordinate, that is, after lowering the <em>y</em> coordinate. Clearing and redrawing the ball with successively falling <em>y</em> coordinates repetitively and swiftly will make the ball appear as if it's falling. We will do the reverse to make the ball bounce up. That is, the ball is drawn, the screen is cleared, and the ball is redrawn at successively higher <em>y</em> coordinates. The radius of the ball is assumed to be 100 px (but it can be any radius).</p>
<p>To compile the program, start the X server and give the following command to compile the program:</p>
<pre><strong>gcc ballanim.c -lGL -lGLU -lglut -lm -o ballanim</strong></pre>
<p>If no error appears, that means the <kbd>ballanim.c</kbd> program has successfully compiled into an executable file: <kbd>ballanim.exe</kbd>. This file is executed using the following command:</p>
<pre><strong>$./ballanim</strong></pre>
<p>We will get the output as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ced1c048-8a20-4f46-9276-9f474f4dfa88.png"/></p>
<p>Figure 12.5</p>
<p>Voilà! We have successfully created an animated bouncing ball.</p>


            

            
        
    </body></html>