["```cpp\ntypedef struct hal_uart_stm32{\n    UART_HandleTypeDef huart_;\n    USART_TypeDef *instance_; \n} hal_uart_stm32;\nvoid hal_init();\nuint32_t hal_get_ms(); \n```", "```cpp\nnamespace hal {\nvoid init();\nstd::uint32_t tick_count;\nstd::uint32_t get_ms() {\n    return tick_count;\n}\nclass uart_stm32 {\nprivate:\n    UART_HandleTypeDef huart_;\n    USART_TypeDef *instance_; \n};\n}; \n```", "```cpp\nhal::init();\nstd::uint32_t time_now = hal::get_ms(); \n```", "```cpp\nusing std::array;\narray<int, 4> arr; \n```", "```cpp\nusing namespace std;\narray<int, 4> arr;\nvector<int> vec; \n```", "```cpp\nconst int ret_val = 0;\nint main() {\n    return ::ret_val;\n} \n```", "```cpp\nnamespace {\nconstexpr std::size_t c_max_retries;\nstd::size_t counter;\n}; \n```", "```cpp\nnamespace sensors {\nnamespace environmental {\nclass temperature {\n};\nclass humidity {\n};\n};\nnamespace indoor_air_quality{\nclass c02{\n};\nclass pm2_5{\n};\n};\n}; \n```", "```cpp\nnamespace sensors::environmental {\nclass temperature {\n};\nclass humidity {\n};\n}; \n```", "```cpp\n#include <cstdio>\nvoid print(int a) {\n    printf(\"Int %d\\r\\n\", a);\n}\nvoid print(float a) {\n    printf(\"Float %2.f\\r\\n\", a);\n}\nint main() {\n    print(2);\n    print(2.f);\n    return 0;\n} \n```", "```cpp\n_Z5printi:\n        mov     r1, r0\n        ldr     r0, .L2\n        b       printf\n_Z5printf:\n        vcvt.f64.f32    d16, s0\n        ldr     r0, .L5\n        vmov    r2, r3, d16\n        b       printf \n```", "```cpp\nint print(int a);\nvoid print(int a); \n```", "```cpp\n[  7%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal.c.o\n[ 15%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_cortex.c.o\n[ 23%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_gpio.c.o\n[ 30%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_rcc.c.o\n[ 38%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_uart.c.o\n[ 46%] Building C object CMakeFiles/bare.elf.dir/platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_uart_ex.c.o\n[ 53%] Building ASM object CMakeFiles/bare.elf.dir/platform/startup_stm32f072xb.s.o\n[ 61%] Building C object CMakeFiles/bare.elf.dir/platform/src/stm32f0xx_hal_msp.c.o\n[ 69%] Building C object CMakeFiles/bare.elf.dir/platform/src/stm32f0xx_it.c.o\n[ 76%] Building C object CMakeFiles/bare.elf.dir/platform/src/system_stm32f0xx.c.o\n[ 84%] Building CXX object CMakeFiles/bare.elf.dir/app/src/main.cpp.o\n[ 92%] Building CXX object CMakeFiles/bare.elf.dir/hal/uart/src/uart_stm32.cpp.o\n[100%] Linking CXX executable bare.elf \n```", "```cpp\nextern \"C\" {\nvoid c_func();\n} \n```", "```cpp\n/* C++ needs to know that types and declarations are C, not C++.  */\n#ifdef    __cplusplus\n# define __BEGIN_DECLS    extern \"C\" {\n# define __END_DECLS    }\n#else\n# define __BEGIN_DECLS\n# define __END_DECLS\n#endif \n```", "```cpp\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n// Declarations\n#ifdef __cplusplus\n}\n#endif \n```", "```cpp\nextern \"C\" {\n#include \"c_library.h\"\n} \n```", "```cpp\nvoid bar();\nint a = 42; // a is lvalue\nint b = a; // a can also appear on the right side\nint * p = &a; // pointer p is lvalue\nvoid(*bar_ptr)() = bar; // func pointer bar_ptr is lvalue \n```", "```cpp\nint a = 42; // 42 is rvalue\nint b = a + 16; // a + 16 is rvalue\nstd::size_t size = sizeof(int); // sizeof(int) is rvalue \n```", "```cpp\n#include <cstdio>\nstruct my_struct {\n    int a_;\n    my_struct() : a_(0) {}\n    my_struct(int a) : a_(a) {}\n};\nint main() {\n    printf(\"a_ = %d\\r\\n\", my_struct().a_);\n    printf(\"a_ = %d\\r\\n\", (my_struct()=my_struct(16)).a_);\n    return 0;\n} \n```", "```cpp\na_ = 0\na_ = 16 \n```", "```cpp\n#include <cstdio>\nint main() {\n    int a = 42;\n    int& a_ref = a;\n    const int& a_const_ref = a;\n    printf(\"a = %d\\r\\n\", a);\n    a_ref = 16;\n    printf(\"a = %d\\r\\n\", a);\n    // a_const_ref = 16; compiler error\n    return 0;\n} \n```", "```cpp\nint&& a = 42;\nint b = 0;\n// int&& b_ref = b; compiler error\nint&& b_ref = b + 10; // ok, b + 10 is rvalue \n```", "```cpp\nvoid push_back( const T& value );\nvoid push_back( T&& value ); \n```", "```cpp\n#include <string>\n#include <vector>\n#include <cstdio>\nint main()\n{\n    std::string str = \"Hello world, this is move semantics demo!!!\";\n    printf(\"str.data address is %p\\r\\n\", (void*)str.data());\n    std::vector<std::string> v;\n    v.push_back(str);\n    printf(\"str after copy is <%s>\\r\\n\", str.data());\n    v.push_back(std::move(str));\n    //v.push_back(static_cast<std::string&&>(str));\n    printf(\"str after move is <%s>\\r\\n\", str.data());\n\n    for(const auto & s:v) {\n        printf(\"s is <%s>\\r\\n\", s.data());\n        printf(\"s.data address is %p\\r\\n\", (void*)s.data());\n    }\n    return 0;\n} \n```", "```cpp\nstr.data address is 0x84c2b0\nstr after copy is <Hello world, this is move semantics demo!!!> \n```", "```cpp\nstr after move is <>\ns is <Hello world, this is move semantics demo!!!>\ns.data address is 0x84d330\ns is <Hello world, this is move semantics demo!!!>\ns.data address is 0x84c2b0 \n```", "```cpp\ntemplate <typename T, size_t S> class fixed_vector : public std::array<T, S> {\n  public:\n    void push_back(const T &el) {\n        if(cnt_ < S) {\n            this->at(cnt_) = el;\n            ++cnt_;\n        }\n    }\n    T &back() {\n        return this->at(cnt_-1);\n    }\n    void pop_back() {\n        if(cnt_) {\n            --cnt_;\n        }\n    }\n    auto end() {\n        return std::array<T, S>::begin() + cnt_;\n    }\n    bool empty() const {\n        return cnt_ == 0;\n    }\n  private:\n    size_t cnt_ = 0;\n}; \n```", "```cpp\nint main() {\n    std::priority_queue<int, fixed_vector<int, 10>> pq;\n    pq.push(10);\n    pq.push(4);\n    pq.push(8);\n    pq.push(1);\n    pq.push(2);\n    printf(\"Popping elements from priority queue: \");\n    while(!pq.empty()) {\n       printf(\"%d \", pq.top());\n       pq.pop();\n    }\n    std::stack<int, fixed_vector<int, 10>> st;\n    st.push(10);\n    st.push(4);\n    st.push(8);\n    st.push(1);\n    st.push(2);\n    printf(\"\\r\\nPopping elements from stack (LIFO): \");\n    while(!st.empty()) {\n       printf(\"%d \", st.top());\n       st.pop();\n    }\n    return 0;\n} \n```", "```cpp\nPopping elements from priority queue: 10 8 4 2 1\nPopping elements from stack (LIFO): 2 1 8 4 10 \n```", "```cpp\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <algorithm>\n#include <numeric>\nvoid print_container(const auto& container) {\n    for(auto& elem: container) {\n       printf(\"%d \", elem);\n    }\n       printf(\"\\r\\n\");\n}\nint main() {\n    std::array<int, 10> src{0};\n    std::array<int, 10> dst{0};\n    std::iota(src.begin(), src.end(), 0);\n    std::copy_if(src.begin(), src.end(), dst.begin(),[] \n        (int x) {return x > 3;});\n    print_container(src);\n    print_container(dst);\n    return 0;\n} \n```", "```cpp\nint main() {\n    std::array<int, 10> src{0};\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> distrib(1, 6);\n    auto rand = [&](int x) -> int {\n        return distrib(gen);\n    };\n    std::transform(src.begin(), src.end(), src.begin(), rand);\n    print_container(src);\n    std::sort(src.begin(), src.end());\n    print_container(src);\n    return 0;\n} \n```", "```cpp\n6 6 1 1 6 5 4 4 1 1\n1 1 1 1 4 4 5 6 6 6 \n```"]