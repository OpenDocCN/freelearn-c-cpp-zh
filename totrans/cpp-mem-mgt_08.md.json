["```cpp\n#include <iostream>\n// this is incomplete (for now)\nint main() {\n   auto pre = // current amount of allocated memory\n   { // BEGIN\n      int *p = new int{ 3 };\n      int *q = new int[10]{ }; // initialized to zero\n      delete p;\n     // oops! Forgot to delete[] q\n   } // END\n   auto post = // current amount of allocated memory\n   // with this code, supposing sizeof(int)==4, we\n   // expect to see \"Leaked 40 bytes\" printed\n   if(post != pre)\n      std::cout << \"Leaked \" << (post - pre) << \" bytes\\n\";\n}\n```", "```cpp\nvoid *operator new(std::size_t n);\nvoid *operator new[](std::size_t n);\nvoid operator delete(void*p) noexcept;\nvoid operator delete[](void*p) noexcept;\n```", "```cpp\nX *p = new X{ /* ... */ };\n```", "```cpp\n#ifndef LEAK_DETECTOR_H\n#define LEAK_DETECTOR_H\n#include <cstddef>\n#include <new>\nclass Accountant {\n   Accountant(); // note: private\n   //...\npublic:\n   // deleted copy operations\n   Accountant(const Accountant&) = delete;\n   Accountant& operator=(const Accountant&) = delete;\n   // to access the singleton object\n   static Accountant& get();\n   // services offered by the object\n   // n bytes were allocated\n   void take(std::size_t n);\n   // n bytes were deallocated\n   void give_back(std::size_t n);\n   // number of bytes currently allocated\n   std::size_t how_much() const;\n};\n// allocation operators (free functions)\nvoid *operator new(std::size_t);\nvoid *operator new[](std::size_t);\nvoid operator delete(void*) noexcept;\nvoid operator delete[](void*) noexcept;\n#endif\n```", "```cpp\n#include \"leak_detector.h\"\n#include <iostream>\nint main() {\n   auto pre = Accountant::get().how_much();\n   { // BEGIN\n      int *p = new int{ 3 };\n      int *q = new int[10]{ }; // initialized to zero\n      delete p;\n     // oops! Forgot to delete[] q\n   } // END\n   auto post = Accountant::get().how_much();\n   // with this code, supposing sizeof(int)==4, we\n   // expect to see \"Leaked 40 bytes\" printed\n   if(post != pre)\n      std::cout << \"Leaked \" << (post - pre) << \" bytes\\n\";\n}\n```", "```cpp\n#ifndef LEAK_DETECTOR_H\n#define LEAK_DETECTOR_H\n#include <cstddef>\n#include <atomic>\n#include <new>\nclass Accountant {\n   std::atomic<long long> cur;\n   Accountant() : cur{ 0LL } { // note: private\n   }\npublic:\n   // deleted copy operations\n   Accountant(const Accountant&) = delete;\n   Accountant& operator=(const Accountant&) = delete;\n   // to access the singleton object\n   static auto& get() { // auto used for simplicity\n      static Accountant singleton; // here it is\n      return singleton;\n   }\n   // services offered by the object\n   // n bytes were allocated\n   void take(std::size_t n) { cur += n; }\n   // n bytes were deallocated\n   void give_back(std::size_t n) { cur -= n; }\n   // number of bytes currently allocated\n   std::size_t how_much() const { return cur.load(); }\n};\n// allocation operators (free functions)\nvoid *operator new(std::size_t);\nvoid *operator new[](std::size_t);\nvoid operator delete(void*) noexcept;\nvoid operator delete[](void*) noexcept;\n#endif\n```", "```cpp\n#include <cstdlib>\nvoid *operator new(std::size_t n) {\n   // allocate n bytes plus enough space to hide n\n   void *p = std::malloc(n + sizeof n); // to revisit\n   // signal failure to meet postconditions if needed\n   if(!p) throw std::bad_alloc{};\n   // hide n at the beginning of the allocated block\n   auto q = static_cast<std::size_t*>(p);\n   *q = n; // to revisit\n   // inform the Accountant of the allocation\n   Accountant::get().take(n);\n   // return the beginning of the requested block memory\n   return q + 1; // to revisit\n}\nvoid *operator new[](std::size_t n) {\n   // exactly the same as operator new above\n}\n```", "```cpp\nvoid operator delete(void *p) noexcept {\n   // delete on a null pointer is a no-op\n   if(!p) return;\n   // find the beginning of the block that was allocated\n   auto q = static_cast<std::size_t*>(p) - 1; // to revisit\n   // inform the Accountant of the deallocation\n   Accountant::get().give_back(*q);\n   // free the memory\n   std::free(q);\n}\nvoid operator delete[](void *p) noexcept {\n   // exactly the same as operator delete above\n}\n```", "```cpp\nint main() {\n   auto pre = Accountant::get().how_much();\n   { // BEGIN\n      int *p = new int{ 3 };\n      int *q = new int[10]{ }; // initialized to zero\n      delete p;\n     // oops! Forgot to delete[] q\n   } // END\n   auto post = Accountant::get().how_much();\n   if(post != pre)\n      std::cout << \"Leaked \" << (post - pre) << \" bytes\\n\";\n}\n```", "```cpp\nint main() {\n   auto pre = Accountant::get().how_much();\n   { // BEGIN\n      int *p = new int{ 3 };\n      int *q = new int[10]{ }; // initialized to zero\n      delete p;\n     // oops! Forgot to delete[] q\n   } // END\n   auto post = Accountant::get().how_much();\n   if(post != pre)\n      std::cout << \"Leaked \" << (post - pre) << \" bytes\\n\";\n}\n```", "```cpp\nvoid *operator new(std::size_t n) {\n   void *p = std::malloc(n + sizeof n);\n   if(!p) throw std::bad_alloc{};\n   auto q = static_cast<std::size_t*>(p);\n   *q = n;\n   Accountant::get().take(n);\n   return q + 1;\n}\n```", "```cpp\nvoid *operator new(std::size_t n) {\nvoid *p = std::malloc(n + sizeof n);\n   if(!p) throw std::bad_alloc{};\n   auto q = static_cast<std::size_t*>(p);\n   *q = n;\n   Accountant::get().take(n);\n   return q + 1;\n}\n```", "```cpp\nvoid *operator new(std::size_t n) {\n   void *p = std::malloc(n + sizeof n);\n   if(!p) throw std::bad_alloc{};\n   auto q = static_cast<std::size_t*>(p);\n   *q = n;\n   Accountant::get().take(n);\n   return q + 1;\n}\n```", "```cpp\nvoid *operator new(std::size_t n) {\n   void *p = std::malloc(n + sizeof n);\n   if(!p) throw std::bad_alloc{};\n   auto q = static_cast<std::size_t*>(p);\n   *q = n;\n   Accountant::get().take(n);\n   return q + 1;\n}\n```", "```cpp\nint main() {\n   auto pre = Accountant::get().how_much();\n   { // BEGIN\n      int *p = new int{ 3 };\n      int *q = new int[10]{ }; // initialized to zero\n      delete p;\n     // oops! Forgot to delete[] q\n   } // END\nauto post = Accountant::get().how_much();\n   if(post != pre)\n      std::cout << \"Leaked \" << (post - pre) << \" bytes\\n\";\n}\n```", "```cpp\nint main() {\n   auto pre = Accountant::get().how_much();\n   { // BEGIN\n      int *p = new int{ 3 };\n      int *q = new int[10]{ }; // initialized to zero\n      delete p;\n     // oops! Forgot to delete[] q\n   } // END\nauto post = Accountant::get().how_much();\n   if(post != pre)\n      std::cout << \"Leaked \" << (post - pre) << \" bytes\\n\";\n}\n```", "```cpp\nvoid operator delete(void *p) noexcept {\n   if(!p) return;\n   auto q = static_cast<std::size_t*>(p) - 1;\n   Accountant::get().give_back(*q);\n   std::free(q);\n}\n```", "```cpp\nvoid *operator new(std::size_t n) {\n   // allocate n bytes plus enough space to hide n\n   void *p = std::malloc(n + sizeof n); // to revisit\n   // signal failure to meet postconditions if needed\n   if(!p) throw std::bad_alloc{};\n   // hide n at the beginning of the allocated block\n   auto q = static_cast<std::size_t*>(p);\n   *q = n; // to revisit\n   // inform the Accountant of the allocation\n   Accountant::get().take(n);\n   // return the beginning of the requested block memory\n   return q + 1; // to revisit\n}\n```", "```cpp\nvoid *operator new(std::size_t n) {\n   // allocate n bytes plus enough space to hide n,\n   // taking worst case natural alignment into account\n   void *p = std::malloc(sizeof(std::max_align_t) + n);\n   // signal failure to meet postconditions if needed\n   if(!p) throw std::bad_alloc{};\n   // hide n at the beginning of the allocated block\n   *static_cast<std::size_t*>(p) = n; // to revisit\n   // inform the Accountant of the allocation\n   Accountant::get().take(n);\n   // return the beginning of the requested block memory\n   return static_cast<std::max_align_t*>(p) + 1;\n}\n```", "```cpp\nvoid operator delete(void *p) noexcept {\n   // delete on a null pointer is a no-op\n   if(!p) return;\n   // find the beginning of the block that was allocated\n   p = static_cast<std::max_align_t*>(p) - 1;\n   // inform the Accountant of the deallocation\n   Accountant::get().give_back(\n     *static_cast<std::size_t*>(p)\n   );\n   // free the memory\n   std::free(p);\n}\n```", "```cpp\nvoid *operator new(std::size_t n) {\n   void *p = std::malloc(n + sizeof(std::max_align_t));\n   if(!p) throw std::bad_alloc{};\n   // hide n at the beginning of the allocated block\n*static_cast<std::size_t*>(p) = n; // to revisit\n   Accountant::get().take(n);\n   return static_cast<std::max_align_t*>(p) + 1;\n}\n```", "```cpp\nvoid *operator new(std::size_t n) {\n   void *p = std::malloc(n + sizeof(std::max_align_t));\n   if(!p) throw std::bad_alloc{};\n   // hide n at the beginning of the allocated block\nnew (p) std::size_t{ n };\n   Accountant::get().take(n);\n   return static_cast<std::max_align_t*>(p) + 1;\n}\n```", "```cpp\nvoid *operator new(std::size_t n) {\n   // allocate n bytes (no need for more!)\n   void *p = std::malloc(n);\n   // signal failure to meet postconditions if needed\n   if(!p) throw std::bad_alloc{};\n   // inform the Accountant of the allocation\n   Accountant::get().take(n);\n   // return the beginning of the requested block memory\n   return p;\n}\nvoid *operator new[](std::size_t n) {\n   // exactly the same as operator new above\n}\nvoid operator delete(void *p, std::size_t n) noexcept {\n   // delete on a null pointer is a no-op\n   if(!p) return;\n   // inform the Accountant of the deallocation\n   Accountant::get().give_back(n);\n   // free the memory\n   std::free(p);\n}\nvoid operator delete[](void *p, std::size_t n) noexcept {\n   // exactly the same as operator delete above\n}\n```"]