- en: Chapter 02
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From Source to Binary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In programming, everything starts with source code. In reality, *source code*,
    which sometimes goes by the other name of the *code base*, usually consists of
    a number of text files. Within that, each of those text files contains textual
    instructions written in a programming language.
  prefs: []
  type: TYPE_NORMAL
- en: We know that a CPU cannot execute textual instructions. The reality is that
    these instructions should first be compiled (or translated) to machine-level instructions
    in order to be executed by a CPU, which eventually will result in a running program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we go through the steps needed to get a final product out
    of C source code. This chapter goes into the subject in great depth, and as such
    we''ve split it into five distinct sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The standard C compilation pipeline**: In the first section, we are going
    to cover standard C compilation, the various steps in the pipeline, and how they
    contribute to producing the final product from C source code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Preprocessor**: In this section, we are going to talk about the preprocessor
    component, which drives the preprocessing step, in greater depth.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compiler**: In this section, we are going to have a deeper look at compilers.
    We will explain how compilers, driving the compilation step, produce *intermediate
    representations* from source code and then translate them into assembly language.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Assemblers**: After compilers, we also talk about *assemblers*, which play
    a significant role in translating the assembly instructions, received from compiler,
    into machine-level instructions. The assembler component drives the assembly step.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Linker**: In the last section, we will discuss the *linker* component, driving
    the linking step, in greater depth. The linker is a build component that finally
    creates the actual products of a C project. There are build errors that are specific
    to this component, and sufficient knowledge of the linker will help us to prevent
    and resolve them. We also discuss the various final products of a C project, and
    we will give some hints about disassembling an object file and reading its content.
    More than that, we discuss briefly what *C++ name mangling* is and how it prevents
    certain defects in the linking step when building C++ code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our discussions in this chapter are mostly themed around Unix-like systems,
    but we discuss some differences in other operating systems, such as Microsoft Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, we need to explain the C compilation pipeline. It is vital
    to know how the pipeline produces the executable and library files from the source
    code. While there are multiple concepts and steps involved, understanding them
    thoroughly is vital for us if we are to be prepared for the content in both this
    and future chapters. Note that the various products of a C project are discussed
    thoroughly in the next chapter, *Object Files*.
  prefs: []
  type: TYPE_NORMAL
- en: Compilation pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compiling some C files usually takes a few seconds, but during this brief period
    of time, the source code enters a pipeline that has four distinct components,
    with each of them doing a certain task. These components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component in this pipeline accepts a certain input from the previous component
    and produces a certain output for the next component in the pipeline. This process
    continues through the pipeline until a *product* is generated by the last component.
  prefs: []
  type: TYPE_NORMAL
- en: Source code can be turned into a product if, and only if, it passes through
    all the required components with success. This means that even a small failure
    in one of the components can lead to a *compilation* or *linkage* failure, resulting
    in you receiving relevant error messages.
  prefs: []
  type: TYPE_NORMAL
- en: For certain intermediate products such as *relocatable object files*, it is
    enough that a single source file goes through the first three components with
    success. The last component, the *linker*, is usually used to create bigger products,
    such as an *executable object file*, by merging some of the already prepared relocatable
    object files. So, building a collection of C source files can create one or sometimes
    multiple object files, including relocatable, executable, and *shared object files*.
  prefs: []
  type: TYPE_NORMAL
- en: There are currently a variety of C compilers available. While some of them are
    free and open source, others are proprietary and commercial. Likewise, some compilers
    will only work on a specific platform while others are cross-platform, although,
    the important note is that almost every platform has at least one compatible C compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete list of available C compilers, please have a look at the following
    Wikipedia page: [https://en.wikipedia.org/wiki/List_of_compilers#C_compilers](https://en.wikipedia.org/wiki/List_of_compilers#C_compilers
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: Before talking about the default platform and the C compiler that we use throughout
    this chapter, let's talk a bit more about the term *platform*, and what we mean
    by it.
  prefs: []
  type: TYPE_NORMAL
- en: A platform is a combination of an operating system running on specific hardware
    (or architecture), and its CPU's *instruction set* is the most important part
    of it. The operating system is the software component of a platform, and the architecture
    defines the hardware part. As an example, we can have Ubuntu running on an ARM-powered
    board, or we could have Microsoft Windows running on an AMD 64-bit CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform software can be run on different platforms. However, it is vital
    to know that *cross-platform* is different from being *portable*. Cross-platform
    software usually has different binaries (final object files) and installers for
    each platform, while portable software uses the same produced binaries and installers
    on all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Some C compilers, for example, `gcc` and `clang`, are cross-platform – they
    can generate code for different platforms – and Java bytecode is portable.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding C and C++, if we say that C/C++ code is portable, we mean that we
    can compile it for different platforms without any change or with little modification
    to the source code. This doesn't mean that the final object files are portable, however.
  prefs: []
  type: TYPE_NORMAL
- en: If you have looked at the Wikipedia article we noted before, you can see that
    there are numerous C compilers. Fortunately for us, all of them follow the same
    standard compilation pipeline that we are going to introduce in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Among these many compilers, we need to choose one of them to work with during
    this chapter. Throughout this chapter, we will be using `gcc` 7.3.0 as our default
    compiler. We are choosing `gcc` because it is available on most operating systems,
    in addition to the fact that there are many online resources to be found for it.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to choose our default platform. In this chapter, we have chosen
    Ubuntu 18.04 as our default operating system running on an AMD 64-bit CPU as our
    default architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: From time to time this chapter might refer to a different compiler, a different
    operating system, or a different architecture to compare various platforms and
    compilers. If we do so, the specification of the new platform or the new compiler
    will be given beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we are going to describe the steps in the compilation
    pipeline. First, we are going to build a simple example to see how the sources
    inside a C project are compiled and linked. Throughout this example, we will become
    familiar with new terms and concepts regarding the compilation process. Only after
    that do we address each component individually in a separate section. There, we
    go deep in to each component to explain more internal concepts and processes.
  prefs: []
  type: TYPE_NORMAL
- en: Building a C project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to demonstrate how a C project is built. The project
    that we are going to work on consists of more than one source file, which is a common
    characteristic of almost all C projects. However, before we move to the example
    and start building it, we need to ensure that we understand the structure of a
    typical C project.
  prefs: []
  type: TYPE_NORMAL
- en: Header files versus source files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every C project has source code, or code base, together with other documents
    related to the project description and existing standards. In a C code base, we
    usually have two kinds of files that contain C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header files**, which usually have a `.h` extension in their names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source files**, which have a `.c` extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, in this chapter, we may use the terms *header* instead of *header
    file* and *source* instead of *source file*.
  prefs: []
  type: TYPE_NORMAL
- en: A header file usually contains enumerations, macros, and typedefs, as well as
    the *declarations* of functions, global variables, and structures. In C, some
    programming elements such as functions, variables, and structures can have their declaration
    separated from their *definition* placed in different files.
  prefs: []
  type: TYPE_NORMAL
- en: C++ follows the same pattern, but in other programming languages, such as Java,
    the elements are defined where they are declared. While this is a great feature
    of both C and C++, as it gives them the power to decouple the declarations from
    definitions, it also makes the source code more complex.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, the declarations are stored in header files, and the corresponding
    definitions go to source files. This is even more critical with regard to function
    declarations and function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: It is strongly recommended that you only keep function declarations in header
    files and move function definitions to the corresponding source files. While this
    is not necessary, it is an important design practice to keep those function definitions
    out of the header files.
  prefs: []
  type: TYPE_NORMAL
- en: While the structures could also have separate declarations and definitions,
    there are special cases in which we move declarations and definitions to different
    files. We will see an example of this in *Chapter 8*, *Inheritance and Polymorphism*,
    where we will be discussing the *inheritance* relationship between classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: Header files can include other header files, but never a source file. Source
    files can only include header files. It is bad practice to let a source file include
    another source file. If you do, then this usually means that you have a serious
    design problem in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To elaborate more on this, we are going to look at an example. The following
    code is the declaration of the `average` function. A function declaration consists
    of a *return type* and a *function signature*. A function signature is simply
    the name of the function together with the list of its input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-1: The declaration of the average function'
  prefs: []
  type: TYPE_NORMAL
- en: The declaration introduces a function signature whose name is `average` and
    it receives a pointer to an array of integers together with a second integer argument,
    which indicates the number of elements in the array. The declaration also states
    that the function returns a double value. Note that the return type is a part
    of the declaration but is not often considered a part of the function signature.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Code Box 2-1*, a function declaration ends with a semicolon
    ";" and it does not have a *body* embraced by curly brackets. We should also take
    note that the parameters in the function declaration do not have associated names,
    and this is valid in C, but only in declarations and not in definitions. With
    that being said, it is recommended that you name the parameters even in declarations.
  prefs: []
  type: TYPE_NORMAL
- en: The function declaration is about how to use the function and the definition
    defines how that function is implemented. The user doesn't need to know about
    the parameter names to use the function, and because of that it's possible to
    hide them in the function declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, you can find the definition of the `average` function
    that we declared before. A function definition contains the actual C code representing
    the function''s logic. This always has a body of code embraced by a pair of curly
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-2: The definition of the average function'
  prefs: []
  type: TYPE_NORMAL
- en: Like we said before, and to put more emphasis on this, function declarations
    go to headers, and definitions (or the bodies) go into source files. There are
    rare cases in which we have enough reason to violate this. In addition, sources
    need to include header files in order to see and use the declarations, which is
    how C and C++ work.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not fully understand this now, do not worry as this will become more
    obvious as we move forward.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: Having more than one definition for any declaration in a *translation unit*
    will lead to a *compile error*. This is true for all functions, structures, and
    global variables. Therefore, providing two definitions for a single function declaration
    is not permitted.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to continue this discussion by introducing our first C example
    for this chapter. This example is supposed to demonstrate the correct way of compiling
    a C/C++ project consisting of more than one source file.
  prefs: []
  type: TYPE_NORMAL
- en: Example source files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *example 2.1*, we have three files, with one being a header file, and the
    other two being source files, and all are in the same directory. The example wants
    to calculate the average of an array with five elements.
  prefs: []
  type: TYPE_NORMAL
- en: The header file is used as a bridge between two separate source files and makes
    it possible to write our code in two separate files but build them together. Without
    the header file, it's not possible to break our code in two source files, without
    breaking the rule mentioned above (sources must not include sources). Here, the
    header file contains everything required by one of the sources to use the functionality
    of the other one.
  prefs: []
  type: TYPE_NORMAL
- en: The header file contains only one function declaration, `avg`, needed for the
    program to work. One of the source files contains the definition of the declared
    function. The other source file contains the `main` function, which is the entry
    point of the program. Without the `main` function, it is impossible to have an
    executable binary to run the program with. The `main` function is recognized by
    the compiler as the starting point of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to move on and see what the contents of these files are. Here
    is the header file, which contains an enumeration and a declaration for the `avg`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-3 [ExtremeC_examples_chapter2_1.h]: The header file as part of example
    2.1'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this file contains an enumeration, a set of named integer constants.
    In C, enumerations cannot have separate declarations and definitions, and they
    should be declared and defined just once in the same place.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the enumeration, the *forward declaration* of the avg function
    can be seen in the code box. The act of declaring a function before giving its
    definition is called forward declaration. The header file is also protected by
    the *header guard* statements. They will prevent the header file from being included
    twice or more while being compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows us the source file that actually contains the definition
    of the `avg` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-4 [ExtremeC_examples_chapter2_1.c]: The source file containing the
    definition of avg function'
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding code, you should notice that the filename ends with a `.c`
    extension. The source file has included the example's header file. This has been
    done because it needs the declarations of the `average_type_t` enumeration and
    the `avg` function before using them. Using a new type, in this case, the `average_type_t`
    enumeration, without declaring it before its usage leads to a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code box showing the second source file that contains
    the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-5 [ExtremeC_examples_chapter2_1_main.c]: The main function of example
    2.1'
  prefs: []
  type: TYPE_NORMAL
- en: In every C project, the `main` function is the entry point of the program. In
    the preceding code box, the `main` function declares and populates an array of
    integers and calculates two different averages for it. Note how the `main` function
    calls the avg function in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Building the example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After introducing the files of *example 2.1* in the previous section, we need
    to build them and create a final executable binary file that can be run as a program.Building
    a C/C++ project means that we will compile all the sources within its code base
    to first produce some *relocatable object files* (known as *intermediate object
    files* too), and finally combine those relocatable object files to produce the
    final products, such as *static libraries* or *executable binaries*.
  prefs: []
  type: TYPE_NORMAL
- en: Building a project in other programming languages is also very similar to doing
    it in either C or C++, but the intermediate and final products have different
    names and likely different file formats. For example, in Java, the intermediate
    products are class files containing *Java bytecode*, and the final products are
    JAR or WAR files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: To compile the example sources, we will not use an **Integrated Development
    Environment** (**IDE**). Instead, we are going to use the compiler directly without
    help from any other software. Our approach to building the example is exactly
    the same as the one that is employed by IDEs and performed in the background while
    compiling a number of source files.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, there are two important rules that we should remember.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1: We only compile source files**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first rule is that we only compile source files due to the fact that it
    is meaningless to compile a header file. Header files should not contain any actual
    C code other than some declarations. Therefore, for *example 2.1*, we only need
    to compile two source files: `ExtremeC_examples_chapter2_1.c` and `ExtremeC_examples_chapter2_1_main.c`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2: We compile each source file separately**'
  prefs: []
  type: TYPE_NORMAL
- en: The second rule is that we compile each source file separately. Regarding *example
    2.1*, it means that we have to run the compiler twice, each time passing one of
    the source files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: It is still possible to pass two source files at once and ask the compiler to
    compile them in just one command, but we don't recommend it and we don't do that
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, for a project made up of 100 source files, we need to compile every
    source file separately, and it means that we have to run the compiler 100 times!
    Yes, that seems to be a lot, but this is the way that you should compile a C or
    C++ project. Believe me, you will encounter projects in which several thousand
    files should be compiled before having a single executable binary!
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: If a header file contains a piece of C code that needs to be compiled, we do
    not compile that header file. Instead, we include it in a source file, and then,
    we compile the source file. This way, the header's C code will be compiled as
    part of the source file.
  prefs: []
  type: TYPE_NORMAL
- en: When we compile a source file, no other source files are going to be compiled
    as part of the same compilation because none of them are included by the compiling
    source file. Remember, including source files is not allowed if we respect the
    best practices in C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's focus on the steps that should be taken in order to build a C project.
    The first step is preprocessing, and we are going to talk about that in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Preprocessing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in the C compilation pipeline is *preprocessing*. A source file
    has a number of header files included. However, before the compilation begins,
    the contents of these files are gathered by the preprocessor as a single body
    of C code. In other words, after the preprocessing step, we get a single piece
    of code created by copying content of the header files into the source file content.
  prefs: []
  type: TYPE_NORMAL
- en: Also, other *preprocessor directives* must be resolved in this step. This preprocessed
    piece of code is called a *translation unit*. A translation unit is a single logical
    unit of C code generated by the preprocessor, and it is ready to be compiled.
    A translation unit is sometimes called a *compilation unit* as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: In a translation unit, no preprocessing directives can be found. As a reminder,
    all preprocessing directives in C (and C++) start with `#`, for example, `#include`
    and `#define`.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to ask compilers to dump the translation unit without compiling
    it further. In the case of `gcc`, it is enough to pass the `-E` option (this is
    case-sensitive). In some rare cases, especially when doing cross-platform development,
    examining the translation units could be useful when fixing weird issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, you can see the translation unit for `ExtremeC_examples_chapter2_1.c`,
    which has been generated by `gcc` on our default platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-1: The produced translation unit while compiling ExtremeC_examples_chapter2_1.c'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all the declarations are copied from the header file into the
    translation unit. The comments have also been removed from the translation unit.
  prefs: []
  type: TYPE_NORMAL
- en: The translation unit for `ExtremeC_examples_chapter2_1_main.c` is very large
    because it includes the `stdio.h` header file.
  prefs: []
  type: TYPE_NORMAL
- en: All declarations from this header file, and further inner header files included
    by it, will be copied into the translation unit recursively. Just to show how
    big the translation unit of `ExtremeC_examples_chapter2_1_main.c` can be, on our
    default platform it has 836 lines of C code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-E` option works also for the `clang` compiler.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the first step. The input to the preprocessing step is a source
    file, and the output is the corresponding translation unit.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have the translation unit, you can go for the second step, which is
    *compilation*. The input to the compilation step is the translation unit, retrieved
    from the previous step, and the output is the corresponding *assembly code*. This
    assembly code is still human-readable, but it is machine-dependent and close to
    the hardware and still needs further processing in order to become machine-level
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: You can always ask `gcc` to stop after performing the second step and dump the
    resulting assembly code by passing the `-S` option (capital S). The output is
    a file with the same name as the given source file but with a `.s` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following shell box, you can see the assembly of the `ExtremeC_examples_chapter2_1_main.c`
    source file. However, when reading the code, you should see that some parts of
    the output are removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-2: The produced assembly code while compiling ExtremeC_examples_chapter2_1.c'
  prefs: []
  type: TYPE_NORMAL
- en: As part of the compilation step, the compiler parses the translation unit and
    turns it into assembly code that is specific to the *target architecture*. By
    the target architecture, we mean the hardware or CPU that the program is being
    compiled for and is eventually to be run on. The target architecture is sometimes
    referred to as the *host architecture*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Shell Box 2-2* shows the assembly code generated for the AMD 64-bit architecture
    and produced by `gcc` running on an AMD 64-bit machine. The following shell box
    contains the assembly code generated for an ARM 32-bit architecture and produced
    by `gcc` running on an Intel x86-64 architecture. Both assembly outputs are generated
    for the same C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-3: The assembly code produced while compiling ExtremeC_examples_chapter2_1.c
    for an ARM 32-bit architecture'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in shell boxes *2-2* and *2-3*, the generated assembly code is
    different for the two architectures. This is despite the fact that they are generated
    for the same C code. For the latter assembly code, we have used the `arm-linux-gnueabi-gcc`
    compiler on an Intel x64-86 hardware set running Ubuntu 16.04.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: The target (or host) architecture is the architecture that the source is both
    being compiled for and will be run on. The *build architecture* is the architecture
    that we are using to compile the source. They can be different. For example, you
    can compile a C source for AMD 64-bit hardware on an ARM 32-bit machine.
  prefs: []
  type: TYPE_NORMAL
- en: Producing assembly code from C code is the most important step in the compilation
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: This is because when you have the assembly code, you are very close to the language
    that a CPU can execute. Because of this important role, the compiler is one of
    the most important and most studied subjects in computer science.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Assembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step after compilation is *assembly*. The objective here is to generate
    the actual machine-level instructions (or *machine code*) based on the assembly
    code generated by the compiler in the previous step. Each architecture has its
    own *assembler*, which can translate its own assembly code to its own machine
    code.
  prefs: []
  type: TYPE_NORMAL
- en: A file containing the machine-level instructions that we are going to assemble
    in this section is called an *object file*. We know that a C project can have
    several products that are all object files, but in this section, we are mainly
    interested in relocatable object files. This file is, without a doubt, the most
    important temporary product that we can obtain during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: Relocatable object files can be referred to as intermediate object files.
  prefs: []
  type: TYPE_NORMAL
- en: To pull both of the previous steps together, the purpose of this assembly step
    is to generate a relocatable object file out of the assembly code produced by
    the compiler. Every other product that we create will be based on the relocatable
    object files generated by the assembler in this step.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about these other products in the future sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Binary file* and *object file* are synonyms that refer to a file containing
    machine-level instructions. Note however that the term "binary files" in other
    contexts can have different meanings, for example binary files vs. text files.'
  prefs: []
  type: TYPE_NORMAL
- en: In most Unix-like operating systems, we have an assembler tool called `as`,
    which can be used to produce a relocatable object file from an assembly file.
  prefs: []
  type: TYPE_NORMAL
- en: However, these object files are not executable, and they only contain the machine-level
    instructions generated for a translation unit. Since each translation unit is
    made up of various functions and global variables, a relocatable object file simply
    contains machine-level instructions for the corresponding functions and the pre-allocated
    entries for the global variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following shell box, you can see how `as` is used to produce the relocatable
    object file for `ExtremeC_examples_chapter2_1_main.s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-4: Producing an object file from the assembly of one of the sources
    in example 2.1'
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the command in the preceding shell box, we can see that the
    `-o` option is used to specify the name of the output object file. Relocatable
    object files usually have a `.o` (or a `.obj` in Microsoft Windows) extension
    in their names, which is why we have passed a filename with `.o` at the end.
  prefs: []
  type: TYPE_NORMAL
- en: The content of an object file, either `.o` or `.obj`, is not textual, so you
    would not be able to read it as a human. Therefore, it is common to say that an
    object file has *binary content*.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that the assembler can be used directly, like what we did in
    *Shell Box 2-4*, this is not recommended. Instead, good practice would be to use
    the compiler itself to call `as` indirectly in order to generate the relocatable
    object file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: We may use the terms *object file* and *relocatable object file* interchangeably.
    But not all object files are relocatable object files, and, in some contexts,
    it may refer to other types of object files such as shared object files.
  prefs: []
  type: TYPE_NORMAL
- en: If you pass the `-c` option to almost all known C compilers, it will directly
    generate the corresponding object file for the input source file. In other words,
    the `-c` option is equivalent to performing the first three steps all together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the following example, you can see that we have used the `-c` option
    to compile `ExtremeC_examples_chapter2_1.c` and generate its corresponding object
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-5: Compiling one of the sources in example 2.1 and producing its
    corresponding relocatable object file'
  prefs: []
  type: TYPE_NORMAL
- en: All of the steps we have just done – preprocessing, compilation, and assembling
    – are done as part of the preceding single command. What this means for us is
    that after running the preceding command, a relocatable object file will be generated.
    This relocatable object file will have the same name as the input source file;
    however, it will differ by having a `.o` extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT**:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that, often, the term *compilation* is used to refer to the first three
    steps in the compilation pipeline all together, and not just the second step.
    It is also possible that we use the term "compilation" but actually mean "building;"
    encompassing all four steps. For instance, we say *C compilation pipeline*, but
    we actually mean *C build pipeline*.
  prefs: []
  type: TYPE_NORMAL
- en: The assembly is the last step in compiling a single source file. In other words,
    when we have the corresponding relocatable object file for a source file, we are
    done with its compilation. At this stage we can put aside the relocatable object
    file and continue compiling other source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *example 2.1*, we have two source files that need to be compiled. By executing
    the following commands, it compiles both source files and as a result, produces
    their corresponding object files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-6: Producing the relocatable object files for the sources in example
    2.1'
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the preceding commands that we have changed the names of the
    object files by specifying our desired names using the `-o` option. As a result,
    after compiling both of them, we get the `impl.o` and `main.o` relocatable object
    files.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we need to remind ourselves that relocatable object files are
    not executable. If a project is going to have an executable file as its final
    product, we need to use all, or at the very least, some, of the already produced
    relocatable object files to build the target executable file through the linking
    step.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – Linking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that *example 2.1* needs to be built to an executable file because we
    have a `main` function in it. However, at this point, we only have two relocatable
    object files. Therefore, the next step is to combine these relocatable object
    files in order to create another object file that is executable. The *linking*
    step does exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we go through the linking step, we need to talk about how we
    add support for a new architecture, or hardware, to an existing Unix-like system.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting new architectures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know that every architecture has a series of manufactured processors and
    that every processor can execute a specific instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction set has been designed by vendor companies such as Intel and
    ARM for their processors. In addition, these companies also design a specific
    assembly language for their architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'A program can be built for a new architecture if two prerequisites are satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: The assembly language is known.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The required assembler tool (or program) developed by the vendor company must
    be at hand. This allows us to translate the assembly code into the equivalent
    machine-level instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once these prerequisites are in place, it would be possible to generate machine-level
    instructions from C source code. Only then, we are able to store the generated
    machine-level instructions within the object files using an *object file format*.
    As an example, this could be in the form of either *ELF* or *Mach-O*.
  prefs: []
  type: TYPE_NORMAL
- en: When the assembly language, assembler tool, and object file format are clear,
    they can be used to develop some further tools that are necessary for us developers
    when doing C programming. However, you hardly notice their existence since you are
    often dealing with a C compiler, and it is using these tools on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two immediate tools that are required for a new architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: C compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools are like the first fundamental building blocks for supporting a
    new architecture in an operating system. The hardware together with these tools
    in an operating system give rise to a new platform.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding Unix-like systems, it is important to remember that Unix has a modular
    design. If you are able to build a few fundamental modules like the assembler,
    compiler, and linker, you will be able to build other modules on top of them and
    before long, the whole system is working on a new architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Step details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With all that's been said before, we know that platforms using Unix-like operating
    systems must have the previously discussed mandatory tools, such as an assembler
    and a linker, in order to work. Remember, the assembler and the linker can be
    run separately from the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unix-like systems, `ld` is the default linker. The following command, which
    you can see in the following shell box, shows us how to use `ld` directly when
    we want to create an executable from the relocatable object files we produced
    in the previous sections for *example 2.1*. However, as you will see, it is not
    that easy to use the linker directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-7: Trying to link the object files using the ld utility directly'
  prefs: []
  type: TYPE_NORMAL
- en: As you see, the command has failed, and it has generated some error messages.
    If you pay attention to the error messages, they say that in three places in the
    Text segment `ld` has encountered three function calls (or *references*) that
    are *undefined*.
  prefs: []
  type: TYPE_NORMAL
- en: Two of these function calls are calls to the `printf` function, which we did
    in the `main` function. However, the other one, `__stack_chk_fail`, has not been
    called by us. It is coming from somewhere else, but where? It has been called
    from the supplementary code that has been put into the relocatable object files
    by the compiler, and this function is specific to Linux, and you may not find
    it in the same object files generated on other platforms. However, whatever it
    is and whatever it does, the linker is looking for its definition and it seems
    that it cannot find the definition in the provided object files.
  prefs: []
  type: TYPE_NORMAL
- en: Like we said before, the default linker, `ld`, has generated these errors because
    it has not been able to find the definitions of these functions. Logically, this
    makes sense, and is true, because we have not defined `printf` and `__stack_chk_fail`
    ourselves in *example 2.1*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we should have given `ld` some other object files, though not
    necessarily relocatable object files, that contain the definitions of the `printf`
    and `__stack_chk_fail` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Reading what we have just said should explain why it can be very hard to use
    `ld` directly. Namely, there are more object files and options that need to be
    specified in order to make `ld` work and generate a working executable.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, in Unix-like systems, the most well-known C compilers use `ld`
    by passing proper options and specifying extra required object files. Hence, we
    do not need to use `ld` directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, let''s look at a much simpler way of producing the final executable
    file. The following shell box shows us how we can use `gcc` to link the object
    files from *example 2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-8: Using gcc to link the object files'
  prefs: []
  type: TYPE_NORMAL
- en: As a result of running these commands, we can breathe because we have finally
    managed to build *example 2.1* and run its final executable!
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a project is equivalent to compiling the sources firstly and then linking
    them together, and possibly other libraries, to create the final products.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to take a minute to pause and reflect on what we have just done.
    Over the last few sections we have successfully built *example 2.1* by compiling
    its sources into relocatable object files, and finally linking the generated object
    files to create the final executable binary.
  prefs: []
  type: TYPE_NORMAL
- en: While this process will be the same for any C/C++ code base, the difference
    will be in the number of times you need to compile sources, which itself depends
    on the number of source files in your project.
  prefs: []
  type: TYPE_NORMAL
- en: While the compilation pipeline has some steps, in each step, there is a specific
    component involved. The focus of the remaining sections of this chapter will be
    delving into the critical information surrounding each component in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: To start this, we are going to focus on the preprocessor component.
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the very start of this book in *Chapter 1*, *Essential Features*, we introduced,
    albeit briefly, the concepts of *C preprocessor*. Specifically, we talked there
    about macros, conditional compilation, and header guards.
  prefs: []
  type: TYPE_NORMAL
- en: You will remember that at the beginning of the book, we discussed C preprocessing
    as an essential feature of the C language. Preprocessing is unique due to the
    fact that it cannot be easily found in other programming languages. In the simplest
    terms, preprocessing allows you to modify your source code before sending it for
    compilation. At the same time, it allows you to divide your source code, especially
    the declarations, into header files so that you can later include them into multiple
    source files and reuse those declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is vital to remember that if you have a syntax error in your source code,
    the preprocessor will not find the error as it does not know anything about the
    C syntax. Instead, it will just perform some easy tasks, which typically revolve
    around text substitutions. As an example, imagine that you have a text file named `sample.c`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-6: C code containing some text!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the preceding code, let us preprocess the file using `gcc`. Note that
    some parts of the following shell box have been removed. This is because including
    `stdio.h` makes the translation unit very big:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-9: The preprocessed sample C code seen in Code Box 2-6'
  prefs: []
  type: TYPE_NORMAL
- en: As you see in the preceding shell box, the content of `stdio.h` is copied before
    the text.
  prefs: []
  type: TYPE_NORMAL
- en: If you pay more attention, you will see that another interesting substitution
    has also happened. The occurrences of the `file` have been replaced by `1000`
    in the text.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows us exactly how the preprocessor works. The preprocessor only
    does simple tasks, such as inclusion, by copying contents from a file or expanding
    the macros by text substitution. It does not know anything about C though; it
    needs a parser to parse the input file before performing any further tasks. This
    means that a C preprocessor uses a parser, which looks for directives in the input code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, a parser is a program that processes the input data and extracts
    some certain parts of it for further analysis and processing. Parsers need to
    know the structure of the input data in order to break it down into some smaller
    and useful pieces of data.
  prefs: []
  type: TYPE_NORMAL
- en: The preprocessor's parser is different from the parser used by a C compiler
    because it uses grammar that is almost independent of C grammar. This enables
    us to use it in circumstances other than preprocessing a C file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: By exploiting the functionalities of a C preprocessor, you could use file inclusion
    and macro expansion for other purposes other than building a C program. They could
    be used to process other text files as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[*The GNU C Preprocessor Int*](http://www.chiark.greenend.org.uk/doc/cpp-4.3-doc/cppinternals.html)*ernals*
    – [http://www.chiark.greenend.org.uk/doc/cpp-4.3-doc/cppinternals.html](http://www.chiark.greenend.org.uk/doc/cpp-4.3-doc/cppinternals.html)
    – is a great source for learning more about the `gcc` preprocessor. This document
    is an official source that describes how the GNU C preprocessor works. The GNU
    C preprocessor is used by the `gcc` compiler to preprocess the source files.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding link, you can find how the preprocessor parses the directives
    and how it creates the *parse tree*. The document also provides an explanation
    of the different macro expansion algorithms. While it is outside of the scope
    of this chapter, if you wanted to implement your own preprocessor for a specific
    in-house programming language, or just for processing some text files, then the
    above link provides some great context.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most Unix-like operating systems, there is a tool called **cpp**, which
    stands for **C Pre-Processor** – and not C Plus Plus! `cpp` is part of the C development
    bundle that is shipped with each flavor of Unix. It can be used to preprocess
    a C file. In the background, the tool is used by a C compiler, like `gcc`, to
    preprocess a C file. If you have a source file, you can use it, in a similar way
    to what we have done next, to preprocess a source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-10: Using the cpp utility to preprocess source code'
  prefs: []
  type: TYPE_NORMAL
- en: As a final note in this section, if you pass a file with the extension `.i`
    to a C compiler, then it will bypass the preprocessor step. It does this because
    a file with a `.i` extension is supposed to have already been preprocessed. Therefore,
    it should be sent directly to the compilation step.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you insist on running the C preprocessor for a file with a `.i` extension,
    then you will get the following warning message. Note that the following shell
    box is produced with the `clang` compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-11: Passing an already preprocessed file, with extension .i, to
    the clang compiler'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `clang` warns us that the file has been already preprocessed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of this chapter, we are going to specifically talk about
    the compiler component in the C compilation pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in the previous sections, the compiler accepts the translation
    unit prepared by the preprocessor and generates the corresponding assembly instructions.
    When multiple C sources are compiled into their equivalent assembly code, the
    existing tools in the platform, such as the assembler and the linker, manage the
    rest by making relocatable object files out of the generated assembly code and
    finally linking them together (and possibly with other object files) to form a
    library or an executable file.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we spoke about `as` and `ld` as two examples among the many available
    tools in Unix for C development. These tools are mainly used to create platform-compatible
    object files. These tools exist necessarily outside of `gcc` or any other compiler.
    By existing outside of any compiler, we actually mean that they are not developed
    as a part of `gcc` (we have chosen `gcc` as an example) and they should be available
    on any platform even without having `gcc` installed. `gcc` only uses them in its
    compilation pipeline, and they are not embedded into `gcc`.
  prefs: []
  type: TYPE_NORMAL
- en: That is because the platform itself is the most knowledgeable entity that knows
    about the instruction set accepted by its processor and the operating system-specific
    formats and restrictions. The compiler is not usually aware of these constraints
    unless it wants to do some *optimization* on the translation unit. Therefore,
    we can conclude that the most important task that `gcc` does is to translate the
    translation unit into assembly instructions. This is what we actually call compilation.
  prefs: []
  type: TYPE_NORMAL
- en: One of the challenges in C compilation is to generate correct assembly instructions
    that can be accepted by the target architecture. It is possible to use `gcc` to
    compile the same C code for various architectures such as ARM, Intel x86, AMD,
    and many more. As we discussed before, each architecture has an instruction set
    that is accepted by its processor, and `gcc` (or any C compiler) is the sole responsible
    entity that should generate correct assembly code for a specific architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The way that `gcc` (or any other C compiler) overcomes this difficulty is to
    split the mission into two steps, first parsing the translation unit into an relocatable
    and C-independent data structure called an **Abstract Syntax Tree** (**AST**),
    and then using the created AST to generate the equivalent assembly instructions
    for the target architecture. The first part is architecture-independent and can
    be done regardless of the target instruction set. But the second step is architecture-dependent,
    and the compiler should be aware of the target instruction set. The subcomponent
    that performs the first step is called a *compiler frontend*, and the subcomponent
    that performs the later step is called a *compiler backend*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we are going to discuss these steps in more depth.
    First, let's talk about the AST.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract syntax tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have explained in the previous section, a C compiler frontend should parse
    the translation unit and create an intermediate data structure. The compiler creates
    this intermediate data structure by parsing the C source code according to the
    *C grammar* and saving the result in a tree-like data structure that is *not*
    architecture-dependent. The final data structure is commonly referred to as an
    AST.
  prefs: []
  type: TYPE_NORMAL
- en: ASTs can be generated for any programming language, not only C, so the AST structure
    must be abstract enough to be independent of C syntax.
  prefs: []
  type: TYPE_NORMAL
- en: This is enough to change the compiler frontend to support other languages. This
    is exactly why you can find **GNU Compiler Collection** (**GCC**), which `gcc`
    is a part of as the C compiler, or **Low-Level Virtual Machine** (**LLVM**), which
    `clang` is a part of as the C compiler, as a collection of compilers for many
    languages beyond just C and C++ such as Java, Fortran, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the AST is produced, the compiler backend can start to optimize the AST
    and generate assembly code based on the optimized AST for a target architecture.
    To get a better understanding of ASTs, we are going to take a look at a real AST.
    In this example, we have the following C source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-7 [ExtremeC_examples_chapter2_2.c]: Simple C code whose AST is going
    to be generated'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to use `clang` to dump the AST within the preceding code.
    In the following figure, *Figure 2-1*, you can see the AST:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B11046_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: The AST generated and dumped for example 2.2'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used `clang` in various places as a C compiler, but let's introduce
    it properly. `clang` is a C compiler frontend developed by the LLVM Developer
    Group for the `llvm` compiler backend. The *LLVM Compiler Infrastructure Project*
    uses an *intermediate representation* – or *LLVM IR* – as its abstract data structure
    used between its frontend and its backend. LLVM is famous for its ability to dump
    its IR data structure for research purposes. The preceding tree-like output is
    the IR generated from the source code of *example 2.2*.
  prefs: []
  type: TYPE_NORMAL
- en: What we have done here is introduce you to the basics of AST. We are not going
    through the details of the preceding AST output because each compiler has its
    own AST implementation. We would require several chapters to cover all of the
    details on this, and that is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you pay attention to the above figure, you can find a line that
    starts with -`FunctionDecl`. This represents the `main` function. Before that,
    you can find meta information regarding the translation unit passed to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: If you continue after `FunctionDecl`, you will find tree entries – or *nodes*
    – for declaration statements, binary operator statements, the return statement,
    and even implicit cast statements. There are lots of interesting things residing
    in an AST, with countless things to learn!
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of having an AST for source code is that you can rearrange the
    order of instructions, prune some unused branches, and replace branches so that
    you have better performance but preserve the purpose of the program. As we pointed
    out before, it is called optimization and it is usually done to a certain configurable
    extent by any C compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The next component that we are going to discuss in more detail is the assembler.
  prefs: []
  type: TYPE_NORMAL
- en: Assembler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained before, a platform has to have an assembler in order to produce
    object files that contain correct machine-level instructions. In a Unix-like operating
    system, the assembler can be invoked by using the `as` utility program. In the
    rest of this section, we are going to discuss what can be put in an object file
    by the assembler.
  prefs: []
  type: TYPE_NORMAL
- en: If you install two different Unix-like operating systems on the same architecture,
    the installed assemblers might not be the same, which is very important. What
    this means is that, despite the fact that the machine-level instructions are the
    same, because of being on the same hardware, the produced object files can be
    different!
  prefs: []
  type: TYPE_NORMAL
- en: If you compile a program and produce the corresponding object file on Linux
    for an AMD64 architecture, it could be different from if you had tried to compile
    the same program in a different operating system such as FreeBSD or macOS, and
    on the same hardware. This implies that while the object files cannot be the same,
    they do contain the same machine-level instructions. This proves that object files
    can have different formats in various operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, each operating system defines its own specific binary format
    or *object file format* when it comes to storing machine-level instructions within
    object files. Therefore, there are two factors that specify the contents of an
    object file: the architecture (or hardware) and the operating system. Typically,
    we will use the term platform for such a combination.'
  prefs: []
  type: TYPE_NORMAL
- en: To round off this section, we usually say that object files, hence the assembler
    generating them, are platform-specific. In Linux, we use the **Executable and
    Linking Format** (**ELF**). As the name implies, all executable files, object
    files, and shared libraries should use this format. In other words, in Linux,
    the assembler produces ELF object files. In the upcoming chapter, *Object Files*,
    we will discuss object files and their formats in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will take a deeper look at the *linker* component.
    We will demonstrate and explain how the component actually produces the final
    products in a C project.
  prefs: []
  type: TYPE_NORMAL
- en: Linker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first big step in building a C project is compiling all the source files
    to their corresponding relocatable object files. This step is a necessary step
    in preparing the final products, but alone, it is not enough, and one more step
    is still needed. Before going through the details of this step, we need to have
    a quick look at the possible *products* (sometimes referred to as *artifacts*)
    in a C project.
  prefs: []
  type: TYPE_NORMAL
- en: 'A C/C++ project can lead to the following products:'
  prefs: []
  type: TYPE_NORMAL
- en: A number of executable files that usually have the `.out` extension in most
    Unix-like operating systems. These files usually have the `.exe` extension in Microsoft
    Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of static libraries that usually have the `.a` extension in most Unix-like
    operating systems. These files have the `.lib` extension in Microsoft Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of dynamic libraries or shared object files that usually have the `.so`
    extension in most Unix-like operating systems. These files have the `.dylib` extension
    in macOS, and `.dll` in Microsoft Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relocatable object files are not considered as one of these products; hence,
    you cannot find them in the preceding list. Relocatable object files are temporary
    products simply because they only take part in the linking step to produce the
    preceding products, and after that, we don't need them anymore. The linker component
    has the sole responsibility of producing the preceding products from the given
    relocatable object files.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final and important note about the used terminology: all these three products
    are called *object files*. Therefore, it is best to use the term **relocatable**
    before the term object file when referring to an object file produced by the assembler
    as an intermediate product.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll now briefly describe each of the final products. The upcoming chapter
    is totally dedicated to the object files and it will discuss these final products
    in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: An executable object file can be run as a *process*. This file usually contains
    a substantial portion of the features provided by a project. It must have an entry
    point where the machine-level instructions are executed. While the `main` function
    is the entry point of a C program, the entry point of an executable object file
    is platform-dependent, and it is not the `main` function. The `main` function
    will eventually be called after some preparations made by a group of platform-specific
    instructions, which have been added by the linker as the result of the linking
    step.
  prefs: []
  type: TYPE_NORMAL
- en: A static library is nothing more than an archive file that contains several
    relocatable object files. Therefore, a static library file is not produced by
    the linker directly. Instead, it is produced by the default archive program of
    the system, which on a Unix-like system is the `ar` program.
  prefs: []
  type: TYPE_NORMAL
- en: Static libraries are usually linked to other executable files, and they then
    become part of those executable files. They are the simplest and easiest way to
    encapsulate a piece of logic so that you can use it at a later point. There is
    an enormous number of static libraries that exist within an operating system,
    with each of them containing a specific piece of logic that can be used to access
    a certain functionality within that operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Shared object files, which have a more complicated structure rather than simply
    being an archive, are created directly by the linker. They are also used differently;
    namely, before they are used, they need to be loaded into a running process at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This is in opposition to static libraries that are used at *link time* to become
    part of the final executable file. In addition, a single shared object file can
    be loaded and used by multiple different processes at the same time. As part of
    the next chapter, we demonstrate how shared object files can be loaded and used
    by a C program at *runtime*.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we explain what happens in the linking step and what
    elements are involved and used by the linker to produce the final products, especially
    executable files.
  prefs: []
  type: TYPE_NORMAL
- en: How does the linker work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to explain how the linker component works and
    what we exactly mean by linking. Suppose that you are building a C project that
    contains five source files, with the final product being an executable. As part
    of the build process, you have compiled all the source files, and now you have
    five relocatable object files. What you now need is a linker to complete the last
    step and produce the final executable file.
  prefs: []
  type: TYPE_NORMAL
- en: Based on what we have said so far, to put it simply, a linker combines all of
    the relocatable object files, in addition to specified static libraries, in order
    to create the final executable object file. However, you would be wrong if you
    thought that this step was straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few concerns, which come from the contents of the object files,
    that need to be considered when we are combining the object files in order to
    produce a working executable object file. In order to see how the linker works,
    we need to know how it uses the relocatable object files, and for this purpose,
    we need to find out what is inside an object file.
  prefs: []
  type: TYPE_NORMAL
- en: The simple answer is that an object file contains the equivalent machine-level
    instructions for a translation unit. However, these instructions are not put into
    the file in random order. Instead, they are grouped under sections called *symbols*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, there are many things in an object file, but symbols are one component
    that explains how the linker works and how it ties some object files together
    to produce a larger one. In order to explain symbols, let''s talk about them in
    the context of an example: *example 2.3*. Using this example, we want to demonstrate
    how some functions are compiled and placed in the corresponding relocatable object
    file. Take a look at the following code, which contains two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-8 [ExtremeC_examples_chapter2_3.c]: A code with two function definitions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to compile the preceding code in order to produce the corresponding
    object file. The following command produces the object file, `target.o`. We are
    compiling the code on our default platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-12: Compiling the source file in example 2.3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the `nm` utility to look into the `target.o` object file. The
    `nm` utility allows us to see the symbols that can be found inside an object file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-13: Using the nm utility to see the defined symbols in a relocatable
    object file'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding shell box shows the symbols defined in the object file. As you
    can see, their names are exactly the same as the function defined in *Code Box
    2-8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the `readelf` utility, like we have done in the following shell
    box, you can see the *symbol table* existing in the object file. A symbol table
    contains all the symbols defined in an object file and it can give you more information
    about the symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-14: Using the readelf utility to see the symbol table of a relocatable
    object file'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the output of `readelf`, there are two function symbols in
    the symbol table. There are also other symbols in the table that refer to different
    sections within the object file. We will discuss some of these symbols in this
    chapter and the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see the disassembly of the machine-level instructions, under
    each function symbol, then you can use the `objdump` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-15: Using the objdump utility to see the instructions of the symbols
    defined in a relocatable object file'
  prefs: []
  type: TYPE_NORMAL
- en: Based on what we see, each function symbol corresponds to a function that has
    been defined in the source code. When you need to link several relocatable object
    files, in order to produce an executable object file, this shows that each of
    the relocatable object files contains only a portion of the whole required function
    symbols needed to build a complete executable program.
  prefs: []
  type: TYPE_NORMAL
- en: Now, going back to the topic of this section, the linker gathers all the symbols
    from the various relocatable object files before putting them together in a bigger
    object file to form a complete executable binary. In order to demonstrate this
    in a real scenario, we need a different example that has some functions distributed
    in a number of source files. This way, we can show how the linker looks up the
    symbols in the given relocatable object files, in order to produce an executable
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example 2.4* consists of four C files – three source files and one header
    file. In the header file, we have declared two functions, with each one defined
    in its own source file. The third source file contains the `main` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The functions in *example 2.4* are amazingly simple, and after compilation,
    each function will contain a few machine-level instructions within their corresponding
    object files. In addition, *example 2.4* will not include any of the standard
    C header files. We have chosen this in order to have a small translation unit
    for each source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code box shows the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-9 [ExtremeC_examples_chapter2_4_decls.h]: The declaration of the
    functions in example 2.4'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at that code, you can see that we used the header guard statements to
    prevent *double inclusion*. More than that, two functions with similar *signatures*
    are declared. Each of them receives two integers as input and will return another
    integer as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said before, each of these functions are implemented in separate source
    files. The first source file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-10 [ExtremeC_examples_chapter2_4_add.c]: The definition of the add
    function'
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see that the source file has not included any other header files.
    However, it does define a function that follows the exact same signature that
    we have declared in the header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see next, the second source file is similar to the first one. This
    one contains the definition of the `multiply` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-11 [ExtremeC_examples_chapter2_4_multiply.c]: The definition of
    the multiply function'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now move onto the third source file, which contains the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-12 [ExtremeC_examples_chapter2_4_main.c]: The main function of example
    2.4'
  prefs: []
  type: TYPE_NORMAL
- en: The third source file has to include the header file in order to obtain the
    declarations of both functions. Otherwise, the source file will not be able to
    use the `add` and `multiply` functions, simply because they are not declared,
    and this may result in a compilation failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the `main` function does not know anything about the definitions
    of either `add` or `multiply`. Therefore, we need to ask an important question:
    how does the `main` function find these definitions when it does not even know
    about the other source files? Note that the file shown in *Code Box 2-12* has
    only included one header file, and therefore it has no relationship with the other
    two source files.'
  prefs: []
  type: TYPE_NORMAL
- en: The above question can be resolved by bringing the linker into consideration.
    The linker will gather the required definitions from various object files and
    put them together, and this way, the code written in the `main` function can finally
    use the code written in another function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: To compile a source file that uses a function, the declaration is enough. However,
    to actually run your program, the definition should be provided to the linker
    in order to be put into the final executable file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to compile *example 2.4* and demonstrate what we''ve said so
    far. Using the following commands, we create corresponding relocatable object
    files. You need to remember that we only compile source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-16: Compiling all sources in example 2.4 to their corresponding
    relocatable object files'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next step, we are going to look at the symbol table contained in each
    relocatable object file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-17: Listing the symbols defined in add.o'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you see, the `add` symbol has been defined. The next object file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-18: Listing the symbols defined in multiply.o'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same happens to the `multiply` symbol within `multiply.o`. And the final
    object file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-19: Listing the symbols defined in main.o'
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that the third source file, *Code Box 2-12*, has only the `main`
    function, we see two symbols for `add` and `multiply` in its corresponding object
    file. However, they are different from the `main` symbol, which has an address
    inside the object file. They are marked as `U`, or *unresolved*. This means that
    while the compiler has seen these symbols in the translation unit, it has not
    been able to find their actual definitions. And this is exactly what we expected
    and explained before.
  prefs: []
  type: TYPE_NORMAL
- en: The source file containing the `main` function, *Code Box 2-12*, should not
    know anything about the definitions of other functions if they are not defined
    in the same translation unit, but the fact that the `main` definition is dependent
    on the declarations of `add` and `multiply` should be somehow pointed out in the
    corresponding relocatable object file.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize where we are now, we have three intermediate object files, with
    one of them having two unresolved symbols. This has now made the job of the linker
    clear; we need to give the linker the necessary symbols that can be found in other
    object files. After having found all of the required symbols, the linker can continue
    to combine them in order to create a final executable binary that works.
  prefs: []
  type: TYPE_NORMAL
- en: If the linker is not able to find the definition of an unresolved symbol, it
    will fail, and inform us by printing a *linkage error*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next step, we want to link the preceding object files together. The
    following command will do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-20: Linking all object files together'
  prefs: []
  type: TYPE_NORMAL
- en: We should note here that running `gcc` with a list of object files, without
    passing any option, will result in the linking step trying to create an executable
    object file out of the input object files. Actually, it calls the linker in the
    background with the given object files, together with some other static libraries
    and object files, that are required on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'To examine what happens if the linker fails to find proper definitions, we
    are going to provide the linker with only two intermediate object files, `main.o`
    and `add.o`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-21: Linking only two of the object files: add.o and main.o'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the linker has failed because it could not find the `multiply`
    symbol in the provided object files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, let''s provide the other two object files, `main.o` and `multiply.o`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-22: Linking only two of the object files, multiply.o and main.o'
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the same thing occurred. This happened since the `add` symbol could
    not be found in the provided object files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s provide the only remaining combination of two object files,
    `add.o` and `multiply.o`. Before we run it, we should expect it to work since
    neither object file has unresolved symbols in their symbol tables. Let''s see
    what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-23: Linking only two of the object files, add.o and multiply.o'
  prefs: []
  type: TYPE_NORMAL
- en: As you see, the linker has failed again! Looking at the output, we can see the
    reason was that none of the object files contain the `main` symbol that is necessary
    to create an executable. The linker needs an entry point for the program, which
    is the `main` function according to the C standard.
  prefs: []
  type: TYPE_NORMAL
- en: At this point – and I cannot emphasize this enough – pay attention to the place
    where a reference to the `main` symbol has been made. It has been made in the
    `_start` function in a file located at `/usr/lib/gcc/x86_64-Linux-gnu/7/../../../x86_64-Linux-gnu/Scrt1.o`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Scrt1.o` file seems to be a relocatable object file that has not been created
    by us. `Scrt1.o` is actually a file that is part of a group of default C object
    files. These default object files have been compiled for Linux as a part of the
    `gcc` bundle and are linked to any program in order to make it runnable.
  prefs: []
  type: TYPE_NORMAL
- en: As you have just seen, there are a lot of different things that are happening
    around your source code that can cause conflicts. Not only that, but there are
    a number of other object files that need to be linked to your program in order
    to make it executable.
  prefs: []
  type: TYPE_NORMAL
- en: Linker can be fooled!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make our current discussion even more interesting, there are rare scenarios
    when the linking step will perform as we planned, but the final binary step does
    not work as expected. In this section, we are going to look at an example of this
    occurring.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example 2.5* is based on an incorrect definition having been gathered by the
    linker and put into the final executable object file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has two source files, one of which contains the definition of
    a function with the same name, but a different signature from the declaration
    used by the `main` function. The following code boxes are the contents of these
    two source files. Here''s the first source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-13 [ExtremeC_examples_chapter2_5_add.c]: Definition of the add function
    in example 2.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, following is the second source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-14 [ExtremeC_examples_chapter2_5_main.c]: The main function in example
    2.5'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `main` function is using another version of the `add` function
    with a different signature, accepting two integers, but the `add` function defined
    in the first source file, *Code Box 2-13*, is accepting four integers.
  prefs: []
  type: TYPE_NORMAL
- en: These functions are usually said to be the *overloads* of each other. For sure,
    there should be something wrong if we compile and link these source files. It's interesting
    to see if we can build the example successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to compile and link the relocatable object files, which we
    can do by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-24: Building example 2.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the shell output, the linking step went well, and the final
    executable has been produced! This clearly shows that the symbols can fool the
    linker. Now let''s look at the output after running the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-25: Running example 2.5 twice and the strange results!'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the output is wrong; it even changes in different runs! This
    example shows that bad things can happen when the linker picks up the wrong version
    of a symbol. Regarding the function symbols, they are just names and they don't
    carry any information regarding the signature of the corresponding function. Function
    arguments are nothing more than a C concept; in fact, they do not truly exist
    in either assembly code or machine-level instructions.
  prefs: []
  type: TYPE_NORMAL
- en: In order to investigate more, we are going to look at the *disassembly* of the
    `add` functions in a different example. In *example 2.6*, we have two `add` functions
    with the same signatures that we had in *example 2.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To study this, we are going to work from the idea that we have the following
    source files in *example 2.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-15 [ExtremeC_examples_chapter2_6_add_1.c]: The first definition
    of add in example 2.6'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the other source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-16 [ExtremeC_examples_chapter2_6_add_2.c]: The second definition
    of add in example 2.6'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step, just like before, is to compile both source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-26: Compiling the source files in example 2.6 to their corresponding
    object files'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to have a look at the disassembly of the `add` symbol in different
    object files. Therefore, we start with the `add_1.o` object file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-27: Using objdump to look at the disassembly of the add symbol
    in add_1.o'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell box shows us the disassembly of the `add` symbol found
    in the other object file, `add_2.o`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-28: Using objdump to look at the disassembly of the add symbol
    in add_2.o'
  prefs: []
  type: TYPE_NORMAL
- en: When a function call takes place, a new *stack frame* is created on top of the
    stack. This stack frame contains both the arguments passed to the function and
    the return address. You will read more about the function call mechanism in *Chapter
    4*, *Process Memory Structure*, and *Chapter 5*, *Stack and Heap*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In shell boxes *2-27* and *2-28*, you can clearly see how the arguments are
    collected from the stack frame. In the disassembly of `add_1.o`, *Shell Box 2-27*,
    you can see the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-17: The assembly instructions to copy the arguments from the stack
    frame to the registers for the first add function'
  prefs: []
  type: TYPE_NORMAL
- en: These instructions copy four values from the memory addresses, which have been
    pointed by the `%rbp` register, and put them into the local registers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Registers* are locations within a CPU that can be accessed quickly. Therefore,
    it would be highly efficient for the CPU to bring the values from main memory
    into its registers first, and then perform calculations on them. The register
    `%rbp` is the one that points to the current stack frame, containing the arguments
    passed to a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the disassembly of the second object file, while it is very
    similar, it differs by not having the copy operation four times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Code Box 2-18: The assembly instructions to copy the arguments from the stack
    frame to the registers for the second add function'
  prefs: []
  type: TYPE_NORMAL
- en: These instructions copy two values simply because the function only expects
    two arguments. This is why we saw those strange values in the output of *example
    2.5*. The `main` function only puts two values into the stack frame while calling
    the `add` function, but the `add` definition was actually expecting four arguments.
    So, it is likely that the wrong definition continues to go beyond the stack frame
    to read the missing arguments, which results in the wrong values for the sum operation.
  prefs: []
  type: TYPE_NORMAL
- en: We could prevent this by changing the function symbol names based on the input
    types. This is usually referred to as *name mangling* and is mostly used in C++
    because of its *function overloading* feature. We discuss this briefly in the
    last section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: C++ name mangling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To highlight how name mangling works in C++, we are going to compile *example
    2.6* using a C++ compiler. Therefore, we will use the GNU C++ compiler `g++` for
    this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have done that, we can use `readelf` to dump the symbol tables for each
    generated object file. By doing this, we can see how C++ has changed the name
    of the function symbols based on the types of input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have noted before, the compilation pipelines of C and C++ are very similar.
    Therefore, we can expect to have relocatable object files as a result of C++ compilation.
    Let''s look at both of the object files produced as part of compiling *example
    2.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell Box 2-29: Using readelf the see the symbol tables of the object files
    produced by a C++ compiler'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the output, we have two different symbol names for different
    overloads of the `add` function. The overload that accepts four integers has the
    symbol name `_Z3addiiii`, and the other overload, which accepts two integers,
    has the symbol name `_Z3addii`.
  prefs: []
  type: TYPE_NORMAL
- en: Every `i` in the symbol name refers to one of the integer input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: From that, you can see the symbol names are different, and if you try to use
    the wrong one, you will get a linking error as a result of the linker not being
    able to find the definition of a wrong symbol. Name mangling is the technique
    that enables C++ to support function overloading and it helps to prevent the problems
    we encountered in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the fundamental steps and components required to
    build a C project. Without knowing how to build a project, it is pointless to
    just write code. In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We went through the C compilation pipeline and its various steps. We discussed
    each step and described the inputs and the outputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined the term *platform* and how different assemblers can lead to different
    machine-level instructions for the same C program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We continued to discuss each step and the component driving that step in a greater
    detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of the compiler component, we explained what the compiler frontends
    and backends are, and how GCC and LLVM use this separation to support many languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of our discussion regarding the assembler component, we saw that object
    files are platform-dependent, and they should have an exact file format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of the linker component, we discussed what a linker does and how it
    uses symbols to find the missing definitions in order to put them together and
    form the final product. We also explained various possible products of a C project.
    We explained why relocatable (or intermediate) object files should not be considered
    as products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We demonstrated how the linker can be fooled when a symbol is provided with
    a wrong definition. We showed this in *example 2.5*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We explained the C++ name mangling feature and how problems like what we saw
    in *example 2.5* can be prevented because of that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will continue our discussion regarding object files and their internal structure
    in the next chapter, *Object Files*.
  prefs: []
  type: TYPE_NORMAL
