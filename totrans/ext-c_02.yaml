- en: Chapter 02
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章
- en: From Source to Binary
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源代码到二进制
- en: In programming, everything starts with source code. In reality, *source code*,
    which sometimes goes by the other name of the *code base*, usually consists of
    a number of text files. Within that, each of those text files contains textual
    instructions written in a programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，一切始于源代码。实际上，通常被称为**代码库**的**源代码**通常由多个文本文件组成。在这些文件中，每个文件都包含用编程语言编写的文本指令。
- en: We know that a CPU cannot execute textual instructions. The reality is that
    these instructions should first be compiled (or translated) to machine-level instructions
    in order to be executed by a CPU, which eventually will result in a running program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道CPU不能直接执行文本指令。实际上，这些指令应该首先被编译（或翻译）成机器级指令，以便CPU执行，最终生成一个可运行的程序。
- en: 'In this chapter, we go through the steps needed to get a final product out
    of C source code. This chapter goes into the subject in great depth, and as such
    we''ve split it into five distinct sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍从C源代码生成最终产品所需的步骤。本章对该主题进行了深入探讨，因此我们将其分为五个不同的部分：
- en: '**The standard C compilation pipeline**: In the first section, we are going
    to cover standard C compilation, the various steps in the pipeline, and how they
    contribute to producing the final product from C source code.'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标准的C编译管道**：在第一部分，我们将介绍标准的C编译过程，管道中的各个步骤以及它们如何有助于从C源代码生成最终产品。'
- en: '**Preprocessor**: In this section, we are going to talk about the preprocessor
    component, which drives the preprocessing step, in greater depth.'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预处理器**：在本节中，我们将更深入地讨论预处理器组件，它驱动预处理步骤。'
- en: '**Compiler**: In this section, we are going to have a deeper look at compilers.
    We will explain how compilers, driving the compilation step, produce *intermediate
    representations* from source code and then translate them into assembly language.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译器**：在本节中，我们将更深入地探讨编译器。我们将解释编译器如何从源代码生成**中间表示**，然后将其翻译成汇编语言，并驱动编译步骤。'
- en: '**Assemblers**: After compilers, we also talk about *assemblers*, which play
    a significant role in translating the assembly instructions, received from compiler,
    into machine-level instructions. The assembler component drives the assembly step.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**汇编器**：在编译器之后，我们还会谈到**汇编器**，它在将编译器接收到的汇编指令转换为机器级指令方面发挥着重要作用。汇编器组件驱动汇编步骤。'
- en: '**Linker**: In the last section, we will discuss the *linker* component, driving
    the linking step, in greater depth. The linker is a build component that finally
    creates the actual products of a C project. There are build errors that are specific
    to this component, and sufficient knowledge of the linker will help us to prevent
    and resolve them. We also discuss the various final products of a C project, and
    we will give some hints about disassembling an object file and reading its content.
    More than that, we discuss briefly what *C++ name mangling* is and how it prevents
    certain defects in the linking step when building C++ code.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链接器**：在最后一部分，我们将更深入地讨论**链接器**组件，它驱动链接步骤。链接器是一个构建组件，最终创建C项目的实际产品。该组件存在一些特定的构建错误，对链接器的充分了解将帮助我们预防和解决这些问题。我们还讨论了C项目的各种最终产品，并给出了一些关于反汇编目标文件和读取其内容的提示。此外，我们还简要讨论了**C++名称修饰**是什么以及它是如何防止在构建C++代码时链接步骤中出现的某些缺陷的。'
- en: Our discussions in this chapter are mostly themed around Unix-like systems,
    but we discuss some differences in other operating systems, such as Microsoft Windows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中的讨论主要围绕类Unix系统展开，但我们也会讨论与其他操作系统（如Microsoft Windows）的一些差异。
- en: In the first section, we need to explain the C compilation pipeline. It is vital
    to know how the pipeline produces the executable and library files from the source
    code. While there are multiple concepts and steps involved, understanding them
    thoroughly is vital for us if we are to be prepared for the content in both this
    and future chapters. Note that the various products of a C project are discussed
    thoroughly in the next chapter, *Object Files*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们需要解释C编译管道。了解管道如何从源代码生成可执行文件和库文件至关重要。虽然涉及多个概念和步骤，但如果我们想要为本书和未来章节的内容做好准备，彻底理解它们是至关重要的。注意，下一章将详细讨论C项目的各种产品，即**目标文件**。
- en: Compilation pipeline
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译管道
- en: 'Compiling some C files usually takes a few seconds, but during this brief period
    of time, the source code enters a pipeline that has four distinct components,
    with each of them doing a certain task. These components are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编译一些C文件通常只需要几秒钟，但在这短暂的时间内，源代码进入了一个包含四个不同组件的管道，每个组件都执行特定的任务。这些组件如下：
- en: Preprocessor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理器
- en: Compiler
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器
- en: Assembler
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇编器
- en: Linker
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接器
- en: Each component in this pipeline accepts a certain input from the previous component
    and produces a certain output for the next component in the pipeline. This process
    continues through the pipeline until a *product* is generated by the last component.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的每个组件都接受来自前一个组件的特定输入，并为管道中的下一个组件产生特定的输出。这个过程一直持续到由管道的最后一个组件生成*产品*。
- en: Source code can be turned into a product if, and only if, it passes through
    all the required components with success. This means that even a small failure
    in one of the components can lead to a *compilation* or *linkage* failure, resulting
    in you receiving relevant error messages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源代码能够成功通过所有必需的组件，那么它可以被转换成一个产品。这意味着即使其中一个组件出现小小的失败，也可能导致*编译*或*链接*失败，从而让你收到相关的错误信息。
- en: For certain intermediate products such as *relocatable object files*, it is
    enough that a single source file goes through the first three components with
    success. The last component, the *linker*, is usually used to create bigger products,
    such as an *executable object file*, by merging some of the already prepared relocatable
    object files. So, building a collection of C source files can create one or sometimes
    multiple object files, including relocatable, executable, and *shared object files*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些中间产品，例如*可重定位目标文件*，只要单个源文件成功通过前三个组件就足够了。最后一个组件，即*链接器*，通常用于通过合并一些已经准备好的可重定位目标文件来创建更大的产品，例如*可执行目标文件*。因此，构建一组C源文件可以创建一个或有时多个目标文件，包括可重定位的、可执行的以及*共享目标文件*。
- en: There are currently a variety of C compilers available. While some of them are
    free and open source, others are proprietary and commercial. Likewise, some compilers
    will only work on a specific platform while others are cross-platform, although,
    the important note is that almost every platform has at least one compatible C compiler.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有各种各样的C编译器可供选择。虽然其中一些是免费和开源的，而另一些则是专有和商业的。同样，一些编译器可能只适用于特定的平台，而其他则是跨平台的，尽管重要的是要注意，几乎每个平台至少有一个兼容的C编译器。
- en: '**Note**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'For a complete list of available C compilers, please have a look at the following
    Wikipedia page: [https://en.wikipedia.org/wiki/List_of_compilers#C_compilers](https://en.wikipedia.org/wiki/List_of_compilers#C_compilers
    ).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的C编译器的完整列表，请参阅以下维基百科页面：[https://en.wikipedia.org/wiki/List_of_compilers#C_compilers](https://en.wikipedia.org/wiki/List_of_compilers#C_compilers)。
- en: Before talking about the default platform and the C compiler that we use throughout
    this chapter, let's talk a bit more about the term *platform*, and what we mean
    by it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论本章中我们使用的默认平台和C编译器之前，让我们更详细地谈谈术语*平台*以及我们对其的理解。
- en: A platform is a combination of an operating system running on specific hardware
    (or architecture), and its CPU's *instruction set* is the most important part
    of it. The operating system is the software component of a platform, and the architecture
    defines the hardware part. As an example, we can have Ubuntu running on an ARM-powered
    board, or we could have Microsoft Windows running on an AMD 64-bit CPU.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 平台是在特定硬件（或架构）上运行的操作系统组合，其CPU的*指令集*是其中最重要的部分。操作系统是平台软件组件的一部分，而架构定义了硬件部分。例如，我们可以在ARM供电的板上运行Ubuntu，或者我们可以在AMD
    64位CPU上运行Microsoft Windows。
- en: Cross-platform software can be run on different platforms. However, it is vital
    to know that *cross-platform* is different from being *portable*. Cross-platform
    software usually has different binaries (final object files) and installers for
    each platform, while portable software uses the same produced binaries and installers
    on all platforms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台软件可以在不同的平台上运行。然而，重要的是要知道*跨平台*与*便携性*是不同的。跨平台软件通常为每个平台有不同的二进制文件（最终目标文件）和安装程序，而便携软件在所有平台上使用相同的生成二进制文件和安装程序。
- en: Some C compilers, for example, `gcc` and `clang`, are cross-platform – they
    can generate code for different platforms – and Java bytecode is portable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些C编译器，例如`gcc`和`clang`，是跨平台的——它们可以为不同的平台生成代码——而Java字节码是便携的。
- en: Regarding C and C++, if we say that C/C++ code is portable, we mean that we
    can compile it for different platforms without any change or with little modification
    to the source code. This doesn't mean that the final object files are portable, however.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C和C++，如果我们说C/C++代码是可移植的，我们的意思是我们可以编译它到不同的平台，无需任何更改或只需对源代码进行少量修改。但这并不意味着最终的目标文件是可移植的。
- en: If you have looked at the Wikipedia article we noted before, you can see that
    there are numerous C compilers. Fortunately for us, all of them follow the same
    standard compilation pipeline that we are going to introduce in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经看过我们之前提到的维基百科文章，你可以看到有大量的C编译器。幸运的是，它们都遵循相同的标准编译流程，我们将在本章中介绍。
- en: Among these many compilers, we need to choose one of them to work with during
    this chapter. Throughout this chapter, we will be using `gcc` 7.3.0 as our default
    compiler. We are choosing `gcc` because it is available on most operating systems,
    in addition to the fact that there are many online resources to be found for it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些许多编译器中，我们需要在本章中选择其中一个来工作。在本章中，我们将使用`gcc` 7.3.0作为我们的默认编译器。我们选择`gcc`是因为它在大多数操作系统上可用，此外，还有许多在线资源可以找到。
- en: We also need to choose our default platform. In this chapter, we have chosen
    Ubuntu 18.04 as our default operating system running on an AMD 64-bit CPU as our
    default architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要选择我们的默认平台。在本章中，我们选择了Ubuntu 18.04作为我们的默认操作系统，运行在AMD 64位CPU上作为我们的默认架构。
- en: '**Note**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: From time to time this chapter might refer to a different compiler, a different
    operating system, or a different architecture to compare various platforms and
    compilers. If we do so, the specification of the new platform or the new compiler
    will be given beforehand.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时本章可能会提到不同的编译器、不同的操作系统或不同的架构，以比较不同的平台和编译器。如果我们这样做，新平台或新编译器的规格将在之前给出。
- en: In the following sections, we are going to describe the steps in the compilation
    pipeline. First, we are going to build a simple example to see how the sources
    inside a C project are compiled and linked. Throughout this example, we will become
    familiar with new terms and concepts regarding the compilation process. Only after
    that do we address each component individually in a separate section. There, we
    go deep in to each component to explain more internal concepts and processes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将描述编译流程中的步骤。首先，我们将构建一个简单的示例，看看C项目中的源文件是如何编译和链接的。在整个示例中，我们将熟悉与编译过程相关的新术语和概念。只有在那之后，我们才会在单独的章节中逐个处理每个组件。在那里，我们将深入解释每个组件的更多内部概念和过程。
- en: Building a C project
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建C项目
- en: In this section, we are going to demonstrate how a C project is built. The project
    that we are going to work on consists of more than one source file, which is a common
    characteristic of almost all C projects. However, before we move to the example
    and start building it, we need to ensure that we understand the structure of a
    typical C project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示如何构建一个C项目。我们将要工作的项目包含多个源文件，这是几乎所有C项目的常见特征。然而，在我们转到示例并开始构建之前，我们需要确保我们理解了典型C项目的结构。
- en: Header files versus source files
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头文件与源文件
- en: 'Every C project has source code, or code base, together with other documents
    related to the project description and existing standards. In a C code base, we
    usually have two kinds of files that contain C code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个C项目都有源代码，或代码库，以及与项目描述和现有标准相关的其他文档。在C代码库中，我们通常有两种包含C代码的文件：
- en: '**Header files**, which usually have a `.h` extension in their names.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头文件**，通常其名称带有`.h`扩展名。'
- en: '**Source files**, which have a `.c` extension.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源文件**，具有`.c`扩展名。'
- en: '**Note**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: For convenience, in this chapter, we may use the terms *header* instead of *header
    file* and *source* instead of *source file*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，在本章中，我们可能会使用术语*头文件*代替*头文件*，以及*源文件*代替*源文件*。
- en: A header file usually contains enumerations, macros, and typedefs, as well as
    the *declarations* of functions, global variables, and structures. In C, some
    programming elements such as functions, variables, and structures can have their declaration
    separated from their *definition* placed in different files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件通常包含枚举、宏和类型定义，以及函数、全局变量和结构的*声明*。在C语言中，一些编程元素如函数、变量和结构可以将其声明与其*定义*分开，分别放在不同的文件中。
- en: C++ follows the same pattern, but in other programming languages, such as Java,
    the elements are defined where they are declared. While this is a great feature
    of both C and C++, as it gives them the power to decouple the declarations from
    definitions, it also makes the source code more complex.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: C++遵循相同的模式，但在其他编程语言中，如Java，元素是在声明的地方定义的。虽然这是C和C++的伟大特性之一，因为它使它们能够将声明与定义解耦，但它也使得源代码更加复杂。
- en: As a rule of thumb, the declarations are stored in header files, and the corresponding
    definitions go to source files. This is even more critical with regard to function
    declarations and function definitions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，声明存储在头文件中，相应的定义则放在源文件中。这对于函数声明和函数定义来说尤为重要。
- en: It is strongly recommended that you only keep function declarations in header
    files and move function definitions to the corresponding source files. While this
    is not necessary, it is an important design practice to keep those function definitions
    out of the header files.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您只将函数声明放在头文件中，并将函数定义移动到相应的源文件中。虽然这不是必需的，但将那些函数定义从头文件中分离出来是一个重要的设计实践。
- en: While the structures could also have separate declarations and definitions,
    there are special cases in which we move declarations and definitions to different
    files. We will see an example of this in *Chapter 8*, *Inheritance and Polymorphism*,
    where we will be discussing the *inheritance* relationship between classes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然结构也可以有单独的声明和定义，但在某些特殊情况下，我们会将声明和定义移动到不同的文件中。我们将在 *第8章*，*继承和多态* 中看到一个这样的例子，我们将讨论类之间的
    *继承* 关系。
- en: '**Note**:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Header files can include other header files, but never a source file. Source
    files can only include header files. It is bad practice to let a source file include
    another source file. If you do, then this usually means that you have a serious
    design problem in your project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件可以包含其他头文件，但不能包含源文件。源文件只能包含头文件。让源文件包含另一个源文件是一种不良实践。如果这样做，通常意味着您的项目中存在严重的设计问题。
- en: 'To elaborate more on this, we are going to look at an example. The following
    code is the declaration of the `average` function. A function declaration consists
    of a *return type* and a *function signature*. A function signature is simply
    the name of the function together with the list of its input parameters:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地说明这一点，我们将通过一个示例来查看。以下代码是 `average` 函数的声明。函数声明由一个 *返回类型* 和一个 *函数签名* 组成。函数签名简单地说就是函数的名称及其输入参数列表：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 2-1: The declaration of the average function'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 2-1：`average` 函数的声明
- en: The declaration introduces a function signature whose name is `average` and
    it receives a pointer to an array of integers together with a second integer argument,
    which indicates the number of elements in the array. The declaration also states
    that the function returns a double value. Note that the return type is a part
    of the declaration but is not often considered a part of the function signature.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 声明引入了一个名为 `average` 的函数签名，它接收一个指向整数数组的指针以及一个表示数组中元素数量的第二个整数参数。声明还指出该函数返回一个双精度值。请注意，返回类型是声明的一部分，但通常不被认为是函数签名的一部分。
- en: As you can see in *Code Box 2-1*, a function declaration ends with a semicolon
    ";" and it does not have a *body* embraced by curly brackets. We should also take
    note that the parameters in the function declaration do not have associated names,
    and this is valid in C, but only in declarations and not in definitions. With
    that being said, it is recommended that you name the parameters even in declarations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 *代码框 2-1* 中所看到的，函数声明以分号 ";" 结尾，并且没有由花括号括起来的 *主体*。我们还应该注意，函数声明中的参数没有关联的名称，这在C语言中是有效的，但仅限于声明，而不是定义。因此，即使在声明中，也建议您为参数命名。
- en: The function declaration is about how to use the function and the definition
    defines how that function is implemented. The user doesn't need to know about
    the parameter names to use the function, and because of that it's possible to
    hide them in the function declaration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明是关于如何使用函数的，而定义则定义了该函数的实现方式。用户不需要知道参数名称就能使用该函数，正因为如此，可以在函数声明中隐藏它们。
- en: 'In the following code, you can find the definition of the `average` function
    that we declared before. A function definition contains the actual C code representing
    the function''s logic. This always has a body of code embraced by a pair of curly
    brackets:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，您可以找到我们之前声明的`average`函数的定义。函数定义包含表示函数逻辑的实际C代码。这始终由一对花括号包围的代码体：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 2-2: The definition of the average function'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-2：平均函数的定义
- en: Like we said before, and to put more emphasis on this, function declarations
    go to headers, and definitions (or the bodies) go into source files. There are
    rare cases in which we have enough reason to violate this. In addition, sources
    need to include header files in order to see and use the declarations, which is
    how C and C++ work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，为了强调这一点，函数声明放在头文件中，而定义（或主体）放在源文件中。在极少数情况下，我们有足够的理由违反这一规则。此外，源文件需要包含头文件，以便查看和使用声明，这正是C和C++的工作方式。
- en: If you do not fully understand this now, do not worry as this will become more
    obvious as we move forward.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在还不完全理解，请不要担心，随着我们继续前进，这将会变得更加明显。
- en: '**Note**:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Having more than one definition for any declaration in a *translation unit*
    will lead to a *compile error*. This is true for all functions, structures, and
    global variables. Therefore, providing two definitions for a single function declaration
    is not permitted.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何*翻译单元*中对任何声明有多个定义将导致*编译错误*。这对于所有函数、结构和全局变量都适用。因此，不允许为单个函数声明提供两个定义。
- en: We are going to continue this discussion by introducing our first C example
    for this chapter. This example is supposed to demonstrate the correct way of compiling
    a C/C++ project consisting of more than one source file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过介绍本章的第一个C语言示例来继续这次讨论。这个示例旨在展示正确编译由多个源文件组成的C/C++项目的正确方法。
- en: Example source files
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例源文件
- en: In *example 2.1*, we have three files, with one being a header file, and the
    other two being source files, and all are in the same directory. The example wants
    to calculate the average of an array with five elements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例2.1*中，我们有三个文件，其中一个头文件，另外两个是源文件，它们都在同一个目录下。这个示例旨在计算包含五个元素的数组的平均值。
- en: The header file is used as a bridge between two separate source files and makes
    it possible to write our code in two separate files but build them together. Without
    the header file, it's not possible to break our code in two source files, without
    breaking the rule mentioned above (sources must not include sources). Here, the
    header file contains everything required by one of the sources to use the functionality
    of the other one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件用作两个独立源文件之间的桥梁，使得我们能够在两个独立的文件中编写代码，但一起构建它们。没有头文件，就无法在不违反上述规则（源文件不得包含源文件）的情况下将代码拆分为两个源文件。在这里，头文件包含了一个源文件使用另一个源文件的功能所需的所有内容。
- en: The header file contains only one function declaration, `avg`, needed for the
    program to work. One of the source files contains the definition of the declared
    function. The other source file contains the `main` function, which is the entry
    point of the program. Without the `main` function, it is impossible to have an
    executable binary to run the program with. The `main` function is recognized by
    the compiler as the starting point of the program.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件中只包含一个函数声明，`avg`，这是程序运行所必需的。其中一个源文件包含声明的函数的定义。另一个源文件包含`main`函数，它是程序的入口点。没有`main`函数，就无法有一个可执行的二进制文件来运行程序。编译器将`main`函数识别为程序的起点。
- en: 'We are now going to move on and see what the contents of these files are. Here
    is the header file, which contains an enumeration and a declaration for the `avg`
    function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续前进，看看这些文件的内容。以下是头文件，它包含一个枚举和`avg`函数的声明：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 2-3 [ExtremeC_examples_chapter2_1.h]: The header file as part of example
    2.1'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-3 [ExtremeC_examples_chapter2_1.h]：示例2.1的一部分头文件
- en: As you can see, this file contains an enumeration, a set of named integer constants.
    In C, enumerations cannot have separate declarations and definitions, and they
    should be declared and defined just once in the same place.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此文件包含一个枚举，一组命名的整数常量。在C语言中，枚举不能有单独的声明和定义，它们应该在同一位置声明和定义一次。
- en: In addition to the enumeration, the *forward declaration* of the avg function
    can be seen in the code box. The act of declaring a function before giving its
    definition is called forward declaration. The header file is also protected by
    the *header guard* statements. They will prevent the header file from being included
    twice or more while being compiled.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了枚举之外，代码框中还可以看到`avg`函数的*前置声明*。在给出定义之前声明一个函数的行为称为前置声明。头文件也受到*头文件保护语句*的保护。它们将防止头文件在编译时被包含两次或更多。
- en: 'The following code shows us the source file that actually contains the definition
    of the `avg` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了实际包含`avg`函数定义的源文件：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code Box 2-4 [ExtremeC_examples_chapter2_1.c]: The source file containing the
    definition of avg function'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-4 [ExtremeC_examples_chapter2_1.c]：包含`avg`函数定义的源文件
- en: With the preceding code, you should notice that the filename ends with a `.c`
    extension. The source file has included the example's header file. This has been
    done because it needs the declarations of the `average_type_t` enumeration and
    the `avg` function before using them. Using a new type, in this case, the `average_type_t`
    enumeration, without declaring it before its usage leads to a compilation error.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，你应该注意到文件名以`.c`扩展名结尾。源文件已包含示例的头文件。这样做是因为在使用之前需要`average_type_t`枚举和`avg`函数的声明。在这种情况下，使用新的类型`average_type_t`枚举，在没有声明之前使用它会导致编译错误。
- en: 'Look at the following code box showing the second source file that contains
    the `main` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码框，展示了包含`main`函数的第二个源文件：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Code Box 2-5 [ExtremeC_examples_chapter2_1_main.c]: The main function of example
    2.1'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-5 [ExtremeC_examples_chapter2_1_main.c]：示例2.1的`main`函数
- en: In every C project, the `main` function is the entry point of the program. In
    the preceding code box, the `main` function declares and populates an array of
    integers and calculates two different averages for it. Note how the `main` function
    calls the avg function in the preceding code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个C项目中，`main`函数是程序的入口点。在上面的代码框中，`main`函数声明并初始化了一个整数数组，并计算了该数组的两个不同平均值。注意`main`函数是如何调用前面代码中的`avg`函数的。
- en: Building the example
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建示例
- en: After introducing the files of *example 2.1* in the previous section, we need
    to build them and create a final executable binary file that can be run as a program.Building
    a C/C++ project means that we will compile all the sources within its code base
    to first produce some *relocatable object files* (known as *intermediate object
    files* too), and finally combine those relocatable object files to produce the
    final products, such as *static libraries* or *executable binaries*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节介绍了*示例2.1*的文件之后，我们需要构建它们并创建一个最终的可执行二进制文件，该文件可以作为程序运行。构建C/C++项目意味着我们将编译其代码库中的所有源代码，首先生成一些*可重定位对象文件*（也称为*中间对象文件*），最后将这些可重定位对象文件组合起来生成最终产品，例如*静态库*或*可执行二进制文件*。
- en: Building a project in other programming languages is also very similar to doing
    it in either C or C++, but the intermediate and final products have different
    names and likely different file formats. For example, in Java, the intermediate
    products are class files containing *Java bytecode*, and the final products are
    JAR or WAR files.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编程语言中构建项目也非常类似于在C或C++中构建，但中间和最终产品的名称和文件格式可能不同。例如，在Java中，中间产品是包含*Java字节码*的类文件，最终产品是JAR或WAR文件。
- en: '**Note**:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: To compile the example sources, we will not use an **Integrated Development
    Environment** (**IDE**). Instead, we are going to use the compiler directly without
    help from any other software. Our approach to building the example is exactly
    the same as the one that is employed by IDEs and performed in the background while
    compiling a number of source files.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译示例源代码，我们不会使用**集成开发环境**（**IDE**）。相反，我们将直接使用编译器，而不依赖任何其他软件的帮助。我们构建示例的方法与IDE中使用的以及编译多个源文件时在后台执行的方法完全相同。
- en: Before we go any further, there are two important rules that we should remember.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有两个重要的规则我们应该记住。
- en: '**Rule 1: We only compile source files**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则1：我们只编译源文件**'
- en: 'The first rule is that we only compile source files due to the fact that it
    is meaningless to compile a header file. Header files should not contain any actual
    C code other than some declarations. Therefore, for *example 2.1*, we only need
    to compile two source files: `ExtremeC_examples_chapter2_1.c` and `ExtremeC_examples_chapter2_1_main.c`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则是我们只编译源文件，因为编译头文件是没有意义的。头文件除了声明之外不应包含任何实际的 C 代码。因此，对于 *示例 2.1*，我们只需要编译两个源文件：`ExtremeC_examples_chapter2_1.c`
    和 `ExtremeC_examples_chapter2_1_main.c`。
- en: '**Rule 2: We compile each source file separately**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 2：我们分别编译每个源文件**'
- en: The second rule is that we compile each source file separately. Regarding *example
    2.1*, it means that we have to run the compiler twice, each time passing one of
    the source files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则是我们分别编译每个源文件。关于*示例 2.1*，这意味着我们必须运行编译器两次，每次传递一个源文件。
- en: '**Note**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**:'
- en: It is still possible to pass two source files at once and ask the compiler to
    compile them in just one command, but we don't recommend it and we don't do that
    in this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以一次性传递两个源文件，并要求编译器在一个命令中编译它们，但我们不推荐这样做，并且在这本书中我们也不会这样做。
- en: Therefore, for a project made up of 100 source files, we need to compile every
    source file separately, and it means that we have to run the compiler 100 times!
    Yes, that seems to be a lot, but this is the way that you should compile a C or
    C++ project. Believe me, you will encounter projects in which several thousand
    files should be compiled before having a single executable binary!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于一个由 100 个源文件组成的工程，我们需要分别编译每个源文件，这意味着我们必须运行编译器 100 次！是的，这看起来很多，但这就是你应该编译
    C 或 C++ 项目的正确方式。相信我，你将遇到需要编译数千个文件才能生成单个可执行二进制文件的项目！
- en: '**Note**:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**:'
- en: If a header file contains a piece of C code that needs to be compiled, we do
    not compile that header file. Instead, we include it in a source file, and then,
    we compile the source file. This way, the header's C code will be compiled as
    part of the source file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个头文件包含需要编译的 C 代码片段，我们不会编译该头文件。相反，我们将它包含在一个源文件中，然后编译该源文件。这样，头文件的 C 代码将作为源文件的一部分进行编译。
- en: When we compile a source file, no other source files are going to be compiled
    as part of the same compilation because none of them are included by the compiling
    source file. Remember, including source files is not allowed if we respect the
    best practices in C/C++.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译一个源文件时，不会将其他源文件作为同一编译的一部分进行编译，因为它们都没有被编译源文件包含。记住，如果我们尊重 C/C++ 的最佳实践，则不允许包含源文件。
- en: Now let's focus on the steps that should be taken in order to build a C project.
    The first step is preprocessing, and we are going to talk about that in the following
    section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于构建 C 项目时应采取的步骤。第一步是预处理，我们将在下一节中讨论这一点。
- en: Step 1 – Preprocessing
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步 - 预处理
- en: The first step in the C compilation pipeline is *preprocessing*. A source file
    has a number of header files included. However, before the compilation begins,
    the contents of these files are gathered by the preprocessor as a single body
    of C code. In other words, after the preprocessing step, we get a single piece
    of code created by copying content of the header files into the source file content.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: C 编译管道的第一步是 *预处理*。一个源文件包含多个头文件。然而，在编译开始之前，这些文件的内容由预处理器收集为一个单一的 C 代码体。换句话说，在预处理步骤之后，我们得到一个由将头文件内容复制到源文件内容中创建的单个代码片段。
- en: Also, other *preprocessor directives* must be resolved in this step. This preprocessed
    piece of code is called a *translation unit*. A translation unit is a single logical
    unit of C code generated by the preprocessor, and it is ready to be compiled.
    A translation unit is sometimes called a *compilation unit* as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，其他 *预处理指令* 也必须在这一步中解决。这个预处理后的代码片段被称为 *翻译单元*。翻译单元是预处理器生成的单个 C 代码逻辑单元，并且已经准备好进行编译。翻译单元有时也被称为
    *编译单元*。
- en: '**Note**:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**:'
- en: In a translation unit, no preprocessing directives can be found. As a reminder,
    all preprocessing directives in C (and C++) start with `#`, for example, `#include`
    and `#define`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个翻译单元中，找不到任何预处理指令。提醒一下，C（和 C++）中的所有预处理指令都以 `#` 开头，例如 `#include` 和 `#define`。
- en: It is possible to ask compilers to dump the translation unit without compiling
    it further. In the case of `gcc`, it is enough to pass the `-E` option (this is
    case-sensitive). In some rare cases, especially when doing cross-platform development,
    examining the translation units could be useful when fixing weird issues.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以要求编译器在进一步编译之前转储翻译单元。在 `gcc` 的情况下，只需传递 `-E` 选项（区分大小写）即可。在某些罕见的情况下，尤其是在进行跨平台开发时，检查翻译单元在修复奇怪问题时可能很有用。
- en: 'In the following code, you can see the translation unit for `ExtremeC_examples_chapter2_1.c`,
    which has been generated by `gcc` on our default platform:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，您可以看到由 `gcc` 在我们的默认平台上生成的 `ExtremeC_examples_chapter2_1.c` 的翻译单元：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shell Box 2-1: The produced translation unit while compiling ExtremeC_examples_chapter2_1.c'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 2-1: 编译 ExtremeC_examples_chapter2_1.c 产生的翻译单元'
- en: As you can see, all the declarations are copied from the header file into the
    translation unit. The comments have also been removed from the translation unit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有声明都已从头文件复制到翻译单元中。翻译单元中的注释也已删除。
- en: The translation unit for `ExtremeC_examples_chapter2_1_main.c` is very large
    because it includes the `stdio.h` header file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtremeC_examples_chapter2_1_main.c` 的翻译单元非常大，因为它包含了 `stdio.h` 头文件。'
- en: All declarations from this header file, and further inner header files included
    by it, will be copied into the translation unit recursively. Just to show how
    big the translation unit of `ExtremeC_examples_chapter2_1_main.c` can be, on our
    default platform it has 836 lines of C code!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个头文件中以及它包含的内部头文件中，所有声明都将递归地复制到翻译单元中。为了展示 `ExtremeC_examples_chapter2_1_main.c`
    的翻译单元可以有多大，在我们的默认平台上，它有 836 行 C 代码！
- en: '**Note**:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**:'
- en: The `-E` option works also for the `clang` compiler.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`-E` 选项也适用于 `clang` 编译器。'
- en: This completes the first step. The input to the preprocessing step is a source
    file, and the output is the corresponding translation unit.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了第一步。预处理步骤的输入是一个源文件，输出是相应的翻译单元。
- en: Step 2 – Compilation
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 步 – 编译
- en: Once you have the translation unit, you can go for the second step, which is
    *compilation*. The input to the compilation step is the translation unit, retrieved
    from the previous step, and the output is the corresponding *assembly code*. This
    assembly code is still human-readable, but it is machine-dependent and close to
    the hardware and still needs further processing in order to become machine-level
    instructions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了翻译单元，您就可以进行第二步，即 *编译*。编译步骤的输入是上一步骤检索到的翻译单元，输出是相应的 *汇编代码*。此汇编代码仍然是可读的，但它依赖于机器，并且接近硬件，仍需要进一步处理才能成为机器级指令。
- en: You can always ask `gcc` to stop after performing the second step and dump the
    resulting assembly code by passing the `-S` option (capital S). The output is
    a file with the same name as the given source file but with a `.s` extension.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以始终通过传递 `-S` 选项（大写 S）来请求 `gcc` 在执行第二步后停止，并转储生成的汇编代码。输出文件与给定的源文件具有相同的名称，但扩展名为
    `.s`。
- en: 'In the following shell box, you can see the assembly of the `ExtremeC_examples_chapter2_1_main.c`
    source file. However, when reading the code, you should see that some parts of
    the output are removed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 Shell Box 中，您可以看到 `ExtremeC_examples_chapter2_1_main.c` 源文件的汇编代码。然而，在阅读代码时，您应该注意到输出中的一些部分已被删除：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Shell Box 2-2: The produced assembly code while compiling ExtremeC_examples_chapter2_1.c'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 2-2: 编译 ExtremeC_examples_chapter2_1.c 产生的汇编代码'
- en: As part of the compilation step, the compiler parses the translation unit and
    turns it into assembly code that is specific to the *target architecture*. By
    the target architecture, we mean the hardware or CPU that the program is being
    compiled for and is eventually to be run on. The target architecture is sometimes
    referred to as the *host architecture*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为编译步骤的一部分，编译器解析翻译单元并将其转换为针对 *目标架构* 的特定汇编代码。目标架构是指程序正在为其编译并最终运行的硬件或 CPU。目标架构有时也称为
    *宿主架构*。
- en: '*Shell Box 2-2* shows the assembly code generated for the AMD 64-bit architecture
    and produced by `gcc` running on an AMD 64-bit machine. The following shell box
    contains the assembly code generated for an ARM 32-bit architecture and produced
    by `gcc` running on an Intel x86-64 architecture. Both assembly outputs are generated
    for the same C code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*壳盒2-2*显示了为AMD 64位架构生成的汇编代码，由在AMD 64位机器上运行的`gcc`生成。下面的壳盒包含了为ARM 32位架构生成的汇编代码，由在Intel
    x86-64架构上运行的`gcc`生成。这两个汇编输出都是为相同的C代码生成的：'
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 2-3: The assembly code produced while compiling ExtremeC_examples_chapter2_1.c
    for an ARM 32-bit architecture'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 壳盒2-3：编译ExtremeC_examples_chapter2_1.c为ARM 32位架构时产生的汇编代码
- en: As you can see in shell boxes *2-2* and *2-3*, the generated assembly code is
    different for the two architectures. This is despite the fact that they are generated
    for the same C code. For the latter assembly code, we have used the `arm-linux-gnueabi-gcc`
    compiler on an Intel x64-86 hardware set running Ubuntu 16.04.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在壳盒*2-2*和*2-3*中看到的那样，为两种架构生成的汇编代码是不同的。尽管它们是为相同的C代码生成的，但这一点仍然成立。对于后者的汇编代码，我们在运行Ubuntu
    16.04的Intel x64-86硬件集上使用了`arm-linux-gnueabi-gcc`编译器。
- en: '**Note**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: The target (or host) architecture is the architecture that the source is both
    being compiled for and will be run on. The *build architecture* is the architecture
    that we are using to compile the source. They can be different. For example, you
    can compile a C source for AMD 64-bit hardware on an ARM 32-bit machine.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 目标（或宿主）架构是指源代码既被编译为该架构，也将在该架构上运行。*构建架构*是我们用来编译源代码的架构。它们可能不同。例如，你可以在ARM 32位机器上编译针对AMD
    64位硬件的C源代码。
- en: Producing assembly code from C code is the most important step in the compilation
    pipeline.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将C代码转换为汇编代码是编译管道中最重要的一步。
- en: This is because when you have the assembly code, you are very close to the language
    that a CPU can execute. Because of this important role, the compiler is one of
    the most important and most studied subjects in computer science.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当你有了汇编代码，你就非常接近CPU可以执行的指令语言了。正因为这个重要的角色，编译器是计算机科学中最重要和最被研究的主题之一。
- en: Step 3 – Assembly
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 – 汇编
- en: The next step after compilation is *assembly*. The objective here is to generate
    the actual machine-level instructions (or *machine code*) based on the assembly
    code generated by the compiler in the previous step. Each architecture has its
    own *assembler*, which can translate its own assembly code to its own machine
    code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 编译之后的下一步是*汇编*。这里的目的是根据编译器在前一步生成的汇编代码生成实际的机器级指令（或*机器代码*）。每个架构都有自己的*汇编器*，可以将自己的汇编代码翻译成自己的机器代码。
- en: A file containing the machine-level instructions that we are going to assemble
    in this section is called an *object file*. We know that a C project can have
    several products that are all object files, but in this section, we are mainly
    interested in relocatable object files. This file is, without a doubt, the most
    important temporary product that we can obtain during the build process.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将要汇编的包含机器级指令的文件被称为*目标文件*。我们知道一个C项目可以有多个产品，它们都是目标文件，但在这个章节中，我们主要关注可重定位的目标文件。毫无疑问，这是我们在构建过程中能够获得的最重要临时产品。
- en: '**Note**:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Relocatable object files can be referred to as intermediate object files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可重定位的目标文件可以被称为中间目标文件。
- en: To pull both of the previous steps together, the purpose of this assembly step
    is to generate a relocatable object file out of the assembly code produced by
    the compiler. Every other product that we create will be based on the relocatable
    object files generated by the assembler in this step.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将前两个步骤结合起来，这个汇编步骤的目的是从编译器生成的汇编代码中生成一个可重定位的目标文件。我们创建的每一个其他产品都将基于本步骤中汇编器生成的可重定位目标文件。
- en: We will talk about these other products in the future sections of this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后续部分讨论这些其他产品。
- en: '**Note**:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: '*Binary file* and *object file* are synonyms that refer to a file containing
    machine-level instructions. Note however that the term "binary files" in other
    contexts can have different meanings, for example binary files vs. text files.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*二进制文件*和*目标文件*是同义词，指代包含机器级指令的文件。然而请注意，在其他上下文中，“二进制文件”这个术语可能有不同的含义，例如与文本文件的区别。'
- en: In most Unix-like operating systems, we have an assembler tool called `as`,
    which can be used to produce a relocatable object file from an assembly file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数类 Unix 操作系统中，我们有一个名为 `as` 的汇编器工具，它可以用来从汇编文件生成可重定位目标文件。
- en: However, these object files are not executable, and they only contain the machine-level
    instructions generated for a translation unit. Since each translation unit is
    made up of various functions and global variables, a relocatable object file simply
    contains machine-level instructions for the corresponding functions and the pre-allocated
    entries for the global variables.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些目标文件是不可执行的，它们只包含为翻译单元生成的机器级指令。由于每个翻译单元由各种函数和全局变量组成，可重定位目标文件仅包含对应函数的机器级指令和全局变量的预分配条目。
- en: 'In the following shell box, you can see how `as` is used to produce the relocatable
    object file for `ExtremeC_examples_chapter2_1_main.s`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 Shell Box 中，你可以看到 `as` 是如何用于生成 `ExtremeC_examples_chapter2_1_main.s` 的可重定位目标文件的：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Shell Box 2-4: Producing an object file from the assembly of one of the sources
    in example 2.1'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-4：从示例 2.1 中的一个源文件的汇编中生成一个目标文件
- en: Looking back at the command in the preceding shell box, we can see that the
    `-o` option is used to specify the name of the output object file. Relocatable
    object files usually have a `.o` (or a `.obj` in Microsoft Windows) extension
    in their names, which is why we have passed a filename with `.o` at the end.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前面的 Shell Box 中的命令，我们可以看到 `-o` 选项用于指定输出目标文件的名称。可重定位目标文件通常在其名称中具有 `.o` 扩展名（或在
    Microsoft Windows 中为 `.obj`），这就是为什么我们传递了一个以 `.o` 结尾的文件名。
- en: The content of an object file, either `.o` or `.obj`, is not textual, so you
    would not be able to read it as a human. Therefore, it is common to say that an
    object file has *binary content*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 目标文件的内容，无论是 `.o` 还是 `.obj`，都不是文本的，因此你无法像人类一样阅读它。因此，通常会说目标文件具有 *二进制内容*。
- en: Despite the fact that the assembler can be used directly, like what we did in
    *Shell Box 2-4*, this is not recommended. Instead, good practice would be to use
    the compiler itself to call `as` indirectly in order to generate the relocatable
    object file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管汇编器可以直接使用，就像我们在 *Shell Box 2-4* 中所做的那样，但这并不推荐。相反，良好的做法是使用编译器本身间接调用 `as` 以生成可重定位目标文件。
- en: '**Note**:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: We may use the terms *object file* and *relocatable object file* interchangeably.
    But not all object files are relocatable object files, and, in some contexts,
    it may refer to other types of object files such as shared object files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用术语 *目标文件* 和 *可重定位目标文件* 互换。但并非所有目标文件都是可重定位目标文件，在某些上下文中，它可能指其他类型的对象文件，例如共享对象文件。
- en: If you pass the `-c` option to almost all known C compilers, it will directly
    generate the corresponding object file for the input source file. In other words,
    the `-c` option is equivalent to performing the first three steps all together.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `-c` 选项传递给几乎所有的已知 C 编译器，它将直接为输入源文件生成相应的目标文件。换句话说，`-c` 选项相当于执行前三个步骤的全部。
- en: 'Looking at the following example, you can see that we have used the `-c` option
    to compile `ExtremeC_examples_chapter2_1.c` and generate its corresponding object
    file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下示例，你可以看到我们已经使用了 `-c` 选项来编译 `ExtremeC_examples_chapter2_1.c` 并生成其对应的目标文件：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Shell Box 2-5: Compiling one of the sources in example 2.1 and producing its
    corresponding relocatable object file'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-5：编译示例 2.1 中的一个源文件并生成其对应的目标文件
- en: All of the steps we have just done – preprocessing, compilation, and assembling
    – are done as part of the preceding single command. What this means for us is
    that after running the preceding command, a relocatable object file will be generated.
    This relocatable object file will have the same name as the input source file;
    however, it will differ by having a `.o` extension.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成的全部步骤——预处理、编译和汇编——都是作为前面单个命令的一部分完成的。这意味着在运行前面的命令之后，将生成一个可重定位目标文件。这个可重定位目标文件将与输入源文件具有相同的名称；然而，它将具有
    `.o` 扩展名。
- en: '**IMPORTANT**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要**：'
- en: Note that, often, the term *compilation* is used to refer to the first three
    steps in the compilation pipeline all together, and not just the second step.
    It is also possible that we use the term "compilation" but actually mean "building;"
    encompassing all four steps. For instance, we say *C compilation pipeline*, but
    we actually mean *C build pipeline*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通常，术语*编译*被用来指代编译管道中的前三个步骤，而不仅仅是第二个步骤。也有可能我们使用“编译”这个术语，但实际上意味着“构建”，包括所有四个步骤。例如，我们说*C编译管道*，但实际上我们指的是*C构建管道*。
- en: The assembly is the last step in compiling a single source file. In other words,
    when we have the corresponding relocatable object file for a source file, we are
    done with its compilation. At this stage we can put aside the relocatable object
    file and continue compiling other source files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编是编译单个源文件的最后一步。换句话说，当我们有了源文件的相应可重定位对象文件时，我们就完成了它的编译。在这个阶段，我们可以把可重定位对象文件放在一边，继续编译其他源文件。
- en: 'In *example 2.1*, we have two source files that need to be compiled. By executing
    the following commands, it compiles both source files and as a result, produces
    their corresponding object files:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例2.1*中，我们有两个需要编译的源文件。通过执行以下命令，它编译了这两个源文件，并因此产生了它们相应的对象文件：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Shell Box 2-6: Producing the relocatable object files for the sources in example
    2.1'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-6：为示例2.1中的源代码生成可重定位对象文件
- en: You can see in the preceding commands that we have changed the names of the
    object files by specifying our desired names using the `-o` option. As a result,
    after compiling both of them, we get the `impl.o` and `main.o` relocatable object
    files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从前面的命令中看到，我们已经通过使用`-o`选项指定我们希望的名字来更改了对象文件的名字。因此，编译完它们之后，我们得到了`impl.o`和`main.o`的可重定位对象文件。
- en: At this point, we need to remind ourselves that relocatable object files are
    not executable. If a project is going to have an executable file as its final
    product, we need to use all, or at the very least, some, of the already produced
    relocatable object files to build the target executable file through the linking
    step.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要提醒自己，可重定位对象文件不是可执行的。如果一个项目最终产品是一个可执行文件，我们需要使用所有，或者至少是其中的一些，已经产生的可重定位对象文件，通过链接步骤构建目标可执行文件。
- en: Step 4 – Linking
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步 – 链接
- en: We know that *example 2.1* needs to be built to an executable file because we
    have a `main` function in it. However, at this point, we only have two relocatable
    object files. Therefore, the next step is to combine these relocatable object
    files in order to create another object file that is executable. The *linking*
    step does exactly that.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道*示例2.1*需要构建成可执行文件，因为我们里面有一个`main`函数。然而，在这个时候，我们只有两个可重定位对象文件。因此，下一步是将这些可重定位对象文件组合起来，以创建另一个可执行的对象文件。*链接*步骤正是如此。
- en: However, before we go through the linking step, we need to talk about how we
    add support for a new architecture, or hardware, to an existing Unix-like system.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们进入链接步骤之前，我们需要讨论如何将新架构或硬件的支持添加到现有的类Unix系统中。
- en: Supporting new architectures
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持新的架构
- en: We know that every architecture has a series of manufactured processors and
    that every processor can execute a specific instruction set.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道每个架构都有一系列制造的处理器，并且每个处理器都可以执行特定的指令集。
- en: The instruction set has been designed by vendor companies such as Intel and
    ARM for their processors. In addition, these companies also design a specific
    assembly language for their architecture.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集是由Intel和ARM等供应商公司为他们的处理器设计的。此外，这些公司还为他们的架构设计了一种特定的汇编语言。
- en: 'A program can be built for a new architecture if two prerequisites are satisfied:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足以下两个先决条件，可以为新的架构构建程序：
- en: The assembly language is known.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇编语言是已知的。
- en: The required assembler tool (or program) developed by the vendor company must
    be at hand. This allows us to translate the assembly code into the equivalent
    machine-level instructions.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必需的汇编器工具（或程序）必须由供应商公司提供。这使我们能够将汇编代码翻译成等效的机器级指令。
- en: Once these prerequisites are in place, it would be possible to generate machine-level
    instructions from C source code. Only then, we are able to store the generated
    machine-level instructions within the object files using an *object file format*.
    As an example, this could be in the form of either *ELF* or *Mach-O*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些先决条件就绪，就可以从C源代码生成机器级指令。只有在这种情况下，我们才能使用*对象文件格式*将生成的机器级指令存储在对象文件中。例如，这可以是*ELF*或*Mach-O*的形式。
- en: When the assembly language, assembler tool, and object file format are clear,
    they can be used to develop some further tools that are necessary for us developers
    when doing C programming. However, you hardly notice their existence since you are
    often dealing with a C compiler, and it is using these tools on your behalf.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当汇编语言、汇编工具和目标文件格式清晰时，我们可以使用它们来开发一些对我们开发者进行C编程时必要的进一步工具。然而，由于你经常在处理C编译器，并且它是在你的
    behalf 使用这些工具，所以你几乎注意不到它们的存。
- en: 'The two immediate tools that are required for a new architecture are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个新的架构，所需的两个直接工具如下：
- en: C compiler
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C编译器
- en: Linker
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接器
- en: These tools are like the first fundamental building blocks for supporting a
    new architecture in an operating system. The hardware together with these tools
    in an operating system give rise to a new platform.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具就像是支持操作系统中新架构的第一个基本构建块。硬件与操作系统中的这些工具结合在一起，产生了一个新的平台。
- en: Regarding Unix-like systems, it is important to remember that Unix has a modular
    design. If you are able to build a few fundamental modules like the assembler,
    compiler, and linker, you will be able to build other modules on top of them and
    before long, the whole system is working on a new architecture.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类Unix系统，重要的是要记住Unix有一个模块化设计。如果你能够构建一些基本模块，比如汇编器、编译器和链接器，你将能够在这之上构建其他模块，不久整个系统就会在新架构上运行。
- en: Step details
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤详情
- en: With all that's been said before, we know that platforms using Unix-like operating
    systems must have the previously discussed mandatory tools, such as an assembler
    and a linker, in order to work. Remember, the assembler and the linker can be
    run separately from the compiler.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前所说的那样，我们知道使用类Unix操作系统的平台必须具有之前讨论的强制工具，如汇编器和链接器，才能工作。记住，汇编器和链接器可以从编译器中单独运行。
- en: 'In Unix-like systems, `ld` is the default linker. The following command, which
    you can see in the following shell box, shows us how to use `ld` directly when
    we want to create an executable from the relocatable object files we produced
    in the previous sections for *example 2.1*. However, as you will see, it is not
    that easy to use the linker directly:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在类Unix系统中，`ld`是默认的链接器。以下命令，你可以在下面的shell box中看到，展示了当我们想要从之前章节中为*example 2.1*生成的可重定位目标文件中直接使用`ld`创建可执行文件时如何使用`ld`。然而，正如你将看到的，直接使用链接器并不那么容易：
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Shell Box 2-7: Trying to link the object files using the ld utility directly'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-7：尝试使用ld工具直接链接目标文件
- en: As you see, the command has failed, and it has generated some error messages.
    If you pay attention to the error messages, they say that in three places in the
    Text segment `ld` has encountered three function calls (or *references*) that
    are *undefined*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命令失败了，并生成了一些错误信息。如果你注意这些错误信息，它们说在文本段的三个地方`ld`遇到了三个未定义的函数调用（或*引用*）。
- en: Two of these function calls are calls to the `printf` function, which we did
    in the `main` function. However, the other one, `__stack_chk_fail`, has not been
    called by us. It is coming from somewhere else, but where? It has been called
    from the supplementary code that has been put into the relocatable object files
    by the compiler, and this function is specific to Linux, and you may not find
    it in the same object files generated on other platforms. However, whatever it
    is and whatever it does, the linker is looking for its definition and it seems
    that it cannot find the definition in the provided object files.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数调用是调用`printf`函数，我们在`main`函数中实现了它。然而，另一个`__stack_chk_fail`函数我们没有调用过。它来自别处，但究竟在哪里呢？它是从编译器放入可重定位目标文件的补充代码中调用的，这个函数是针对Linux的，你可能在其他平台上生成的相同目标文件中找不到它。然而，无论它是什么，无论它做什么，链接器都在寻找它的定义，而且似乎它无法在提供的对象文件中找到定义。
- en: Like we said before, the default linker, `ld`, has generated these errors because
    it has not been able to find the definitions of these functions. Logically, this
    makes sense, and is true, because we have not defined `printf` and `__stack_chk_fail`
    ourselves in *example 2.1*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前说的那样，默认的链接器`ld`生成这些错误是因为它无法找到这些函数的定义。从逻辑上讲，这是有道理的，也是真实的，因为我们没有在*example
    2.1*中自己定义`printf`和`__stack_chk_fail`。
- en: This means that we should have given `ld` some other object files, though not
    necessarily relocatable object files, that contain the definitions of the `printf`
    and `__stack_chk_fail` functions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应该给`ld`提供一些其他的目标文件，虽然不一定是可重定位的目标文件，它们包含`printf`和`__stack_chk_fail`函数的定义。
- en: Reading what we have just said should explain why it can be very hard to use
    `ld` directly. Namely, there are more object files and options that need to be
    specified in order to make `ld` work and generate a working executable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读我们刚才所说的，应该可以解释为什么直接使用`ld`可能非常困难。也就是说，需要指定更多的对象文件和选项，以便使`ld`工作并生成一个可工作的可执行文件。
- en: Fortunately, in Unix-like systems, the most well-known C compilers use `ld`
    by passing proper options and specifying extra required object files. Hence, we
    do not need to use `ld` directly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在类Unix系统中，最著名的C编译器通过传递适当的选项并指定额外的必需对象文件来使用`ld`。因此，我们不需要直接使用`ld`。
- en: 'Therefore, let''s look at a much simpler way of producing the final executable
    file. The following shell box shows us how we can use `gcc` to link the object
    files from *example 2.1*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看一种更简单的方法来生成最终的可执行文件。下面的shell框图展示了我们如何使用`gcc`来链接来自*示例2.1*的对象文件：
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Shell Box 2-8: Using gcc to link the object files'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Shell框2-8：使用gcc链接对象文件
- en: As a result of running these commands, we can breathe because we have finally
    managed to build *example 2.1* and run its final executable!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些命令的结果是，我们可以松一口气，因为我们终于成功构建了*示例2.1*并运行了其最终的可执行文件！
- en: '**Note**:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Building a project is equivalent to compiling the sources firstly and then linking
    them together, and possibly other libraries, to create the final products.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个项目等同于首先编译源代码，然后将它们链接在一起，可能还有其他库，以创建最终产品。
- en: It is important to take a minute to pause and reflect on what we have just done.
    Over the last few sections we have successfully built *example 2.1* by compiling
    its sources into relocatable object files, and finally linking the generated object
    files to create the final executable binary.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是花一分钟暂停并反思我们刚刚所做的事情。在过去的几个部分中，我们通过编译源代码为可重定位对象文件，并最终将这些生成的对象文件链接起来，成功地构建了*示例2.1*。
- en: While this process will be the same for any C/C++ code base, the difference
    will be in the number of times you need to compile sources, which itself depends
    on the number of source files in your project.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个过程对于任何C/C++代码库都是相同的，但区别在于你需要编译源代码的次数，这本身取决于你的项目中源文件的数量。
- en: While the compilation pipeline has some steps, in each step, there is a specific
    component involved. The focus of the remaining sections of this chapter will be
    delving into the critical information surrounding each component in the pipeline.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编译管道有一些步骤，但在每个步骤中，都涉及一个特定的组件。本章剩余部分的焦点将深入探讨管道中每个组件周围的关键信息。
- en: To start this, we are going to focus on the preprocessor component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个过程，我们将重点关注预处理程序组件。
- en: Preprocessor
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理程序
- en: At the very start of this book in *Chapter 1*, *Essential Features*, we introduced,
    albeit briefly, the concepts of *C preprocessor*. Specifically, we talked there
    about macros, conditional compilation, and header guards.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的*第一章*，*基本特性*中，我们简要介绍了*C预处理程序*的概念。具体来说，我们当时讨论了宏、条件编译和头文件保护。
- en: You will remember that at the beginning of the book, we discussed C preprocessing
    as an essential feature of the C language. Preprocessing is unique due to the
    fact that it cannot be easily found in other programming languages. In the simplest
    terms, preprocessing allows you to modify your source code before sending it for
    compilation. At the same time, it allows you to divide your source code, especially
    the declarations, into header files so that you can later include them into multiple
    source files and reuse those declarations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，在本书的开头，我们讨论了C预处理作为C语言的一个基本特性。预处理之所以独特，是因为它不能轻易地在其他编程语言中找到。最简单的说法是，预处理允许你在发送代码进行编译之前修改你的源代码。同时，它允许你将源代码（尤其是声明）分成头文件，这样你就可以稍后将其包含到多个源文件中并重用这些声明。
- en: 'It is vital to remember that if you have a syntax error in your source code,
    the preprocessor will not find the error as it does not know anything about the
    C syntax. Instead, it will just perform some easy tasks, which typically revolve
    around text substitutions. As an example, imagine that you have a text file named `sample.c`
    with the following content:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点至关重要：如果你在源代码中有语法错误，预处理程序不会找到错误，因为它对C语法一无所知。相反，它只会执行一些简单的任务，这些任务通常围绕文本替换。例如，假设你有一个名为`sample.c`的文本文件，其内容如下：
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 2-6: C code containing some text!'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-6：包含一些文本的C代码！
- en: 'Having the preceding code, let us preprocess the file using `gcc`. Note that
    some parts of the following shell box have been removed. This is because including
    `stdio.h` makes the translation unit very big:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了前面的代码之后，让我们使用`gcc`来预处理文件。请注意，以下Shell Box中的某些部分已被删除。这是因为包含`stdio.h`会使翻译单元变得非常大：
- en: '[PRE14]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Shell Box 2-9: The preprocessed sample C code seen in Code Box 2-6'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-9：在代码框2-6中看到的预处理后的C代码示例
- en: As you see in the preceding shell box, the content of `stdio.h` is copied before
    the text.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的Shell Box中看到的，`stdio.h`的内容在文本之前被复制。
- en: If you pay more attention, you will see that another interesting substitution
    has also happened. The occurrences of the `file` have been replaced by `1000`
    in the text.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更加留意，你会看到另一个有趣的替换也发生了。文本中的`file`出现都被替换成了`1000`。
- en: This example shows us exactly how the preprocessor works. The preprocessor only
    does simple tasks, such as inclusion, by copying contents from a file or expanding
    the macros by text substitution. It does not know anything about C though; it
    needs a parser to parse the input file before performing any further tasks. This
    means that a C preprocessor uses a parser, which looks for directives in the input code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子确切地展示了预处理器是如何工作的。预处理器只执行简单的任务，例如通过复制文件内容或通过文本替换来扩展宏。尽管如此，它对C语言一无所知；在执行任何进一步的任务之前，它需要一个解析器来解析输入文件。这意味着C预处理器使用一个解析器，该解析器在输入代码中寻找指令。
- en: '**Note**:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Generally, a parser is a program that processes the input data and extracts
    some certain parts of it for further analysis and processing. Parsers need to
    know the structure of the input data in order to break it down into some smaller
    and useful pieces of data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，解析器是一个程序，它处理输入数据并从中提取某些部分以进行进一步的分析和处理。解析器需要了解输入数据的结构，以便将其分解成一些更小且有用的数据块。
- en: The preprocessor's parser is different from the parser used by a C compiler
    because it uses grammar that is almost independent of C grammar. This enables
    us to use it in circumstances other than preprocessing a C file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器的解析器与C编译器使用的解析器不同，因为它使用的是几乎独立于C语法的语法。这使得我们能够在除了预处理C文件之外的其他情况下使用它。
- en: '**Note**:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: By exploiting the functionalities of a C preprocessor, you could use file inclusion
    and macro expansion for other purposes other than building a C program. They could
    be used to process other text files as well.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用C预处理器的功能，你可以将文件包含和宏扩展用于除了构建C程序以外的其他目的。它们也可以用于处理其他文本文件。
- en: '[*The GNU C Preprocessor Int*](http://www.chiark.greenend.org.uk/doc/cpp-4.3-doc/cppinternals.html)*ernals*
    – [http://www.chiark.greenend.org.uk/doc/cpp-4.3-doc/cppinternals.html](http://www.chiark.greenend.org.uk/doc/cpp-4.3-doc/cppinternals.html)
    – is a great source for learning more about the `gcc` preprocessor. This document
    is an official source that describes how the GNU C preprocessor works. The GNU
    C preprocessor is used by the `gcc` compiler to preprocess the source files.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[*GNU C预处理器内部机制*](http://www.chiark.greenend.org.uk/doc/cpp-4.3-doc/cppinternals.html)*
    – [http://www.chiark.greenend.org.uk/doc/cpp-4.3-doc/cppinternals.html](http://www.chiark.greenend.org.uk/doc/cpp-4.3-doc/cppinternals.html)
    – 是学习更多关于`gcc`预处理器的好资源。这份文档是官方资料，描述了GNU C预处理器的工作原理。GNU C预处理器被`gcc`编译器用于预处理源文件。'
- en: In the preceding link, you can find how the preprocessor parses the directives
    and how it creates the *parse tree*. The document also provides an explanation
    of the different macro expansion algorithms. While it is outside of the scope
    of this chapter, if you wanted to implement your own preprocessor for a specific
    in-house programming language, or just for processing some text files, then the
    above link provides some great context.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的链接中，你可以找到预处理器如何解析指令以及它如何创建*解析树*的信息。文档还提供了不同宏扩展算法的解释。虽然这超出了本章的范围，但如果你想要为特定的内部编程语言实现自己的预处理器，或者只是处理一些文本文件，那么上述链接提供了很好的背景信息。
- en: 'In most Unix-like operating systems, there is a tool called **cpp**, which
    stands for **C Pre-Processor** – and not C Plus Plus! `cpp` is part of the C development
    bundle that is shipped with each flavor of Unix. It can be used to preprocess
    a C file. In the background, the tool is used by a C compiler, like `gcc`, to
    preprocess a C file. If you have a source file, you can use it, in a similar way
    to what we have done next, to preprocess a source file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数类Unix操作系统中，有一个名为**cpp**的工具，代表**C预处理器**——而不是C++！`cpp`是随每个Unix版本一起提供的C开发包的一部分。它可以用来预处理C文件。在后台，该工具被C编译器，如`gcc`，用来预处理C文件。如果你有一个源文件，你可以使用它，就像我们接下来要做的那样，来预处理源文件：
- en: '[PRE15]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Shell Box 2-10: Using the cpp utility to preprocess source code'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-10：使用cpp工具预处理源代码
- en: As a final note in this section, if you pass a file with the extension `.i`
    to a C compiler, then it will bypass the preprocessor step. It does this because
    a file with a `.i` extension is supposed to have already been preprocessed. Therefore,
    it should be sent directly to the compilation step.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一点，如果你将一个扩展名为`.i`的文件传递给C编译器，那么它将跳过预处理步骤。它这样做是因为具有`.i`扩展名的文件应该已经被预处理过。因此，它应该直接进入编译步骤。
- en: 'If you insist on running the C preprocessor for a file with a `.i` extension,
    then you will get the following warning message. Note that the following shell
    box is produced with the `clang` compiler:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你坚持要对扩展名为`.i`的文件运行C预处理器，那么你将得到以下警告信息。请注意，以下shell窗口是由`clang`编译器生成的：
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Shell Box 2-11: Passing an already preprocessed file, with extension .i, to
    the clang compiler'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-11：将已预处理的文件（扩展名为.i）传递给clang编译器
- en: As you can see, `clang` warns us that the file has been already preprocessed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`clang`警告我们该文件已经被预处理过。
- en: In the next section of this chapter, we are going to specifically talk about
    the compiler component in the C compilation pipeline.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节，我们将专门讨论C编译管道中的编译器组件。
- en: Compiler
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器
- en: As we discussed in the previous sections, the compiler accepts the translation
    unit prepared by the preprocessor and generates the corresponding assembly instructions.
    When multiple C sources are compiled into their equivalent assembly code, the
    existing tools in the platform, such as the assembler and the linker, manage the
    rest by making relocatable object files out of the generated assembly code and
    finally linking them together (and possibly with other object files) to form a
    library or an executable file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中讨论的，编译器接受预处理程序准备的翻译单元，并生成相应的汇编指令。当多个C源文件编译成它们等价的汇编代码时，平台中现有的工具，如汇编器和链接器，通过将生成的汇编代码制作成可重定位对象文件来管理其余部分，并最终将它们（以及可能的其他对象文件）链接在一起，形成一个库或可执行文件。
- en: As an example, we spoke about `as` and `ld` as two examples among the many available
    tools in Unix for C development. These tools are mainly used to create platform-compatible
    object files. These tools exist necessarily outside of `gcc` or any other compiler.
    By existing outside of any compiler, we actually mean that they are not developed
    as a part of `gcc` (we have chosen `gcc` as an example) and they should be available
    on any platform even without having `gcc` installed. `gcc` only uses them in its
    compilation pipeline, and they are not embedded into `gcc`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们提到了`as`和`ld`作为Unix中许多C开发工具中的两个例子。这些工具主要用于创建与平台兼容的对象文件。这些工具必须在`gcc`或其他任何编译器之外存在。通过在任何编译器之外存在，我们实际上是指它们不是作为`gcc`（我们以`gcc`为例）的一部分开发的，并且它们应该在任何平台上都可用，即使没有安装`gcc`。`gcc`只在它的编译管道中使用它们，并且它们没有被嵌入到`gcc`中。
- en: That is because the platform itself is the most knowledgeable entity that knows
    about the instruction set accepted by its processor and the operating system-specific
    formats and restrictions. The compiler is not usually aware of these constraints
    unless it wants to do some *optimization* on the translation unit. Therefore,
    we can conclude that the most important task that `gcc` does is to translate the
    translation unit into assembly instructions. This is what we actually call compilation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为平台本身是关于其处理器接受的指令集以及特定操作系统的格式和限制最了解的实体。编译器通常不会意识到这些限制，除非它想要对翻译单元进行一些**优化**。因此，我们可以得出结论，`gcc`最重要的任务是将翻译单元翻译成汇编指令。这就是我们所说的编译过程。
- en: One of the challenges in C compilation is to generate correct assembly instructions
    that can be accepted by the target architecture. It is possible to use `gcc` to
    compile the same C code for various architectures such as ARM, Intel x86, AMD,
    and many more. As we discussed before, each architecture has an instruction set
    that is accepted by its processor, and `gcc` (or any C compiler) is the sole responsible
    entity that should generate correct assembly code for a specific architecture.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: C编译中的一个挑战是生成目标架构可以接受的正确汇编指令。可以使用`gcc`为各种架构编译相同的C代码，例如ARM、Intel x86、AMD等等。正如我们之前讨论的，每个架构都有一个其处理器可以接受的指令集，`gcc`（或任何C编译器）是唯一负责生成特定架构正确汇编代码的实体。
- en: The way that `gcc` (or any other C compiler) overcomes this difficulty is to
    split the mission into two steps, first parsing the translation unit into an relocatable
    and C-independent data structure called an **Abstract Syntax Tree** (**AST**),
    and then using the created AST to generate the equivalent assembly instructions
    for the target architecture. The first part is architecture-independent and can
    be done regardless of the target instruction set. But the second step is architecture-dependent,
    and the compiler should be aware of the target instruction set. The subcomponent
    that performs the first step is called a *compiler frontend*, and the subcomponent
    that performs the later step is called a *compiler backend*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc`（或任何其他C编译器）克服这种困难的方法是将任务分为两个步骤，首先将翻译单元解析成一个可重定位且与C无关的数据结构，称为**抽象语法树**（**AST**），然后使用创建的AST为目标架构生成等效的汇编指令。第一个步骤是架构无关的，可以在不考虑目标指令集的情况下完成。但第二个步骤是架构相关的，编译器应该了解目标指令集。执行第一个步骤的子组件称为*编译器前端*，执行后续步骤的子组件称为*编译器后端*。'
- en: In the following sections, we are going to discuss these steps in more depth.
    First, let's talk about the AST.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地讨论这些步骤。首先，让我们谈谈AST。
- en: Abstract syntax tree
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象语法树
- en: As we have explained in the previous section, a C compiler frontend should parse
    the translation unit and create an intermediate data structure. The compiler creates
    this intermediate data structure by parsing the C source code according to the
    *C grammar* and saving the result in a tree-like data structure that is *not*
    architecture-dependent. The final data structure is commonly referred to as an
    AST.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中解释的，C编译器前端应该解析翻译单元并创建一个中间数据结构。编译器通过根据*C语法*解析C源代码来创建这个中间数据结构，并将结果保存在一个*不*依赖于架构的树状数据结构中。最终的数据结构通常被称为AST。
- en: ASTs can be generated for any programming language, not only C, so the AST structure
    must be abstract enough to be independent of C syntax.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: AST可以为任何编程语言生成，而不仅仅是C，因此AST结构必须足够抽象，以独立于C语法。
- en: This is enough to change the compiler frontend to support other languages. This
    is exactly why you can find **GNU Compiler Collection** (**GCC**), which `gcc`
    is a part of as the C compiler, or **Low-Level Virtual Machine** (**LLVM**), which
    `clang` is a part of as the C compiler, as a collection of compilers for many
    languages beyond just C and C++ such as Java, Fortran, and so on.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足以将编译器前端修改为支持其他语言。这正是为什么你可以找到**GNU编译器集合**（**GCC**），`gcc`是其一部分作为C编译器，或者**低级虚拟机**（**LLVM**），`clang`是其一部分作为C编译器，作为一个支持许多语言的编译器集合，而不仅仅是C和C++，例如Java、Fortran等等。
- en: 'Once the AST is produced, the compiler backend can start to optimize the AST
    and generate assembly code based on the optimized AST for a target architecture.
    To get a better understanding of ASTs, we are going to take a look at a real AST.
    In this example, we have the following C source code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了AST，编译器后端就可以开始优化AST，并基于优化后的AST为目标架构生成汇编代码。为了更好地理解AST，我们将查看一个真实的AST。在这个例子中，我们有以下C源代码：
- en: '[PRE17]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Code Box 2-7 [ExtremeC_examples_chapter2_2.c]: Simple C code whose AST is going
    to be generated'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-7 [ExtremeC_examples_chapter2_2.c]：将要生成AST的简单C代码
- en: 'The next step is to use `clang` to dump the AST within the preceding code.
    In the following figure, *Figure 2-1*, you can see the AST:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用`clang`在前面代码中输出AST。在下面的图中，*图2-1*，你可以看到AST：
- en: '![](img/B11046_02.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B11046_02.png)'
- en: 'Figure 2-1: The AST generated and dumped for example 2.2'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1：为示例2.2生成的AST及其输出
- en: So far, we have used `clang` in various places as a C compiler, but let's introduce
    it properly. `clang` is a C compiler frontend developed by the LLVM Developer
    Group for the `llvm` compiler backend. The *LLVM Compiler Infrastructure Project*
    uses an *intermediate representation* – or *LLVM IR* – as its abstract data structure
    used between its frontend and its backend. LLVM is famous for its ability to dump
    its IR data structure for research purposes. The preceding tree-like output is
    the IR generated from the source code of *example 2.2*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在多个地方使用了`clang`作为C编译器，但让我们正确地介绍它。`clang`是由LLVM开发者小组为`llvm`编译器后端开发的C编译器前端。*LLVM编译器基础设施项目*使用*中间表示*——或*LLVM
    IR*——作为其前端和后端之间使用的抽象数据结构。LLVM因其能够将其IR数据结构导出以供研究而闻名。前面的树形输出是从*示例2.2*的源代码生成的IR。
- en: What we have done here is introduce you to the basics of AST. We are not going
    through the details of the preceding AST output because each compiler has its
    own AST implementation. We would require several chapters to cover all of the
    details on this, and that is beyond the scope of this book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是向您介绍AST（抽象语法树）的基础知识。我们不会深入探讨前面AST输出的细节，因为每个编译器都有自己的AST实现。要涵盖所有这些细节，我们需要几章内容，而这超出了本书的范围。
- en: However, if you pay attention to the above figure, you can find a line that
    starts with -`FunctionDecl`. This represents the `main` function. Before that,
    you can find meta information regarding the translation unit passed to the compiler.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你注意上面的图，你可以找到一个以-`FunctionDecl`开头的行。这代表`main`函数。在此之前，你可以找到有关传递给编译器的翻译单元的元信息。
- en: If you continue after `FunctionDecl`, you will find tree entries – or *nodes*
    – for declaration statements, binary operator statements, the return statement,
    and even implicit cast statements. There are lots of interesting things residing
    in an AST, with countless things to learn!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你继续阅读`FunctionDecl`之后的内容，你会找到声明语句、二元运算符语句、返回语句甚至隐式转换语句的树形条目——或*节点*。AST中有很多有趣的东西，有无数的东西可以学习！
- en: Another benefit of having an AST for source code is that you can rearrange the
    order of instructions, prune some unused branches, and replace branches so that
    you have better performance but preserve the purpose of the program. As we pointed
    out before, it is called optimization and it is usually done to a certain configurable
    extent by any C compiler.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有源代码的AST的另一个好处是，你可以重新排列指令的顺序，剪枝一些未使用的分支，并替换分支，以便你获得更好的性能，同时保留程序的目的。正如我们之前指出的，这被称为优化，并且通常任何C编译器都会在一定可配置的程度上进行优化。
- en: The next component that we are going to discuss in more detail is the assembler.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将要更详细讨论的下一个组件是汇编器。
- en: Assembler
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编器
- en: As we explained before, a platform has to have an assembler in order to produce
    object files that contain correct machine-level instructions. In a Unix-like operating
    system, the assembler can be invoked by using the `as` utility program. In the
    rest of this section, we are going to discuss what can be put in an object file
    by the assembler.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，一个平台必须有一个汇编器来生成包含正确机器级指令的目标文件。在类Unix操作系统中，汇编器可以通过使用`as`实用程序来调用。在本节的其余部分，我们将讨论汇编器可以在目标文件中放入的内容。
- en: If you install two different Unix-like operating systems on the same architecture,
    the installed assemblers might not be the same, which is very important. What
    this means is that, despite the fact that the machine-level instructions are the
    same, because of being on the same hardware, the produced object files can be
    different!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在同一架构上安装两个不同的类Unix操作系统，安装的汇编器可能不同，这非常重要。这意味着，尽管机器级指令相同，但由于在相同硬件上运行，生成的目标文件可能不同！
- en: If you compile a program and produce the corresponding object file on Linux
    for an AMD64 architecture, it could be different from if you had tried to compile
    the same program in a different operating system such as FreeBSD or macOS, and
    on the same hardware. This implies that while the object files cannot be the same,
    they do contain the same machine-level instructions. This proves that object files
    can have different formats in various operating systems.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为Linux上的AMD64架构编译一个程序并生成相应的目标文件，它可能与你在不同的操作系统（如FreeBSD或macOS）上编译相同程序，或者在相同硬件上编译时有所不同。这意味着虽然目标文件可能不同，但它们确实包含相同的机器级指令。这证明了在不同的操作系统中，目标文件可以有不同的格式。
- en: 'In other words, each operating system defines its own specific binary format
    or *object file format* when it comes to storing machine-level instructions within
    object files. Therefore, there are two factors that specify the contents of an
    object file: the architecture (or hardware) and the operating system. Typically,
    we will use the term platform for such a combination.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每个操作系统在存储对象文件中的机器级指令时，都会定义自己的特定二进制格式或*目标文件格式*。因此，有两个因素指定了对象文件的内容：架构（或硬件）和操作系统。通常，我们将使用术语平台来指这种组合。
- en: To round off this section, we usually say that object files, hence the assembler
    generating them, are platform-specific. In Linux, we use the **Executable and
    Linking Format** (**ELF**). As the name implies, all executable files, object
    files, and shared libraries should use this format. In other words, in Linux,
    the assembler produces ELF object files. In the upcoming chapter, *Object Files*,
    we will discuss object files and their formats in greater detail.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本节，我们通常会说，目标文件，因此生成它们的汇编器，是平台特定的。在Linux中，我们使用**可执行和链接格式**（**ELF**）。正如其名所示，所有可执行文件、目标文件和共享库都应该使用此格式。换句话说，在Linux中，汇编器生成ELF目标文件。在即将到来的章节“目标文件”中，我们将更详细地讨论目标文件及其格式。
- en: In the following section, we will take a deeper look at the *linker* component.
    We will demonstrate and explain how the component actually produces the final
    products in a C project.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地探讨*链接器*组件。我们将演示并解释该组件实际上是如何在C项目中生成最终产品的。
- en: Linker
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接器
- en: The first big step in building a C project is compiling all the source files
    to their corresponding relocatable object files. This step is a necessary step
    in preparing the final products, but alone, it is not enough, and one more step
    is still needed. Before going through the details of this step, we need to have
    a quick look at the possible *products* (sometimes referred to as *artifacts*)
    in a C project.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 构建C项目的第一步是将所有源文件编译成它们对应的目标文件。这一步骤是准备最终产品的必要步骤，但仅此还不够，还需要再进行一步。在详细讨论这一步骤之前，我们需要快速看一下C项目中可能的*产品*（有时被称为*工件*）。
- en: 'A C/C++ project can lead to the following products:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++项目可以导致以下产品：
- en: A number of executable files that usually have the `.out` extension in most
    Unix-like operating systems. These files usually have the `.exe` extension in Microsoft
    Windows.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列可执行文件，通常在大多数类Unix操作系统中具有`.out`扩展名。这些文件通常在Microsoft Windows中具有`.exe`扩展名。
- en: A number of static libraries that usually have the `.a` extension in most Unix-like
    operating systems. These files have the `.lib` extension in Microsoft Windows.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列静态库，通常在大多数类Unix操作系统中具有`.a`扩展名。这些文件在Microsoft Windows中具有`.lib`扩展名。
- en: A number of dynamic libraries or shared object files that usually have the `.so`
    extension in most Unix-like operating systems. These files have the `.dylib` extension
    in macOS, and `.dll` in Microsoft Windows.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列动态库或共享目标文件，通常在大多数类Unix操作系统中具有`.so`扩展名。这些文件在macOS中具有`.dylib`扩展名，在Microsoft
    Windows中具有`.dll`扩展名。
- en: Relocatable object files are not considered as one of these products; hence,
    you cannot find them in the preceding list. Relocatable object files are temporary
    products simply because they only take part in the linking step to produce the
    preceding products, and after that, we don't need them anymore. The linker component
    has the sole responsibility of producing the preceding products from the given
    relocatable object files.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可重定位目标文件不被视为这些产品之一；因此，您无法在前面列表中找到它们。可重定位目标文件仅仅是临时产品，因为它们只参与链接步骤以生成前面的产品，之后我们就不再需要它们了。链接器组件的唯一责任是从给定的可重定位目标文件生成前面的产品。
- en: 'One final and important note about the used terminology: all these three products
    are called *object files*. Therefore, it is best to use the term **relocatable**
    before the term object file when referring to an object file produced by the assembler
    as an intermediate product.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所使用的术语的最后一个重要说明：这三个产品都被称为*目标文件*。因此，在提到汇编器生成的作为中间产品的目标文件时，最好在目标文件之前使用术语**可重定位**。
- en: We'll now briefly describe each of the final products. The upcoming chapter
    is totally dedicated to the object files and it will discuss these final products
    in greater detail.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将简要描述每个最终产品。接下来的章节将完全致力于目标文件，并将更详细地讨论这些最终产品。
- en: An executable object file can be run as a *process*. This file usually contains
    a substantial portion of the features provided by a project. It must have an entry
    point where the machine-level instructions are executed. While the `main` function
    is the entry point of a C program, the entry point of an executable object file
    is platform-dependent, and it is not the `main` function. The `main` function
    will eventually be called after some preparations made by a group of platform-specific
    instructions, which have been added by the linker as the result of the linking
    step.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行对象文件可以作为*进程*运行。这个文件通常包含项目提供的许多功能。它必须有一个入口点，机器级指令在这里执行。虽然`main`函数是C程序的入口点，但可执行对象文件的入口点是平台相关的，并且不是`main`函数。`main`函数最终会在一组平台特定指令准备就绪后被调用，这些指令是由链接器在链接步骤中添加的。
- en: A static library is nothing more than an archive file that contains several
    relocatable object files. Therefore, a static library file is not produced by
    the linker directly. Instead, it is produced by the default archive program of
    the system, which on a Unix-like system is the `ar` program.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库不过是一个包含多个可重定位对象文件的归档文件。因此，静态库文件不是由链接器直接生成的。相反，它是由系统的默认归档程序生成的，在类Unix系统中是`ar`程序。
- en: Static libraries are usually linked to other executable files, and they then
    become part of those executable files. They are the simplest and easiest way to
    encapsulate a piece of logic so that you can use it at a later point. There is
    an enormous number of static libraries that exist within an operating system,
    with each of them containing a specific piece of logic that can be used to access
    a certain functionality within that operating system.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库通常链接到其他可执行文件，然后成为这些可执行文件的一部分。这是封装逻辑的最简单和最直接的方法，以便你可以在以后使用它。操作系统内部存在大量的静态库，每个库都包含可以用来访问该操作系统特定功能的特定逻辑。
- en: Shared object files, which have a more complicated structure rather than simply
    being an archive, are created directly by the linker. They are also used differently;
    namely, before they are used, they need to be loaded into a running process at runtime.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 共享对象文件结构更复杂，不仅仅是归档，它们是由链接器直接创建的。它们的使用方式也不同；也就是说，在使用之前，它们需要在运行时加载到一个正在运行的过程中。
- en: This is in opposition to static libraries that are used at *link time* to become
    part of the final executable file. In addition, a single shared object file can
    be loaded and used by multiple different processes at the same time. As part of
    the next chapter, we demonstrate how shared object files can be loaded and used
    by a C program at *runtime*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在*链接时间*使用的静态库形成对比，静态库被用来成为最终可执行文件的一部分。此外，单个共享对象文件可以被多个不同的进程同时加载和使用。作为下一章的一部分，我们将演示如何将共享对象文件在*运行时*加载并用于C程序。
- en: In the upcoming section, we explain what happens in the linking step and what
    elements are involved and used by the linker to produce the final products, especially
    executable files.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将解释链接步骤中发生的情况以及链接器所涉及和使用哪些元素来生成最终产品，特别是可执行文件。
- en: How does the linker work?
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接器是如何工作的？
- en: In this section, we are going to explain how the linker component works and
    what we exactly mean by linking. Suppose that you are building a C project that
    contains five source files, with the final product being an executable. As part
    of the build process, you have compiled all the source files, and now you have
    five relocatable object files. What you now need is a linker to complete the last
    step and produce the final executable file.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释链接组件的工作原理以及我们所说的链接究竟是什么意思。假设你正在构建一个包含五个源文件的C项目，最终产品是一个可执行文件。作为构建过程的一部分，你已经编译了所有源文件，现在你有五个可重定位对象文件。你现在需要的是一个链接器来完成最后一步并生成最终的可执行文件。
- en: Based on what we have said so far, to put it simply, a linker combines all of
    the relocatable object files, in addition to specified static libraries, in order
    to create the final executable object file. However, you would be wrong if you
    thought that this step was straightforward.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们到目前为止所说的，简单来说，链接器将所有可重定位对象文件以及指定的静态库结合起来，以创建最终的可执行对象文件。然而，如果你认为这一步很简单，那你就错了。
- en: There are a few concerns, which come from the contents of the object files,
    that need to be considered when we are combining the object files in order to
    produce a working executable object file. In order to see how the linker works,
    we need to know how it uses the relocatable object files, and for this purpose,
    we need to find out what is inside an object file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在将目标文件组合起来生成可工作的可执行目标文件时，有一些来自目标文件内容的问题需要考虑。为了了解链接器的工作原理，我们需要知道它如何使用可重定位目标文件，为此，我们需要找出目标文件内部的内容。
- en: The simple answer is that an object file contains the equivalent machine-level
    instructions for a translation unit. However, these instructions are not put into
    the file in random order. Instead, they are grouped under sections called *symbols*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的答案是，目标文件包含翻译单元的等效机器级指令。然而，这些指令并不是随机地放入文件中。相反，它们被分组在称为*符号*的部分下。
- en: 'In fact, there are many things in an object file, but symbols are one component
    that explains how the linker works and how it ties some object files together
    to produce a larger one. In order to explain symbols, let''s talk about them in
    the context of an example: *example 2.3*. Using this example, we want to demonstrate
    how some functions are compiled and placed in the corresponding relocatable object
    file. Take a look at the following code, which contains two functions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，目标文件中有许多内容，但符号是解释链接器如何工作以及如何将一些目标文件连接在一起以生成更大的目标文件的一个组成部分。为了解释符号，让我们在示例*example
    2.3*的上下文中讨论它们：使用这个示例，我们想展示一些函数是如何编译并放置在相应的可重定位目标文件中的。看一下以下包含两个函数定义的代码：
- en: '[PRE18]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Code Box 2-8 [ExtremeC_examples_chapter2_3.c]: A code with two function definitions'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 2-8 [ExtremeC_examples_chapter2_3.c]：包含两个函数定义的代码
- en: 'Firstly, we need to compile the preceding code in order to produce the corresponding
    object file. The following command produces the object file, `target.o`. We are
    compiling the code on our default platform:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编译前面的代码以生成相应的目标文件。以下命令生成了目标文件，`target.o`。我们正在默认平台上编译代码：
- en: '[PRE19]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Shell Box 2-12: Compiling the source file in example 2.3'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-12：编译示例 2.3 中的源文件
- en: 'Next, we use the `nm` utility to look into the `target.o` object file. The
    `nm` utility allows us to see the symbols that can be found inside an object file:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`nm`工具查看`target.o`目标文件。`nm`工具允许我们查看目标文件内可以找到的符号：
- en: '[PRE20]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Shell Box 2-13: Using the nm utility to see the defined symbols in a relocatable
    object file'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-13：使用`nm`工具查看可重定位目标文件中定义的符号
- en: The preceding shell box shows the symbols defined in the object file. As you
    can see, their names are exactly the same as the function defined in *Code Box
    2-8*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 上述shell box显示了目标文件中定义的符号。如您所见，它们的名称与*Code Box 2-8*中定义的函数名称完全相同。
- en: 'If you use the `readelf` utility, like we have done in the following shell
    box, you can see the *symbol table* existing in the object file. A symbol table
    contains all the symbols defined in an object file and it can give you more information
    about the symbols:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`readelf`工具，就像我们在以下shell box中所做的那样，您可以看到存在于目标文件中的*符号表*。符号表包含目标文件中定义的所有符号，并且可以为您提供有关符号的更多信息：
- en: '[PRE21]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Shell Box 2-14: Using the readelf utility to see the symbol table of a relocatable
    object file'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-14：使用`readelf`工具查看可重定位目标文件的符号表
- en: As you can see in the output of `readelf`, there are two function symbols in
    the symbol table. There are also other symbols in the table that refer to different
    sections within the object file. We will discuss some of these symbols in this
    chapter and the next chapter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在`readelf`的输出中看到的，符号表中包含两个函数符号。表中还有其他符号，它们指向目标文件中的不同部分。我们将在本章和下一章讨论其中的一些符号。
- en: 'If you want to see the disassembly of the machine-level instructions, under
    each function symbol, then you can use the `objdump` tool:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看机器级指令的汇编代码，可以在每个函数符号下使用`objdump`工具：
- en: '[PRE22]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Shell Box 2-15: Using the objdump utility to see the instructions of the symbols
    defined in a relocatable object file'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-15：使用`objdump`工具查看定义在可重定位目标文件中的符号的指令
- en: Based on what we see, each function symbol corresponds to a function that has
    been defined in the source code. When you need to link several relocatable object
    files, in order to produce an executable object file, this shows that each of
    the relocatable object files contains only a portion of the whole required function
    symbols needed to build a complete executable program.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们所看到的，每个函数符号对应于源代码中定义的函数。当你需要链接多个可重定位对象文件以生成可执行对象文件时，这表明每个可重定位对象文件只包含构建完整可执行程序所需的全部函数符号的一部分。
- en: Now, going back to the topic of this section, the linker gathers all the symbols
    from the various relocatable object files before putting them together in a bigger
    object file to form a complete executable binary. In order to demonstrate this
    in a real scenario, we need a different example that has some functions distributed
    in a number of source files. This way, we can show how the linker looks up the
    symbols in the given relocatable object files, in order to produce an executable
    file.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到本节的主题，链接器在将符号组合到一个更大的对象文件中以形成完整的可执行二进制文件之前，会从各种可重定位对象文件中收集所有符号。为了在一个实际场景中演示这一点，我们需要一个不同的示例，其中一些函数分布在多个源文件中。这样，我们可以展示链接器如何在给定的可重定位对象文件中查找符号，以生成可执行文件。
- en: '*Example 2.4* consists of four C files – three source files and one header
    file. In the header file, we have declared two functions, with each one defined
    in its own source file. The third source file contains the `main` function.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2.4* 由四个 C 文件组成——三个源文件和一个头文件。在头文件中，我们声明了两个函数，每个函数都在其各自的源文件中定义。第三个源文件包含
    `main` 函数。'
- en: The functions in *example 2.4* are amazingly simple, and after compilation,
    each function will contain a few machine-level instructions within their corresponding
    object files. In addition, *example 2.4* will not include any of the standard
    C header files. We have chosen this in order to have a small translation unit
    for each source file.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2.4* 中的函数非常简单，编译后，每个函数在其相应的对象文件中都将包含一些机器级指令。此外，*示例 2.4* 不会包含任何标准 C 头文件。我们选择这样做是为了使每个源文件都有一个小的翻译单元。'
- en: 'The following code box shows the header file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了头文件：
- en: '[PRE23]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Code Box 2-9 [ExtremeC_examples_chapter2_4_decls.h]: The declaration of the
    functions in example 2.4'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 2-9 [ExtremeC_examples_chapter2_4_decls.h]：示例 2.4 中函数的声明
- en: Looking at that code, you can see that we used the header guard statements to
    prevent *double inclusion*. More than that, two functions with similar *signatures*
    are declared. Each of them receives two integers as input and will return another
    integer as a result.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 看看那段代码，你可以看到我们使用了头文件保护语句来防止 *双重包含*。不仅如此，还声明了两个具有相似 *签名* 的函数。每个函数接收两个整数作为输入，并将返回另一个整数作为结果。
- en: 'As we said before, each of these functions are implemented in separate source
    files. The first source file looks as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，这些函数都是分别在不同的源文件中实现的。第一个源文件看起来如下：
- en: '[PRE24]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code Box 2-10 [ExtremeC_examples_chapter2_4_add.c]: The definition of the add
    function'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 2-10 [ExtremeC_examples_chapter2_4_add.c]：add 函数的定义
- en: We can clearly see that the source file has not included any other header files.
    However, it does define a function that follows the exact same signature that
    we have declared in the header file.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，源文件没有包含任何其他头文件。然而，它定义了一个函数，其签名与我们头文件中声明的完全相同。
- en: 'As we can see next, the second source file is similar to the first one. This
    one contains the definition of the `multiply` function:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，第二个源文件与第一个类似。这个文件包含了 `multiply` 函数的定义：
- en: '[PRE25]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Code Box 2-11 [ExtremeC_examples_chapter2_4_multiply.c]: The definition of
    the multiply function'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 2-11 [ExtremeC_examples_chapter2_4_multiply.c]：multiply 函数的定义
- en: 'We can now move onto the third source file, which contains the `main` function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以转向第三个源文件，它包含了 `main` 函数：
- en: '[PRE26]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Code Box 2-12 [ExtremeC_examples_chapter2_4_main.c]: The main function of example
    2.4'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 2-12 [ExtremeC_examples_chapter2_4_main.c]：示例 2.4 的主函数
- en: The third source file has to include the header file in order to obtain the
    declarations of both functions. Otherwise, the source file will not be able to
    use the `add` and `multiply` functions, simply because they are not declared,
    and this may result in a compilation failure.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个源文件必须包含头文件，以便获取两个函数的声明。否则，源文件将无法使用 `add` 和 `multiply` 函数，仅仅因为它们没有被声明，这可能会导致编译失败。
- en: 'In addition, the `main` function does not know anything about the definitions
    of either `add` or `multiply`. Therefore, we need to ask an important question:
    how does the `main` function find these definitions when it does not even know
    about the other source files? Note that the file shown in *Code Box 2-12* has
    only included one header file, and therefore it has no relationship with the other
    two source files.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，main 函数对 add 或 multiply 的定义一无所知。因此，我们需要提出一个重要问题：当 main 函数甚至不知道其他源文件时，它是如何找到这些定义的？请注意，*代码框
    2-12* 中显示的文件只包含了一个头文件，因此它与另外两个源文件没有关系。
- en: The above question can be resolved by bringing the linker into consideration.
    The linker will gather the required definitions from various object files and
    put them together, and this way, the code written in the `main` function can finally
    use the code written in another function.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 上述问题可以通过考虑链接器来解决。链接器将从各种目标文件中收集所需的定义并将它们组合起来，这样，main 函数中编写的代码最终可以使用另一个函数中编写的代码。
- en: '**Note**:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: To compile a source file that uses a function, the declaration is enough. However,
    to actually run your program, the definition should be provided to the linker
    in order to be put into the final executable file.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译使用函数的源文件，声明就足够了。然而，为了实际运行你的程序，定义应该提供给链接器，以便将其放入最终的可执行文件中。
- en: 'Now, it''s time to compile *example 2.4* and demonstrate what we''ve said so
    far. Using the following commands, we create corresponding relocatable object
    files. You need to remember that we only compile source files:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候编译 *示例 2.4* 并演示我们迄今为止所说的内容了。使用以下命令，我们创建相应的可重定位目标文件。你需要记住，我们只编译源文件：
- en: '[PRE27]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Shell Box 2-16: Compiling all sources in example 2.4 to their corresponding
    relocatable object files'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-16：将 example 2.4 中的所有源文件编译成它们对应的可重定位目标文件
- en: 'For the next step, we are going to look at the symbol table contained in each
    relocatable object file:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步，我们将查看每个可重定位目标文件中包含的符号表：
- en: '[PRE28]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Shell Box 2-17: Listing the symbols defined in add.o'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-17：列出 add.o 中定义的符号
- en: 'As you see, the `add` symbol has been defined. The next object file:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，add 符号已被定义。下一个目标文件：
- en: '[PRE29]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Shell Box 2-18: Listing the symbols defined in multiply.o'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-18：列出 multiply.o 中定义的符号
- en: 'The same happens to the `multiply` symbol within `multiply.o`. And the final
    object file:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: multiply.o 中的 multiply 符号也发生了同样的事情。最终的目标文件：
- en: '[PRE30]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Shell Box 2-19: Listing the symbols defined in main.o'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-19：列出 main.o 中定义的符号
- en: Despite the fact that the third source file, *Code Box 2-12*, has only the `main`
    function, we see two symbols for `add` and `multiply` in its corresponding object
    file. However, they are different from the `main` symbol, which has an address
    inside the object file. They are marked as `U`, or *unresolved*. This means that
    while the compiler has seen these symbols in the translation unit, it has not
    been able to find their actual definitions. And this is exactly what we expected
    and explained before.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第三个源文件，*代码框 2-12*，只有 main 函数，但我们看到其对应的目标文件中有两个 add 和 multiply 的符号。然而，它们与具有目标文件内地址的
    main 符号不同，它们被标记为 `U`，或 *未解决*。这意味着虽然编译器在翻译单元中看到了这些符号，但它还没有找到它们的实际定义。这正是我们之前预期和解释的。
- en: The source file containing the `main` function, *Code Box 2-12*, should not
    know anything about the definitions of other functions if they are not defined
    in the same translation unit, but the fact that the `main` definition is dependent
    on the declarations of `add` and `multiply` should be somehow pointed out in the
    corresponding relocatable object file.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 main 函数的源文件，*代码框 2-12*，如果它们不在同一个翻译单元中定义，则不应了解其他函数的定义，但 main 定义依赖于 add 和 multiply
    的声明这一事实应该以某种方式在相应的可重定位目标文件中指出。
- en: To summarize where we are now, we have three intermediate object files, with
    one of them having two unresolved symbols. This has now made the job of the linker
    clear; we need to give the linker the necessary symbols that can be found in other
    object files. After having found all of the required symbols, the linker can continue
    to combine them in order to create a final executable binary that works.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们现在所处的位置，我们有三个中间目标文件，其中之一有两个未解决的符号。这现在使得链接器的任务变得明确；我们需要给链接器提供可以在其他目标文件中找到的必要符号。在找到所有必需的符号后，链接器可以继续将它们组合起来，以创建一个最终可执行的二进制文件。
- en: If the linker is not able to find the definition of an unresolved symbol, it
    will fail, and inform us by printing a *linkage error*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链接器找不到未解决符号的定义，它将失败，并通过打印一个 *链接错误* 来通知我们。
- en: 'For the next step, we want to link the preceding object files together. The
    following command will do that:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们想要链接前面的目标文件。以下命令将完成这个任务：
- en: '[PRE31]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Shell Box 2-20: Linking all object files together'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-20：将所有目标文件链接在一起
- en: We should note here that running `gcc` with a list of object files, without
    passing any option, will result in the linking step trying to create an executable
    object file out of the input object files. Actually, it calls the linker in the
    background with the given object files, together with some other static libraries
    and object files, that are required on the platform.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在这里注意，使用不带任何选项的对象文件列表运行 `gcc`，将导致链接步骤尝试从输入对象文件中创建一个可执行对象文件。实际上，它会在后台调用链接器，并使用给定的对象文件，以及一些其他平台所需的静态库和对象文件。
- en: 'To examine what happens if the linker fails to find proper definitions, we
    are going to provide the linker with only two intermediate object files, `main.o`
    and `add.o`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查如果链接器找不到适当的定义会发生什么，我们将只向链接器提供两个中间目标文件，`main.o` 和 `add.o`：
- en: '[PRE32]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Shell Box 2-21: Linking only two of the object files: add.o and main.o'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-21：仅链接两个目标文件：add.o 和 main.o
- en: As you can see, the linker has failed because it could not find the `multiply`
    symbol in the provided object files.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，链接器失败了，因为它在提供的对象文件中找不到 `multiply` 符号。
- en: 'Moving on, let''s provide the other two object files, `main.o` and `multiply.o`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们提供另外两个目标文件，`main.o` 和 `multiply.o`：
- en: '[PRE33]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Shell Box 2-22: Linking only two of the object files, multiply.o and main.o'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-22：仅链接两个目标文件，multiply.o 和 main.o
- en: As expected, the same thing occurred. This happened since the `add` symbol could
    not be found in the provided object files.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，发生了同样的事情。这是因为提供的对象文件中没有找到 `add` 符号。
- en: 'Finally, let''s provide the only remaining combination of two object files,
    `add.o` and `multiply.o`. Before we run it, we should expect it to work since
    neither object file has unresolved symbols in their symbol tables. Let''s see
    what happens:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们提供仅剩的两个对象文件的组合，`add.o` 和 `multiply.o`。在我们运行它之前，我们应该预期它会工作，因为这两个对象文件在它们的符号表中都没有未解决的符号。让我们看看会发生什么：
- en: '[PRE34]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Shell Box 2-23: Linking only two of the object files, add.o and multiply.o'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-23：仅链接两个目标文件，add.o 和 multiply.o
- en: As you see, the linker has failed again! Looking at the output, we can see the
    reason was that none of the object files contain the `main` symbol that is necessary
    to create an executable. The linker needs an entry point for the program, which
    is the `main` function according to the C standard.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，链接器再次失败了！查看输出，我们可以看到原因是没有任何对象文件包含创建可执行文件所必需的 `main` 符号。链接器需要一个程序的入口点，根据
    C 标准，这是 `main` 函数。
- en: At this point – and I cannot emphasize this enough – pay attention to the place
    where a reference to the `main` symbol has been made. It has been made in the
    `_start` function in a file located at `/usr/lib/gcc/x86_64-Linux-gnu/7/../../../x86_64-Linux-gnu/Scrt1.o`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上——我无法强调这一点——请注意对 `main` 符号的引用位置。它是在位于 `/usr/lib/gcc/x86_64-Linux-gnu/7/../../../x86_64-Linux-gnu/Scrt1.o`
    的文件中的 `_start` 函数中进行的。
- en: The `Scrt1.o` file seems to be a relocatable object file that has not been created
    by us. `Scrt1.o` is actually a file that is part of a group of default C object
    files. These default object files have been compiled for Linux as a part of the
    `gcc` bundle and are linked to any program in order to make it runnable.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scrt1.o` 文件似乎是一个可重定位的目标文件，它不是由我们创建的。实际上，`Scrt1.o` 是一组默认 C 目标文件的一部分。这些默认对象文件是作为
    `gcc` 套件的一部分为 Linux 编译的，并将链接到任何程序，以便使其可执行。'
- en: As you have just seen, there are a lot of different things that are happening
    around your source code that can cause conflicts. Not only that, but there are
    a number of other object files that need to be linked to your program in order
    to make it executable.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚才看到的，在您的源代码周围发生了很多不同的事情，这些都可能导致冲突。不仅如此，还有许多其他对象文件需要链接到您的程序中，以便使其可执行。
- en: Linker can be fooled!
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接器可以被欺骗！
- en: To make our current discussion even more interesting, there are rare scenarios
    when the linking step will perform as we planned, but the final binary step does
    not work as expected. In this section, we are going to look at an example of this
    occurring.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的讨论更加有趣，在链接步骤按计划执行，但最终的二进制步骤不符合预期的情况下，也有一些罕见的情况。在本节中，我们将查看一个发生这种情况的示例。
- en: '*Example 2.5* is based on an incorrect definition having been gathered by the
    linker and put into the final executable object file.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例2.5*基于由链接器收集的错误定义，并将其放入最终的可执行目标文件中。'
- en: 'This example has two source files, one of which contains the definition of
    a function with the same name, but a different signature from the declaration
    used by the `main` function. The following code boxes are the contents of these
    two source files. Here''s the first source file:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例有两个源文件，其中一个包含具有相同名称但与`main`函数使用的声明不同的签名的函数定义。以下代码框是这两个源文件的内容。以下是第一个源文件：
- en: '[PRE35]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Code Box 2-13 [ExtremeC_examples_chapter2_5_add.c]: Definition of the add function
    in example 2.5'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-13 [ExtremeC_examples_chapter2_5_add.c]：示例2.5中`add`函数的定义
- en: 'And, following is the second source file:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是第二个源文件：
- en: '[PRE36]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Code Box 2-14 [ExtremeC_examples_chapter2_5_main.c]: The main function in example
    2.5'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-14 [ExtremeC_examples_chapter2_5_main.c]：示例2.5中的主函数
- en: As you can see, the `main` function is using another version of the `add` function
    with a different signature, accepting two integers, but the `add` function defined
    in the first source file, *Code Box 2-13*, is accepting four integers.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`main`函数正在使用具有不同签名的另一个版本的`add`函数，接受两个整数，但第一个源文件*代码框2-13*中定义的`add`函数接受四个整数。
- en: These functions are usually said to be the *overloads* of each other. For sure,
    there should be something wrong if we compile and link these source files. It's interesting
    to see if we can build the example successfully.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数通常被称为彼此的*重载*。当然，如果我们编译和链接这些源文件，肯定会有一些错误。看看我们是否可以成功构建示例是有趣的。
- en: 'The next step is to compile and link the relocatable object files, which we
    can do by running the following code:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编译和链接可重定位的目标文件，我们可以通过运行以下代码来完成：
- en: '[PRE37]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Shell Box 2-24: Building example 2.5'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 壳命令框2-24：构建示例2.5
- en: 'As you can see in the shell output, the linking step went well, and the final
    executable has been produced! This clearly shows that the symbols can fool the
    linker. Now let''s look at the output after running the executable:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在shell输出中看到的，链接步骤进行得很顺利，最终的可执行文件已经生成！这清楚地表明符号可以欺骗链接器。现在让我们看看运行可执行文件后的输出：
- en: '[PRE38]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Shell Box 2-25: Running example 2.5 twice and the strange results!'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 壳命令框2-25：运行示例2.5两次和奇怪的结果！
- en: As you can see, the output is wrong; it even changes in different runs! This
    example shows that bad things can happen when the linker picks up the wrong version
    of a symbol. Regarding the function symbols, they are just names and they don't
    carry any information regarding the signature of the corresponding function. Function
    arguments are nothing more than a C concept; in fact, they do not truly exist
    in either assembly code or machine-level instructions.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出是错误的；甚至在不同的运行中都会改变！这个例子表明，当链接器选择错误的符号版本时，会发生不好的事情。关于函数符号，它们只是名称，并不携带任何关于相应函数签名的信息。函数参数不过是C语言的一个概念；实际上，它们在汇编代码或机器级指令中并不真正存在。
- en: In order to investigate more, we are going to look at the *disassembly* of the
    `add` functions in a different example. In *example 2.6*, we have two `add` functions
    with the same signatures that we had in *example 2.5*.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步调查，我们将查看不同示例中`add`函数的*反汇编*。在*示例2.6*中，我们有两个与*示例2.5*中相同的签名`add`函数。
- en: 'To study this, we are going to work from the idea that we have the following
    source files in *example 2.6*:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究这个问题，我们将从以下想法开始，即我们在*示例2.6*中有以下源文件：
- en: '[PRE39]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Code Box 2-15 [ExtremeC_examples_chapter2_6_add_1.c]: The first definition
    of add in example 2.6'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-15 [ExtremeC_examples_chapter2_6_add_1.c]：示例2.6中`add`的第一个定义
- en: 'The following code is the other source file:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是另一个源文件：
- en: '[PRE40]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Code Box 2-16 [ExtremeC_examples_chapter2_6_add_2.c]: The second definition
    of add in example 2.6'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-16 [ExtremeC_examples_chapter2_6_add_2.c]：示例2.6中`add`的第二个定义
- en: 'The first step, just like before, is to compile both source files:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，就像之前一样，是编译两个源文件：
- en: '[PRE41]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Shell Box 2-26: Compiling the source files in example 2.6 to their corresponding
    object files'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 壳命令框2-26：将示例2.6中的源文件编译成相应的目标文件
- en: 'We then need to have a look at the disassembly of the `add` symbol in different
    object files. Therefore, we start with the `add_1.o` object file:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要查看不同目标文件中`add`符号的反汇编。因此，我们首先从`add_1.o`目标文件开始：
- en: '[PRE42]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Shell Box 2-27: Using objdump to look at the disassembly of the add symbol
    in add_1.o'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Shell框2-27：使用objdump查看`add_1.o`中的加法符号的反汇编
- en: 'The following shell box shows us the disassembly of the `add` symbol found
    in the other object file, `add_2.o`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的shell框展示了在其他目标文件`add_2.o`中找到的`add`符号的反汇编：
- en: '[PRE43]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Shell Box 2-28: Using objdump to look at the disassembly of the add symbol
    in add_2.o'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Shell框2-28：使用objdump查看`add_2.o`中的加法符号的反汇编
- en: When a function call takes place, a new *stack frame* is created on top of the
    stack. This stack frame contains both the arguments passed to the function and
    the return address. You will read more about the function call mechanism in *Chapter
    4*, *Process Memory Structure*, and *Chapter 5*, *Stack and Heap*.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生函数调用时，在栈顶创建一个新的*栈帧*。这个栈帧包含传递给函数的参数和返回地址。你将在*第四章*，*进程内存结构*和*第五章*，*栈和堆*中了解更多关于函数调用机制的内容。
- en: 'In shell boxes *2-27* and *2-28*, you can clearly see how the arguments are
    collected from the stack frame. In the disassembly of `add_1.o`, *Shell Box 2-27*,
    you can see the following lines:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell框*2-27*和*2-28*中，你可以清楚地看到参数是如何从栈帧中收集的。在`add_1.o`的反汇编中，Shell框*2-27*，你可以看到以下行：
- en: '[PRE44]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Code Box 2-17: The assembly instructions to copy the arguments from the stack
    frame to the registers for the first add function'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-17：将参数从栈帧复制到寄存器以供第一个加法函数使用的汇编指令
- en: These instructions copy four values from the memory addresses, which have been
    pointed by the `%rbp` register, and put them into the local registers.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令从由`%rbp`寄存器指向的内存地址复制四个值，并将它们放入局部寄存器中。
- en: '**Note**:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: '*Registers* are locations within a CPU that can be accessed quickly. Therefore,
    it would be highly efficient for the CPU to bring the values from main memory
    into its registers first, and then perform calculations on them. The register
    `%rbp` is the one that points to the current stack frame, containing the arguments
    passed to a function.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*寄存器*是CPU内部可以快速访问的位置。因此，对于CPU来说，首先将值从主内存传输到其寄存器中，然后对它们进行计算将是非常高效的。`%rbp`寄存器是指向当前栈帧的，其中包含传递给函数的参数。'
- en: 'If you look at the disassembly of the second object file, while it is very
    similar, it differs by not having the copy operation four times:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看第二个目标文件的反汇编，虽然非常相似，但它没有进行四次复制操作：
- en: '[PRE45]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Code Box 2-18: The assembly instructions to copy the arguments from the stack
    frame to the registers for the second add function'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框2-18：将参数从栈帧复制到寄存器以供第二个加法函数使用的汇编指令
- en: These instructions copy two values simply because the function only expects
    two arguments. This is why we saw those strange values in the output of *example
    2.5*. The `main` function only puts two values into the stack frame while calling
    the `add` function, but the `add` definition was actually expecting four arguments.
    So, it is likely that the wrong definition continues to go beyond the stack frame
    to read the missing arguments, which results in the wrong values for the sum operation.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令简单地复制两个值，因为函数只期望两个参数。这就是为什么我们在*示例2.5*的输出中看到了那些奇怪值的原因。在调用`add`函数时，`main`函数只将两个值放入栈帧，但`add`的定义实际上期望四个参数。因此，很可能是错误的定义继续超出栈帧以读取缺失的参数，这导致求和操作的结果出现错误值。
- en: We could prevent this by changing the function symbol names based on the input
    types. This is usually referred to as *name mangling* and is mostly used in C++
    because of its *function overloading* feature. We discuss this briefly in the
    last section of the chapter.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过根据输入类型更改函数符号名称来防止这种情况。这通常被称为*名称修饰*，并且由于它的*函数重载*特性，在C++中广泛使用。我们在本章的最后部分简要讨论了这一点。
- en: C++ name mangling
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++名称修饰
- en: To highlight how name mangling works in C++, we are going to compile *example
    2.6* using a C++ compiler. Therefore, we will use the GNU C++ compiler `g++` for
    this purpose.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出C++中名称修饰的工作原理，我们将使用C++编译器编译*示例2.6*。因此，我们将使用GNU C++编译器`g++`来完成这项任务。
- en: Once we have done that, we can use `readelf` to dump the symbol tables for each
    generated object file. By doing this, we can see how C++ has changed the name
    of the function symbols based on the types of input parameters.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个，我们就可以使用`readelf`来转储每个生成的目标文件的符号表。通过这样做，我们可以看到C++是如何根据输入参数的类型更改函数符号的名称的。
- en: 'As we have noted before, the compilation pipelines of C and C++ are very similar.
    Therefore, we can expect to have relocatable object files as a result of C++ compilation.
    Let''s look at both of the object files produced as part of compiling *example
    2.6*:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，C和C++的编译管道非常相似。因此，我们可以预期C++编译的结果将是有可重定位的目标文件。让我们看看编译*示例2.6*时产生的两个目标文件：
- en: '[PRE46]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Shell Box 2-29: Using readelf the see the symbol tables of the object files
    produced by a C++ compiler'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 2-29：使用readelf查看由C++编译器产生的目标文件的符号表
- en: As you can see in the output, we have two different symbol names for different
    overloads of the `add` function. The overload that accepts four integers has the
    symbol name `_Z3addiiii`, and the other overload, which accepts two integers,
    has the symbol name `_Z3addii`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在输出中看到的，我们有`add`函数不同重载的两个不同的符号名称。接受四个整数的重载具有符号名称`_Z3addiiii`，而接受两个整数的另一个重载具有符号名称`_Z3addii`。
- en: Every `i` in the symbol name refers to one of the integer input parameters.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 符号名称中的每个`i`都指代一个整数输入参数。
- en: From that, you can see the symbol names are different, and if you try to use
    the wrong one, you will get a linking error as a result of the linker not being
    able to find the definition of a wrong symbol. Name mangling is the technique
    that enables C++ to support function overloading and it helps to prevent the problems
    we encountered in the previous section.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 从中，你可以看到符号名称是不同的，如果你尝试使用错误的一个，由于链接器无法找到错误符号的定义，你将得到一个链接错误。名称混淆是使C++能够支持函数重载的技术，它有助于防止我们在上一节中遇到的问题。
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered the fundamental steps and components required to
    build a C project. Without knowing how to build a project, it is pointless to
    just write code. In this chapter:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了构建C项目所需的基本步骤和组件。如果不了解如何构建项目，仅仅编写代码是没有意义的。在本章中：
- en: We went through the C compilation pipeline and its various steps. We discussed
    each step and described the inputs and the outputs.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们回顾了C编译管道及其各个步骤。我们讨论了每个步骤，并描述了输入和输出。
- en: We defined the term *platform* and how different assemblers can lead to different
    machine-level instructions for the same C program.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了术语*平台*以及不同的汇编器如何导致相同的C程序有不同的机器级指令。
- en: We continued to discuss each step and the component driving that step in a greater
    detail.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们继续详细讨论了每个步骤以及驱动该步骤的组件。
- en: As part of the compiler component, we explained what the compiler frontends
    and backends are, and how GCC and LLVM use this separation to support many languages.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为编译器组件的一部分，我们解释了编译器前端和后端是什么，以及GCC和LLVM如何使用这种分离来支持多种语言。
- en: As part of our discussion regarding the assembler component, we saw that object
    files are platform-dependent, and they should have an exact file format.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为我们关于汇编器组件的讨论的一部分，我们看到了目标文件是平台相关的，并且它们应该有一个确切的文件格式。
- en: As part of the linker component, we discussed what a linker does and how it
    uses symbols to find the missing definitions in order to put them together and
    form the final product. We also explained various possible products of a C project.
    We explained why relocatable (or intermediate) object files should not be considered
    as products.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为链接器组件的一部分，我们讨论了链接器的作用以及它是如何使用符号来查找缺失的定义，以便将它们组合在一起形成最终产品。我们还解释了C项目的各种可能的产品。我们解释了为什么可重定位（或中间）目标文件不应被视为产品。
- en: We demonstrated how the linker can be fooled when a symbol is provided with
    a wrong definition. We showed this in *example 2.5*.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了当提供一个错误的定义时，链接器是如何被欺骗的。我们在*示例2.5*中展示了这一点。
- en: We explained the C++ name mangling feature and how problems like what we saw
    in *example 2.5* can be prevented because of that.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了C++名称混淆功能以及如何通过该功能防止像我们在*示例2.5*中看到的问题。
- en: We will continue our discussion regarding object files and their internal structure
    in the next chapter, *Object Files*.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章“目标文件”中继续讨论关于目标文件及其内部结构的内容。
