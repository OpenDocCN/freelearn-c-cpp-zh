["```cpp\nusing GUI_Interfaces = std::unordered_map<std::string,\n  GUI_Interface*>;\nusing GUI_Container = std::unordered_map<StateType,\n  GUI_Interfaces>;\nusing GUI_Events = std::unordered_map<StateType,\n  std::vector<GUI_Event>>;\nusing GUI_Factory = std::unordered_map<GUI_ElementType,\n  std::function<GUI_Element*(GUI_Interface*)>>;\nusing GUI_ElemTypes = std::unordered_map<std::string,\n  GUI_ElementType>;\n```", "```cpp\nstruct SharedContext; // Forward declaration.\nclass GUI_Manager{\n  friend class GUI_Interface;\npublic:\n  GUI_Manager(EventManager* l_evMgr, SharedContext* l_context);\n  ~GUI_Manager();\n  ...\n  template<class T>\n  void RegisterElement(const GUI_ElementType& l_id){\n    m_factory[l_id] = [](GUI_Interface* l_owner) -> GUI_Element*\n    { return new T(\"\",l_owner); };\n  }\nprivate:\n  GUI_Element* CreateElement(const GUI_ElementType& l_id,\n    GUI_Interface* l_owner);\n  GUI_ElementType StringToType(const std::string& l_string);\n  bool LoadStyle(const std::string& l_file,\n    GUI_Element* l_element);\n\n  GUI_Container m_interfaces;\n  GUI_Events m_events;\n  SharedContext* m_context;\n  StateType m_currentState;\n  GUI_Factory m_factory;\n  GUI_ElemTypes m_elemTypes;\n};\n```", "```cpp\nGUI_Manager::GUI_Manager(EventManager* l_evMgr,\n  SharedContext* l_shared): m_eventMgr(l_evMgr),\n  m_context(l_shared), m_currentState(StateType(0))\n{\n  RegisterElement<GUI_Label>(GUI_ElementType::Label);\n  RegisterElement<GUI_Scrollbar>(GUI_ElementType::Scrollbar);\n  RegisterElement<GUI_Textfield>(GUI_ElementType::Textfield);\n  m_elemTypes.emplace(\"Label\", GUI_ElementType::Label);\n  m_elemTypes.emplace(\"Button\", GUI_ElementType::Button);\n  m_elemTypes.emplace(\"Scrollbar\", GUI_ElementType::Scrollbar);\n  m_elemTypes.emplace(\"TextField\", GUI_ElementType::Textfield);\n  m_elemTypes.emplace(\"Interface\", GUI_ElementType::Window);\n\n  m_eventMgr->AddCallback(StateType(0),\n    \"Mouse_Left\", &GUI_Manager::HandleClick, this);\n  m_eventMgr->AddCallback(StateType(0),\n    \"Mouse_Left_Release\", &GUI_Manager::HandleRelease, this);\n  m_eventMgr->AddCallback(StateType(0),\n    \"Text_Entered\", &GUI_Manager::HandleTextEntered, this);\n}\n```", "```cpp\nGUI_Manager::~GUI_Manager(){\n  m_eventMgr->RemoveCallback(StateType(0), \"Mouse_Left\");\n  m_eventMgr->RemoveCallback(StateType(0), \"Mouse_Left_Release\");\n  m_eventMgr->RemoveCallback(StateType(0), \"Text_Entered\");\n\n  for (auto &itr : m_interfaces){\n    for (auto &itr2 : itr.second){\n      delete itr2.second;\n    }\n  }\n}\n```", "```cpp\nbool GUI_Manager::AddInterface(const StateType& l_state,\n  const std::string& l_name)\n{\n  auto s = m_interfaces.emplace(l_state, GUI_Interfaces()).first;\n  GUI_Interface* temp = new GUI_Interface(l_name, this);\n  if (s->second.emplace(l_name, temp).second){ return true; }\n  delete temp;\n  return false;\n}\n```", "```cpp\nGUI_Interface* GUI_Manager::GetInterface(const StateType& l_state,\n  const std::string& l_name)\n{\n  auto s = m_interfaces.find(l_state);\n  if (s == m_interfaces.end()){ return nullptr; }\n  auto i = s->second.find(l_name);\n  return (i != s->second.end() ? i->second : nullptr);\n}\n```", "```cpp\nbool GUI_Manager::RemoveInterface(const StateType& l_state,\n  const std::string& l_name)\n{\n  auto s = m_interfaces.find(l_state);\n  if (s == m_interfaces.end()){ return false; }\n  auto i = s->second.find(l_name);\n  if (i == s->second.end()){ return false; }\n  delete i->second;\n  return s->second.erase(l_name);\n}\n```", "```cpp\nvoid GUI_Manager::SetCurrentState(const StateType& l_state){\n  if (m_currentState == l_state){ return; }\n  HandleRelease(nullptr);\n  m_currentState = l_state;\n}\n```", "```cpp\nvoid GUI_Manager::HandleClick(EventDetails* l_details){\n  auto state = m_interfaces.find(m_currentState);\n  if (state == m_interfaces.end()){ return; }\n  sf::Vector2i mousePos = m_eventMgr->\n    GetMousePos(m_context->m_wind->GetRenderWindow());\n  for (auto itr = state->second.rbegin();\n    itr != state->second.rend(); ++itr)\n  {\n    if (!itr->second->IsInside(sf::Vector2f(mousePos))){continue;}\n    if (!itr->second->IsActive()){ return; }\n    itr->second->OnClick(sf::Vector2f(mousePos));\n    itr->second->Focus();\n    if (itr->second->IsBeingMoved()){itr->second->BeginMoving();}\n    return;\n  }\n}\n```", "```cpp\nvoid GUI_Manager::HandleRelease(EventDetails* l_details){\n  auto state = m_interfaces.find(m_currentState);\n  if (state == m_interfaces.end()){ return; }\n  for (auto &itr : state->second){\n    GUI_Interface* i = itr.second;\n    if (!i->IsActive()){ continue; }\n    if (i->GetState() == GUI_ElementState::Clicked)\n    {\n      i->OnRelease();\n    }\n    if (i->IsBeingMoved()){ i->StopMoving(); }\n  }\n}\n```", "```cpp\nvoid GUI_Manager::HandleTextEntered(EventDetails* l_details){\n  auto state = m_interfaces.find(m_currentState);\n  if (state == m_interfaces.end()){ return; }\n  for (auto &itr : state->second){\n    if (!itr.second->IsActive()){ continue; }\n    if (!itr.second->IsFocused()){ continue; }\n    itr.second->OnTextEntered(l_details->m_textEntered);\n    return;\n  }\n}\n```", "```cpp\nvoid GUI_Manager::AddEvent(GUI_Event l_event){\n    m_events[m_currentState].push_back(l_event);\n}\n```", "```cpp\nbool GUI_Manager::PollEvent(GUI_Event& l_event){\n  if (m_events[m_currentState].empty()){ return false; }\n  l_event = m_events[m_currentState].back();\n  m_events[m_currentState].pop_back();\n  return true;\n}\n```", "```cpp\nvoid GUI_Manager::Update(float l_dT){\n  sf::Vector2i mousePos = m_eventMgr->\n    GetMousePos(m_context->m_wind->GetRenderWindow());\n\n  auto state = m_interfaces.find(m_currentState);\n  if (state == m_interfaces.end()){ return; }\n  for (auto itr = state->second.rbegin();\n    itr != state->second.rend(); ++itr)\n  {\n    GUI_Interface* i = itr->second;\n    if (!i->IsActive()){ continue; }\n    i->Update(l_dT);\n    if (i->IsBeingMoved()){ continue; }\n    if (i->IsInside(sf::Vector2f(mousePos)))\n    {\n      if (i->GetState() == GUI_ElementState::Neutral){\n        i->OnHover(sf::Vector2f(mousePos));\n      }\n      return;\n    } else if (i->GetState() == GUI_ElementState::Focused){\n      i->OnLeave();\n    }\n  }\n}\n```", "```cpp\nvoid GUI_Manager::Render(sf::RenderWindow* l_wind){\n  auto state = m_interfaces.find(m_currentState);\n  if (state == m_interfaces.end()){ return; }\n  for (auto &itr : state->second){\n    GUI_Interface* i = itr.second;\n    if (!i->IsActive()){ continue; }\n    if (i->NeedsRedraw()){ i->Redraw(); }\n    if (i->NeedsContentRedraw()){ i->RedrawContent(); }\n    if (i->NeedsControlRedraw()){ i->RedrawControls(); }\n    i->Draw(l_wind);\n  }\n}\n```", "```cpp\nGUI_Element* GUI_Manager::CreateElement(\n  const GUI_ElementType& l_id, GUI_Interface* l_owner)\n{\n  if (l_id == GUI_ElementType::Window){ \n    return new GUI_Interface(\"\", this);\n  }\n  auto f = m_factory.find(l_id);\n  return (f != m_factory.end() ? f->second(l_owner) : nullptr);\n}\n```", "```cpp\nInterface name Style.style 0 0 Immovable NoTitle \"Title\"\nElement Label name 100 0 Style.style \"Label text\"\n...\n```", "```cpp\nbool GUI_Manager::LoadInterface(const StateType& l_state,const std::string& l_interface, const std::string& l_name)\n{\n    ...\n}\n```", "```cpp\nif (key == \"Interface\"){\n  std::string style;\n  keystream >> InterfaceName >> style;\n  if (!AddInterface(l_state, l_name)){\n    std::cout << \"Failed adding interface: \" \n      << l_name << std::endl;\n    return false;\n  }\n  GUI_Interface* i = GetInterface(l_state, l_name);\n  keystream >> *i;\n  if (!LoadStyle(style, i)){\n    std::cout << \"Failed loading style file: \"\n      << style << \" for interface \" << l_name << std::endl;\n  }\n  i->SetContentSize(i->GetSize());\n} else if ...\n```", "```cpp\n} else if (key == \"Element\"){\n  if (InterfaceName == \"\"){\n    std::cout << \"Error: 'Element' outside or before \n      declaration of 'Interface'!\" << std::endl;\n    continue;\n  }\n  std::string type;\n  std::string name;\n  sf::Vector2f position;\n  std::string style;\n  keystream >> type >> name >> position.x >> position.y >> style;\n  GUI_ElementType eType = StringToType(type);\n  if (eType == GUI_ElementType::None){\n    std::cout << \"Unknown element('\" << name\n      << \"') type: '\" << type << \"'\" << std::endl;\n    continue;\n  }\n\n  GUI_Interface* i = GetInterface(l_state, l_name);\n  if (!i){ continue; }\n  if (!i->AddElement(eType, name)){ continue; }\n  GUI_Element* e = i->GetElement(name);\n  keystream >> *e;\n  e->SetPosition(position);\n  if (!LoadStyle(style, e)){\n    std::cout << \"Failed loading style file: \" << style\n      << \" for element \" << name << std::endl;\n    continue;\n  }\n}\n```", "```cpp\nState Neutral\nSize 64 32\nTextColor 0 0 0 255\nTextSize 12\nFont Main\nTextPadding 0 0\n/State\n\nState Hover\nTextColor 255 255 255 255\n/State\n\nState Clicked\nTextColor 255 0 0 255\n/State\n```", "```cpp\nbool GUI_Manager::LoadStyle(const std::string& l_file,\n  GUI_Element* l_element)\n{\n  ...\n  std::string currentState;\n  GUI_Style ParentStyle;\n  GUI_Style TemporaryStyle;\n  ...\n}\n```", "```cpp\nif (type == \"State\"){\n  if (currentState != \"\"){\n    std::cout << \"Error: 'State' keyword found \n      inside another state!\" << std::endl;\n    continue;\n  }\n  keystream >> currentState;\n} else if ...\n```", "```cpp\n} else if (type == \"/State\"){\n  if (currentState == \"\"){\n    std::cout << \"Error: '/State' keyword found \n      prior to 'State'!\" << std::endl;\n    continue;\n  }\n  GUI_ElementState state = GUI_ElementState::Neutral;\n  if (currentState == \"Hover\"){state = GUI_ElementState::Focused;}\n  else if (currentState == \"Clicked\"){\n    state = GUI_ElementState::Clicked;\n  }\n\n  if (state == GUI_ElementState::Neutral){\n    ParentStyle = TemporaryStyle;\n    l_element->UpdateStyle(\n      GUI_ElementState::Neutral, TemporaryStyle);\n    l_element->UpdateStyle(\n      GUI_ElementState::Focused, TemporaryStyle);\n    l_element->UpdateStyle(\n      GUI_ElementState::Clicked, TemporaryStyle);\n  } else {\n    l_element->UpdateStyle(state, TemporaryStyle);\n  }\n  TemporaryStyle = ParentStyle;\n  currentState = \"\";\n} else { ...\n```", "```cpp\n} else {\n  // Handling style information.\n  if (currentState == \"\"){\n    std::cout << \"Error: '\" << type\n      << \"' keyword found outside of a state!\" << std::endl;\n    continue;\n  }\n  if (type == \"Size\"){\n    keystream >>TemporaryStyle.m_size.x >>TemporaryStyle.m_size.y;\n  } else if (type == \"BgColor\"){\n    int r, g, b, a = 0;\n    keystream >> r >> g >> b >> a;\n    TemporaryStyle.m_backgroundColor = sf::Color(r,g,b,a);\n  } else if (type == \"BgImage\"){\n    keystream >> TemporaryStyle.m_backgroundImage;\n  } else if (type == \"BgImageColor\"){\n    int r, g, b, a = 0;\n    keystream >> r >> g >> b >> a;\n    TemporaryStyle.m_backgroundImageColor = sf::Color(r, g, b, a);\n  } else if (type == \"TextColor\"){\n    int r, g, b, a = 0;\n    keystream >> r >> g >> b >> a;\n    TemporaryStyle.m_textColor = sf::Color(r, g, b, a);\n  } else if (type == \"TextSize\"){\n    keystream >> TemporaryStyle.m_textSize;\n  } else if (type == \"TextOriginCenter\"){\n    TemporaryStyle.m_textCenterOrigin = true;\n  } else if (type == \"Font\"){\n    keystream >> TemporaryStyle.m_textFont;\n  } else if (type == \"TextPadding\"){\n    keystream >> TemporaryStyle.m_textPadding.x\n      >> TemporaryStyle.m_textPadding.y;\n  } else if (type == \"ElementColor\"){\n    int r, g, b, a = 0;\n    keystream >> r >> g >> b >> a;\n    TemporaryStyle.m_elementColor = sf::Color(r, g, b, a);\n  } else if (type == \"Glyph\"){\n    keystream >> TemporaryStyle.m_glyph;\n  } else if (type == \"GlyphPadding\"){\n    Keystream >> TemporaryStyle.m_glyphPadding.x\n      >> TemporaryStyle.m_glyphPadding.y;\n  } else {\n    std::cout << \"Error: style tag '\" << type\n      << \"' is unknown!\" << std::endl;\n  }\n}\n```", "```cpp\nGUI_Label::GUI_Label(const std::string& l_name,\n  GUI_Interface* l_owner)\n  : GUI_Element(l_name, GUI_ElementType::Label, l_owner){}\n```", "```cpp\nElement Label TestLabel 0 0 Default.style \"Some text\"\n```", "```cpp\nvoid GUI_Label::ReadIn(std::stringstream& l_stream){\n    std::string content;\n    Utils::ReadQuotedString(l_stream, content);\n    m_visual.m_text.setString(content);\n}\n```", "```cpp\nvoid GUI_Label::OnClick(const sf::Vector2f& l_mousePos){\n  SetState(GUI_ElementState::Clicked);\n}\nvoid GUI_Label::OnRelease(){\n  SetState(GUI_ElementState::Neutral);\n}\nvoid GUI_Label::OnHover(const sf::Vector2f& l_mousePos){\n  SetState(GUI_ElementState::Focused);\n}\nvoid GUI_Label::OnLeave(){\n  SetState(GUI_ElementState::Neutral);\n}\n```", "```cpp\nvoid GUI_Label::Draw(sf::RenderTarget* l_target){\n  l_target->draw(m_visual.m_backgroundSolid);\n  if (m_style[m_state].m_glyph != \"\"){\n    l_target->draw(m_visual.m_glyph);\n  }\n  l_target->draw(m_visual.m_text);\n}\n```", "```cpp\nGUI_Textfield::GUI_Textfield(const std::string& l_name,\n  GUI_Interface* l_owner)\n  : GUI_Element(l_name, GUI_ElementType::Textfield , l_owner){}\n```", "```cpp\nvoid GUI_Textfield::ReadIn(std::stringstream& l_stream){\n  std::string content;\n  Utils::ReadQuotedString(l_stream, content);\n  m_visual.m_text.setString(content);\n}\n```", "```cpp\nvoid GUI_Textfield::OnRelease(){}\n```", "```cpp\nvoid GUI_Textfield::Draw(sf::RenderTarget* l_target){\n  l_target->draw(m_visual.m_backgroundSolid);\n  if (m_style[m_state].m_glyph != \"\"){\n    l_target->draw(m_visual.m_glyph);\n  }\n  l_target->draw(m_visual.m_text);\n}\n```", "```cpp\nenum class SliderType{ Horizontal, Vertical };\n\nclass GUI_Scrollbar : public GUI_Element{\npublic:\n  ...\n  void SetPosition(const sf::Vector2f& l_pos);\n  void ApplyStyle();\n  void UpdateStyle(const GUI_ElementState& l_state,\n    const GUI_Style& l_style);\nprivate:\n  SliderType m_sliderType;\n  sf::RectangleShape m_slider;\n  sf::Vector2f m_moveMouseLast;\n  int m_percentage;\n};\n```", "```cpp\nGUI_Scrollbar::GUI_Scrollbar(const std::string& l_name,\n  GUI_Interface* l_owner)\n  : GUI_Element(l_name, GUI_ElementType::Scrollbar, l_owner)\n{\n  m_isControl = true;\n}\n```", "```cpp\nvoid GUI_Scrollbar::SetPosition(const sf::Vector2f& l_pos){\n  GUI_Element::SetPosition(l_pos);\n  if (m_sliderType == SliderType::Horizontal){ m_position.x = 0; }\n  else { m_position.y = 0; }\n}\n```", "```cpp\nvoid GUI_Scrollbar::ReadIn(std::stringstream& l_stream){\n  std::string type;\n  l_stream >> type;\n  if (type == \"Horizontal\"){m_sliderType =SliderType::Horizontal;}\n  else { m_sliderType = SliderType::Vertical; }\n\n  if (m_sliderType == SliderType::Horizontal){\n    m_slider.setPosition(0, GetPosition().y);\n  }\n  else { m_slider.setPosition(GetPosition().x, 0); }\n}\n```", "```cpp\nvoid GUI_Scrollbar::OnClick(const sf::Vector2f& l_mousePos){\n  if (!m_slider.getGlobalBounds().contains(\n    l_mousePos - m_owner->GetPosition()))\n  {\n    return;\n  }\n  SetState(GUI_ElementState::Clicked);\n  m_moveMouseLast = l_mousePos;\n}\n```", "```cpp\nvoid GUI_Scrollbar::OnRelease(){\n  SetState(GUI_ElementState::Neutral);\n}\nvoid GUI_Scrollbar::OnHover(const sf::Vector2f& l_mousePos){\n  SetState(GUI_ElementState::Focused);\n}\nvoid GUI_Scrollbar::OnLeave(){\n  SetState(GUI_ElementState::Neutral);\n}\n```", "```cpp\nvoid GUI_Scrollbar::UpdateStyle(const GUI_ElementState& l_state,\n  const GUI_Style& l_style)\n{\n  GUI_Element::UpdateStyle(l_state, l_style);\n  if (m_sliderType == SliderType::Horizontal){\n    m_style[l_state].m_size.x = m_owner->GetSize().x;\n  }\n  else { m_style[l_state].m_size.y = m_owner->GetSize().y; }\n}\n```", "```cpp\nvoid GUI_Scrollbar::ApplyStyle(){\n  GUI_Element::ApplyStyle();\n  m_slider.setFillColor(m_style[m_state].m_elementColor);\n  bool horizontal = m_sliderType == SliderType::Horizontal;\n  auto& bgSolid = m_visual.m_backgroundSolid;\n  SetPosition((horizontal ?\n    sf::Vector2f(0, m_owner->GetSize().y - bgSolid.getSize().y) :\n    sf::Vector2f(m_owner->GetSize().x - bgSolid.getSize().x, 0)));\n  bgSolid.setSize((horizontal ?\n   sf::Vector2f(m_owner->GetSize().x,m_style[m_state].m_size.y) :\n   sf::Vector2f(m_style[m_state].m_size.x,m_owner->GetSize().y)));\n  m_slider.setPosition(\n    (horizontal ? m_slider.getPosition().x : GetPosition().x),\n    (horizontal ? GetPosition().y : m_slider.getPosition().y));\n  float SizeFactor = (horizontal ?\n    m_owner->GetContentSize().x / m_owner->GetSize().x :\n    m_owner->GetContentSize().y / m_owner->GetSize().y);\n  if (SizeFactor < 1.f){ SizeFactor = 1.f; }\n  float SliderSize = (horizontal ?\n    m_owner->GetSize().x : m_owner->GetSize().y) / SizeFactor;\n  m_slider.setSize((horizontal ?\n    sf::Vector2f(SliderSize,bgSolid.getSize().y):\n    sf::Vector2f(bgSolid.getSize().x, SliderSize)));\n  bgSolid.setPosition(GetPosition());\n}\n```", "```cpp\nvoid GUI_Scrollbar::Update(float l_dT){\n  // Mouse-drag code.\n  if (GetState() != GUI_ElementState::Clicked){ return; }\n  SharedContext* context = m_owner->GetManager()->GetContext();\n  sf::Vector2f mousePos = \n    sf::Vector2f(context->m_eventManager->GetMousePos(\n    context->m_wind->GetRenderWindow()));\n  if (m_moveMouseLast == mousePos){ return; }\n  sf::Vector2f difference = mousePos - m_moveMouseLast;\n  m_moveMouseLast = mousePos;\n\n  bool horizontal = m_sliderType == SliderType::Horizontal;\n  m_slider.move((horizontal ? difference.x : 0),\n    (horizontal ? 0 : difference.y));\n  if (horizontal && m_slider.getPosition().x < 0){\n    m_slider.setPosition(0, m_slider.getPosition().y);\n  } else if (m_slider.getPosition().y < 0){\n    m_slider.setPosition(m_slider.getPosition().x, 0);\n  }\n  if (horizontal&&(m_slider.getPosition().x+m_slider.getSize().x >\n    m_owner->GetSize().x))\n  {\n    m_slider.setPosition(\n      m_owner->GetSize().x - m_slider.getSize().x,\n      m_slider.getPosition().y);\n  } else if (m_slider.getPosition().y + m_slider.getSize().y >\n    m_owner->GetSize().y)\n  {\n    m_slider.setPosition(m_slider.getPosition().x,\n      m_owner->GetSize().y - m_slider.getSize().y);\n  }\n  float WorkArea = (horizontal ?\n    m_owner->GetSize().x - m_slider.getSize().x :\n    m_owner->GetSize().y - m_slider.getSize().y);\n  int percentage = ((horizontal ?\n    m_slider.getPosition().x : m_slider.getPosition().y) /\n    WorkArea) * 100;\n  if (horizontal){ m_owner->UpdateScrollHorizontal(percentage); }\n  else { m_owner->UpdateScrollVertical(percentage); }\n  SetRedraw(true);\n}\n```", "```cpp\nvoid GUI_Scrollbar::Draw(sf::RenderTarget* l_target){\n    l_target->draw(m_visual.m_backgroundSolid);\n    l_target->draw(m_slider);\n}\n```", "```cpp\nstruct SharedContext{\n  SharedContext():\n    ...\n    m_fontManager(nullptr),\n    ...\n    m_guiManager(nullptr){}\n     ...\n     FontManager* m_fontManager;\n  GUI_Manager* m_guiManager;\n};\n```", "```cpp\nclass Game{\npublic:\n    ...\nprivate:\n    ...\n    FontManager m_fontManager;\n    ...\n    GUI_Manager m_guiManager;\n};\n```", "```cpp\nGame::Game() : m_window(\"Chapter 11\", sf::Vector2u(800, 600)),\n  m_entityManager(&m_systemManager, &m_textureManager),\n  m_stateManager(&m_context),\n  m_guiManager(m_window.GetEventManager(),&m_context)\n{\n  ...\n  m_context.m_guiManager = &m_guiManager;\n  ...\n  m_fontManager.RequireResource(\"Main\");\n}\nGame::~Game(){ \n  m_fontManager.ReleaseResource(\"Main\");\n}\n```", "```cpp\nvoid Game::Update(){\n    ...\n    m_context.m_guiManager->Update(m_elapsed.asSeconds());\n    GUI_Event guiEvent;\n    while (m_context,m_guiManager->PollEvent(guiEvent)){\n        m_window.GetEventManager()->HandleEvent(guiEvent);\n    }\n}\n```", "```cpp\nvoid Game::Render(){\n    ...\n    m_stateManager.Draw();\n\n    sf::View CurrentView = m_window.GetRenderWindow()->getView();\n    m_window.GetRenderWindow()->setView(m_window.GetRenderWindow()->getDefaultView());\n    m_context.m_guiManager->Render(m_window->GetRenderWindow());\n    m_window.GetRenderWindow()->setView(CurrentView);\n\n    m_window.EndDraw();\n}\n```", "```cpp\nenum class EventType{ \n  ...\n  Keyboard = sf::Event::Count + 1, Mouse, Joystick,\n  GUI_Click, GUI_Release, GUI_Hover, GUI_Leave\n};\n```", "```cpp\nstruct EventInfo{\n    EventInfo(){ l_code = 0; }\n    EventInfo(int l_event){ l_code = l_event; }\n    EventInfo(GUI_Event l_guiEvent){ l_gui = l_guiEvent; }\n    union{\n        int l_code;\n        GUI_Event l_gui;\n    };\n};\n```", "```cpp\nstruct EventDetails{\n    EventDetails(const std::string& l_bindName)\n        : m_name(l_bindName){ Clear(); }\n    ...\n    std::string m_guiInterface; // GUI interface name.\n    std::string m_guiElement; // GUI element name.\n    GUI_EventType m_guiEvent; // GUI event type.\n\n    void Clear(){\n        ...\n        m_guiInterface = \"\";\n        m_guiElement = \"\";\n        m_guiEvent = GUI_EventType::None;\n    }\n};\n```", "```cpp\nstruct Binding{\n  Binding(const std::string& l_name): m_name(l_name),\n    m_details(l_name), c(0){}\n  ~Binding(){\n    // GUI portion.\n    for (auto itr = m_events.begin();\n      itr != m_events.end(); ++itr)\n    {\n      if (itr->first == EventType::GUI_Click ||\n        itr->first == EventType::GUI_Release ||\n        itr->first == EventType::GUI_Hover ||\n        itr->first == EventType::GUI_Leave)\n      {\n        delete [] itr->second.m_gui.m_interface;\n        delete [] itr->second.m_gui.m_element;\n      }\n    }\n  }\n  ...\n};\n```", "```cpp\nvoid HandleEvent(sf::Event& l_event);\nvoid HandleEvent(GUI_Event& l_event);\n```", "```cpp\nvoid EventManager::HandleEvent(sf::Event& l_event){\n  ...\n  for(auto &e_itr : bind->m_events){\n    EventType sfmlEvent = (EventType)l_event.type;\n    if (e_itr.first == EventType::GUI_Click ||\n      e_itr.first == EventType::GUI_Release ||\n      e_itr.first == EventType::GUI_Hover ||\n      e_itr.first == EventType::GUI_Leave)\n    {\n      continue;\n    }\n    ...\n  }\n  ...\n}\n```", "```cpp\nvoid EventManager::HandleEvent(GUI_Event& l_event){\n  for (auto &b_itr : m_bindings){\n    Binding* bind = b_itr.second;\n    for (auto &e_itr : bind->m_events)\n    {\n      if (e_itr.first != EventType::GUI_Click &&\n        e_itr.first != EventType::GUI_Release &&\n        e_itr.first != EventType::GUI_Hover &&\n        e_itr.first != EventType::GUI_Leave)\n      { continue; }\n      if ((e_itr.first == EventType::GUI_Click &&\n        l_event.m_type != GUI_EventType::Click) ||\n        (e_itr.first == EventType::GUI_Release &&\n        l_event.m_type != GUI_EventType::Release) ||\n        (e_itr.first == EventType::GUI_Hover &&\n        l_event.m_type != GUI_EventType::Hover) ||\n        (e_itr.first == EventType::GUI_Leave &&\n        l_event.m_type != GUI_EventType::Leave))\n      { continue; }\n      if (strcmp(e_itr.second.m_gui.m_interface,\n        l_event.m_interface) ||\n        strcmp(e_itr.second.m_gui.m_element, l_event.m_element))\n      { continue; }\n      bind->m_details.m_guiInterface = l_event.m_interface;\n      bind->m_details.m_guiElement = l_event.m_element;\n      ++(bind->c);\n    }\n  }\n}\n```", "```cpp\nKey_X 5:23\nMainMenu_Play 27:MainMenu:Play\n```", "```cpp\nvoid EventManager::LoadBindings(){\n  ...\n  while(!keystream.eof()){\n    std::string keyval;\n    keystream >> keyval;\n    int start = 0;\n    int end = keyval.find(delimiter);\n    if (end == std::string::npos){\n      delete bind;\n      bind = nullptr;\n      break;\n    }\n    EventType type = EventType(\n      stoi(keyval.substr(start, end-start)));\n\n    EventInfo eventInfo;\n    if (type==EventType::GUI_Click ||\n      type==EventType::GUI_Release ||\n      type == EventType::GUI_Hover ||\n      type == EventType::GUI_Leave)\n    {\n      start = end + delimiter.length();\n      end = keyval.find(delimiter, start);\n      std::string window = keyval.substr(start, end - start);\n      std::string element;\n      if (end != std::string::npos){\n        start = end + delimiter.length();\n        end = keyval.length();\n        element = keyval.substr(start, end);\n      }\n      char* w = new char[window.length() + 1]; // +1 for \\0\n char* e = new char[element.length() + 1];\n\n // Size in bytes is the same as character length.1 char = 1B.\n strcpy_s(w, window.length() + 1, window.c_str());\n strcpy_s(e, element.length() + 1, element.c_str());\n\n eventInfo.m_gui.m_interface = w;\n eventInfo.m_gui.m_element = e;\n    } else {\n      int code = stoi(keyval.substr(end + delimiter.length(),\n        keyval.find(delimiter,end + delimiter.length())));\n      eventInfo.m_code = code;\n    }\n    bind->BindEvent(type, eventInfo);\n  }\n  ...\n}\n```", "```cpp\nInterface MainMenu MainMenu.style 0 0 Immovable NoTitle \"Main menu\"\nElement Label Title 100 0 MainMenuTitle.style \"Main menu:\"\nElement Label Play 0 32 MainMenuLabel.style \"PLAY\"\nElement Label Credits 0 68 MainMenuLabel.style \"CREDITS\"\nElement Label Quit 0 104 MainMenuLabel.style \"EXIT\"\n```", "```cpp\nState Neutral\nSize 300 150\nTextSize 12\nFont Main\n/State\n```", "```cpp\nState Neutral\nSize 300 32\nBgColor 255 0 0 255\nTextColor 255 255 255 255\nTextSize 14\nFont Main\nTextPadding 150 16\nTextOriginCenter\n/State\n\nState Hover\nBgColor 255 100 0 255\n/State\n\nState Clicked\nBgColor 255 150 0 255\n/State\n```", "```cpp\nState Neutral\nSize 118 32\nTextColor 255 255 255 255\nTextSize 24\nFont Main\n/State\n```", "```cpp\nclass State_MainMenu : public BaseState{\npublic:\n    ...\n    void Play(EventDetails* l_details); // Callback.\n    void Quit(EventDetails* l_details); // Callback.\n};\n```", "```cpp\nvoid State_MainMenu::OnCreate(){\n  GUI_Manager* gui = m_stateMgr->GetContext()->m_guiManager;\n  gui->LoadInterface(StateType::MainMenu,\n    \"MainMenu.interface\", \"MainMenu\");\n  gui->GetInterface(StateType::MainMenu,\n    \"MainMenu\")->SetPosition(sf::Vector2f(250.f, 168.f));\n  EventManager* eMgr = m_stateMgr->GetContext()->m_eventManager;\n  eMgr->AddCallback(StateType::MainMenu,\n    \"MainMenu_Play\", &State_MainMenu::Play, this);\n  eMgr->AddCallback(StateType::MainMenu,\n    \"MainMenu_Quit\", &State_MainMenu::Quit, this);\n}\n```", "```cpp\nvoid State_MainMenu::OnDestroy(){\n  m_stateMgr->GetContext()->m_guiManager->\n    RemoveInterface(StateType::MainMenu, \"MainMenu\");\n  EventManager* eMgr = m_stateMgr->GetContext()->m_eventManager;\n  eMgr->RemoveCallback(StateType::MainMenu, \"MainMenu_Play\");\n  eMgr->RemoveCallback(StateType::MainMenu, \"MainMenu_Quit\");\n}\n```", "```cpp\nvoid State_MainMenu::Activate(){\n  auto& play = *m_stateMgr->GetContext()->m_guiManager->\n    GetInterface(StateType::MainMenu, \"MainMenu\")->\n    GetElement(\"Play\");\n  if (m_stateMgr->HasState(StateType::Game)){\n    // Resume\n    play.SetText(\"Resume\");\n  } else {\n    // Play\n    play.SetText(\"Play\");\n  }\n}\n```", "```cpp\nvoid State_MainMenu::Play(EventDetails* l_details){\n    m_stateMgr->SwitchTo(StateType::Game);\n}\nvoid State_MainMenu::Quit(EventDetails* l_details){\n    m_stateMgr->GetContext()->m_wind->Close();\n}\n```"]