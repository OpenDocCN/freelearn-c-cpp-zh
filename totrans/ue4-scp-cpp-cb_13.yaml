- en: AI for Controlling NPCs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC 控制AI
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Implementing a simple following behavior
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单的跟随行为
- en: Laying down a Navigation Mesh
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放置导航网格
- en: Creating a Blackboard
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建黑板
- en: Creating a Behavior Tree
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建行为树
- en: Connecting a Behavior Tree to a Character
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将行为树连接到角色
- en: Creating a BTService
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 BTService
- en: Creating a BTTask
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 BTTask
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: AI includes many aspects of a game's NPC, as well as player behavior. The general
    topic of AI includes pathfinding and NPC behavior. Generally, we term the selection
    of what the NPC does for a period of time within the game as behavior.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: AI 包括游戏 NPC 的许多方面，以及玩家行为。AI 的一般主题包括路径查找和 NPC 行为。通常，我们将 NPC 在游戏内一段时间内所做的事情称为行为。
- en: AI in UE4 is well supported. A number of constructs exist to allow basic AI
    programming from within the editor, but we will be focusing on using C++ to program
    elements while touching on engine aspects when needed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: UE4 中的 AI 得到了很好的支持。存在许多结构，允许在编辑器内进行基本的 AI 编程，但我们将专注于使用 C++ 编程元素，并在需要时涉及引擎方面。
- en: 'To make it easier to visualize our AI character and the interactions with the
    player, in this chapter, I will be using the C++ Third Person template:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使可视化我们的 AI 角色和与玩家的交互更容易，在本章中，我将使用 C++ 第三人称模板：
- en: '![](img/0293a11c-8c73-4598-b464-097efdc453a5.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0293a11c-8c73-4598-b464-097efdc453a5.png)'
- en: While I would love to cover all aspects of working with AI in Unreal Engine
    4, that could take a whole book of its own. If you are interested in exploring
    AI even more after reading this chapter, I suggest that you check out *Unreal
    Engine 4 AI Programming Essentials*, also available from Packt Publishing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我很乐意涵盖 Unreal Engine 4 中与 AI 一起工作的所有方面，但这可能需要一本整本书。如果你在阅读本章后对探索 AI 更加感兴趣，我建议你查看*Unreal
    Engine 4 AI 编程基础*，该书籍也由 Packt Publishing 提供。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用 Unreal Engine 4 和 Visual Studio 2017 作为 IDE。有关如何安装这两款软件及其要求的信息，请参阅[第
    1 章](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)，*UE4 开发工具*。
- en: Implementing a simple following behavior
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现简单的跟随行为
- en: The most simple way to implement any kind of AI is to just write it out by hand.
    This allows you to get something up-and-running quickly, but lacks the elegance
    and finesse that using Unreal's built-in systems gives us. This recipe gives us
    a super-simple implementation of making an object follow another one.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实现任何类型 AI 的最简单方法就是手动编写。这允许你快速启动并运行，但缺乏使用 Unreal 内置系统给我们带来的优雅和技巧。这个食谱提供了一个超级简单的实现，使一个对象跟随另一个对象。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have a UE4 project ready with a simple landscape or set of geometry on the ground, ideally
    with a *cul-de-sac* somewhere in the geometry to test AI movement functions. The
    `ThirdPersonExampleMap` that comes with the C++ Third Person template should work
    just fine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个 UE4 项目，其中包含一个简单的景观或地面上的一组几何形状，理想情况下在几何形状中有一个*死胡同*来测试 AI 移动功能。随 C++ 第三人称模板一起提供的`ThirdPersonExampleMap`应该可以正常工作。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new C++ class that derives from `Character` by going to Add New |
    New C++ Class. Under the Add C++ Class menu, select Character and hit the Next button:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到“添加新”|“新建 C++ 类”，创建一个新的 C++ 类，该类从`Character`派生。在“添加 C++ 类”菜单下，选择“Character”并点击“下一步”按钮：
- en: '![](img/39d55e09-2d74-4208-a316-e58723a542d9.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39d55e09-2d74-4208-a316-e58723a542d9.png)'
- en: 'From the next screen, Name the class `FollowingCharacter` and click on the Create
    Class button:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，将类命名为`FollowingCharacter`并点击“创建类”按钮：
- en: '![](img/597248e0-ee12-459f-9588-84457a32324a.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/597248e0-ee12-459f-9588-84457a32324a.png)'
- en: 'From the `FollowingCharacter.cpp` file, update the `Tick` function to the following:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FollowingCharacter.cpp`文件中，将`Tick`函数更新为以下内容：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `auto` keyword can be used for variable declarations if the compiler can
    deduce what the type of an object is from the assignment given to it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器可以从分配给对象的赋值中推断出对象类型，则可以使用`auto`关键字进行变量声明。
- en: Save your script and compile your code.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并编译你的代码。
- en: 'Drag and drop the Following Character into your scene. There is currently no
    visualization of the character, so go ahead and select the object. Then, from
    the Details tab, click the Add Component button. From there, select the Cylinder
    shape:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将跟随角色拖放到你的场景中。目前没有角色的可视化，所以请选择该对象。然后，从详细信息选项卡中，点击添加组件按钮。从那里，选择圆柱形状：
- en: '![](img/c8d54ec0-bd6d-4269-8951-2fcc86cf0489.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8d54ec0-bd6d-4269-8951-2fcc86cf0489.png)'
- en: If all goes well, you should see the object on the screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能在屏幕上看到对象。
- en: '![](img/eaec7727-a31c-429c-a0c9-d53b6b24b012.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eaec7727-a31c-429c-a0c9-d53b6b24b012.png)'
- en: The Following Character with a Cylinder shape added
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了圆柱形形状的以下角色
- en: Run the game and move around. You should notice that the cylinder will follow
    the player, no matter where they go!
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并四处移动。你应该注意到，无论玩家走到哪里，圆柱体都会跟随玩家！
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we are effectively *hard-coding* this enemy to follow the player
    character by doing simple vector math ourselves. While this technically works,
    it doesn't make use of Unreal's built-in AI functionality. It will also stop the
    AI at walls since there is no actual path-finding going on, and it will break
    the player character if you let the AI catch up. The player won't be able to move
    anymore due to collisions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实际上是通过自己进行简单的向量运算来*硬编码*这个敌人跟随玩家角色。虽然技术上可行，但它没有利用Unreal内置的AI功能。如果没有实际进行路径查找，它会在墙壁处停止AI，如果你让AI赶上玩家，它还会破坏玩家角色。由于碰撞，玩家将无法再移动。
- en: The rest of this chapter will be working with Unreal's actual built-in systems,
    which create a much more robust implementation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将使用Unreal的实际内置系统，这将创建一个更健壮的实现。
- en: Laying down a Navigation Mesh
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放置导航网格
- en: A Navigation Mesh (also known as a **Nav Mesh**) is basically a definition of
    areas that an AI-controlled unit considers passable (that is, areas that the "AI-controlled"
    unit is allowed to move into or across). A Nav Mesh does not include geometry
    that would block the player if the player tried to move through it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 导航网格（也称为**导航网格**）基本上是AI控制单位认为可通行的区域（即，“AI控制”单位被允许进入或穿越的区域）的定义。导航网格不包括如果玩家试图穿过它将会阻挡玩家的几何形状。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Constructing a Nav Mesh based on your scene's geometry is fairly easy in UE4\.
    Start with a project that has some obstacles around it, or one that uses terrain.
    The `ThirdPersonExampleMap` included with the C++ Third Person template works
    well for this purpose.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中根据场景的几何形状构建导航网格相当简单。从一个周围有一些障碍物或使用地形的现有项目开始。与C++第三人称模板一起提供的`ThirdPersonExampleMap`非常适合这个目的。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To construct your Nav Mesh, simply perform the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建你的导航网格，只需执行以下步骤：
- en: Go to Modes | Volumes.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 模式 | 体积。
- en: Drag the Nav Mesh Bounds Volume option onto your viewport.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 导航网格边界体积 选项拖放到你的视图中。
- en: 'Use the Scale tool to increase the size of the Nav Mesh so that it covers the
    area the actors that use the Nav Mesh should be allowed to navigate and pathfind
    in. To toggle the visibility of the completed Nav Mesh, press the *P* key:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用缩放工具增加导航网格的大小，使其覆盖使用导航网格的演员应该被允许导航和路径查找的区域。要切换完成后的导航网格的可见性，按*P*键：
- en: '![](img/9b025c53-495a-412d-91e5-ae9c9e6b5b92.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b025c53-495a-412d-91e5-ae9c9e6b5b92.png)'
- en: A Nav Mesh drawn within the bounds of the Nav Mesh Bounds Volume
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航网格边界体积范围内的导航网格
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A Nav Mesh doesn't block the player pawn (or other entities) from stepping on
    a certain geometry, but it serves to guide AI-controlled entities as to where
    they can and cannot go.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 导航网格不会阻止玩家 pawn（或其他实体）踩在某个几何形状上，但它用于指导AI控制实体他们可以和不可以去的地方。
- en: For more information on scaling objects in UE4, check out the following link: [https://docs.unrealengine.com/en-us/Engine/Actors/Transform](https://docs.unrealengine.com/en-us/Engine/Actors/Transform).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于在UE4中缩放对象的信息，请查看以下链接：[https://docs.unrealengine.com/en-us/Engine/Actors/Transform](https://docs.unrealengine.com/en-us/Engine/Actors/Transform).
- en: Creating a Blackboard
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建黑板
- en: A **Blackboard** is a container for variables that are often used with Behavior
    Trees. This data is used for decision-making purposes, either by a single AI or
    a whole group of others. We will be creating a Blackboard here that we will then
    use in future recipes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑板**是用于与行为树一起使用的变量的容器。这些数据用于决策目的，无论是单个AI还是一组AI。我们在这里将创建一个黑板，然后在未来的菜谱中使用它。'
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'From the Content Browser under the `Content` folder, select Add New | Artificial
    Intelligence | Blackboard:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`内容`文件夹下的内容浏览器中，选择添加新项 | 人工智能 | 黑板：
- en: '![](img/ab959cad-1fb0-4c9f-9d53-5425a5ed955c.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ab959cad-1fb0-4c9f-9d53-5425a5ed955c.png)'
- en: When asked for a name, provide `EnemyBlackboard`. Double-click on the file to
    open the Blackboard Editor.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求提供名称时，提供`EnemyBlackboard`。双击文件以打开黑板编辑器。
- en: 'From the Blackboard tab, click New Key | Object:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“黑板”选项卡中，点击新建键 | 对象：
- en: '![](img/bf12d03b-7d23-4239-bdb8-8f1bdc718b8a.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf12d03b-7d23-4239-bdb8-8f1bdc718b8a.png)'
- en: 'When asked for the name of the object, insert `Target`. Then, open the Key
    Type property by clicking the arrow to the left of the name and set the Base Class
    property to `Actor`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求提供对象的名称时，输入`Target`。然后，通过点击名称左侧的箭头打开键类型属性，并将基本类属性设置为`Actor`：
- en: '![](img/bf4829a3-3d30-4687-a757-43229a9bed7c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf4829a3-3d30-4687-a757-43229a9bed7c.png)'
- en: Add any other properties you wish to have access to and then click on the Save
    button.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加任何其他你希望访问的属性，然后点击“保存”按钮。
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a blackboard that we will later use in code to set
    and get the value of the player that we will use in our behavior tree.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个黑板，稍后我们将在代码中使用它来设置和获取我们在行为树中将使用的玩家的值。
- en: Creating a Behavior Tree
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建行为树
- en: If a Blackboard is the shared memory of an AI, the Behavior Tree is the AI's
    processor, which will contain the logic of the AI. It makes decisions, and then
    acts on those decisions to enable an AI to actually do something when the game
    is running. In this recipe, we will create a Behavior Tree and then assign its
    Blackboard.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果黑板是AI的共享内存，那么行为树就是AI的处理器，其中将包含AI的逻辑。它做出决策，然后根据这些决策采取行动，使AI在游戏运行时实际上能够做些什么。在这个菜谱中，我们将创建一个行为树并将其分配给黑板。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'From the Content Browser under the `Content` folder, select Add New | Artificial
    Intelligence | Behavior Tree:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`内容`文件夹下的`内容浏览器`中，选择添加新项 | 人工智能 | 行为树：
- en: '![](img/144f462c-a25f-4e5f-9243-507ee517881a.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/144f462c-a25f-4e5f-9243-507ee517881a.png)'
- en: When asked for a name, provide `EnemyBehaviorTree`. Double-click on the file
    to open the Behavior Tree Editor.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求提供名称时，提供`EnemyBehaviorTree`。双击文件以打开行为树编辑器。
- en: 'Once opened, under the Details tab, open the AI | Behavior Tree section and
    verify that the Blackboard Asset property is set to `EnemyBlackboard`. You should
    notice the Target property we created listed under Keys. If not, close the editor
    and open it again:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开后，在“详细信息”选项卡下，打开AI | 行为树部分，并验证黑板资产属性是否设置为`EnemyBlackboard`。你应该会注意到我们创建的Target属性在“键”下列出。如果没有，请关闭编辑器并重新打开：
- en: '![](img/40020a2c-e30b-4f4b-b880-8c227ee889d0.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40020a2c-e30b-4f4b-b880-8c227ee889d0.png)'
- en: A view of the Behavior Tree Editor
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树编辑器的视图
- en: Once finished, click on the Save button.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击“保存”按钮。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a Behavior Tree, which is required by the AI system
    so that it can fulfill tasks and other assorted features. In future recipes, we
    will use this to create our own custom Character classes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个行为树，这是AI系统所必需的，以便它能够完成任务和其他各种功能。在未来的菜谱中，我们将使用它来创建我们自己的自定义角色类。
- en: Connecting a Behavior Tree to a Character
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将行为树连接到角色
- en: A `BehaviorTree` chooses a behavior to be exhibited by an AI-controlled unit
    at any given moment. Behavior Trees are relatively simple to construct, but there
    is a lot of setting up to do to get one running. You also have to be familiar
    with the components that are available for constructing your **Behavior Tree** to
    do so effectively.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`行为树`在任意时刻选择一个由AI控制的单位所表现的行为。行为树相对简单构建，但要使其运行，需要进行大量的设置。你还需要熟悉用于构建你的**行为树**的组件，以便有效地进行操作。
- en: A Behavior Tree is extremely useful for defining NPC behavior that is more varied
    than simply moving toward an opponent (as shown in the previous recipe with `AIMoveTo`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树对于定义比简单地朝向对手移动（如前一个菜谱中的`AIMoveTo`所示）更丰富的NPC行为非常有用。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before starting this recipe, verify that you have completed the following recipes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始此菜谱之前，请确保你已经完成了以下菜谱：
- en: '*Laying down a Navigation Mesh*'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*铺设导航网格*'
- en: '*Creating a Blackboard*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建黑板*'
- en: '*Creating a Behavior Tree*'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建行为树*'
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open up your `.Build.cs` file (in our case, `Chapter_13.Build.cs`) and add
    the following dependencies:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`.Build.cs`文件（在我们的例子中，`Chapter_13.Build.cs`）并添加以下依赖项：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile your code.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码。
- en: 'From the Content Browser, select Add New | New C++ Class. At the Add C++ Class
    menu, check the Show All Classes option type in `AIController`, and then select
    the `AIController` class. Then, click on Next:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中，选择添加新 | 新C++类。在添加C++类菜单中，检查显示所有类选项，输入`AIController`，然后选择`AIController`类。然后，点击下一步：
- en: '![](img/4db220e7-1fa7-48a1-9f27-d230b88354d4.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4db220e7-1fa7-48a1-9f27-d230b88354d4.png)'
- en: When asked for a name for the class, name it `EnemyAIController` and click on
    the Create Class button.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求为类命名时，命名为`EnemyAIController`并点击创建类按钮。
- en: 'Open up Visual Studio and update the `EnemyAIController.h` file to the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并更新`EnemyAIController.h`文件如下：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After creating the function declarations, we need to define them in the `EnemyAIController.cpp`
    file:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建函数声明后，我们需要在`EnemyAIController.cpp`文件中定义它们：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In addition to an AI Controller, we also need to have a Character.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了AI控制器，我们还需要有一个角色。
- en: 'Create a new C++ class that derives from `Character` by going to Add New |
    New C++ Class. Under the Add C++ Class menu, select Character and hit the Next button:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到添加新 | 新C++类创建一个新的C++类，该类从`Character`派生。在添加C++类菜单下，选择`Character`并点击下一步按钮：
- en: '![](img/9f10b90b-8e30-4d27-9752-a97c1c011ad5.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f10b90b-8e30-4d27-9752-a97c1c011ad5.png)'
- en: From the next screen, `Name` the class `EnemyCharacter` and click on the Create
    Class button.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，将类命名为`EnemyCharacter`并点击创建类按钮。
- en: 'Open Visual Studio. Under the `EnemyCharacter.h` file, add the following property:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。在`EnemyCharacter.h`文件下，添加以下属性：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we can go back into the `EnemyAIController.cpp` file and update the `Possess`
    function since our Character class exists:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以回到`EnemyAIController.cpp`文件并更新`Possess`函数，因为我们的角色类已经存在：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save your scripts and compile your code.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并编译你的代码。
- en: Now, we will create a Blueprint version of the two classes we just created and
    assign our variables.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们刚刚创建的两个类的蓝图版本，并分配我们的变量。
- en: From the Content Browser under the `C++ Classes/Chapter_13` folder, right-click
    on the `EnemyAIController` object and select the Create Blueprint class based
    on EnemyAIController option. Give it a name and click on the Create Blueprint
    Class button.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`C++ Classes/Chapter_13`文件夹下的内容浏览器中，右键单击`EnemyAIController`对象，选择基于`EnemyAIController`创建蓝图类选项。给它一个名字并点击创建蓝图类按钮。
- en: Likewise, do the same thing for the `EnemyCharacter` object.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，对`EnemyCharacter`对象做同样的事情。
- en: 'Double-click on your `MyEnemyCharacter` Blueprint and, under the Details tab,
    set the Enemy Behavior Tree property to EnemyBehaviorTree. Then, set the AI Controller Class
    property to `MyEnemyAIController`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击你的`MyEnemyCharacter`蓝图，在详细信息选项卡下，将敌对行为树属性设置为`EnemyBehaviorTree`。然后，将AI控制器类属性设置为`MyEnemyAIController`：
- en: '![](img/553deaf5-094e-49be-850d-047a325d2958.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/553deaf5-094e-49be-850d-047a325d2958.png)'
- en: Assigning the Enemy Behavior Tree and AI Controller Class properties
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 分配敌对行为树和AI控制器类属性
- en: You'll likely want a visual component for the character as well, so from the
    Components tab, click on the Add Component button and select Cube. Afterward,
    modify the Scale to (`0.5, 0.5, 1.5`).
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还想为角色添加一个视觉组件，因此从组件选项卡，点击添加组件按钮并选择立方体。之后，修改缩放为（`0.5, 0.5, 1.5`）。
- en: As we discussed previously, you may need to click on the Open Full Blueprint
    Editor text to see all of the available options.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，你可能需要点击打开完整蓝图编辑器文本以查看所有可用选项。
- en: '16\. Then, hit Compile and save all of your assets:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 16. 然后，编译并保存所有你的资产：
- en: '![](img/ea359363-aa31-4d0b-b7d0-c8d67aab84e7.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea359363-aa31-4d0b-b7d0-c8d67aab84e7.png)'
- en: The completed enemy character
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的敌对角色
- en: And with that, we've set up a connection between an AI Character, an AI Controller,
    and a Behavior Tree!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就建立了一个AI角色、AI控制器和行为树之间的连接！
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The AI Controller class we created will add both the Behavior Tree and the Blackboard
    that we created in the previous two recipes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的AI控制器类将添加我们在前两个菜谱中创建的行为树和黑板。
- en: A Behavior Tree is connected to an AI Controller, which in turn is connected
    to a Character. We will control the behavior of `Character` through the Behavior
    Tree by entering Task and Service nodes in the diagram.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树连接到AI控制器，AI控制器反过来连接到角色。我们将通过在图中输入任务和服务节点来通过行为树控制`Character`的行为。
- en: 'A Behavior Tree hosts six different types of node, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树托管了六种不同类型的节点，如下所示：
- en: '**Task**: Task nodes are the purple nodes in the Behavior Tree that contain
    Blueprint code to run. It''s something that the AI-controlled unit has to do (code-wise).
    Tasks must return either `true` or `false`, depending on whether the task succeeded
    or not (by providing a `FinishExecution()` node at the end).'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任务**：任务节点是行为树中的紫色节点，包含要运行的蓝图代码。这是由 AI 控制的单位必须执行的操作（代码方面）。任务必须返回 `true` 或
    `false`，具体取决于任务是否成功（通过在末尾提供 `FinishExecution()` 节点）。'
- en: '**Decorator**: A decorator is just a Boolean condition for the execution of
    a node. It checks a condition, and is typically used within a Selector or Sequence
    block.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**装饰器**：装饰器只是节点执行的布尔条件。它检查一个条件，通常用于选择器或序列块内。'
- en: '**Service**: This runs some Blueprint code when it ticks. The tick interval
    for these nodes is adjustable (it can run slower than a per-frame tick, for example,
    every 10 seconds). You can use these to query the scene for updates, a new opponent
    to chase, and so on. The Blackboard can be used to store queried information.
    Service nodes do not have a `FinishExecute()` call at the end of them.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务**：当它计时时会运行一些蓝图代码。这些节点的计时间隔是可调整的（例如，它可以比每帧计时慢，比如每10秒一次）。你可以使用这些来查询场景更新、新的对手等。黑板可以用来存储查询信息。服务节点在其末尾没有
    `FinishExecute()` 调用。'
- en: '**Selector**: This runs all subtrees from left to right until it encounters
    a success. When it encounters a success, the execution goes back up the tree.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择器**：它从左到右运行所有子树，直到遇到成功。当遇到成功时，执行会回溯到树中。'
- en: '**Sequence**: This runs all subtrees from left to right until it encounters
    a failure. When a failure is encountered, the execution goes back up the tree.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**序列**：它从左到右运行所有子树，直到遇到失败。当遇到失败时，执行会回溯到树中。'
- en: '**Simple Parallel**: This runs a single task (purple) in parallel with a subtree
    (gray).'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简单并行**：这将在并行子树（灰色）与单个任务（紫色）一起运行。'
- en: Creating a BTService
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 BTService
- en: Services attach to nodes in Behavior Trees and will execute at their defined
    frequency; that is, as long as their branch is being executed. Similar to Parallel
    nodes in other Behavior Tree systems, these are often used to make checks and
    to update the Blackboard, which we will use in this recipe to find our player
    object and assign it to our Blackboard.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 服务附加到行为树中的节点，并将以它们定义的频率执行；也就是说，只要它们的分支正在执行。类似于其他行为树系统中的并行节点，这些通常用于进行检查和更新黑板，我们将在此配方中使用它来找到我们的玩家对象并将其分配给我们的黑板。
- en: Getting ready...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Finish the previous recipe, *Connecting a Behavior Tree to a Character*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完成之前的配方，*将行为树连接到角色*。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'From the Content Browser, select Add New | New C++ Class. From the Choose Parent
    Class menu, check the Show All Classes option and look for the `BTService` class.
    Select it and then hit the Next button:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内容浏览器中选择添加新内容 | 新 C++ 类。从选择父类菜单中，勾选显示所有类选项，并查找 `BTService` 类。选择它然后点击下一步按钮：
- en: '![](img/0a41289d-bab4-4f68-a540-4f354a5e08a8.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a41289d-bab4-4f68-a540-4f354a5e08a8.png)'
- en: At the next menu, set its name to `BTService_FindPlayer` and then click on the
    Create Class option.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个菜单中，将其名称设置为 `BTService_FindPlayer`，然后点击创建类选项。
- en: 'From the `BTService_FindPlayer.h` file, use the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `BTService_FindPlayer.h` 文件中，使用以下代码：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From the `BTService_FindPlayer.cpp` file, use the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `BTService_FindPlayer.cpp` 文件中，使用以下代码：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save your scripts and compile them.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并编译它们。
- en: In the Content Browser, go to the `Content` folder where the `EnemyBehaviorTree`
    we created previously is located and double-click on it to open the Behavior Tree
    editor.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中，转到 `Content` 文件夹，其中包含我们之前创建的 `EnemyBehaviorTree`，双击它以打开行为树编辑器。
- en: 'From there, drag a line from ROOT down and select Selector:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，从 ROOT 处拖动一条线并选择选择器：
- en: '![](img/02b17ca7-1f63-459e-812c-f631ef24d0e5.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02b17ca7-1f63-459e-812c-f631ef24d0e5.png)'
- en: It's important to note that you need to drag from the darker gray rectangle
    on the bottom. If you try to drag from the middle of ROOT, you'll just move the
    node.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，你需要从底部的深灰色矩形处拖动。如果你尝试从 ROOT 的中间拖动，你只会移动节点。
- en: 'Right-click on the Selector node and select Add Service | FindPlayer:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击选择器节点并选择添加服务 | 查找玩家：
- en: '![](img/36058d95-940d-494f-bcd3-9f1d70ff5617.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36058d95-940d-494f-bcd3-9f1d70ff5617.png)'
- en: 'Now, drag and drop an instance of your `MyEnemyCharacter` object into your
    scene and run the game:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将你的 `MyEnemyCharacter` 对象实例拖放到场景中并运行游戏：
- en: '![](img/538167bc-799d-4532-a475-eaa0eee25c53.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/538167bc-799d-4532-a475-eaa0eee25c53.png)'
- en: As you can see, the value has been set!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，值已经被设置！
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our Behavior Tree will continue to call the Selector as there are no other nodes
    for it to transition to.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有其他节点可以转换到，我们的行为树将继续调用选择器。
- en: Creating a BTTask
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个BTTask
- en: In addition to Services, we also have Tasks, which are leaf nodes of Behavior
    Trees. These are the things that actually perform actions. In our example, we
    are going to have our AI follow our target, the player.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了服务之外，我们还有任务，它们是行为树的叶节点。这些是实际执行动作的东西。在我们的例子中，我们将让我们的AI跟随我们的目标，即玩家。
- en: Getting ready...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中...
- en: Finish the previous recipe, *Creating a BTService*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完成之前的配方，*创建一个BTService*。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'From the Content Browser, select Add New | New C++ Class. From the Choose Parent
    Class menu, check the Show All Classes option and look for the `BTTask_BlackboardBase` class.
    Select it and then hit the Next button:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内容浏览器中选择“添加新内容”|“新C++类”。在“选择父类”菜单中，勾选“显示所有类”选项，并查找`BTTask_BlackboardBase`类。选择它然后点击“下一步”按钮：
- en: '![](img/91d4a05e-cee6-4e79-bdc9-18e76094d6d9.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91d4a05e-cee6-4e79-bdc9-18e76094d6d9.png)'
- en: 'At the next menu, set its name to `BTTask_MoveToPlayer` and then click on the Create
    Class option:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个菜单中，将其名称设置为`BTTask_MoveToPlayer`，然后点击“创建类”选项：
- en: '![](img/00eb28d3-9f0c-4946-89f3-a726f8b2f435.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00eb28d3-9f0c-4946-89f3-a726f8b2f435.png)'
- en: 'Open Visual Studio and add the following function to `BTTask_MoveToPlayer.h`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio，并将以下函数添加到`BTTask_MoveToPlayer.h`中：
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, open the `BTTask_MoveToPlayer.cpp` file and update it to the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`BTTask_MoveToPlayer.cpp`文件，并将其更新为以下内容：
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save your files and return to the Unreal Editor. Compile your code.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的文件并返回到Unreal编辑器。编译您的代码。
- en: In the Content Browser, go to the `Content` folder where the `EnemyBehaviorTree` we
    created previously is located and double-click on it to open the Behavior Tree
    editor.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中，转到包含我们之前创建的`EnemyBehaviorTree`的`Content`文件夹，并双击它以打开行为树编辑器。
- en: 'Drag this below the Selector node and select Tasks | Move to Player:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此操作拖到选择节点下方，并选择任务|移动到玩家：
- en: '![](img/571d92a5-1006-40e6-b2a4-64a3d13b72fc.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/571d92a5-1006-40e6-b2a4-64a3d13b72fc.png)'
- en: 'Save the Behavior Tree and return to the Unreal Editor. Drag and drop a `MyEnemyCharacter` object
    into the scene if you haven''t done so already and play the game:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存行为树并返回到Unreal编辑器。如果您还没有这样做，将`MyEnemyCharacter`对象拖放到场景中并玩游戏：
- en: '![](img/dcddb9f0-f8a7-4b70-b9c9-2088fd700a86.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcddb9f0-f8a7-4b70-b9c9-2088fd700a86.png)'
- en: As you can see, our enemy is now following our player, which will happen for
    as long as the NavMesh covers the area!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的敌人现在正在跟随我们的玩家，只要导航网格覆盖该区域，这种情况就会发生！
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe takes all of the materials we've covered so far and compiles them
    all together. The `ExecuteTask` method will be called as long as the BehaviorTree
    is inside this state. This function requires us to return an `EBTNodeResult`,
    which should return `Succeeded`, `Failed`, or `InProgress` to let the BehaviorTree
    know whether we can change states or not.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将我们迄今为止涵盖的所有材料全部编译在一起。只要行为树处于此状态内部，就会调用`ExecuteTask`方法。此函数要求我们返回一个`EBTNodeResult`，它应该返回`Succeeded`、`Failed`或`InProgress`，以便让行为树知道我们是否可以更改状态。
- en: In our case, we first obtain the `EnemyController` and the `Target` objects
    so that we can figure out who we want to move and where we want to move to. As
    long as those properties are valid, we can call the `MoveToActor` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们首先获取`EnemyController`和`Target`对象，以便我们可以确定我们想要移动谁以及我们想要移动到哪里。只要这些属性有效，我们就可以调用`MoveToActor`函数。
- en: There are a lot of other properties that the `MoveToActor` function offers that
    may be useful so that you can customize your movement. For more information, check
    out the following link: [https://api.unrealengine.com/INT/API/Runtime/AIModule/AAIController/MoveToActor/index.html](https://api.unrealengine.com/INT/API/Runtime/AIModule/AAIController/MoveToActor/index.html).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveToActor`函数提供了许多其他属性，这些属性可能很有用，以便您可以自定义您的移动。更多信息，请查看以下链接：[https://api.unrealengine.com/INT/API/Runtime/AIModule/AAIController/MoveToActor/index.html](https://api.unrealengine.com/INT/API/Runtime/AIModule/AAIController/MoveToActor/index.html)。'
- en: For those of you who are interested in exploring additional AI concepts with
    UE4, I highly suggest checking out Orfeas Eleftheriou's UE4 AI Tutorials: [https://orfeasel.com/category/ue_tuts/ai-programming/](https://orfeasel.com/category/ue_tuts/ai-programming/).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对在UE4中探索更多AI概念的感兴趣的人，我强烈建议查看Orfeas Eleftheriou的UE4 AI教程：[https://orfeasel.com/category/ue_tuts/ai-programming/](https://orfeasel.com/category/ue_tuts/ai-programming/)。
