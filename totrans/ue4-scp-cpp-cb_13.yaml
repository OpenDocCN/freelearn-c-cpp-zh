- en: AI for Controlling NPCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple following behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laying down a Navigation Mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Blackboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Behavior Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting a Behavior Tree to a Character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a BTService
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a BTTask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AI includes many aspects of a game's NPC, as well as player behavior. The general
    topic of AI includes pathfinding and NPC behavior. Generally, we term the selection
    of what the NPC does for a period of time within the game as behavior.
  prefs: []
  type: TYPE_NORMAL
- en: AI in UE4 is well supported. A number of constructs exist to allow basic AI
    programming from within the editor, but we will be focusing on using C++ to program
    elements while touching on engine aspects when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier to visualize our AI character and the interactions with the
    player, in this chapter, I will be using the C++ Third Person template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0293a11c-8c73-4598-b464-097efdc453a5.png)'
  prefs: []
  type: TYPE_IMG
- en: While I would love to cover all aspects of working with AI in Unreal Engine
    4, that could take a whole book of its own. If you are interested in exploring
    AI even more after reading this chapter, I suggest that you check out *Unreal
    Engine 4 AI Programming Essentials*, also available from Packt Publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple following behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most simple way to implement any kind of AI is to just write it out by hand.
    This allows you to get something up-and-running quickly, but lacks the elegance
    and finesse that using Unreal's built-in systems gives us. This recipe gives us
    a super-simple implementation of making an object follow another one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a UE4 project ready with a simple landscape or set of geometry on the ground, ideally
    with a *cul-de-sac* somewhere in the geometry to test AI movement functions. The
    `ThirdPersonExampleMap` that comes with the C++ Third Person template should work
    just fine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new C++ class that derives from `Character` by going to Add New |
    New C++ Class. Under the Add C++ Class menu, select Character and hit the Next button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/39d55e09-2d74-4208-a316-e58723a542d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the next screen, Name the class `FollowingCharacter` and click on the Create
    Class button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/597248e0-ee12-459f-9588-84457a32324a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the `FollowingCharacter.cpp` file, update the `Tick` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `auto` keyword can be used for variable declarations if the compiler can
    deduce what the type of an object is from the assignment given to it.
  prefs: []
  type: TYPE_NORMAL
- en: Save your script and compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop the Following Character into your scene. There is currently no
    visualization of the character, so go ahead and select the object. Then, from
    the Details tab, click the Add Component button. From there, select the Cylinder
    shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c8d54ec0-bd6d-4269-8951-2fcc86cf0489.png)'
  prefs: []
  type: TYPE_IMG
- en: If all goes well, you should see the object on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaec7727-a31c-429c-a0c9-d53b6b24b012.png)'
  prefs: []
  type: TYPE_IMG
- en: The Following Character with a Cylinder shape added
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and move around. You should notice that the cylinder will follow
    the player, no matter where they go!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we are effectively *hard-coding* this enemy to follow the player
    character by doing simple vector math ourselves. While this technically works,
    it doesn't make use of Unreal's built-in AI functionality. It will also stop the
    AI at walls since there is no actual path-finding going on, and it will break
    the player character if you let the AI catch up. The player won't be able to move
    anymore due to collisions.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter will be working with Unreal's actual built-in systems,
    which create a much more robust implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Laying down a Navigation Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Navigation Mesh (also known as a **Nav Mesh**) is basically a definition of
    areas that an AI-controlled unit considers passable (that is, areas that the "AI-controlled"
    unit is allowed to move into or across). A Nav Mesh does not include geometry
    that would block the player if the player tried to move through it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructing a Nav Mesh based on your scene's geometry is fairly easy in UE4\.
    Start with a project that has some obstacles around it, or one that uses terrain.
    The `ThirdPersonExampleMap` included with the C++ Third Person template works
    well for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To construct your Nav Mesh, simply perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Modes | Volumes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Nav Mesh Bounds Volume option onto your viewport.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the Scale tool to increase the size of the Nav Mesh so that it covers the
    area the actors that use the Nav Mesh should be allowed to navigate and pathfind
    in. To toggle the visibility of the completed Nav Mesh, press the *P* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b025c53-495a-412d-91e5-ae9c9e6b5b92.png)'
  prefs: []
  type: TYPE_IMG
- en: A Nav Mesh drawn within the bounds of the Nav Mesh Bounds Volume
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Nav Mesh doesn't block the player pawn (or other entities) from stepping on
    a certain geometry, but it serves to guide AI-controlled entities as to where
    they can and cannot go.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on scaling objects in UE4, check out the following link: [https://docs.unrealengine.com/en-us/Engine/Actors/Transform](https://docs.unrealengine.com/en-us/Engine/Actors/Transform).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Blackboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Blackboard** is a container for variables that are often used with Behavior
    Trees. This data is used for decision-making purposes, either by a single AI or
    a whole group of others. We will be creating a Blackboard here that we will then
    use in future recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the Content Browser under the `Content` folder, select Add New | Artificial
    Intelligence | Blackboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ab959cad-1fb0-4c9f-9d53-5425a5ed955c.png)'
  prefs: []
  type: TYPE_IMG
- en: When asked for a name, provide `EnemyBlackboard`. Double-click on the file to
    open the Blackboard Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Blackboard tab, click New Key | Object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bf12d03b-7d23-4239-bdb8-8f1bdc718b8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When asked for the name of the object, insert `Target`. Then, open the Key
    Type property by clicking the arrow to the left of the name and set the Base Class
    property to `Actor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bf4829a3-3d30-4687-a757-43229a9bed7c.png)'
  prefs: []
  type: TYPE_IMG
- en: Add any other properties you wish to have access to and then click on the Save
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created a blackboard that we will later use in code to set
    and get the value of the player that we will use in our behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a Blackboard is the shared memory of an AI, the Behavior Tree is the AI's
    processor, which will contain the logic of the AI. It makes decisions, and then
    acts on those decisions to enable an AI to actually do something when the game
    is running. In this recipe, we will create a Behavior Tree and then assign its
    Blackboard.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the Content Browser under the `Content` folder, select Add New | Artificial
    Intelligence | Behavior Tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/144f462c-a25f-4e5f-9243-507ee517881a.png)'
  prefs: []
  type: TYPE_IMG
- en: When asked for a name, provide `EnemyBehaviorTree`. Double-click on the file
    to open the Behavior Tree Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once opened, under the Details tab, open the AI | Behavior Tree section and
    verify that the Blackboard Asset property is set to `EnemyBlackboard`. You should
    notice the Target property we created listed under Keys. If not, close the editor
    and open it again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/40020a2c-e30b-4f4b-b880-8c227ee889d0.png)'
  prefs: []
  type: TYPE_IMG
- en: A view of the Behavior Tree Editor
  prefs: []
  type: TYPE_NORMAL
- en: Once finished, click on the Save button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created a Behavior Tree, which is required by the AI system
    so that it can fulfill tasks and other assorted features. In future recipes, we
    will use this to create our own custom Character classes.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a Behavior Tree to a Character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `BehaviorTree` chooses a behavior to be exhibited by an AI-controlled unit
    at any given moment. Behavior Trees are relatively simple to construct, but there
    is a lot of setting up to do to get one running. You also have to be familiar
    with the components that are available for constructing your **Behavior Tree** to
    do so effectively.
  prefs: []
  type: TYPE_NORMAL
- en: A Behavior Tree is extremely useful for defining NPC behavior that is more varied
    than simply moving toward an opponent (as shown in the previous recipe with `AIMoveTo`).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting this recipe, verify that you have completed the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Laying down a Navigation Mesh*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a Blackboard*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a Behavior Tree*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open up your `.Build.cs` file (in our case, `Chapter_13.Build.cs`) and add
    the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Content Browser, select Add New | New C++ Class. At the Add C++ Class
    menu, check the Show All Classes option type in `AIController`, and then select
    the `AIController` class. Then, click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4db220e7-1fa7-48a1-9f27-d230b88354d4.png)'
  prefs: []
  type: TYPE_IMG
- en: When asked for a name for the class, name it `EnemyAIController` and click on
    the Create Class button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up Visual Studio and update the `EnemyAIController.h` file to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the function declarations, we need to define them in the `EnemyAIController.cpp`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In addition to an AI Controller, we also need to have a Character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C++ class that derives from `Character` by going to Add New |
    New C++ Class. Under the Add C++ Class menu, select Character and hit the Next button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f10b90b-8e30-4d27-9752-a97c1c011ad5.png)'
  prefs: []
  type: TYPE_IMG
- en: From the next screen, `Name` the class `EnemyCharacter` and click on the Create
    Class button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open Visual Studio. Under the `EnemyCharacter.h` file, add the following property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can go back into the `EnemyAIController.cpp` file and update the `Possess`
    function since our Character class exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Save your scripts and compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will create a Blueprint version of the two classes we just created and
    assign our variables.
  prefs: []
  type: TYPE_NORMAL
- en: From the Content Browser under the `C++ Classes/Chapter_13` folder, right-click
    on the `EnemyAIController` object and select the Create Blueprint class based
    on EnemyAIController option. Give it a name and click on the Create Blueprint
    Class button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, do the same thing for the `EnemyCharacter` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on your `MyEnemyCharacter` Blueprint and, under the Details tab,
    set the Enemy Behavior Tree property to EnemyBehaviorTree. Then, set the AI Controller Class
    property to `MyEnemyAIController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/553deaf5-094e-49be-850d-047a325d2958.png)'
  prefs: []
  type: TYPE_IMG
- en: Assigning the Enemy Behavior Tree and AI Controller Class properties
  prefs: []
  type: TYPE_NORMAL
- en: You'll likely want a visual component for the character as well, so from the
    Components tab, click on the Add Component button and select Cube. Afterward,
    modify the Scale to (`0.5, 0.5, 1.5`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we discussed previously, you may need to click on the Open Full Blueprint
    Editor text to see all of the available options.
  prefs: []
  type: TYPE_NORMAL
- en: '16\. Then, hit Compile and save all of your assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea359363-aa31-4d0b-b7d0-c8d67aab84e7.png)'
  prefs: []
  type: TYPE_IMG
- en: The completed enemy character
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we've set up a connection between an AI Character, an AI Controller,
    and a Behavior Tree!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AI Controller class we created will add both the Behavior Tree and the Blackboard
    that we created in the previous two recipes.
  prefs: []
  type: TYPE_NORMAL
- en: A Behavior Tree is connected to an AI Controller, which in turn is connected
    to a Character. We will control the behavior of `Character` through the Behavior
    Tree by entering Task and Service nodes in the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Behavior Tree hosts six different types of node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task**: Task nodes are the purple nodes in the Behavior Tree that contain
    Blueprint code to run. It''s something that the AI-controlled unit has to do (code-wise).
    Tasks must return either `true` or `false`, depending on whether the task succeeded
    or not (by providing a `FinishExecution()` node at the end).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Decorator**: A decorator is just a Boolean condition for the execution of
    a node. It checks a condition, and is typically used within a Selector or Sequence
    block.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Service**: This runs some Blueprint code when it ticks. The tick interval
    for these nodes is adjustable (it can run slower than a per-frame tick, for example,
    every 10 seconds). You can use these to query the scene for updates, a new opponent
    to chase, and so on. The Blackboard can be used to store queried information.
    Service nodes do not have a `FinishExecute()` call at the end of them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Selector**: This runs all subtrees from left to right until it encounters
    a success. When it encounters a success, the execution goes back up the tree.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sequence**: This runs all subtrees from left to right until it encounters
    a failure. When a failure is encountered, the execution goes back up the tree.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Simple Parallel**: This runs a single task (purple) in parallel with a subtree
    (gray).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a BTService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services attach to nodes in Behavior Trees and will execute at their defined
    frequency; that is, as long as their branch is being executed. Similar to Parallel
    nodes in other Behavior Tree systems, these are often used to make checks and
    to update the Blackboard, which we will use in this recipe to find our player
    object and assign it to our Blackboard.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finish the previous recipe, *Connecting a Behavior Tree to a Character*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the Content Browser, select Add New | New C++ Class. From the Choose Parent
    Class menu, check the Show All Classes option and look for the `BTService` class.
    Select it and then hit the Next button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a41289d-bab4-4f68-a540-4f354a5e08a8.png)'
  prefs: []
  type: TYPE_IMG
- en: At the next menu, set its name to `BTService_FindPlayer` and then click on the
    Create Class option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the `BTService_FindPlayer.h` file, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `BTService_FindPlayer.cpp` file, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Save your scripts and compile them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Content Browser, go to the `Content` folder where the `EnemyBehaviorTree`
    we created previously is located and double-click on it to open the Behavior Tree
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From there, drag a line from ROOT down and select Selector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02b17ca7-1f63-459e-812c-f631ef24d0e5.png)'
  prefs: []
  type: TYPE_IMG
- en: It's important to note that you need to drag from the darker gray rectangle
    on the bottom. If you try to drag from the middle of ROOT, you'll just move the
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the Selector node and select Add Service | FindPlayer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/36058d95-940d-494f-bcd3-9f1d70ff5617.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, drag and drop an instance of your `MyEnemyCharacter` object into your
    scene and run the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/538167bc-799d-4532-a475-eaa0eee25c53.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the value has been set!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Behavior Tree will continue to call the Selector as there are no other nodes
    for it to transition to.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a BTTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to Services, we also have Tasks, which are leaf nodes of Behavior
    Trees. These are the things that actually perform actions. In our example, we
    are going to have our AI follow our target, the player.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finish the previous recipe, *Creating a BTService*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the Content Browser, select Add New | New C++ Class. From the Choose Parent
    Class menu, check the Show All Classes option and look for the `BTTask_BlackboardBase` class.
    Select it and then hit the Next button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91d4a05e-cee6-4e79-bdc9-18e76094d6d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the next menu, set its name to `BTTask_MoveToPlayer` and then click on the Create
    Class option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00eb28d3-9f0c-4946-89f3-a726f8b2f435.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open Visual Studio and add the following function to `BTTask_MoveToPlayer.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the `BTTask_MoveToPlayer.cpp` file and update it to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Save your files and return to the Unreal Editor. Compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Content Browser, go to the `Content` folder where the `EnemyBehaviorTree` we
    created previously is located and double-click on it to open the Behavior Tree
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag this below the Selector node and select Tasks | Move to Player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/571d92a5-1006-40e6-b2a4-64a3d13b72fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Save the Behavior Tree and return to the Unreal Editor. Drag and drop a `MyEnemyCharacter` object
    into the scene if you haven''t done so already and play the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dcddb9f0-f8a7-4b70-b9c9-2088fd700a86.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our enemy is now following our player, which will happen for
    as long as the NavMesh covers the area!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe takes all of the materials we've covered so far and compiles them
    all together. The `ExecuteTask` method will be called as long as the BehaviorTree
    is inside this state. This function requires us to return an `EBTNodeResult`,
    which should return `Succeeded`, `Failed`, or `InProgress` to let the BehaviorTree
    know whether we can change states or not.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we first obtain the `EnemyController` and the `Target` objects
    so that we can figure out who we want to move and where we want to move to. As
    long as those properties are valid, we can call the `MoveToActor` function.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of other properties that the `MoveToActor` function offers that
    may be useful so that you can customize your movement. For more information, check
    out the following link: [https://api.unrealengine.com/INT/API/Runtime/AIModule/AAIController/MoveToActor/index.html](https://api.unrealengine.com/INT/API/Runtime/AIModule/AAIController/MoveToActor/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who are interested in exploring additional AI concepts with
    UE4, I highly suggest checking out Orfeas Eleftheriou's UE4 AI Tutorials: [https://orfeasel.com/category/ue_tuts/ai-programming/](https://orfeasel.com/category/ue_tuts/ai-programming/).
  prefs: []
  type: TYPE_NORMAL
