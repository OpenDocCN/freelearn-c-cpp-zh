["```cpp\nflash (rx) : ORIGIN = 0x08000000, LENGTH = 256K\nSRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 128K\nCCMSRAM(rwx) : ORIGIN = 0x10000000, LENGTH = 64K\n```", "```cpp\nvoid function(void)\n{\n   char buffer[200];\n   read_serial_buffer(buffer);\n}\n```", "```cpp\nmain.c: In function 'function':\nmain.c:15:6: warning: stack usage is 208 bytes [-Wstack-usage=]\n```", "```cpp\nMEMORY\n{\n  FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 1M\n  SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 128K\n  CCRAM(rwx) : ORIGIN = 0x10000000, LENGTH = 64K\n}\n```", "```cpp\n_stack_size = 16 * 1024;\n_stack_end = ORIGIN(CCRAM) + _stack_size;\n```", "```cpp\n__attribute__ ((section(\".isr_vector\")))\nvoid (* const IV[])(void) =\n{\n  (void (*)(void))(&_end_stack),\n  isr_reset, // Reset\n  isr_fault, // NMI\n  isr_fault, // HardFault\n  /* more interrupt routines follow */\n```", "```cpp\n_end_stack = ORIGIN(RAM) + LENGTH(RAM);\n```", "```cpp\nstatic unsigned int sp;\n```", "```cpp\nasm volatile(\"mrs %0, msp\" : \"=r\"(sp));\ndst = ((unsigned int *)(&_end_stack)) – (8192 / sizeof(unsigned int)); ;\nwhile (dst < sp) {\n   *dst = 0xDEADC0DE;\n   dst++;\n}\n```", "```cpp\nvoid *malloc(size_t size);\nvoid free(void *ptr);\n```", "```cpp\nvoid *realloc(void *ptr, size_t size);\n```", "```cpp\nstruct malloc_block {\n  unsigned int signature;\n  unsigned int size;\n};\n```", "```cpp\n#define SIGNATURE_IN_USE (0xAAC0FFEE)\n#define SIGNATURE_FREED (0xFEEDFACE)\n#define NULL (((void *)0))\n```", "```cpp\nvoid *malloc(unsigned int size)\n{\n  static unsigned int *end_heap = 0;\n  struct malloc_block *blk;\n  char *ret = NULL;\n  if (!end_heap) {\n    end_heap = &_start_heap;\n  }\n```", "```cpp\n if (((size >>2) << 2) != size)\n   size = ((size >> 2) + 1) << 2;\n```", "```cpp\n blk = (struct malloc_block *)&_start_heap;\n while (blk < end_heap) {\n   if ((blk->signature == SIGNATURE_FREED) &&\n        (blk->size >= size)) {\n     blk->signature = SIGNATURE_IN_USE;\n     ret = ((char *)blk) + sizeof(struct malloc_block);\n     return ret;\n   }\n   blk = ((char *)blk) + sizeof(struct malloc_block) +\n       blk->size;\n   }\n```", "```cpp\n   blk = (struct malloc_block *)end_heap;\n   blk->signature = SIGNATURE_IN_USE;\n   blk->size = size;\n   ret = ((char *)end_heap) + sizeof(struct malloc_block);\n   end_heap = ret + size;\n   return ret;\n }\n```", "```cpp\nvoid free(void *ptr)\n{\n  struct malloc_block *blk = (struct malloc_block *)\n        (((char *)ptr)-sizeof(struct malloc_block));\n  if (!ptr)\n    return;\n  if (blk->signature != SIGNATURE_IN_USE)\n    return;\n  blk->signature = SIGNATURE_FREED;\n}\n```", "```cpp\nvoid * _sbrk(unsigned int incr)\n{\n  static unsigned char *heap = NULL;\n  void *old_heap = heap;\n  if (((incr & 0x03) != incr)\n    incr = ((incr >> 2) + 1) << 2;\n  if (old_heap == NULL)\n    old_heap = heap = (unsigned char *)&_start_heap;\n  heap += incr;\n  return old_heap;\n}\n```", "```cpp\n_heap_end = ORIGIN(RAM) + LENGTH(RAM);\n```", "```cpp\nvoid * _sbrk(unsigned int incr) {\n  static unsigned char *heap = NULL;\n  void *old_heap = heap;\n  if (((incr & 0x03) != incr)\n    incr = ((incr >> 2) + 1) << 2;\n  if (old_heap == NULL)\n    old_heap = heap = (unsigned char *)&_start_heap;\n  if ((heap + incr) >= &_end_heap)\n    return (void *)(-1);\n  else\n    heap += incr;\n  return old_heap;\n}\n```", "```cpp\nPROVIDE(_start_pool0 = _end_bss);\nPROVIDE(_end_pool0 = _start_pool0 + 8KB);\nPROVIDE(_start_pool1 = _end_pool0);\nPROVIDE(_end_pool1 = _start_pool1 + 4KB);\n```", "```cpp\nstruct memory_pool {\n  void *start;\n  void *end;\n  void *cur;\n};\nstatic struct memory_pool mem_pool[2] = {\n  {\n    .start = &_start_pool0;\n    .end = &_end_pool0;\n  },\n  {\n    .start = &_start_pool1;\n    .end = &_end_pool1;\n  },\n};\n```", "```cpp\nvoid *mempool_alloc(int pool, unsigned int size)\n{\n  struct malloc_block *blk;\n  struct memory_pool *mp;\n  char *ret = NULL;\n  if (pool != 0 && pool != 1)\n    return NULL;\n  mp = mem_pool[pool];\n  if (!mp->cur)\n    mp->cur = mp->start;\n  if (((size >>2) << 2) != size)\n    size = ((size >> 2) + 1) << 2;\n  blk = (struct malloc_block *)mp->start;\n  while (blk < mp->cur) {\n    if ((blk->signature == SIGNATURE_FREED) &&\n          (blk->size >= size)) {\n      blk->signature = SIGNATURE_IN_USE;\n      ret = ((char *)blk) + sizeof(struct malloc_block);\n      return ret;\n    }\n    blk = ((char *)blk) + sizeof(struct malloc_block) +\n           blk->size;\n  }\n  blk = (struct malloc_block *)mp->cur;\n  if (mp->cur + size >= mp->end)\n    return NULL;\n  blk->signature = SIGNATURE_IN_USE;\n  blk->size = size;\n  ret = ((char *)mp->cur) + sizeof(struct malloc_block);\n  mp->cur = ret + size;\n  return ret;\n}\n```", "```cpp\nif (blk->signature != SIGNATURE_IN_USE) {\n  /* Double free detected! */\n  asm(\"BKPT #0\") ;\n  return;\n}\n```", "```cpp\n#define MPU_BASE 0xE000ED90\n#define MPU_TYPE (*(volatile uint32_t *)(MPU_BASE + 0x00))\n#define MPU_CTRL (*(volatile uint32_t *)(MPU_BASE + 0x04))\n#define MPU_RNR (*(volatile uint32_t *)(MPU_BASE + 0x08))\n#define MPU_RBAR (*(volatile uint32_t *)(MPU_BASE + 0x0c))\n#define MPU_RASR (*(volatile uint32_t *)(MPU_BASE + 0x10))\n```", "```cpp\n#define RASR_ENABLED (1)\n#define RASR_RW (1 << 24)\n#define RASR_RDONLY (5 << 24)\n#define RASR_NOACCESS (0 << 24)\n#define RASR_SCB (7 << 16)\n#define RASR_SB (5 << 16)\n#define RASR_NOEXEC (1 << 28)\n```", "```cpp\n#define MPUSIZE_1K (0x09 << 1)\n#define MPUSIZE_2K (0x0a << 1)\n#define MPUSIZE_4K (0x0b << 1)\n#define MPUSIZE_8K (0x0c << 1)\n#define MPUSIZE_16K (0x0d << 1)\n#define MPUSIZE_32K (0x0e << 1)\n#define MPUSIZE_64K (0x0f << 1)\n#define MPUSIZE_128K (0x10 << 1)\n#define MPUSIZE_256K (0x11 << 1)\n#define MPUSIZE_512K (0x12 << 1)\n#define MPUSIZE_1M (0x13 << 1)\n#define MPUSIZE_2M (0x14 << 1)\n#define MPUSIZE_4M (0x15 << 1)\n#define MPUSIZE_8M (0x16 << 1)\n#define MPUSIZE_16M (0x17 << 1)\n#define MPUSIZE_32M (0x18 << 1)\n#define MPUSIZE_64M (0x19 << 1)\n#define MPUSIZE_128M (0x1a << 1)\n#define MPUSIZE_256M (0x1b << 1)\n#define MPUSIZE_512M (0x1c << 1)\n#define MPUSIZE_1G (0x1d << 1)\n#define MPUSIZE_2G (0x1e << 1)\n#define MPUSIZE_4G (0x1f << 1)\n```", "```cpp\nint mpu_enable(void)\n{\n  volatile uint32_t type;\n  volatile uint32_t start;\n  volatile uint32_t attr;\n  type = MPU_TYPE;\n  if (type == 0) {\n    /* MPU not present! */\n    return -1;\n  }\n```", "```cpp\n  MPU_CTRL = 0;\n```", "```cpp\n  start = 0;\n  attr = RASR_ENABLED | MPUSIZE_256K | RASR_SCB |\n       RASR_RDONLY;\n  mpu_set_region(0, start, attr);\n```", "```cpp\n  start = 0x20000000;\n  attr = RASR_ENABLED | MPUSIZE_64K | RASR_SCB | RASR_RW \n      | RASR_NOEXEC;\n  mpu_set_region(1, start, attr);\n```", "```cpp\n  start = (uint32_t)(&_end_stack) - (STACK_SIZE + 1024);\n  attr = RASR_ENABLED | MPUSIZE_1K | RASR_SCB |\n  RASR_NOACCESS | RASR_NOEXEC;\n  mpu_set_region(2, start, attr);\n```", "```cpp\n  start = 0xE0000000;\n  attr = RASR_ENABLED | MPUSIZE_256M | RASR_SB\n  RASR_RW | RASR_NOEXEC;\n  mpu_set_region(3, start, attr);\n```", "```cpp\n  MPU_CTRL = 1;\n  return 0;\n}\n```", "```cpp\nstatic void mpu_set_region(int region, uint32_t start, uint32_t attr)\n{\n  MPU_RNR = region;\n  MPU_RBAR = start;\n  MPU_RNR = region;\n  MPU_RASR = attr;\n}\n```"]