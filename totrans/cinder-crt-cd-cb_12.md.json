["```cpp\n#include \"cinder/audio/Output.h\"\n#include \"cinder/audio/Callback.h\"\n#include \"cinder/Rand.h\"\n#include \"cinder/CinderMath.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    void audioCallback( uint64_t inSampleOffset, uint32_t ioSampleCount, audio::Buffer32f *buffer );\n    float mFrequency;\n    float mPhase, mPhaseAdd;\n    vector<float> mOutput;\n    ```", "```cpp\n    mFrequency = 0.0f;\n    mPhase = 0.0f;\n    mPhaseAdd = 0.0f;\n    audio::Output::play( audio::createCallback( this, &SineApp::audioCallback ) );\n    ```", "```cpp\n    float maxFrequency = 5000.0f;\n    float targetFrequency = ( getMousePos().y / (float)getWindowHeight() ) * maxFrequency;\n    mFrequency = math<float>::clamp( targetFrequency, 0.0f, maxFrequency );\n    ```", "```cpp\n    if( mOutput.size() != ioSampleCount ){\n     mOutput.resize( ioSampleCount );\n    }\n    int numChannels = buffer->mNumberChannels;\n    mPhaseAdd += ( ( mFrequency / 44100.0f ) - mPhaseAdd ) * 0.1f;\n    for( int i=0; i<ioSampleCount; i++ ){\n     mPhase += mPhaseAdd;\n     float output = math<float>::sin( mPhase * 2.0f * M_PI );\n     for( int j=0; j<numChannels; j++ ){\n      buffer->mData[ i*numChannels + j ] = output;\n     }\n     mOutput[i] = output;\n    }\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) );\n    if( mOutput.size() > 0 ){\n     Vec2f scale;\n     scale.x = (float)getWindowWidth() / (float)mOutput.size();\n     scale.y = 100.0f;\n     float centerY= getWindowHeight() / 2.0f;\n     gl::begin( GL_LINE_STRIP );\n     for( int i=0; i<mOutput.size(); i++ ){\n      float x = (float)i * scale.x;\n      float y = mOutput[i] * scale.y + centerY;\n      gl::vertex( x,  y );\n     } \n     gl::end();\n    }\n    ```", "```cpp\nmPhaseAdd += ( ( mFrequency / 44100.0f ) - mPhaseAdd ) * 0.1f;\n```", "```cpp\n    float mModFrequency;\n    float mModPhase, mModPhaseAdd;\n    ```", "```cpp\n    mModFrequency = 0.0f;\n    mModPhase = 0.0f;\n    mModPhaseAdd = 0.0f;\n    ```", "```cpp\n    float maxModFrequency= 30.0f;\n    float targetModFrequency= ( getMousePos().x / (float)getWindowWidth() ) * maxModFrequency;\n    mModFrequency = math<float>::clamp( targetModFrequency, 0.0f, maxModFrequency );\n    ```", "```cpp\n    if( mOutput.size() != ioSampleCount ){\n     mOutput.resize( ioSampleCount );\n    }\n    mPhaseAdd += ( ( mFrequency / 44100.0f ) - mPhaseAdd ) * 0.1f;\n    mModPhaseAdd += ( ( mModFrequency / 44100.0f ) - mModPhaseAdd )\n      * 0.1f;\n    int numChannels= buffer->mNumberChannels;\n    for( int i=0; i<ioSampleCount; i++ ){\n     mPhase += mPhaseAdd;\n     mModPhase += mModPhaseAdd;\n     float output = math<float>::sin( mPhase * 2.0f * M_PI ) \n       * math<float>::sin( mModPhase * 2.0f * M_PI );\n     for( int j=0; j<numChannels; j++ ){\n      buffer->mData[ i*numChannels + j ] = output;\n     }\n     mOutput[i] = output;\n    }\n    ```", "```cpp\n    int mDelay;\n    float mMix, mFeedback;\n    vector<float> mDelayLine;\n    int mDelayIndex;\n    int mDelaySize;\n    ```", "```cpp\n    mDelay = 200;\n    mMix = 0.2f;\n    mFeedback = 0.3f;\n    mDelaySize = mDelay * 44.1f;\n    for( int i=0; i<mDelaySize; i++ ){\n     mDelayLine.push_back( 0.0f );\n    }\n    ```", "```cpp\n    for( int i=0; i<ioSampleCount; i++ ){\n     float output = buffer->mData[ i*numChannels ];\n     int readIndex= mDelayIndex - mDelaySize + 1;\n     if( readIndex< 0 ) readIndex += mDelaySize;\n     float delay = mDelayLine[ readIndex * numChannels ];\n     mDelayLine[ mDelayIndex ] = output + delay * mFeedback;\n     if( ++mDelayIndex == mDelaySize ){\n      mDelayIndex = 0;\n     }\n     output = math<float>::clamp(output+mMix*delay,-1.0f,1.0f);\n     mOutput[i] = output;\n     for( int j=0; j<numChannels; j++ ){\n      buffer->mData[ i*numChannels + j ] = output;\n     } \n    }\n    ```", "```cpp\n    #include \"cinder/audio/Output.h\"\n    #include \"cinder/audio/Callback.h\"\n    #include \"cinder/Rand.h\"\n    #include \"cinder/CinderMath.h\"\n    #include \"ParticleSystem.h\"\n    ```", "```cpp\n    ParticleSystem mParticleSystem;\n    Vec2fattrPosition;\n    float attrFactor;\n    float attrRadius;\n    ```", "```cpp\n    bool    dragging;\n    Particle *dragParticle;\n    ```", "```cpp\n    void audioCallback( uint64_t inSampleOffset, uint32_t ioSampleCount,audio::Buffer32f *buffer );\n    float mSndFrequency;\n    float mPhase, mPhaseAdd;\n    vector<float> mOutput;\n    ```", "```cpp\n    mRunning= true;\n    dragging = false;\n    attrPosition = getWindowCenter();\n    attrRadius = 75.f;\n    attrFactor = 0.02f;\n    int numParticle= 10;\n    for( int i=0; i<numParticle; i++ ){\n     float x = Rand::randFloat( 0.0f, getWindowWidth() );\n     float y = Rand::randFloat( 0.0f, getWindowHeight() );\n     float radius = Rand::randFloat(2.f, 40.f);\n     Rand::randomize();\n     float mass = radius;\n     float drag = 0.95f;\n     Particle *particle = new Particle( Vec2f( x, y ), radius,\n      mass, drag );\n     mParticleSystem.addParticle( particle );\n    }\n    ```", "```cpp\n    mSndFrequency = 0.0f;\n    mPhase = 0.0f;\n    mPhaseAdd = 0.0f;\n    audio::Output::play( audio::createCallback( this, &MainApp::audioCallback ) );\n    ```", "```cpp\n    void MainApp::resize(ResizeEvent event)\n    {\n      attrPosition = getWindowCenter();\n    }\n    ```", "```cpp\n    void MainApp::mouseDown(MouseEvent event)\n    ```", "```cpp\n    {\n     dragging = false;\n     std::vector<Particle*>::iterator it;\n     for( it = mParticleSystem.particles.begin(); \n       it != mParticleSystem.particles.end(); ++it ) {\n      if( (*it)->position.distance(event.getPos()) \n        < (*it)->radius ) {\n       dragging = true;\n       dragParticle = (*it);\n      }\n     }\n    }\n\n    void MainApp::mouseUp(MouseEvent event) {\n     dragging = false;\n    }\n    ```", "```cpp\n    float maxFrequency = 15000.0f;\n    float targetFrequency = ( getMousePos().y / (float)getWindowHeight() ) * maxFrequency;\n    targetFrequency = mSndFrequency - 10000.f;\n    mSndFrequency = math<float>::clamp( targetFrequency, 0.0f, maxFrequency );\n    ```", "```cpp\n    std::vector<Particle*>::iterator it;\n    for( it = mParticleSystem.particles.begin(); \n      it != mParticleSystem.particles.end(); ++it ) {\n     std::vector<Particle*>::iterator it2;\n     for( it2 = mParticleSystem.particles.begin(); \n       it2 != mParticleSystem.particles.end(); ++it2 ) {\n      float d = (*it)->position.distance( (*it2)->position );\n      float d2 = (*it)->radius + (*it2)->radius;\n      if(d >0.f&& d <= d2 ) {\n       (*it)->forces += -1.1f * ( (*it2)->position \n         - (*it)->position );\n       (*it2)->forces += -1.1f * ( (*it)->position \n         - (*it2)->position );\n       mSndFrequency = 2000.f;\n       mSndFrequency+= 10000.f\n         * (1.f - ((*it)->radius / 40.f));\n       mSndFrequency+= 10000.f \n         * (1.f - ((*it2)->radius / 40.f));\n      }\n     }\n     Vec2f attrForce = attrPosition - (*it)->position;\n     attrForce *= attrFactor;\n     (*it)->forces += attrForce;\n    }\n    mSndFrequency = math<float>::clamp( mSndFrequency, \n     0.0f, maxFrequency );maxFrequency );\n    ```", "```cpp\n    if(dragging) {\n      dragParticle->forces = Vec2f::zero();\n      dragParticle->position = getMousePos();\n    }\n\n    mParticleSystem.update();\n    ```", "```cpp\n    gl::clear( Color::white() );\n    gl::setViewport(getWindowBounds());\n    gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );\n    gl::color( Color::black() );\n    mParticleSystem.draw();\n    ```", "```cpp\n    #include \"cinder/gl/gl.h\"\n    #include \"cinder/audio/Io.h\"\n    #include \"cinder/audio/Output.h\"\n    #include \"cinder/audio/FftProcessor.h\"\n    #include \"cinder/audio/PcmBuffer.h\"\n    ```", "```cpp\n    void drawFft();\n    audio::TrackRef mTrack;\n    audio::PcmBuffer32fRef mPcmBuffer;\n    uint16_t bandCount;\n    float levels[32];\n    float levelsPts[32];\n    ```", "```cpp\n    bandCount = 32;\n    std::fill(boost::begin(levels), boost::end(levels), 0.f);\n    std::fill(boost::begin(levelsPts), boost::end(levelsPts), 0.f);\n    mTrack = audio::Output::addTrack( audio::load( getAssetPath(\"music.mp3\").c_str() ) );\n    mTrack->enablePcmBuffering( true );\n    ```", "```cpp\n    mPcmBuffer = mTrack->getPcmBuffer();\n    for( int i = 0; i< ( bandCount ); i++ ) {\n      levels[i] = max(0.f, levels[i] - 1.f );\n      levelsPts[i] = max(0.f, levelsPts[i] - 0.95f );\n    }\n    ```", "```cpp\n    gl::enableAlphaBlending();\n    gl::clear( Color( 1.0f, 1.0f, 1.0f ) );\n    gl::color( Color::black() );\n    gl::pushMatrices();\n    gl::translate(getWindowCenter());\n    gl::rotate( getElapsedSeconds() * 10.f );\n    drawFft();\n    gl::popMatrices();\n    ```", "```cpp\n    float centerMargin= 25.0f;\n    if( !mPcmBuffer ) return;\n    std::shared_ptr<float> fftRef = audio::calculateFft( \n     mPcmBuffer->getChannelData( audio::CHANNEL_FRONT_LEFT ), \n     bandCount );\n    if( !fftRef ) {\n    return;\n    }\n    float *fftBuffer = fftRef.get();\n    gl::color( Color::black() );\n    gl::drawSolidCircle(Vec2f::zero(), 5.f);\n    glLineWidth(3.f);\n    float avgLvl= 0.f;\n    for( int i= 0; i<bandCount; i++ ) {\n      Vec2f p = Vec2f(0.f, 500.f);\n      p.rotate( 2.f * M_PI * (i/(float)bandCount) );\n      float lvl = fftBuffer[i] / bandCount * p.length();\n      lvl = min(lvl, p.length());\n      levels[i] = max(levels[i], lvl);\n      levelsPts[i] = max(levelsPts[i], levels[i]);\n      p.limit(1.f + centerMargin + levels[i]);\n      gl::drawLine(p.limited(centerMargin), p);\n      glPointSize(2.f);\n      glBegin(GL_POINTS);\n      gl::vertex(p+p.normalized()*levelsPts[i]);\n      glEnd();\n      glPointSize(1.f);\n      avgLvl += lvl;\n    }\n    avgLvl /= (float)bandCount;â€©glLineWidth(1.f);\n    gl::color( ColorA(0.f,0.f,0.f, 0.1f) );\n    gl::drawSolidCircle(Vec2f::zero(), 5.f+avgLvl);\n    ```", "```cpp\n    #include \"cinder/Rand.h\"\n    #include \"cinder/MayaCamUI.h\"\n    #include \"cinder/audio/Io.h\"\n    #include \"cinder/audio/Output.h\"\n    #include \"cinder/audio/FftProcessor.h\"\n    #include \"cinder/audio/PcmBuffer.h\"\n    #include \"ParticleSystem.h\"\n    ```", "```cpp\n    audio::TrackRef mTrack;\n    audio::PcmBuffer32fRef mPcmBuffer;\n    float beatForce;\n    float beatSensitivity;\n    float avgLvlOld;\n    float randAngle;\n    ```", "```cpp\n    ParticleSystem mParticleSystem;\n    Vec3f   attrPosition;\n    float attrFactor;\n    CameraPersp mCam;\n    ```", "```cpp\n    beatForce = 150.f;\n    beatSensitivity = 0.03f;\n    avgLvlOld = 0.f;\n    randAngle = 15.f;\n    attrPosition = Vec3f::zero();\n    attrFactor = 0.05f;\n    int numParticle = 450;\n    for( int i=0; i<numParticle; i++ ){\n     float x = Rand::randFloat( 0.0f, getWindowWidth() );\n     float y = Rand::randFloat( 0.0f, getWindowHeight() );\n     float z = Rand::randFloat( 0.0f, getWindowHeight() );\n     float radius = Rand::randFloat(2.f, 5.f);\n     float mass = radius;\n     if(i>300) {\n      radius = 1.f;\n      mass = 1.0f; \n     }\n     float drag = 0.95f;\n     Particle *particle = new Particle( Vec3f( x, y, z ), radius,\n      mass, drag );\n     mParticleSystem.addParticle( particle );\n    }\n    ```", "```cpp\n    mCam.setPerspective(45.0f, 640.f/480.f, 0.1, 10000);\n    mCam.setEyePoint(Vec3f(0.f,0.f,500.f));\n    mCam.setCenterOfInterestPoint(Vec3f::zero());\n    mTrack = audio::Output::addTrack( audio::load( getAssetPath(\"music.mp3\").c_str() ) );\n    mTrack->enablePcmBuffering( true );\n    ```", "```cpp\n    void MainApp::resize(ResizeEvent event)\n    {\n    mCam.setPerspective(45.0f, getWindowAspectRatio(), 0.1, 10000);\n    }\n    ```", "```cpp\n    float beatValue = 0.f;\n    mPcmBuffer = mTrack->getPcmBuffer();\n    if( mPcmBuffer ) {\n     int bandCount= 32;\n     std::shared_ptr<float> fftRef = audio::calculateFft( \n      mPcmBuffer->getChannelData( audio::CHANNEL_FRONT_LEFT ), \n      bandCount );\n     if( fftRef ) {\n      float * fftBuffer = fftRef.get();\n      float avgLvl= 0.f;\n      for( int i= 0; i<bandCount; i++ ) {\n       avgLvl += fftBuffer[i] / (float)bandCount;\n      }\n      avgLvl /= (float)bandCount;\n      if(avgLvl>avgLvlOld+beatSensitivity) {\n       beatValue = avgLvl - beatSensitivity;\n      }\n      avgLvlOld = avgLvl;\n     }\n    }\n    ```", "```cpp\n    std::vector<Particle*>::iterator it;\n    for( it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {\n        Vec3f attrForce = attrPosition - (*it)->position;\n    attrForce *= attrFactor;\n    if( attrPosition.distance( (*it)->position ) <100.f ) {\n      attrForce = (*it)->position - attrPosition;\n      attrForce *= 0.02f;\n        }\n        (*it)->forces += attrForce;\n        Vec3f bearForceVec = (*it)->position - attrPosition;\n        bearForceVec.normalize();\n        bearForceVec.rotate(randVec3f(), randAngle);\n        bearForceVec *= beatValue*randFloat(beatForce*0.5f, beatForce);\n        (*it)->forces += bearForceVec;\n        std::vector<Particle*>::iterator it2;\n        for( it2 = mParticleSystem.particles.begin(); it2 != mParticleSystem.particles.end(); ++it2 ) {\n            (*it)->forces +=  ( (*it)->position - (*it2)->position ) *0.5f * 0.0001f;\n        }\n    }\n    mParticleSystem.update();\n    ```", "```cpp\n    gl::enableAlphaBlending();\n    gl::clear( ColorA::white() );\n    gl::setViewport(getWindowBounds());\n    gl::setModelView(mCam);\n    float r = getElapsedSeconds()*10.f;\n    gl::rotate(Vec3f::one()*r);\n    mParticleSystem.draw();\n    ```", "```cpp\n    #include \"cinder/params/Params.h\"\n    ```", "```cpp\n    params::InterfaceGl    mParams;\n    ```", "```cpp\n    mParams = params::InterfaceGl( \"Parameters\", Vec2i( 200, 100 ) );\n    mParams.addParam( \"beatForce\", &beatForce, \"step=0.01\" );\n    mParams.addParam( \"beatSensitivity\", &beatSensitivity, \"step=0.01\" );\n    mParams.addParam( \"randAngle\", &randAngle, \"step=0.01\" );\n    ```", "```cpp\n    params::InterfaceGl::draw();\n    ```"]