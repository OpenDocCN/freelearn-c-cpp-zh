- en: Fun with Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the larger projects that we create will use one or more LEDs as indicators.
    These LEDs can indicate things such as power, receiving data, warnings or anything
    else that we may need visual feedback for. We have already seen how to use a basic,
    single-color LED but what if we need multiple LEDs or even multicolor LEDs? In
    this chapter, we will look at other ways to add LEDs to your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What NeoPixels are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How an RGB LED works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use NeoPixels in your projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use an RGB LED in your projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to use RGB LEDs and a **WS2812 40 RGB LED
    Pixel Arduino shield**. Let's start off by learning about the RGB LED.
  prefs: []
  type: TYPE_NORMAL
- en: A multicolor or RGB LED isn't really a single LED that can change color, it
    is actually three LEDs. An RGB LED contains three LEDs, which are red, green,
    and blue in color. The color that the LED produces is a combination of the colors
    produced by these three LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of RGB LEDs. These are the common anode and the common cathode
    LED. In a common cathode LED, the three LEDs share a common ground source, and
    in a common anode RGB LED, the three LEDs share a common power source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RGB LED has four pins, one for each color and the fourth one for the common
    cathode or anode connection. The following diagram shows the pins for both the
    common cathode and common anode RGB LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f9d2d26-bbc0-49f9-ad94-1566ff4478b3.png)'
  prefs: []
  type: TYPE_IMG
- en: To produce the various colors, we can adjust the intensities of the three different
    LEDs using the PWM pins on the Arduino. The light will then mix together, because
    the LEDs are so close, producing the color we want. Now let's look at what a WS2812
    integrated light source, or, as they are known on Adafruit's site, the **NeoPixel**.
    For most of this chapter, we will refer to the WS2812 integrated light source
    as a NeoPixel because it is shorter and also sounds cool.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, if we wanted to include 10 RGB LEDs in a project, where
    each LED required three input pins, the project would very quickly turn into a
    wired mess. Not to mention we would quickly run out of pins on the Arduino as
    well. One of the ways that we can solve this problem is to use the NeoPixel. The
    NeoPixel integrates red, green and blue LEDs alongside a driver chip on a tiny
    surface-mounted package. This package can be controlled through a single wire
    and can be used individually or as a group. NeoPixel's come in many form factors
    including strips, rings, Arduino shields and even on jewelry.
  prefs: []
  type: TYPE_NORMAL
- en: One nice thing about the NeoPixel is there is no inherent limit to the number
    of NeoPixels that can be chained together. However, there are some practical limits
    based on the RAM and power constraints of the controller you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using a NeoPixel shield. If you use individual
    NeoPixels, there are a couple of things you need to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Before connecting the NeoPixels to a power source, you will want to add a 1000
    microfarad, 6.3V or higher capacitor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will also want to add a 470 ohm resistor between the Arduino data output
    and the input line on the first NeoPixel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If at all possible, avoid connecting/disconnecting NeoPixels when the circuit
    is live. If you must connect them to a live circuit, always connect the ground
    first. If you must disconnect them from a live circuit, always disconnect the
    5V power first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NeoPixels should always be powered from a 5V power source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using the **Keyestudio 40 RGB LED 2812 Pixel Matrix
    shield**. This shield already contains the capacitor and resistor, so all we need
    to do is to place the shield on top of the Arduino Uno and we are good to go.
    The Keyestudio shield attaches to the Arduino as shown in the following photograph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37ad2196-1591-40d9-b5e6-a9298a8678d6.png)'
  prefs: []
  type: TYPE_IMG
- en: When using other NeoPixel form factors, always read the manufacturers' data
    sheet prior to connecting it to the Arduino. It is really easy to damage a NeoPixels
    so make sure you follow the manufacturers' recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Components needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need the following components for this chapter''s project:'
  prefs: []
  type: TYPE_NORMAL
- en: One Arduino Uno or compatible board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One RGB LED either a common cathode or a common anode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three 330 ohm resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One Keyestudio 40 RGB LED 2812 Pixel Matrix shield
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows how we would connect a common anode RGB LED to
    the Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da63fa99-99f0-45ca-89ac-9c5ea6863a23.png)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, we show how to connect a common anode RGB LED. We can see this
    because the common pin is connected to the power rail on the breadboard. If the
    RBG LED that you are using is a common cathode LED, then connect the common pin,
    on the LEDs, to the ground rail instead of the power rail. Each of the RGB pins
    is connected to the Arduino PWM pins with a 330 ohm resistor.
  prefs: []
  type: TYPE_NORMAL
- en: We are not showing a circuit diagram for the NeoPixel shield because we only
    need to attach the shield to the Arduino. Now let's look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start off by looking at the code for the RGB LED.
  prefs: []
  type: TYPE_NORMAL
- en: RGB LED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start off by defining which pins on the Arduino are connected to the
    RGB pins on the LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code shows that the red pin is connected to the Arduino 11 PWM pin, the
    blue pin is connected to the Arduino 10 PWM pin and the green pin is connected
    to the Arduino 9 PWM pin. We are going to define an empty macro that will let
    the application code know whether we have a common anode or a common cathode RGB
    LED. The following code will do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you are using a common cathode RGB LED, then comment or remove this line
    from your code. We will see how to use this when we look at the function that
    sets the colors of the LED. Now let's look at the `setup()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setup()` function will set the mode of the pins, that are connected to
    the RGB pins on the LED, to output. This will allow us to use the PWM pins to
    set the light intensity of the three-color LEDs that make up the RGB LED. Next,
    we will need to create a function that will set these colors. We will name this
    function `setColor()`, and it will take three parameters that will define the
    intensity of each RGB LED and contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code in this function starts off with a `#ifdef` statement. This statement
    says that if the `COMMON_ANODE` macro is defined, then execute the code between
    the `#ifdef` and the `#endif` statements; otherwise, skip that code. Therefore,
    if we define the `COMMON_ANODE` macro at the beginning of the code, then we subtract
    each parameter from `255` to get the correct intensity. We then use the `analogWrite()`
    function to write the values to the RGB pins.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we explained that an RGB LED worked by adjusting
    the intensity of each of the three RGB LEDs that are inside of the RGB LED. If
    we write the value of `255` to a common cathode LED, then the LED will be at its
    brightest. For a common anode LED, we will need to write a value of 0 to make
    the LED its brightest. That is why we subtracted the value of each parameter by
    `255` if the `COMMON_ANODE` macro is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `loop()` function, we loop through a couple colors to demonstrate how
    the LED displays different colors. The following shows the code for the `loop()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the `loop()` function, we call the `setColor()` function five times to change
    the LED's color. The colors that we display are red, green, blue, white and purple.
    Each time the color changes there will be a one-second pause before the next color
    is displayed. The pause is from the `delay()` function.
  prefs: []
  type: TYPE_NORMAL
- en: How we display the colors in an RGB LED is pretty similar to how we light a
    normal LED except that we define the light intensity (brightness) for the three
    colors. Now let's look at the code for the NeoPixel shield.
  prefs: []
  type: TYPE_NORMAL
- en: NeoPixel shield
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin coding, we will need to install the **Adafruit NeoPixel** library.
    The following screenshot shows the library that should be installed by the library
    manager. If you do not remember the steps to install a library, refer back to
    [Chapter 9](4334ea1c-5df5-4be7-a7c1-86592cb3aaa6.xhtml), *Environment Sensors*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be910d93-d7d8-46d7-9f51-78daf098172e.png)'
  prefs: []
  type: TYPE_IMG
- en: Sensors where we install the library for the DHT11 temperature and humidity
    sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the library is installed, we will need to include it by putting the following
    line at the top of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the Adafruit NeoPixel library, we need to tell it what pin the
    NeoPixels are connected to and how many NeoPixels are attached. Therefore, we
    will define macros that contain these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the datasheet for the Keyestudio shield, the shield is connected
    to pin 13 on the Arduino, and the shield contains 40 NeoPixels; therefore, we
    define those values in the macros. We will now use these values to initiate an
    instance of the `Adafruit_NeoPixel` class as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the number of pixels in the shield and the second parameter
    is the pin that the NeoPixels are connected to. The last parameter is the pixel
    type flag. The values shown in this example are by far the most common. The following
    are the possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NEO_KHZ800`: 800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NEO_KHZ400`: 400 KHz (classic v1 (not v2) FLORA pixels, WS2811 drivers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NEO_GRB`: Pixels are wired for GRB bitstream (most NeoPixel products)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NEO_RGB`: Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we will be turning each pixel, one by one, to a certain color.
    Therefore, we will need a global variable to point to the pixel we are on and
    another global variable to define what color to use. We will be using two colors
    in this example and swap between the two. The following code defines this global
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `setup()` function, we will need to initiate the NeoPixels. The following
    code shows the `setup()` function with the code to initiate the NeoPixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `begin()` function prepares the data pin, on the Arduino, for output to
    the NeoPixels. The `show()` function pushes the data out to the NeoPixels and
    isn't absolutely necessary here; I find that it is good practice to include the
    function anytime we write anything to the NeoPixels for thoroughness. The third
    function controls the brightness of the pixels. I usually set this to 50% because
    the NeoPixels are very bright.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the `loop()` function that will set each pixel to a color
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the `loop()` function, we start off by increasing the `num` variable by one
    and then checking to see whether we have reached the last pixel. If we have reached
    the last pixel, we set the `num` variable back to zero and swap the `color` variable.
    In the line `color = !color`, the `!`Â operator is the NOT operator, which causes
    the `color` variable to switch between true and false. This works because the
    NOT operator returns the opposite of the current value of the `color` variable.
    Therefore if, as an example, the `color` variable was currently false, then the
    `!color` operation would return true.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then use the `setPixelColor()` function to set the current pixel to one
    of two colors depending on whether the `color` variable is true or false. The
    `setPixelColor()` function comes in two versions. The version that we see here
    uses the first parameter as the pixel number that we are setting and then the
    next three numbers define the intensity of the red, green and blue colors that
    make up the color we want. If we were using an RGBW NeoPixel, we would also need
    to define the white color. Therefore, this function would add an additional parameter
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way to call the `setPixelColor()` function is to pass two arguments
    where the first one is the pixel number and the second is a 32-bit number that
    combines the red, green and blue values. This version of the function looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The color value can range from 0 to 16,777,216.
  prefs: []
  type: TYPE_NORMAL
- en: After we set the pixel's color, we then call the `show()` function to push the
    values out to the pixels and then use the delay function to put in a half-second
    pause in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Running the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we run the sketch for the RBG LED, we would see the LED slowly cycle between
    the five colors. The code for the NeoPixels will flip the pixels, one by one,
    between two colors.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will be one of the hardest challenges in the book. The Keyestudio NeoPixel
    shield has eight columns of pixels where each column contains five pixels where
    the pixels are numbered like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0bdca92-c921-4780-848e-fd36259f20f3.png)'
  prefs: []
  type: TYPE_IMG
- en: For the challenge, set each column to a different color and have the colors
    rotate from left to right across the shield. Here are a couple of hints to get
    you started. The first is the Adafruit NeoPixel library, which has a function
    named `Color()` that will return the 32-bit color based on the three red, green
    and blue values. Therefore, you can use the following code to convert an 8-bit
    number to the 32-bit color.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then use the following code, which will set all of the pixels in a
    column to their color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `tmpColorMode` variable is a number from 1 to 8 that will be used to pick
    the color for that column. That should give you the basics to start this challenge.
    The answer is in the downloadable code for the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how RGB LEDs work, how to use them and looked at
    the differences between a common anode and common cathode RGB LED. We also learned
    how the WS2812 (NeoPixel) works and how to use it. NeoPixels come in many different
    form factors and can be used almost anywhere that you need a large number of RGB
    LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to use a small buzzer with the Arduino
    to produce sound.
  prefs: []
  type: TYPE_NORMAL
