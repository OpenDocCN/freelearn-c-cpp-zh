- en: Fun with Lights
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转灯光
- en: Most of the larger projects that we create will use one or more LEDs as indicators.
    These LEDs can indicate things such as power, receiving data, warnings or anything
    else that we may need visual feedback for. We have already seen how to use a basic,
    single-color LED but what if we need multiple LEDs or even multicolor LEDs? In
    this chapter, we will look at other ways to add LEDs to your project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的大部分大型项目将使用一个或多个LED作为指示器。这些LED可以指示诸如电源、接收数据、警告或任何我们需要视觉反馈的其他事物。我们已经看到了如何使用基本的单色LED，但如果我们需要多个LED或甚至多色LED怎么办？在本章中，我们将探讨其他将LED添加到项目中的方法。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: What NeoPixels are
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是NeoPixel
- en: How an RGB LED works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB LED的工作原理
- en: How to use NeoPixels in your projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在项目中使用NeoPixel
- en: How to use an RGB LED in your projects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在项目中使用RGB LED
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will look at how to use RGB LEDs and a **WS2812 40 RGB LED
    Pixel Arduino shield**. Let's start off by learning about the RGB LED.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用RGB LED和**WS2812 40 RGB LED Pixel Arduino屏蔽板**。让我们先了解一下RGB LED。
- en: A multicolor or RGB LED isn't really a single LED that can change color, it
    is actually three LEDs. An RGB LED contains three LEDs, which are red, green,
    and blue in color. The color that the LED produces is a combination of the colors
    produced by these three LEDs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 多色或RGB LED实际上并不是一个可以改变颜色的单个LED，它实际上是三个LED。RGB LED包含三个LED，分别是红色、绿色和蓝色。LED产生的颜色是这三个LED产生的颜色的组合。
- en: There are two types of RGB LEDs. These are the common anode and the common cathode
    LED. In a common cathode LED, the three LEDs share a common ground source, and
    in a common anode RGB LED, the three LEDs share a common power source.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED有两种类型。这些是公共阳极和公共阴极LED。在公共阴极RGB LED中，三个LED共享一个公共接地源，而在公共阳极RGB LED中，三个LED共享一个公共电源源。
- en: 'The RGB LED has four pins, one for each color and the fourth one for the common
    cathode or anode connection. The following diagram shows the pins for both the
    common cathode and common anode RGB LED:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED有四个引脚，每个颜色一个，第四个用于公共阴极或阳极连接。以下图示显示了公共阴极和公共阳极RGB LED的引脚：
- en: '![](img/2f9d2d26-bbc0-49f9-ad94-1566ff4478b3.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f9d2d26-bbc0-49f9-ad94-1566ff4478b3.png)'
- en: To produce the various colors, we can adjust the intensities of the three different
    LEDs using the PWM pins on the Arduino. The light will then mix together, because
    the LEDs are so close, producing the color we want. Now let's look at what a WS2812
    integrated light source, or, as they are known on Adafruit's site, the **NeoPixel**.
    For most of this chapter, we will refer to the WS2812 integrated light source
    as a NeoPixel because it is shorter and also sounds cool.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要产生各种颜色，我们可以通过Arduino上的PWM引脚调整三个不同LED的强度。由于LED非常靠近，光线会混合在一起，从而产生我们想要的颜色。现在让我们看看WS2812集成光源，或者，如它们在Adafruit网站上所知，称为**NeoPixel**。在本章的大部分内容中，我们将把WS2812集成光源称为NeoPixel，因为它更简洁，听起来也更酷。
- en: As you can imagine, if we wanted to include 10 RGB LEDs in a project, where
    each LED required three input pins, the project would very quickly turn into a
    wired mess. Not to mention we would quickly run out of pins on the Arduino as
    well. One of the ways that we can solve this problem is to use the NeoPixel. The
    NeoPixel integrates red, green and blue LEDs alongside a driver chip on a tiny
    surface-mounted package. This package can be controlled through a single wire
    and can be used individually or as a group. NeoPixel's come in many form factors
    including strips, rings, Arduino shields and even on jewelry.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，如果我们想在项目中包含10个RGB LED，每个LED需要三个输入引脚，项目会很快变成一团糟。更不用说Arduino上的引脚也会很快用完。我们可以解决这个问题的方法之一是使用NeoPixel。NeoPixel将红色、绿色和蓝色LED以及驱动芯片集成在一个微型表面贴装组件上。这个组件可以通过一根线控制，可以单独使用或作为一组使用。NeoPixel有多种形式，包括条带、环形、Arduino屏蔽板，甚至珠宝。
- en: One nice thing about the NeoPixel is there is no inherent limit to the number
    of NeoPixels that can be chained together. However, there are some practical limits
    based on the RAM and power constraints of the controller you are using.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: NeoPixel的一个优点是，没有固有的限制可以连接多少个NeoPixel。然而，根据你使用的控制器的RAM和电源限制，有一些实际限制。
- en: 'In this chapter, we will be using a NeoPixel shield. If you use individual
    NeoPixels, there are a couple of things you need to keep in mind:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用NeoPixel屏蔽板。如果你使用单个NeoPixel，有几件事你需要记住：
- en: Before connecting the NeoPixels to a power source, you will want to add a 1000
    microfarad, 6.3V or higher capacitor.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将NeoPixels连接到电源之前，您可能需要添加一个1000微法拉、6.3V或更高电压的电容。
- en: You will also want to add a 470 ohm resistor between the Arduino data output
    and the input line on the first NeoPixel.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还希望在Arduino数据输出和第一个NeoPixel的输入线之间添加一个470欧姆电阻。
- en: If at all possible, avoid connecting/disconnecting NeoPixels when the circuit
    is live. If you must connect them to a live circuit, always connect the ground
    first. If you must disconnect them from a live circuit, always disconnect the
    5V power first.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，在电路通电时避免连接/断开NeoPixels。如果必须将它们连接到通电电路，请始终先连接地线。如果必须从通电电路中断开它们，请始终先断开5V电源。
- en: NeoPixels should always be powered from a 5V power source.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NeoPixels应始终从5V电源供电。
- en: 'In this chapter, we will be using the **Keyestudio 40 RGB LED 2812 Pixel Matrix
    shield**. This shield already contains the capacitor and resistor, so all we need
    to do is to place the shield on top of the Arduino Uno and we are good to go.
    The Keyestudio shield attaches to the Arduino as shown in the following photograph:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**Keyestudio 40 RGB LED 2812像素矩阵盾**。这个盾已经包含了电容器和电阻，所以我们只需要将盾放置在Arduino
    Uno的顶部，就可以开始了。Keyestudio盾与Arduino的连接方式如图所示：
- en: '![](img/37ad2196-1591-40d9-b5e6-a9298a8678d6.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37ad2196-1591-40d9-b5e6-a9298a8678d6.png)'
- en: When using other NeoPixel form factors, always read the manufacturers' data
    sheet prior to connecting it to the Arduino. It is really easy to damage a NeoPixels
    so make sure you follow the manufacturers' recommendations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用其他NeoPixel形式时，在将其连接到Arduino之前，请务必阅读制造商的数据表。损坏NeoPixels很容易，所以请确保遵循制造商的建议。
- en: Components needed
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要的组件
- en: 'We will need the following components for this chapter''s project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下组件来完成本章的项目：
- en: One Arduino Uno or compatible board
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Arduino Uno或兼容板
- en: One RGB LED either a common cathode or a common anode
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个RGB LED，要么是常见的阳极，要么是常见的阴极
- en: Three 330 ohm resistors
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个330欧姆电阻
- en: One Keyestudio 40 RGB LED 2812 Pixel Matrix shield
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Keyestudio 40 RGB LED 2812像素矩阵盾
- en: Jumper wires
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: One breadboard
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块面包板
- en: Circuit diagrams
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电路图
- en: 'The following diagram shows how we would connect a common anode RGB LED to
    the Arduino:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了我们如何将一个常见的阳极RGB LED连接到Arduino：
- en: '![](img/da63fa99-99f0-45ca-89ac-9c5ea6863a23.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da63fa99-99f0-45ca-89ac-9c5ea6863a23.png)'
- en: In this diagram, we show how to connect a common anode RGB LED. We can see this
    because the common pin is connected to the power rail on the breadboard. If the
    RBG LED that you are using is a common cathode LED, then connect the common pin,
    on the LEDs, to the ground rail instead of the power rail. Each of the RGB pins
    is connected to the Arduino PWM pins with a 330 ohm resistor.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，我们展示了如何连接一个常见的阳极RGB LED。我们可以看到这一点，因为公共引脚连接到面包板上的电源轨。如果您使用的RGB LED是常见的阴极LED，那么请将LED上的公共引脚连接到地轨而不是电源轨。每个RGB引脚都通过一个330欧姆电阻连接到Arduino的PWM引脚。
- en: We are not showing a circuit diagram for the NeoPixel shield because we only
    need to attach the shield to the Arduino. Now let's look at the code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有展示NeoPixel盾的电路图，因为我们只需要将盾连接到Arduino。现在让我们看看代码。
- en: Code
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: Let's start off by looking at the code for the RGB LED.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看RGB LED的代码开始。
- en: RGB LED
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RGB LED
- en: 'We will start off by defining which pins on the Arduino are connected to the
    RGB pins on the LED:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义Arduino上的哪些引脚连接到LED的RGB引脚：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code shows that the red pin is connected to the Arduino 11 PWM pin, the
    blue pin is connected to the Arduino 10 PWM pin and the green pin is connected
    to the Arduino 9 PWM pin. We are going to define an empty macro that will let
    the application code know whether we have a common anode or a common cathode RGB
    LED. The following code will do that:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码显示红色引脚连接到Arduino 11 PWM引脚，蓝色引脚连接到Arduino 10 PWM引脚，绿色引脚连接到Arduino 9 PWM引脚。我们将定义一个空宏，让应用程序代码知道我们是否有常见的阳极或阴极RGB
    LED。以下代码将做到这一点：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are using a common cathode RGB LED, then comment or remove this line
    from your code. We will see how to use this when we look at the function that
    sets the colors of the LED. Now let's look at the `setup()` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是常见的阴极RGB LED，那么请注释或删除此行代码。当我们查看设置LED颜色的函数时，我们将看到如何使用它。现在让我们看看`setup()`函数。
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `setup()` function will set the mode of the pins, that are connected to
    the RGB pins on the LED, to output. This will allow us to use the PWM pins to
    set the light intensity of the three-color LEDs that make up the RGB LED. Next,
    we will need to create a function that will set these colors. We will name this
    function `setColor()`, and it will take three parameters that will define the
    intensity of each RGB LED and contain the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()` 函数将设置连接到 LED 上 RGB 引脚的引脚模式为输出。这将允许我们使用 PWM 引脚来设置组成 RGB LED 的三个颜色
    LED 的光强度。接下来，我们需要创建一个设置这些颜色的函数。我们将把这个函数命名为 `setColor()`，它将接受三个参数，这些参数将定义每个 RGB
    LED 的强度，并包含以下代码：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code in this function starts off with a `#ifdef` statement. This statement
    says that if the `COMMON_ANODE` macro is defined, then execute the code between
    the `#ifdef` and the `#endif` statements; otherwise, skip that code. Therefore,
    if we define the `COMMON_ANODE` macro at the beginning of the code, then we subtract
    each parameter from `255` to get the correct intensity. We then use the `analogWrite()`
    function to write the values to the RGB pins.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中的代码从 `#ifdef` 语句开始。这个语句表示如果定义了 `COMMON_ANODE` 宏，则执行 `#ifdef` 和 `#endif`
    语句之间的代码；否则，跳过该代码。因此，如果我们定义 `COMMON_ANODE` 宏在代码的开头，那么我们将每个参数从 `255` 减去以获得正确的强度。然后我们使用
    `analogWrite()` 函数将值写入 RGB 引脚。
- en: At the beginning of this chapter, we explained that an RGB LED worked by adjusting
    the intensity of each of the three RGB LEDs that are inside of the RGB LED. If
    we write the value of `255` to a common cathode LED, then the LED will be at its
    brightest. For a common anode LED, we will need to write a value of 0 to make
    the LED its brightest. That is why we subtracted the value of each parameter by
    `255` if the `COMMON_ANODE` macro is defined.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章的开头，我们解释了 RGB LED 的工作原理是通过调整 RGB LED 内部三个 RGB LED 的强度。如果我们向一个共阴极 LED 写入
    `255` 的值，那么 LED 将达到最亮。对于一个共阳极 LED，我们需要写入 `0` 的值来使 LED 最亮。这就是为什么如果定义了 `COMMON_ANODE`
    宏，我们就从每个参数的值中减去 `255`。 '
- en: 'In the `loop()` function, we loop through a couple colors to demonstrate how
    the LED displays different colors. The following shows the code for the `loop()`
    function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loop()` 函数中，我们循环通过几种颜色来演示 LED 如何显示不同的颜色。以下显示了 `loop()` 函数的代码：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `loop()` function, we call the `setColor()` function five times to change
    the LED's color. The colors that we display are red, green, blue, white and purple.
    Each time the color changes there will be a one-second pause before the next color
    is displayed. The pause is from the `delay()` function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loop()` 函数中，我们调用 `setColor()` 函数五次来改变 LED 的颜色。我们显示的颜色有红色、绿色、蓝色、白色和紫色。每次颜色改变后，在显示下一个颜色之前会有一个一秒的暂停。这个暂停是由
    `delay()` 函数实现的。
- en: How we display the colors in an RGB LED is pretty similar to how we light a
    normal LED except that we define the light intensity (brightness) for the three
    colors. Now let's look at the code for the NeoPixel shield.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 RGB LED 中显示颜色的方式与点亮一个普通 LED 的方式非常相似，只是我们为三种颜色定义了光强度（亮度）。现在让我们看看 NeoPixel
    面板的代码。
- en: NeoPixel shield
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NeoPixel 面板
- en: 'Before we begin coding, we will need to install the **Adafruit NeoPixel** library.
    The following screenshot shows the library that should be installed by the library
    manager. If you do not remember the steps to install a library, refer back to
    [Chapter 9](4334ea1c-5df5-4be7-a7c1-86592cb3aaa6.xhtml), *Environment Sensors*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我们需要安装 **Adafruit NeoPixel** 库。以下截图显示了应该通过库管理器安装的库。如果你不记得安装库的步骤，请参阅第
    9 章 *环境传感器*：
- en: '![](img/be910d93-d7d8-46d7-9f51-78daf098172e.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be910d93-d7d8-46d7-9f51-78daf098172e.png)'
- en: Sensors where we install the library for the DHT11 temperature and humidity
    sensor.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装 DHT11 温湿传感器的库的传感器位置。
- en: 'Once the library is installed, we will need to include it by putting the following
    line at the top of our code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了库，我们需要在代码顶部添加以下行来包含它：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we use the Adafruit NeoPixel library, we need to tell it what pin the
    NeoPixels are connected to and how many NeoPixels are attached. Therefore, we
    will define macros that contain these values:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Adafruit NeoPixel 库时，我们需要告诉它 NeoPixel 连接到哪个引脚以及连接了多少个 NeoPixel。因此，我们将定义包含这些值的宏：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'According to the datasheet for the Keyestudio shield, the shield is connected
    to pin 13 on the Arduino, and the shield contains 40 NeoPixels; therefore, we
    define those values in the macros. We will now use these values to initiate an
    instance of the `Adafruit_NeoPixel` class as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Keyestudio盾牌的数据表，盾牌连接到Arduino的13号引脚，盾牌包含40个NeoPixels；因此，我们在宏中定义这些值。现在我们将使用这些值来初始化`Adafruit_NeoPixel`类的一个实例，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first parameter is the number of pixels in the shield and the second parameter
    is the pin that the NeoPixels are connected to. The last parameter is the pixel
    type flag. The values shown in this example are by far the most common. The following
    are the possible values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是盾牌上的像素数量，第二个参数是NeoPixels连接的引脚。最后一个参数是像素类型标志。本例中显示的值是最常见的。以下是一些可能的值：
- en: '`NEO_KHZ800`: 800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEO_KHZ800`: 800 KHz比特流（大多数NeoPixel产品带有WS2812 LED）'
- en: '`NEO_KHZ400`: 400 KHz (classic v1 (not v2) FLORA pixels, WS2811 drivers)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEO_KHZ400`: 400 KHz (经典v1（非v2）FLORA像素，WS2811驱动器)'
- en: '`NEO_GRB`: Pixels are wired for GRB bitstream (most NeoPixel products)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEO_GRB`: 像素以GRB比特流连接（大多数NeoPixel产品）'
- en: '`NEO_RGB`: Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEO_RGB`: 像素以RGB比特流连接（v1 FLORA像素，非v2）'
- en: 'In this example, we will be turning each pixel, one by one, to a certain color.
    Therefore, we will need a global variable to point to the pixel we are on and
    another global variable to define what color to use. We will be using two colors
    in this example and swap between the two. The following code defines this global
    variable:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将逐个将每个像素转换为特定的颜色。因此，我们需要一个全局变量来指向我们所在的像素，另一个全局变量来定义要使用的颜色。在这个例子中，我们将使用两种颜色并在两者之间切换。以下代码定义了这个全局变量：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `setup()` function, we will need to initiate the NeoPixels. The following
    code shows the `setup()` function with the code to initiate the NeoPixels:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，我们需要初始化NeoPixels。以下代码展示了包含初始化NeoPixels代码的`setup()`函数：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `begin()` function prepares the data pin, on the Arduino, for output to
    the NeoPixels. The `show()` function pushes the data out to the NeoPixels and
    isn't absolutely necessary here; I find that it is good practice to include the
    function anytime we write anything to the NeoPixels for thoroughness. The third
    function controls the brightness of the pixels. I usually set this to 50% because
    the NeoPixels are very bright.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin()`函数准备Arduino上的数据引脚，以便输出到NeoPixels。`show()`函数将数据推送到NeoPixels，在这里并不是绝对必要的；我发现，无论何时我们向NeoPixels写入任何内容，都包括这个函数是一种好的做法。第三个函数控制像素的亮度。我通常将其设置为50%，因为NeoPixels非常亮。'
- en: Now let's look at the `loop()` function that will set each pixel to a color
    one by one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看将每个像素逐个设置为颜色的`loop()`函数。
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `loop()` function, we start off by increasing the `num` variable by one
    and then checking to see whether we have reached the last pixel. If we have reached
    the last pixel, we set the `num` variable back to zero and swap the `color` variable.
    In the line `color = !color`, the `!` operator is the NOT operator, which causes
    the `color` variable to switch between true and false. This works because the
    NOT operator returns the opposite of the current value of the `color` variable.
    Therefore if, as an example, the `color` variable was currently false, then the
    `!color` operation would return true.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop()`函数中，我们首先将`num`变量增加一，然后检查是否到达了最后一个像素。如果我们到达了最后一个像素，我们将`num`变量重置为零，并交换`color`变量。在`color
    = !color`这一行中，`!`运算符是NOT运算符，它使得`color`变量在true和false之间切换。这是因为NOT运算符返回`color`变量当前值的相反数。因此，如果以`color`变量当前为false为例，那么`!color`操作将返回true。
- en: 'We then use the `setPixelColor()` function to set the current pixel to one
    of two colors depending on whether the `color` variable is true or false. The
    `setPixelColor()` function comes in two versions. The version that we see here
    uses the first parameter as the pixel number that we are setting and then the
    next three numbers define the intensity of the red, green and blue colors that
    make up the color we want. If we were using an RGBW NeoPixel, we would also need
    to define the white color. Therefore, this function would add an additional parameter
    like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`setPixelColor()`函数将当前像素设置为两种颜色之一，这取决于`color`变量是true还是false。`setPixelColor()`函数有两种版本。我们在这里看到的版本使用第一个参数作为我们设置的像素编号，然后接下来的三个数字定义了组成我们想要的颜色的红色、绿色和蓝色强度的值。如果我们使用RGBW
    NeoPixel，我们还需要定义白色颜色。因此，这个函数将添加一个额外的参数，如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The second way to call the `setPixelColor()` function is to pass two arguments
    where the first one is the pixel number and the second is a 32-bit number that
    combines the red, green and blue values. This version of the function looks like
    this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`setPixelColor()`函数的第二种方式是传递两个参数，其中第一个参数是像素编号，第二个参数是一个32位数字，它结合了红色、绿色和蓝色值。这个版本的函数看起来像这样：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The color value can range from 0 to 16,777,216.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色值可以从0到16,777,216。
- en: After we set the pixel's color, we then call the `show()` function to push the
    values out to the pixels and then use the delay function to put in a half-second
    pause in the code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置像素颜色后，我们接着调用`show()`函数将值推送到像素，然后使用延时函数在代码中插入半秒的暂停。
- en: Running the project
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行项目
- en: If we run the sketch for the RBG LED, we would see the LED slowly cycle between
    the five colors. The code for the NeoPixels will flip the pixels, one by one,
    between two colors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行RGB LED的草图，我们会看到LED缓慢地在五种颜色之间循环。NeoPixel的代码将逐个翻转像素，在两种颜色之间切换。
- en: Challenge
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: 'This will be one of the hardest challenges in the book. The Keyestudio NeoPixel
    shield has eight columns of pixels where each column contains five pixels where
    the pixels are numbered like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是书中最难的挑战之一。Keyestudio NeoPixel盾牌有八列像素，每列包含五个像素，像素的编号如下：
- en: '![](img/c0bdca92-c921-4780-848e-fd36259f20f3.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0bdca92-c921-4780-848e-fd36259f20f3.png)'
- en: For the challenge, set each column to a different color and have the colors
    rotate from left to right across the shield. Here are a couple of hints to get
    you started. The first is the Adafruit NeoPixel library, which has a function
    named `Color()` that will return the 32-bit color based on the three red, green
    and blue values. Therefore, you can use the following code to convert an 8-bit
    number to the 32-bit color.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个挑战，将每一列设置为不同的颜色，并让颜色从左到右在盾牌上旋转。以下是一些帮助你开始的提示。第一个是Adafruit NeoPixel库，它有一个名为`Color()`的函数，可以根据三个红色、绿色和蓝色值返回32位颜色。因此，你可以使用以下代码将8位数字转换为32位颜色。
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We could then use the following code, which will set all of the pixels in a
    column to their color:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码，该代码将列中的所有像素设置为它们的颜色：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `tmpColorMode` variable is a number from 1 to 8 that will be used to pick
    the color for that column. That should give you the basics to start this challenge.
    The answer is in the downloadable code for the book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpColorMode`变量是一个从1到8的数字，将用于选择该列的颜色。这应该为你开始这个挑战提供了基础知识。答案可以在本书的可下载代码中找到。'
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how RGB LEDs work, how to use them and looked at
    the differences between a common anode and common cathode RGB LED. We also learned
    how the WS2812 (NeoPixel) works and how to use it. NeoPixels come in many different
    form factors and can be used almost anywhere that you need a large number of RGB
    LEDs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了RGB LED的工作原理，如何使用它们，并探讨了共阳极和共阴极RGB LED之间的区别。我们还学习了WS2812（NeoPixel）的工作原理以及如何使用它。NeoPixel有多种不同的形式，几乎可以用于需要大量RGB
    LED的任何地方。
- en: In the next chapter, we will look at how to use a small buzzer with the Arduino
    to produce sound.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用Arduino和一个小蜂鸣器来产生声音。
