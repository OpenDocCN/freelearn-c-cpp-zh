- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Super-Loop with Sequencer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Super-loop** is the basic software architecture of bare-metal firmware. It
    is an infinite loop that executes tasks (functions) often conditioned by flags
    set in an **Interrupt Service Routine** (**ISR**). As the complexity of business
    logic increases, so does the size of a super loop, which can quickly turn into
    a spaghetti mess. To solve this problem within bare-metal constraints (no operating
    system), we can use a sequencer.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A **sequencer** stores and executes tasks (functions) in an organized fashion.
    Instead of setting a flag in an ISR, checking it in a super loop, and executing
    a function if a flag is set, we simply add a task to a sequencer from the ISR.
    The super loop then runs the sequencer, which executes the added tasks. Tasks
    in the sequencer can be prioritized, so the sequencer will execute higher-priority
    tasks first.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover sequencer design and implementation through
    the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Super-loop and motivation for a sequencer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a sequencer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing a callable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a sequencer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples from this chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter14](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter14)).
    To get the most out of this chapter, run the examples in the Renode simulator.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Super-loop and motivation for a sequencer
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get into the design and implementation of a sequencer, we will first
    analyze the limitations of a super loop. In a usual super-loop scenario, we check
    flags that are set from an ISR. Below is an example pseudocode of a super loop:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding pseudocode, we perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Check the Boolean flag `data_read_ready` and, if it is set, we execute the function
    `sensor_data_read_and_buffer`. We then reset the `data_read_ready` flag.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Boolean flag `data_send_timeout` and, if it is set, we execute the
    function `data_send_from_buffer`. We then reset the `data_send_timeout` flag.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the `data_read_ready` and `data_send_timeout` flags are set from an ISR.
    In our example, this might be the timer’s ISR.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we check if both flags are false, and if they are, we enter sleep mode.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The example we discussed is simple, but as the number of flags grows, so does
    the size of the super loop, the number of global variables (flags), and the possibility
    of a mistake such as resetting a flag or forgetting to include it in the `if`
    statement, which provides the conditions for entering sleep mode.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine we wanted to prioritize functions executed in the super loop. Using
    the current approach would be difficult. Adding a priority variable and checking
    it in `if` statements might work initially, but the code would quickly become
    messy and difficult to maintain.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: To address issues of a super loop in a bare-metal environment, we will utilize
    a sequencer. Instead of defining global flags and setting them from an ISR, we
    will add tasks to the sequencer from an ISR. Each task will include priority information,
    enabling the sequencer to organize them in an internal queue based on their priority.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In the main loop, the sequencer runs repeatedly. It handles tasks by always
    picking the highest-priority one from the queue and executing it first, keeping
    task management efficient and orderly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will proceed with the design of the sequencer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Designing a sequencer
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will base the sequencer design on a command pattern that we covered in [*Chapter
    10*](Chapter_10.xhtml). In the command pattern, a sequencer will take the role
    of invoker. In our design, we’ll use the term *task* instead of *command*. This
    *task* is equivalent to a function – it represents a specific unit of functionality
    – not a task as defined in operating systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Sequencer design – UML diagram](img/B22402_14_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Sequencer design – UML diagram
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.1* depicts a UML diagram of a sequencer. We can see it takes the
    role of a sequencer in the command pattern, as described earlier. Instead of a
    command interface and concrete command, this UML design uses a `std::function`
    class template (we used the same approach in the *GPIO Interrupt manager* example
    of [*Chapter 10*](Chapter_10.xhtml)).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sequencer` class holds an array of tasks, which are used to store callable
    objects. The sequencer provides a simple interface, with just two methods:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '`void add(task t)`: The method used to add a task to the sequencer'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void run()`: The method used to take a task with the highest priority, execute
    it, and remove it from the sequencer'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we go into the implementation of sequencer methods, we will first go
    over the `task` class and alternatives to `std::array` for storing tasks. The
    `task` class represents a unit of functionality that will be executed by a sequencer
    according to priority. It has the following members:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '`std::function<void()> the_task_`: An actual callable that will be executed'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::uint8_t priority_`: Priority according to which tasks will be sorted
    in the sequencer’s storage'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Below is the code that implements the `task` class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code implements the task as a class template, allowing us to use it with
    different callable holders. The one we introduced in the book previously is `std::function`.
    The class template task has the following members:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: A constructor that initializes the `the_task_` member, which is type `CallableHolder`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `void execute()` method, which calls `operator()` on `the_task_`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator<`, which compares task by priority'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This code demonstrates the usage of the class template task:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, we instantiate the class template task with `std::function<void()>`.
    We create two objects, `task_a` and `task_b`, and then execute one with higher
    priority by using `operator<` to compare them. Task objects in this example are
    initialized with lambdas, which are internally stored in `std::function<void()>`.
    If you run the preceding example, you will see the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the task with higher priority was executed thanks to the overloaded
    `operator<`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](Chapter_10.xhtml), we saw that the class template `std::function`
    can resort to dynamic memory allocation to store lambdas that are captured. To
    mitigate this concern, we will introduce the **Embedded Template Library** (**ETL**),
    a library that defines a set of containers and algorithms whose operations are
    deterministic and don’t use dynamic memory allocation. The ETL will be discussed
    more in [*Chapter 17*](Chapter_17.xhtml).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Storing a callable
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of `std::function`, we can use `etl::delegate` – a callable holder
    from the ETL. One of its limitations is it doesn’t work with capturing lambdas.
    This may affect the code expressiveness, but it provides us with equivalent functionality
    that allows us to capture different callables. This code demonstrates using the
    class template task with `etl::delegate`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code demonstrates how we can use `etl::delegate` to store a callable:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '`callable_etl::create<test, &test::print>(test_1)` creates `etl::delegate`
    using the template method `create` instantiated with the class `test` and its
    member `print`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_etl::create<test::print_static>()` creates `etl::delegate` using
    the template method `create` instantiated with the static method `print_static`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`task_lambda([](){ printf("This is non capturing lambda!\r\n");});` initializes
    `etl::delegate` with the provided non-capturing lambda'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running the preceding example will result in the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can run the full example in the Renode simulator. Start Visual Studio Code,
    attach it to the running container, open the `Chapter14/sequencer` project, as
    described in [*Chapter 4*](Chapter_04.xhtml), and run the following commands in
    the Visual Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have alternative implementations for callable storage – `std::function` from
    the standard library, or the more embedded-friendly `etl::delegate` from ETL.
    Next, let us consider options for a container for storing the tasks inside the
    sequencer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: In the UML diagram in *Figure 14.1*, the sequencer is using `std::array` to
    store tasks. This implies that sorting the elements of an array according to the
    priority is handled by the sequencer itself. Instead of implementing this manually,
    we can use `std::priority_queue` – a container adapter from the standard library.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '`std::priority_queue` is a template class that is used as an adapter for another
    container, which provides a random access iterator and the following methods:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`front()`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push_back()`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop_back()`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could use `std::vector` from the standard library, as it meets all the requirements
    imposed by `std::priority_queue`. As you know, `std::vector` uses dynamic memory
    allocation, which doesn’t make it a good fit for most of the embedded applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'ETL provides a fixed-size implementation of a vector with a similar interface
    as standard library implementation. This makes it compatible with the priority
    queue. This code demonstrates using `etl::vector` with `std::priority_queue`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code performs the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`std::priority_queue<int, etl::vector<int, 6>> pq{}` defines a priority queue,
    `pq`, with the underlying container `etl::vector<int, 6>`, which is a fixed size
    vector of size `6`.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pq.push(12)` inserts an element (`12`) in the priority queue, `pq`, and sorts
    the queue.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `push` method, we add 5 more elements in the queue – `6`, `16`, `8`,
    `1`, and `10`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `while(!pq.empty())`, we run a `while` loop until the priority queue is
    empty.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `while` loop, we print the top element, which we access using the
    `top()` method, and size using the `size()` method. Then, we pop the top element
    from the queue using `pop()`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Running the preceding code will result in the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see from the output, the elements in the priority queue are sorted.
    This makes it a good solution for storing tasks that can be sorted thanks to the
    overloaded `operator<`. You can run the full example in the Renode simulator.
    Start Visual Studio Code, attach it to the running container, open the `Chapter14/sequencer`
    project, as described in [*Chapter 4*](Chapter_04.xhtml), and run the following
    commands in the Visual Studio Code terminal, or run them directly in the container
    terminal:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have all the elements we need for the sequencer, we will proceed
    with the implementation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a sequencer
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we introduced `etl::delegate` – an alternative to `std::function`
    and fixed size vector implementation from ETL. As ETL avoids dynamic memory allocation,
    we will use these components for the implementation of the sequencer. Below is
    an updated UML diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – UML sequencer diagram using ETL components](img/B22402_14_02.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – UML sequencer diagram using ETL components
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.2* depicts a UML diagram of the sequencer using delegate and vector
    ETL components and the priority queue from the standard library. This code implements
    `sequencer`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this code, `sequencer` is implemented as a static template class with `Task`
    and `Size` as template parameters. This allows us to use it with either `std::function`
    or `etl::function`-based tasks and to define the size of the ETL vector. `sequencer`
    has the following members:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '`static inline std::priority_queue<Task, etl::vector<Task, Size>> pq{}`: A
    private static priority queue based on an ETL vector.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static void add(Task task)`: A static method used to add tasks to the queue
    using the `push` method, guarded by disabling and enabling interrupts, as it can
    be called from an ISR.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static void add(Task task)`：一个静态方法，用于使用`push`方法将任务添加到队列中，通过禁用和启用中断来保护，因为它可以从ISR中调用。'
- en: '`static void run()`: A static method used to take the top element from the
    queue and execute it. Access to the queue is guarded by disabling and enabling
    interrupts.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static void run()`：一个静态方法，用于从队列中取出顶部元素并执行它。对队列的访问通过禁用和启用中断来保护。'
- en: 'Below is an example of using the sequencer:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用序列器的示例：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this code, we do the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们执行以下操作：
- en: Instantiate the `etl::delegate`-based tasks `task_member_fun`, `task_static_fun`,
    and `task_lambda`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化基于`etl::delegate`的任务`task_member_fun`、`task_static_fun`和`task_lambda`。
- en: We add tasks to the sequencer using the sequencer `add` method.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用序列器的`add`方法将任务添加到序列器中。
- en: We run the sequencer in the main `while` loop using the method `run()`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`run()`方法在主`while`循环中运行序列器。
- en: 'Running the preceding code will result in the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将产生以下输出：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see in this code, the tasks are executed according to the assigned
    priority. You can run the full example in Renode. Start Visual Studio Code, attach
    it to the running container, open the `Chapter14/sequencer` project, as described
    in [*Chapter 4*](Chapter_04.xhtml), and run the following commands in the Visual
    Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，任务将根据分配的优先级执行。您可以在Renode中运行完整示例。启动Visual Studio Code，将其附加到正在运行的容器，打开`Chapter14/sequencer`项目，如[*第4章*](Chapter_04.xhtml)中所述，然后在Visual
    Studio Code终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running the example in the simulator should provide the same console output.
    I invite you to explore the sequencer by adding tasks from the timer or external
    interrupts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中运行示例应提供相同的控制台输出。我邀请您通过添加来自计时器或外部中断的任务来探索序列器。
- en: A sequencer offers a better alternative to a super loop by organizing tasks
    in a strictly sequential, prioritized manner. Deterministic behavior needs to
    be assured through task implementation. For instance, in the case of real-time
    requirements, each task must include internal monitoring to guarantee it meets
    the necessary real-time constraints.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 序列器通过以严格顺序、优先级的方式组织任务，提供了一个比超级循环更好的替代方案。通过任务实现确保确定性行为。例如，在实时需求的情况下，每个任务都必须包括内部监控，以确保它满足必要的实时约束。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined the common problems with a basic super loop, which
    motivated our move toward a sequencer design. We covered sequencer design in detail
    and introduced ETL components `etl::delegate` – callable holder which is an alternative
    to `std::function` – and a fixed size vector, which are both great fits for embedded
    applications as they don’t use dynamic memory allocation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了基本超级循环的常见问题，这促使我们转向序列器设计。我们详细介绍了序列器设计，并引入了ETL组件`etl::delegate`——一个可调用的持有者，它是`std::function`的替代品——以及固定大小的向量，它们都是嵌入式应用的绝佳选择，因为它们不使用动态内存分配。
- en: In the next chapter, we will learn about the observer pattern and apply it to
    a temperature-reading application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习观察者模式并将其应用于温度读取应用。
