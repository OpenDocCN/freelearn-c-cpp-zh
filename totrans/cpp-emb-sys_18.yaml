- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Enhancing Super-Loop with Sequencer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用序列器增强超级循环
- en: '**Super-loop** is the basic software architecture of bare-metal firmware. It
    is an infinite loop that executes tasks (functions) often conditioned by flags
    set in an **Interrupt Service Routine** (**ISR**). As the complexity of business
    logic increases, so does the size of a super loop, which can quickly turn into
    a spaghetti mess. To solve this problem within bare-metal constraints (no operating
    system), we can use a sequencer.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**超级循环**是裸机固件的基本软件架构。它是一个无限循环，根据在**中断服务例程**（**ISR**）中设置的标志执行任务（函数）。随着业务逻辑复杂性的增加，超级循环的大小也会增加，这可能会迅速变成一团糟。为了在裸机约束（没有操作系统）内解决这个问题，我们可以使用序列器。'
- en: A **sequencer** stores and executes tasks (functions) in an organized fashion.
    Instead of setting a flag in an ISR, checking it in a super loop, and executing
    a function if a flag is set, we simply add a task to a sequencer from the ISR.
    The super loop then runs the sequencer, which executes the added tasks. Tasks
    in the sequencer can be prioritized, so the sequencer will execute higher-priority
    tasks first.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列器**以有组织的方式存储和执行任务（函数）。我们不是在ISR中设置一个标志，在超级循环中检查它，如果设置了标志就执行一个函数，而是简单地从ISR中将一个任务添加到序列器中。然后超级循环运行序列器，执行添加的任务。序列器中的任务可以被优先级排序，因此序列器会首先执行优先级较高的任务。'
- en: 'In this chapter, we’re going to cover sequencer design and implementation through
    the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下主要主题来介绍序列器的设计和实现：
- en: Super-loop and motivation for a sequencer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超级循环和序列器的动机
- en: Designing a sequencer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计序列器
- en: Storing a callable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储可调用对象
- en: Implementing a sequencer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现序列器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The examples from this chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter14](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter14)).
    To get the most out of this chapter, run the examples in the Renode simulator.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例可在GitHub上找到（[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter14](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter14)）。为了充分利用本章内容，请在Renode模拟器中运行示例。
- en: Super-loop and motivation for a sequencer
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级循环和序列器的动机
- en: 'Before we get into the design and implementation of a sequencer, we will first
    analyze the limitations of a super loop. In a usual super-loop scenario, we check
    flags that are set from an ISR. Below is an example pseudocode of a super loop:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到序列器的设计和实现之前，我们将首先分析超级循环的限制。在通常的超级循环场景中，我们检查由ISR设置的标志。下面是一个超级循环的示例伪代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding pseudocode, we perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的伪代码中，我们执行以下步骤：
- en: Check the Boolean flag `data_read_ready` and, if it is set, we execute the function
    `sensor_data_read_and_buffer`. We then reset the `data_read_ready` flag.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查布尔标志`data_read_ready`，如果它被设置，则执行函数`sensor_data_read_and_buffer`。然后我们重置`data_read_ready`标志。
- en: Check the Boolean flag `data_send_timeout` and, if it is set, we execute the
    function `data_send_from_buffer`. We then reset the `data_send_timeout` flag.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查布尔标志`data_send_timeout`，如果它被设置，则执行函数`data_send_from_buffer`。然后我们重置`data_send_timeout`标志。
- en: Both the `data_read_ready` and `data_send_timeout` flags are set from an ISR.
    In our example, this might be the timer’s ISR.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`data_read_ready`和`data_send_timeout`标志都由ISR设置。在我们的例子中，这可能是计时器的ISR。'
- en: Finally, we check if both flags are false, and if they are, we enter sleep mode.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们检查两个标志是否都为假，如果是，则进入睡眠模式。
- en: The example we discussed is simple, but as the number of flags grows, so does
    the size of the super loop, the number of global variables (flags), and the possibility
    of a mistake such as resetting a flag or forgetting to include it in the `if`
    statement, which provides the conditions for entering sleep mode.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的例子很简单，但随着标志数量的增加，超级循环的大小、全局变量（标志）的数量以及出现错误的可能性（如重置标志或忘记将其包含在`if`语句中，这提供了进入睡眠模式的条件）也会增加。
- en: Now, imagine we wanted to prioritize functions executed in the super loop. Using
    the current approach would be difficult. Adding a priority variable and checking
    it in `if` statements might work initially, but the code would quickly become
    messy and difficult to maintain.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要优先执行超级循环中的函数。使用当前的方法会很困难。添加一个优先级变量并在`if`语句中检查它可能最初有效，但代码会很快变得混乱且难以维护。
- en: To address issues of a super loop in a bare-metal environment, we will utilize
    a sequencer. Instead of defining global flags and setting them from an ISR, we
    will add tasks to the sequencer from an ISR. Each task will include priority information,
    enabling the sequencer to organize them in an internal queue based on their priority.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决裸机环境中的超级循环问题，我们将利用序列器。我们不会定义全局标志并在中断服务例程中设置它们，而是将从中断服务例程中将任务添加到序列器中。每个任务都将包括优先级信息，使序列器能够根据它们的优先级在内部队列中组织它们。
- en: In the main loop, the sequencer runs repeatedly. It handles tasks by always
    picking the highest-priority one from the queue and executing it first, keeping
    task management efficient and orderly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，序列器会反复运行。它通过始终从队列中选取优先级最高的任务并首先执行，以保持任务管理高效且有序。
- en: Next, we will proceed with the design of the sequencer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续进行序列器的设计。
- en: Designing a sequencer
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计序列器
- en: We will base the sequencer design on a command pattern that we covered in [*Chapter
    10*](Chapter_10.xhtml). In the command pattern, a sequencer will take the role
    of invoker. In our design, we’ll use the term *task* instead of *command*. This
    *task* is equivalent to a function – it represents a specific unit of functionality
    – not a task as defined in operating systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于我们在 [*第 10 章*](Chapter_10.xhtml) 中介绍的命令模式来设计序列器。在命令模式中，序列器将扮演调用者的角色。在我们的设计中，我们将使用术语
    *task* 而不是 *command*。这个 *task* 等同于一个函数 – 它代表了一个特定的功能单元 – 而不是操作系统定义的任务。
- en: '![Figure 14.1 – Sequencer design – UML diagram](img/B22402_14_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 序列器设计 – UML 图](img/B22402_14_01.png)'
- en: Figure 14.1 – Sequencer design – UML diagram
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 序列器设计 – UML 图
- en: '*Figure 14.1* depicts a UML diagram of a sequencer. We can see it takes the
    role of a sequencer in the command pattern, as described earlier. Instead of a
    command interface and concrete command, this UML design uses a `std::function`
    class template (we used the same approach in the *GPIO Interrupt manager* example
    of [*Chapter 10*](Chapter_10.xhtml)).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14.1* 展示了一个序列器的 UML 图。我们可以看到它扮演了前面描述的命令模式中的序列器角色。与命令接口和具体命令不同，这个 UML 设计使用了
    `std::function` 类模板（我们在 [*第 10 章*](Chapter_10.xhtml) 的 *GPIO 中断管理器* 示例中也使用了相同的方法）。'
- en: 'The `sequencer` class holds an array of tasks, which are used to store callable
    objects. The sequencer provides a simple interface, with just two methods:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequencer` 类包含一个任务数组，用于存储可调用对象。序列器提供了一个简单的接口，仅包含两个方法：'
- en: '`void add(task t)`: The method used to add a task to the sequencer'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void add(task t)`: 用于将任务添加到序列器中的方法'
- en: '`void run()`: The method used to take a task with the highest priority, execute
    it, and remove it from the sequencer'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void run()`: 用于获取具有最高优先级的任务，执行它，并将其从序列器中移除的方法'
- en: 'Before we go into the implementation of sequencer methods, we will first go
    over the `task` class and alternatives to `std::array` for storing tasks. The
    `task` class represents a unit of functionality that will be executed by a sequencer
    according to priority. It has the following members:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入序列器方法的实现之前，我们首先回顾一下 `task` 类以及存储任务的 `std::array` 的替代方案。`task` 类代表一个将被序列器根据优先级执行的功能单元。它具有以下成员：
- en: '`std::function<void()> the_task_`: An actual callable that will be executed'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::function<void()> the_task_`: 将要执行的实际可调用对象'
- en: '`std::uint8_t priority_`: Priority according to which tasks will be sorted
    in the sequencer’s storage'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::uint8_t priority_`: 根据该优先级对任务进行排序，以便在序列器的存储中排序'
- en: 'Below is the code that implements the `task` class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现 `task` 类的代码：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code implements the task as a class template, allowing us to use it with
    different callable holders. The one we introduced in the book previously is `std::function`.
    The class template task has the following members:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将任务实现为一个类模板，使我们能够使用不同的可调用持有者。我们在书中之前介绍的是 `std::function`。类模板 `task` 具有以下成员：
- en: A constructor that initializes the `the_task_` member, which is type `CallableHolder`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，用于初始化 `the_task_` 成员，其类型为 `CallableHolder`
- en: The `void execute()` method, which calls `operator()` on `the_task_`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void execute()` 方法，它调用 `the_task_` 上的 `operator()`'
- en: '`operator<`, which compares task by priority'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator<`, 用于按优先级比较任务'
- en: 'This code demonstrates the usage of the class template task:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了类模板 `task` 的使用：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, we instantiate the class template task with `std::function<void()>`.
    We create two objects, `task_a` and `task_b`, and then execute one with higher
    priority by using `operator<` to compare them. Task objects in this example are
    initialized with lambdas, which are internally stored in `std::function<void()>`.
    If you run the preceding example, you will see the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用`std::function<void()>`实例化类模板`task`。我们创建了两个对象`task_a`和`task_b`，然后通过使用`operator<`来比较它们，执行优先级更高的一个。在此示例中，任务对象使用lambda初始化，这些lambda内部存储在`std::function<void()>`中。如果您运行前面的示例，您将看到以下输出：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the task with higher priority was executed thanks to the overloaded
    `operator<`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于重载的`operator<`，优先级更高的任务被执行。
- en: In [*Chapter 10*](Chapter_10.xhtml), we saw that the class template `std::function`
    can resort to dynamic memory allocation to store lambdas that are captured. To
    mitigate this concern, we will introduce the **Embedded Template Library** (**ETL**),
    a library that defines a set of containers and algorithms whose operations are
    deterministic and don’t use dynamic memory allocation. The ETL will be discussed
    more in [*Chapter 17*](Chapter_17.xhtml).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](Chapter_10.xhtml)中，我们了解到类模板`std::function`可以求助于动态内存分配来存储捕获的lambda。为了减轻这一担忧，我们将介绍**嵌入式模板库**（**ETL**），这是一个定义了一组容器和算法的库，其操作是确定的且不使用动态内存分配。ETL将在[*第17章*](Chapter_17.xhtml)中进一步讨论。
- en: Storing a callable
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储一个可调用对象
- en: 'Instead of `std::function`, we can use `etl::delegate` – a callable holder
    from the ETL. One of its limitations is it doesn’t work with capturing lambdas.
    This may affect the code expressiveness, but it provides us with equivalent functionality
    that allows us to capture different callables. This code demonstrates using the
    class template task with `etl::delegate`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用来自ETL的`etl::delegate`代替`std::function` – 一个可调用持有者。它的一个限制是它不与捕获的lambda一起工作。这可能会影响代码的表达性，但它为我们提供了等效的功能，使我们能够捕获不同的可调用对象。以下代码演示了使用类模板`task`与`etl::delegate`：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code demonstrates how we can use `etl::delegate` to store a callable:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了我们如何使用`etl::delegate`来存储一个可调用对象：
- en: '`callable_etl::create<test, &test::print>(test_1)` creates `etl::delegate`
    using the template method `create` instantiated with the class `test` and its
    member `print`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callable_etl::create<test, &test::print>(test_1)` 使用模板方法`create`（通过实例化的类`test`和其成员`print`）创建`etl::delegate`'
- en: '`callable_etl::create<test::print_static>()` creates `etl::delegate` using
    the template method `create` instantiated with the static method `print_static`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callable_etl::create<test::print_static>()` 使用模板方法`create`（通过实例化的静态方法`print_static`）创建`etl::delegate`'
- en: '`task_lambda([](){ printf("This is non capturing lambda!\r\n");});` initializes
    `etl::delegate` with the provided non-capturing lambda'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task_lambda([](){ printf("This is non capturing lambda!\r\n");});` 使用提供的非捕获lambda初始化`etl::delegate`'
- en: 'Running the preceding example will result in the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的示例将产生以下输出：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can run the full example in the Renode simulator. Start Visual Studio Code,
    attach it to the running container, open the `Chapter14/sequencer` project, as
    described in [*Chapter 4*](Chapter_04.xhtml), and run the following commands in
    the Visual Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Renode模拟器中运行完整示例。启动Visual Studio Code，将其附加到正在运行的容器，打开`Chapter14/sequencer`项目，如[*第4章*](Chapter_04.xhtml)中所述，然后在Visual
    Studio Code终端中运行以下命令，或者在容器终端中直接运行：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have alternative implementations for callable storage – `std::function` from
    the standard library, or the more embedded-friendly `etl::delegate` from ETL.
    Next, let us consider options for a container for storing the tasks inside the
    sequencer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有可调用存储的替代实现 – 标准库中的`std::function`，或者更嵌入式友好的ETL中的`etl::delegate`。接下来，让我们考虑在序列器内部存储任务的容器选项。
- en: In the UML diagram in *Figure 14.1*, the sequencer is using `std::array` to
    store tasks. This implies that sorting the elements of an array according to the
    priority is handled by the sequencer itself. Instead of implementing this manually,
    we can use `std::priority_queue` – a container adapter from the standard library.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图14.1*的UML图中，序列器使用`std::array`来存储任务。这意味着根据优先级对数组元素进行排序是由序列器本身处理的。我们不必手动实现这一点，可以使用来自标准库的容器适配器`std::priority_queue`。
- en: '`std::priority_queue` is a template class that is used as an adapter for another
    container, which provides a random access iterator and the following methods:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::priority_queue`是一个模板类，用作另一个容器的适配器，该容器提供随机访问迭代器和以下方法：'
- en: '`front()`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`front()`'
- en: '`push_back()`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push_back()`'
- en: '`pop_back()`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop_back()`'
- en: We could use `std::vector` from the standard library, as it meets all the requirements
    imposed by `std::priority_queue`. As you know, `std::vector` uses dynamic memory
    allocation, which doesn’t make it a good fit for most of the embedded applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准库中的 `std::vector`，因为它满足 `std::priority_queue` 强加的所有要求。如您所知，`std::vector`
    使用动态内存分配，这使其不适合大多数嵌入式应用。
- en: 'ETL provides a fixed-size implementation of a vector with a similar interface
    as standard library implementation. This makes it compatible with the priority
    queue. This code demonstrates using `etl::vector` with `std::priority_queue`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ETL 提供了一个具有类似标准库实现的固定大小向量的实现。这使得它与优先队列兼容。此代码演示了使用 `etl::vector` 与 `std::priority_queue`：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code performs the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行以下步骤：
- en: '`std::priority_queue<int, etl::vector<int, 6>> pq{}` defines a priority queue,
    `pq`, with the underlying container `etl::vector<int, 6>`, which is a fixed size
    vector of size `6`.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::priority_queue<int, etl::vector<int, 6>> pq{}` 定义了一个优先队列 `pq`，其底层容器为
    `etl::vector<int, 6>`，这是一个大小为 `6` 的固定大小向量。'
- en: '`pq.push(12)` inserts an element (`12`) in the priority queue, `pq`, and sorts
    the queue.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pq.push(12)` 将元素 (`12`) 插入优先队列 `pq` 并对队列进行排序。'
- en: Using the `push` method, we add 5 more elements in the queue – `6`, `16`, `8`,
    `1`, and `10`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `push` 方法，我们在队列中添加了 5 个更多元素 – `6`、`16`、`8`、`1` 和 `10`。
- en: With `while(!pq.empty())`, we run a `while` loop until the priority queue is
    empty.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `while(!pq.empty())`，我们运行一个 `while` 循环，直到优先队列为空。
- en: Inside the `while` loop, we print the top element, which we access using the
    `top()` method, and size using the `size()` method. Then, we pop the top element
    from the queue using `pop()`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `while` 循环内部，我们打印最高元素，使用 `top()` 方法访问，并使用 `size()` 方法打印大小。然后，我们使用 `pop()`
    从队列中弹出最高元素。
- en: 'Running the preceding code will result in the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将产生以下输出：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see from the output, the elements in the priority queue are sorted.
    This makes it a good solution for storing tasks that can be sorted thanks to the
    overloaded `operator<`. You can run the full example in the Renode simulator.
    Start Visual Studio Code, attach it to the running container, open the `Chapter14/sequencer`
    project, as described in [*Chapter 4*](Chapter_04.xhtml), and run the following
    commands in the Visual Studio Code terminal, or run them directly in the container
    terminal:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中看到的，优先队列中的元素是排序的。这使得它成为存储可以因重载 `operator<` 而排序的任务的好解决方案。您可以在 Renode 模拟器中运行完整示例。启动
    Visual Studio Code，将其附加到正在运行的容器，打开 `Chapter14/sequencer` 项目，如 [*第 4 章*](Chapter_04.xhtml)
    中所述，并在 Visual Studio Code 终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have all the elements we need for the sequencer, we will proceed
    with the implementation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了实现顺序器所需的所有元素，我们将继续进行实现。
- en: Implementing a sequencer
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现顺序器
- en: 'In this chapter, we introduced `etl::delegate` – an alternative to `std::function`
    and fixed size vector implementation from ETL. As ETL avoids dynamic memory allocation,
    we will use these components for the implementation of the sequencer. Below is
    an updated UML diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 `etl::delegate` – `std::function` 的替代方案和来自 ETL 的固定大小向量实现。由于 ETL 避免动态内存分配，我们将使用这些组件来实现顺序器。以下是更新后的
    UML 图：
- en: '![Figure 14.2 – UML sequencer diagram using ETL components](img/B22402_14_02.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 使用 ETL 组件的 UML 顺序图](img/B22402_14_02.png)'
- en: Figure 14.2 – UML sequencer diagram using ETL components
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 使用 ETL 组件的 UML 顺序图
- en: '*Figure 14.2* depicts a UML diagram of the sequencer using delegate and vector
    ETL components and the priority queue from the standard library. This code implements
    `sequencer`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14.2* 展示了一个使用代理和向量 ETL 组件以及标准库中的优先队列的 UML 顺序图。此代码实现了 `顺序器`：'
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this code, `sequencer` is implemented as a static template class with `Task`
    and `Size` as template parameters. This allows us to use it with either `std::function`
    or `etl::function`-based tasks and to define the size of the ETL vector. `sequencer`
    has the following members:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`顺序器` 被实现为一个静态模板类，`Task` 和 `Size` 作为模板参数。这允许我们使用基于 `std::function` 或 `etl::function`
    的任务，并定义 ETL 向量的尺寸。`顺序器` 有以下成员：
- en: '`static inline std::priority_queue<Task, etl::vector<Task, Size>> pq{}`: A
    private static priority queue based on an ETL vector.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static inline std::priority_queue<Task, etl::vector<Task, Size>> pq{}`：基于
    ETL 向量的私有静态优先队列。'
- en: '`static void add(Task task)`: A static method used to add tasks to the queue
    using the `push` method, guarded by disabling and enabling interrupts, as it can
    be called from an ISR.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static void add(Task task)`：一个静态方法，用于使用`push`方法将任务添加到队列中，通过禁用和启用中断来保护，因为它可以从ISR中调用。'
- en: '`static void run()`: A static method used to take the top element from the
    queue and execute it. Access to the queue is guarded by disabling and enabling
    interrupts.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static void run()`：一个静态方法，用于从队列中取出顶部元素并执行它。对队列的访问通过禁用和启用中断来保护。'
- en: 'Below is an example of using the sequencer:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用序列器的示例：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this code, we do the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们执行以下操作：
- en: Instantiate the `etl::delegate`-based tasks `task_member_fun`, `task_static_fun`,
    and `task_lambda`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化基于`etl::delegate`的任务`task_member_fun`、`task_static_fun`和`task_lambda`。
- en: We add tasks to the sequencer using the sequencer `add` method.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用序列器的`add`方法将任务添加到序列器中。
- en: We run the sequencer in the main `while` loop using the method `run()`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`run()`方法在主`while`循环中运行序列器。
- en: 'Running the preceding code will result in the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将产生以下输出：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see in this code, the tasks are executed according to the assigned
    priority. You can run the full example in Renode. Start Visual Studio Code, attach
    it to the running container, open the `Chapter14/sequencer` project, as described
    in [*Chapter 4*](Chapter_04.xhtml), and run the following commands in the Visual
    Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，任务将根据分配的优先级执行。您可以在Renode中运行完整示例。启动Visual Studio Code，将其附加到正在运行的容器，打开`Chapter14/sequencer`项目，如[*第4章*](Chapter_04.xhtml)中所述，然后在Visual
    Studio Code终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running the example in the simulator should provide the same console output.
    I invite you to explore the sequencer by adding tasks from the timer or external
    interrupts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中运行示例应提供相同的控制台输出。我邀请您通过添加来自计时器或外部中断的任务来探索序列器。
- en: A sequencer offers a better alternative to a super loop by organizing tasks
    in a strictly sequential, prioritized manner. Deterministic behavior needs to
    be assured through task implementation. For instance, in the case of real-time
    requirements, each task must include internal monitoring to guarantee it meets
    the necessary real-time constraints.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 序列器通过以严格顺序、优先级的方式组织任务，提供了一个比超级循环更好的替代方案。通过任务实现确保确定性行为。例如，在实时需求的情况下，每个任务都必须包括内部监控，以确保它满足必要的实时约束。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined the common problems with a basic super loop, which
    motivated our move toward a sequencer design. We covered sequencer design in detail
    and introduced ETL components `etl::delegate` – callable holder which is an alternative
    to `std::function` – and a fixed size vector, which are both great fits for embedded
    applications as they don’t use dynamic memory allocation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了基本超级循环的常见问题，这促使我们转向序列器设计。我们详细介绍了序列器设计，并引入了ETL组件`etl::delegate`——一个可调用的持有者，它是`std::function`的替代品——以及固定大小的向量，它们都是嵌入式应用的绝佳选择，因为它们不使用动态内存分配。
- en: In the next chapter, we will learn about the observer pattern and apply it to
    a temperature-reading application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习观察者模式并将其应用于温度读取应用。
