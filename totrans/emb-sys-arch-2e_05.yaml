- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Memory Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: Handling memory is one of the most important tasks for an embedded system programmer,
    and surely the most important to take into account in every phase of the development
    of a system. This chapter is about the models commonly used to manage memory in
    an embedded system, the geometry and the mapping of the memory, and how to prevent
    issues that could compromise the stability and safety of the software running
    on the target.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 处理内存是嵌入式系统程序员最重要的任务之一，并且在系统开发的每个阶段都无疑是最重要的考虑因素。本章介绍了在嵌入式系统中管理内存的常用模型、内存的几何形状和映射，以及如何防止可能危害目标上运行的软件稳定性和安全性的问题。
- en: 'This chapter is divided into four parts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为四个部分：
- en: Memory mapping
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存映射
- en: The execution stack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行栈
- en: Heap management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆管理
- en: The memory protection unit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存保护单元
- en: By the end of this chapter, you will have an in-depth knowledge of how to manage
    the memory in an embedded system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深入了解如何在嵌入式系统中管理内存。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter5/memory](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter5/memory).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter5/memory](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter5/memory)。
- en: Memory mapping
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存映射
- en: Application software usually benefits from a number of abstractions available
    in the environment for the handling of memory. In modern operating systems on
    personal computers, each process can access its own memory space, which can also
    be relocated by remapping memory blocks to virtual memory addresses. Moreover,
    dynamic memory allocations are possible through virtual memory pools provided
    by the kernel. Embedded devices do not rely on these mechanisms, as there is no
    way to assign virtual addresses to physical memory locations. In all contexts
    and running modes, all the symbols can be accessed only by pointing at physical
    addresses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用软件通常可以从环境中可用的内存处理抽象中受益。在现代个人计算机的操作系统上，每个进程都可以访问其自己的内存空间，这些空间也可以通过重新映射内存块到虚拟内存地址来重新定位。此外，通过内核提供的虚拟内存池，可以实现动态内存分配。嵌入式设备不依赖于这些机制，因为没有方法可以将虚拟地址分配给物理内存位置。在所有上下文和运行模式下，所有符号只能通过指向物理地址来访问。
- en: As we have seen in the previous chapter, booting a bare-metal embedded application
    requires defining the sections at compile time within the assigned regions in
    the available address space, using the linker script. In order to properly configure
    the memory sections in our embedded software, it is important to analyze the properties
    of the various regions and the techniques that we can use to organize and manage
    the memory areas.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，启动裸机嵌入式应用程序需要在编译时定义分配在可用地址空间指定区域内的段，使用链接脚本。为了正确配置嵌入式软件中的内存段，分析各个区域的特性和我们可以用来组织和管理的内存区域的技术是重要的。
- en: Memory model and address space
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存模型和地址空间
- en: 'The total amount of available addresses depends on the size of memory pointers.
    32-bit machines can reference a contiguous memory space of 4 GB, which is segmented
    to host all the memory-mapped devices in a system. This may include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可用地址的总数取决于内存指针的大小。32位机器可以引用4 GB的连续内存空间，这被分割以容纳系统中的所有内存映射设备。这可能会包括以下内容：
- en: Internal RAM
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部RAM
- en: Flash memory
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪存
- en: System control registers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统控制寄存器
- en: Components internal to the microcontroller
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微控制器内部的组件
- en: An external peripheral bus
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部外围总线
- en: Additional external RAM
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的外部RAM
- en: Every region has a fixed physical address that may depend on the characteristics
    of the platform. All the locations are hardcoded, and some of them are platform-specific.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区域都有一个固定的物理地址，这可能会依赖于平台的特性。所有位置都是硬编码的，其中一些是平台特定的。
- en: 'In the ARM Cortex-M, the total addressable space is divided into six macro-regions.
    Depending on their purpose, the regions have different permissions so that there
    are areas of memory that can only be accessible for read operations at runtime,
    or that are not allowed to execute in place. These constraints are implemented
    in hardware but might be configurable at runtime on microcontrollers that include
    an MPU:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ARM Cortex-M 中，总的地址空间被划分为六个宏区域。根据它们的目的，这些区域有不同的权限，以便存在只能进行读取操作的内存区域，或者不允许在原地执行的区域。这些限制在硬件中实现，但在包含
    MPU 的微控制器上可能在运行时可配置：
- en: '![Figure 5.1 – The ARM Cortex-M address space](img/B18730_05_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – ARM Cortex-M 地址空间](img/B18730_05_01.jpg)'
- en: Figure 5.1 – The ARM Cortex-M address space
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – ARM Cortex-M 地址空间
- en: In general, only small sections (that are the same size as physical components)
    are mapped within these regions. Trying to access memory that is not mapped to
    any hardware triggers an exception in the CPU. When approaching a target platform,
    it is important to know the locations and the sizes of the memory sections corresponding
    to the hardware on board, in order to properly describe the geometry of the available
    address space in the linker script and in the source code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，只有小部分（与物理组件大小相同）被映射到这些区域中。尝试访问未映射到任何硬件的内存会在 CPU 中触发异常。在接近目标平台时，了解与板上硬件对应的内存部分的地址和大小非常重要，以便在链接脚本和源代码中正确描述可用的地址空间几何形状。
- en: The code region
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码区域
- en: The lowest 512 MB of the addressing space in a Cortex-M microcontroller is reserved
    for executable code. Targets that support XIP always map the flash memory within
    this area, and the memory is generally not writable at runtime. In our previous
    examples, the `.text` and `.rodata` sections are mapped within this region, as
    they remain constant during the execution of the software. Additionally, the initial
    values of all non-zero defined symbols are placed in this area and need to be
    explicitly copied and re-mapped to a writable segment in order to modify their
    value at runtime. As we already know, the `0x00000000`, while others choose a
    different starting address (for example, `0x10000000` or `0x08000000`). STM32F4
    FLASH memory is mapped at `0x08000000` and provides an alias so that the same
    memory can be accessed at runtime, starting at address `0x00000000` as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Cortex-M 微控制器地址空间的最低 512 MB 保留用于可执行代码。支持 XIP 的目标总是将闪存映射到这个区域，并且通常在运行时不允许写入。在我们之前的例子中，`.text`
    和 `.rodata` 部分被映射到这个区域，因为它们在软件执行期间保持不变。此外，所有非零定义符号的初始值都放置在这个区域，并且需要显式地复制和重新映射到可写段，以便在运行时修改它们的值。正如我们已知的，`0x00000000`，而其他人选择不同的起始地址（例如，`0x10000000`
    或 `0x08000000`）。STM32F4 闪存映射到 `0x08000000` 并提供了一个别名，以便可以在运行时从地址 `0x00000000` 访问相同的内存。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When the flash memory address starts at address `0`, NULL pointers can be de-referenced
    and will point to the beginning of the code region, which is normally accessible
    for reading. While this technically violates the C standard, it is a common practice
    within embedded C code to read from address `0x00000000`in these cases – for example,
    to read the initial stack pointer in the IVT on the ARM.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当闪存地址从地址 `0` 开始时，空指针可以被解引用，并将指向代码区域的开始，这通常是可以读取的。虽然这在技术上违反了 C 标准，但在嵌入式 C 代码中，在这种情况下从地址
    `0x00000000` 读取是一种常见的做法——例如，在 ARM 的 IVT 中读取初始堆栈指针。
- en: The RAM regions
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RAM 区域
- en: 'Internal RAM banks are mapped to addresses in the second 512 MB block, starting
    at address `0x20000000`. External memory banks may be mapped anywhere in the 1
    GB region, starting at address `0x60000000`. Depending on the geometry of the
    internal SRAM inside the Cortex-M microcontroller, or the displacement of external
    memory banks, actually accessible memory areas can be mapped in non-contiguous,
    different parts of the memory within the allowed range. Memory management must
    take into account discontinuity in the physical mapping and refer to each section
    separately. The STM32F407 MPU, for example, has two non-contiguously mapped blocks
    of internal SRAM:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 内部 RAM 银行被映射到第二个 512 MB 块中的地址，起始地址为 `0x20000000`。外部内存银行可以映射到 1 GB 区域的任何位置，起始地址为
    `0x60000000`。根据 Cortex-M 微控制器内部 SRAM 的几何形状或外部内存银行的偏移量，实际上可访问的内存区域可以映射到允许范围内的非连续的不同内存部分。内存管理必须考虑到物理映射的不连续性，并分别引用每个部分。例如，STM32F407
    MPU 有两个非连续映射的内部 SRAM 块：
- en: 128 KB of SRAM at address `0x20000000` (in two contiguous blocks of 112 KB and
    16 KB)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址`0x20000000`（由两个连续的112 KB和16 KB块组成）的128 KB SRAM
- en: A separate bank of 64 KB `0x10000000`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独立的64 KB `0x10000000`银行
- en: This second memory is tightly coupled to the CPU and optimized for time-critical
    operations, which allows for zero wait state access from the CPU itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这第二个内存与CPU紧密耦合，并针对时间关键操作进行了优化，这允许从CPU本身进行零等待状态访问。
- en: 'In this case, we may reference the two blocks as two separate areas in the
    linker script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以在链接脚本中将这两个块引用为两个单独的区域：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While the RAM region is designed for data, it generally keeps execution permissions,
    so sections of code can be loaded into RAM and executed at runtime. Executing
    code in RAM expands the flexibility of the system, allowing us to process code
    sections before loading them to memory. Binaries that are not meant to be executed
    in place can be stored on any device in other formats too, even using compression
    or encryption algorithms. While sometimes handy, the possibility of using sections
    in RAM to store executable code takes away precious runtime memory from a system.
    The benefits must be carefully taken into account beforehand when designing the
    system, especially from the point of view of actual runtime memory demands coming
    from the application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RAM区域是为数据设计的，但它通常保留执行权限，因此代码部分可以被加载到RAM中并在运行时执行。在RAM中执行代码扩展了系统的灵活性，使我们能够在将代码部分加载到内存之前处理它们。那些不打算在原地执行的二进制文件也可以以其他格式存储在任何设备上，甚至可以使用压缩或加密算法。虽然有时很方便，但使用RAM中的部分来存储可执行代码会从系统中夺取宝贵的运行时内存。在设计系统之前必须仔细考虑这些好处，尤其是从应用程序的实际运行时内存需求的角度来看。
- en: Peripheral-access regions
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外设访问区域
- en: The 512 MB area following the internal RAM region, starting at address `0x40000000`,
    is reserved for peripherals that are normally built into a microcontroller. The
    1 GB area starting at address `0xA0000000` is instead used to map external memory
    chips and other devices that can be memory-mapped in the MCU addressing space
    but are not part of the original chip package. In order to correctly access the
    peripherals, the configuration of the internal components within the MCU packaging
    and the addresses of the memory-mapped devices must be known in advance. Code
    execution is never allowed in these regions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 内部RAM区域之后的512 MB区域，从地址`0x40000000`开始，是为通常集成到微控制器中的外设保留的。从地址`0xA0000000`开始的1
    GB区域则用于映射外部内存芯片和其他可以在MCU寻址空间中内存映射但不是原始芯片封装部分的外设。为了正确访问外设，必须事先了解MCU封装内部组件的配置和内存映射设备的地址。这些区域不允许代码执行。
- en: The system region
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统区域
- en: The highest 512 MB of the Cortex-M memory mapping is reserved for accessing
    system configuration and private control blocks. This region contains the system
    control registers, which are the registers used to program the processor, and
    the peripheral control registers, used to configure devices and peripherals. Code
    execution is not allowed, and the region is uniquely accessible when the processor
    is running at *privileged level*, as explained in more detail in [*Chapter 10*](B18730_10.xhtml#_idTextAnchor357),
    *Parallel Tasks* *and Scheduling*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Cortex-M内存映射的最高512 MB是为访问系统配置和私有控制块保留的。这个区域包含系统控制寄存器，这些寄存器用于编程处理器，以及外设控制寄存器，用于配置设备和外设。不允许在这些区域执行代码，并且当处理器在*特权级别*运行时，该区域是唯一可访问的，如在第10章[*并行任务*和[*调度*](B18730_10.xhtml#_idTextAnchor357)]中更详细地解释。
- en: Accessing hardware registers by de-referencing their well-known addresses is
    useful to set and get their values at runtime. However, there is no way for the
    compiler to tell the difference between an assignment of a variable mapped in
    RAM and a configuration register in the system control block. For this reason,
    the compiler often thinks that it is a good idea to optimize code by altering
    the order of the memory transactions, which might in fact result in unpredictable
    effects when the next operation depends on the correct conclusion of all the memory
    transfer from the previous ones. For this reason, extra care is needed when accessing
    configuration registers to ensure that the memory transfer operation is concluded
    before the next one is executed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解引用其众所周知的地址来访问硬件寄存器，在运行时设置和获取它们的值是有用的。然而，编译器无法区分映射到RAM的变量赋值和系统控制块中的配置寄存器。因此，编译器通常认为通过改变内存事务的顺序来优化代码是一个好主意，这实际上可能会在下一个操作依赖于所有之前内存传输的正确结论时产生不可预测的效果。因此，在访问配置寄存器时需要格外小心，以确保在执行下一个操作之前，内存传输操作已经完成。
- en: Order of memory transactions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存事务的顺序
- en: 'On ARM CPUs, the memory system does not guarantee that the memory transactions
    are executed in the same order as the instructions that generate them. The order
    of memory transactions can be altered to adjust to the characteristics of the
    hardware, such as the wait states required to access underlying physical memory,
    or by the speculative branch prediction mechanisms implemented at the microcode
    level. While Cortex-M microcontrollers guarantee a strict ordering of the transactions
    involving the peripherals and the system regions, in all other cases code must
    be instrumented accordingly, by placing adequate memory barriers to ensure that
    the previous memory transactions have been executed before executing the next
    instruction. The Cortex-M instruction set includes three kinds of barriers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARM CPU上，内存系统不保证内存事务的执行顺序与生成它们的指令相同。内存事务的顺序可以被改变以适应硬件的特性，例如访问底层物理内存所需的等待状态，或者通过在微代码级别实现的推测性分支预测机制。虽然Cortex-M微控制器保证了涉及外设和系统区域的交易顺序严格，但在所有其他情况下，代码必须相应地进行配置，通过放置足够的内存屏障来确保在执行下一个指令之前，之前的内存事务已经执行。Cortex-M指令集包括三种类型的屏障：
- en: The **data memory** **barrier** (**DMB**)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据内存** **屏障**（**DMB**）'
- en: The **data synchronization** **barrier** (**DSB**)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据同步** **屏障**（**DSB**）'
- en: The **instruction synchronization** **barrier** (**ISB**)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令同步** **屏障**（**ISB**）'
- en: 'The DSB is a *soft* barrier, invoked to ensure that all the pending transactions
    are executed before the next memory transaction occurs. The DSB is used to actually
    suspend the execution until all the pending transactions have been executed. The
    ISB, in addition, also flushes the CPU pipeline and ensures that all the new instructions
    are fetched again after the memory transactions, thus preventing any side effects
    caused by the outdated memory content. There are a number of cases where using
    a barrier is required:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: DSB是一个**软**屏障，用于确保在下一个内存事务发生之前，所有挂起的交易都已执行。DSB实际上用于暂停执行，直到所有挂起的交易都已执行。此外，ISB还会刷新CPU流水线，确保在内存事务之后重新获取所有新指令，从而防止由过时的内存内容引起的任何副作用。有许多情况下需要使用屏障：
- en: After updating the VTOR to change the address of the IV
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新VTOR以更改IV的地址后
- en: After updating the memory mapping
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新内存映射后
- en: During the execution of code that modifies itself
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行修改自身代码的过程中
- en: The execution stack
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行栈
- en: As seen in the previous chapter, a bare-metal application starts executing with
    an empty stack area. The execution stack grows backward, from the high address
    provided at boot to lower addresses every time a new item is stored. The stack
    keeps track of the chain of function calls at all times by storing the branching
    point at each function call, but it also serves as temporary storage during function
    executions. Variables within the local scope of each function are stored inside
    the stack while the function is executing. For this reason, keeping stack usage
    under control is one of the most critical tasks while developing an embedded system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所见，裸机应用程序以空堆栈区域开始执行。执行堆栈向后增长，从启动时提供的高地址到每次存储新项目时的低地址。堆栈始终跟踪函数调用链，通过在每次函数调用时存储分支点，但它在函数执行期间也充当临时存储。每个函数的局部作用域内的变量在函数执行时存储在堆栈中。因此，在开发嵌入式系统时，保持堆栈使用量在控制之下是最关键的任务之一。
- en: 'Embedded programming requires us to be aware at all times of stack usage while
    coding. Placing big objects in the stack, such as communication buffers or long
    strings, is in general not a good idea, considering that the space for the stack
    is always very limited. The compiler can be instructed to produce a warning every
    time the stack space required by a single function exceeds a certain threshold,
    as, for example, in this code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式编程要求我们在编码时始终意识到堆栈使用情况。将大对象放置在堆栈中，例如通信缓冲区或长字符串，通常不是一个好主意，考虑到堆栈的空间总是非常有限。编译器可以被指示在单个函数所需的堆栈空间超过某个阈值时产生警告，例如，在这个代码中：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If compiled with the GCC option, `-Wstack-usage=100`, it will produce the following
    warning:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 GCC 选项 `-Wstack-usage=100` 进行编译，将产生以下警告：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This can be intercepted at compile time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在编译时拦截。
- en: 'While this mechanism is useful to identify local stack overuses, it is not
    effective to identify all the potential stack overflows in the code, as the function
    calls may be nested and their stack usage added up. Our function uses 208 bytes
    of the stack whenever it is invoked, 200 to host the `buffer` local variable in
    the stack, and 8 additional bytes to store two pointers: the origin of the call
    in the code section, which is stored as a return point, and the frame pointer,
    which contains the old location of the stack pointer before the call.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种机制有助于识别局部堆栈过度使用，但它不能有效地识别代码中所有潜在的堆栈溢出，因为函数调用可能是嵌套的，它们的堆栈使用量会累加。我们的函数每次被调用时都会使用
    208 字节的堆栈，其中 200 字节用于在堆栈中托管 `buffer` 局部变量，另外 8 字节用于存储两个指针：代码部分的调用起源，存储为返回点，以及帧指针，它包含调用之前的旧堆栈指针位置。
- en: 'By design, the stack grows every time a function is called and shrinks again
    when functions return. In a given case, it is particularly difficult to make estimations
    about the runtime stack usage, which is the purpose of recursive functions. For
    this reason, the use of recursion in the code should be avoided whenever possible,
    or reduced to the minimum and kept under strict control otherwise, knowing that
    the memory area reserved for the stack in the target is small:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按照设计，每次函数被调用时堆栈都会增长，当函数返回时又会缩小。在特定情况下，对运行时堆栈使用量的估计尤其困难，这正是递归函数的目的。因此，在可能的情况下应避免在代码中使用递归，或者将其减少到最小并严格控制在其他情况下，要知道目标中为堆栈保留的内存区域很小：
- en: "![Figure 5.2 – The stack pointer moves down when a function is called to store\
    \ frame pointer\uFEFFs and local variables](img/B18730_05_02.jpg)"
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 当函数被调用以存储帧指针和局部变量时，堆栈指针向下移动](img/B18730_05_02.jpg)'
- en: Figure 5.2 – The stack pointer moves down when a function is called to store
    frame pointers and local variables
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 当函数被调用以存储帧指针和局部变量时，堆栈指针向下移动
- en: Stack placement
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈放置
- en: The initial pointer to the stack area can be selected at boot by setting the
    desired memory address in the first word of the IV table, which corresponds to
    the beginning of the binary image loaded in flash.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，可以通过设置 IV 表的第一词中的所需内存地址来选择堆栈区域的初始指针，该地址对应于在闪存中加载的二进制图像的起始位置。
- en: This pointer may be set at compile time, in different ways. The simple example
    from [*Chapter 4*](B18730_04.xhtml#_idTextAnchor115), *The Boot-Up Procedure*,
    shows how it is possible to assign a specific area for the stack or use symbols
    exported from the linker script.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指针可以在编译时设置，有多种方式。来自[*第 4 章*](B18730_04.xhtml#_idTextAnchor115)，“启动过程”，的简单示例展示了如何为堆栈分配一个特定区域或使用来自链接脚本导出的符号。
- en: Using the linker script as a central point to describe memory regions and segments
    makes the code more portable across similar platforms.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链接脚本作为描述内存区域和段的中心点，使得代码在类似平台之间更具可移植性。
- en: 'Since our STM32F407 provides an additional, tightly coupled 64-KB memory bank
    at address `0x10000000`, we may want to reserve its lower 16 KB for the execution
    stack and keep the rest in a separate section for later use. The linker script
    must define the region on top, in the `MEMORY` block:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 STM32F407 在地址 `0x10000000` 提供了一个额外的、紧密耦合的 64-KB 内存银行，我们可能想要为其保留下 16 KB
    作为执行栈，并将其余部分保留在单独的部分以供以后使用。链接脚本必须在 `MEMORY` 块中定义顶部的区域：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Two symbols may now be exported at the end of the file, by assigning constant,
    pre-defined values:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在文件末尾导出两个符号，通过分配常量、预定义的值：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The values of `_stack_size` and `_stack_end` can be accessed by the application
    as ordinary C symbols. `_stack_end` is placed at address `0` when the vector table
    is initialized to indicate the highest stack address:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`_stack_size` 和 `_stack_end` 的值可以通过应用程序作为普通 C 符号访问。当向量表初始化时，`_stack_end` 被放置在地址
    `0`，以指示最高的栈地址：'
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Whenever possible, it is a good idea to delegate a separate memory region to
    the stack area, as in this case. Unfortunately, this is not possible on all platforms.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，将单独的内存区域委托给栈区域是一个好主意，就像在这个例子中一样。不幸的是，这并不是所有平台都可行。
- en: Most embedded devices with physical memory mapping offer a single continuous
    mapping region for the entire RAM. A common strategy used to organize the memory
    in these cases is to place the initial stack pointer at the highest available
    address at the end of the mappable memory. This way, the stack is free to grow
    from the top of the memory down, while the application can still use the memory
    to allocate dynamic objects from the lowest address that is not used by any other
    section. While this mechanism is considered the most efficient, giving the illusion
    that it is possible to use up every last byte of RAM available, it is dangerous
    because the two areas growing in opposite directions may collide, leading to unpredictable
    results.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数具有物理内存映射的嵌入式设备为整个 RAM 提供一个单一的连续映射区域。在这些情况下，组织内存的常见策略是将初始栈指针放置在可映射内存末尾的最高可用地址。这样，栈可以从内存顶部向下自由增长，而应用程序仍然可以使用内存从未被任何其他部分使用的最低地址分配动态对象。虽然这种机制被认为是最有效的，给人一种似乎可以耗尽所有可用
    RAM 的错觉，但它很危险，因为两个向相反方向增长的区域可能会碰撞，导致不可预测的结果。
- en: Stack overflows
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈溢出
- en: The main problem with stack sizing and placement is that it is very difficult,
    if not impossible, to recover from a situation of stack overflow in a single-thread,
    bare-metal application. When the stack is self-contained in its own physical region,
    such as a separate memory bank, if its lower bound is a region not mapped to any
    device, a stack overflow will cause a hard fault exception, which can be trapped
    to halt the target.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 栈大小和放置的主要问题是，在单线程、裸机应用程序中，从栈溢出情况中恢复是非常困难的，甚至可能是不可能的。当栈在其自身的物理区域内自包含，例如在单独的内存银行中，如果其下限是一个未映射到任何设备的区域，栈溢出将导致硬故障异常，这可以被捕获以停止目标。
- en: 'In other cases, such as when adjacent memory is used for other purposes, the
    stack pointer might overflow into other segments, with a concrete risk of corrupting
    other memory areas, with catastrophic consequences including even opening the
    door to malicious code injections and arbitrary code execution attacks on the
    target. The best strategy usually consists of assigning adequate stack space at
    boot, isolating the stack as much as possible from the other memory sections,
    and checking the stack usage at runtime. Configuring the stack to use the lowest
    available addresses in RAM ensures that a stack overflow will result in a hard
    fault, rather than accessing valid pointers in adjacent areas in memory. The most
    classic approach for a bare-metal system with a single contiguous region of memory-mapped
    RAM is putting the initial stack pointer at the highest address available and
    having it grow backward toward lower addresses. The linker script exports the
    highest address mapped as the initial stack pointer:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，例如当相邻内存用于其他目的时，栈指针可能会溢出到其他段，存在破坏其他内存区域的具体风险，包括甚至打开恶意代码注入和针对目标任意代码执行攻击的大门。通常，最佳策略是在启动时分配足够的栈空间，尽可能地将栈与其他内存区隔离开来，并在运行时检查栈的使用情况。将栈配置为使用
    RAM 中可用的最低地址确保了栈溢出会导致硬错误，而不是访问内存中相邻区域的有效指针。对于具有单一连续内存映射RAM区域的裸机系统，最经典的方法是将初始栈指针放在可用的最高地址，并使其向后增长到较低的地址。链接脚本导出映射的最高地址作为初始栈指针：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The available memory between the end of the `.bss` section and the lowest address
    in the stack may be used for dynamic allocations by the application, and at the
    same time, the stack is allowed to grow in the opposite direction. This is an
    efficient way to utilize all the available memory because the stack does not require
    a lower boundary, but it is safe only as long as the total amount of memory used
    from both sides fits inside the designated areas. If the sections are allowed
    to dynamically grow toward higher addresses, there is always a possibility of
    collisions if there is overlap from both sides:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`.bss` 区段结束和栈最低地址之间的可用内存可以被应用程序用于动态分配，同时，栈也被允许向相反方向增长。这是利用所有可用内存的有效方法，因为栈不需要一个下界，但只有在从两侧使用的总内存量适合指定区域时才是安全的。如果允许这些区段动态增长到更高的地址，那么如果两侧有重叠，就总有可能发生冲突：'
- en: '![Figure 5.3 – Heap allocations and the execution stack growing in opposite
    directions](img/B18730_05_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 堆分配和执行栈向相反方向增长](img/B18730_05_03.jpg)'
- en: Figure 5.3 – Heap allocations and the execution stack growing in opposite directions
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 堆分配和执行栈向相反方向增长
- en: Collisions between two contiguous memory areas are very common and dangerous
    events in embedded systems with one single continuous region of memory. A solution
    proposed later in this chapter, in the *Memory protection unit* section, can be
    used to separate memory into two logical blocks by inserting a third inaccessible
    block in the middle and to help identify and intercept these cases.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有单一连续内存区域的嵌入式系统中，两个连续内存区域之间的冲突是非常常见且危险的事件。在本章稍后提出的解决方案，即在 *内存保护单元* 部分中，可以通过在中间插入一个不可访问的第三块来将内存分成两个逻辑块，并帮助识别和拦截这些情况。
- en: Stack painting
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈着色
- en: An effective way to measure the amount of stack space needed at runtime consists
    of filling the estimated stack space with a well-known pattern. This mechanism,
    informally referred to as stack painting, reveals the maximum expansion of the
    execution stack at any time. By running the software with a painted stack, it
    is in fact possible to measure the amount of stack used by looking for the last
    recognizable pattern, and assuming that the stack pointer has moved during the
    execution, but never crossing that point.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测量运行时所需栈空间的有效方法是在估计的栈空间中填充一个已知的模式。这种机制非正式地被称为栈着色，它揭示了执行栈在任何时刻的最大扩展。通过运行带有着色栈的软件，实际上可以通过寻找最后一个可识别的模式来测量使用的栈空间量，并假设栈指针在执行过程中已经移动，但永远不会越过那个点。
- en: 'We can perform stack painting manually in the reset handler, during memory
    initialization. To do so, we need to assign an area to paint. In this case, it
    would be the last 8 KB of memory up until `_end_stack`. Once again, while manipulating
    the stack in the `reset_handler` function, local variables should not be used.
    The `reset_handler` function will store the value of the current stack pointer
    in the `sp` global variable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在复位处理程序中手动执行栈绘制，在内存初始化期间进行。为此，我们需要分配一个绘制区域。在这种情况下，将是内存的最后8 KB，直到`_end_stack`。再次强调，在`reset_handler`函数中操作栈时，不应使用局部变量。`reset_handler`函数将当前栈指针的值存储在`sp`全局变量中：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Within the handler, the following section can be added before invoking `main()`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序中，可以在调用`main()`之前添加以下部分：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first assembly instruction is used to store the current value of the stack
    pointer to the `sp` variable, ensuring that the painting stops after the area
    is painted but only up until the last unused address in the stack:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首条汇编指令用于将栈指针的当前值存储到`sp`变量中，确保在区域被绘制后绘画停止，但仅限于栈中最后一个未使用的地址：
- en: '![Figure 5.4 – Painting the stack area with a recognizable pattern helps to
    estimate the stack memory used in the prototype](img/B18730_05_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 使用可识别的图案绘制栈区域有助于估计原型中使用的栈内存](img/B18730_05_04.jpg)'
- en: Figure 5.4 – Painting the stack area with a recognizable pattern helps to estimate
    the stack memory used in the prototype
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 使用可识别的图案绘制栈区域有助于估计原型中使用的栈内存
- en: The current stack usage can be checked periodically at runtime – for instance,
    in the `main` loop – to detect the area painted with the recognizable pattern.
    The areas that are still painted have never been used by the execution stack so
    far and indicate the amount of stack still available.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在运行时定期检查当前的栈使用情况 – 例如，在`main`循环中 – 以检测带有可识别图案的区域。仍然被涂色的区域至今尚未被执行栈使用，表明了仍然可用的栈空间量。
- en: This mechanism may be used to verify the amount of stack space required by the
    application to run comfortably. According to the design, this information can
    be used later on to set a safe lower limit on the segment that can be used for
    the stack. Stack painting, however, is not always effective, as it gives a measurement
    of the stack used during the execution, but it might overlook corner cases where
    the stack usage may be bigger. Increasing test coverage while keeping an eye on
    the stack painting at the end of each test may help to allocate the appropriate
    amount of stack space during the development phase.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此机制可用于验证应用程序运行时所需的栈空间量。根据设计，此信息可以稍后用于设置栈可用段的安全下限。然而，栈绘制并不总是有效的，因为它提供了执行期间使用的栈的测量值，但它可能忽略了栈使用可能更大的边缘情况。在每次测试结束时关注栈绘制，同时增加测试覆盖率，可能有助于在开发阶段分配适当的栈空间。
- en: Heap management
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆管理
- en: Safety-critical embedded systems are often designed not to implement any dynamic
    memory allocation. While this may sound extreme, it minimizes the impact of the
    most common programming mistakes in the application code, which might lead to
    catastrophic consequences for the running system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关键安全性的嵌入式系统通常设计为不实现任何动态内存分配。虽然这听起来可能有些极端，但它最小化了应用代码中最常见的编程错误对系统运行的影响，这些错误可能导致系统运行出现灾难性的后果。
- en: On the other hand, dynamic allocation is a powerful tool because it gives complete
    control over the lifetime and the size of the memory blocks. Many third-party
    libraries designed for embedded devices expect an existing implementation of dynamic
    memory allocation. Dynamic memory is managed through a heap structure in memory,
    by keeping track of the status and the size for each allocation, incrementing
    the pointer to the next area of free memory, and reusing blocks that have been
    freed if new allocation requests are processed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，动态分配是一种强大的工具，因为它提供了对内存块生命周期和大小的完全控制。许多为嵌入式设备设计的第三方库都期望存在动态内存分配的实现。动态内存通过在内存中维护每个分配的状态和大小来管理，通过跟踪指向下一个空闲内存区域的指针，并在处理新的分配请求时重用已释放的块。
- en: 'A standard programming interface for heap allocation consists of two basic
    functions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 堆分配的标准编程接口由两个基本函数组成：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These function signatures are defined by the ANSI-C standard and are commonly
    found in operating systems. They allow us to request a new memory area of a given
    size and free up the previously allocated area referred to by the specified pointer
    respectively. More complete heap management has support for an additional call,
    `realloc`, that allows us to resize a memory area previously allocated, either
    in place or by relocating it to a new segment that is large enough to contain
    an object of the given size:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数签名由 ANSI-C 标准定义，通常在操作系统中找到。它们允许我们请求一个给定大小的新的内存区域，并释放由指定指针引用的先前分配的区域。更完整的堆管理支持一个额外的调用，`realloc`，它允许我们调整先前分配的内存区域的大小，无论是在原地调整还是将其重新定位到一个足够大的新段，以容纳给定大小的对象：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While `realloc` is generally left out from most of the embedded system implementations,
    it may be useful in some cases to resize objects in memory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `realloc` 通常被大多数嵌入式系统实现省略，但在某些情况下，调整内存中的对象大小可能是有用的。
- en: Depending on the implementation, memory management could be more or less efficient
    in joining together contiguous blocks that had been freed, in order to create
    larger available segments without having to allocate new space. Real-time operating
    systems usually offer allocators with different heap management. To mention one,
    FreeRTOS provides five different portable heap managers to choose from.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 根据实现方式，内存管理在连接已释放的连续块以创建更大的可用段时可能更有效率或更低效，而不必分配新空间。实时操作系统通常提供具有不同堆管理的分配器。以 FreeRTOS
    为例，它提供了五个不同的可移植堆管理器可供选择。
- en: 'If we opt for a solution that allows for dynamic allocations, it is important
    to design it while taking into account a few important factors:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择一个允许动态分配的解决方案，重要的是在设计时要考虑到几个重要因素：
- en: The geometry of the regions where the heap is placed
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆放置区域的几何形状
- en: The higher boundary of the section dedicated to the heap, if it is shared with
    the stack, to prevent heap-stack collisions
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果堆与栈共享，则分配给堆的部分的上限，以防止堆栈冲突
- en: The policy to adopt if there is not enough memory to satisfy requests for new
    allocations
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有足够的内存来满足新分配请求，应采取的政策
- en: How to deal with memory fragmentation and keep the overhead of unused blocks
    as small as possible
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理内存碎片化并尽可能减小未使用块的开销
- en: Using separate pools to separate the memory used by specific objects and modules
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单独的池来分离特定对象和模块使用的内存
- en: Spreading a single pool of memory across non-contiguous regions
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单个内存池分散到非连续的区域
- en: When no allocator is available on the target – for example, if we are developing
    a bare-metal application from scratch – we might be required to implement an allocator
    that responds to the characteristics of the design. This can be done either from
    scratch by providing a custom implementation of the `malloc`/`free` functions
    or using implementations provided by the C library in use. The first approach
    gives complete control over the fragmentation, memory areas, and pools to be used
    to implement the heap, while the latter hides most of the handling while still
    allowing customization of the (contiguous) memory area and boundaries. In the
    next two sections, we will explore the two possible strategies in more detail.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标上没有可用的分配器时——例如，如果我们从头开始开发裸机应用程序——我们可能需要实现一个响应设计特性的分配器。这可以通过从头开始提供 `malloc`/`free`
    函数的自定义实现来完成，或者使用使用的 C 库提供的实现。第一种方法可以完全控制碎片化、内存区域和用于实现堆的池，而后者隐藏了大部分处理，同时仍然允许定制（连续的）内存区域和边界。在接下来的两个部分中，我们将更详细地探讨两种可能策略。
- en: Custom implementation
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义实现
- en: 'Unlike servers and personal computers, where memory allocations are handled
    using pages of a specific size, in bare-metal embedded systems, the heap is usually
    one or more contiguous areas of physical memory that can be divided internally
    using any alignment. Building heap-based memory allocation based on the `malloc`/`free`
    interface consists of keeping track of the requested allocations in memory. This
    is usually done by attaching a small header in front of each allocation to track
    the state and the size of the allocated section, which can be used in the `free`
    function to validate the allocated block and make it available for the next allocation.
    A basic implementation, providing dynamic memory starting from the first available
    address after the end of the `.bss` section, might represent each block in memory
    using a preamble, such as the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器和个人计算机不同，在这些系统中内存分配是通过特定大小的页面来处理的，在裸机嵌入式系统中，堆通常是物理内存的一个或多个连续区域，可以使用任何对齐方式内部划分。基于
    `malloc`/`free` 接口的堆内存分配构建包括在内存中跟踪请求的分配。这通常是通过在每个分配前附加一个小型头部来完成的，以跟踪状态和分配部分的大小，这可以在
    `free` 函数中使用来验证分配的块并将其提供给下一次分配。一个基本的实现，从 `.bss` 部分结束后的第一个可用地址开始提供动态内存，可能使用以下预头表示内存中的每个块：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Two different signatures can be assigned to identify valid blocks and differentiate
    blocks still in use versus blocks that have already been freed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以分配两个不同的签名来识别有效的块并区分仍在使用的块和已经释放的块：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `malloc` function should keep track of the highest address in the heap.
    In this example, a static variable is used to mark the current end of the heap.
    This is set to the start address at the beginning and will grow every time a new
    block is allocated:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc` 函数应该跟踪堆中的最高地址。在这个例子中，一个静态变量被用来标记堆的当前末尾。它在开始时设置为起始地址，并且每次分配新块时都会增长：'
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next two lines ensure that the block requested is 32-bit-aligned to optimize
    the access to `malloc_block`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两行确保请求的块是32位对齐的，以优化对 `malloc_block` 的访问：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `malloc` function then first looks in the heap for a memory section that
    has been previously freed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `malloc` 函数首先在堆中查找之前已释放的内存部分：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If no available slot is found, or if none of them is large enough to satisfy
    the size required for the allocation, the memory is allocated at the end of the
    stack and the pointer is updated accordingly:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到可用插槽，或者如果没有一个足够大以满足分配所需的大小，内存将在栈的末尾分配，并且指针相应地更新：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In both cases, the address returned hides the `malloc_block` control structure
    that precedes it. The `end_heap` variable always points to the end of the last
    block allocated in the heap, but it is not an indication of the memory used, as
    intermediate blocks may have been freed in the meanwhile. This example `free`
    function, demonstrating a very simple case, is only performing basic checks on
    the block that needs to be freed and setting the signature to indicate that the
    block is no longer being used:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，返回的地址隐藏了在其前面的 `malloc_block` 控制结构。`end_heap` 变量始终指向堆中最后分配的块的末尾，但它并不是内存使用的指示，因为在此期间可能已经释放了中间的块。这个示例
    `free` 函数，演示了一个非常简单的情况，仅对需要释放的块执行基本检查，并将签名设置为指示该块不再被使用：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Although this example is very simplistic, it aims at explaining the basic functionality
    of heap allocation without taking into account all real-life constraints and limitations.
    In fact, allocating and freeing objects of different sizes may cause fragmentation.
    To minimize the impact of this phenomenon in terms of memory usage and wasted
    space between active allocations, the `free` function should at least implement
    some kind of mechanism to join together adjacent areas that are no longer in play.
    Furthermore, the preceding example, `malloc`, assumes that the heap section does
    not have an upper boundary, does not perform any check on the new location of
    the `end_heap` pointer, and does not define a strategy when there is no memory
    available to allocate.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子非常简单，但其目的是解释堆分配的基本功能，而不考虑所有现实生活中的限制和限制。实际上，分配和释放不同大小的对象可能会导致碎片化。为了最大限度地减少这种现象对内存使用和活动分配之间浪费空间的影响，`free`
    函数至少应该实现某种机制来合并不再使用的相邻区域。此外，前面的例子 `malloc` 假设堆部分没有上限，不对 `end_heap` 指针的新位置进行任何检查，并且在没有可用内存进行分配时没有定义策略。
- en: Although toolchains and libraries often provide a default implementation of
    `malloc` and `free`, implementing custom heap-based allocation mechanisms still
    makes sense in cases where the implementations available do not meet the requirements
    – for example, if we want to manage separate memory pools or merge separate physical
    memory sections to use them in the same pool.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然工具链和库通常提供 `malloc` 和 `free` 的默认实现，但在现有实现不符合要求的情况下，实现自定义基于堆的分配机制仍然是有意义的——例如，如果我们想管理单独的内存池或将单独的物理内存部分合并以在同一个池中使用。
- en: Fragmentation issues cannot be completely resolved on systems with physical
    memory mapping because it is impossible to move around previously allocated blocks
    to optimize the space available. The issue can, however, be mitigated by keeping
    the number of allocations under control, reusing allocated blocks as much as possible,
    and avoiding frequent calls to `malloc`/`free`, especially to request blocks with
    different sizes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有物理内存映射的系统上，无法完全解决碎片化问题，因为无法移动之前分配的块以优化可用的空间。然而，通过控制分配的数量，尽可能多地重用分配的块，并避免频繁调用
    `malloc`/`free`，特别是请求不同大小的块，可以减轻这个问题。
- en: The use of dynamic memory, regardless of the implementation, introduces a number
    of safety concerns and should be avoided in all life-critical systems, and in
    general wherever it is not required. Simpler, single-purpose embedded systems
    can be designed to avoid the use of dynamic memory allocations altogether. In
    these cases, a simple `malloc` interface can be provided to allow permanent allocations
    during startup.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不论实现方式如何，动态内存的使用都会引入许多安全问题，并且应该在所有生命关键系统中避免使用，在一般情况下，在不必要的地方也应避免使用。简单的单用途嵌入式系统可以被设计为完全避免使用动态内存分配。在这些情况下，可以提供一个简单的
    `malloc` 接口，以允许在启动期间进行永久分配。
- en: Using newlib
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 newlib
- en: Toolchains may provide a set of utilities, which often include dynamic memory
    allocation mechanisms. GCC-based toolchains for microcontrollers include a reduced
    set of standard C calls, usually in the built-in standard C library. A popular
    choice, often included in the ARM-GCC embedded toolchain, is `newlib`. While providing
    the implementation of many standard calls, `newlib` remains as flexible as possible
    by allowing customization of the operations involving the hardware. The `newlib`
    library can be integrated into both single-thread, bare-metal applications and
    in a real-time operating system, provided that the required system calls are implemented.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链可能提供一系列实用工具，通常包括动态内存分配机制。基于 GCC 的微控制器工具链包括一组减少的标准 C 调用，通常在内置的标准 C 库中。一个流行的选择，通常包含在
    ARM-GCC 嵌入式工具链中，是 `newlib`。虽然提供了许多标准调用的实现，但 `newlib` 通过允许定制涉及硬件的操作，尽可能保持灵活性。只要实现了所需的系统调用，`newlib`
    库就可以集成到单线程、裸机应用程序和实时操作系统中。
- en: 'In the case of `malloc`, `newlib` requires an existing implementation of the
    `sbrk` function. This function is expected to move the heap pointer forward every
    time a new allocation requires an extension of the heap space and return the old
    value of the heap to `malloc`, in order to complete allocations every time an
    existing, previously freed, and reusable block is not found in the pool:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `malloc`，`newlib` 需要一个现有的 `sbrk` 函数实现。这个函数预期在每次新的分配需要扩展堆空间时将堆指针向前移动，并将旧的堆值返回给
    `malloc`，以便在现有、之前释放且可重用的块在池中找不到时完成分配：
- en: '![Figure 5.5 – newlib implements malloc and free and relies on an existing
    implementation of _sbrk](img/B18730_05_05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – newlib 实现 malloc 和 free 并依赖于现有的 _sbrk 实现](img/B18730_05_05.jpg)'
- en: Figure 5.5 – newlib implements malloc and free and relies on an existing implementation
    of _sbrk
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – newlib 实现 malloc 和 free 并依赖于现有的 _sbrk 实现
- en: 'A possible implementation of the `_sbrk` function may be the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`_sbrk` 函数的一个可能的实现如下：'
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the code is linked without the `-nostdlib` flag, the `malloc` and `free`
    functions, if invoked anywhere in the code, will be automatically found within
    the `newlib` library built in the toolchain and included in the final binary.
    Failing to define an `_sbrk` symbol, in this case, will result in a linking error.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码在未使用 `-nostdlib` 标志的情况下进行链接，那么在代码的任何地方调用的 `malloc` 和 `free` 函数将会自动在工具链中构建的
    `newlib` 库中找到，并包含在最终的二进制文件中。如果没有定义 `_sbrk` 符号，则会导致链接错误。
- en: Limiting the heap
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制堆大小
- en: In all the allocation functions seen so far, there is no limit imposed by the
    software on the amount of memory reserved for the heap. While overflowing the
    stack is often hard to prevent, and extremely difficult to recover from, running
    out of available heap memory can more often be gracefully handled by the application
    – for example, by canceling or postponing the operation that required the allocation.
    In more complex multithreaded systems, an operating system could actively react
    to the memory shortage by terminating non-vital processes to free up memory for
    new allocations. Some advanced systems using page-swapping mechanisms, such as
    Linux, may implement overcommit on the available memory. This mechanism guarantees
    that memory allocations never fail, and `malloc` will never return `NULL` to indicate
    a failure.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止看到的所有分配函数中，软件对为堆保留的内存量没有设置限制。虽然防止栈溢出通常很难，而且恢复起来极其困难，但应用程序通常可以优雅地处理可用堆内存耗尽的情况——例如，通过取消或推迟需要分配的操作。在更复杂的线程系统中，操作系统可以通过终止非关键进程来主动响应内存短缺，为新分配腾出空间。一些使用页面交换机制的高级系统，如Linux，可能会在可用内存上实现超分配。这种机制确保内存分配永远不会失败，`malloc`永远不会返回`NULL`来指示失败。
- en: 'Memory-consuming processes in a system may be instead terminated at any time
    by a kernel thread, the out-of-memory killer, to make space for new allocations
    from other less resource-consuming processes. On an embedded system, especially
    if there is no multithreading, the best choice is to have the allocator return
    `NULL` when there is no physical space left on the heap so that the system can
    keep running and the application can possibly recover by recognizing the out-of-memory
    episode. The section in memory dedicated to the heap can be limited by exporting
    the address for its upper boundary in the linker script, as shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的内存消耗进程可能在任何时候由内核线程，即内存不足杀手，终止，为新分配腾出空间，以便其他资源消耗较少的进程继续运行。在嵌入式系统中，特别是如果没有多线程，当堆上没有剩余物理空间时，最好让分配器返回`NULL`，这样系统可以继续运行，应用程序可能通过识别内存不足事件来恢复。可以通过在链接脚本中导出其上边界地址来限制堆在内存中的部分，如下所示：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The backend for the `newlib` library `malloc` implementation can account for
    the newly introduced upper bound in the `_sbrk()` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`newlib`库`malloc`实现的后端可以考虑到在`_sbrk()`函数中引入的新上限：'
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The special `(void *)(-1)` value that is returned by `sbrk` in case of memory
    shortage for heap allocation indicates to the calling `malloc` that there is not
    enough space to perform the requested allocation. `malloc` will then return `NULL`
    to the caller.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当`sbrk`因堆分配内存不足而返回特殊值`(void *)(-1)`时，这表示调用`malloc`的内存不足，无法执行所需的分配。然后`malloc`将返回`NULL`给调用者。
- en: It is very important in this case that the caller always checks the return value
    at each invocation of `malloc()` and that the application logic is able to correctly
    detect that the system is out of memory, and react in an attempt to recover from
    it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，调用者始终检查`malloc()`每次调用的返回值，并且应用程序逻辑能够正确检测系统内存不足，并尝试从中恢复，这一点非常重要。
- en: Multiple memory pools
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个内存池
- en: 'In some systems, it is useful to keep separate sections as dynamic memory heaps,
    each dedicated to a specific function in the system. Heap allocation mechanisms
    using separate pools may be implemented for different reasons, such as ensuring
    that specific modules or subsystems do not use more memory than the amount that
    is assigned to them at compile time, or ensuring that allocations with the same
    size can reuse the same physical space in memory, reducing the impact of fragmentation,
    or even assigning a pre-defined, fixed area in memory for DMA operations with
    peripherals or network devices. It is possible to delimit the sections for the
    different pools by, as usual, exporting symbols in the linker script. The following
    example pre-allocates the space in memory for two pools, of 8 KB and 4 KB respectively,
    located at the end of the `.bss` section in RAM:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统中，将内存的独立部分作为动态内存堆保留是有用的，每个部分都专门用于系统中的特定功能。出于不同原因，如确保特定模块或子系统不会使用比编译时分配的更多内存，或者确保具有相同大小的分配可以重用相同的物理内存空间，从而减少碎片化影响，或者甚至为与外围设备或网络设备的DMA操作分配预定义的固定内存区域，可以实现使用独立池的堆分配机制。可以通过通常在链接脚本中导出符号的方式来界定不同池的分区。以下示例预先在内存中为两个池分配空间，分别为8
    KB和4 KB，位于RAM中`.bss`部分的末尾：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A custom allocation function must be defined, since the `malloc` interface
    does not support the selector of the pool, but the functions can be made generic
    for both pools. A global structure can be populated with the values exported by
    the linker:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 必须定义一个自定义的分配函数，因为`malloc`接口不支持选择池，但函数可以针对两个池都进行通用化。可以使用全局结构体来填充由链接器导出的值：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The function must take an extra argument to specify the pool. Then, the allocation
    is performed with the same algorithm, only changing the current pointer and the
    boundaries of the selected pool. In this version, the out-of-memory errors are
    detected before moving the current heap value forward, returning `NULL` to notify
    the caller:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 函数必须接受一个额外的参数来指定池。然后，使用相同的算法执行分配，只需更改当前指针和所选池的边界。在这个版本中，在将当前堆值向前移动之前检测到内存不足错误，返回`NULL`以通知调用者：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once again, this mechanism does not account for memory fragmentation, so the
    `mempool_free` function can have the same implementation as `free` for the simplified
    `malloc`, as the only necessary thing to do is to mark the blocks being freed
    as unused.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此机制不考虑内存碎片，因此`mempool_free`函数可以与`free`具有相同的实现，对于简化的`malloc`来说，唯一必要的事情是将释放的块标记为未使用。
- en: In more complete cases, where `free` or a separate garbage collector routine
    takes care of merging contiguous freed blocks, it might be required to keep track
    of the freed blocks in each pool, in a list, or in another data structure that
    can be visited to check whether merging is possible.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在更完整的情况下，当`free`或单独的垃圾回收例程负责合并连续释放的块时，可能需要在每个池中跟踪释放的块，在列表中或在可以访问以检查合并是否可能的其他数据结构中。
- en: Common heap usage errors
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的堆使用错误
- en: 'The use of dynamic memory allocation is considered unsafe in some environments,
    as it is widely known to be the source of nasty bugs, which are in general both
    critical and very hard to identify and fix. Dynamic allocations may be difficult
    to track, especially when code grows in size and complexity and there are many
    dynamically allocated data structures. This is already very serious in multithreaded
    environments, where it is still possible to implement fallback mechanisms, such
    as terminating a misbehaving application, but it becomes critical on single-threaded
    embedded systems, where these kinds of errors are often fatal for the system.
    The most common types of errors when programming with heap allocations are as
    follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些环境中，使用动态内存分配被认为是不安全的，因为它众所周知是导致讨厌的错误的来源，这些错误通常是关键且非常难以识别和修复。动态分配可能难以跟踪，尤其是在代码大小和复杂性增加以及存在许多动态分配的数据结构时。这在多线程环境中已经非常严重，在那里仍然可以实施回退机制，例如终止行为不当的应用程序，但在单线程嵌入式系统中，这些类型的错误通常对系统是致命的。使用堆分配编程时最常见的错误类型如下：
- en: '`NULL` pointer de-reference'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NULL`指针解引用'
- en: Double `free`
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重`free`
- en: Use after `free`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`free`之后的使用'
- en: Failure to call `free`, resulting in memory leaks
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未调用`free`导致内存泄漏
- en: Some of these can be avoided by following a few simple rules. `malloc` returns
    the value that should always be checked before using the pointer. This is particularly
    important in environments where resources are limited, and the allocator can return
    `NULL` pointers to indicate that there is no memory available for the allocation.
    The preferred approach is ensuring that there is a defined strategy to follow
    when the required memory is not available. In any case, all dynamic pointers must
    be checked to ensure that they do not point to a `NULL` value before attempting
    to de-reference.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循一些简单的规则可以避免其中的一些。`malloc`返回的值在使用指针之前应该始终进行检查。这在资源有限的环境中尤为重要，分配器可以返回`NULL`指针以指示没有可用于分配的内存。首选的方法是确保当所需的内存不可用时有一个明确的策略。在任何情况下，所有动态指针都必须进行检查，以确保在尝试解引用之前它们不指向`NULL`值。
- en: Freeing `NULL` pointers is a legal operation that must be identified when `free`
    is called. By including a check at the beginning of the function, if the pointer
    is `NULL`, no action is performed and the call is ignored.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 释放`NULL`指针是一个合法的操作，当调用`free`时必须识别。通过在函数开始处包含一个检查，如果指针是`NULL`，则不执行任何操作，并忽略调用。
- en: 'Immediately after, we can also check that the memory has not been freed before.
    In our `free` function, we implement a simple check against the signature of the
    `malloc_block` structure in memory. It would be possible to add a log message,
    or even a breakpoint, to debug the origin of the second `free` function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们还可以检查内存是否在释放之前已被释放。在我们的`free`函数中，我们通过在内存中对`malloc_block`结构的签名实现一个简单的检查。可以添加日志消息，甚至断点来调试第二个`free`函数的来源：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unfortunately, this mechanism may only work in some cases. In fact, if the block
    that was previously freed is assigned again by the allocator, it would be impossible
    to detect further uses of its original reference, and a second `free` would cause
    the second reference to be lost as well. For the same reason, use-after-`free`
    errors are hard to diagnose, as there is no way to tell that a freed memory block
    has been accessed again. It is possible to paint freed blocks with a recognizable
    pattern so that if the content of the block is altered after `free` has been called,
    the next invocation of `malloc` on that block can detect the alteration. However,
    this again does not guarantee detection of all the cases and only works for write
    accesses to a freed pointer; additionally, this would not be able to identify
    all the cases where freed memory is accessed for reading.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种机制可能只在某些情况下有效。事实上，如果之前释放的块被分配器再次分配，将无法检测到其原始引用的进一步使用，第二次`free`会导致第二个引用也丢失。同样，由于没有方法可以判断已释放的内存块是否再次被访问，使用-after-`free`错误也难以诊断。可以通过在`free`调用后用可识别的模式标记释放的块，这样如果块的
    内容在`free`调用后被更改，那么在该块上调用`malloc`的下一个实例可以检测到更改。然而，这并不能保证检测到所有情况，并且仅适用于对释放的指针的写访问；此外，这无法识别所有读取访问释放内存的情况。
- en: Memory leaks are easy to diagnose but sometimes difficult to locate. With limited
    resources, it is often the case that forgetting to free allocated memory uses
    up all the available heap very quickly. While there are techniques used to track
    down allocations, it is often sufficient to break into the software with the debugger
    and look for repeated allocations of the same size to track down the buggy caller.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏容易诊断，但有时难以定位。资源有限时，忘记释放分配的内存很快就会耗尽所有可用的堆。虽然有一些用于追踪分配的技术，但通常足够使用调试器中断软件，寻找相同大小的重复分配来追踪有问题的调用者。
- en: In conclusion, due to their catastrophic and hideous nature, dynamic memory
    bugs may be one of the biggest challenges on embedded systems. Therefore, writing
    safer application code is often less expensive in terms of resources than hunting
    for memory bugs at the system level – for example, instrumenting the allocator.
    Analyzing the lifetime of each allocated object thoroughly, and making the logic
    as clear and readable as possible, can prevent most of the problems related to
    pointer handling and save a lot of time that would otherwise be spent debugging.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，由于动态内存错误的灾难性和恐怖性，它们可能是嵌入式系统上最大的挑战之一。因此，编写更安全的应用程序代码在资源方面通常比在系统级别寻找内存错误（例如，对分配器进行仪器化）要便宜得多。彻底分析每个分配对象的生存期，并尽可能使逻辑清晰易读，可以防止大多数与指针处理相关的问题，并节省大量本应花费在调试上的时间。
- en: The memory protection unit
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存保护单元
- en: In a system without virtual address mapping, it is harder to create a separation
    between sections that can be accessed by the software at runtime. The memory protection
    unit, often referred to as the MPU, is an optional component present in many ARM-based
    microcontrollers. The MPU is used to separate sections in memory by setting local
    permissions and attributes. This mechanism has several uses in real-life scenarios,
    such as preventing access to memory when the CPU is running in user mode, or preventing
    fetching code from being executed from writable locations in RAM. When the MPU
    is enabled, it enforces the rules by triggering a memory exception interrupt when
    those rules are violated.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有虚拟地址映射的系统上，创建可以由软件在运行时访问的段的分离更困难。内存保护单元，通常称为MPU，是许多基于ARM的微控制器中可选的组件。MPU通过设置本地权限和属性来分离内存中的段。这种机制在实际场景中有几种用途，例如，当CPU在用户模式下运行时防止访问内存，或者防止从RAM的可写位置获取可执行代码。当MPU启用时，它通过在违反规则时触发内存异常中断来强制执行这些规则。
- en: While commonly used by operating systems to create process stack separation
    and enforce privileged access to system memory, the MPU can be useful in a number
    of other cases, including bare-metal applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然操作系统通常用于创建进程堆栈分离并强制对系统内存的特权访问，但MPU在许多其他情况下也很有用，包括裸机应用程序。
- en: MPU configuration registers
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MPU配置寄存器
- en: 'In the Cortex-M, the control block region related to MPU configuration is located
    in the system control block, starting at address `0xE000ED90`. Five registers
    are used to access the MPU:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cortex-M中，与MPU配置相关的控制块区域位于系统控制块中，起始地址为`0xE000ED90`。使用五个寄存器来访问MPU：
- en: The `0x00`) contains information about the availability of the MPU system and
    the number of regions supported. This register is also available on systems without
    an MPU to indicate that the functionality is not supported.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x00`包含有关MPU系统可用性和支持的区域数量的信息。此寄存器也适用于没有MPU的系统，以指示不支持该功能。'
- en: The `0x04`) is used to activate the MPU system and enable the default background
    mapping for all the regions that are not explicitly mapped in the MPU. If background
    mapping is not enabled, accessing non-mapped regions is not allowed.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x04`用于激活MPU系统并启用所有未明确映射在MPU中的区域的默认背景映射。如果未启用背景映射，则不允许访问未映射的区域。'
- en: The `RNR` offset `0x08`) is used to select the region to configure.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RNR`偏移量`0x08`用于选择要配置的区域。'
- en: The `RBAR` offset `0x0C`) can be accessed to change the base address of the
    selected region.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`RBAR`偏移量`0x0C`来访问以更改所选区域的基本地址。
- en: The `RASR` offset `0x10`) defines the permissions, attributes, and size of the
    selected region.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RASR`的偏移量`0x10`定义了所选区域的权限、属性和大小。'
- en: Programming the MPU
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程MPU
- en: 'The MPU of Cortex-M microcontrollers supports up to eight different programmable
    regions. A function that enables the MPU and sets up all the regions can be implemented
    and invoked at the beginning of program. The MPU registers are mapped in HAL libraries,
    but in this case, we are going to define our own version and access them directly:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Cortex-M微控制器的MPU支持多达八个不同的可编程区域。可以在程序开始时实现并调用一个启用MPU并设置所有区域的函数。MPU寄存器在HAL库中映射，但在此情况下，我们将定义自己的版本并直接访问它们：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In our example, we used the following defined bit-field value definitions to
    set the right attributes in `RASR`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了以下定义的位字段值定义来在`RASR`中设置正确的属性：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The possible sizes, which should end up in the size field of `RASR` in bits
    1:5, are coded as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的大小，最终应在`RASR`的大小字段中以比特1:5结束，编码如下：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first thing to do when we enter the `mpu_enable` function is to ensure
    that the feature is available on our target, by checking the `MPU_TYPE` register:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入`mpu_enable`函数时，首先要做的是确保我们的目标上具有该功能，通过检查`MPU_TYPE`寄存器：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In order to configure the MPU, we must ensure that it is disabled while we
    change the base addresses and the attributes of each region:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置MPU，我们必须确保在更改基本地址和每个区域的属性时，它处于禁用状态：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The flash region that contains the executable code can be marked as read-only
    region `0`. The values for the `RASR` attributes are as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 包含可执行代码的闪存区域可以被标记为只读区域`0`。`RASR`属性的值如下：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The whole RAM region can be mapped as read-write. If we do not need to execute
    code from RAM, we can set the `1` in this case:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 整个RAM区域可以映射为读写。如果我们不需要从RAM中执行代码，我们可以在这种情况下设置`1`：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since memory mapping is processed in the same order as memory region numbers,
    we can use region `2` to create an exception within region `1`. Regions with higher
    numbers have priority over regions with lower numbers, so exceptions can be created
    within an existing mapping with a lower number.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存映射是按照内存区域编号的顺序处理的，我们可以使用区域`2`在区域`1`内创建一个异常。编号较高的区域比编号较低的区域具有更高的优先级，因此可以在具有较低编号的现有映射内创建异常。
- en: 'Region `2` is used to define a guard region as a lower boundary for the stack
    growing backward, the purpose of which is to intercept stack overflows. In fact,
    if at any moment the program tries to access the guard region, it triggers an
    exception and the operation fails. In this case, the guard region occupies 1 KB
    at the bottom of the stack. It has no access permissions configured in its attributes.
    The MPU ensures that the region is not accessible at runtime:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 区域 `2` 用于定义一个保护区域，作为栈向后增长的底部边界，其目的是拦截栈溢出。实际上，如果程序在任何时刻尝试访问保护区域，则会触发异常，操作失败。在这种情况下，保护区域占据栈底部的
    1 KB。其属性中没有配置访问权限。MPU 确保该区域在运行时不可访问：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we describe the system area as a read-write, non-executable, and non-cacheable
    area so that the program will still be able to access the system registers after
    the MPU has been activated again. We use region `3` for this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将系统区域描述为一个可读写、不可执行且不可缓存的区域，以便在 MPU 再次激活后程序仍然能够访问系统寄存器。我们为此使用区域 `3`：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As a final step, we enable the MPU again. The MPU will allow us to define a
    *background region*, setting the default permissions for those areas that are
    not covered in the active region configurations. In this case, the absence of
    a definition for a background policy results in prohibited access to all the areas
    that are not explicitly mapped:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们再次启用 MPU。MPU 将允许我们定义一个 *背景区域*，为那些在活动区域配置中未覆盖的区域设置默认权限。在这种情况下，背景策略的定义缺失导致所有未明确映射的区域都无法访问：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The helping function that sets the starting address and the attributes for
    the memory regions looks like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 设置内存区域起始地址和属性的辅助函数看起来如下：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The value used to set attributes and sizes in `MPU_RASR` in this example is
    defined according to the structure of the register itself. `MPU_RASR` is a bit-field
    register, containing the following fields:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中用于设置 `MPU_RASR` 中属性和大小的值是根据寄存器本身的结构定义的。`MPU_RASR` 是一个位域寄存器，包含以下字段：
- en: '**Bit 0**: The enable/disable region.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位 0**：启用/禁用区域。'
- en: '**Bits 1:5**: The size of the partition (see the special values to assign to
    this field).'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位 1:5**：分区的大小（请参阅分配给此字段的特殊值）。'
- en: '**Bits 16:18**: Indicate whether the memory is bufferable, cacheable, and shared,
    respectively. Devices and system registers should be marked as non-cacheable at
    all times to guarantee the strict order of the transaction, as explained at the
    beginning of this chapter.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位 16:18**：分别指示内存是否可缓冲、可缓存和共享。设备和系统寄存器应始终标记为不可缓存，以确保事务的严格顺序，如本章开头所述。'
- en: '**Bits 24:26**: Access permissions (read/write), separated for user and supervisor
    mode.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位 24:26**：访问权限（读/写），分别针对用户模式和监督模式。'
- en: '`XN` flag).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XN` 标志）。'
- en: 'It is now possible to write a program that overflows the stack and see the
    difference in the debugger when the `mpu_enable` function is called and when it
    is not. If the MPU is available on the target, it is now able to intercept stack
    overflows, triggering an exception in the CPU:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以编写一个溢出栈的程序，并在调用 `mpu_enable` 函数和不调用时，在调试器中看到差异。如果目标上可用 MPU，现在它能够拦截栈溢出，在
    CPU 中触发异常：
- en: '![Figure 5.6 – The guard region is marked as inaccessible in the MPU to prevent
    stack overflows](img/B18730_05_06.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 在 MPU 中将保护区域标记为不可访问，以防止栈溢出](img/B18730_05_06.jpg)'
- en: Figure 5.6 – The guard region is marked as inaccessible in the MPU to prevent
    stack overflows
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 在 MPU 中将保护区域标记为不可访问，以防止栈溢出
- en: The configuration we used in this case for the MPU is very strict, not allowing
    access to any memory, except for the regions mapping flash and RAM. The extra
    1-KB guard region ensures that we can detect stack overflows at runtime. This
    configuration in fact introduces an artificial separation between the two regions
    allocated for heap and stack areas, in a physically continuous space, by introducing
    a block that replicates inaccessible blocks in between. Although allocations in
    the heap exceeding the heap limit will not directly trigger an overflow, any memory
    access in the guard region will cause a memory fault.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个案例中为 MPU 使用的配置非常严格，不允许访问任何内存，除了映射闪存和 RAM 的区域。额外的 1-KB 保护区域确保我们可以在运行时检测到栈溢出。实际上，这种配置通过引入一个复制不可访问块的块，在物理上连续的空间中引入了两个分配给堆和栈区域的区域之间的虚假分离。尽管超出堆限制的堆分配不会直接触发溢出，但保护区域中的任何内存访问都会导致内存故障。
- en: In real applications, the MPU configuration may be more complex and even change
    its values at runtime. In [*Chapter 10*](B18730_10.xhtml#_idTextAnchor357), *Parallel
    Tasks and Scheduling*, for example, we will explain how the MPU can be used to
    isolate thread address spaces in a real-time operating system.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，MPU的配置可能更加复杂，甚至可能在运行时改变其值。例如，在[*第10章*](B18730_10.xhtml#_idTextAnchor357)，*并行任务和调度*中，我们将解释如何在实时操作系统中使用MPU来隔离线程地址空间。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Memory management in an embedded system is the source of the most critical bugs,
    and for this reason, particular attention must be dedicated to designing and implementing
    the correct solutions for the platform in use and application purposes. The execution
    stack should be carefully placed, sized, and delimited when possible.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统中的内存管理是大多数关键错误的来源，因此，必须特别关注为使用的平台和应用目的设计和实现正确的解决方案。当可能时，应仔细放置、调整大小和限定执行堆栈。
- en: Systems not providing dynamic allocations are safer, but embedded systems with
    higher complexity benefit from dynamic allocation techniques. Programmers must
    be aware that errors in memory handling can be critical for a system and very
    difficult to spot, so extra care is required when code handles dynamically allocated
    pointers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不提供动态分配的系统更安全，但具有更高复杂性的嵌入式系统从动态分配技术中受益。程序员必须意识到，内存处理中的错误可能对系统至关重要，并且非常难以发现，因此在代码处理动态分配的指针时需要格外小心。
- en: The MPU can be a vital tool to enforce access permissions and attributes on
    memory regions, and it can be used for several purposes. In the example shown,
    we implemented an MPU-based mechanism to enforce a physical boundary for the stack
    pointer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: MPU可以是一个重要的工具，用于在内存区域上强制执行访问权限和属性，并且它可以用于多个目的。在下面的示例中，我们实现了一个基于MPU的机制来强制执行堆栈指针的物理边界。
- en: In the next chapter, we will examine other common components included in modern
    microcontrollers. We will learn how to handle clock settings, interrupt priorities,
    general-purpose I/O communication, and other optional features.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将检查现代微控制器中包含的其他常见组件。我们将学习如何处理时钟设置、中断优先级、通用I/O通信以及其他可选功能。
- en: Part 3 – Device Drivers and Communication Interfaces
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分 – 设备驱动程序和通信接口
- en: This part explains how to program interface and device drivers typical of an
    embedded system. All the system communication from and to the outside world, up
    to distributed systems communicating via TCP/IP, will be covered in this part,
    with particular attention paid to increasing the security of IoT solutions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分解释了如何编写嵌入式系统典型的接口和设备驱动程序。本部分将涵盖从外部世界到系统的所有系统通信，直至通过TCP/IP进行通信的分布式系统，并将特别关注提高物联网解决方案的安全性。
- en: 'This part has the following chapters:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B18730_06.xhtml#_idTextAnchor194), *General-Purpose Peripherals*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18730_06.xhtml#_idTextAnchor194)，*通用外围设备*'
- en: '[*Chapter 7*](B18730_07.xhtml#_idTextAnchor230), *Local Bus Interfaces*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18730_07.xhtml#_idTextAnchor230)，*局部总线接口*'
- en: '[*Chapter 8*](B18730_08.xhtml#_idTextAnchor275), *Power Management and Energy
    Saving*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18730_08.xhtml#_idTextAnchor275)，*电源管理和节能*'
- en: '[*Chapter 9*](B18730_09.xhtml#_idTextAnchor311), *Distributed Systems and IoT
    Architecture*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18730_09.xhtml#_idTextAnchor311)，*分布式系统和物联网架构*'
