<html><head></head><body>
		<div><h1 id="_idParaDest-745" class="chapter-number"><a id="_idTextAnchor745"/>21</h1>
			<h1 id="_idParaDest-746"><a id="_idTextAnchor746"/>STL Interaction with Concepts and Coroutines</h1>
			<p>This chapter will explore the interplay between the STL and two of C++’s advanced features: concepts and coroutines. This chapter is designed to deepen your understanding of how these modern C++ features enhance and interact with the STL.</p>
			<p>We begin by learning about concepts, starting with an introduction and progressively exploring their role in refining STL algorithm constraints, enhancing data structures, and developing custom concepts. This section is crucial for grasping how explicit type constraints can lead to more robust and readable code.</p>
			<p>Following this, we focus on coroutines, providing a refresher before examining their integration with STL algorithms and data structures. This includes exploring potential synergies with ranges and views, culminating in discussing how coroutines might herald a paradigm shift in C++ programming.</p>
			<p>This chapter will provide a comprehensive understanding and practical insights into using these features effectively, highlighting their importance in modern C++ development and their potential challenges.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Concepts</li>
				<li>Coroutines</li>
			</ul>
			<h1 id="_idParaDest-747"><a id="_idTextAnchor747"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub:</p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>
			<h1 id="_idParaDest-748"><a id="_idTextAnchor748"/>Concepts</h1>
			<p>The introduction of concepts in C++20 marked a pivotal step towards safer and more expressive templated programming. With their inherent ability to specify constraints on template arguments, concepts promise to reshape how we interact with and utilize the <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>). Let’s discover how concepts intertwine with the rich tapestry of STL algorithms and data structures to create a more robust and declarative C++ programming paradigm.</p>
			<h2 id="_idParaDest-749"><a id="_idTextAnchor749"/>A brief introduction to concepts</h2>
			<p><strong class="bold">Concepts</strong> provide<a id="_idIndexMarker1133"/> a mechanism to specify and check constraints on template arguments. Essentially, they allow developers to assert requirements about the types passed to a template. Concepts aim to make template errors more readable, help avoid common pitfalls, and promote the creation of more generic and reusable code.</p>
			<p>Consider the following concept for an arithmetic type:</p>
			<pre class="source-code">
template&lt;typename T&gt;
concept Arithmetic = std::is_arithmetic_v&lt;T&gt;;</pre>			<p>Using this concept, one can constrain a function only to accept arithmetic types:</p>
			<pre class="source-code">
template&lt;Arithmetic T&gt;
T add(T a, T b) { return (a + b); }</pre>			<h2 id="_idParaDest-750"><a id="_idTextAnchor750"/>Refined constraints in STL algorithms</h2>
			<p>STL algorithms, historically, have relied on complex, sometimes nebulous requirements for their <a id="_idIndexMarker1134"/>template parameters. With concepts, these requirements become explicit and understandable. For instance, the <code>std::sort</code> algorithm requires random access iterators, which can now be asserted using concepts. This leads to more precise error messages if one mistakenly uses a list (which only provides bidirectional iterators).</p>
			<h2 id="_idParaDest-751"><a id="_idTextAnchor751"/>Effectively constraining templates</h2>
			<p>When<a id="_idIndexMarker1135"/> working with C++ template programming, ensuring that a given type satisfies a specific set of requirements has historically been challenging. Before the introduction of concepts, developers would rely on complex techniques involving <strong class="bold">substitution failure is not an error</strong> (<strong class="bold">SFINAE</strong>) or specialized trait classes to impose type constraints. These methods were verbose and error-prone, often resulting in convoluted error messages that were difficult to decipher.</p>
			<p>Concepts allow developers to define a set of predicates that a type must satisfy, offering a more structured and readable way to constrain templates. Using concepts, you can specify the requirements that template arguments must meet. When a type does not match the constraints defined by a concept, the compiler will reject the template instantiation, producing a more straightforward and more meaningful error message. This enhances the template code’s readability, maintainability, and robustness. With concepts, the compiler can quickly ascertain the suitability of a type for a given template, ensuring that only appropriate types are utilized, thereby minimizing the potential for runtime errors or undefined behavior.</p>
			<p>Here’s a code example that demonstrates the use of concepts and how the same task had to be carried out before the introduction of concepts:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
// Create a class that is not inherently printable.
struct NotPrintable
{
  int foo{0};
  int bar{0};
};
// Concept definition using the 'requires' clause
template &lt;typename T&gt;
concept Printable = requires(T t) {
  // Requires that t can be printed to std::cout
  std::cout &lt;&lt; t;
};
// Before C++20:
// A Function template that uses SFINAE to implement a
// "Printable concept"
template &lt;typename T,
          typename = typename std::enable_if&lt;std::is_same&lt;
              decltype(std::cout &lt;&lt; std::declval&lt;T&gt;()),
              std::ostream &amp;&gt;::value&gt;::type&gt;
void printValueSFINAE(const T &amp;value) {
  std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; "\n";
}
// After C++20:
// A Function template that uses the Printable concept
template &lt;Printable T&gt; void printValue(const T &amp;value) {
  std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; "\n";
}
int main() {
  const int num = 42;
  const NotPrintable np;
  const std::string str = "Hello, Concepts!";
  // Using the function template with SFINAE
  printValueSFINAE(num);
  // This line would fail to compile:
  // printValueSFINAE(np);
  printValueSFINAE(str);
  // Using the function template with concepts
  printValue(num);
  // This line would fail to compile
  // printValue(np);
  printValue(str);
  return 0;
}</pre>			<p>Here is the example output:</p>
			<pre class="console">
Value: 42
Value: Hello, Concepts!
Value: 42
Value: Hello, Concepts!</pre>			<p>In this example, we define a concept called <code>Printable</code> using the required clause. The <code>Printable</code> concept checks if a type can be printed to <code>std::cout</code>. We then have two function templates, <code>printValue</code>, and <code>printValueSFINAE</code>, that print a value if it satisfies the concept or the SFINAE condition, respectively.</p>
			<p>When using the <code>printValue</code> function template with the <code>Printable</code> concept, the compiler will ensure that the type passed to it can be printed, and if not, it will produce a clear error message. This makes the code more readable and provides meaningful error messages.</p>
			<p>On the other <a id="_idIndexMarker1136"/>hand, when using the <code>printValueSFINAE</code> function template, we rely on SFINAE to achieve the same task. This approach is more verbose and error-prone, as it involves complex <code>std::enable_if</code> constructs and may lead to cryptic error messages when the constraints are unmet.</p>
			<p>By comparing these two approaches, you can see how concepts improve the readability, maintainability, and robustness of C++ template code, making it easier to specify and enforce type requirements.</p>
			<h2 id="_idParaDest-752"><a id="_idTextAnchor752"/>Enhanced data structures with explicit requirements</h2>
			<p>STL<a id="_idIndexMarker1137"/> containers, such as <code>std::vector</code> or <code>std::map</code>, often have their requirements for stored types, such as being copy-constructible or assignable. Concepts can articulate these requirements with great clarity.</p>
			<p>Imagine a custom container that necessitates its elements to be default constructible. This requirement can be eloquently expressed with concepts, ensuring safer and more predictable container behavior.</p>
			<h2 id="_idParaDest-753"><a id="_idTextAnchor753"/>Custom concepts and STL interactions</h2>
			<p>One <a id="_idIndexMarker1138"/>of the strengths of concepts is that they’re not limited to the ones provided by the standard library. Developers can create custom concepts tailored to specific needs, ensuring that STL structures and algorithms can be adapted to unique and complex scenarios without sacrificing type safety.</p>
			<p>For instance, if a particular algorithm demands types with a specific interface (such as having a <code>draw()</code> member function), one can design a concept to enforce this, leading to more intuitive and self-documenting code. Let's look at a code example:</p>
			<pre class="source-code">
#include &lt;concepts&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
template &lt;typename T&gt;
concept Drawable = requires(T obj) {
  { obj.draw() } -&gt; std::convertible_to&lt;void&gt;;
};
class Circle {
public:
  void draw() const { std::cout &lt;&lt; "Drawing a circle.\n"; }
};
class Square {
public:
  // No draw() member function
};
template &lt;Drawable T&gt; void drawShape(const T &amp;shape) {
  shape.draw();
}
int main() {
  Circle circle;
  Square square;
  drawShape(circle);
  // Uncommenting the line below would result in
  // 'drawShape': no matching overloaded function found:
  // drawShape(square);
  return 0;
}</pre>			<p>Here is the example output:</p>
			<pre class="console">
Drawing a circle.</pre>			<p>In the<a id="_idIndexMarker1139"/> preceding code example, we do the following:</p>
			<ul>
				<li>We define a custom concept called <code>Drawable</code>, which requires a type with a <code>draw()</code> member function returning <code>void.</code></li>
				<li>We create two example classes: <code>Circle</code>, which satisfies the <code>Drawable</code> concept by having a <code>draw()</code> member function, and <code>Square</code>, which does not satisfy the concept because it lacks the <code>draw()</code> member function.</li>
				<li>We define a generic function called <code>drawShape</code>, which takes a <code>Drawable</code> type as a parameter and calls its <code>draw()</code> member function.</li>
				<li>In the <code>main</code> function, we create instances of <code>Circle</code> and <code>Square</code> and demonstrate that <code>drawShape</code> can be called with a <code>Drawable</code> type (e.g., <code>Circle</code>) but not with a type that does not satisfy the <code>Drawable</code> concept (e.g., <code>Square</code>).</li>
			</ul>
			<p>This example illustrates how custom concepts can enforce specific interface requirements, ensuring type safety and making the code more intuitive and self-documenting when working with complex scenarios and algorithms in C++.</p>
			<h2 id="_idParaDest-754"><a id="_idTextAnchor754"/>Potential challenges and caveats</h2>
			<p>While concepts <a id="_idIndexMarker1140"/>are undeniably powerful, there are a few considerations to be made:</p>
			<ul>
				<li><strong class="bold">Complexity</strong>: Designing intricate custom concepts can be challenging and may steepen the learning curve for newcomers</li>
				<li><strong class="bold">Compile times</strong>: As with most template-based features, over-reliance or misuse can increase compilation times</li>
				<li><strong class="bold">Backward compatibility</strong>: Older codebases may require refactoring to leverage or comply fully with new concept-driven constraints</li>
			</ul>
			<p>This section provided a window into a powerful feature in C++ that allows us to specify constraints on template parameters. We began with a brief introduction to concepts, understanding their role in enhancing the expressiveness and safety of our code. We then explored how refined constraints can be applied in STL algorithms, leading to more robust and readable code. We also learned how to constrain templates effectively, which is crucial for preventing the misuse of our code and ensuring that it behaves as expected.</p>
			<p>However, we also acknowledged the potential challenges and caveats associated with concepts. While they offer many benefits, using them judiciously is important to avoid unnecessary complexity and potential pitfalls.</p>
			<p>The knowledge gained from this section is invaluable as it equips us with the tools to write safer, more expressive, and more efficient code using the STL. It also prepares us for the next section, where we will explore another exciting feature of C++: coroutines.</p>
			<p>The next section will refresh our understanding of coroutines and discuss their integration with STL algorithms and data structures. We will also explore potential synergies with ranges and views, which can lead to even more efficient and elegant code. Finally, we will look at how coroutines represent a paradigm shift in how we write asynchronous code.</p>
			<h1 id="_idParaDest-755"><a id="_idTextAnchor755"/>Coroutines</h1>
			<p>The<a id="_idIndexMarker1141"/> integration of coroutines into C++20 ushers in a new paradigm for asynchronous programming that’s more readable and intuitive. By allowing functions to be suspended and resumed, coroutines offer an alternative to the callback-heavy style often seen in asynchronous C++ code. While transformative in its own right, this evolution also provides fresh, innovative ways to interact with the venerable STL. Examining the interaction of coroutines with STL algorithms and data structures reveals how they simplify asynchronous operations.</p>
			<h2 id="_idParaDest-756"><a id="_idTextAnchor756"/>Understanding coroutines – a refresher</h2>
			<p>A <code>co_await</code>, <code>co_return</code>, and <code>co_yield</code>:</p>
			<ul>
				<li><code>co_await</code>: Suspends the current coroutine until the awaited expression is ready, at which point the coroutine resumes</li>
				<li><code>co_return</code>: This is used to finish the coroutine, potentially returning a value</li>
				<li><code>co_yield</code>: Produces a value in a generator-like fashion, allowing iteration over a coroutine</li>
			</ul>
			<h2 id="_idParaDest-757"><a id="_idTextAnchor757"/>STL algorithms and coroutine integration</h2>
			<p>With<a id="_idIndexMarker1142"/> coroutines, STL algorithms that previously demanded a more convoluted asynchronous approach can now be elegantly written with direct, linear logic. Consider algorithms that operate on sequences or ranges; they can be combined with coroutines to asynchronously generate values.</p>
			<p>For instance, a coroutine could asynchronously produce values and then process them using <code>std::transform</code> or <code>std::for_each</code>, weaving asynchronous code seamlessly with synchronous STL algorithms.</p>
			<h2 id="_idParaDest-758"><a id="_idTextAnchor758"/>Coroutines and STL data structures</h2>
			<p>The <a id="_idIndexMarker1143"/>magic of coroutines also touches the realm of STL data structures. Coroutines present an intriguing potential for containers such as <code>std::vector</code> or <code>std::list: </code><code>populating</code> (asynchronously).</p>
			<p>Imagine a scenario where data must be fetched from a network source and stored in <code>std::vector</code>. A coroutine can be used to fetch the data asynchronously, yielding values as they arrive, and then these values can be directly inserted into the vector. This blend of asynchronicity with the directness of STL data structures simplifies code and reduces cognitive overhead.</p>
			<h2 id="_idParaDest-759"><a id="_idTextAnchor759"/>Potential synergies with ranges and views</h2>
			<p>As the C++ language <a id="_idIndexMarker1144"/>evolves, other features, such as ranges and views, combined with coroutines, can offer a more expressive way to handle data manipulation and transformation. Coroutines can generate ranges, which can be lazily evaluated, filtered, and transformed using views, resulting in a robust and composable asynchronous programming model.</p>
			<p>Let’s look at the following code example that involves the following steps:</p>
			<ul>
				<li><code>std::vector&lt;int&gt;</code> to store a sequence of numbers.</li>
				<li><strong class="bold">Coroutine</strong>: A generator that asynchronously generates numbers to populate our vector.</li>
				<li><code>std::ranges::copy_if</code>.</li>
				<li><code>std::views::transform</code>, we’ll multiply each number by two. First, we must create our <code>generator</code> class with a special <code>promise_type</code> structure that our coroutine will use. The generator class template and its nested <code>promise_type</code> structure in this code are key components in implementing a coroutine for generating a sequence of values in C++.</li>
			</ul>
			<p>A <code>T</code>, one at a time, upon request. It encapsulates the coroutine’s state and provides an interface to control its execution and access the yielded values.</p>
			<p>The <code>promise_type</code> nested <a id="_idIndexMarker1146"/>within the generator is the coroutine’s lifecycle and state management backbone. It holds the current value to be yielded (value) and defines several key functions:</p>
			<ul>
				<li><code>get_return_object</code>: Returns the generator object associated with this coroutine</li>
				<li><code>initial_suspend</code> and <code>final_suspend</code>: Control the coroutine’s execution, suspending it initially and after completion</li>
				<li><code>unhandled_exception</code>: Defines behavior for unhandled exceptions, terminating the program</li>
				<li><code>return_void</code>: A placeholder for when the coroutine reaches its end</li>
				<li><code>yield_value</code>: This is called when a value is yielded (co_yield), suspending the coroutine and storing the yielded value</li>
			</ul>
			<p>The code example below is broken into several sections (the complete example can be found in the book's GitHub repository):</p>
			<pre class="source-code">
template &lt;typename T&gt; class generator {
public:
  struct promise_type {
    T value;
    auto get_return_object() {
      return generator{handle_type::from_promise(*this)};
    }
    auto initial_suspend() {
      return std::suspend_always{};
    }
    auto final_suspend() noexcept {
      return std::suspend_always{};
    }
    void unhandled_exception() { std::terminate(); }
    void return_void() {}
    auto yield_value(T x) {
      value = x;
      return std::suspend_always{};
    }
  };
  using handle_type = std::coroutine_handle&lt;promise_type&gt;;
  generator(handle_type h) : m_handle(h) {}
  generator(const generator &amp;) = delete;
  generator(generator &amp;&amp;o) noexcept
      : m_handle(std::exchange(o.m_handle, {})) {}
  ~generator() {
    if (m_handle) m_handle.destroy();
  }
  bool next() {
    m_handle.resume();
    return !m_handle.done();
  }
  T value() const { return m_handle.promise().value; }
private:
  handle_type m_handle;
};</pre>			<p>The <a id="_idIndexMarker1147"/>preceding code defines a generic template class called <code>generator</code>. This class is instantiated as the return type of the <code>generate_numbers</code> function, which creates a sequence of integers from start to end. When called, it initiates a coroutine that iteratively yields integers within the specified range. Each iteration suspends the coroutine, making the current value available to the caller. The generator class provides mechanisms to resume the coroutine (<code>next()</code>) and retrieve the current value (<code>value()</code>). The generator’s constructor, move constructor, destructor, and deleted copy constructor manage the coroutine’s lifecycle and ensure proper resource management.</p>
			<p>That was the hard part. Now, we can get to work building and using our coroutine:</p>
			<pre class="source-code">
generator&lt;int&gt; generate_numbers(int start, int end) {
  for (int i = start; i &lt;= end; ++i) { co_yield i; }
}
int main() {
  std::vector&lt;int&gt; numbers;
  auto gen = generate_numbers(1, 10);
  while (gen.next()) { numbers.push_back(gen.value()); }
  std::vector&lt;int&gt; evenNumbers;
  std::ranges::copy_if(numbers,
                       std::back_inserter(evenNumbers),
                       [](int n) { return n % 2 == 0; });
  const auto transformed =
      evenNumbers |
      std::views::transform([](int n) { return n * 2; });
  for (int n : transformed) { std::cout &lt;&lt; n &lt;&lt; " "; }
  return 0;
}</pre>			<p>Here is the example output:</p>
			<pre class="console">
4 8 12 16 20</pre>			<p>In this example, we <a id="_idIndexMarker1148"/>did the following:</p>
			<ul>
				<li>We created a <code>generator</code> class to represent asynchronous generators.</li>
				<li>We used the coroutine <code>generate_numbers</code> to asynchronously generate numbers from 1 to 10.</li>
				<li>With ranges, we filtered only even numbers and stored them in another vector.</li>
				<li>Using views, we transformed these even numbers by multiplying them by two.</li>
				<li>Lastly, we output the transformed sequence.</li>
			</ul>
			<h2 id="_idParaDest-760"><a id="_idTextAnchor760"/>Looking ahead – a paradigm shift</h2>
			<p>Coroutines in C++ represent a significant advancement in the domain of asynchronous programming. By introducing a standardized way to handle asynchronous tasks, coroutines facilitate writing nonblocking, efficient, and maintainable code. When used in conjunction with the STL, coroutines have the potential to streamline complex operations, transforming the landscape of C++ programming.</p>
			<p>The STL provides a robust framework for data manipulation and algorithm implementation. The introduction of coroutines enhances this framework by offering a concurrency model that is less error-prone and more intuitive than traditional threading mechanisms. This synergy allows for developing sophisticated asynchronous programs to leverage the full power of the STL’s containers, iterators, and algorithms without compromising performance.</p>
			<p>As coroutines become more integrated within the STL, we anticipate a paradigm shift where high-performance code will not only be characterized by its speed but also by its clarity and modular structure. The adoption of coroutines is poised to expand, driven by their ability to produce scalable and responsive software.</p>
			<p>The future iterations of the C++ standard will likely introduce more features that complement the coroutine–STL interface, providing developers with a richer toolkit. This evolution will solidify C++’s role as a premier language for developing high-performance, asynchronous applications. The commitment to continual improvement within the C++ community maintains the language’s relevance and efficacy in solving modern programming challenges.</p>
			<h1 id="_idParaDest-761"><a id="_idTextAnchor761"/>Summary</h1>
			<p>This chapter uncovered the integration of C++20’s concepts and coroutines with the STL. We began by exploring the role of concepts in templated programming. Concepts strengthen code robustness by enforcing type constraints and enhancing the expressivity and safety of template use. They replace error-prone SFINAE techniques with a more readable and declarative syntax. We saw how concepts improve the clarity of algorithms’ requirements, leading to more maintainable code.</p>
			<p>Next, we examined how coroutines introduce a new level of sophistication to asynchronous programming in C++. We discussed the mechanics of coroutines, emphasizing the use of <code>co_await</code>, <code>co_return</code>, and <code>co_yield</code> for creating nonblocking operations. We looked at how coroutines can interact with STL data structures and algorithms, allowing asynchronous and synchronous code to blend seamlessly.</p>
			<p>Understanding the interplay between concepts, coroutines, and the STL is crucial. It enables us to write code that is not just performant but also clear and reliable. This knowledge equips us to tackle complex programming scenarios with confidence and foresight.</p>
			<p>Next, we will focus on applying execution policies that enable parallelism in STL algorithms. The chapter will guide us through the nuances of parallel execution policies, the role of <code>constexpr</code> in enhancing compile-time optimizations, and the best practices for achieving optimal performance in concurrent environments.</p>
		</div>
	</body></html>