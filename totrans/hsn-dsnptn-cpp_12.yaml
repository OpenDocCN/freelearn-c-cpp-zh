- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Friend Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to talk about making friends. We mean C++ friends
    here, not friends of C++ (you find those in your local C++ users group). In C++,
    friends of classes are functions or other classes that are granted special access
    to the class. In that way, they are not so different from your friends. But C++
    can just manufacture friends as needed, on demand!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How do friend functions work in C++ and what do they do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should you use friend functions versus class member functions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to combine friends and templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to generate friend functions from templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example code for this chapter can be found at the following GitHub link:
    https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter12.'
  prefs: []
  type: TYPE_NORMAL
- en: Friends in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by reviewing the way in which C++ grants friendship to classes,
    and the effects of this action, as well as when and for what reasons the friendship
    should be used (“my code does not compile until I add `friend` everywhere” is
    not a valid reason, but an indication of a poorly designed interface - redesign
    your classes instead).
  prefs: []
  type: TYPE_NORMAL
- en: How to grant friendship in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *friend* is a C++ concept that applies to classes and affects the access
    to class members (*access* is what `public` and `private` control). Usually, public
    member functions and data members are accessible to anyone, and private ones are
    only accessible to other member functions of the class itself. The following code
    does not compile because the data member `C:x_` is private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to solve this particular problem is to make `increase()` a
    member function, but let’s stay with this version for a moment. The other option
    is to relax access and make `C::x_` public. That is a bad idea because it exposes
    `x_` - not just to `increase()`, but to any other code out there that wants to
    directly modify an object of type `C`. What we need is to make `x_` public, or
    at least accessible, to `increase()` and to nobody else. This is done with a friend
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The friend declaration does nothing more than give the specified function the
    same access as the class member functions get. There is also a form of friend
    declaration that grants friendship not to a function, but to a class; this is
    just a way to grant friendship to all member functions of that class.
  prefs: []
  type: TYPE_NORMAL
- en: Friends versus member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do have to come back to the question, why not just make `increase()` a member
    function of the `C` class? In the example given in the preceding section, there’s
    no reason to, really - `increase()` is clearly meant to be a part of the public
    interface of the `C` class since it’s one of the operations `C` supports. It needs
    special access to do its work, so it should be a member function. There are, however,
    cases where member functions come with limitations, or even cannot be used at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider an addition operator for the same `C` class - it’s what is
    needed to make an expression such as `c1 + c2` compile if both variables are of
    type `C`. The addition, or `operator+()`, can be declared as a member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code compiles and does exactly what we want; there does not seem to be
    anything obviously wrong with it. That’s because there isn’t - so far. But we
    can add more than just objects of type `C`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This also compiles, and points to a subtle detail in the declaration of the
    `C` class - we did not make the `C(int)` constructor explicit. This constructor
    now introduces an implicit conversion from int to `C`, and that is how the expression
    `x + 2` compiles - first, `2` is converted into a temporary object, `C(2)`, using
    the constructor we provided, and second the member function, `x.operator+(const
    C&)`, is called - the right-hand side is the temporary object we just created.
    The temporary object itself is deleted right after the expression is evaluated.
    The implicit conversion from integers is rather broad and might have been an oversight.
    Let’s assume that it wasn’t and that we really want the expression such as `x
    + 2` to compile. What’s not to like, then? Again, nothing so far. The objectionable
    feature of our design is what comes next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If `x + 2` compiles, you would reasonably expect `2 + x` to compile and give
    the same result (there are areas of math where the addition is not commutative,
    but let’s stick with the arithmetic here). The reason it does not compile is that
    the compiler cannot get to `operator+()` in the `C` class from here, and no other
    `operator+()` is available for these arguments. The `x + y` expression, when used
    with member function operators, is just syntactic sugar for the equivalent, if
    verbose, call to `x.operator+(y)`. The same is true for any other binary operator
    such as multiplication or comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'The point is, the member function operator is invoked on the first argument
    of the expression (so technically, `x + y` and `y + x` are not identical; the
    member function is called on different objects, but the implementation is such
    that both give the same result). In our case, the member function would have to
    be invoked on the number `2`, which is an integer and has no member functions
    at all. So, how did the expression `x + 2` compile? Quite simple, really: `x +`
    by itself implies `x.operator+()`, and the argument is whatever comes after `+`.
    In our case, it’s `2`. So, either `x.operator+(2)` compiles, or it does not, but
    in either case, the search for `operator+` to the call is over. The implicit conversion
    from `int` in our `C` class makes this call compile. So, why doesn’t the compiler
    attempt a conversion on the first argument? The answer is, it never does because
    it has no guidance on what to convert it into - there may be any number of other
    types that have the `operator+()` member function, and some of them may accept
    the `C` class as their argument, or something `C` can be converted to. The compiler
    does not attempt to explore the almost infinite number of such possible conversions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use plus in expressions where the first type may be a built-in
    type or any other type that does not have or cannot have a member function of
    `operator+()`, then we have to use a non-member function. No problem; we know
    how to write those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But now we have lost access to the private data member `C::x_`, so our non-member
    `operator+()` does not compile either. We have seen the solution to that problem
    in the previous section - we need to make it a friend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, everything compiles and works as intended - the non-member function `operator+()`
    is simply a non-member function with two arguments of type `const C&`. The rules
    for it are the same as for any other such function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid typing the declaration of the `operator+()` twice if we define
    its body *in situ* (immediately following the declaration, inside the class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The latter example is subtly different from the previous one, but usually, you
    won’t be able to see the difference, so it is simply a matter of style - moving
    the body of the function into the object makes the object itself longer, but defining
    the function outside of the class is more typing (as well as a possible divergence
    between the friend declaration and the actual function, if the code is ever changed).
    We will explain the intricacies of in situ friend declarations in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either way, the friend function is really a part of the class public interface,
    but, for technical reasons, we prefer a non-member function in this case. There
    is even a case when the non-member function is the only choice. Consider the C++
    input/output operators, such as the inserter, or `operator<<()`, which are used
    to write objects out into a stream (for example, `std::cout`). We want to be able
    to print an object of type `C` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no standard `operator<<()` for our type C, so we have to declare our
    own. The inserter is a binary operator, just like plus (it has parameters on either
    side), so, were it a member function, it would have to be one on the left-hand
    side object. Look at the preceding statement - the left-hand side object in the
    `std::cout << c1` expression is not our object, `c1`, but the standard out stream,
    `std::cout`. That’s the object we would have to add a member function to, but
    we cannot - `std::cout` is declared somewhere in the C++ standard library headers,
    and there is no way to extend its interface, at least not in a direct manner.
    Member functions on the `C` class can be declared by us, but this does not help
    - only the member functions of the left-hand side object are considered. The only
    alternative is a non-member function. The first argument has to be `std::ostream&`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has to be declared as a friend since it also needs access to
    the private data of the `C` class. It can also be defined *in situ*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By convention, the return value is the same stream object, so the inserter
    operators can be chained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The way the last statement is interpreted is `(std::cout << c1) << c2`, which
    boils down to `operator<<(operator<<(std::cout, c1), c2)`. The outer `operator<<()`
    is called on the return value of the inner `operator<<()`, which is the same:
    `std::cout`. Again, the inserter is part of the public interface of the `C` class
    - it makes the objects of type `C` printable. However, it has to be a non-member
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: The introduction to the use of `friend` in C++ glossed over several subtle details
    that are occasionally important, so let us spend some time to elucidate them.
  prefs: []
  type: TYPE_NORMAL
- en: Subtle details of friendship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let us talk about the effect of declaring a `friend` function without
    defining it (i.e., without the in situ implementation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, it makes no difference whatsoever whether you put the `friend`
    declaration into the public or private part of the class. But about the `friend`
    declaration itself: which function did we grant access to? This is the first mention
    of an `operator+()` with this signature in our program (its definition must come
    later, after class `C` itself was declared). Turns out that the `friend` statement
    does double duty: it also acts as a forward declaration for the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there is no rule that prevents us from forward-declaring the same
    function ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is no need to use a separate forward declaration just to use `friend`,
    but it may be necessary for other reasons if we want to use `operator+()` earlier
    in our program.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the compiler does not warn you if the `friend` forward declaration
    does not match the function definition, or if the `friend` statement does not
    match the forward declaration. If the function signature in the `friend` statement
    differs from the actual function, you will have granted friendship to some other
    function that is forward-declared but not defined anywhere. It is highly likely
    that you will get a syntax error compiling the real function because it now has
    no special access to the class and can’t access its private members. But the error
    message won’t say anything about a mismatch between the `friend` statement and
    the function definition. You just have to know that if you granted friendship
    to a function and the compiler doesn’t see it, there is a discrepancy between
    the function signature in the `friend` statement and the one in the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if the `friend` statement also defines the function instead of just
    declaring it, then it is not acting as a forward declaration at all. But in this
    case, there is another subtlety, namely, in which scope is the new function defined?
    Consider that if you declare a static function inside a class, that function exists
    in the scope of the class itself. If we have a class `C` with a static function
    `f()`, the proper name of this function outside of the class is `C::f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It is easy to see that the same does not apply to the `friend` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This makes sense, considering that we already saw that the `friend` statement
    without a definition forward-declared a function that is defined outside of the
    class. So, if the `friend` declaration forward-declared a function in the scope
    containing the class (in our case, the global scope, but could have been a `namespace`),
    then the `friend` statement with an in situ definition must define a function
    in the same scope, i.e., it injects a function into the outer scope of the class.
    Right? Yes, but not entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, odds are good that you would never notice the “not entirely” part,
    and everything behaves as if the function was simply injected into the containing
    scope. It takes a rather contrived example to demonstrate what really happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have two `friend` functions, `f()` and `g()`, both are defined at the
    point of declaration. The function `g()` behaves as if it was declared in the
    global scope (or the scope containing the class `C`, if we used a `namespace`).
    But a call to `f()` in the same scope does not compile, and the error message
    is going to be “function f is not declared in this scope” or something to that
    effect. The wording of compiler error messages varies widely, but that is the
    gist of the error: the call to `f()` did not find a function to call. The only
    difference between the functions `f()` and `g()` is their arguments; that turns
    out to be key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, we have to know how the compiler looks up a function name
    when you write a function call such as `f(0)`. First of all, this is a non-member
    function, so the compiler looks only for those (it could also be a functor – a
    class with `operator()`, but that is not important right now since we don’t have
    any). Second, the compiler searches the current scope, the one where the call
    is made, and all containing scopes such as nested function bodies, classes, and
    namespaces) all the way to the global scope. But this is not the end of it: the
    compiler also looks at the arguments of the function and searches the scope (or
    scopes) where each of these argument types is declared. This step is called the
    **argument-dependent lookup** (**ADL**), also known as the **Koenig lookup** after
    Andrew Koenig (who denies inventing it). After all these lookups are done and
    the compiler finds every function with the matching name in one of the scopes
    we just listed, the compiler does the overload resolution on all the functions
    it found (i.e., there is no priority given to any particular scope).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does this have to do with the `friend` functions? Only this: according
    to the standard, a function defined by the `friend` statement is injected into
    the scope containing the class, but *it can be found only by the* *argument-dependent
    lookup*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This explains the behavior we just saw: both the functions `f()` and `g()`
    are injected into the global scope since that is the scope containing class `C`.
    Function `g()` has an argument of type `const C&`, so it is found by the ADL in
    the scope containing the class `C`. Function `f()` has an argument of type `int`,
    and the built-in types are not considered to be declared in any scope, they “just
    are.” Since no ADL can be performed and the functions defined as friends are only
    found by ADL, function `f()` cannot be found at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this situation is very fragile. For example, if we forward-declare
    the same function, it can be found in the scope where it is forward-declared and
    does not need the ADL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The same happens if the `friend` statement only declared the function, to be
    defined later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Why don’t we see this as a problem more often? Because most of the time, functions
    declared as friends inside classes have at least one argument of the type related
    to the class itself (such as a pointer or a reference). Both `operator+()` and
    `operator<<()` we have seen earlier fall into that category. After all, the only
    reason to declare a function as a friend is so it can access private members of
    the class, but the function would not need this access if it did not operate on
    an object of the class type. As a non-member function, how would it get access
    to such an object if not through its arguments? Of course, there are ways, but
    these situations rarely happen in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another subtle and potentially dangerous case happens when a program defines
    its own `operator new`. This is not illegal, class-specific memory allocation
    operators are often necessary. But declaring one is not that simple. There are
    two common uses of a custom `operator new`: the first one is where the operator
    is defined for the class that is being allocated, usually inside the class itself.
    These are called class-specific operators, and they aren’t the subject of our
    interest now. We need to explain the second common case, where the custom `operator
    new` is defined to allocate memory using a specific allocator class. This is how
    it is usually done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several details to note: first, our allocator class `Alloc` has an
    overload for `operator new`: the first argument of every `operator new` is mandatory
    and must be the size of the allocation (the compiler fills that in). The second
    argument (and the third, etc, if necessary) are arbitrary; in our case, it’s the
    pointer to the allocator class that is going to provide memory for this allocation.
    The `operator new` itself is a function in the global scope, and it is declared
    as a friend of class `Alloc`. If you are wondering how you can call the matching
    `operator delete` that we also declared, the answer is you cannot; this operator
    is used only by the compiler itself in case the allocation by `operator new` succeeded
    but the constructor of the new object throws an exception. The compiler will use
    `operator delete` with the arguments matching those of `operator new`. But this
    is not how you will delete this object when its lifetime is over: there is no
    way to add extra arguments to a `delete` expression, so you’ll have to call the
    destructor yourself and then explicitly return the memory to the allocator.'
  prefs: []
  type: TYPE_NORMAL
- en: This works exactly as intended. The compiler looks for the best match for the
    call to `operator new(size_t, Alloc*)` and finds our custom `operator new` in
    the global scope as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you may decide to move the body of the operator into the `friend` statement
    to save some typing as well as avoid the possibility of the `friend` declaration
    and the actual `operator new` definition ever getting out of sync. This is done
    with only a minor change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will almost certainly compile. It will work correctly on some
    compilers and produce horrible memory corruption on others. Unfortunately, those
    other compilers are correct. This is what is going on: the *new expression* (which
    is the standard name for the syntax “`new` … some-type”) has special rules for
    looking up the matching `operator new`. Specifically, the lookup is done in the
    scope of the class that is being constructed (class `C` in our case) and in the
    global scope (these rules are defined in the section `[expr.new]` of the standard).
    Note that there is no lookup in the scope of the arguments to `operator new` itself,
    i.e., no argument-dependent lookup. Since the function defined in situ by the
    `friend` statement can be found only by the argument-dependent lookup, it is not
    found at all. But how does the program compile then? This happens because of another
    overload for `operator new`, the so-called *placement new*. This overload has
    the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is declared in the standard header `<new>`, which is included by so many
    other headers that your program is very likely to include it even if you did not
    do so explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The intent for the placement new is to construct an object in memory that was
    allocated earlier (we used this to construct objects in the space reserved inside
    a class when we studied type erasure in the eponymous chapter earlier). But it
    is also a possible match to our call of operator `new(size_t, Alloc*)` because
    `Alloc*` can be implicitly converted to `void*`. Our own overload, which does
    not require this conversion, would be a better match, but, unfortunately, when
    defined in situ, it is not found by the lookup. The result is that the object
    of type `C` is constructed in the memory already occupied by the allocator object
    itself, corrupting the latter object in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test your compilers using our examples: when defined outside of the
    class, the custom `operator new` should be invoked and the program should work
    as intended. But when defined by the `friend` statement, only the placement new
    should be found (some compilers will also issue a warning about overwriting an
    already constructed object).'
  prefs: []
  type: TYPE_NORMAL
- en: So far, our classes are just regular classes, not templates, and our non-member
    functions have declared friends that were just regular non-template functions.
    Now, let’s consider what, if anything, needs to change if the class becomes a
    template.
  prefs: []
  type: TYPE_NORMAL
- en: Friends and templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both classes and functions in C++ can be templates, and we can have several
    different combinations - a class template can grant friendship to a non-template
    function if its parameter types don’t depend on the template parameters; this
    is not a particularly interesting case, and certainly does not solve any of the
    problems we’re dealing with now. When the friend function needs to operate on
    the template parameter types, making the right friends becomes trickier.
  prefs: []
  type: TYPE_NORMAL
- en: Friends of template classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by making our `C` class into a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We still want to add objects of type `C` and print them out. We have already
    considered reasons why the former is better accomplished with a non-member function,
    and the latter cannot be done in any other way. These reasons remain valid for
    class templates as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'No problem - we can declare template functions to go with our template classes
    and do the work that the non-template functions used to do in the previous section.
    Let’s start with `operator+()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same function that we saw previously, only made into a template
    that can accept any instantiation of the class template `C`. Note that we parameterized
    this template on the type `T`, that is, the template parameter of `C`. We could,
    of course, simply declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: However, this introduces - into the global scope no less - an `operator+()`
    that claims to accept two arguments of any type. Of course, it really only handles
    types that have an `x_` data member. So, what are we going to do when we have
    a template class, `D`, that is also addable but has a `y_` data member instead?
  prefs: []
  type: TYPE_NORMAL
- en: 'The earlier version of the template is at least restricted to all possible
    instantiations of the class template `C`. Of course, it suffers from the same
    problem as our very first attempt at a non-member function - it does not have
    access to the private data member `C<T>::x_`. No problem - this chapter is about
    friends, after all. But friends to what? The entire class template, `C`, is going
    to have a friend declaration, just one for all `T` types, and that has to work
    for every instantiation of the template function `operator+()`. It appears that
    we have to grant friendship to the entire function template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the correct syntax - the keyword `friend` appears after the template and
    its parameters but before the return type of the function. Also, note that we
    had to rename the template parameter of the nested friend declaration - the `T`
    identifier is already used for the class template parameter. Similarly, we could
    rename the template parameter `T` in the definition of the function itself, but
    we don’t have to - just like in function declarations and definitions, the parameter
    is just a name; it is only meaningful within each declaration - two declarations
    for the same function can use different names for the same parameter. What we
    can do instead is move the function body inline, into the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You might point out that we have blown a rather wide hole in the encapsulation
    of the template class `C` – by granting friendship of any instantiation of `C<T>`
    to the entire template function, we have, for example, made the `operator+(const
    C&<double>, const C&<double>)` instantiation a friend of `C<int>`. This is clearly
    not necessary, although it may not be immediately obvious where the harm is in
    that (an example that shows actual harm would be rather convoluted, as necessary).
    But this misses a much more serious problem with our design, which becomes apparent
    as soon as we start using it to add something. It works, up to a point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'But only up to a point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: But was this not the very reason to use a non-member function? What happened
    to our implicit conversions? This used to work! The answer is in the details -
    it used to work, but for a non-template function, `operator+()`. The conversion
    rules for a template function are very different. The exact technical details
    can be gleaned from the standard, with great diligence and effort, but this is
    the gist of it - when considering non-member, non-template functions, the compiler
    will look for all functions with the given name (`operator+`, in our case), then
    check if they accept the right number of parameters (possibly considering default
    arguments), then check if, for each such function, for each of its parameters,
    a conversion from the supplied argument to the specified parameter type exists
    (the rules on which conversions, exactly, are considered, and again fairly complex,
    but let’s say that both user-given implicit conversions and built-in conversions
    such as non-const to `const` are considered). If this process yields only one
    function, that function is called (otherwise the compiler either selects the *best*
    overload or complains that several candidates are equally possible and the call
    is ambiguous).
  prefs: []
  type: TYPE_NORMAL
- en: For template functions, this process would again yield an almost unlimited number
    of candidates - every template function with the name `operator+()` would have
    to be instantiated on every known type just to check if enough type conversions
    are available to make it work. Instead, a much simpler process is attempted -
    in addition to all non-template functions described in the previous paragraph
    (in our case, none), the compiler also considers instantiations of template functions
    with the given name (again, `operator+`) and the types of all parameters equal
    to the types of the function arguments at the call site (so-called trivial conversions,
    such as adding `const`, are allowed).
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the argument types in the `x + 2` expression are `C<int>` and `int`,
    respectively. The compiler looks for an instantiation of the template function,
    `operator+`, that accepts two arguments of this type, and the user-given conversions
    are not considered. There is no such function, of course, and so the call to `operator+()`
    cannot be resolved.
  prefs: []
  type: TYPE_NORMAL
- en: The root of the problem is that we really want the user-given conversions to
    be used by the compiler automatically, but this is not going to happen as long
    as we are trying to instantiate a template function. We could declare a non-template
    function for `operator+(const C<int>&, const C<int>&)`, but, with a `C` template
    class, we would have to declare one for every `T` type that the `C` class might
    be instantiated on.
  prefs: []
  type: TYPE_NORMAL
- en: The template friend factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we need is to automatically generate a non-template function for every
    `T` type that’s used to instantiate the class template `C`. Of course, it is impossible
    to generate all of these functions in advance - there is a nearly unlimited number
    of `T` types that could, in theory, be used with the template class `C`. Fortunately,
    we do not need to generate `operator+()` for every one of such types - we only
    need them for the types that were actually used with this template in our program.
  prefs: []
  type: TYPE_NORMAL
- en: Generating friends on demand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pattern that we are about to see is a very old one, and was introduced by
    John Barton and Lee Nackman in 1994 for a completely different purpose - they
    used it to work around certain limitations of the compilers that existed at the
    time. The inventors proposed the name *Restricted Template Expansion*, which was
    never widely used. Years later, Dan Sacks coined the name *Friends Factory*, but
    the pattern is also sometimes referred to simply as the *Barton-Nackman trick*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern looks very simple and very similar to the code we wrote earlier
    throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We are taking advantage of a very specific C++ feature, and so the code must
    be written precisely. A non-template friend function is defined inside the class
    template. This function must be defined inline; it cannot be declared a friend
    and then defined later, except as an explicit template instantiation - we could
    have declared the friend function inside the class and then defined `operator+<const
    C<int>>&, const C<int>&)`, which would work for `C<int>` but not `C<double>` (since
    we do not know what types the callers may instantiate later, this is not very
    useful). It may have the parameters of the `T` type, the template parameter, the
    `C<T>` type (which, inside the class template, can be referred to as simply `C`),
    and any other type that is either fixed or depends only on the template parameters,
    but it may not be a template itself. Every instantiation of the `C` class template,
    with any combination of template parameter types, generates exactly one non-template,
    non-member function with the specified name. Note that the generated functions
    are non-template functions; they are regular functions, and the usual conversion
    rules apply to them. We are now back to the non-template `operator+()`, and all
    conversions work exactly the way we want them to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is it - this is the whole pattern. There are a few details we must note.
    First of all, the keyword `friend` cannot be omitted. A class cannot normally
    generate a non-member function, except for declaring a friend. Even if the function
    does not need access to any private data, in order to automatically generate non-template
    functions from instantiations of class templates, these functions have to be declared
    friends (static non-member functions can be generated in a similar manner, but
    the binary operators cannot be static functions - the standard explicitly forbids
    it). Second, the generated function is placed in the scope containing the class
    but must be found by the argument-dependent lookup, as we learned earlier in this
    chapter. For example, let’s define the inserter operator for our `C` template
    class, but not before wrapping the entire class in a namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now both add and print the objects of the `C` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that, even though the `C` class template is now in the namespace `NS`,
    and has to be used as such (`NS::C<int>`), we did not need to do anything special
    to invoke either `operator+()` or `operator<<()`. This does not mean that they
    were generated in the global scope. No, they are still in the namespace `NS`,
    but what we see is the argument-dependent lookup in action - when looking for
    a function named `operator+()`, for example, the compiler considers the candidates
    in the current scope (that is, the global scope, and there aren’t any), as well
    as the scope in which the arguments to the function are defined. In our case,
    at least one of the arguments to `operator+()` is of type `NS::C<int>`, which
    automatically brings all functions declared in the `NS` namespace into play. The
    friend factory generates its functions in the scope containing the class template,
    which is, of course, also the `NS` namespace. Thus, the lookup finds the definition,
    and both the `+` and `<<` operations are resolved exactly the way we would want
    them to be. Rest assured that this is by design and is no accident; the argument
    lookup rules are fine-tuned to produce this desired and expected result.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to prove that, even though friend functions are generated in the
    scope containing the class (in our case namespace `NS`), they can only be found
    by the argument-dependent lookup. A straightforward attempt to find the function
    without using an argument-dependent lookup will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is also a connection between the friend factory pattern and one of the
    patterns we studied earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The friend factory and the Curiously Recurring Template Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The friend factory is a pattern that synthesizes a non-template, non-member
    function from every instantiation of a class template - every time the template
    is instantiated on a new type, a new function is generated. For its parameters,
    this function can use any types we can declare in that instantiation of the class
    template. Usually, this is the class itself, but it can be any type the template
    knows about.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this manner, the friend factory can be employed together with the `operator!=()`
    can be implemented through `operator==()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the derived class `C` uses the friend factory pattern to generate a non-template
    function for the binary `operator==()` directly from the instantiation of the
    class template. It also inherits from the base class `B`, which triggers an instantiation
    of that template as well, which in turn generates a non-template function for
    `operator!=()` for every type for which we have generated `operator==()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second use of CRTP is to convert member functions to non-member functions.
    For example, the binary `operator+()` is sometimes implemented in terms of `operator+=()`,
    which is always a member function (it acts on its first operand). To implement
    the binary `operator+()`, someone has to take care of the conversions to that
    object’s type, and then `operator+=()` can be called. These conversions are provided
    by the binary operators that are generated by the common CRTP base class when
    using the friend factory. Similarly, the inserter operator can be generated if
    we establish the convention that our classes have a `print()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this fashion, CRTP can be used to add boilerplate interfaces while delegating
    the implementation to the derived classes. It is, after all, a static (compile-time)
    delegation pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about a very C++-specific pattern that was
    originally introduced as a workaround for the buggy early C++ compilers but found
    new use years later. The friend factory is used to generate non-template functions
    from instantiations of class templates. As non-template functions, these generated
    friends have much more flexible rules with regard to argument conversions compared
    to template functions. We have also learned how the argument-dependent lookup,
    type conversions, and the friend factory work together to deliver a result that
    looks very natural, by a process that is far from intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter describes a totally different kind of Factory - a C++ pattern
    that’s based on the classic Factory pattern and addresses a certain asymmetry
    in the language - all member functions, even destructors, can be virtual, except
    the constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the effect of declaring a function as a *friend*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between granting friendship to a function versus a function
    template?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are binary operators usually implemented as non-member functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the inserter operator always implemented as a non-member function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main difference between argument conversions for template and non-template
    functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we make the act of instantiating the template also generate a unique
    non-template, non-member function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
