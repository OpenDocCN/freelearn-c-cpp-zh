- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Friend Factory
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to talk about making friends. We mean C++ friends
    here, not friends of C++ (you find those in your local C++ users group). In C++,
    friends of classes are functions or other classes that are granted special access
    to the class. In that way, they are not so different from your friends. But C++
    can just manufacture friends as needed, on demand!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: How do friend functions work in C++ and what do they do?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should you use friend functions versus class member functions?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to combine friends and templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to generate friend functions from templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example code for this chapter can be found at the following GitHub link:
    https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter12.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Friends in C++
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by reviewing the way in which C++ grants friendship to classes,
    and the effects of this action, as well as when and for what reasons the friendship
    should be used (“my code does not compile until I add `friend` everywhere” is
    not a valid reason, but an indication of a poorly designed interface - redesign
    your classes instead).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: How to grant friendship in C++
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *friend* is a C++ concept that applies to classes and affects the access
    to class members (*access* is what `public` and `private` control). Usually, public
    member functions and data members are accessible to anyone, and private ones are
    only accessible to other member functions of the class itself. The following code
    does not compile because the data member `C:x_` is private:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The easiest way to solve this particular problem is to make `increase()` a
    member function, but let’s stay with this version for a moment. The other option
    is to relax access and make `C::x_` public. That is a bad idea because it exposes
    `x_` - not just to `increase()`, but to any other code out there that wants to
    directly modify an object of type `C`. What we need is to make `x_` public, or
    at least accessible, to `increase()` and to nobody else. This is done with a friend
    declaration:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The friend declaration does nothing more than give the specified function the
    same access as the class member functions get. There is also a form of friend
    declaration that grants friendship not to a function, but to a class; this is
    just a way to grant friendship to all member functions of that class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Friends versus member functions
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do have to come back to the question, why not just make `increase()` a member
    function of the `C` class? In the example given in the preceding section, there’s
    no reason to, really - `increase()` is clearly meant to be a part of the public
    interface of the `C` class since it’s one of the operations `C` supports. It needs
    special access to do its work, so it should be a member function. There are, however,
    cases where member functions come with limitations, or even cannot be used at
    all.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider an addition operator for the same `C` class - it’s what is
    needed to make an expression such as `c1 + c2` compile if both variables are of
    type `C`. The addition, or `operator+()`, can be declared as a member function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 `C` 类的一个加法运算符——这是使表达式如 `c1 + c2` 能够编译（如果两个变量都是类型 `C`）所必需的。加法，或 `operator+()`，可以声明为一个成员函数：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code compiles and does exactly what we want; there does not seem to be
    anything obviously wrong with it. That’s because there isn’t - so far. But we
    can add more than just objects of type `C`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码编译并且完全按照我们的预期工作；看起来并没有什么明显的问题。那是因为到目前为止确实没有。但我们不仅能添加类型为 `C` 的对象：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This also compiles, and points to a subtle detail in the declaration of the
    `C` class - we did not make the `C(int)` constructor explicit. This constructor
    now introduces an implicit conversion from int to `C`, and that is how the expression
    `x + 2` compiles - first, `2` is converted into a temporary object, `C(2)`, using
    the constructor we provided, and second the member function, `x.operator+(const
    C&)`, is called - the right-hand side is the temporary object we just created.
    The temporary object itself is deleted right after the expression is evaluated.
    The implicit conversion from integers is rather broad and might have been an oversight.
    Let’s assume that it wasn’t and that we really want the expression such as `x
    + 2` to compile. What’s not to like, then? Again, nothing so far. The objectionable
    feature of our design is what comes next:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也能编译，并且指向了 `C` 类声明中的一个微妙细节——我们没有显式地定义 `C(int)` 构造函数。这个构造函数现在引入了从 `int` 到
    `C` 的隐式转换，这就是表达式 `x + 2` 编译的原因——首先，`2` 被转换成一个临时对象，`C(2)`，使用我们提供的构造函数，然后调用成员函数，`x.operator+(const
    C&)`——右侧是我们刚刚创建的临时对象。临时对象在表达式评估后立即被删除。从整数到隐式转换相当广泛，可能是一个疏忽。让我们假设它不是，并且我们确实希望表达式如
    `x + 2` 能够编译。那有什么不满意的呢？再次，到目前为止没有。我们设计中的令人反感之处在于接下来会发生什么：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If `x + 2` compiles, you would reasonably expect `2 + x` to compile and give
    the same result (there are areas of math where the addition is not commutative,
    but let’s stick with the arithmetic here). The reason it does not compile is that
    the compiler cannot get to `operator+()` in the `C` class from here, and no other
    `operator+()` is available for these arguments. The `x + y` expression, when used
    with member function operators, is just syntactic sugar for the equivalent, if
    verbose, call to `x.operator+(y)`. The same is true for any other binary operator
    such as multiplication or comparison.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x + 2` 能够编译，你合理地预期 `2 + x` 也能编译并给出相同的结果（在数学的某些领域加法不是交换的，但让我们在这里坚持算术）。它不能编译的原因是编译器无法从这里访问
    `C` 类中的 `operator+()`，并且没有其他 `operator+()` 可用于这些参数。当使用成员函数运算符时，`x + y` 表达式只是对等价（如果冗长）调用
    `x.operator+(y)` 的语法糖。对于任何其他二元运算符，如乘法或比较，也是如此。
- en: 'The point is, the member function operator is invoked on the first argument
    of the expression (so technically, `x + y` and `y + x` are not identical; the
    member function is called on different objects, but the implementation is such
    that both give the same result). In our case, the member function would have to
    be invoked on the number `2`, which is an integer and has no member functions
    at all. So, how did the expression `x + 2` compile? Quite simple, really: `x +`
    by itself implies `x.operator+()`, and the argument is whatever comes after `+`.
    In our case, it’s `2`. So, either `x.operator+(2)` compiles, or it does not, but
    in either case, the search for `operator+` to the call is over. The implicit conversion
    from `int` in our `C` class makes this call compile. So, why doesn’t the compiler
    attempt a conversion on the first argument? The answer is, it never does because
    it has no guidance on what to convert it into - there may be any number of other
    types that have the `operator+()` member function, and some of them may accept
    the `C` class as their argument, or something `C` can be converted to. The compiler
    does not attempt to explore the almost infinite number of such possible conversions.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use plus in expressions where the first type may be a built-in
    type or any other type that does not have or cannot have a member function of
    `operator+()`, then we have to use a non-member function. No problem; we know
    how to write those:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But now we have lost access to the private data member `C::x_`, so our non-member
    `operator+()` does not compile either. We have seen the solution to that problem
    in the previous section - we need to make it a friend:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, everything compiles and works as intended - the non-member function `operator+()`
    is simply a non-member function with two arguments of type `const C&`. The rules
    for it are the same as for any other such function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid typing the declaration of the `operator+()` twice if we define
    its body *in situ* (immediately following the declaration, inside the class):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The latter example is subtly different from the previous one, but usually, you
    won’t be able to see the difference, so it is simply a matter of style - moving
    the body of the function into the object makes the object itself longer, but defining
    the function outside of the class is more typing (as well as a possible divergence
    between the friend declaration and the actual function, if the code is ever changed).
    We will explain the intricacies of in situ friend declarations in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Either way, the friend function is really a part of the class public interface,
    but, for technical reasons, we prefer a non-member function in this case. There
    is even a case when the non-member function is the only choice. Consider the C++
    input/output operators, such as the inserter, or `operator<<()`, which are used
    to write objects out into a stream (for example, `std::cout`). We want to be able
    to print an object of type `C` like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is no standard `operator<<()` for our type C, so we have to declare our
    own. The inserter is a binary operator, just like plus (it has parameters on either
    side), so, were it a member function, it would have to be one on the left-hand
    side object. Look at the preceding statement - the left-hand side object in the
    `std::cout << c1` expression is not our object, `c1`, but the standard out stream,
    `std::cout`. That’s the object we would have to add a member function to, but
    we cannot - `std::cout` is declared somewhere in the C++ standard library headers,
    and there is no way to extend its interface, at least not in a direct manner.
    Member functions on the `C` class can be declared by us, but this does not help
    - only the member functions of the left-hand side object are considered. The only
    alternative is a non-member function. The first argument has to be `std::ostream&`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的类型C，没有标准的`operator<<()`，因此我们必须声明自己的。插入器是一个二元运算符，就像加号一样（它两边都有参数），所以，如果它是一个成员函数，它必须是一个左边的对象上的函数。看看前面的语句——在`std::cout
    << c1`表达式中，左边的对象不是我们的对象`c1`，而是标准输出流`std::cout`。这就是我们必须添加成员函数的对象，但我们不能——`std::cout`在C++标准库头文件中某处被声明，而且没有方法可以扩展其接口，至少不是直接的方式。我们可以声明`C`类上的成员函数，但这没有帮助——只有左边的对象的成员函数被考虑。唯一的替代方案是非成员函数。第一个参数必须是`std::ostream&`：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function has to be declared as a friend since it also needs access to
    the private data of the `C` class. It can also be defined *in situ*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数必须被声明为`friend`，因为它还需要访问`C`类的私有数据。它也可以就地定义：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By convention, the return value is the same stream object, so the inserter
    operators can be chained:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，返回值是相同的流对象，因此插入器运算符可以被链式调用：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The way the last statement is interpreted is `(std::cout << c1) << c2`, which
    boils down to `operator<<(operator<<(std::cout, c1), c2)`. The outer `operator<<()`
    is called on the return value of the inner `operator<<()`, which is the same:
    `std::cout`. Again, the inserter is part of the public interface of the `C` class
    - it makes the objects of type `C` printable. However, it has to be a non-member
    function.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句的解释方式是`(std::cout << c1) << c2`，这归结为`operator<<(operator<<(std::cout,
    c1), c2)`。外层的`operator<<()`是在内层`operator<<()`的返回值上调用的，而这个返回值是相同的：`std::cout`。再次强调，插入器是`C`类的公共接口的一部分——它使得类型`C`的对象可打印。然而，它必须是一个非成员函数。
- en: The introduction to the use of `friend` in C++ glossed over several subtle details
    that are occasionally important, so let us spend some time to elucidate them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: C++中关于`friend`使用介绍的章节略过了几个偶尔很重要的微妙细节，因此让我们花些时间来阐明它们。
- en: Subtle details of friendship
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 友谊的微妙细节
- en: 'First, let us talk about the effect of declaring a `friend` function without
    defining it (i.e., without the in situ implementation):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈声明一个未定义的`friend`函数（即，没有就地实现）的效果：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By the way, it makes no difference whatsoever whether you put the `friend`
    declaration into the public or private part of the class. But about the `friend`
    declaration itself: which function did we grant access to? This is the first mention
    of an `operator+()` with this signature in our program (its definition must come
    later, after class `C` itself was declared). Turns out that the `friend` statement
    does double duty: it also acts as a forward declaration for the function.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，你将`friend`声明放在类的公共部分还是私有部分，这完全无关紧要。但关于`friend`声明本身：我们授予了哪个函数访问权限？这是我们程序中第一次提到具有此签名的`operator+()`（其定义必须在类`C`本身声明之后出现）。结果是`friend`语句起到了双重作用：它还充当了函数的前置声明。
- en: 'Of course, there is no rule that prevents us from forward-declaring the same
    function ourselves:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有规则阻止我们自行提前声明相同的函数：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is no need to use a separate forward declaration just to use `friend`,
    but it may be necessary for other reasons if we want to use `operator+()` earlier
    in our program.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要为了使用`friend`而单独使用前置声明，但如果我们想在程序中更早地使用`operator+()`，可能出于其他原因就需要这样做。
- en: Note that the compiler does not warn you if the `friend` forward declaration
    does not match the function definition, or if the `friend` statement does not
    match the forward declaration. If the function signature in the `friend` statement
    differs from the actual function, you will have granted friendship to some other
    function that is forward-declared but not defined anywhere. It is highly likely
    that you will get a syntax error compiling the real function because it now has
    no special access to the class and can’t access its private members. But the error
    message won’t say anything about a mismatch between the `friend` statement and
    the function definition. You just have to know that if you granted friendship
    to a function and the compiler doesn’t see it, there is a discrepancy between
    the function signature in the `friend` statement and the one in the function definition.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if the `friend` statement also defines the function instead of just
    declaring it, then it is not acting as a forward declaration at all. But in this
    case, there is another subtlety, namely, in which scope is the new function defined?
    Consider that if you declare a static function inside a class, that function exists
    in the scope of the class itself. If we have a class `C` with a static function
    `f()`, the proper name of this function outside of the class is `C::f`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It is easy to see that the same does not apply to the `friend` functions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This makes sense, considering that we already saw that the `friend` statement
    without a definition forward-declared a function that is defined outside of the
    class. So, if the `friend` declaration forward-declared a function in the scope
    containing the class (in our case, the global scope, but could have been a `namespace`),
    then the `friend` statement with an in situ definition must define a function
    in the same scope, i.e., it injects a function into the outer scope of the class.
    Right? Yes, but not entirely.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, odds are good that you would never notice the “not entirely” part,
    and everything behaves as if the function was simply injected into the containing
    scope. It takes a rather contrived example to demonstrate what really happens:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here we have two `friend` functions, `f()` and `g()`, both are defined at the
    point of declaration. The function `g()` behaves as if it was declared in the
    global scope (or the scope containing the class `C`, if we used a `namespace`).
    But a call to `f()` in the same scope does not compile, and the error message
    is going to be “function f is not declared in this scope” or something to that
    effect. The wording of compiler error messages varies widely, but that is the
    gist of the error: the call to `f()` did not find a function to call. The only
    difference between the functions `f()` and `g()` is their arguments; that turns
    out to be key.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, we have to know how the compiler looks up a function name
    when you write a function call such as `f(0)`. First of all, this is a non-member
    function, so the compiler looks only for those (it could also be a functor – a
    class with `operator()`, but that is not important right now since we don’t have
    any). Second, the compiler searches the current scope, the one where the call
    is made, and all containing scopes such as nested function bodies, classes, and
    namespaces) all the way to the global scope. But this is not the end of it: the
    compiler also looks at the arguments of the function and searches the scope (or
    scopes) where each of these argument types is declared. This step is called the
    **argument-dependent lookup** (**ADL**), also known as the **Koenig lookup** after
    Andrew Koenig (who denies inventing it). After all these lookups are done and
    the compiler finds every function with the matching name in one of the scopes
    we just listed, the compiler does the overload resolution on all the functions
    it found (i.e., there is no priority given to any particular scope).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does this have to do with the `friend` functions? Only this: according
    to the standard, a function defined by the `friend` statement is injected into
    the scope containing the class, but *it can be found only by the* *argument-dependent
    lookup*.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'This explains the behavior we just saw: both the functions `f()` and `g()`
    are injected into the global scope since that is the scope containing class `C`.
    Function `g()` has an argument of type `const C&`, so it is found by the ADL in
    the scope containing the class `C`. Function `f()` has an argument of type `int`,
    and the built-in types are not considered to be declared in any scope, they “just
    are.” Since no ADL can be performed and the functions defined as friends are only
    found by ADL, function `f()` cannot be found at all.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this situation is very fragile. For example, if we forward-declare
    the same function, it can be found in the scope where it is forward-declared and
    does not need the ADL:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The same happens if the `friend` statement only declared the function, to be
    defined later:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Why don’t we see this as a problem more often? Because most of the time, functions
    declared as friends inside classes have at least one argument of the type related
    to the class itself (such as a pointer or a reference). Both `operator+()` and
    `operator<<()` we have seen earlier fall into that category. After all, the only
    reason to declare a function as a friend is so it can access private members of
    the class, but the function would not need this access if it did not operate on
    an object of the class type. As a non-member function, how would it get access
    to such an object if not through its arguments? Of course, there are ways, but
    these situations rarely happen in practice.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another subtle and potentially dangerous case happens when a program defines
    its own `operator new`. This is not illegal, class-specific memory allocation
    operators are often necessary. But declaring one is not that simple. There are
    two common uses of a custom `operator new`: the first one is where the operator
    is defined for the class that is being allocated, usually inside the class itself.
    These are called class-specific operators, and they aren’t the subject of our
    interest now. We need to explain the second common case, where the custom `operator
    new` is defined to allocate memory using a specific allocator class. This is how
    it is usually done:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序定义自己的`operator new`时，还会发生另一个微妙且可能危险的案例。这并不违法，类特定的内存分配操作符通常是必要的。但声明一个并不那么简单。自定义`operator
    new`的两种常见用途：第一个是操作符为正在分配的类定义，通常在类内部定义。这些被称为类特定操作符，它们不是我们现在感兴趣的主题。我们需要解释第二种常见情况，即自定义`operator
    new`被定义为使用特定的分配器类分配内存。这通常是这样做：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are several details to note: first, our allocator class `Alloc` has an
    overload for `operator new`: the first argument of every `operator new` is mandatory
    and must be the size of the allocation (the compiler fills that in). The second
    argument (and the third, etc, if necessary) are arbitrary; in our case, it’s the
    pointer to the allocator class that is going to provide memory for this allocation.
    The `operator new` itself is a function in the global scope, and it is declared
    as a friend of class `Alloc`. If you are wondering how you can call the matching
    `operator delete` that we also declared, the answer is you cannot; this operator
    is used only by the compiler itself in case the allocation by `operator new` succeeded
    but the constructor of the new object throws an exception. The compiler will use
    `operator delete` with the arguments matching those of `operator new`. But this
    is not how you will delete this object when its lifetime is over: there is no
    way to add extra arguments to a `delete` expression, so you’ll have to call the
    destructor yourself and then explicitly return the memory to the allocator.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个细节需要注意：首先，我们的分配器类`Alloc`为`operator new`提供了一个重载：每个`operator new`的第一个参数是强制性的，必须是分配的大小（编译器会填充这个值）。第二个参数（以及如果需要的话，第三个等）是任意的；在我们的情况下，它是将提供此分配内存的分配器类的指针。`operator
    new`本身是在全局作用域中的一个函数，并且它被声明为类`Alloc`的朋友。如果你想知道如何调用我们也声明的匹配的`operator delete`，答案是你不能；这个操作符仅由编译器本身在`operator
    new`的分配成功但新对象的构造函数抛出异常的情况下使用。编译器将使用与`operator new`相同的参数调用`operator delete`。但当你想要删除这个对象并且它的生命周期结束时，这并不是你删除对象的方式：无法向`delete`表达式添加额外的参数，所以你必须自己调用析构函数，然后显式地将内存返回给分配器。
- en: This works exactly as intended. The compiler looks for the best match for the
    call to `operator new(size_t, Alloc*)` and finds our custom `operator new` in
    the global scope as intended.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全符合预期。编译器寻找对`operator new(size_t, Alloc*)`调用的最佳匹配，并如预期地在全局作用域中找到我们的自定义`operator
    new`。
- en: 'Now, you may decide to move the body of the operator into the `friend` statement
    to save some typing as well as avoid the possibility of the `friend` declaration
    and the actual `operator new` definition ever getting out of sync. This is done
    with only a minor change:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会决定将操作符的主体移动到`friend`语句中，以节省一些输入并避免`friend`声明和实际的`operator new`定义不同步的可能性。这只需要进行微小的更改：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This program will almost certainly compile. It will work correctly on some
    compilers and produce horrible memory corruption on others. Unfortunately, those
    other compilers are correct. This is what is going on: the *new expression* (which
    is the standard name for the syntax “`new` … some-type”) has special rules for
    looking up the matching `operator new`. Specifically, the lookup is done in the
    scope of the class that is being constructed (class `C` in our case) and in the
    global scope (these rules are defined in the section `[expr.new]` of the standard).
    Note that there is no lookup in the scope of the arguments to `operator new` itself,
    i.e., no argument-dependent lookup. Since the function defined in situ by the
    `friend` statement can be found only by the argument-dependent lookup, it is not
    found at all. But how does the program compile then? This happens because of another
    overload for `operator new`, the so-called *placement new*. This overload has
    the form:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is declared in the standard header `<new>`, which is included by so many
    other headers that your program is very likely to include it even if you did not
    do so explicitly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The intent for the placement new is to construct an object in memory that was
    allocated earlier (we used this to construct objects in the space reserved inside
    a class when we studied type erasure in the eponymous chapter earlier). But it
    is also a possible match to our call of operator `new(size_t, Alloc*)` because
    `Alloc*` can be implicitly converted to `void*`. Our own overload, which does
    not require this conversion, would be a better match, but, unfortunately, when
    defined in situ, it is not found by the lookup. The result is that the object
    of type `C` is constructed in the memory already occupied by the allocator object
    itself, corrupting the latter object in the process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test your compilers using our examples: when defined outside of the
    class, the custom `operator new` should be invoked and the program should work
    as intended. But when defined by the `friend` statement, only the placement new
    should be found (some compilers will also issue a warning about overwriting an
    already constructed object).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: So far, our classes are just regular classes, not templates, and our non-member
    functions have declared friends that were just regular non-template functions.
    Now, let’s consider what, if anything, needs to change if the class becomes a
    template.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Friends and templates
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both classes and functions in C++ can be templates, and we can have several
    different combinations - a class template can grant friendship to a non-template
    function if its parameter types don’t depend on the template parameters; this
    is not a particularly interesting case, and certainly does not solve any of the
    problems we’re dealing with now. When the friend function needs to operate on
    the template parameter types, making the right friends becomes trickier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Friends of template classes
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by making our `C` class into a template:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We still want to add objects of type `C` and print them out. We have already
    considered reasons why the former is better accomplished with a non-member function,
    and the latter cannot be done in any other way. These reasons remain valid for
    class templates as well.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然想要添加 `C` 类型的对象并将它们打印出来。我们已经考虑了为什么前者用非成员函数完成更好，以及后者不能以任何其他方式完成的原因。这些原因对类模板同样有效。
- en: 'No problem - we can declare template functions to go with our template classes
    and do the work that the non-template functions used to do in the previous section.
    Let’s start with `operator+()`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题——我们可以声明与我们的模板类一起使用的模板函数，并执行之前章节中非模板函数所做的工作。让我们从 `operator+()` 开始：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is the same function that we saw previously, only made into a template
    that can accept any instantiation of the class template `C`. Note that we parameterized
    this template on the type `T`, that is, the template parameter of `C`. We could,
    of course, simply declare the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前看到过的相同函数，只是变成了一个模板，可以接受类模板 `C` 的任何实例化。请注意，我们在这个模板上参数化了类型 `T`，即 `C` 的模板参数。当然，我们可以简单地声明以下内容：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: However, this introduces - into the global scope no less - an `operator+()`
    that claims to accept two arguments of any type. Of course, it really only handles
    types that have an `x_` data member. So, what are we going to do when we have
    a template class, `D`, that is also addable but has a `y_` data member instead?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这引入了一个——不亚于全局作用域——声称接受任何类型两个参数的 `operator+()`。当然，它实际上只处理具有 `x_` 数据成员的类型。那么，当我们有一个也是可添加的模板类
    `D`，但它有一个 `y_` 数据成员而不是 `x_` 数据成员时，我们将怎么办呢？
- en: 'The earlier version of the template is at least restricted to all possible
    instantiations of the class template `C`. Of course, it suffers from the same
    problem as our very first attempt at a non-member function - it does not have
    access to the private data member `C<T>::x_`. No problem - this chapter is about
    friends, after all. But friends to what? The entire class template, `C`, is going
    to have a friend declaration, just one for all `T` types, and that has to work
    for every instantiation of the template function `operator+()`. It appears that
    we have to grant friendship to the entire function template:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的早期版本至少限制在类模板 `C` 的所有可能实例化上。当然，它也面临着我们第一次尝试非成员函数时遇到的问题——它无法访问私有数据成员 `C<T>::x_`。没问题——毕竟，本章是关于朋友的。但朋友是针对什么的？整个类模板
    `C` 将有一个朋友声明，只为所有 `T` 类型，并且它必须适用于模板函数 `operator+()` 的每个实例化。看起来我们必须授予整个函数模板朋友权限：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note the correct syntax - the keyword `friend` appears after the template and
    its parameters but before the return type of the function. Also, note that we
    had to rename the template parameter of the nested friend declaration - the `T`
    identifier is already used for the class template parameter. Similarly, we could
    rename the template parameter `T` in the definition of the function itself, but
    we don’t have to - just like in function declarations and definitions, the parameter
    is just a name; it is only meaningful within each declaration - two declarations
    for the same function can use different names for the same parameter. What we
    can do instead is move the function body inline, into the class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意正确的语法——关键字 `friend` 出现在模板及其参数之后，但在函数的返回类型之前。此外，请注意，我们必须重命名嵌套朋友声明的模板参数——`T`
    标识符已经被用于类模板参数。同样，我们可以在函数定义中将模板参数 `T` 重命名，但不必这样做——就像在函数声明和定义中一样，参数只是一个名称；它只在每个声明中有意义——同一函数的两个声明可以使用不同的名称来表示相同的参数。我们可以做的替代方案是将函数体内联，放入类中：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You might point out that we have blown a rather wide hole in the encapsulation
    of the template class `C` – by granting friendship of any instantiation of `C<T>`
    to the entire template function, we have, for example, made the `operator+(const
    C&<double>, const C&<double>)` instantiation a friend of `C<int>`. This is clearly
    not necessary, although it may not be immediately obvious where the harm is in
    that (an example that shows actual harm would be rather convoluted, as necessary).
    But this misses a much more serious problem with our design, which becomes apparent
    as soon as we start using it to add something. It works, up to a point:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会指出，我们在模板类 `C` 的封装上打开了一个相当大的漏洞——通过将 `C<T>` 的任何实例化与整个模板函数视为友元，例如，我们使 `operator+(const
    C&<double>, const C&<double>)` 的实例化成为 `C<int>` 的友元。这显然是不必要的，尽管这种做法可能不会立即显现出危害（一个展示实际危害的例子将会相当复杂，因为这是必要的）。但这个问题忽略了我们的设计中一个更严重的问题，这个问题在我们开始使用它来添加内容时变得明显。它在一开始是可行的：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But only up to a point:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅到此为止：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: But was this not the very reason to use a non-member function? What happened
    to our implicit conversions? This used to work! The answer is in the details -
    it used to work, but for a non-template function, `operator+()`. The conversion
    rules for a template function are very different. The exact technical details
    can be gleaned from the standard, with great diligence and effort, but this is
    the gist of it - when considering non-member, non-template functions, the compiler
    will look for all functions with the given name (`operator+`, in our case), then
    check if they accept the right number of parameters (possibly considering default
    arguments), then check if, for each such function, for each of its parameters,
    a conversion from the supplied argument to the specified parameter type exists
    (the rules on which conversions, exactly, are considered, and again fairly complex,
    but let’s say that both user-given implicit conversions and built-in conversions
    such as non-const to `const` are considered). If this process yields only one
    function, that function is called (otherwise the compiler either selects the *best*
    overload or complains that several candidates are equally possible and the call
    is ambiguous).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但这难道不是使用非成员函数的原因吗？我们的隐式转换怎么了？这曾经是可行的！答案在细节中——它曾经可行，但对于非模板函数 `operator+()`，模板函数的转换规则非常不同。确切的技术细节可以通过标准获得，但需要极大的勤奋和努力，但这是关键——在考虑非成员、非模板函数时，编译器会寻找所有具有给定名称（在我们的例子中是
    `operator+`）的函数，然后检查它们是否接受正确的参数数量（可能考虑默认参数），然后检查对于每个这样的函数，对于它的每个参数，是否存在从提供的参数到指定参数类型的转换（关于哪些转换被考虑的规则相当复杂，但让我们说，用户提供的隐式转换和内置转换，如非
    `const` 到 `const`，都被考虑）。如果这个过程只产生一个函数，那么就调用该函数（否则编译器要么选择 *最佳* 覆载，要么抱怨有多个候选者且调用是模糊的）。
- en: For template functions, this process would again yield an almost unlimited number
    of candidates - every template function with the name `operator+()` would have
    to be instantiated on every known type just to check if enough type conversions
    are available to make it work. Instead, a much simpler process is attempted -
    in addition to all non-template functions described in the previous paragraph
    (in our case, none), the compiler also considers instantiations of template functions
    with the given name (again, `operator+`) and the types of all parameters equal
    to the types of the function arguments at the call site (so-called trivial conversions,
    such as adding `const`, are allowed).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模板函数，这个过程将再次产生几乎无限多的候选者——每个具有 `operator+()` 名称的模板函数都必须在所有已知类型上实例化，以检查是否足够多的类型转换可用以使其工作。相反，尝试了一个更简单的过程——除了前一段中描述的所有非模板函数（在我们的例子中，没有）之外，编译器还考虑了具有给定名称（再次是
    `operator+`）的模板函数的实例化，以及所有参数类型与函数调用位置上的函数参数类型相等的类型（允许所谓的平凡转换，例如添加 `const`）。
- en: In our case, the argument types in the `x + 2` expression are `C<int>` and `int`,
    respectively. The compiler looks for an instantiation of the template function,
    `operator+`, that accepts two arguments of this type, and the user-given conversions
    are not considered. There is no such function, of course, and so the call to `operator+()`
    cannot be resolved.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`x + 2` 表达式中的参数类型分别是 `C<int>` 和 `int`。编译器会寻找一个接受这种类型两个参数的模板函数 `operator+`
    的实例化，而用户提供的转换不被考虑。当然，这样的函数不存在，因此对 `operator+()` 的调用无法解析。
- en: The root of the problem is that we really want the user-given conversions to
    be used by the compiler automatically, but this is not going to happen as long
    as we are trying to instantiate a template function. We could declare a non-template
    function for `operator+(const C<int>&, const C<int>&)`, but, with a `C` template
    class, we would have to declare one for every `T` type that the `C` class might
    be instantiated on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The template friend factory
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we need is to automatically generate a non-template function for every
    `T` type that’s used to instantiate the class template `C`. Of course, it is impossible
    to generate all of these functions in advance - there is a nearly unlimited number
    of `T` types that could, in theory, be used with the template class `C`. Fortunately,
    we do not need to generate `operator+()` for every one of such types - we only
    need them for the types that were actually used with this template in our program.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Generating friends on demand
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pattern that we are about to see is a very old one, and was introduced by
    John Barton and Lee Nackman in 1994 for a completely different purpose - they
    used it to work around certain limitations of the compilers that existed at the
    time. The inventors proposed the name *Restricted Template Expansion*, which was
    never widely used. Years later, Dan Sacks coined the name *Friends Factory*, but
    the pattern is also sometimes referred to simply as the *Barton-Nackman trick*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern looks very simple and very similar to the code we wrote earlier
    throughout this chapter:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We are taking advantage of a very specific C++ feature, and so the code must
    be written precisely. A non-template friend function is defined inside the class
    template. This function must be defined inline; it cannot be declared a friend
    and then defined later, except as an explicit template instantiation - we could
    have declared the friend function inside the class and then defined `operator+<const
    C<int>>&, const C<int>&)`, which would work for `C<int>` but not `C<double>` (since
    we do not know what types the callers may instantiate later, this is not very
    useful). It may have the parameters of the `T` type, the template parameter, the
    `C<T>` type (which, inside the class template, can be referred to as simply `C`),
    and any other type that is either fixed or depends only on the template parameters,
    but it may not be a template itself. Every instantiation of the `C` class template,
    with any combination of template parameter types, generates exactly one non-template,
    non-member function with the specified name. Note that the generated functions
    are non-template functions; they are regular functions, and the usual conversion
    rules apply to them. We are now back to the non-template `operator+()`, and all
    conversions work exactly the way we want them to:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is it - this is the whole pattern. There are a few details we must note.
    First of all, the keyword `friend` cannot be omitted. A class cannot normally
    generate a non-member function, except for declaring a friend. Even if the function
    does not need access to any private data, in order to automatically generate non-template
    functions from instantiations of class templates, these functions have to be declared
    friends (static non-member functions can be generated in a similar manner, but
    the binary operators cannot be static functions - the standard explicitly forbids
    it). Second, the generated function is placed in the scope containing the class
    but must be found by the argument-dependent lookup, as we learned earlier in this
    chapter. For example, let’s define the inserter operator for our `C` template
    class, but not before wrapping the entire class in a namespace:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部的模式。有几个细节我们必须注意。首先，关键字 `friend` 不能省略。一个类通常不能生成非成员函数，除非声明为友元。即使函数不需要访问任何私有数据，为了从类模板的实例化中自动生成非模板函数，这些函数必须被声明为友元（可以通过类似的方式生成静态非成员函数，但二进制运算符不能是静态函数——标准明确禁止）。其次，生成的函数放置在包含类的范围内，但必须通过参数依赖查找来找到，正如我们在本章前面学到的。例如，让我们为我们的
    `C` 模板类定义插入操作符，但在这样做之前，将整个类包裹在一个命名空间中：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now both add and print the objects of the `C` type:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加并打印 `C` 类型的对象：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that, even though the `C` class template is now in the namespace `NS`,
    and has to be used as such (`NS::C<int>`), we did not need to do anything special
    to invoke either `operator+()` or `operator<<()`. This does not mean that they
    were generated in the global scope. No, they are still in the namespace `NS`,
    but what we see is the argument-dependent lookup in action - when looking for
    a function named `operator+()`, for example, the compiler considers the candidates
    in the current scope (that is, the global scope, and there aren’t any), as well
    as the scope in which the arguments to the function are defined. In our case,
    at least one of the arguments to `operator+()` is of type `NS::C<int>`, which
    automatically brings all functions declared in the `NS` namespace into play. The
    friend factory generates its functions in the scope containing the class template,
    which is, of course, also the `NS` namespace. Thus, the lookup finds the definition,
    and both the `+` and `<<` operations are resolved exactly the way we would want
    them to be. Rest assured that this is by design and is no accident; the argument
    lookup rules are fine-tuned to produce this desired and expected result.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `C` 类模板现在位于命名空间 `NS` 中，并且必须这样使用（`NS::C<int>`），我们并不需要做任何特殊的事情来调用 `operator+()`
    或 `operator<<()`。这并不意味着它们是在全局作用域中生成的。不，它们仍然在 `NS` 命名空间中，但我们看到的是参数依赖查找正在起作用——例如，当寻找名为
    `operator+()` 的函数时，编译器会考虑当前作用域（即全局作用域，且没有）以及函数参数定义的作用域。在我们的例子中，`operator+()` 至少有一个参数是
    `NS::C<int>` 类型，这会自动将 `NS` 命名空间中声明的所有函数都纳入考虑。友元工厂在其包含类模板的作用域中生成其函数，这当然是 `NS` 命名空间。因此，查找找到了定义，`+`
    和 `<<` 操作符的解析正是我们期望的方式。请放心，这是设计好的，绝非偶然；参数查找规则被精心调整以产生这个期望和预期的结果。
- en: 'It is easy to prove that, even though friend functions are generated in the
    scope containing the class (in our case namespace `NS`), they can only be found
    by the argument-dependent lookup. A straightforward attempt to find the function
    without using an argument-dependent lookup will fail:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易证明，尽管友元函数是在包含类的（在我们的例子中是命名空间 `NS`）作用域中生成的，但它们只能通过参数依赖查找来找到。一个直接尝试不使用参数依赖查找来查找函数的尝试将会失败：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is also a connection between the friend factory pattern and one of the
    patterns we studied earlier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 友元工厂模式与我们之前研究过的模式之一也有联系。
- en: The friend factory and the Curiously Recurring Template Pattern
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 友元工厂和奇特重复的模板模式
- en: The friend factory is a pattern that synthesizes a non-template, non-member
    function from every instantiation of a class template - every time the template
    is instantiated on a new type, a new function is generated. For its parameters,
    this function can use any types we can declare in that instantiation of the class
    template. Usually, this is the class itself, but it can be any type the template
    knows about.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'In this manner, the friend factory can be employed together with the `operator!=()`
    can be implemented through `operator==()`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the derived class `C` uses the friend factory pattern to generate a non-template
    function for the binary `operator==()` directly from the instantiation of the
    class template. It also inherits from the base class `B`, which triggers an instantiation
    of that template as well, which in turn generates a non-template function for
    `operator!=()` for every type for which we have generated `operator==()`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The second use of CRTP is to convert member functions to non-member functions.
    For example, the binary `operator+()` is sometimes implemented in terms of `operator+=()`,
    which is always a member function (it acts on its first operand). To implement
    the binary `operator+()`, someone has to take care of the conversions to that
    object’s type, and then `operator+=()` can be called. These conversions are provided
    by the binary operators that are generated by the common CRTP base class when
    using the friend factory. Similarly, the inserter operator can be generated if
    we establish the convention that our classes have a `print()` member function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this fashion, CRTP can be used to add boilerplate interfaces while delegating
    the implementation to the derived classes. It is, after all, a static (compile-time)
    delegation pattern.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about a very C++-specific pattern that was
    originally introduced as a workaround for the buggy early C++ compilers but found
    new use years later. The friend factory is used to generate non-template functions
    from instantiations of class templates. As non-template functions, these generated
    friends have much more flexible rules with regard to argument conversions compared
    to template functions. We have also learned how the argument-dependent lookup,
    type conversions, and the friend factory work together to deliver a result that
    looks very natural, by a process that is far from intuitive.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter describes a totally different kind of Factory - a C++ pattern
    that’s based on the classic Factory pattern and addresses a certain asymmetry
    in the language - all member functions, even destructors, can be virtual, except
    the constructors.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the effect of declaring a function as a *friend*?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between granting friendship to a function versus a function
    template?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are binary operators usually implemented as non-member functions?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the inserter operator always implemented as a non-member function?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main difference between argument conversions for template and non-template
    functions?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板函数和非模板函数的参数转换之间主要区别是什么？
- en: How can we make the act of instantiating the template also generate a unique
    non-template, non-member function?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使模板实例化的过程同时生成一个独特的非模板、非成员函数？
