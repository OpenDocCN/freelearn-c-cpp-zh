- en: Drawing Vulkan Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制 Vulkan 对象
- en: In the previous chapter, we created all the resources that were required for
    an object to be drawn. In this chapter, we will create the `ObjectRenderer` class,
    which will draw an object on the viewport. This class is used so that we have
    an actual geometric object to draw and view alongside our awesome purple viewport.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了绘制对象所需的所有资源。在本章中，我们将创建 `ObjectRenderer` 类，该类将在视口中绘制对象。这个类被用来确保我们有一个实际的几何对象来绘制和查看，与我们的紫色视口一起。
- en: We will also learn how to synchronize CPU and GPU operations at the end of the
    chapter, which will remove the validation error that we got in [Chapter 11](ebc6fd68-325b-439e-9e11-8e01f818dd9b.xhtml), *Creating
    Object Resources*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何在章节末尾同步 CPU 和 GPU 操作，这将消除我们在[第 11 章](ebc6fd68-325b-439e-9e11-8e01f818dd9b.xhtml)，*创建对象资源*中遇到的验证错误。
- en: Before we set the scene up for rendering, we have to prepare one last thing
    for the geometry render; that is, the graphics pipeline. We will begin setting
    this up next.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为渲染设置场景之前，我们必须为几何渲染准备最后一件事；那就是图形管线。我们将在下一节开始设置它。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Preparing the `GraphicsPipeline` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备 `GraphicsPipeline` 类
- en: The `ObjectRenderer` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectRenderer` 类'
- en: Changes to the `VulkanContext` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VulkanContext` 类的更改'
- en: The `Camera` class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Camera` 类'
- en: Drawing an object
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个对象
- en: Synchronizing an object
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步一个对象
- en: Preparing the GraphicsPipeline class
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 GraphicsPipeline 类
- en: 'The graphics pipeline defines the pipeline an object should follow when it
    is drawn. As we discovered in [Chapter 2](ee788533-687d-4231-91a4-cb1de9ca01dd.xhtml), *Mathematics
    and Graphics Concepts*, there is a series of steps that we need to follow to draw
    an object:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图形管线定义了对象绘制时应遵循的管线。正如我们在[第 2 章](ee788533-687d-4231-91a4-cb1de9ca01dd.xhtml)，*数学和图形概念*中发现的，我们需要遵循一系列步骤来绘制对象：
- en: '![](img/14e58b29-0939-4abf-a065-4424953587e6.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14e58b29-0939-4abf-a065-4424953587e6.png)'
- en: In OpenGL, pipeline states can be changed at any time, just like we enabled
    and disabled blending when drawing text in [Chapter 8](ed5ec7d6-9257-48c4-9f66-3a2aca68eeeb.xhtml),
    *Enhancing Your Game with Collision, Loop, and Lighting*. However, changing states
    takes up a lot of system resources, which is why Vulkan discourages you from changing
    states at will. Therefore, you will have to set the pipeline states in advance
    for each object. Before you create a pipeline's state, you also need to create
    a pipeline layout that takes the descriptor set layout we created in the previous
    chapter. So, we will create the pipeline layout first.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL 中，管线状态可以在任何时候更改，就像我们在[第 8 章](ed5ec7d6-9257-48c4-9f66-3a2aca68eeeb.xhtml)，*通过碰撞、循环和光照增强你的游戏*中绘制文本时启用和禁用混合一样。然而，更改状态会占用大量系统资源，这就是为什么
    Vulkan 鼓励你不要随意更改状态。因此，你必须为每个对象预先设置管线状态。在你创建管线状态之前，你还需要创建一个管线布局，该布局将使用我们在上一章中创建的描述符集布局。所以，我们首先创建管线布局。
- en: Then, we also need to provide the shader SPIR-V files, which will have to be
    read to understand how to create the shader modules. So, add the functionality
    to the class. We then populate the graphics pipeline info, which will use the
    different shader modules that we created. We also specify the vertex input state,
    which will have information regarding the buffer's bindings and attributes, which
    we created earlier when defining the vertex struct.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还需要提供着色器 SPIR-V 文件，这些文件必须被读取以了解如何创建着色器模块。因此，向类中添加功能。然后我们填充图形管线信息，它将使用我们创建的不同着色器模块。我们还指定了顶点输入状态，它将包含有关我们之前在定义顶点结构时创建的缓冲区绑定和属性的信息。
- en: The input assembly state also needs to be specified, which describes the kind
    of geometry to be drawn with the vertices. Note that we can draw points, lines,
    or triangles with the given set of vertices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入装配状态也需要指定，它描述了将使用顶点绘制的几何类型。请注意，我们可以使用给定的顶点集绘制点、线或三角形。
- en: Additionally, we need to specify the viewport state, which describes the region
    of the framebuffer that will be rendered, as we can display part of the framebuffer
    to the viewport if necessary. In our case, we will be displaying the whole region
    to the viewport. We specify the rasterization state, which will perform depth
    testing and back-face culling, and convert the geometry to rasterized lines –
    which will be colored, as specified in the fragment shader.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要指定视图状态，它描述了将要渲染的帧缓冲区区域，因为如果需要，我们可以将帧缓冲区的一部分显示到视口中。在我们的情况下，我们将显示整个区域到视口中。我们指定了光栅化状态，它将执行深度测试和背面剔除，并将几何形状转换为光栅化线条——这些线条将按照片段着色器中指定的颜色进行着色。
- en: The multisampling state will specify whether you want to enable multisampling
    to enable anti-aliasing. The depth and stencil states specify whether the depth
    and stencil tests are enabled and are to be performed on the object. The color
    blending state specifies whether blending is enabled or not. Finally, the dynamic
    state enables us to change some pipeline states dynamically without creating the
    pipeline again. We won't be using dynamic states for our implementation. With
    all this set, we can create the graphics pipeline for the object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 多采样状态将指定是否要启用多采样以启用抗锯齿。深度和模板状态指定是否启用深度和模板测试，并且要在对象上执行。颜色混合状态指定是否启用混合。最后，动态状态使我们能够在不重新创建管线的情况下动态地更改一些管线状态。在我们的实现中，我们不会使用动态状态。设置好所有这些后，我们可以为对象创建图形管线。
- en: 'Let''s begin by creating a new class for the graphics pipeline. In the `GraphicsPipeline.h`
    file, add the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的类来处理图形管线。在`GraphicsPipeline.h`文件中，添加以下内容：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We include the usual headers and also `fstream`, because we will need it for
    reading the shader files. We then create the class itself. In the `public` section,
    we will add the constructor and destructor. We create objects for storing the `pipelineLayout`
    and `graphicsPipeline` of the `VkPipelineLayout` and `VkPipeline` types respectively.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了常用的头文件，还包含了`fstream`，因为我们需要它来读取着色器文件。然后我们创建类本身。在`public`部分，我们将添加构造函数和析构函数。我们创建了用于存储`VkPipelineLayout`和`VkPipeline`类型的`pipelineLayout`和`graphicsPipeline`对象的实例。
- en: We create a new function called `createGraphicsPipelineLayoutAndPipeline`, which
    takes `VkExtent2D`, `VkDesriptorSetLayout`, and `VkRenderPass`, as this is required
    for creating both the layout and the actual pipeline itself. The function will
    internally be calling `createGraphicsPipelineLayout` and `createGraphicsPipeline`,
    which will create the layout and the pipeline respectively. These functions are
    added to the `private` section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`createGraphicsPipelineLayoutAndPipeline`的新函数，它接受`VkExtent2D`、`VkDescriptorSetLayout`和`VkRenderPass`作为参数，因为这是创建布局和实际管线本身所必需的。该函数将内部调用`createGraphicsPipelineLayout`和`createGraphicsPipeline`，分别创建布局和管线。这些函数被添加到`private`部分。
- en: 'In the `public` section, we also have a function called `destroy`, which will
    destroy all the created resources. In the `private` section, we also have two
    more functions. The first is the `readFile` function, which reads the SPIR-V file,
    and the second is `createShaderModule`, which will create the shader module from
    the read shader file. Let''s now move on to the `GraphicsPipeline.cpp` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`部分，我们还有一个名为`destroy`的函数，它将销毁所有创建的资源。在`private`部分，我们还有另外两个函数。第一个是`readFile`函数，它读取SPIR-V文件，第二个是`createShaderModule`函数，它将从读取的着色器文件创建着色器模块。现在让我们转到`GraphicsPipeline.cpp`文件：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code block, we include the `GraphicsPipeline.h`, `VulkanContext.h`,
    and `Mesh.h` files because they are required. We also add the implementation for
    the constructor and the destructor.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们包含了`GraphicsPipeline.h`、`VulkanContext.h`和`Mesh.h`文件，因为它们是必需的。我们还添加了构造函数和析构函数的实现。
- en: 'We then add the `createGraphicsPipelineLayoutAndPipeline` function, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了`createGraphicsPipelineLayoutAndPipeline`函数，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `createPipelineLayout` function is created as follows. We have to create
    a `createInfo` struct with the structure type, set the `descriptorLayout` and
    count, and then create the pipeline layout using the `vkCreatePipelineLayout`
    function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`createPipelineLayout`函数的创建如下。我们必须创建一个`createInfo`结构体，设置结构类型，设置`descriptorLayout`和计数，然后使用`vkCreatePipelineLayout`函数创建管线布局：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before we add the create pipeline function, we will add the `readFile` and
    `createShaderModule` functions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加创建管线函数之前，我们将添加`readFile`和`createShaderModule`函数：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`readFile` takes a SPIR-V code file, opens and reads it, saves the contents
    of the file into a vector of char called `buffer`, and then returns it. We then
    add the `createShaderModule` function, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile` 函数接收一个 SPIR-V 代码文件，打开并读取它，将文件内容保存到名为 `buffer` 的字符向量中，然后返回它。然后我们添加
    `createShaderModule` 函数，如下所示：'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To create the shader module, which is required for `ShaderStageCreateInfo`
    to create the pipeline, we need to populate the `ShaderModuleCreateInfo,` which
    takes the code and the size from the buffer to create the shader module. The shader
    module is created using the `vkCreateShaderModule` function, which takes the device
    and the `CreateInfo`. Once the shader module is created, it is returned. To create
    the pipeline, we have to create the following info structs: the shader stage info,
    the vertex input info, the input assembly struct, the viewport info struct, the
    rasterization info struct, the multisample state struct, the depth stencil struct
    (if required), the color blending struct, and the dynamic state struct.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建所需的 `ShaderStageCreateInfo` 来创建管线，我们需要填充 `ShaderModuleCreateInfo`，它从缓冲区中获取代码和大小以创建着色器模块。着色器模块是通过
    `vkCreateShaderModule` 函数创建的，它接收设备和 `CreateInfo`。一旦创建了着色器模块，它就会被返回。要创建管线，我们必须创建以下信息结构体：着色器阶段信息、顶点输入信息、输入装配结构体、视口信息结构体、光栅化信息结构体、多重采样状态结构体、深度模板结构体（如果需要）、颜色混合结构体和动态状态结构体。
- en: 'So, let''s create each, one after the other, starting with the shader stage
    struct. Add the `createGraphicsPipeline` function, and in it, we will create the
    pipeline:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们依次创建每个结构体，从着色器阶段结构体开始。添加 `createGraphicsPipeline` 函数，并在其中创建管线：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this function, we will now add the following, which will create the graphics
    pipeline.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们现在将添加以下内容，这将创建图形管线。
- en: ShaderStageCreateInfo
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ShaderStageCreateInfo
- en: 'To create the vertex shader, `ShaderStageCreateInfo`, we need to read the shader
    code first and create the shader module for it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建顶点着色器 `ShaderStageCreateInfo`，我们需要首先读取着色器代码并为其创建着色器模块：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To read the shader file, we pass in the location of the shader file. Then,
    we pass the read code into the `createShaderModule` function, which will give
    us `vertexShaderModule`. We create the shader stage info struct for the vertex
    shader and pass in the stage, the shader module, and the name of the function
    to be used in the shader, which is `main`, in our case:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取着色器文件，我们传递着色器文件的路径。然后，我们将读取的代码传递给 `createShaderModule` 函数，这将给我们 `vertexShaderModule`。我们为顶点着色器创建着色器阶段信息结构体，并传递阶段、着色器模块以及要在着色器中使用的函数名称，在我们的例子中是
    `main`：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, we will create the `ShaderStageCreateInfo` struct for the fragment
    shader:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将为片段着色器创建 `ShaderStageCreateInfo` 结构体：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the shader stage is set to `VK_SHADER_STAGE_FRAGMENT_BIT` to show
    that this is the fragment shader, and we also pass in `basic.frag.spv` as the
    file to read, which is the fragment shader file. We then create an array of `shaderStageCreateInfo`
    and add the two shaders to it for convenience:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，着色器阶段被设置为 `VK_SHADER_STAGE_FRAGMENT_BIT` 以表明这是一个片段着色器，我们还传递了 `basic.frag.spv`
    作为要读取的文件，这是片段着色器文件。然后我们创建一个 `shaderStageCreateInfo` 数组，并将两个着色器添加到其中以方便使用：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: VertexInputStateCreateInfo
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VertexInputStateCreateInfo
- en: 'In this info, we specify the input buffer binding and the attribute description:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个信息中，我们指定了输入缓冲区绑定和属性描述：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is specified in the `Mesh.h` file under the vertex struct.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `Mesh.h` 文件下的顶点结构体中指定。
- en: InputAssemblyStateCreateInfo
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InputAssemblyStateCreateInfo
- en: 'Here, we specify the geometry we want to create, which is a triangle list.
    Add it as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定我们想要创建的几何形状，即三角形列表。添加如下：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: RasterizationStateCreateInfo
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RasterizationStateCreateInfo
- en: In this struct, we specify that depth clamping is enabled, which, instead of
    discarding the fragments if they are beyond the near and far planes, still keeps
    the value of that fragment and sets it equal to the near or far plane, even if
    that pixel is beyond either of these planes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构体中，我们指定启用深度裁剪，这意味着如果片段超出了近平面和远平面，不会丢弃这些片段，而是仍然保留该片段的值，并将其设置为近平面或远平面的值，即使该像素超出了这两个平面中的任何一个。
- en: Discard the pixel in the rasterization stage by setting the value of `rasterizerDiscardEnable` to
    true or false. Set the polygon mode to either `VK_POLYGON_MODE_FILL` or `VK_POLYGON_MODE_LINE`.
    If it is set to line, then only a wireframe will be drawn; otherwise, the insides
    are also rasterized.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `rasterizerDiscardEnable` 的值设置为 true 或 false 来在光栅化阶段丢弃像素。将多边形模式设置为 `VK_POLYGON_MODE_FILL`
    或 `VK_POLYGON_MODE_LINE`。如果设置为线，则只绘制线框；否则，内部也会被光栅化。
- en: We can set the line width with the `lineWidth` parameter. Additionally, we can
    enable or disable back-face culling and then set the order of the front face winding
    by setting the `cullMode` and `frontFace` parameters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`lineWidth`参数设置线宽。此外，我们可以启用或禁用背面剔除，然后通过设置`cullMode`和`frontFace`参数来设置前向面
    winding 的顺序。
- en: 'We can alter the depth value by enabling it and adding a constant value to
    the depth, clamping it, or adding a slope factor. Depth biases are used in shadow
    maps, which we won''t be using, so we won''t enable depth bias. Add the struct
    and populate it as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启用它并添加一个常数到深度，夹断它，或添加一个斜率因子来改变深度值。深度偏差在阴影图中使用，我们不会使用，所以不会启用深度偏差。添加结构体并按如下方式填充它：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: MultisampleStateCreateInfo
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MultisampleStateCreateInfo
- en: 'For our project, we won''t be enabling multisampling for anti-aliasing. However,
    we will still need to create the struct:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们不会启用多采样来抗锯齿。然而，我们仍然需要创建以下结构体：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We disable it by setting `sampleShadingEnable` to false and setting the sample
    count to `1`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`sampleShadingEnable`设置为false并将样本计数设置为`1`来禁用它。
- en: Depth and stencil create info
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度和模板创建信息
- en: Since we don't have a depth or stencil buffer, we don't need to create it. But
    when you have a depth buffer, you will need to add it to use the depth texture.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有深度或模板缓冲区，我们不需要创建它。但是，当你有一个深度缓冲区时，你需要将其添加到使用深度纹理。
- en: ColorBlendStateCreateInfo
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ColorBlendStateCreateInfo
- en: We set the color blending to false because it is not required for our project.
    To populate it, we have to first create the `ColorBlend` attachment state, which
    contains the configuration of each `ColorBlend` in each attachment. Then, we create
    `ColorBlendStateInfo`, which contains the overall blend state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将颜色混合设置为false，因为我们的项目不需要。为了填充它，我们必须首先创建`ColorBlend`附加状态，它包含每个附加中每个`ColorBlend`的配置。然后，我们创建`ColorBlendStateInfo`，它包含整体混合状态。
- en: 'Create the `ColorBlendAttachment` state as follows. In this, we still specify
    the color write mask, which is the red, green, blue, and alpha bits, and set the
    attachment state to false, which disables blending for the framebuffer attachment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`ColorBlendAttachment`状态如下。在这里，我们仍然指定颜色写入掩码，即红色、绿色、蓝色和alpha位，并将附加状态设置为false，以禁用帧缓冲区附加的混合：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We create the actual blend struct, which takes the blend attachment info created,
    and we set the attachment count to `1` because we have a single attachment:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建实际的混合结构体，它接受创建的混合附加信息，并将附加计数设置为`1`，因为我们有一个单独的附加：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Dynamic state info
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态状态信息
- en: Since we don't have any dynamic states, this is not created.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有任何动态状态，所以没有创建。
- en: ViewportStateCreateInfo
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ViewportStateCreateInfo
- en: In `ViewportStateCreateInfo`, we can specify the region of the framebuffer in
    which the output will be rendered to the viewport. So, we can render the scene
    but then only show some of it to the viewport. We can also specify a scissor rectangle,
    which will discard the pixels being rendered to the viewport.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewportStateCreateInfo`中，我们可以指定输出将被渲染到视口的帧缓冲区区域。因此，我们可以渲染场景，但只显示其中的一部分到视口。我们还可以指定一个裁剪矩形，这将丢弃渲染到视口的像素。
- en: 'However, we won''t be doing anything fancy like that because we will render
    the whole scene to the viewport as it is. To define the viewport size and scissor
    size, we have to create the respective structs, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会做任何花哨的事情，因为我们将会以原样渲染整个场景到视口。为了定义视口大小和裁剪大小，我们必须创建相应的结构体，如下所示：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For the viewport size and extent, we set them to the size of the `swapChain`
    image size in terms of width and height, starting from `(0, 0)`. We also set the
    minimum and maximum depth, which is normally between `0` and `1`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视口大小和范围，我们将它们设置为`swapChain`图像大小的宽度和高度，从`(0, 0)`开始。我们还设置了最小和最大深度，通常在`0`和`1`之间。
- en: For the scissor, since we want to show the whole viewport, we set the offset
    to `(0, 0)`, which indicates that we don't want the offset to start from where
    the viewport starts. Accordingly, we set the `scissor.extent` to the size of the
    `swapChain` image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于裁剪，由于我们想显示整个视口，我们将偏移设置为`(0, 0)`，这表示我们不想从视口开始的地方开始偏移。相应地，我们将`scissor.extent`设置为`swapChain`图像的大小。
- en: 'Now we can create `ViewportStateCreateInfo` function, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`ViewportStateCreateInfo`函数，如下所示：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: GraphicsPipelineCreateInfo
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphicsPipelineCreateInfo
- en: 'To create the graphics pipeline, we have to create the final `Info` struct,
    which we will populate with the `Info` structs we have created so far. So, add
    the struct as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建图形管线，我们必须创建最终的`Info`结构体，我们将使用迄今为止创建的`Info`结构体来填充它。所以，添加如下结构体：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We also need to pass in the pipeline layout, render the pass, and specify whether
    there are any subpasses:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要传递管线布局，渲染通道，并指定是否有任何子通道：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can create the pipeline, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建管线，如下所示：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Additionally, make sure that you destroy the shader modules, as they are no
    longer required:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保销毁着色器模块，因为它们不再需要：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And that is all for the `createGraphicsPipeline` function. Finally, add the
    `destroy` function, which will destroy the pipeline and the layout:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`createGraphicsPipeline`函数的所有内容到此为止。最后，添加`destroy`函数，该函数将销毁管线和布局：'
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The ObjectRenderer class
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象渲染器类
- en: With all the necessary classes created, we can finally create our `ObjectRenderer`
    class, which will render the mesh object to the scene.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了所有必要的类之后，我们最终可以创建我们的`ObjectRenderer`类，该类将渲染网格对象到场景中。
- en: 'Let''s create a new class called `ObjectRenderer`. In `ObjectRenderer.h`, add
    the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的类，称为`ObjectRenderer`。在`ObjectRenderer.h`中添加以下内容：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will include the descriptor, pipeline, and object buffer headers because
    they are required for the class. In the `public` section of the class, we will
    add objects of the three classes to define the pipeline, object buffers, and descriptors.
    We add four functions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将包含描述符、管线和对象缓冲区头文件，因为它们对于类是必需的。在类的`public`部分，我们将添加三个类的对象来定义管线、对象缓冲区和描述符。我们添加四个函数：
- en: The first one is the `createObjectRenderer` function, which takes the model
    type, the position in which the object needs to be created, and the scale of the
    object.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数是`createObjectRenderer`函数，它接受模型类型、对象需要创建的位置以及对象的比例。
- en: Then, we have `updateUniformBuffer`, which will update the uniform buffer at
    every different frame and pass it to the shader. This takes the camera as a parameter
    because it is needed to get the view and perspective matrices. So, include the
    camera header as well.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有了`updateUniformBuffer`函数，它将在每一帧更新统一缓冲区并将其传递给着色器。这个函数以相机作为参数，因为它需要获取视图和透视矩阵。因此，还需要包含相机头文件。
- en: We then have the `draw` function, which will be used to bind the pipeline, vertex,
    index, and descriptors to make the draw call.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们有`draw`函数，它将被用来绑定管线、顶点、索引和描述符以进行绘制调用。
- en: We also have a `destroy` function to call the `destroy` functions of the pipeline,
    descriptors, and object buffers.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一个`destroy`函数来调用管线、描述符和对象缓冲区的`destroy`函数。
- en: 'In the object''s `Renderer.cpp` file, add the following `include` and the `createObjectRenderer`
    function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象的`Renderer.cpp`文件中，添加以下`include`和`createObjectRenderer`函数：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We get the number of swap buffer images and their extents. Then, we create
    the vertex index and uniform buffers, we create and populate the descriptor set
    layout and sets, and then we create the graphics pipeline itself. Finally, we
    set the position and scale of the current object. Then, we add the `updateUniformBuffer`
    function. To get access to `SwapChain` and `RenderPass`, we will make some changes
    to the `VulkanContext` class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取交换缓冲区图像的数量及其范围。然后，我们创建顶点索引和统一缓冲区，创建并填充描述符集布局和集，然后创建图形管线本身。最后，我们设置当前对象的位置和缩放。然后，我们添加`updateUniformBuffer`函数。为了访问`SwapChain`和`RenderPass`，我们将对`VulkanContext`类进行一些修改：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we create a new `UniformBufferObject` struct called `ubo`. To do so, initialize
    the translation, rotation, and scale matrices. We then assign values for the scale
    and rotation matrices. After multiplying the scale, rotation, and translation
    matrices together, assign the result to the model matrix. From the `camera` class,
    we assign the view and projection matrices to `ubo.view` and `ubo.proj`. Then,
    we have to invert the *y* axis in the projection space because, in OpenGL, the
    *y* axis is already inverted. We now copy the updated `ubo` struct to the uniform
    buffer memory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的`UniformBufferObject`结构体，称为`ubo`。为此，初始化平移、旋转和缩放矩阵。然后，我们为缩放和旋转矩阵分配值。然后，我们将缩放、旋转和平移矩阵相乘的结果分配给模型矩阵。从`camera`类中，我们将视图和投影矩阵分配给`ubo.view`和`ubo.proj`。然后，我们必须在投影空间中反转*y*轴，因为在OpenGL中，*y*轴已经反转了。现在，我们将更新的`ubo`结构体复制到统一缓冲区内存中。
- en: 'Next is the `draw` function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`draw`函数：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before we actually make the draw call, we have to bind the graphics pipeline
    and pass in the vertex, index, and descriptor using the command buffer. To do
    this, we get the current command buffer and pass the commands through it. We will
    make changes to the `VulkanContext` class to get access to it as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际进行绘制调用之前，我们必须绑定图形管道，并通过命令缓冲区传入顶点、索引和描述符。为此，我们获取当前命令缓冲区并通过它传递命令。我们还将修改`VulkanContext`类以获取对它的访问权限。
- en: 'We make the draw call using `vkCmdDrawIndexed`, in which we pass in the current
    command buffer, the index size, the instance count, the start of the index (which
    is `0`), the vertex offset (which is again `0`), and the location of the first
    index (which is `0`). Then, we add the `destroy` function, which basically just
    calls the `destroy` function of the pipeline, the descriptor, and the object buffer:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`vkCmdDrawIndexed`进行绘制调用，其中我们传入当前命令缓冲区、索引大小、实例计数、索引的起始位置（为`0`）、顶点偏移（再次为`0`）和第一个索引的位置（为`0`）。然后，我们添加`destroy`函数，该函数基本上只是调用管道、描述符和对象缓冲区的`destroy`函数：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Changes to the VulkanContext class
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VulkanContext类的更改
- en: 'To get access to `SwapChain`, `RenderPass`, and the current command buffer,
    we will add the following functions to the `VulkanContext.h` file under the `VulkanContext`
    class in the `public` section:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取对`SwapChain`、`RenderPass`和当前命令缓冲区的访问权限，我们将在`VulkanContext.h`文件中`VulkanContext`类的`public`部分添加以下函数：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, in the `VulkanContext.cpp` file, add the implementation for accessing
    the values:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`VulkanContext.cpp`文件中，添加访问值的实现：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Camera class
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像机类
- en: 'We will create a basic camera class so that we can set the camera''s position
    and set the view and projection matrices. This class will be very similar to the
    camera class created for the OpenGL project. The `camera.h` file is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个基本的摄像机类，以便我们可以设置摄像机的位置并设置视图和投影矩阵。这个类将与为OpenGL项目创建的摄像机类非常相似。`camera.h`文件如下：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It has an `init` function, which takes the `FOV`, width, and height of the
    viewport, and the near and far planes to construct the projection matrix. We have
    a `setCameraPosition` function, which sets the location of the camera and two
    `getter` functions to get the camera view and projection matrices. In the `private`
    section, we have three local variables: two are for storing the projection and
    view matrices, and the third is a `vec3` for storing the camera''s position.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个`init`函数，该函数接受视口的`FOV`、宽度和高度以及近平面和远平面来构建投影矩阵。我们有一个`setCameraPosition`函数，用于设置摄像机的位置，以及两个`getter`函数来获取摄像机视图和投影矩阵。在`private`部分，我们有三个局部变量：两个用于存储投影和视图矩阵，第三个是一个`vec3`用于存储摄像机的位置。
- en: 'The `Camera.cpp` file is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera.cpp`文件如下：'
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the `init` function, we set the view and projection matrices, and then we
    add two getter functions and the `setCameraPosition` function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，我们设置视图和投影矩阵，然后添加两个`getter`函数和`setCameraPosition`函数。
- en: Drawing the object
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制对象
- en: 'Now that we have completed the prerequisites, let''s draw a triangle:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了先决条件，让我们绘制一个三角形：
- en: 'In `source.cpp`, include `Camera.h` and `ObjectRenderer.h`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`source.cpp`中包含`Camera.h`和`ObjectRenderer.h`：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `main` function, after initializing `VulkanContext`, create a new camera
    and an object to render, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，初始化`VulkanContext`之后，创建一个新的摄像机和一个要渲染的对象，如下所示：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `while` loop, update the object''s buffer and call the `object.draw`
    function:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，更新对象的缓冲区并调用`object.draw`函数：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When the program is done, call the `object.destroy` function:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序完成时，调用`object.destroy`函数：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the application and see a glorious triangle, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并看到一个辉煌的三角形，如下所示：
- en: '![](img/ab5584e7-f339-4be2-a71b-7576efe4a732.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ab5584e7-f339-4be2-a71b-7576efe4a732.png)'
- en: 'Woohoo! Finally, we have a triangle. Well, we are still not quite done yet.
    Remember the annoying validation layer error that we keep getting? Take a look:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！终于有一个三角形了。嗯，我们还没有完全完成。还记得我们一直遇到的讨厌的验证层错误吗？看看：
- en: '![](img/b5fc391a-688c-40f4-bb92-47d328b241e8.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5fc391a-688c-40f4-bb92-47d328b241e8.png)'
- en: 'It is time to understand why we are getting this error and what it actually
    means. This leads us to our final topic of this book: synchronization.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候了解为什么我们会得到这个错误以及它实际上意味着什么。这把我们带到了这本书的最后一个主题：同步。
- en: Synchronizing the object
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步对象
- en: The process of drawing is actually asynchronous, meaning that the GPU might
    have to wait until the CPU has finished its current job. For example, using the
    constant buffer, we send instructions to the GPU to update each frame of the model
    view projection matrix. Now, if the GPU doesn't wait for the CPU to get the uniform
    buffer for the current frame, then the object would not be rendered correctly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图的过程实际上是异步的，这意味着GPU可能必须等待CPU完成当前工作。例如，使用常量缓冲区，我们向GPU发送指令以更新模型视图投影矩阵的每一帧。现在，如果GPU不等待CPU获取当前帧的统一缓冲区，则对象将无法正确渲染。
- en: 'To make sure that the GPU only executes when the CPU has done its work, we
    need to synchronize the CPU and GPU. This can be done using two types synchronization
    objects:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保GPU仅在CPU完成其工作后执行，我们需要同步CPU和GPU。这可以通过两种类型的同步对象来完成：
- en: The first is fences. Fences are synchronization objects that synchronize CPU
    and GPU operations.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一类是栅栏。栅栏是同步CPU和GPU操作的对象。
- en: We have a second kind of synchronization object, called semaphores. Semaphore
    objects synchronize GPU queues. In the current scene of one triangle that we are
    rendering, the graphics queue submits all the graphics commands, and then the
    presentation queue takes the image and presents it to the viewport. Of course,
    even this needs to be synchronized; otherwise, we will see scenes that haven't
    been fully rendered.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一种同步对象，称为信号量。信号量对象同步GPU队列。在我们当前渲染的单个三角形场景中，图形队列提交所有图形命令，然后显示队列获取图像并将其呈现到视口。当然，这同样需要同步；否则，我们将看到尚未完全渲染的场景。
- en: There are also events and barriers, which are other types of synchronization
    objects used for synchronizing work within a command buffer or a sequence of command
    buffers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外还有事件和屏障，它们是用于在命令缓冲区或一系列命令缓冲区内部同步工作的其他类型的同步对象。
- en: Since we haven't used any synchronization objects, the Vulkan validation layer
    is throwing errors and telling us that when we acquire an image from the SwapChain,
    we need to either use a fence or a semaphore to synchronize it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有使用任何同步对象，Vulkan验证层正在抛出错误并告诉我们，当我们从SwapChain获取图像时，我们需要使用栅栏或信号量来同步它。
- en: 'In `VulkanContext.h`, in the `private` section, we will add the synchronization
    objects to be created, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VulkanContext.h`中的`private`部分，我们将添加要创建的同步对象，如下所示：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have created two semaphores: one semaphore to signal when an image is available
    for us to render into, and another to signal when the rendering of the image has
    finished. We also created two fences to synchronize the two frames. In `VulkanContext.cpp`,
    under the `initVulkan` function, create the `Synchronization` object after the
    `DrawCommandBuffer` object:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个信号量：一个用于在图像可供我们渲染时发出信号，另一个用于在图像渲染完成后发出信号。我们还创建了两个栅栏来同步两个帧。在`VulkanContext.cpp`中的`initVulkan`函数下，在创建`DrawCommandBuffer`对象之后创建`Synchronization`对象：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We created the semaphore first using the `semaphoreCreatInfo` struct. We just
    have to set the struct type; we can create it using the `vkCreateSemaphore` function
    and pass in the logical device and the info struct.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`semaphoreCreateInfo`结构体创建了信号量。我们只需设置结构体类型；我们可以使用`vkCreateSemaphore`函数创建它，并传递逻辑设备和信息结构体。
- en: 'Next, we create our fences. We resize the vector with the number of frames
    in flight, which is `2`. Then, we create the `fenceCreateInfo` struct and set
    the type of the struct. We now also signal the fences so that they are ready to
    be rendered. Then, we create the fences using `vkCreateFence` and pass in the
    logical device and the create fence info using a `for` loop. In the `DrawBegin`
    function, when we acquire the image, we pass in the `imageAvailable` semaphore
    to the function so that the semaphore will be signaled when the image is available
    for us to render into:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的栅栏。我们将向量的大小调整为正在飞行的帧数，即`2`。然后，我们创建`fenceCreateInfo`结构体并设置其类型。现在我们还发出信号，使栅栏准备好渲染。然后，我们使用`vkCreateFence`创建栅栏，并通过`for`循环传递逻辑设备和创建栅栏的信息。在`DrawBegin`函数中，当我们获取图像时，我们将`imageAvailable`信号量传递给函数，以便当图像可供我们渲染时，信号量将被发出：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once an image is available to render into, we wait for the fence to be signaled
    so that we can start writing our command buffers:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图像可供渲染，我们等待栅栏发出信号，以便我们可以开始编写我们的命令缓冲区：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We wait for the fence by calling `vkWaitForFences` and pass in the logical
    device, the fence count (which is `1`), and the fence itself. Then, we pass `TRUE`
    to wait for all fences, and pass in a timeout. Once the fence is available, we
    set it to unsignaled by calling `vkResetFence`, and then pass in the logical device,
    the fence count, and the fence:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `vkWaitForFences` 来等待栅栏，并传入逻辑设备、栅栏计数（为 `1`）以及栅栏本身。然后，我们传入 `TRUE` 以等待所有栅栏，并传入超时时间。一旦栅栏可用，我们通过调用
    `vkResetFence` 将其设置为未触发状态，然后传入逻辑设备、栅栏计数和栅栏：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The reset of the `DrawBegin` function remains the same so that we can begin
    recording the command buffer. Now, in the `DrawEnd` function, when it is time
    to submit the command buffer, we set the pipeline stage for `imageAvailableSemaphore`
    to wait on and set `imageAvailableSemaphore` to wait. We will set `renderFinishedSemaphore`
    to be signaled.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawBegin` 函数的重置保持不变，这样我们就可以开始记录命令缓冲区。现在，在 `DrawEnd` 函数中，当提交命令缓冲区的时间到来时，我们设置
    `imageAvailableSemaphore` 的管道阶段以等待，并将 `imageAvailableSemaphore` 设置为等待。我们将 `renderFinishedSemaphore`
    设置为触发状态。'
- en: 'The `submitInfo` struct is changed accordingly:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`submitInfo` 结构体相应地进行了更改：'
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The stage to wait on is `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` for
    `imageAvailableSemaphore` to go from unsignaled to signaled. This will be signaled
    when the color buffer is written to. We then set `renderFinishedSemaphore` to
    be signaled so that the image will be ready for presenting. Submit the command
    and pass in the fence to show that the submission has been done:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 等待的阶段是 `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`，以便 `imageAvailableSemaphore`
    从未触发状态变为触发状态。这将在颜色缓冲区被写入时触发。然后，我们将 `renderFinishedSemaphore` 设置为触发状态，以便图像准备好进行展示。提交命令并传入栅栏以显示提交已完成：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once the submission is done, we can present the image. In the `presentInfo`
    struct, we set `renderFinishedSemaphore` to wait to go from an unsignaled state
    to a signaled state. We do this because, when the semaphore is signaled, the image
    will be ready for presentation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提交完成，我们就可以展示图像。在 `presentInfo` 结构体中，我们将 `renderFinishedSemaphore` 设置为等待从未触发状态变为触发状态。我们这样做是因为，当信号量被触发时，图像将准备好进行展示：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `cleanup` function in `VulkanContext`, make sure that you destroy the
    semaphores and fences, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `VulkanContext` 中的 `cleanup` 函数中，确保销毁信号量和栅栏，如下所示：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now build and run the application in debug mode and see that the validation
    layer has stopped complaining:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以调试模式构建并运行应用程序，看看验证层是否停止了抱怨：
- en: '![](img/fb29545e-ac23-43a4-968b-a5260e027511.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb29545e-ac23-43a4-968b-a5260e027511.png)'
- en: 'Now draw other objects as well, such as a quad, cube, and sphere, by changing
    the `source.cpp` file as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过更改 `source.cpp` 文件，绘制其他对象，例如四边形、立方体和球体：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And this should be the final output, with all the objects rendered:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是最终的输出，其中所有对象都已渲染：
- en: '![](img/a298e7f5-a683-46ee-851e-1f49d7253608.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a298e7f5-a683-46ee-851e-1f49d7253608.png)'
- en: You can also add custom geometries that can be loaded from a file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加可以从文件加载的自定义几何形状。
- en: In addition to this, now that you have different shapes to render, you can add
    physics and try to replicate the physics game made in OpenGL, and port the game
    to use the Vulkan rendering API.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在你有不同的形状可以渲染，可以添加物理效果并尝试复制在 OpenGL 中制作的物理游戏，并将游戏移植到使用 Vulkan 渲染 API。
- en: Furthermore, the code can be extended to include the depth buffer, adding textures
    to the object, and more.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，代码可以扩展以包括深度缓冲区，向对象添加纹理等。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, this is the final summary of this book. In this book, we journeyed from
    creating a basic game in Simple and Fast Multimedia Library (SFML), which uses
    OpenGL for rendering, to showing how a rendering API fits into the whole scheme
    when making a game.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是本书的最终总结。在这本书中，我们从在 Simple and Fast Multimedia Library (SFML) 中创建一个基本游戏开始，该库使用
    OpenGL 进行渲染，然后展示了在制作游戏时渲染 API 如何融入整个方案。
- en: We then created a complete physics-based game from the ground up, using our
    own mini game engine. Apart from just drawing objects using the high-level OpenGL
    graphics API, we also added bullet physics to take care of game physics and contact
    detection between game objects. We also added some text rendering to make the
    score visible to the player, and we also learned about basic lighting to do lighting
    calculations for our small scene in order to make the scene a little more interesting.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后从头开始创建了一个基于物理的完整游戏，使用我们自己的小型游戏引擎。除了使用高级 OpenGL 图形 API 绘制对象外，我们还添加了 bullet
    物理引擎来处理游戏物理和游戏对象之间的碰撞检测。我们还添加了一些文本渲染，以便玩家可以看到分数，并且我们还学习了基本的照明，以便为我们的小场景进行照明计算，使场景更加有趣。
- en: Finally, we moved on to the Vulkan rendering API, which is a low-level graphics
    library. In comparison to OpenGL, which we used to make a small game by the end
    of [Chapter 3](7ae25a2f-fcf6-4501-a5f3-e5b7fb6e27c3.xhtml), *Setting Up Your Game*,
    in Vulkan, at the end of four chapters, we were able to render a basic geometric
    objects. However, with Vulkan, we have complete access to the GPU, which gives
    us more freedom to tailor the engine based on the game's requirements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们转向了 Vulkan 渲染 API，这是一个低级图形库。与我们在第三章“设置你的游戏”结束时使用 OpenGL 制作的小游戏相比，在 Vulkan
    中，我们到第四章结束时就能渲染基本的几何对象。然而，与 Vulkan 相比，我们能够完全访问 GPU，这给了我们更多的自由度来根据游戏需求定制引擎。
- en: If you have come this far, then congratulations! I hope you enjoyed going through
    this book and that you will continue to expand your knowledge of the SFML, OpenGL,
    and Vulkan projects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经走到这一步，那么恭喜你！我希望你喜欢阅读这本书，并且你将继续扩展你对 SFML、OpenGL 和 Vulkan 项目的知识。
- en: Best wishes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 祝好运。
- en: Further Reading
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more, I wholeheartedly recommend the Vulkan tutorial website: [https://vulkan-tutorial.com/](https://vulkan-tutorial.com/).
    The tutorial also covers how to add textures, depth buffers, model loading, and
    mipmaps. The code for the book is based on this tutorial, so it should be easy
    to follow and should help you take the Vulkan code base in the book further:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多，我强烈推荐访问 Vulkan 教程网站：[https://vulkan-tutorial.com/](https://vulkan-tutorial.com/)。该教程还涵盖了如何添加纹理、深度缓冲区、模型加载和米柏映射。本书的代码基于这个教程，因此应该很容易跟随，并有助于你进一步学习书中的
    Vulkan 代码库：
- en: '![](img/e6b960d7-7c8f-4186-bfd6-c1d914324702.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6b960d7-7c8f-4186-bfd6-c1d914324702.png)'
- en: 'The source code for the Doom 3 Vulkan renderer is available at [https://github.com/DustinHLand/vkDOOM3](https://github.com/DustinHLand/vkDOOM3)—it
    is fun to see the code in practice:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Doom 3 Vulkan 渲染器的源代码可在[https://github.com/DustinHLand/vkDOOM3](https://github.com/DustinHLand/vkDOOM3)找到——看到实际应用的代码很有趣：
- en: '![](img/e7c5ce9e-a689-4545-a3db-5e9bfce2cf41.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7c5ce9e-a689-4545-a3db-5e9bfce2cf41.png)'
- en: I also recommend reading the blog at [https://www.fasterthan.life/blog](https://www.fasterthan.life/blog),
    as it goes through the journey of porting the Doom 3 OpenGL code to Vulkan. In
    this book, we let Vulkan allocate and deallocate resources. This blog goes into
    detail about how memory management is done in Vulkan.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我还推荐阅读[https://www.fasterthan.life/blog](https://www.fasterthan.life/blog)上的博客，因为它讲述了将
    Doom 3 OpenGL 代码移植到 Vulkan 的过程。在这本书中，我们让 Vulkan 负责分配和释放资源。该博客详细介绍了 Vulkan 中内存管理的实现方式。
