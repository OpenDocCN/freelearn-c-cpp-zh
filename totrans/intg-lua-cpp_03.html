<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer031">
<h1 class="chapter-number" id="_idParaDest-63"><a id="_idTextAnchor063"/>3</h1>
<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>How to Call Lua from C++</h1>
<p>In this chapter, we will implement a C++ utility class to execute Lua scripts. This serves two purposes. First, by doing this, you will learn in detail how to integrate the Lua library and call Lua code from C++. Second, you will have a Lua wrapper class ready to use. This helps in hiding all the details. We will start with a basic Lua executor and then we will gradually add more features to it as we progress. You will learn about <span class="No-Break">the following:</span></p>
<ul>
<li>Implementing a <span class="No-Break">Lua executor</span></li>
<li>Executing a <span class="No-Break">Lua file</span></li>
<li>Executing a <span class="No-Break">Lua script</span></li>
<li>Understanding the <span class="No-Break">Lua stack</span></li>
<li>Operating on <span class="No-Break">global variables</span></li>
<li>Calling <span class="No-Break">Lua functions</span></li>
</ul>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>Technical requirements</h2>
<p>Starting from this chapter, we will focus more on code and Lua integration itself and will be brief about toolchain and project settings. However, you can always refer to the book’s GitHub repository to get the complete projects. Please make sure you meet the <span class="No-Break">following requirements:</span></p>
<ul>
<li>You need to be able to compile the Lua library from source code. <span class="No-Break"><em class="italic">Chapter 1</em></span> <span class="No-Break">covered this.</span></li>
<li>You need to be able to write some basic Lua code to test the C++ class that we will write. <span class="No-Break"><em class="italic">Chapter 2</em></span> <span class="No-Break">covered this.</span></li>
<li>You can create a <strong class="source-inline">Makefile</strong> project, or use an alternative. In <span class="No-Break"><em class="italic">Chapter 1</em></span>, we created three <strong class="source-inline">Makefile</strong> projects. We will create a new project for <span class="No-Break">this chapter.</span></li>
<li>You can access the source code for this chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter03</span></a><a href="https://github.com/PacktPublishing/Integrate-Lua-to-CPP/tree/main/Chapter03%0D"/></li>
</ul>
<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/>Implementing a Lua executor</h1>
<p>We will implement a reusable C++ Lua executor<a id="_idIndexMarker113"/> class step by step. Let us call it <strong class="source-inline">LuaExecutor</strong>. We will continue to improve this executor by adding new functions <span class="No-Break">to it.</span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/>How to include the Lua library in C++ code</h2>
<p>To work with<a id="_idIndexMarker114"/> the Lua library, you<a id="_idIndexMarker115"/> only need three <span class="No-Break">header files:</span></p>
<ul>
<li><strong class="source-inline">lua.h</strong> for core<a id="_idIndexMarker116"/> functions. Everything here has a <span class="No-Break"><strong class="source-inline">lua_</strong></span><span class="No-Break"> prefix.</span></li>
<li><strong class="source-inline">lauxlib.h</strong> for the auxiliary library (<strong class="source-inline">auxlib</strong>). The auxiliary library provides more helper functions built on top of the core functions in <strong class="source-inline">lua.h</strong>. Everything here has a <span class="No-Break"><strong class="source-inline">luaL_</strong></span><span class="No-Break"> prefix.</span></li>
<li><strong class="source-inline">lualib.h</strong> for loading and building Lua libraries. For example, the <strong class="source-inline">luaL_openlibs</strong> function opens all <span class="No-Break">standard libraries.</span></li>
</ul>
<p>Lua is implemented in C and those three header files are C header files. To work with C++, Lua provides a convenient wrapper, <strong class="source-inline">lua.hpp</strong>, whose content is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
extern "C" {
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}</pre>
<p>In your C++ code, <strong class="source-inline">lua.hpp</strong> is the only Lua header file you need to include. With this sorted out, let us start to work on our <span class="No-Break">Lua executor.</span></p>
<p class="callout-heading">C++ filename extensions</p>
<p class="callout">The Lua library<a id="_idIndexMarker117"/> uses <strong class="source-inline">hpp</strong> as the header file extension for <strong class="source-inline">lua.hpp</strong>. This is to distinguish it from other C header files from the Lua library. In this book, for our own C++ code, we use <strong class="source-inline">h</strong> for header files with declaration, <strong class="source-inline">hpp</strong> for header files that include all implementation, <strong class="source-inline">cc</strong> for C++ class implementation, and <strong class="source-inline">cpp</strong> for C++ code not part of a class. This is only one way to name the source code files. Feel free to use your <span class="No-Break">own convention.</span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>Getting a Lua instance</h2>
<p>We need<a id="_idIndexMarker118"/> to get hold of “an instance” of the Lua library to execute Lua scripts. With some other C++ library, you might<a id="_idIndexMarker119"/> create a certain class instance and work with the object. With Lua, you get a <strong class="bold">Lua state</strong> and pass this state around for <span class="No-Break">different operations.</span></p>
<p>Our Lua executor will hide the low-level Lua library details and provide a high-level API for your projects. Here is the <strong class="source-inline">LuaExecutor.h</strong> class definition to <span class="No-Break">start with:</span></p>
<pre class="source-code">
#include &lt;lua.hpp&gt;
class LuaExecutor
{
public:
    LuaExecutor();
    virtual ~LuaExecutor();
private:
    lua_State *const L;
};</pre>
<p>We have defined a constructor, a destructor, and a private member variable of type <strong class="source-inline">lua_State</strong>, which is the Lua state, and named it <strong class="source-inline">L</strong> per <span class="No-Break">Lua conventions.</span></p>
<p>Here is the <strong class="source-inline">LuaExecutor.cc</strong> class implementation for the definition <span class="No-Break">so far:</span></p>
<pre class="source-code">
#include "LuaExecutor.h"
LuaExecutor::LuaExecutor()
    : L(luaL_newstate())
{
    luaL_openlibs(L);
}
LuaExecutor::~LuaExecutor()
{
    lua_close(L);
}</pre>
<p>The class encapsulates the creation and cleaning up of <span class="No-Break">Lua state:</span></p>
<ol>
<li><strong class="source-inline">luaL_newstate()</strong> creates a new Lua state. We do this in the constructor <span class="No-Break">initializer list.</span></li>
<li><strong class="source-inline">luaL_openlibs(L)</strong> opens the Lua standard libraries for the provided Lua state. This makes library functions – for example, <strong class="source-inline">string.gmatch</strong> – available to be used in <span class="No-Break">Lua scripts.</span></li>
<li><strong class="source-inline">lua_close(L)</strong> closes the Lua state and releases its allocated resources – for example, dynamically <a id="_idIndexMarker120"/>allocated memory, and <span class="No-Break">so on.</span></li>
</ol>
<p>We will now learn more about <span class="No-Break">Lua state.</span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>What is Lua state?</h2>
<p>The Lua library <a id="_idIndexMarker121"/>maintains no global state, instead, except for <strong class="source-inline">luaL_newstate</strong>, all Lua library functions expect a Lua state as the first parameter. This makes Lua re-entrant and it can be used for multithreaded code with <span class="No-Break">little effort.</span></p>
<p>Lua state is a structure named <strong class="source-inline">lua_State</strong> that keeps all Lua internal states. To create a Lua state, use <strong class="source-inline">luaL_newstate</strong>. You can use Lua and treat this state transparently, without being concerned about its <span class="No-Break">internal details.</span></p>
<p>We can compare this to C++ classes. Lua state<a id="_idIndexMarker122"/> holds the class member variables and states. Lua library functions serve<a id="_idIndexMarker123"/> the purpose of class member functions. To go one step further, consider the C++ <strong class="bold">pimpl</strong> (pointer to <span class="No-Break">implementation) idiom:</span></p>
<pre class="source-code">
class Lua
{
public:
    void openlibs();
private:
    LuaState *pImpl;
};
struct LuaState
{
    // implementation details
};</pre>
<p>In this analogy, <strong class="source-inline">class Lua</strong> is our pseudo C++ Lua library; <strong class="source-inline">struct LuaState</strong> is the private implementation that defines and hides the details. In header files, you would only see its forward declaration, not the definition. The <strong class="source-inline">openlibs</strong> public member function uses <strong class="source-inline">pImpl</strong> (the Lua <span class="No-Break">state) internally.</span></p>
<p>As an advanced topic, C++ member functions will have <strong class="source-inline">this</strong> as the first parameter after being compiled. The Lua library functions expecting <strong class="source-inline">LuaState</strong> as their first parameter can be understood in a similar way: both <strong class="source-inline">this</strong> and <strong class="source-inline">LuaState</strong> point to the private details of <span class="No-Break">the class.</span></p>
<p>All this information is to make you feel comfortable in passing Lua state around, while at the same time remaining at ease with not operating on it directly. Now, let us go back and continue<a id="_idIndexMarker124"/> to build our <span class="No-Break">Lua executor.</span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/>Executing a Lua file</h1>
<p>In <span class="No-Break"><em class="italic">Chapter 1</em></span>, we used the Lua library<a id="_idIndexMarker125"/> to load a file and run the script. We will do the same here but in a more proper C++ way. In <strong class="source-inline">LuaExecutor.h</strong>, add the following <span class="No-Break">new code:</span></p>
<pre class="source-code">
#include &lt;string&gt;
class LuaExecutor
{
public:
    void executeFile(const std::string &amp;path);
private:
    void pcall(int nargs = 0, int nresults = 0);
    std::string popString();
};</pre>
<p>You can of course make all those member functions <strong class="source-inline">const</strong>, for example, <strong class="source-inline">std::string popString() const</strong>, because in <strong class="source-inline">LuaExecutor</strong> we only keep the Lua state <strong class="source-inline">L</strong> transparently and do not change its value. Here, we are omitting it to prevent too many line breaks in <span class="No-Break">code listings.</span></p>
<p><strong class="source-inline">executeFile</strong> is our public function and the other two are internal helper functions. In <strong class="source-inline">LuaExecutor.cc</strong>, let us implement <span class="No-Break"><strong class="source-inline">executeFile</strong></span><span class="No-Break"> first:</span></p>
<pre class="source-code">
#include &lt;iostream&gt;
void LuaExecutor::executeFile(const std::string &amp;path)
{
    if (luaL_loadfile(L, path.c_str()))
    {
        std::cerr &lt;&lt; "Failed to prepare file: "
                  &lt;&lt; popString() &lt;&lt; std::endl;
        return;
    }
    pcall();
}</pre>
<p>We load the script with <strong class="source-inline">luaL_loadfile</strong>, providing the file path. <strong class="source-inline">luaL_loadfile</strong> will load the file, compile it into a <strong class="bold">chunk</strong>, and put it onto the <strong class="bold">Lua stack</strong>. We will explain what a chunk<a id="_idIndexMarker126"/> is and what the Lua<a id="_idIndexMarker127"/> stack <span class="No-Break">is soon.</span></p>
<p>Most Lua library functions<a id="_idIndexMarker128"/> will return 0 if they are successful. You can also compare the return value with <strong class="source-inline">LUA_OK</strong> explicitly, which is defined as 0. In our case, if no error occurs, we will proceed to the next step to call <strong class="source-inline">pcall</strong>. If there is an error, we will get the error with <strong class="source-inline">popString</strong> and print it out. Next, implement <strong class="source-inline">pcall</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void LuaExecutor::pcall(int nargs, int nresults)
{
    if (lua_pcall(L, nargs, nresults, 0))
    {
        std::cerr &lt;&lt; "Failed to execute Lua code: "
                  &lt;&lt; popString() &lt;&lt; std::endl;
    }
}</pre>
<p>In <strong class="source-inline">pcall</strong>, we execute the compiled chunk, which is already on the top of the stack, with <strong class="source-inline">lua_pcall</strong>. This will also remove the chunk from the stack. If an error occurs, we retrieve and print out the <span class="No-Break">error message.</span></p>
<p>Besides <strong class="source-inline">L</strong>, <strong class="source-inline">lua_pcall</strong> takes three more parameters. We are passing 0 for them now. For now, you only need to know that the second parameter is the number of parameters the Lua chunk expects, and the third parameter is the number of values the Lua <span class="No-Break">chunk returns.</span></p>
<p>Finally, we will implement the last <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">popString</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
std::string LuaExecutor::popString()
{
    std::string result(lua_tostring(L, -1));
    lua_pop(L, 1);
    return result;
}</pre>
<p>This pops the top<a id="_idIndexMarker129"/> of the Lua stack as a string. We will explain more when you learn more about the <span class="No-Break">Lua stack.</span></p>
<p>We have two concepts to explain before trying <span class="No-Break">out </span><span class="No-Break"><strong class="source-inline">LuaExecutor</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>What is a chunk?</h2>
<p>A unit of compilation<a id="_idIndexMarker130"/> in Lua is called a chunk. Syntactically, a chunk is simply a code block. When put on the stack, a chunk is a value of the function type. So, although not fully accurate, you can consider it a function, and a Lua file an implicit function definition. Further, functions can have embedded functions defined <span class="No-Break">within them.</span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>What is a Lua stack?</h2>
<p>A Lua stack<a id="_idIndexMarker131"/> is a stack data structure. Each Lua state internally maintains a Lua stack. Each element in the stack can hold a reference to a piece of Lua data. If you recall that a function is also a basic Lua type, you will feel more comfortable about a stack element representing a function. Both Lua code and C++ code can push elements onto and pop elements from the Lua stack, either explicitly or implicitly. We will discuss more about the Lua stack and how our <strong class="source-inline">popString</strong> function works later in <span class="No-Break">this chapter.</span></p>
<p>Now you have learned about chunks and the Lua stack, two of the important concepts in Lua, we can <span class="No-Break">test </span><span class="No-Break"><strong class="source-inline">LuaExecutor</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Testing the Lua executor so far</h2>
<p>To test<a id="_idIndexMarker132"/> our executor, we need to write a Lua script and some C++ test code to call <strong class="source-inline">LuaExecutor</strong>. Write <strong class="source-inline">script.lua</strong> as the <span class="No-Break">following one-liner:</span></p>
<pre class="source-code">
print("Hello C++")</pre>
<p>This will print <strong class="source-inline">Hello C++</strong> to <span class="No-Break">the console.</span></p>
<p>Write <strong class="source-inline">main.cpp</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#include "LuaExecutor.h"
int main()
{
    LuaExecutor lua;
    lua.executeFile("script.lua");
    return 0;
}</pre>
<p>This will create an instance of <strong class="source-inline">LuaExecutor</strong> and execute the Lua <span class="No-Break">script file.</span></p>
<p>Now, write <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Makefile</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
LUA_PATH = ../lua/src
CXX = g++
CXXFLAGS = -Wall -Werror
CPPFLAGS = -I${LUA_PATH}
LDFLAGS = -L${LUA_PATH}
EXECUTABLE = executable
all: lua project
lua:
    @cd ../lua &amp;&amp; make
project: main.cpp LuaExecutor.cc LuaExecutor.h
    $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) -o
       $(EXECUTABLE) main.cpp LuaExecutor.cc -llua
clean:
    rm -f $(EXECUTABLE)</pre>
<p>Compared to the <strong class="source-inline">Makefiles</strong> in <span class="No-Break"><em class="italic">Chapter 1</em></span>, we have one more source file, <strong class="source-inline">LuaExecutor.cc</strong>, and one more header file, <strong class="source-inline">LuaExecutor.h</strong>, that the <strong class="source-inline">project</strong> target depends on. Remember to use tabs for indentations, not spaces. You can find explanations on how to write a <strong class="source-inline">Makefile</strong> in <span class="No-Break"><em class="italic">Chapter 1</em></span> if you need to <span class="No-Break">revisit it.</span></p>
<p>With all the test code written, test this out in <span class="No-Break">a terminal:</span></p>
<pre class="source-code">
Chapter03 % make
Chapter03 % ./executable
Hello C++</pre>
<p>If you have done everything correctly, the code will compile. When executed, it will output <strong class="source-inline">Hello C++</strong>, which is from the Lua <span class="No-Break">script file.</span></p>
<p>We have learned how<a id="_idIndexMarker133"/> to execute Lua code from a file. Now let us try to execute a Lua <span class="No-Break">script directly.</span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>Executing a Lua script</h1>
<p>In some projects, you may have<a id="_idIndexMarker134"/> a file layer abstraction, or you may get a Lua script from a remote server. Then, you cannot pass a file path to the Lua library and ask it to load it for you. You may also want to load the file yourself as a string to do more auditing before executing it. In those situations, you can ask the Lua library to execute a string as a <span class="No-Break">Lua script.</span></p>
<p>To do this, we will add a new capability to our Lua executor. In <strong class="source-inline">LuaExecutor.h</strong>, add one <span class="No-Break">more function:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    void execute(const std::string &amp;script);
};</pre>
<p>This new function will accept the Lua code in a string directly and <span class="No-Break">execute it.</span></p>
<p>In <strong class="source-inline">LuaExecutor.cc</strong>, add <span class="No-Break">this implementation:</span></p>
<pre class="source-code">
void LuaExecutor::execute(const std::string &amp;script)
{
    if (luaL_loadstring(L, script.c_str()))
    {
        std::cerr &lt;&lt; "Failed to prepare script: "
                  &lt;&lt; popString() &lt;&lt; std::endl;
        return;
    }
    pcall();
}</pre>
<p>This new function is exactly the same as <strong class="source-inline">executeFile</strong> with only one difference. It calls the Lua library <strong class="source-inline">luaL_loadstring</strong> function, which compiles the string as Lua code and puts the compiled<a id="_idIndexMarker135"/> chunk onto the stack. Then, <strong class="source-inline">pcall</strong> will pop and execute <span class="No-Break">the chunk.</span></p>
<h3>Testing it out</h3>
<p>Let us test<a id="_idIndexMarker136"/> a Lua script. We no longer need a script file now. Write <strong class="source-inline">main.cpp</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#include "LuaExecutor.h"
int main()
{
    LuaExecutor lua;
    lua.execute("print('Hello Lua')");
    return 0;
}</pre>
<p>This tells the Lua executor to run the <span class="No-Break">Lua code:</span></p>
<pre class="source-code">
print('Hello Lua')</pre>
<p>Make and run the project and you will see the output <span class="No-Break"><strong class="source-inline">Hello Lua</strong></span><span class="No-Break">.</span></p>
<h3>More on Lua compilation and execution</h3>
<p>As explained before, <strong class="source-inline">luaL_loadstring</strong> and <strong class="source-inline">luaL_loadfile</strong> will compile the Lua code, while <strong class="source-inline">lua_pcall</strong> will execute the compiled code. In our <strong class="source-inline">LuaExecutor</strong> implementation, we are outputting different error messages – <strong class="source-inline">Failed to prepare</strong> and <strong class="source-inline">Failed to execute</strong> respectively. Let us test the two different scenarios to understand the execution <span class="No-Break">stages more.</span></p>
<h4>Testing compilation errors</h4>
<p>In <strong class="source-inline">main.cpp</strong>, change the statement<a id="_idIndexMarker137"/> to execute the Lua code and make a Lua syntax error intentionally, by deleting the <span class="No-Break">closing parenthesis:</span></p>
<pre class="source-code">
lua.execute("print('Hello Lua'");</pre>
<p>Now recompile the project and run it. You should see the following <span class="No-Break">error output:</span></p>
<pre class="source-code">
Failed to prepare script: [string "print('Hello Lua'"]:1:
')' expected near &lt;eof&gt;</pre>
<p><strong class="source-inline">pcall</strong> is not called at all, because the Lua code failed <span class="No-Break">to compile.</span></p>
<h4>Testing the runtime error</h4>
<p>This time, change<a id="_idIndexMarker138"/> the Lua code to <span class="No-Break">the following:</span></p>
<pre class="source-code">
lua.execute("print(a / 2)");</pre>
<p>There is no syntax error. Recompile, run the project, and see the <span class="No-Break">new error:</span></p>
<pre class="source-code">
Failed to execute Lua code: [string "print(a / 2)"]:1:
attempt to perform arithmetic on a nil value (global 'a')</pre>
<p>This is an execution error because the <strong class="source-inline">a</strong> variable is not defined yet, but we used it <span class="No-Break">for division.</span></p>
<p>By now, we have a reusable Lua executor that can execute both a Lua script file and Lua code. Let us learn more about the Lua stack before adding even more features to <span class="No-Break">our executor.</span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/>Understanding the Lua stack</h1>
<p>The Lua stack is used between C/C++ code<a id="_idIndexMarker139"/> and Lua code so that they can communicate with each other. Both C++ code and Lua code can operate on this stack either explicitly <span class="No-Break">or implicitly.</span></p>
<p>We have seen some Lua library functions reading from and writing to the stack. For example, <strong class="source-inline">luaL_loadstring</strong> can push a compiled chuck onto the stack, and <strong class="source-inline">lua_pcall</strong> pops the chunk from the stack. Let us learn some explicit ways to operate on <span class="No-Break">the stack.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Pushing elements</h2>
<p>The Lua library<a id="_idIndexMarker140"/> provides functions to push different types of values onto <span class="No-Break">the stack:</span></p>
<pre class="source-code">
void lua_pushnil     (lua_State *L);
void lua_pushboolean (lua_State *L, int bool);
void lua_pushnumber  (lua_State *L, lua_Number n);
void lua_pushinteger (lua_State *L, lua_Integer n);
void lua_pushstring  (lua_State *L, const char *s);</pre>
<p>There are more <strong class="source-inline">lua_pushX</strong> functions but the ones shown above are the basic ones. <strong class="source-inline">lua_Number</strong> is a type alias most likely for either <strong class="source-inline">double</strong> or <strong class="source-inline">float</strong>, and <strong class="source-inline">lua_Integer</strong> can be <strong class="source-inline">long,</strong> <strong class="source-inline">long long</strong>, or something else. They depend on how the Lua library is configured and on your operating system defaults. You would need to decide on the scope of the different platforms your project will support and how you would like to map them to C++ types. In most situations, mapping <strong class="source-inline">lua_Number</strong> to <strong class="source-inline">double</strong> and <strong class="source-inline">lua_Integer</strong> to <strong class="source-inline">long</strong> might be good enough, however, if required, you can implement<a id="_idIndexMarker141"/> it in a more <span class="No-Break">portable way.</span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>Querying elements</h2>
<p>We can use <strong class="source-inline">lua_gettop</strong> to check how many<a id="_idIndexMarker142"/> elements are in the stack. The first element in the stack is the bottom of the stack and is indexed with 1. The second element is indexed as 2, and so on. You can also access the stack by referencing the top of the stack. In this referencing system, the top of the stack is indexed with -1, the second from the top is indexed with -2, and so on. You can see the two referencing systems in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 3.1 – Two ways to access stack elements" height="642" src="image/B20927_03_01.jpg" width="633"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Two ways to access stack elements</p>
<p>As you can see in the figure, each element<a id="_idIndexMarker143"/> can be indexed with two numbers. Using the minus number can be very convenient when you need to access the elements you just pushed onto <span class="No-Break">the stack.</span></p>
<p>Similar to <strong class="source-inline">lua_pushX</strong> for pushing elements, we have <strong class="source-inline">lua_toX</strong> to <span class="No-Break">query elements:</span></p>
<pre class="source-code">
int         lua_toboolean (lua_State *L, int index);
const char *lua_tostring  (lua_State *L, int index);
lua_Number  lua_tonumber  (lua_State *L, int index);
lua_Integer lua_tointeger (lua_State *L, int index);</pre>
<p>The querying functions will always convert the values to the requested type. This may not be what you want. In this case, you can use <strong class="source-inline">lua_type</strong> to query the type of the element in a given index. There are also corresponding <strong class="source-inline">lua_isX</strong> functions to check whether a given stack<a id="_idIndexMarker144"/> index contains a <span class="No-Break">certain type.</span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>Popping elements</h2>
<p>To remove<a id="_idIndexMarker145"/> the top <strong class="source-inline">n</strong> elements from the stack, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">lua_pop</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
void lua_pop (lua_State *L, int n);</pre>
<p>For high-level operations in your projects, you should maintain a balanced stack in most situations. This means after you are done, the stack size remains the same as the size before you started. Compared with when you started, if you remove more elements from the stack, you will corrupt the stack and cause undefined behaviors the next time you call Lua. On the other hand, if you remove fewer elements from the stack, you will waste stack space, as well as causing memory leaks. So, popping elements correctly is important at the end of the operation. For example, in our <strong class="source-inline">LuaExecutor::pcall</strong> function, if there is an error, the Lua library will push the error message onto the stack. Because this is triggered by our action, we need to remove the error message <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">LuaExecutor::popString</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
std::string LuaExecutor::popString()
{
    std::string result(lua_tostring(L, -1));
    lua_pop(L, 1);
    return result;
}</pre>
<p>This function first reads the top of the stack as a string and then pops the top of <span class="No-Break">the stack.</span></p>
<p>All communications between C++ and Lua need to use the Lua stack. With a good understanding of the Lua stack, we can continue to learn about Lua <span class="No-Break">global variables.</span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor079"/>Operating on global variables</h1>
<p>Lua global variables<a id="_idIndexMarker146"/> are accessible for the whole Lua state. Consider this <span class="No-Break">Lua code:</span></p>
<pre class="source-code">
whom = "C++"
function hello()
    print("Hello " .. whom)
end</pre>
<p>The <strong class="source-inline">hello</strong> function uses the global variable <strong class="source-inline">whom</strong> to print out <span class="No-Break">a greeting.</span></p>
<p>How do we get and set this Lua global variable from C++? We will now extend <strong class="source-inline">LuaExecutor</strong> to do this and use the <strong class="source-inline">hello</strong> function to test it. In this chapter, we will only implement the method to work with string variables to focus primarily on <span class="No-Break">the mechanism.</span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>Getting global variables</h2>
<p>You use the Lua library <strong class="source-inline">lua_getglobal</strong> function<a id="_idIndexMarker147"/> to get global variables. Its prototype is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
int lua_getglobal (lua_State *L, const char *name);</pre>
<p><strong class="source-inline">lua_getglobal</strong> expects two parameters. The first one is the Lua state. The second one is the name for the global variable. <strong class="source-inline">lua_getglobal</strong> pushes the value of the global variable onto the stack and returns its type. The types are defined <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#define LUA_TNIL           0
#define LUA_TBOOLEAN       1
#define LUA_TLIGHTUSERDATA 2
#define LUA_TNUMBER        3
#define LUA_TSTRING        4
#define LUA_TTABLE         5
#define LUA_TFUNCTION      6
#define LUA_TUSERDATA      7
#define LUA_TTHREAD        8</pre>
<p>You can check the returned type against those constants to see if the type of the returned data is what <span class="No-Break">was expected.</span></p>
<p>Let us extend <strong class="source-inline">LuaExecutor</strong> to get global variables. In <strong class="source-inline">LuaExecutor.h</strong>, add a new <span class="No-Break">function declaration:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    std::string getGlobalString(const std::string &amp;name);
};</pre>
<p>This function will get a Lua global variable and return it as a string. Implement it <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">LuaExecutor.cc</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
std::string
LuaExecutor::getGlobalString(const std::string &amp;name)
{
    const int type = lua_getglobal(L, name.c_str());
    assert(LUA_TSTRING == type);
    return popString();
}</pre>
<p>We call <strong class="source-inline">lua_getglobal</strong> to get the global variable and check to make sure it is of the string type. Then we pop it from the stack with the <strong class="source-inline">popString</strong> function that we implemented earlier to get<a id="_idIndexMarker148"/> the Lua library <span class="No-Break">error message.</span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>Setting global variables</h2>
<p>To set a Lua global<a id="_idIndexMarker149"/> variable from C++, we also utilize the stack. This time, we push the value onto the stack. The Lua library pops it and assigns it to the variable. The Lua library <strong class="source-inline">lua_setglobal</strong> function does the popping and <span class="No-Break">assigning part.</span></p>
<p>We will add the capability to set global variables<a id="_idIndexMarker150"/> to our executor. In <strong class="source-inline">LuaExecutor.h</strong>, add one <span class="No-Break">more function:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    void setGlobal(const std::string &amp;name,
                   const std::string &amp;value);
};</pre>
<p>It will set a Lua global variable. The variable’s name is provided by the <strong class="source-inline">name</strong> parameter, and the value is set by <strong class="source-inline">value</strong>. In <strong class="source-inline">LuaExecutor.cc</strong>, add <span class="No-Break">the implementation:</span></p>
<pre class="source-code">
void LuaExecutor::setGlobal(const std::string &amp;name,
                            const std::string &amp;value)
{
    lua_pushstring(L, value.c_str());
    lua_setglobal(L, name.c_str());
}</pre>
<p>The code affects the Lua stack as depicted in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<img alt="Figure 3.2 – Set global variable" height="411" src="image/B20927_03_02.jpg" width="1118"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Set global variable</p>
<p>As explained, we first push the value onto the stack with <strong class="source-inline">lua_pushstring</strong>, then invoke the <strong class="source-inline">lua_setglobal</strong> library function to set the global variable. We have maintained a balanced <span class="No-Break">stack</span><span class="No-Break"><a id="_idIndexMarker151"/></span><span class="No-Break"> size.</span></p>
<p>Now, let us test <span class="No-Break">our implementations.</span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Testing it out</h2>
<p>We will get<a id="_idIndexMarker152"/> and set the <strong class="source-inline">whom</strong> global variable and call our <strong class="source-inline">hello</strong> Lua function to test our Lua executor. Rewrite <strong class="source-inline">main.cpp</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include "LuaExecutor.h"
int main()
{
    LuaExecutor lua;
    lua.executeFile("script.lua");
    std::cout &lt;&lt; "Lua variable whom="
              &lt;&lt; lua.getGlobalString("whom")
              &lt;&lt; std::endl;
    lua.execute("hello()");
    lua.setGlobal("whom", "Lua");
    std::cout &lt;&lt; "Lua variable whom="
              &lt;&lt; lua.getGlobalString("whom")
              &lt;&lt; std::endl;
    lua.execute("hello()");
    return 0;
}</pre>
<p>The test code <a id="_idIndexMarker153"/>is doing <span class="No-Break">four things:</span></p>
<ol>
<li>Loading <strong class="source-inline">script.lua</strong>, whose content is the <strong class="source-inline">hello</strong> function referencing the <strong class="source-inline">whom</strong> <span class="No-Break">global variable.</span></li>
<li>Calling our <strong class="source-inline">getGlobalString</strong> executor function to check the value of the <strong class="source-inline">whom</strong> global variable and executing the Lua <strong class="source-inline">hello</strong> function to see the truth from <span class="No-Break">Lua’s side.</span></li>
<li>Using our <strong class="source-inline">setGlobal</strong> executor function to change the value of <strong class="source-inline">whom</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">"Lua"</strong></span><span class="No-Break">.</span></li>
<li>Verifying that <strong class="source-inline">whom</strong> has a new value from both the C++ side and the <span class="No-Break">Lua side.</span></li>
</ol>
<p>If you have done everything correctly so far, this test code will output <span class="No-Break">the following:</span></p>
<pre class="source-code">
Lua variable whom=C++
Hello C++
Lua variable whom=Lua
Hello Lua</pre>
<p>Well done for making it this far in the Lua integration journey. With the knowledge of getting and setting global<a id="_idIndexMarker154"/> variables, let us move on to the last topic of this chapter: how to call Lua functions <span class="No-Break">from C++.</span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Calling Lua functions</h1>
<p>The Lua <strong class="source-inline">hello</strong> function<a id="_idIndexMarker155"/> we used in the previous section is a good example to demonstrate global variables, but it is not how you would usually implement such a feature. Now consider a more <span class="No-Break">suitable implementation:</span></p>
<pre class="source-code">
function greetings(whom)
    return "Hello " .. whom
end</pre>
<p>This Lua <strong class="source-inline">greetings</strong> function expects <strong class="source-inline">whom</strong> as a function parameter and returns the greeting string instead of printing it out. You can use the greeting string in more flexible ways, for example, by using it on a <span class="No-Break">GUI window.</span></p>
<p>Earlier in this chapter, while learning how to execute Lua scripts, we implemented the <strong class="source-inline">execute</strong> function in our executor. We can invoke <strong class="source-inline">greetings</strong> <span class="No-Break">with it:</span></p>
<pre class="source-code">
LuaExecutor lua;
lua.executeFile("script.lua");
lua.execute("greetings('Lua')");</pre>
<p>But this is not C++ calling a Lua function; it is a Lua script calling a Lua function. C++ just compiles the Lua script and has no access to the function’s return value. To call this function from C++ properly, C++ needs to provide the Lua function parameter and retrieve the return value. By now, this should not be a surprise: you need to use the Lua stack to <span class="No-Break">do that.</span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/>Implementing function invocation</h2>
<p>We have actually learned<a id="_idIndexMarker156"/> everything we need to do this. How it works is a leap of faith in understanding. Let us see the code first and then <span class="No-Break">the explanation.</span></p>
<p>In <strong class="source-inline">LuaExecutor.h</strong>, add a function to execute a <span class="No-Break">Lua function:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    std::string call(const std::string &amp;function,
                     const std::string &amp;param);
};</pre>
<p>This function calls a Lua<a id="_idIndexMarker157"/> function, whose name is provided in <strong class="source-inline">function</strong>. It passes a single parameter to the Lua function and expects the Lua function to return a single string type value. It is not very general but is good enough for the purpose of learning <span class="No-Break">for now.</span></p>
<p>In <strong class="source-inline">LuaExecutor.cc</strong>, implement the <span class="No-Break"><strong class="source-inline">call</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
std::string
LuaExecutor::call(const std::string &amp;function,
                  const std::string &amp;param)
{
    int type = lua_getglobal(L, function.c_str());
    assert(LUA_TFUNCTION == type);
    lua_pushstring(L, param.c_str());
    pcall(1, 1);
    return popString();
}</pre>
<p>We implemented <strong class="source-inline">pcall</strong> and <strong class="source-inline">popString</strong> earlier in this chapter. The <strong class="source-inline">call</strong> function does the <span class="No-Break">following things:</span></p>
<ol>
<li>Pushes the Lua function – the name provided in the <strong class="source-inline">function</strong> parameter – onto <span class="No-Break">the stack.</span></li>
<li>Pushes the Lua function parameter – the value provided in the <strong class="source-inline">param</strong> parameter – onto <span class="No-Break">the stack.</span></li>
<li>Calls the Lua <strong class="source-inline">lua_pcall</strong> library function – indicating that the Lua function expects one parameter and returns <span class="No-Break">one value.</span></li>
</ol>
<p>Wait! The first line of code looks exactly the same as getting a global variable, no? Indeed, it is! Do you recall that <strong class="source-inline">function</strong> is one of the basic types in Lua? You are getting a global variable, whose name is the function name, and whose value is the function body, onto the stack. Actually, you can also write a Lua function <span class="No-Break">this way:</span></p>
<pre class="source-code">
greetings = function (whom)
    return "Hello " .. whom
end</pre>
<p>This is more cumbersome<a id="_idIndexMarker158"/> to write, but shows what is really happening under <span class="No-Break">the hood.</span></p>
<p>Now, let us look at <span class="No-Break">another similarity:</span></p>
<ul>
<li>In our Lua <strong class="source-inline">execute</strong> and <strong class="source-inline">executeFile</strong> executor functions, we first compile the Lua script as a chunk and put it onto the stack. Then we call <strong class="source-inline">lua_pcall</strong>, indicating a zero count of parameters and a zero count of <span class="No-Break">return values.</span></li>
<li>To call a Lua function, we first load the function onto the stack with <strong class="source-inline">lua_getglobal</strong>. Then we push the parameter onto the stack. Finally, we call <strong class="source-inline">lua_pcall</strong> to execute the Lua function, indicating it needs one parameter and will return <span class="No-Break">one value.</span></li>
</ul>
<p>Executing Lua scripts is a simplified version of calling a Lua function, without the need to pass parameters and retrieve <span class="No-Break">return values.</span></p>
<p>By looking at the similarities<a id="_idIndexMarker159"/> instead of differences, you will understand better. Now let us test <span class="No-Break">our work.</span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>Testing it out</h2>
<p>Rewrite <strong class="source-inline">main.cpp</strong> <span class="No-Break">as</span><span class="No-Break"><a id="_idIndexMarker160"/></span><span class="No-Break"> follows:</span></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include "LuaExecutor.h"
int main()
{
    LuaExecutor lua;
    lua.executeFile("script.lua");
    std::cout &lt;&lt; lua.call("greetings", "next adventure")
              &lt;&lt; std::endl;
    return 0;
}</pre>
<p>This will output <strong class="source-inline">"Hello next adventure"</strong> and concludes<a id="_idIndexMarker161"/> <span class="No-Break">this chapter.</span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Summary</h1>
<p>In this chapter, we implemented a Lua executor. Not only can it load and execute Lua scripts, but it can also call specific Lua functions. We also learned how to get and set Lua global variables. During the course of the chapter, we explained the <span class="No-Break">Lua stack.</span></p>
<p>Please take a moment to reflect on how the Lua stack changes during the process of calling a <span class="No-Break">Lua function.</span></p>
<p>In the next chapter, we will continue to improve this Lua executor and work on Lua data types and C++ data <span class="No-Break">type mappings.</span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Exercises</h1>
<ol>
<li>Implement another function in <strong class="source-inline">LuaExecutor</strong> to call a Lua function with two parameters and two return values. Try to use different Lua <span class="No-Break">data types.</span></li>
<li>In <strong class="source-inline">LuaExecutor</strong>, we are using <strong class="source-inline">std::cerr</strong> to print error messages to the console. So far, the callers cannot get the error state. Design an interface to notify failures. You can pass an implementation of this interface in the <span class="No-Break"><strong class="source-inline">LuaExecutor</strong></span><span class="No-Break"> constructor.</span></li>
</ol>
</div>
</div></body></html>