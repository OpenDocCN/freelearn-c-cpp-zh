<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-63"><a id="_idTextAnchor063"/>3</h1>
<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>How to Call Lua from C++</h1>
<p>In this chapter, we will implement a C++ utility class to execute Lua scripts. This serves two purposes. First, by doing this, you will learn in detail how to integrate the Lua library and call Lua code from C++. Second, you will have a Lua wrapper class ready to use. This helps in hiding all the details. We will start with a basic Lua executor and then we will gradually add more features to it as we progress. You will learn about the following:</p>
<ul>
<li>Implementing a Lua executor</li>
<li>Executing a Lua file</li>
<li>Executing a Lua script</li>
<li>Understanding the Lua stack</li>
<li>Operating on global variables</li>
<li>Calling Lua functions</li>
</ul>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>Technical requirements</h2>
<p>Starting from this chapter, we will focus more on code and Lua integration itself and will be brief about toolchain and project settings. However, you can always refer to the book’s GitHub repository to get the complete projects. Please make sure you meet the following requirements:</p>
<ul>
<li>You need to be able to compile the Lua library from source code. <em class="italic">Chapter 1</em> covered this.</li>
<li>You need to be able to write some basic Lua code to test the C++ class that we will write. <em class="italic">Chapter 2</em> covered this.</li>
<li>You can create a <code>Makefile</code> project, or use an alternative. In <em class="italic">Chapter 1</em>, we created three <code>Makefile</code> projects. We will create a new project for this chapter.</li>
<li>You can access the source code for this chapter here: <a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter03">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter03</a><a href="https://github.com/PacktPublishing/Integrate-Lua-to-CPP/tree/main/Chapter03%0D"/></li>
</ul>
<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/>Implementing a Lua executor</h1>
<p>We will implement a reusable C++ Lua executor<a id="_idIndexMarker113"/> class step by step. Let us call it <code>LuaExecutor</code>. We will continue to improve this executor by adding new functions to it.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/>How to include the Lua library in C++ code</h2>
<p>To work with<a id="_idIndexMarker114"/> the Lua library, you<a id="_idIndexMarker115"/> only need three header files:</p>
<ul>
<li><code>lua.h</code> for core<a id="_idIndexMarker116"/> functions. Everything here has a <code>lua_</code> prefix.</li>
<li><code>lauxlib.h</code> for the auxiliary library (<code>auxlib</code>). The auxiliary library provides more helper functions built on top of the core functions in <code>lua.h</code>. Everything here has a <code>luaL_</code> prefix.</li>
<li><code>lualib.h</code> for loading and building Lua libraries. For example, the <code>luaL_openlibs</code> function opens all standard libraries.</li>
</ul>
<p>Lua is implemented in C and those three header files are C header files. To work with C++, Lua provides a convenient wrapper, <code>lua.hpp</code>, whose content is as follows:</p>
<pre class="source-code">
extern "C" {
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}</pre>
<p>In your C++ code, <code>lua.hpp</code> is the only Lua header file you need to include. With this sorted out, let us start to work on our Lua executor.</p>
<p class="callout-heading">C++ filename extensions</p>
<p class="callout">The Lua library<a id="_idIndexMarker117"/> uses <code>hpp</code> as the header file extension for <code>lua.hpp</code>. This is to distinguish it from other C header files from the Lua library. In this book, for our own C++ code, we use <code>h</code> for header files with declaration, <code>hpp</code> for header files that include all implementation, <code>cc</code> for C++ class implementation, and <code>cpp</code> for C++ code not part of a class. This is only one way to name the source code files. Feel free to use your own convention.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>Getting a Lua instance</h2>
<p>We need<a id="_idIndexMarker118"/> to get hold of “an instance” of the Lua library to execute Lua scripts. With some other C++ library, you might<a id="_idIndexMarker119"/> create a certain class instance and work with the object. With Lua, you get a <strong class="bold">Lua state</strong> and pass this state around for different operations.</p>
<p>Our Lua executor will hide the low-level Lua library details and provide a high-level API for your projects. Here is the <code>LuaExecutor.h</code> class definition to start with:</p>
<pre class="source-code">
#include &lt;lua.hpp&gt;
class LuaExecutor
{
public:
    LuaExecutor();
    virtual ~LuaExecutor();
private:
    lua_State *const L;
};</pre>
<p>We have defined a constructor, a destructor, and a private member variable of type <code>lua_State</code>, which is the Lua state, and named it <code>L</code> per Lua conventions.</p>
<p>Here is the <code>LuaExecutor.cc</code> class implementation for the definition so far:</p>
<pre class="source-code">
#include "LuaExecutor.h"
LuaExecutor::LuaExecutor()
    : L(luaL_newstate())
{
    luaL_openlibs(L);
}
LuaExecutor::~LuaExecutor()
{
    lua_close(L);
}</pre>
<p>The class encapsulates the creation and cleaning up of Lua state:</p>
<ol>
<li><code>luaL_newstate()</code> creates a new Lua state. We do this in the constructor initializer list.</li>
<li><code>luaL_openlibs(L)</code> opens the Lua standard libraries for the provided Lua state. This makes library functions – for example, <code>string.gmatch</code> – available to be used in Lua scripts.</li>
<li><code>lua_close(L)</code> closes the Lua state and releases its allocated resources – for example, dynamically <a id="_idIndexMarker120"/>allocated memory, and so on.</li>
</ol>
<p>We will now learn more about Lua state.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>What is Lua state?</h2>
<p>The Lua library <a id="_idIndexMarker121"/>maintains no global state, instead, except for <code>luaL_newstate</code>, all Lua library functions expect a Lua state as the first parameter. This makes Lua re-entrant and it can be used for multithreaded code with little effort.</p>
<p>Lua state is a structure named <code>lua_State</code> that keeps all Lua internal states. To create a Lua state, use <code>luaL_newstate</code>. You can use Lua and treat this state transparently, without being concerned about its internal details.</p>
<p>We can compare this to C++ classes. Lua state<a id="_idIndexMarker122"/> holds the class member variables and states. Lua library functions serve<a id="_idIndexMarker123"/> the purpose of class member functions. To go one step further, consider the C++ <strong class="bold">pimpl</strong> (pointer to implementation) idiom:</p>
<pre class="source-code">
class Lua
{
public:
    void openlibs();
private:
    LuaState *pImpl;
};
struct LuaState
{
    // implementation details
};</pre>
<p>In this analogy, <code>class Lua</code> is our pseudo C++ Lua library; <code>struct LuaState</code> is the private implementation that defines and hides the details. In header files, you would only see its forward declaration, not the definition. The <code>openlibs</code> public member function uses <code>pImpl</code> (the Lua state) internally.</p>
<p>As an advanced topic, C++ member functions will have <code>this</code> as the first parameter after being compiled. The Lua library functions expecting <code>LuaState</code> as their first parameter can be understood in a similar way: both <code>this</code> and <code>LuaState</code> point to the private details of the class.</p>
<p>All this information is to make you feel comfortable in passing Lua state around, while at the same time remaining at ease with not operating on it directly. Now, let us go back and continue<a id="_idIndexMarker124"/> to build our Lua executor.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/>Executing a Lua file</h1>
<p>In <em class="italic">Chapter 1</em>, we used the Lua library<a id="_idIndexMarker125"/> to load a file and run the script. We will do the same here but in a more proper C++ way. In <code>LuaExecutor.h</code>, add the following new code:</p>
<pre class="source-code">
#include &lt;string&gt;
class LuaExecutor
{
public:
    void executeFile(const std::string &amp;path);
private:
    void pcall(int nargs = 0, int nresults = 0);
    std::string popString();
};</pre>
<p>You can of course make all those member functions <code>const</code>, for example, <code>std::string popString() const</code>, because in <code>LuaExecutor</code> we only keep the Lua state <code>L</code> transparently and do not change its value. Here, we are omitting it to prevent too many line breaks in code listings.</p>
<p><code>executeFile</code> is our public function and the other two are internal helper functions. In <code>LuaExecutor.cc</code>, let us implement <code>executeFile</code> first:</p>
<pre class="source-code">
#include &lt;iostream&gt;
void LuaExecutor::executeFile(const std::string &amp;path)
{
    if (luaL_loadfile(L, path.c_str()))
    {
        std::cerr &lt;&lt; "Failed to prepare file: "
                  &lt;&lt; popString() &lt;&lt; std::endl;
        return;
    }
    pcall();
}</pre>
<p>We load the script with <code>luaL_loadfile</code>, providing the file path. <code>luaL_loadfile</code> will load the file, compile it into a <strong class="bold">chunk</strong>, and put it onto the <strong class="bold">Lua stack</strong>. We will explain what a chunk<a id="_idIndexMarker126"/> is and what the Lua<a id="_idIndexMarker127"/> stack is soon.</p>
<p>Most Lua library functions<a id="_idIndexMarker128"/> will return 0 if they are successful. You can also compare the return value with <code>LUA_OK</code> explicitly, which is defined as 0. In our case, if no error occurs, we will proceed to the next step to call <code>pcall</code>. If there is an error, we will get the error with <code>popString</code> and print it out. Next, implement <code>pcall</code> as follows:</p>
<pre class="source-code">
void LuaExecutor::pcall(int nargs, int nresults)
{
    if (lua_pcall(L, nargs, nresults, 0))
    {
        std::cerr &lt;&lt; "Failed to execute Lua code: "
                  &lt;&lt; popString() &lt;&lt; std::endl;
    }
}</pre>
<p>In <code>pcall</code>, we execute the compiled chunk, which is already on the top of the stack, with <code>lua_pcall</code>. This will also remove the chunk from the stack. If an error occurs, we retrieve and print out the error message.</p>
<p>Besides <code>L</code>, <code>lua_pcall</code> takes three more parameters. We are passing 0 for them now. For now, you only need to know that the second parameter is the number of parameters the Lua chunk expects, and the third parameter is the number of values the Lua chunk returns.</p>
<p>Finally, we will implement the last function, <code>popString</code>:</p>
<pre class="source-code">
std::string LuaExecutor::popString()
{
    std::string result(lua_tostring(L, -1));
    lua_pop(L, 1);
    return result;
}</pre>
<p>This pops the top<a id="_idIndexMarker129"/> of the Lua stack as a string. We will explain more when you learn more about the Lua stack.</p>
<p>We have two concepts to explain before trying out <code>LuaExecutor</code>.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>What is a chunk?</h2>
<p>A unit of compilation<a id="_idIndexMarker130"/> in Lua is called a chunk. Syntactically, a chunk is simply a code block. When put on the stack, a chunk is a value of the function type. So, although not fully accurate, you can consider it a function, and a Lua file an implicit function definition. Further, functions can have embedded functions defined within them.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>What is a Lua stack?</h2>
<p>A Lua stack<a id="_idIndexMarker131"/> is a stack data structure. Each Lua state internally maintains a Lua stack. Each element in the stack can hold a reference to a piece of Lua data. If you recall that a function is also a basic Lua type, you will feel more comfortable about a stack element representing a function. Both Lua code and C++ code can push elements onto and pop elements from the Lua stack, either explicitly or implicitly. We will discuss more about the Lua stack and how our <code>popString</code> function works later in this chapter.</p>
<p>Now you have learned about chunks and the Lua stack, two of the important concepts in Lua, we can test <code>LuaExecutor</code>.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Testing the Lua executor so far</h2>
<p>To test<a id="_idIndexMarker132"/> our executor, we need to write a Lua script and some C++ test code to call <code>LuaExecutor</code>. Write <code>script.lua</code> as the following one-liner:</p>
<pre class="source-code">
print("Hello C++")</pre>
<p>This will print <code>Hello C++</code> to the console.</p>
<p>Write <code>main.cpp</code> as follows:</p>
<pre class="source-code">
#include "LuaExecutor.h"
int main()
{
    LuaExecutor lua;
    lua.executeFile("script.lua");
    return 0;
}</pre>
<p>This will create an instance of <code>LuaExecutor</code> and execute the Lua script file.</p>
<p>Now, write the <code>Makefile</code>:</p>
<pre class="source-code">
LUA_PATH = ../lua/src
CXX = g++
CXXFLAGS = -Wall -Werror
CPPFLAGS = -I${LUA_PATH}
LDFLAGS = -L${LUA_PATH}
EXECUTABLE = executable
all: lua project
lua:
    @cd ../lua &amp;&amp; make
project: main.cpp LuaExecutor.cc LuaExecutor.h
    $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) -o
       $(EXECUTABLE) main.cpp LuaExecutor.cc -llua
clean:
    rm -f $(EXECUTABLE)</pre>
<p>Compared to the <code>Makefiles</code> in <em class="italic">Chapter 1</em>, we have one more source file, <code>LuaExecutor.cc</code>, and one more header file, <code>LuaExecutor.h</code>, that the <code>project</code> target depends on. Remember to use tabs for indentations, not spaces. You can find explanations on how to write a <code>Makefile</code> in <em class="italic">Chapter 1</em> if you need to revisit it.</p>
<p>With all the test code written, test this out in a terminal:</p>
<pre class="source-code">
Chapter03 % make
Chapter03 % ./executable
Hello C++</pre>
<p>If you have done everything correctly, the code will compile. When executed, it will output <code>Hello C++</code>, which is from the Lua script file.</p>
<p>We have learned how<a id="_idIndexMarker133"/> to execute Lua code from a file. Now let us try to execute a Lua script directly.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>Executing a Lua script</h1>
<p>In some projects, you may have<a id="_idIndexMarker134"/> a file layer abstraction, or you may get a Lua script from a remote server. Then, you cannot pass a file path to the Lua library and ask it to load it for you. You may also want to load the file yourself as a string to do more auditing before executing it. In those situations, you can ask the Lua library to execute a string as a Lua script.</p>
<p>To do this, we will add a new capability to our Lua executor. In <code>LuaExecutor.h</code>, add one more function:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    void execute(const std::string &amp;script);
};</pre>
<p>This new function will accept the Lua code in a string directly and execute it.</p>
<p>In <code>LuaExecutor.cc</code>, add this implementation:</p>
<pre class="source-code">
void LuaExecutor::execute(const std::string &amp;script)
{
    if (luaL_loadstring(L, script.c_str()))
    {
        std::cerr &lt;&lt; "Failed to prepare script: "
                  &lt;&lt; popString() &lt;&lt; std::endl;
        return;
    }
    pcall();
}</pre>
<p>This new function is exactly the same as <code>executeFile</code> with only one difference. It calls the Lua library <code>luaL_loadstring</code> function, which compiles the string as Lua code and puts the compiled<a id="_idIndexMarker135"/> chunk onto the stack. Then, <code>pcall</code> will pop and execute the chunk.</p>
<h3>Testing it out</h3>
<p>Let us test<a id="_idIndexMarker136"/> a Lua script. We no longer need a script file now. Write <code>main.cpp</code> as follows:</p>
<pre class="source-code">
#include "LuaExecutor.h"
int main()
{
    LuaExecutor lua;
    lua.execute("print('Hello Lua')");
    return 0;
}</pre>
<p>This tells the Lua executor to run the Lua code:</p>
<pre class="source-code">
print('Hello Lua')</pre>
<p>Make and run the project and you will see the output <code>Hello Lua</code>.</p>
<h3>More on Lua compilation and execution</h3>
<p>As explained before, <code>luaL_loadstring</code> and <code>luaL_loadfile</code> will compile the Lua code, while <code>lua_pcall</code> will execute the compiled code. In our <code>LuaExecutor</code> implementation, we are outputting different error messages – <code>Failed to prepare</code> and <code>Failed to execute</code> respectively. Let us test the two different scenarios to understand the execution stages more.</p>
<h4>Testing compilation errors</h4>
<p>In <code>main.cpp</code>, change the statement<a id="_idIndexMarker137"/> to execute the Lua code and make a Lua syntax error intentionally, by deleting the closing parenthesis:</p>
<pre class="source-code">
lua.execute("print('Hello Lua'");</pre>
<p>Now recompile the project and run it. You should see the following error output:</p>
<pre class="source-code">
Failed to prepare script: [string "print('Hello Lua'"]:1:
')' expected near &lt;eof&gt;</pre>
<p><code>pcall</code> is not called at all, because the Lua code failed to compile.</p>
<h4>Testing the runtime error</h4>
<p>This time, change<a id="_idIndexMarker138"/> the Lua code to the following:</p>
<pre class="source-code">
lua.execute("print(a / 2)");</pre>
<p>There is no syntax error. Recompile, run the project, and see the new error:</p>
<pre class="source-code">
Failed to execute Lua code: [string "print(a / 2)"]:1:
attempt to perform arithmetic on a nil value (global 'a')</pre>
<p>This is an execution error because the <code>a</code> variable is not defined yet, but we used it for division.</p>
<p>By now, we have a reusable Lua executor that can execute both a Lua script file and Lua code. Let us learn more about the Lua stack before adding even more features to our executor.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/>Understanding the Lua stack</h1>
<p>The Lua stack is used between C/C++ code<a id="_idIndexMarker139"/> and Lua code so that they can communicate with each other. Both C++ code and Lua code can operate on this stack either explicitly or implicitly.</p>
<p>We have seen some Lua library functions reading from and writing to the stack. For example, <code>luaL_loadstring</code> can push a compiled chuck onto the stack, and <code>lua_pcall</code> pops the chunk from the stack. Let us learn some explicit ways to operate on the stack.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Pushing elements</h2>
<p>The Lua library<a id="_idIndexMarker140"/> provides functions to push different types of values onto the stack:</p>
<pre class="source-code">
void lua_pushnil     (lua_State *L);
void lua_pushboolean (lua_State *L, int bool);
void lua_pushnumber  (lua_State *L, lua_Number n);
void lua_pushinteger (lua_State *L, lua_Integer n);
void lua_pushstring  (lua_State *L, const char *s);</pre>
<p>There are more <code>lua_pushX</code> functions but the ones shown above are the basic ones. <code>lua_Number</code> is a type alias most likely for either <code>double</code> or <code>float</code>, and <code>lua_Integer</code> can be <code>long,</code> <code>long long</code>, or something else. They depend on how the Lua library is configured and on your operating system defaults. You would need to decide on the scope of the different platforms your project will support and how you would like to map them to C++ types. In most situations, mapping <code>lua_Number</code> to <code>double</code> and <code>lua_Integer</code> to <code>long</code> might be good enough, however, if required, you can implement<a id="_idIndexMarker141"/> it in a more portable way.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>Querying elements</h2>
<p>We can use <code>lua_gettop</code> to check how many<a id="_idIndexMarker142"/> elements are in the stack. The first element in the stack is the bottom of the stack and is indexed with 1. The second element is indexed as 2, and so on. You can also access the stack by referencing the top of the stack. In this referencing system, the top of the stack is indexed with -1, the second from the top is indexed with -2, and so on. You can see the two referencing systems in the following figure:</p>
<div><div><img alt="Figure 3.1 – Two ways to access stack elements" height="642" src="img/B20927_03_01.jpg" width="633"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Two ways to access stack elements</p>
<p>As you can see in the figure, each element<a id="_idIndexMarker143"/> can be indexed with two numbers. Using the minus number can be very convenient when you need to access the elements you just pushed onto the stack.</p>
<p>Similar to <code>lua_pushX</code> for pushing elements, we have <code>lua_toX</code> to query elements:</p>
<pre class="source-code">
int         lua_toboolean (lua_State *L, int index);
const char *lua_tostring  (lua_State *L, int index);
lua_Number  lua_tonumber  (lua_State *L, int index);
lua_Integer lua_tointeger (lua_State *L, int index);</pre>
<p>The querying functions will always convert the values to the requested type. This may not be what you want. In this case, you can use <code>lua_type</code> to query the type of the element in a given index. There are also corresponding <code>lua_isX</code> functions to check whether a given stack<a id="_idIndexMarker144"/> index contains a certain type.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>Popping elements</h2>
<p>To remove<a id="_idIndexMarker145"/> the top <code>n</code> elements from the stack, use <code>lua_pop</code>:</p>
<pre class="source-code">
void lua_pop (lua_State *L, int n);</pre>
<p>For high-level operations in your projects, you should maintain a balanced stack in most situations. This means after you are done, the stack size remains the same as the size before you started. Compared with when you started, if you remove more elements from the stack, you will corrupt the stack and cause undefined behaviors the next time you call Lua. On the other hand, if you remove fewer elements from the stack, you will waste stack space, as well as causing memory leaks. So, popping elements correctly is important at the end of the operation. For example, in our <code>LuaExecutor::pcall</code> function, if there is an error, the Lua library will push the error message onto the stack. Because this is triggered by our action, we need to remove the error message with <code>LuaExecutor::popString</code>:</p>
<pre class="source-code">
std::string LuaExecutor::popString()
{
    std::string result(lua_tostring(L, -1));
    lua_pop(L, 1);
    return result;
}</pre>
<p>This function first reads the top of the stack as a string and then pops the top of the stack.</p>
<p>All communications between C++ and Lua need to use the Lua stack. With a good understanding of the Lua stack, we can continue to learn about Lua global variables.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor079"/>Operating on global variables</h1>
<p>Lua global variables<a id="_idIndexMarker146"/> are accessible for the whole Lua state. Consider this Lua code:</p>
<pre class="source-code">
whom = "C++"
function hello()
    print("Hello " .. whom)
end</pre>
<p>The <code>hello</code> function uses the global variable <code>whom</code> to print out a greeting.</p>
<p>How do we get and set this Lua global variable from C++? We will now extend <code>LuaExecutor</code> to do this and use the <code>hello</code> function to test it. In this chapter, we will only implement the method to work with string variables to focus primarily on the mechanism.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>Getting global variables</h2>
<p>You use the Lua library <code>lua_getglobal</code> function<a id="_idIndexMarker147"/> to get global variables. Its prototype is as follows:</p>
<pre class="source-code">
int lua_getglobal (lua_State *L, const char *name);</pre>
<p><code>lua_getglobal</code> expects two parameters. The first one is the Lua state. The second one is the name for the global variable. <code>lua_getglobal</code> pushes the value of the global variable onto the stack and returns its type. The types are defined as follows:</p>
<pre class="source-code">
#define LUA_TNIL           0
#define LUA_TBOOLEAN       1
#define LUA_TLIGHTUSERDATA 2
#define LUA_TNUMBER        3
#define LUA_TSTRING        4
#define LUA_TTABLE         5
#define LUA_TFUNCTION      6
#define LUA_TUSERDATA      7
#define LUA_TTHREAD        8</pre>
<p>You can check the returned type against those constants to see if the type of the returned data is what was expected.</p>
<p>Let us extend <code>LuaExecutor</code> to get global variables. In <code>LuaExecutor.h</code>, add a new function declaration:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    std::string getGlobalString(const std::string &amp;name);
};</pre>
<p>This function will get a Lua global variable and return it as a string. Implement it in <code>LuaExecutor.cc</code>:</p>
<pre class="source-code">
std::string
LuaExecutor::getGlobalString(const std::string &amp;name)
{
    const int type = lua_getglobal(L, name.c_str());
    assert(LUA_TSTRING == type);
    return popString();
}</pre>
<p>We call <code>lua_getglobal</code> to get the global variable and check to make sure it is of the string type. Then we pop it from the stack with the <code>popString</code> function that we implemented earlier to get<a id="_idIndexMarker148"/> the Lua library error message.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>Setting global variables</h2>
<p>To set a Lua global<a id="_idIndexMarker149"/> variable from C++, we also utilize the stack. This time, we push the value onto the stack. The Lua library pops it and assigns it to the variable. The Lua library <code>lua_setglobal</code> function does the popping and assigning part.</p>
<p>We will add the capability to set global variables<a id="_idIndexMarker150"/> to our executor. In <code>LuaExecutor.h</code>, add one more function:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    void setGlobal(const std::string &amp;name,
                   const std::string &amp;value);
};</pre>
<p>It will set a Lua global variable. The variable’s name is provided by the <code>name</code> parameter, and the value is set by <code>value</code>. In <code>LuaExecutor.cc</code>, add the implementation:</p>
<pre class="source-code">
void LuaExecutor::setGlobal(const std::string &amp;name,
                            const std::string &amp;value)
{
    lua_pushstring(L, value.c_str());
    lua_setglobal(L, name.c_str());
}</pre>
<p>The code affects the Lua stack as depicted in the following figure:</p>
<div><div><img alt="Figure 3.2 – Set global variable" height="411" src="img/B20927_03_02.jpg" width="1118"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Set global variable</p>
<p>As explained, we first push the value onto the stack with <code>lua_pushstring</code>, then invoke the <code>lua_setglobal</code> library function to set the global variable. We have maintained a balanced stack<a id="_idIndexMarker151"/> size.</p>
<p>Now, let us test our implementations.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Testing it out</h2>
<p>We will get<a id="_idIndexMarker152"/> and set the <code>whom</code> global variable and call our <code>hello</code> Lua function to test our Lua executor. Rewrite <code>main.cpp</code> as follows:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include "LuaExecutor.h"
int main()
{
    LuaExecutor lua;
    lua.executeFile("script.lua");
    std::cout &lt;&lt; "Lua variable whom="
              &lt;&lt; lua.getGlobalString("whom")
              &lt;&lt; std::endl;
    lua.execute("hello()");
    lua.setGlobal("whom", "Lua");
    std::cout &lt;&lt; "Lua variable whom="
              &lt;&lt; lua.getGlobalString("whom")
              &lt;&lt; std::endl;
    lua.execute("hello()");
    return 0;
}</pre>
<p>The test code <a id="_idIndexMarker153"/>is doing four things:</p>
<ol>
<li>Loading <code>script.lua</code>, whose content is the <code>hello</code> function referencing the <code>whom</code> global variable.</li>
<li>Calling our <code>getGlobalString</code> executor function to check the value of the <code>whom</code> global variable and executing the Lua <code>hello</code> function to see the truth from Lua’s side.</li>
<li>Using our <code>setGlobal</code> executor function to change the value of <code>whom</code> to <code>"Lua"</code>.</li>
<li>Verifying that <code>whom</code> has a new value from both the C++ side and the Lua side.</li>
</ol>
<p>If you have done everything correctly so far, this test code will output the following:</p>
<pre class="source-code">
Lua variable whom=C++
Hello C++
Lua variable whom=Lua
Hello Lua</pre>
<p>Well done for making it this far in the Lua integration journey. With the knowledge of getting and setting global<a id="_idIndexMarker154"/> variables, let us move on to the last topic of this chapter: how to call Lua functions from C++.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Calling Lua functions</h1>
<p>The Lua <code>hello</code> function<a id="_idIndexMarker155"/> we used in the previous section is a good example to demonstrate global variables, but it is not how you would usually implement such a feature. Now consider a more suitable implementation:</p>
<pre class="source-code">
function greetings(whom)
    return "Hello " .. whom
end</pre>
<p>This Lua <code>greetings</code> function expects <code>whom</code> as a function parameter and returns the greeting string instead of printing it out. You can use the greeting string in more flexible ways, for example, by using it on a GUI window.</p>
<p>Earlier in this chapter, while learning how to execute Lua scripts, we implemented the <code>execute</code> function in our executor. We can invoke <code>greetings</code> with it:</p>
<pre class="source-code">
LuaExecutor lua;
lua.executeFile("script.lua");
lua.execute("greetings('Lua')");</pre>
<p>But this is not C++ calling a Lua function; it is a Lua script calling a Lua function. C++ just compiles the Lua script and has no access to the function’s return value. To call this function from C++ properly, C++ needs to provide the Lua function parameter and retrieve the return value. By now, this should not be a surprise: you need to use the Lua stack to do that.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/>Implementing function invocation</h2>
<p>We have actually learned<a id="_idIndexMarker156"/> everything we need to do this. How it works is a leap of faith in understanding. Let us see the code first and then the explanation.</p>
<p>In <code>LuaExecutor.h</code>, add a function to execute a Lua function:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    std::string call(const std::string &amp;function,
                     const std::string &amp;param);
};</pre>
<p>This function calls a Lua<a id="_idIndexMarker157"/> function, whose name is provided in <code>function</code>. It passes a single parameter to the Lua function and expects the Lua function to return a single string type value. It is not very general but is good enough for the purpose of learning for now.</p>
<p>In <code>LuaExecutor.cc</code>, implement the <code>call</code> function:</p>
<pre class="source-code">
std::string
LuaExecutor::call(const std::string &amp;function,
                  const std::string &amp;param)
{
    int type = lua_getglobal(L, function.c_str());
    assert(LUA_TFUNCTION == type);
    lua_pushstring(L, param.c_str());
    pcall(1, 1);
    return popString();
}</pre>
<p>We implemented <code>pcall</code> and <code>popString</code> earlier in this chapter. The <code>call</code> function does the following things:</p>
<ol>
<li>Pushes the Lua function – the name provided in the <code>function</code> parameter – onto the stack.</li>
<li>Pushes the Lua function parameter – the value provided in the <code>param</code> parameter – onto the stack.</li>
<li>Calls the Lua <code>lua_pcall</code> library function – indicating that the Lua function expects one parameter and returns one value.</li>
</ol>
<p>Wait! The first line of code looks exactly the same as getting a global variable, no? Indeed, it is! Do you recall that <code>function</code> is one of the basic types in Lua? You are getting a global variable, whose name is the function name, and whose value is the function body, onto the stack. Actually, you can also write a Lua function this way:</p>
<pre class="source-code">
greetings = function (whom)
    return "Hello " .. whom
end</pre>
<p>This is more cumbersome<a id="_idIndexMarker158"/> to write, but shows what is really happening under the hood.</p>
<p>Now, let us look at another similarity:</p>
<ul>
<li>In our Lua <code>execute</code> and <code>executeFile</code> executor functions, we first compile the Lua script as a chunk and put it onto the stack. Then we call <code>lua_pcall</code>, indicating a zero count of parameters and a zero count of return values.</li>
<li>To call a Lua function, we first load the function onto the stack with <code>lua_getglobal</code>. Then we push the parameter onto the stack. Finally, we call <code>lua_pcall</code> to execute the Lua function, indicating it needs one parameter and will return one value.</li>
</ul>
<p>Executing Lua scripts is a simplified version of calling a Lua function, without the need to pass parameters and retrieve return values.</p>
<p>By looking at the similarities<a id="_idIndexMarker159"/> instead of differences, you will understand better. Now let us test our work.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>Testing it out</h2>
<p>Rewrite <code>main.cpp</code> as<a id="_idIndexMarker160"/> follows:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include "LuaExecutor.h"
int main()
{
    LuaExecutor lua;
    lua.executeFile("script.lua");
    std::cout &lt;&lt; lua.call("greetings", "next adventure")
              &lt;&lt; std::endl;
    return 0;
}</pre>
<p>This will output <code>"Hello next adventure"</code> and concludes<a id="_idIndexMarker161"/> this chapter.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Summary</h1>
<p>In this chapter, we implemented a Lua executor. Not only can it load and execute Lua scripts, but it can also call specific Lua functions. We also learned how to get and set Lua global variables. During the course of the chapter, we explained the Lua stack.</p>
<p>Please take a moment to reflect on how the Lua stack changes during the process of calling a Lua function.</p>
<p>In the next chapter, we will continue to improve this Lua executor and work on Lua data types and C++ data type mappings.</p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Exercises</h1>
<ol>
<li>Implement another function in <code>LuaExecutor</code> to call a Lua function with two parameters and two return values. Try to use different Lua data types.</li>
<li>In <code>LuaExecutor</code>, we are using <code>std::cerr</code> to print error messages to the console. So far, the callers cannot get the error state. Design an interface to notify failures. You can pass an implementation of this interface in the <code>LuaExecutor</code> constructor.</li>
</ol>
</div>
</div></body></html>