["```cpp\nQNetworkAccessManager *m_nam = new QNetworkAccessManager(this);\n```", "```cpp\ntemplate <class T>\nclass Singleton\n{\npublic:\n  static T& Instance()\n  {\n    static T _instance;\n    return _instance;\n  }\nprivate:\n  Singleton();\n  ~Singleton();\n  Singleton(const Singleton &);\n  Singleton& operator=(const Singleton &);\n};\n```", "```cpp\nMyClass *singleton = &Singleton<MyClass>::Instance();\n```", "```cpp\nQQuickView *view = new QQuickView;\nQNetworkAccessManager *m_nam \n  = view->engine()->networkAccessManager();\n```", "```cpp\nconnect(m_nam, SIGNAL(finished(QNetworkReply*)), this, \n  SLOT(downloadFinished(QNetworkReply*)));\n```", "```cpp\nm_nam->get(QNetworkRequest(QUrl(\"http://localhost/version.txt\")));\n```", "```cpp\nQNetworkRequest request;\nrequest.setUrl(QUrl(\"http://localhost/version.txt\"));\nrequest.setHeader(QNetworkRequest::UserAgentHeader, \"MyGame\");\nm_nam->get(request);\n```", "```cpp\nrequest.setRawHeader(\"User-Agent\", \"MyGame\");\n```", "```cpp\nvoid FileDownload::downloadFinished(QNetworkReply *reply) {\n const QByteArray content = reply->readAll();\n  m_edit->setPlainText(content);\n reply->deleteLater();\n}\n```", "```cpp\nif (reply->error() != QNetworkReply::NoError) {/* error occurred */}\n```", "```cpp\nif (reply->error()) {\n  // an error occurred\n}\n```", "```cpp\nif (reply->error()) {\n  const QString error = reply->errorString();\n  m_edit->setPlainText(error);\n  return;\n}\n```", "```cpp\nreply->attribute(QNetworkRequest::HttpStatusCodeAttribute)\n```", "```cpp\nQNetworkRequest req(QUrl(\"...\"));\nreq.setRawHeader(\"Range\", \"bytes=300-500\");\nQNetworkReply *reply = m_nam->get(req);\n```", "```cpp\nm_nam->get(QNetworkRequest(QUrl(\"ftp://localhost/version.txt\")));\n```", "```cpp\nQNetworkReply *reply = qobject_cast<QNetworkReply*>\n(sender());\nif (!reply)\n  return;\n```", "```cpp\nQNetworkAccessManager *m_nam;\nQSignalMapper *m_mapper;\nQHash<int, QNetworkReply*> m_replies;\n```", "```cpp\nQNetworkReply *reply = m_nam->get(QNetworkRequest(QUrl(/*...*/)));\nconnect(reply, SIGNAL(finished()), m_mapper, SLOT(map()));\nint id = /* unique id, not already used in m_replies*/;\nm_replies.insert(id, reply);\nm_mapper->setMapping(reply, id);\n```", "```cpp\nconnect(m_mapper, SIGNAL(mapped(int)), this, SLOT(downloadFinished(int)));\n```", "```cpp\nvoid SomeClass::downloadFinished(int id) {\n  QNetworkReply *reply = m_replies.take(id);\n  // do some stuff with reply here\n  reply->deleteLater();\n}\n```", "```cpp\nconnect(reply, SIGNAL(readyRead()), this, SLOT(readContent()));\nfile.open(QIODevice::WriteOnly);\n```", "```cpp\nconst QByteArray ba = reply->readAll();\nfile.write(ba);\nfile.flush();\n```", "```cpp\nreply->head(QNetworkRequest::ContentLengthHeader).toInt();\n```", "```cpp\nvoid SomeClass::downloadProgress(qint64 bytesReceived, qint64 bytesTotal) {\n  qreal progress = (bytesTotal < 1) ? 1.0 \n                   : bytesReceived * 100.0 / bytesTotal;\n  progressBar->setValue(progress * progressBar->maximum());\n}\n```", "```cpp\nprogressBar->setRange(0, 2048);\n```", "```cpp\nqint64 total = m_timer.elapsed() / progress;\nqint64 remaining = (total â€“ m_timer.elapsed()) / 1000;\n```", "```cpp\nvoid MainWindow::sendRequest()\n{\n  if (m_reply != 0 && m_reply->isRunning())\n    m_reply->abort();\n  ui->result->clear();\n```", "```cpp\nurl = baseUrl + \"?origin=\" + ui->from->text() + \"&...\";\n```", "```cpp\nQUrlQuery query;\nquery.addQueryItem(\"sensor\", \"false\");\nquery.addQueryItem(\"language\", \"en\");\nquery.addQueryItem(\"units\", \"metric\");\nquery.addQueryItem(\"origins\", ui->from->text());\nquery.addQueryItem(\"destinations\", ui->to->text());\nquery.addQueryItem(\"mode\", ui->vehicle->currentText());\n```", "```cpp\n  QUrl url\n    = (\"http://maps.googleapis.com/maps/api/distancematrix/json\");\n  url.setQuery(query);\n  m_reply = m_nam->get(QNetworkRequest(url));\n}\n```", "```cpp\nvoid MainWindow::finished(QNetworkReply *reply)\n{\n  if (m_reply != reply) {\n    reply->deleteLater();\n    return;\n  }\n```", "```cpp\nm_reply = 0;\nif (reply->error()) {\n  ui->result->setPlainText(reply->errorString());\n  reply->deleteLater();\n  return;\n}\n```", "```cpp\nconst QByteArray content = reply->readAll();\nQJsonDocument doc = QJsonDocument::fromJson(content);\nif (doc.isNull() || !doc.isObject()) {\n  ui->result->setPlainText(\"Error while reading the JSON file.\");\n  reply->deleteLater();\n  return;\n}\n```", "```cpp\nQJsonObject obj = doc.object();\nQVariantList origins = obj.value(\"origin_addresses\")\n                       .toArray().toVariantList();\nQVariantList destinations = obj.value(\"destination_addresses\")\n                            .toArray().toVariantList();\n```", "```cpp\n{\n  \"destination_addresses\" : [ \"Birmingham, West Midlands, UK\" ],\n  \"origin_addresses\" : [ \"Warsaw, Poland\", \"Erlangen, Germany\" ],\n  \"rows\" : [ ... ],\n  \"status\" : \"OK\"\n}\n```", "```cpp\n\"rows\" : [\n    {\n      \"elements\" : [{...}, {...}]\n    },\n    {\n      \"elements\" : [{...}, {...}]\n    }\n  ],\n```", "```cpp\n{\n  \"distance\" : {\n    \"text\" : \"1,835 km\",\n    \"value\" : 1834751\n  },\n  \"duration\" : {\n    \"text\" : \"16 hours 37 mins\",\n    \"value\" : 59848\n  },\n  \"status\" : \"OK\"\n}\n```", "```cpp\nfor (int i = 0; i < origins.count(); ++i) {\n  for (int j = 0; j < destinations.count(); ++j) {\n```", "```cpp\nQString output;\noutput += QString(\"From:\").leftJustified(10, ' ') \n          + origins.at(i).toString() + \"\\n\";\noutput += QString(\"To:\").leftJustified(10, ' ') \n          + destinations.at(j).toString() + \"\\n\";\n```", "```cpp\nFrom:     Warsaw, Poland\nTo:       Birmingham, West Midlands, UK\n```", "```cpp\nQJsonObject data = obj.value(\"rows\").toArray().at(i).toObject()\n                  .value(\"elements\").toArray().at(j).toObject();\n```", "```cpp\nQString status = data.value(\"status\").toString();\n```", "```cpp\nif (status == \"OK\") {\n  output += QString(\"Distance:\").leftJustified(10, ' ') + \n    data.value(\"distance\").toObject().value(\"text\").toString() \n    + \"\\n\";\n  output += QString(\"Duration:\").leftJustified(10, ' ') + \n    data.value(\"duration\").toObject().value(\"text\").toString() \n    + \"\\n\";\n}\n```", "```cpp\nelse if (status == \"NOT_FOUND\") {\n  output += \"Origin and/or destination of this pairing could not be geocoded.\\n\";\n} else if (status == \"ZERO_RESULTS\") {\n  output += \"No route could be found.\\n\";\n} else {\n  output += \"Unknown error.\\n\";\n}\n```", "```cpp\n      output += QString(\"\\n\").fill('=', 35) + \"\\n\\n\";\n      ui->result->moveCursor(QTextCursor::End);\n      ui->result->insertPlainText(output);\n    }\n  }\n  reply->deleteLater();\n}\n```", "```cpp\nQNetworkConfigurationManager manager;\nQList<QNetworkConfiguration> cfgs = manager.allConfigurations();\n```", "```cpp\nQNetworkConfigurationManager manager;\nQNetworkConfiguration cfg = manager.defaultConfiguration();\nQNetworkSession *session = new QNetworkSession(cfg, this);\nsession->open();\n```", "```cpp\nif (!m_server->listen(QHostAddress::LocalHost, 52693)) {\n  ui->log->setPlainText(\"Failure while starting server: \"\n                        + m_server->errorString());\n  return;\n}\nconnect(m_server, SIGNAL(newConnection()),\n        this, SLOT(newConnection()));\n```", "```cpp\nm_server->listen(QHostAddress(\"127.0.0.1\"), 0);\n```", "```cpp\nui->address->setText(m_server->serverAddress().toString());\nui->port->setText(QString::number(m_server->serverPort()));\n```", "```cpp\nvoid TcpServer::newConnection() {\n  while (m_server->hasPendingConnections()) {\n    QTcpSocket *con = m_server->nextPendingConnection();\n    m_clients << con;\n    ui->disconnectClients->setEnabled(true);\n    connect(con, SIGNAL(disconnected()), this, SLOT(removeConnection()));\n    connect(con, SIGNAL(readyRead()), this, SLOT(newMessage()));\n    ui->log->insertPlainText(\n      QString(\"* New connection: %1, port %2\\n\")\n      .arg(con->peerAddress().toString())\n      .arg(QString::number(con->peerPort())));\n  }\n}\n```", "```cpp\nvoid TcpServer::newMessage()\n{\n  if (QTcpSocket *con = qobject_cast<QTcpSocket*>(sender())) {\n    m_receivedData[con].append(con->readAll());\n```", "```cpp\n    if (!m_receivedData[con].contains(QChar(23)))\n      return;\n```", "```cpp\n    QStringList messages = m_receivedData[con].split(QChar(23));\n    m_receivedData[con] = messages.takeLast();\n```", "```cpp\n    foreach (QString message, messages) {\n      ui->log->insertPlainText(\"Sending message: \" + message + \"\\n\");\n```", "```cpp\n      message.append(QChar(23));\n      foreach (QTcpSocket *socket, m_clients) {\n        if (socket == con)\n          continue;\n        if (socket->state() == QAbstractSocket::ConnectedState)\n          socket->write(message.toLocal8Bit());\n      }\n    }\n  }\n}\n```", "```cpp\nvoid TcpServer::removeConnection()\n{\n  if (QTcpSocket *con = qobject_cast<QTcpSocket*>(sender())) {\n    ui->log->insertPlainText(\n      QString(\"* Connection removed: %1, port %2\\n\")\n      .arg(con->peerAddress().toString())\n      .arg(QString::number(con->peerPort())));\n    m_clients.removeOne(con);\n    con->deleteLater();\n    ui->disconnectClients->setEnabled(!m_clients.isEmpty());\n  }\n}\n```", "```cpp\nvoid TcpClient::on_connect_clicked()\n{\n  //...\n  if (m_socket->state() != QAbstractSocket::ConnectedState) {\n    m_socket->connectToHost(ui->address->text(), ui->port->value());\n    ui->chat->insertPlainText(\"== Connecting...\\n\");\n  }\n  //...\n}\n```", "```cpp\nm_receivedData.append(m_socket->readAll());\nif (!m_receivedData.contains(QChar(23)))\n  return;\n\nQStringList messages = m_receivedData.split(QChar(23));\nm_receivedData = messages.takeLast();\nforeach (const QString &message, messages) {\n  ui->chat->insertPlainText(message + \"\\n\");\n}\n```", "```cpp\nQString message = m_user + \": \" + ui->text->text();\nm_socket->write(message.toLocal8Bit());\nui->text->clear();\n```", "```cpp\nsocketA->writeDatagram(QByteArray(\"Hello!\"), QHostAddress(\"127.0.0.1\"), 52001);\n```", "```cpp\nwhile (socketB->hasPendingDatagrams()) {\n  QByteArray datagram;\n  datagram.resize(socketB->pendingDatagramSize())\n  QHostAddress sender;\n  quint16 senderPort;\n  socketB->readDatagram(datagram.data(), datagram.size(),\n                       &sender, &senderPort);\n  // do something with datagram, sender and port.\n}\n```"]