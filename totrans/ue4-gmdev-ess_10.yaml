- en: Chapter 10. Introduction to Unreal C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。Unreal C++ 简介
- en: In [Chapter 6](ch06.html "Chapter 6. Blueprints"), *Blueprints*, you learned
    about Blueprints, the visual scripting language of Unreal Engine 4\. Now you will
    learn about C++, which can be used to create base classes for Blueprints. In this
    chapter, you will learn how to create a C++ project (we will use the **Third Person
    Template**) and modify it to add support for health and health regeneration for
    our character. You will also learn how to expose variables and functions to Blueprint.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html "第 6 章。蓝图") *蓝图* 中，你学习了关于蓝图的内容，这是 Unreal Engine 4 的可视化脚本语言。现在你将学习
    C++，它可以用来为蓝图创建基类。在本章中，你将学习如何创建一个 C++ 项目（我们将使用 **第三人称模板**）并修改它以添加对角色健康和健康恢复的支持。你还将学习如何将变量和函数暴露给蓝图。
- en: This chapter will be focused on writing C++ code using Visual Studio 2015 in
    Microsoft Windows.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于在 Microsoft Windows 中使用 Visual Studio 2015 编写 C++ 代码。
- en: Setting up Visual Studio 2015
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Visual Studio 2015
- en: 'With Unreal Engine 4.10, you will need Visual Studio 2015 to compile C++ for
    your projects. There are three editions of Visual Studio available. They are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Unreal Engine 4.10 时，您需要 Visual Studio 2015 来编译项目的 C++ 代码。Visual Studio 有三个版本可供选择。它们是：
- en: '**Community edition**: This is free for any individual and nonenterprise organizations
    for up to five users. For this book, I will be using this edition.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区版**：对于任何个人和非企业组织，最多五名用户免费。对于这本书，我将使用这个版本。'
- en: '**Professional edition**: This is a paid version and is useful for small teams.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专业版**：这是一个付费版本，适用于小型团队。'
- en: '**Enterprise edition**: This is for large teams working on projects of any
    size and complexity.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业版**：适用于任何规模和复杂性的项目的大型团队。'
- en: You can download the Visual Studio 2015 community edition from [https://www.visualstudio.com/downloads/download-visual-studio-vs](https://www.visualstudio.com/downloads/download-visual-studio-vs)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [https://www.visualstudio.com/downloads/download-visual-studio-vs](https://www.visualstudio.com/downloads/download-visual-studio-vs)
    下载 Visual Studio 2015 社区版。
- en: 'After visiting the above link, select **Community 2015** and choose your format
    to download. You can either download the web installer or the offline installer.
    To download the offline installer, select the **ISO** format:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 访问上述链接后，选择 **Community 2015** 并选择您的格式进行下载。您可以下载网络安装程序或离线安装程序。要下载离线安装程序，请选择 **ISO**
    格式：
- en: '![Setting up Visual Studio 2015](img/B03950_10_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Visual Studio 2015](img/B03950_10_01.jpg)'
- en: After downloading the setup, double-click on **vs_community.exe** to run the
    setup and install Visual Studio 2015.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下载设置文件后，双击 **vs_community.exe** 运行设置并安装 Visual Studio 2015。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before installing Visual Studio 2015, make sure you select **Visual C++** under
    the **Programming Languages** section. This is required to work with Unreal Engine
    4.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Visual Studio 2015 之前，请确保在 **编程语言** 部分选择 **Visual C++**。这是与 Unreal Engine
    4 一起工作的必要条件。
- en: '![Setting up Visual Studio 2015](img/B03950_10_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Visual Studio 2015](img/B03950_10_02.jpg)'
- en: When the installation is complete, the setup will prompt you to restart your
    computer. Do this, and you are good to go with Unreal Engine 4 C++.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，设置程序将提示您重新启动计算机。这样做，您就可以使用 Unreal Engine 4 C++ 了。
- en: Workflow improvements
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流程改进
- en: 'There are some recommended settings for Visual Studio 2015 to work with Unreal
    Engine 4 that improves the overall user experience for developers. Some of them
    are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Visual Studio 2015 与 Unreal Engine 4 一起工作并提高开发者的整体用户体验，有一些推荐的设置。其中一些包括：
- en: Turn off **Show Inactive Blocks**. If you do not, many chunks of code may appear
    grayed out in the text editor. (**Tools** | **Options** | **Text Editor** | **C/C++**
    | **View**).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭 **显示非活动块**。如果不关闭，许多代码块可能会在文本编辑器中显示为灰色。(**工具** | **选项** | **文本编辑器** | **C/C++**
    | **视图**）。
- en: Set **Disable External Dependencies Folders** to **True** to hide unneeded folders
    in the **Solution Explorer**. (**Tools** | **Options** | **Text Editor** | **C/C++**
    | **Advanced**).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **禁用外部依赖文件夹** 设置为 **True** 以在 **解决方案资源管理器** 中隐藏不必要的文件夹。（**工具** | **选项** |
    **文本编辑器** | **C/C++** | **高级**）。
- en: Turn off **Edit & Continue** features. (**Tools** | **Options** | **Debugging**
    | **Edit** and click on **Continue**).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭 **编辑并继续** 功能。（**工具** | **选项** | **调试** | **编辑** 并点击 **继续**）。
- en: Turn on **IntelliSense**.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 **IntelliSense**。
- en: Creating a C++ project
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 C++ 项目
- en: 'Now that we have Visual Studio installed, let''s create a project that includes
    C++ code. In this project, we will extend the Third Person Template that comes
    with Unreal Engine 4 and add support for health (including health regeneration):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Visual Studio，让我们创建一个包含 C++ 代码的项目。在这个项目中，我们将扩展 Unreal Engine 4 附带的三人称模板，并添加对健康（包括健康恢复）的支持：
- en: '![Creating a C++ project](img/B03950_10_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![创建 C++ 项目](img/B03950_10_03.jpg)'
- en: 'Start Unreal Engine 4 and when the project browser dialog appears:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Unreal Engine 4，当项目浏览器对话框出现时：
- en: Select the **New Project** tab
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 **新建项目** 选项卡
- en: Select the **C++** sub tab
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 **C++** 子选项卡
- en: Select **Third Person**
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 **第三人称**
- en: Name your project
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名您的项目
- en: Click on **Create Project**
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击 **创建项目**
- en: When you click on **Create Project**, Unreal Engine 4 will create all the base
    classes required and will compile the project for you. This might take a minute
    or so. Once this is completed, the solution file (Visual Studio file) for your
    project will be automatically opened along with the project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击 **创建项目** 时，Unreal Engine 4 将创建所有必需的基本类，并为您编译项目。这可能需要一分钟或更长时间。一旦完成，您的项目解决方案文件（Visual
    Studio 文件）将自动打开，同时打开项目。
- en: 'Once the project is opened, one main change you might notice is the new **Compile**
    button that appears on the **Toolbar**. This will only appear if your project
    is a code project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目打开，您可能会注意到的一个主要变化是在 **工具栏** 上出现了一个新的 **编译** 按钮。这只会出现在您的项目是代码项目的情况下：
- en: '![Creating a C++ project](img/B03950_10_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![创建 C++ 项目](img/B03950_10_04.jpg)'
- en: This is used to recompile the code changes and reload them on the fly, even
    when you are playing the game! This system is called **Hot Reloading**. As a programmer,
    you will make use of this feature extensively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于重新编译代码更改并在玩游戏时即时重新加载它们！这个系统被称为 **热重载**。作为程序员，您将广泛使用这个功能。
- en: The character class
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色类
- en: In this project, we have a character class and a game mode class already available.
    Let's take a quick look at how the character class is made.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们已经有了一个角色类和一个游戏模式类可用。让我们快速看看角色类是如何制作的。
- en: Basically, what we have is a source file (with the extension `.cpp`) and a header
    file (`.h`). In a nutshell, a header file contains all the declarations, and the
    source file contains the definitions of those declarations. To access a specific
    method (or a function) in another file, we use `# include` `ExampleHeader.h`.
    This way, we will have access to all functions declared in that header file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们有一个源文件（扩展名为 `.cpp`）和一个头文件（`.h`）。简而言之，头文件包含所有声明，源文件包含这些声明的定义。要访问另一个文件中的特定方法（或函数），我们使用
    `# include` `ExampleHeader.h`。这样，我们将能够访问在该头文件中声明的所有函数。
- en: Accessing declarations on another header file are based on access specifiers.
    We will learn more about them later in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个头文件中访问声明基于访问说明符。我们将在本章后面了解更多关于它们的内容。
- en: 'To open the source file (`.cpp`) and header file (`.h`) from Unreal Engine
    4:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Unreal Engine 4 打开源文件（`.cpp`）和头文件（`.h`）：
- en: Open **Content Browser**
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开 **内容浏览器**
- en: Go to **C++ Classes**
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前往 **C++ 类**
- en: Select your project name folder
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您的项目名称文件夹
- en: Double-click on your character class
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双击您的角色类
- en: 'This will open both source file (`.cpp`) and header file (`.h`) in Visual Studio:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 Visual Studio 中打开源文件（`.cpp`）和头文件（`.h`）：
- en: '![The character class](img/B03950_10_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![角色类](img/B03950_10_05.jpg)'
- en: The preceding screenshot shows the header file of our character class. Let's
    analyze it line by line.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了我们的角色类的头文件。让我们逐行分析它。
- en: '`#pragma once`: Any line that is preceded by a hash (`#`) sign is called a
    preprocessor directive. Think of it as instruction to the compiler to run before
    any actual code is compiled. They start with the hash (`#`) sign and usually ends
    with a new line. You can have multi-line by using the backslash (`\`) sign. In
    this case, `#pragma once` is a preprocessor and its job is to protect against
    multiple includes. `#pragma once` is known as header guard.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#pragma once`：任何以井号（`#`）开头的行称为预处理器指令。将其视为在编译任何实际代码之前由编译器运行的指令。它们以井号（`#`）开头，通常以新行结束。您可以使用反斜杠（`\`）进行多行。在这种情况下，`#pragma
    once` 是一个预处理器，其任务是防止多次包含。`#pragma once` 也称为头文件保护。'
- en: '`#include`: In this file, we see two include files. One is `Character.h` from
    the `GameFramework` folder (which is in the `UE4` directory) and the other is
    a `generated.h` file:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include`：在这个文件中，我们看到两个包含文件。一个是来自 `GameFramework` 文件夹的 `Character.h`（位于 `UE4`
    目录中），另一个是 `generated.h` 文件：'
- en: '`Character.h`: This file is included because our character class is inherited
    from the `ACharacter` class that comes with Unreal Engine 4\. This include is
    required to access all the declarations in the `Character` class.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Character.h`: 包含这个文件是因为我们的角色类是从Unreal Engine 4中提供的 `ACharacter` 类继承而来的。这个包含是必须的，以便访问
    `Character` 类中的所有声明。'
- en: '`generated.h`: This is automatically generated for you by **Unreal Header Tool**
    (**UHT**). These are generated whenever you have a `USTRUCT()`or `UCLASS()` macro
    declared. They contain the details of type declarations in your header file. This
    should be the last include file in your header.'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generated.h`: 这是由 **Unreal Header Tool** （**UHT**）自动为你生成的。这些文件在你声明了 `USTRUCT()`
    或 `UCLASS()` 宏时生成。它们包含了你的头文件中类型声明的详细信息。这应该是你头文件中的最后一个包含文件。'
- en: '`Macros`: `Macros` are also preprocessor-directive, which starts with `#define`.
    Right before the compile time, the compiler copies and pastes the actual values
    anywhere this macro is used. For example, if you create a macro like this: `#define
    MyMacro 3.14`, then `3.14` will be copied and pasted everywhere that `MyMacro`
    is used.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Macros`: `Macros` 也是一种预处理指令，以 `#define` 开头。在编译时间之前，编译器会将实际值复制并粘贴到使用此宏的任何地方。例如，如果你创建了一个这样的宏：`#define
    MyMacro 3.14`，那么 `3.14` 将被复制并粘贴到使用 `MyMacro` 的任何地方。'
- en: '`UCLASS(config=game)`: This is an Unreal macro that makes the editor aware
    of the new class. Inside the parentheses, you specify the class specifiers and
    metadata. In this example, we specify the config specifier. This indicates that
    this class is allowed to store data in the given configuration file. In this case,
    the name of your config file will be `YourGameNameGame.ini`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UCLASS(config=game)`: 这是一个Unreal宏，它使编辑器知道新的类。在括号内，你指定类修饰符和元数据。在这个例子中，我们指定了配置修饰符。这表示这个类允许在给定的配置文件中存储数据。在这种情况下，你的配置文件名将是
    `YourGameNameGame.ini`。'
- en: '`class APACKT_CPPCharacter`: `public ACharacter`: This indicates the class
    name and shows you which class we inherited this from. For this class, we inherited
    it from the `Character` class.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class APACKT_CPPCharacter`: `public ACharacter`: 这表示类名，并显示了我们从哪个类继承了这个类。对于这个类，我们是从
    `Character` 类继承的。'
- en: '`GENERATED_BODY()`: This is a macro that must be placed at the very beginning
    of the class body. When compiling, Unreal will replace it with all the boilerplate
    code that is necessary. This means that, right before compile time, `GENERATED_BODY()`
    is replaced by the actual code. Since this chunk of code is required to compile
    the class, Epic has made it easier for us by creating this macro.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GENERATED_BODY()`: 这是一个必须放在类体非常开始的宏。在编译时，Unreal会将其替换为所有必要的样板代码。这意味着在编译时间之前，`GENERATED_BODY()`
    被替换为实际的代码。由于这段代码是编译类所必需的，Epic通过创建这个宏使我们更容易做到这一点。'
- en: '`private`, `public`, and `protected`: These are called access specifiers. Access
    specifiers let you decide whether a method can be accessed by other files or not.
    There are three types of access specifiers. They are:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`, `public`, 和 `protected`: 这些被称为访问修饰符。访问修饰符允许你决定一个方法是否可以被其他文件访问。有三种类型的访问修饰符。它们是：'
- en: '`private`: This means you can access the members only in this class. In this
    example, `CameraBoom` and `FollowCamera` are set as private properties. That means,
    you can access them `only` inside this class. If you create a new class deriving
    from this class, you cannot access them.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`: 这意味着你只能在类内部访问成员。在这个例子中，`CameraBoom` 和 `FollowCamera` 被设置为私有属性。这意味着你只能在类内部访问它们。如果你创建一个新的从该类派生的类，你将无法访问它们。'
- en: '`public`: This means all the members can be accessed from any other class.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`: 这意味着所有成员都可以从任何其他类中访问。'
- en: '`protected`: This means all the members can be accessed from this class and
    any class that is derived from this class.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`: 这意味着所有成员都可以从这个类及其派生类中访问。'
- en: '`UPROPERTY()`: This defines the property metadata and specifiers. These are
    used on properties to serialize, replicate, and expose them to Blueprints. There
    are a number of `UPROPERTY ()` specifiers that you can use. To see the full list,
    visit this link: [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPROPERTY()`: 这定义了属性元数据和修饰符。这些用于在属性上序列化、复制并将它们暴露给蓝图。你可以使用许多 `UPROPERTY ()`
    修饰符。要查看完整列表，请访问此链接：[https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html)。'
- en: '`void`: This means it''s a function that does not return any data type. A function
    can return any type of data such as `float`, `int`, `bool`, or even objects, but
    doesn''t require a data type all the time. In such cases, you would use the void
    return type to indicate that this method does not return any type of data. This
    will also prevent overriding the function in any child classes. If you want to
    override a function in child classes, then you need to make it a virtual void.
    When you create a virtual void, it means child classes can override this function,
    implement their own logic, and optionally call the parent class function using
    the keyword `Super`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`：这意味着它是一个不返回任何数据类型的函数。一个函数可以返回任何类型的数据，如 `float`、`int`、`bool`，甚至对象，但并不总是需要数据类型。在这种情况下，你会使用
    void 返回类型来表示此方法不返回任何类型的数据。这也可以防止在子类中覆盖函数。如果你想覆盖子类中的函数，那么你需要将其设置为 virtual void。当你创建一个
    virtual void 时，这意味着子类可以覆盖此函数，实现自己的逻辑，并可选地使用关键字 `Super` 调用父类函数。'
- en: Understanding the preceding things (preprocessors, macros, access specifiers,
    and so on) will help a lot as you work in Unreal C++.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 理解前面的内容（预处理程序、宏、访问说明符等）将有助于你在 Unreal C++ 中工作。
- en: Another thing that is worth mentioning is the use of double colons (`::`), hyphen
    arrows (`->`), and periods (`.`). Understanding what they are and how to use them
    is crucial. Out of these, mostly we use the hyphen arrow (`->`) symbol. Let's
    see what they are.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提及的是双冒号（`::`）、连字符箭头（`->`）和点（`.`）的使用。理解它们是什么以及如何使用它们是至关重要的。在这些中，我们主要使用连字符箭头（`->`）符号。让我们看看它们是什么。
- en: '**Double colons** (`::`): When using this symbol, it means you are accessing
    a method from a specific namespace or scope. For example, you will use this symbol
    when you want to call static methods from other classes.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双冒号** (`::`): 当使用此符号时，意味着你正在访问特定命名空间或作用域中的方法。例如，当你想要从其他类中调用静态方法时，你会使用此符号。'
- en: '**Hyphen arrow** (`->`): This is used when you are pointing to some data that
    might or might not exist somewhere in the memory. Using this symbol means you
    are trying to access a pointer. A pointer points to a location somewhere in the
    memory where the actual data of that pointer is stored. Before accessing a pointer,
    it is always a good idea to check them and make sure they are valid. Pointers
    are one of the most important part in Unreal C++ so I''d highly recommend to read
    this article provided by Nathan Iyer (Rama): [https://wiki.unrealengine.com/Entry_Level_Guide_to_UE4_C%2B%2B#Pointers](https://wiki.unrealengine.com/Entry_Level_Guide_to_UE4_C%2B%2B#Pointers)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连字符箭头** (`->`): 当你指向可能在内存中某个地方存在或不存在的数据时使用。使用此符号意味着你正在尝试访问一个指针。指针指向内存中某个位置，该位置存储了该指针的实际数据。在访问指针之前，始终检查它们并确保它们是有效的。指针是
    Unreal C++ 中最重要的部分之一，所以我强烈建议阅读 Nathan Iyer (Rama) 提供的这篇文章：[https://wiki.unrealengine.com/Entry_Level_Guide_to_UE4_C%2B%2B#Pointers](https://wiki.unrealengine.com/Entry_Level_Guide_to_UE4_C%2B%2B#Pointers)'
- en: '**Period** (.): This is used to access the data itself. For example, you will
    use this to access the data inside a struct.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点** (.): 这用于访问数据本身。例如，你将使用它来访问结构体内的数据。'
- en: Adding the health system
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加生命值系统
- en: 'Now that we know about the `Character` class, let''s begin by modifying our
    character to add support for the health and health regeneration system. Before
    we begin, let''s see a quick breakdown of what we will be doing. In this system:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `Character` 类，让我们开始修改我们的角色，以添加对生命值和生命值恢复系统的支持。在我们开始之前，让我们快速了解一下我们将要做什么。在这个系统中：
- en: A `float` variable that holds the current health of the player when the game
    begins. We will make sure that the player has maximum health when the player is
    initialized.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `float` 变量，用于存储游戏开始时玩家的当前生命值。我们将确保当玩家初始化时，玩家拥有最大生命值。
- en: Override the default function `TakeDamage ()` of the `Actor` class.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖 `Actor` 类的默认函数 `TakeDamage ()`。
- en: When the player is taking damage, we will check how much damage was taken and
    subtract that amount from the health. We will then start a timer that will execute
    an event that regenerates health.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家受到伤害时，我们将检查受到的伤害量，并从生命值中减去这个数值。然后我们将启动一个计时器，该计时器将执行一个恢复生命值的事件。
- en: Creating a health variable
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个生命值变量
- en: 'So let''s get started. Open up your character source file and add the following
    code under private access specifier:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。打开你的角色源文件，并在私有访问说明符下添加以下代码：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we declare a `Health` variable with the data type `float`. We also added
    `UPROPERTY` to our `float` variable and added the specifiers `EditAnywhere`, `BlueprintReadWrite`,
    and `Category`. The `EditAnywhere` specifier lets you edit this property in the
    **Details** panel. `BlueprintReadWrite` allows you to get or set this value in
    Blueprint. Whatever name you write as the category will appear in the **Details**
    panel. If you compile and start your game and look at the **Details** panel of
    the **ThirdPersonCharacter** Blueprint (in **ThirdPersonCPP/Blueprints**) you
    will see our new property exposed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个 `Health` 变量，其数据类型为 `float`。我们还为我们的 `float` 变量添加了 `UPROPERTY` 并添加了
    `EditAnywhere`、`BlueprintReadWrite` 和 `Category` 修饰符。`EditAnywhere` 修饰符允许你在 **Details**
    面板中编辑这个属性。`BlueprintReadWrite` 允许你在 Blueprint 中获取或设置这个值。无论你将什么名字作为类别，它都会出现在 **Details**
    面板中。如果你编译并启动你的游戏，查看 **ThirdPersonCharacter** Blueprint 的 **Details** 面板（在 **ThirdPersonCPP/Blueprints**
    中），你会看到我们新暴露的属性：
- en: '![Creating a health variable](img/B03950_10_06.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![创建健康变量](img/B03950_10_06.jpg)'
- en: 'As you can see, a value of `0.0` doesn''t make sense to `Health`. So what we
    will do is open the source file of our character class and type the following
    line under the class `constructor`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`0.0` 的值对 `Health` 来说没有意义。所以我们将打开我们角色类的源文件，并在类 `constructor` 下输入以下行：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `constructor` class is usually the first definition in a source file. It
    looks like `YourClassName::YourClassName()`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor` 类通常是源文件中的第一个定义。它看起来像 `YourClassName::YourClassName()`。'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any line preceded by `//` (double slash) is a comment and is ignored by the
    compiler.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以 `//`（双斜杠）开头的一行都是注释，并且会被编译器忽略。
- en: The `constructor` class is basically where we set the default values of our
    class. In this case, we want the default value of our player health to be `100`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor` 类基本上是我们设置类默认值的地方。在这种情况下，我们希望玩家的默认健康值为 `100`。'
- en: Now, if you press the **Compile** button in Unreal Engine editor, the editor
    will compile the new changes and hot reload it when it's finished. When the compilation
    is finished, you should see the new value (which is **100**) as the default value
    for `health`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在 Unreal Engine 编辑器中按下 **Compile** 按钮，编辑器将编译新的更改，并在完成后进行热重载。当编译完成后，你应该看到
    `health` 的默认值（**100**）。
- en: Taking damage
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 受伤
- en: 'Now that our health is set, we can access it and change it in our `character`
    class. We now need to update this value whenever our player is taking damage.
    Since our character is an `Actor` class, we can use the `TakeDamage()` function
    to update the health. To do so, add the following code to your character header
    file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了健康值，我们可以在我们的 `character` 类中访问并更改它。我们现在需要在我们玩家受到伤害时更新这个值。由于我们的角色是 `Actor`
    类，我们可以使用 `TakeDamage()` 函数来更新健康值。要做到这一点，请将以下代码添加到你的角色头文件中：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`TakeDamage` is a virtual function that already exists in the `Actor` class.
    So when you want to have custom logic inside virtual functions, make sure you
    include an override keyword for them. This way you are telling the compiler to
    look in the parent class for a definition of this function. In case if the base
    class definition could not be found or has been changed then the compiler will
    throw an error. Keep in mind that if the override keyword is not there then the
    compiler will treat this as a new definition.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`TakeDamage` 是 `Actor` 类中已经存在的一个虚拟函数。所以当你想在虚拟函数中实现自定义逻辑时，确保为它们包含一个 `override`
    关键字。这样你就告诉编译器在父类中查找这个函数的定义。如果找不到基类定义或者它已经被修改，编译器将抛出一个错误。记住，如果没有 `override` 关键字，编译器将把它视为一个新的定义。'
- en: 'The `TakeDamage` function takes some parameters and returns a `float` value,
    which is the actual damage applied. In this function, we will first check whether
    our health value is larger than `0`. If it is, we decrease the `Health` value
    by the `Damage` value. If not, then we simply return `0`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`TakeDamage` 函数接受一些参数并返回一个 `float` 类型的值，这是实际造成的伤害。在这个函数中，我们首先检查我们的健康值是否大于 `0`。如果是，我们将
    `Health` 值减少 `Damage` 值。如果不是，我们则直接返回 `0`：'
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, you can see the use of comments and how it can help
    when reading the code later. `TakeDamage` function first calls the parent class
    function which returns the actual damage to apply. We will save this value to
    a local variable called `ActualDamage`. We then check whether the `health` value
    is greater than `0.0` and if it is then `health` value is reduced by the `ActualDamage`
    float variable and return that value. Whenever you override a virtual function
    and implement your custom logic, you use `Super::FunctionName()` to inherit the
    basic functionality of the parent class. Since the `TakeDamage()` function is
    virtual, and we override that function, we use `Super::TakeDamage()` to call the
    actual function defined in the parent class, which does the logic of applying
    damage to the actor.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到注释的使用以及它如何有助于以后阅读代码。`TakeDamage` 函数首先调用父类函数，该函数返回要应用的实际伤害。我们将此值保存到名为
    `ActualDamage` 的局部变量中。然后我们检查 `health` 值是否大于 `0.0`，如果是，则通过 `ActualDamage` `float`
    变量减少 `health` 值并返回该值。每次你重写一个虚函数并实现自定义逻辑时，你使用 `Super::FunctionName()` 来继承父类的基本功能。由于
    `TakeDamage()` 函数是虚函数，并且我们重写了该函数，因此我们使用 `Super::TakeDamage()` 来调用在父类中定义的实际函数，该函数执行对演员应用伤害的逻辑。
- en: Health regeneration
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生命恢复
- en: Now that our character can take damage, we will modify this system further and
    add health regeneration. Our health regeneration system will regenerate health
    based on a `float` variable that is by default set to `1.0` every 1 second, which
    is also set to a `float` variable. These settings will be exposed to the Blueprint
    editor, so we can change them later without compiling the game again.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的角色可以受到伤害，我们将进一步修改这个系统并添加生命恢复。我们的生命恢复系统将基于默认设置为每1秒恢复 `1.0` 的 `float`
    变量来恢复生命值，这个值也设置为 `float` 变量。这些设置将公开到蓝图编辑器，这样我们可以在不重新编译游戏的情况下稍后更改它们。
- en: 'Let''s take a quick look at the health regeneration system:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下生命恢复系统：
- en: We use a timer to regenerate health.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用计时器来恢复生命值。
- en: When the player takes damage, we clear this timer.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家受到伤害时，我们将清除这个计时器。
- en: After taking damage, we set the timer to restart after 2 seconds. The timer
    will call a custom function that will regenerate health.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在受到伤害后，我们将计时器设置为2秒后重启。计时器将调用一个自定义函数来恢复生命值。
- en: When the timer finishes, it will call the custom event which will add 1 health.
    This timer will continue to run until the player reaches maximum health.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计时器结束时，它将调用自定义事件，增加1点生命值。这个计时器将持续运行，直到玩家达到最大生命值。
- en: 'So the first thing we need is a `TimerHandle`. This helps in identifying `Timers`
    that have identical methods bound to them. To declare a `TimerHandle`, open up
    the character header file and add the following line under `GENERATED_BODY ()`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先需要的是一个 `TimerHandle`。这有助于识别绑定有相同方法的 `Timers`。要声明 `TimerHandle`，打开角色头文件，并在
    `GENERATED_BODY ()` 下添加以下行：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can use any name for `TimerHandle`. Here, the use of `TimerHandle`_ before
    `HealthRegen` is optional.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为 `TimerHandle` 使用任何名称。在这里，在 `HealthRegen` 前使用 `_TimerHandle` 是可选的。
- en: 'Since we now know that we will be using timers, let''s add two new `float`
    variables that will act as the time to activate the `RegenerateHealth` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们将使用计时器，那么让我们添加两个新的 `float` 变量，它们将作为激活 `RegenerateHealth` 函数的时间：
- en: We will call the first `float` variable `InitialDelay`. This is used to call
    `RegenerateHealth` after taking damage. We will set the default value to `2`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将第一个 `float` 变量命名为 `InitialDelay`。这个变量用于在受到伤害后调用 `RegenerateHealth`。我们将默认值设置为
    `2`。
- en: We will call the second `float` variable `RegenDelay`. When regenerating starts
    from the `TakeDamage` function, we use this `RegenDelay` time to call the `RegenerateHealth`
    function again. We will set the default value to `0.5`.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将第二个 `float` 变量命名为 `RegenDelay`。当从 `TakeDamage` 函数开始恢复时，我们使用这个 `RegenDelay`
    时间再次调用 `RegenerateHealth` 函数。我们将默认值设置为 `0.5`。
- en: 'The following are the variables:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些变量：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will also add a new property called `RegenerateAmount` and expose it to
    the Blueprint editor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个名为 `RegenerateAmount` 的新属性，并将其公开到蓝图编辑器：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `RegenerateAmount` variable you can see a new meta specifier called
    `AllowPrivateAccess`. This is used when you want a variable in private access
    specifier but you need it in Blueprint as well (`BlueprintReadOnly` or `BlueprintReadWrite`).
    Without `AllowPrivateAccess` compiler will throw an error when you use `BlueprintReadWrite`
    or `BlueprintReadOnly` on a variable under private access specifier. Finally,
    we will add a new function called `RegenerateHealth` like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RegenerateAmount`变量中，你可以看到一个名为`AllowPrivateAccess`的新元指定符。当你想在私有访问指定符中有一个变量，但同时也需要在蓝图中使用它（`BlueprintReadOnly`或`BlueprintReadWrite`）时，会用到这个指定符。如果没有`AllowPrivateAccess`，当你在私有访问指定符下的变量上使用`BlueprintReadWrite`或`BlueprintReadOnly`时，编译器将抛出错误。最后，我们将添加一个名为`RegenerateHealth`的新函数，如下所示：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For now, we are done with the header file. Let's open the character source file
    and inside the class constructor (remember the class constructor is `YourClassName::YourClassName()`),
    add the default value for `RegenerateAmount` as `1.0`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经完成了头文件的修改。让我们打开角色源文件，并在类构造函数（记住类构造函数是`YourClassName::YourClassName()`）中添加`RegenerateAmount`的默认值`1.0`。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `constructor` class is not construction script in Blueprints. If you want
    construction script behavior in C++, then you need to override the `OnConstruction`
    method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor`类在蓝图中不是构造脚本。如果你想在C++中实现构造脚本行为，你需要重写`OnConstruction`方法。'
- en: 'We will also add the `RegenerateHealth` function into our source file like
    this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将像这样将`RegenerateHealth`函数添加到我们的源文件中：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside this function, we will write our code that will add the `RegenerateAmount`
    value to our existing health. So let''s modify it like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们将编写我们的代码，将`RegenerateAmount`值添加到我们现有的健康值中。所以让我们修改如下：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's analyze that code. The first thing we do inside this function is
    to check whether our `Health` is greater than or equal to our default `Health`.
    If it is, we simply set the health value to the default value (which is what we
    set in the constructor). If it's not, we add `RegenerateAmount` to our existing
    health and rerun this function using a timer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析一下这段代码。在这个函数内部，我们首先做的事情是检查我们的`Health`是否大于或等于我们的默认`Health`。如果是，我们只需将健康值设置为默认值（这是我们在构造函数中设置的）。如果不是，我们向现有的健康值添加`RegenerateAmount`，并使用计时器重新运行此函数。
- en: 'Finally, we modify the `TakeDamage` function to add `HealthRegeneration`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们修改`TakeDamage`函数以添加`HealthRegeneration`：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the code above, we first check if our health is less than or equal to `0.0`.
    If it is then we know the player has no health so we simply return `0.0`. Otherwise
    we reduce our `health` value and check if health is less than or equal to `0`.
    We clear the timer if health is `0` otherwise we check if health regeneration
    is currently active. If it is not active then we create a new timer to run the
    `RegenerateHealth` function and lastly we return the `ActualDamage` applied.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们首先检查我们的健康值是否小于或等于`0.0`。如果是，那么我们知道玩家没有健康值，所以我们只需简单地返回`0.0`。否则，我们减少我们的`health`值，并检查健康是否小于或等于`0`。如果健康值为`0`，我们清除计时器，否则我们检查健康恢复是否当前处于活动状态。如果它不活跃，那么我们创建一个新的计时器来运行`RegenerateHealth`函数，最后返回应用的`ActualDamage`。
- en: C++ to Blueprint
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 到 蓝图
- en: 'We now have a health and health regeneration system in our character class.
    One problem with our current system is that we have not yet defined what happens
    to our character after the health reaches 0\. In this section, we will create
    an event that we will implement in Blueprint. This event will be called when the
    player''s health reaches 0.0\. To create this Blueprint event, open our character
    header file and add the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在我们的角色类中有一个健康和健康恢复系统。我们当前系统的一个问题是，我们还没有定义当健康值达到0时我们的角色会发生什么。在本节中，我们将创建一个事件，我们将在蓝图（Blueprint）中实现这个事件。当玩家的健康值达到0.0时，将调用此事件。要创建此蓝图事件，打开我们的角色头文件，并添加以下代码：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we added a normal function called `PlayerHealthIsZero()`. To
    make this available in Blueprint, we added a `UFUNCTION` specifier and inside
    that we added `BlueprintImplementableEvent`. This means C++ can call this function
    and it will execute inside Blueprint but we cannot add a definition for this in
    our character source file. Instead, we will just call it inside the source file
    whenever we want. In this example, we will call it inside our `TakeDamage` event
    if the player''s health is `0`. So let''s modify our `TakeDamage` like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们添加了一个名为`PlayerHealthIsZero()`的普通函数。为了使其在蓝图（Blueprint）中可用，我们添加了`UFUNCTION`指定符，并在其中添加了`BlueprintImplementableEvent`。这意味着C++可以调用这个函数，它将在蓝图内部执行，但我们不能在我们的角色源文件中为这个函数添加定义。相反，我们将在源文件中随时调用它。在这个例子中，如果玩家的健康值为`0`，我们将在`TakeDamage`事件中调用它。所以让我们这样修改我们的`TakeDamage`：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we call PlayerHealthIsZero right after clearing the regen
    timer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在清除恢复计时器后立即调用`PlayerHealthIsZero`。
- en: 'Now it''s time to compile and run the project. In Visual Studio, press *F5*
    to compile and launch the project. Once the project is loaded, open our character
    Blueprint and you will see our new variables exposed in the **Details** panel:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是编译和运行项目的时候了。在Visual Studio中，按*F5*编译并启动项目。一旦项目加载，打开我们的角色蓝图，你将在**详细信息**面板中看到我们新的变量被暴露出来：
- en: '![C++ to Blueprint](img/B03950_10_07.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![C++到蓝图](img/B03950_10_07.jpg)'
- en: 'From here, you can open the Blueprint graph and add our **Player Health Is
    Zero** event:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以打开蓝图图并添加我们的**玩家健康值为零**事件：
- en: '![C++ to Blueprint](img/B03950_10_08.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![C++到蓝图](img/B03950_10_08.jpg)'
- en: In this event, you can program your logic to play a death animation, show some
    UI screen, and so on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个事件中，你可以编写逻辑来播放死亡动画，显示一些UI屏幕等等。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Unreal C++ is easy to learn compared to actual C++. This is because the programming
    wizards at Epic Games implemented so many features that makes writing Unreal C++
    fun! You can extend what you learned from this chapter by including Armor system,
    Stamina system, and so on for your character. By incorporating UMG and Blueprints,
    you can show a HUD that shows player health and maybe a small warning system that
    pops up when the player's health goes below 50\. In the next chapter, you will
    learn how to package a project for shipping.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与实际的C++相比，Unreal C++更容易学习。这是因为Epic Games的编程巫师们实现了许多功能，使得编写Unreal C++变得有趣！你可以通过包括装甲系统、耐力系统等等来扩展你在本章中学到的内容，为你的角色添加功能。通过结合UMG和蓝图，你可以显示一个HUD，显示玩家健康值，也许还有一个当玩家健康值低于50时弹出的小型警告系统。在下一章中，你将学习如何打包项目以进行分发。
