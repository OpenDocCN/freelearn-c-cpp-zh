["```cpp\n#include <QCoreApplication>\n#include <QJSEngine>\n\nint main(int argc, char **argv) {\n    QCoreApplication app(argc, argv);\n    QJSEngine engine;\n    engine.installExtensions(QJSEngine::ConsoleExtension);\n    engine.evaluate(\"console.log('Hello World!');\");\n    return 0;\n} \n```", "```cpp\nQJSValue result = engine.evaluate(\"console.log('Hello World!')\");\nif (result.isError()) {\n    qDebug() << \"JS error:\" << result.toString();\n}\n```", "```cpp\nJS error: \"SyntaxError: Expected token `)'\"\n```", "```cpp\nQJSValue result = engine.evaluate(\"(7 + 8) / 2\");\nif (result.isError()) {\n    //...\n} else {\n    qDebug() << result.toNumber();\n}\n```", "```cpp\nvoid MainWindow::openDocument()\n{\n    QString filePath = QFileDialog::getOpenFileName(\n        this, tr(\"Open Document\"),\n        QDir::homePath(), tr(\"JavaScript Documents (*.js)\"));\n    if(filePath.isEmpty()) {\n        return;\n    }\n    open(filePath);\n}\n```", "```cpp\nvoid MainWindow::open(const QString &filePath)\n{\n    QFile file(filePath);\n    if(!file.open(QFile::ReadOnly | QFile::Text)) {\n        QMessageBox::critical(this, tr(\"Error\"), tr(\"Can't open file.\"));\n        return;\n    }\n    setWindowFilePath(filePath);\n    ui->codeEditor->setPlainText(QString::fromUtf8(file.readAll()));\n    ui->logWindow->clear();\n}\n```", "```cpp\nvoid MainWindow::run()\n{\n    ui->logWindow->clear();\n    QTextCursor logCursor = ui->logWindow->textCursor();\n    QString scriptSourceCode = ui->codeEditor->toPlainText();\n    QJSValue result = m_engine.evaluate(scriptSourceCode, \n                                        windowFilePath());\n    if(result.isError()) {\n        QTextCharFormat errFormat;\n        errFormat.setForeground(Qt::red);\n        logCursor.insertText(tr(\"Exception at line %1:\\n\")\n            .arg(result.property(\"lineNumber\").toInt()), errFormat);\n        logCursor.insertText(result.toString(), errFormat);\n        logCursor.insertBlock();\n        logCursor.insertText(result.property(\"stack\").toString(), \n                             errFormat);\n    } else {\n        QTextCharFormat resultFormat;\n        resultFormat.setForeground(Qt::blue);\n        logCursor.insertText(result.toString(), resultFormat);\n    }\n}\n```", "```cpp\nfunction factorial(n) {\n    if(n < 0) {\n        return;\n    }\n    if(n == 0) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nfactorial(7)\n```", "```cpp\nfunction factorial(n) {\n    return N;\n}\n\nfactorial(7) \n```", "```cpp\nvar fun = function() {\n    return 42;\n}\n```", "```cpp\nQString wrappedCode =\n    QStringLiteral(\"(function() { %1\\n})()\").arg(scriptSourceCode);\nQJSValue result = m_engine.evaluate(wrappedCode, windowFilePath());\n```", "```cpp\nvar fun = function() {\n    return 42;\n}\nreturn fun();\n```", "```cpp\nReferenceError: fun is not defined\n```", "```cpp\nQJSEngine engine;\nQPushButton *button = new QPushButton(\"Button\");\n// ...\nQJSValue scriptButton = engine.newQObject(button);\nengine.globalObject().setProperty(\"pushButton\", scriptButton); \n```", "```cpp\npushButton.text = 'My Scripted Button';\npushButton.checkable = true;\npushButton.setChecked(true);\npushButton.show();\n```", "```cpp\npublic:\n    Q_INVOKABLE int myMethod();\n```", "```cpp\npushButton.toggled.connect(function() {\n    console.log('button toggled!');\n});\n```", "```cpp\nfunction buttonToggled() {\n    //...\n}\npushButton.toggled.connect(buttonToggled);\n//...\npushButton.toggled.disconnect(buttonToggled);\n```", "```cpp\nvar obj = { 'name': 'FooBar' };\npushButton.clicked.connect(obj, function() {\n    console.log(this.name);\n});\n```", "```cpp\npushButton.clicked.connect(lineEdit.clear);\n```", "```cpp\npushButton.clicked();\nspinBox.valueChanged(7);\n```", "```cpp\nQJSValue func = engine.evaluate(\n    \"function(checked) { console.log('func', checked); }\");\nQObject::connect(&button, &QPushButton::clicked, [func](bool checked) {\n    QJSValue(func).call({ checked });\n});\n```", "```cpp\nint main(int argc, char *argv[]) {\n    QApplication app(argc, argv);\n    QJSEngine engine;\n    engine.installExtensions(QJSEngine::ConsoleExtension);\n    QPushButton button;\n    engine.globalObject().setProperty(\"pushButton\", engine.newQObject(&button));\n    QString script =\n        \"pushButton.text = 'My Scripted Button';\\n\"\n        \"pushButton.checkable = true;\\n\"\n        \"pushButton.setChecked(true);\\n\"\n        \"pushButton.toggled.connect(function(checked) {\\n\"\n        \"  console.log('button toggled!', checked);\\n\"\n        \"});\\n\"\n        \"pushButton.show();\";\n    engine.evaluate(script);\n\n    QJSValue func = engine.evaluate(\n          \"function(checked) { console.log('button toggled 2!', checked); }\");\n    QObject::connect(&button, &QPushButton::clicked, [func](bool checked) {\n        QJSValue(func).call({ checked });\n    });\n    return app.exec();\n}\n```", "```cpp\nQ_PROPERTY(QString internalName READ internalName SCRIPTABLE false) \n```", "```cpp\npublic:\n    Q_INVOKABLE QObject* createMyObject(int argument) {\n        return new MyObject(argument);\n    }\n```", "```cpp\nvar newObject = originalObject.createMyObject(42);\nnewObject.slot1();\n```", "```cpp\npublic:\n    Q_INVOKABLE explicit MyObject(int argument, QObject *parent = nullptr);\n```", "```cpp\nengine.globalObject().setProperty(\"MyObject\",\n     engine.newQMetaObject(&MyObject::staticMetaObject));\n```", "```cpp\nvar newObject = new MyObject(42);\nnewObject.slot1();\n```", "```cpp\nQ_INVOKABLE double factorial(int x) {\n    return superFastFactorial(x);\n}\n```", "```cpp\nQJSValue myObjectJS = engine.newQObject(new MyObject());\nengine.globalObject().setProperty(\"factorial\",\n                                  myObjectJS.property(\"factorial\"));\n```", "```cpp\nsetRect(-0.4, -0.4, 0.8, 0.8);\nsetPen(Qt::NoPen);\n```", "```cpp\nvoid Entity::setTeam(int team) {\n    m_team = team;\n    QColor color;\n    switch(team) {\n    case 0:\n        color = Qt::green;\n        break;\n    case 1:\n        color = Qt::red;\n        break;\n    }\n    setBrush(color);\n}\n```", "```cpp\nvoid Entity::setAlive(bool alive)\n{\n    m_alive = alive;\n    setVisible(alive);\n    //...\n}\n```", "```cpp\nvoid Scene::setFieldSize(const QSize &fieldSize)\n{\n    m_fieldSize = fieldSize;\n    setSceneRect(-1, -1,\n                 m_fieldSize.width() + 2,\n                 m_fieldSize.height() + 2);\n}\n```", "```cpp\nm_stepTimer = new QTimer(this);\nconnect(m_stepTimer, &QTimer::timeout,\n        this, &Scene::step);\nm_stepTimer->setInterval(1000);\n```", "```cpp\nvoid Scene::start() {\n    const int TEAM_COUNT = 2;\n    for(int i = 0; i < m_teamSize; i++) {\n        for(int team = 0; team < TEAM_COUNT; team++) {\n            Entity* entity = new Entity(this);\n            entity->setTeam(team);\n            QPoint pos;\n            do {\n                pos.setX(qrand() % m_fieldSize.width());\n                pos.setY(qrand() % m_fieldSize.height());\n            } while(itemAt(pos, QTransform()));\n            entity->setPos(pos);\n            addItem(entity);\n            m_entities << entity;\n        }\n    }\n    //...\n    m_stepTimer->start();\n}\n```", "```cpp\nqsrand(QDateTime::currentMSecsSinceEpoch());\n```", "```cpp\nSceneProxy::SceneProxy(Scene *scene) :\n    QObject(scene), m_scene(scene)\n{\n}\n```", "```cpp\nQ_INVOKABLE QSize size() const;\nQ_INVOKABLE QJSValue entities() const;\n```", "```cpp\nQSize SceneProxy::size() const {\n    return m_scene->fieldSize();\n}\n```", "```cpp\nclass EntityProxy : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit EntityProxy(Entity *entity, QObject *parent = nullptr);\n    Q_INVOKABLE int team() const;\n    Q_INVOKABLE QPoint pos() const;\n    //...\nsignals:\n    void killed();\nprivate:\n    Entity *m_entity;\n};\n```", "```cpp\nint EntityProxy::team() const\n{\n    return m_entity->team();\n}\n\nQPoint EntityProxy::pos() const\n{\n    return m_entity->pos().toPoint();\n}\n```", "```cpp\nEntityProxy *m_proxy;\nQJSValue m_proxyValue;\n```", "```cpp\nm_proxy = new EntityProxy(this, scene);\nm_proxyValue = scene->jsEngine()->newQObject(m_proxy);\n```", "```cpp\nvoid Entity::setAlive(bool alive)\n{\n    m_alive = alive;\n    setVisible(alive);\n    if (!alive) {\n        emit m_proxy->killed();\n    }\n}\n```", "```cpp\nQJSValue SceneProxy::entities() const\n{\n    QJSValue list = m_scene->jsEngine()->newArray();\n    int arrayIndex = 0;\n    for(Entity *entity: m_scene->entities()) {\n        if (entity->isAlive()) {\n            list.setProperty(arrayIndex, entity->proxyValue());\n            arrayIndex++;\n        }\n    }\n    return list;\n}\n```", "```cpp\nSceneProxy *sceneProxy = new SceneProxy(this);\nm_sceneProxyValue = m_jsEngine.newQObject(sceneProxy);\n```", "```cpp\nQHash<int, QJSValue> m_teamScripts;\n```", "```cpp\nvoid Scene::setScript(int team, const QString &script) {\n    QJSValue value = m_jsEngine.evaluate(script);\n    if (value.isError()) {\n        qDebug() << \"js error: \" << value.toString();\n        return;\n    }\n    if(!value.isObject()) {\n        qDebug() << \"script must return an object\";\n        return;\n    }\n    m_teamScripts[team] = value;\n}\n```", "```cpp\nscene.setScript(0, loadFile(\":/scripts/1.js\"));\nscene.setScript(1, loadFile(\":/scripts/2.js\"));\n```", "```cpp\nQString loadFile(const QString& path) {\n    QFile file(path);\n    if (!file.open(QFile::ReadOnly)) {\n        qDebug() << \"failed to open \" << path;\n        return QString();\n    }\n    return QString::fromUtf8(file.readAll());\n}\n```", "```cpp\nQStringList arguments = app.arguments();\nif (arguments.count() < 3) {\n    qDebug() << \"usage: \" << argv[0] << \" path/to/script1.js path/to/script2.js\";\n    return 1;\n}\nscene.setScript(0, loadFile(arguments[1]));\nscene.setScript(1, loadFile(arguments[2]));\n```", "```cpp\nfor(int team = 0; team < TEAM_COUNT; team++) {\n    QJSValue script = m_teamScripts.value(team);\n    if (script.isUndefined()) {\n        continue;\n    }\n    if (!script.hasProperty(\"init\")) {\n        continue;\n    }\n    m_jsEngine.globalObject().setProperty(\"field\", m_sceneProxyValue);\n    QJSValue scriptOutput = script.property(\"init\").call();\n    if (scriptOutput.isError()) {\n        qDebug() << \"script error: \" << scriptOutput.toString();\n        continue;\n    }\n}\n```", "```cpp\nvoid Scene::step() {\n    for(Entity* entity: m_entities) {\n        if (!entity->isAlive()) {\n            continue;\n        }\n        QJSValue script = m_teamScripts.value(entity->team());\n        if (script.isUndefined()) {\n            continue;\n        }\n        m_jsEngine.globalObject().setProperty(\"field\", m_sceneProxyValue);\n\n        QJSValue scriptOutput =\n            script.property(\"step\").call({ entity->proxyValue() });\n        //...\n    }\n}\n```", "```cpp\nif (scriptOutput.isError()) {\n    qDebug() << \"script error: \" << scriptOutput.toString();\n    continue;\n}\nQJSValue scriptOutputX = scriptOutput.property(\"x\");\nQJSValue scriptOutputY = scriptOutput.property(\"y\");\nif (!scriptOutputX.isNumber() || !scriptOutputY.isNumber()) {\n    qDebug() << \"invalid script output: \" << scriptOutput.toVariant();\n    continue;\n}\nQPoint pos(scriptOutputX.toInt(), scriptOutputY.toInt());\nif (!moveEntity(entity, pos)) {\n    qDebug() << \"invalid move\";\n}\n```", "```cpp\nbool Scene::moveEntity(Entity *entity, QPoint pos) {\n    if (pos.x() < 0 || pos.y() < 0 ||\n        pos.x() >= m_fieldSize.width() ||\n        pos.y() >= m_fieldSize.height())\n    {\n        return false; // out of field bounds\n    }\n    QPoint posChange = entity->pos().toPoint() - pos;\n    if (posChange.isNull()) {\n        return true; // no change\n    }\n    if (qAbs(posChange.x()) > 1 || qAbs(posChange.y()) > 1) {\n        return false; // invalid move\n    }\n    QGraphicsItem* item = itemAt(pos, QTransform());\n    Entity* otherEntity = qgraphicsitem_cast<Entity*>(item);\n    if (otherEntity) {\n        otherEntity->setAlive(false);\n    }\n    entity->setPos(pos);\n    return true;\n}\n```", "```cpp\n{\n    \"step\": function(current) {\n        function getRandomInt(min, max) {\n          return Math.floor(Math.random() * (max - min)) + min;\n        }\n        return {\n            x: current.pos().x + getRandomInt(-1, 2),\n            y: current.pos().y + getRandomInt(-1, 2),\n        }\n    }\n}\n```", "```cpp\nsudo apt-get install libpython3.5-dev\n```", "```cpp\nCONFIG += link_pkgconfig no_keywords\n# adjust the version number to suit your needs\nPKGCONFIG += python-3.5m\n```", "```cpp\nCONFIG += no_keywords\nINCLUDEPATH += C:\\Python35\\include\nLIBS += -LC:\\Python35\\include -lpython35\n```", "```cpp\n#include <Python.h>\n#include <QtCore>\n\nint main(int argc, char **argv) {\n    QCoreApplication app(argc, argv);\n    Py_Initialize();\n    const char *script = \"print(\\\"Hello from Python\\\")\";\n    PyRun_SimpleString(script);\n    Py_Finalize();\n    return app.exec();\n} \n```", "```cpp\nclass QtPython : public QObject {\n    Q_OBJECT\npublic:\n    QtPython(QObject *parent = 0);\n    ~QtPython();\n    void run(const QString &program);\n\nprivate:\n    QVector<wchar_t> programNameBuffer;\n};\n```", "```cpp\n#include <Python.h>\n//...\nQtPython::QtPython(QObject *parent) : QObject(parent) {\n    QStringList args = qApp->arguments();\n    if (args.count() > 0) {\n        programNameBuffer.resize(args[0].count());\n        args[0].toWCharArray(programNameBuffer.data());\n        Py_SetProgramName(programNameBuffer.data());\n    }\n    Py_InitializeEx(0);\n}\n\nQtPython::~QtPython() {\n    Py_Finalize();\n}\n\nvoid QtPython::run(const QString &program) {\n    PyRun_SimpleString(qPrintable(program));\n}\n```", "```cpp\nint main(int argc, char *argv[])\n{\n    QCoreApplication app(argc, argv);\n    QtPython python;\n    python.run(\"print('Hello from Python')\");\n    return 0;\n}\n```", "```cpp\nclass QtPythonValue {\npublic:\n    QtPythonValue();\n    QtPythonValue(const QtPythonValue &other);\n    QtPythonValue& operator=(const QtPythonValue &other);\n\n    QtPythonValue(int val);\n    QtPythonValue(const QString &str);\n    ~QtPythonValue();\n\n    int toInt() const;\n    QString toString() const;\n    bool isNone() const;\n\nprivate:\n    QtPythonValue(PyObject *ptr);\n    void incRef();\n    void incRef(PyObject *val);\n    void decRef();\n\n    PyObject *m_value;\n    friend class QtPython;\n};\n```", "```cpp\nQtPythonValue::QtPythonValue() {\n    incRef(Py_None);\n}\nQtPythonValue::QtPythonValue(const QtPythonValue &other) {\n    incRef(other.m_value);\n}\nQtPythonValue::QtPythonValue(PyObject *ptr) {\n    m_value = ptr;\n}\nQtPythonValue::QtPythonValue(const QString &str) {\n    m_value = PyUnicode_FromString(qPrintable(str));\n}\nQtPythonValue::QtPythonValue(int val) {\n    m_value = PyLong_FromLong(val);\n}\nQtPythonValue &QtPythonValue::operator=(const QtPythonValue &other) {\n    if(m_value == other.m_value) {\n        return *this;\n    }\n    decRef();\n    incRef(other.m_value);\n    return *this;\n}\nQtPythonValue::~QtPythonValue()\n{\n    decRef();\n}\n```", "```cpp\nvoid QtPythonValue::incRef(PyObject *val) {\n    m_value = val;\n    incRef();\n}\nvoid QtPythonValue::incRef() {\n    if(m_value) {\n        Py_INCREF(m_value);\n    }\n}\nvoid QtPythonValue::decRef() {\n    if(m_value) {\n        Py_DECREF(m_value);\n    }\n}\n```", "```cpp\nint QtPythonValue::toInt() const {\n    return PyLong_Check(m_value) ? PyLong_AsLong(m_value) : 0;\n}\n\nQString QtPythonValue::toString() const {\n    return PyUnicode_Check(m_value) ?\n        QString::fromUtf8(PyUnicode_AsUTF8(m_value)) : QString();\n}\n\nbool QtPythonValue::isNone() const {\n    return m_value == Py_None;\n}\n```", "```cpp\nint main(int argc, char *argv[]) {\n    QCoreApplication app(argc, argv);\n    QtPython python;\n    QtPythonValue integer = 7, string = QStringLiteral(\"foobar\"), none;\n    qDebug() << integer.toInt() << string.toString() << none.isNone();\n    return 0;\n} \n```", "```cpp\nQtPythonValue::QtPythonValue(const QVariant &variant)\n{\n    switch(variant.type()) {\n    case QVariant::Invalid:\n        incRef(Py_None);\n        return;\n    case QVariant::String:\n        m_value = PyUnicode_FromString(qPrintable(variant.toString()));\n        return;\n    case QVariant::Int:\n        m_value = PyLong_FromLong(variant.toInt());\n        return;\n    case QVariant::LongLong:\n        m_value = PyLong_FromLongLong(variant.toLongLong());\n        return;\n    case QVariant::List: {\n        QVariantList list = variant.toList();\n        const int listSize = list.size();\n        PyObject *tuple = PyTuple_New(listSize);\n        for(int i = 0; i < listSize; ++i) {\n            PyTuple_SetItem(tuple, i, QtPythonValue(list.at(i)).m_value);\n        }\n        m_value = tuple;\n        return;\n    }\n    case QVariant::Map: {\n        QVariantMap map = variant.toMap();\n        PyObject *dict = PyDict_New();\n        for(auto iter = map.begin(); iter != map.end(); ++iter) {\n            PyDict_SetItemString(dict, qPrintable(iter.key()),\n                                 QtPythonValue(iter.value()).m_value);\n        }\n        m_value = dict;\n        return;\n    }\n    default:\n        incRef(Py_None);\n        return;\n    }\n}\n```", "```cpp\nQtPythonValue QtPython::run(const QString &program,\n    const QtPythonValue &globals, const QtPythonValue &locals)\n{\n    PyObject *retVal = PyRun_String(qPrintable(program),\n        Py_file_input, globals.m_value, locals.m_value);\n    return QtPythonValue(retVal);\n} \n```", "```cpp\nQtPythonValue QtPython::import(const QString &name) const\n{\n    return QtPythonValue(PyImport_ImportModule(qPrintable(name)));\n}\n\nQtPythonValue QtPython::addModule(const QString &name) const\n{\n    PyObject *retVal = PyImport_AddModule(qPrintable(name));\n    Py_INCREF(retVal);\n    return QtPythonValue(retVal);\n}\n\nQtPythonValue QtPython::dictionary(const QtPythonValue &module) const\n{\n    PyObject *retVal = PyModule_GetDict(module.m_value);\n    Py_INCREF(retVal);\n    return QtPythonValue(retVal);\n}\n```", "```cpp\nbool QtPythonValue::isCallable() const {\n    return PyCallable_Check(m_value);\n}\n\nQtPythonValue QtPythonValue::attribute(const QString &name) const {\n    return QtPythonValue(PyObject_GetAttrString(m_value, qPrintable(name)));\n}\n\nbool QtPythonValue::setAttribute(const QString &name, const QtPythonValue &value) {\n    int retVal = PyObject_SetAttrString(m_value, qPrintable(name), value.m_value);\n    return retVal != -1;\n}\n\nQtPythonValue QtPythonValue::call(const QVariantList &arguments) const {\n    return QtPythonValue(\n        PyObject_CallObject(m_value, QtPythonValue(arguments).m_value));\n}\n\nQtPythonValue QtPythonValue::call(const QStringList &arguments) const {\n    return QtPythonValue(\n        PyObject_CallObject(m_value, QtPythonValue(arguments).m_value));\n}\n```", "```cpp\nint main(int argc, char *argv[])\n{\n    QCoreApplication app(argc, argv);\n    QtPython python;\n\n    QtPythonValue mainModule = python.addModule(\"__main__\");\n    QtPythonValue dict = python.dictionary(mainModule);\n    python.run(\"foo = (1, 2, 3)\", dict, dict);\n    python.run(\"print(foo)\", dict, dict);\n\n    QtPythonValue module = python.import(\"os\");\n    QtPythonValue chdir = module.attribute(\"chdir\");\n    chdir.call(QStringList() << \"/home\");\n    QtPythonValue func = module.attribute(\"getcwd\");\n    qDebug() << func.call(QVariantList()).toString();\n\n    return 0;\n}\n```"]