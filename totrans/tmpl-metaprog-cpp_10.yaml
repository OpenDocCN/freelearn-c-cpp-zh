- en: '*Chapter 7*: Patterns and Idioms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous parts of the book were designed to help you learn everything about
    templates, from the basics to the most advanced features, including the latest
    concepts and constraints from C++20\. Now, it is time for us to put this knowledge
    to work and learn about various metaprogramming techniques. In this chapter, we
    will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic versus static polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Curiously Recurring Template Pattern** (**CRTP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type erasure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag dispatching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typelists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a good understanding of various multiprogramming
    techniques that will help you solve a variety of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start the chapter by discussing the two forms of polymorphism: dynamic
    and static.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic versus static polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you learn about object-oriented programming, you learn about its fundamental
    principles, which are **abstraction**, **encapsulation**, **inheritance**, and
    **polymorphism**. C++ is a multi-paradigm programming language that supports object-oriented
    programming too. Although a broader discussion on the principles of object-oriented
    programming is beyond the scope of this chapter and this book, it is worth discussing
    at least some aspects related to polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is polymorphism? The term is derived from the Greek words for “*many
    forms*”. In programming, it’s the ability of objects of different types to be
    treated as if they were of the same type. The C++ standard actually defines a
    polymorphic class as follows (see C++20 standard, paragraph *11.7.2*, *Virtual
    functions*):'
  prefs: []
  type: TYPE_NORMAL
- en: A class that declares or inherits a virtual function is called a polymorphic
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also defines polymorphic objects based on this definition, as follows (see
    C++20 standard, paragraph *6.7.2*, *Object model*):'
  prefs: []
  type: TYPE_NORMAL
- en: Some objects are polymorphic (11.7.2); the implementation generates information
    associated with each such object that makes it possible to determine that object’s
    type during program execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this actually refers to what is called **dynamic polymorphism** (or
    late binding), but there is yet another form of polymorphism, called **static
    polymorphism** (or early binding). Dynamic polymorphism occurs at runtime with
    the help of interfaces and virtual functions, while static polymorphism occurs
    at compile-time with the help of overloaded functions and templates. This is described
    in Bjarne Stroustrup’s glossary of terms for the C++ language (see [https://www.stroustrup.com/glossary.html](https://www.stroustrup.com/glossary.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism - providing a single interface to entities of different types.
    virtual functions provide dynamic (run-time) polymorphism through an interface
    provided by a base class. Overloaded functions and templates provide static (compile-time)
    polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of dynamic polymorphism. The following is a hierarchy
    of classes representing different units in a game. These units may attack others,
    so there is a base class with a pure virtual function called `attack`, and several
    derived classes implementing specific units that override this virtual function
    doing different things (of course, for simplicity, here we just print a message
    to the console). It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this hierarchy of classes (which according to the standard are called
    `fight` shown as follows. This takes a sequence of pointers to objects of the
    base `game_unit` type and calls the `attack` member function. Here is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This function does not need to know the actual type of each object because
    due to dynamic polymorphism, it can handle them as if they were of the same (base)
    type. Here is an example of using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But now let’s say you could combine a mage and a knight and create a new unit,
    a knight mage with special abilities from both these units. C++ enables us to
    write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This does not come out of the box, but the language supports overloading operators,
    and we could do that for any user-defined types. To make the preceding line possible,
    we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind these are just some simple snippets without any complex code. But
    the ability to add a `knight` and a `mage` together to create a `knight_mage`
    is nothing short of the ability to add two integers together, or a `double` and
    an `int`, or two `std::string` objects. This happens because there are many overloads
    of the `+` operator (both for built-in types and user-defined types) and based
    on the operands, the compiler is selecting the appropriate overload. Therefore,
    it can be said there are many forms of this operator. This is true for all the
    operators that can be overloaded; the `+` operator is just a typical example since
    it is ubiquitous. And this is the compile-time version of polymorphism, called
    **static polymorphism**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators are not the only functions that can be overloaded. Any function can
    be overloaded. Although we have seen many examples in the book, let’s take another
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, the `increment` function is overloaded for both the `attack`
    and `defense` types, allowing us to write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replace the two overloads of `increment` with a function template. The
    changes are minimal, as shown in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code continues to work, but there is a significant difference:
    in the former example, we had two overloads, one for `attack` and one for `defense`,
    so you could call the function with objects of these types but nothing else. In
    the latter, we have a template that defines a family of overloaded functions for
    any possible type `T` that has a data member called `value` whose type supports
    the post-increment operator. We can define constraints for such a function template,
    which is something we have seen in the previous two chapters of the book. However,
    the key takeaway is that overloaded functions and templates are the mechanisms
    to implement static polymorphism in the C++ language.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic polymorphism incurs a performance cost because in order to know what
    functions to call, the compiler needs to build a table of pointers to virtual
    functions (and also a table of pointers to virtual base classes in case of virtual
    inheritance). So, there is some level of indirection when calling virtual functions
    polymorphically. Moreover, the details of virtual functions are not made available
    to the compiler who cannot optimize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When these things can be validated as performance issues, we could raise the
    question: can we get the benefits of dynamic polymorphism at compile time? The
    answer is yes and there is one way to achieve this: the Curiously Recurring Template
    Pattern, which we will discuss next.'
  prefs: []
  type: TYPE_NORMAL
- en: The Curiously Recurring Template Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This pattern has a rather curious name: the **Curiously Recurring Template
    Pattern**, or **CRTP** for short. It’s called curious because it is rather odd
    and unintuitive. The pattern was first described (and its name coined) by James
    Coplien in a column in the *C++ Report* in 1995\. This pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a base class template that defines the (static) interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derived classes are themselves the template argument for the base class template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member functions of the base class call member functions of its type template
    parameter (which are the derived classes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how the pattern implementation looks in practice. We will transform
    the previous example with game units into a version using the CRTP. The pattern
    implementation goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `game_unit` class is now a template class but contains the same member function,
    `attack`. Internally, this performs an upcast of the `this` pointer to `T*` and
    then invokes a member function called `do_attack`. The `knight` and `mage` classes
    derive from the `game_unit` class and pass themselves as the argument for the
    type template parameter `T`. Both provide a member function called `do_attack`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the member function in the base class template and the called member
    function in the derived classes have different names. Otherwise, if they had the
    same name, the derived class member functions would hide the member from the base
    since these are no longer virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fight` function that takes a collection of game units and calls the `attack`
    function needs to change too. It needs to be implemented as a function template,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this function is a little different than before. It goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We have moved the runtime polymorphism to compile-time. Therefore, the `fight`
    function cannot treat `knight` and `mage` objects polymorphically. Instead, we
    get two different overloads, one that can handle `knight` objects and one that
    can handle `mage` objects. This is static polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the pattern might not look complicated after all, the question you’re
    probably asking yourself at this point is: how is this pattern actually useful?
    There are different problems you can solve using CRT, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the number of times a type can be instantiated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding common functionality and avoiding code duplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the composite design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following subsections, we will look at each of these problems and see
    how to solve them with CRTP.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the object count with CRTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s assume that for the game in which we created knights and mages we need
    some items to be available in a limited number of instances. For instance, there
    is a special sword type called *Excalibur* and there should be only one instance
    of it. On the other hand, there is a book of magic spells but there cannot be
    more than three instances of it at a time in the game. How do we solve this? Obviously,
    the sword problem could be solved with the singleton pattern. But what do we do
    when we need to limit the number to some higher value but still finite? The singleton
    pattern wouldn’t be of much help (unless we transform it into a “*multiton*”)
    but the CRTP would.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start with a base class template. The only thing this class template
    does is keep a count of how many times it has been instantiated. The counter,
    which is a static data member, is incremented in the constructor and decremented
    in the destructor. When that count exceeds a defined limit, an exception is thrown.
    Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the template consists of defining the derived classes. For
    the mentioned problem, they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate `excalibur` once. The second time we try to do the same
    (while the first instance is still alive) an exception will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can instantiate `book_of_magic` three times and an exception
    will be thrown the fourth time we attempt to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Next, we look at a more common scenario, adding common functionality to types.
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionality with CRTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another case when the curiously recurring template pattern can help us is providing
    common functionalities to derived classes through generic functions in a base
    class that relies solely on derived class members. Let’s take an example to understand
    this use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose that some of our game units have member functions such as `step_forth`
    and `step_back` that move them one position, forward or backward. These classes
    would look as follows (at a bare minimum):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it could be a requirement that everything that can move back and forth
    one step should also be able to advance or retreat an arbitrary number of steps.
    However, this functionality could be implemented based on the `step_forth` and
    `step_back` functions, which would help avoid having duplicate code in each of
    these game unit classes. The CRTP implementation for this problem would, therefore,
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'We can advance and retreat the units by calling the base class `advance` and
    `retreat` member functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'You could argue that the same result could be achieved using non-member function
    templates. For the sake of discussion, such a solution is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The client code would need to change but the changes are actually small:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: The choice between these two may depend on the nature of the problem and your
    preferences. However, the CRTP has the advantage that it is describing well the
    interface of the derived classes (such as `knight` and `mage` in our example).
    With the non-member functions, you wouldn’t necessarily know about this functionality,
    which would probably come from a header that you need to include. However, with
    CRTP, the class interface is well visible to those using it.
  prefs: []
  type: TYPE_NORMAL
- en: For the last scenario we discuss here, let’s see how CRTP helps to implement
    the composite design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the composite design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In their famous book, *Design Patterns: Elements of Reusable Object-Oriented
    Software*, the Gang of Four (Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides) describe a structural pattern called composite that enables us to compose
    objects into larger structures and treat both individual objects and compositions
    uniformly. This pattern can be used when you want to represent part-whole hierarchies
    of objects and you want to ignore the differences between individual objects and
    compositions of individual objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To put this pattern into practice, let’s consider the game scenario again.
    We have heroes that have special abilities and can do different actions, one of
    which is allying with another hero. That can be easily modeled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'These heroes are represented by the `hero` class that contains a name, a list
    of connections to other `hero` objects, as well as a member function, `ally_with`,
    that defines an alliance between two heroes. We can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running this snippet is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything was simple so far. But the requirement is that heroes could be grouped
    together to form parties. It should be possible for a hero to ally with a group,
    and for a group to ally with either a hero or an entire group. Suddenly, there
    is an explosion of functions that we need to provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where the composite design pattern helps us treat heroes and parties
    uniformly and avoid unnecessary duplications of the code. As usual, there are
    different ways to implement it, but one way is using the curiously recurring template
    pattern. The implementation requires a base class that defines the common interface.
    In our case, this will be a class template with a single member function called
    `ally_with`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define the `hero` class as a derived class from `base_unit<hero>`.
    This time, the `hero` class no longer implements `ally_with` itself. However,
    it features `begin` and `end` methods that are intended to simulate the behavior
    of a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'The class that models a group of heroes is called `hero_party` and derives
    from both `std::vector<hero>` (to define a container of `hero` objects) and from
    `base_unit<hero_party>`. This is why the `hero` class has `begin` and `end` functions
    to help us perform iterating operations on `hero` objects, just as we would do
    with `hero_party` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to implement the `ally_with` member function of the base class. The
    code is shown as follows. What it does is iterate through all the sub-objects
    of the current object and connect them with all the sub-objects of the supplied
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hero` class declared the `base_unit` class template a friend so that it
    could access the `connections` member. It also declared the `operator<<` as a
    friend so that this function could access both the `connections` and `name` private
    members. For more information about templates and friends, see [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*. The output stream operator implementation is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'Having all this defined, we can write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from this that we are able to ally a `hero` with both another `hero`
    and a `hero_party`, as well as a `hero_party` with either a `hero` or another
    `hero_party`. That was the proposed goal, and we were able to do it without duplicating
    the code between `hero` and `hero_party`. The output of executing the previous
    snippet is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: After seeing how the CRTP helps achieve different goals, let’s look at the use
    of the CRTP in the C++ standard library.
  prefs: []
  type: TYPE_NORMAL
- en: The CRTP in the standard library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard library contains a helper type called `std::enabled_shared_from_this`
    (in the `<memory>` header) that enables objects managed by a `std::shared_ptr`
    to generate more `std::shared_ptr` instances in a safe manner. The `std::enabled_shared_from_this`
    class is the base class in the CRTP pattern. However, the previous description
    may sound abstract, so let’s try to understand it with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we have a class called `building` and we are creating `std::shared_ptr`
    objects in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: We have a raw pointer and, on line `[1]`, we instantiate a `std::shared_ptr`
    object to manage its lifetime. However, on line `[2]`, we instantiate a second
    `std::shared_ptr` object for the same pointer. Unfortunately, the two smart pointers
    know nothing of each other, so upon getting out of scope, they will both delete
    the `building` object allocated on the heap. Deleting an object that was already
    deleted is undefined behavior and will likely result in a crash of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::enable_shared_from_this` class helps us create more `shared_ptr`
    objects from an existing one in a safe manner. First, we need to implement the
    CRTP pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'Having this new implementation, we can call the member function `shared_from_this`
    to create more `std::shared_ptr` instances from an object, which all refer to
    the same instance of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface of the `std::enable_shared_from_this` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: The previous example shows how `enable_shared_from_this` works but does not
    help understand when it is appropriate to use it. Therefore, let’s modify the
    example to show a realistic example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider that the buildings we have can be upgraded. This is a process
    that takes some time and involves several steps. This task, as well as other tasks
    in the game, are executed by a designated entity, which we will call `executor`.
    In its simplest form, this `executor` class has a public member function called
    `execute` that takes a function object and executes it on a different thread.
    The following listing is a simple implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'The `building` class has a pointer to an `executor`, which is passed from the
    client. It also has a member function called `upgrade` that kicks off the execution
    process. However, the actual upgrade occurs in a different, private, function
    called `do_upgrade`. This is called from a lambda expression that is passed to
    the `execute` member function of the `executor`. All these are shown in the following
    listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'The client code is relatively simple: create an `executor`, create a building
    managed by a `shared_ptr`, set the `executor` reference, and run the upgrade process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this program, you get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: What we can see here is that the building is destroyed before the upgrade process
    begins. This incurs undefined behavior and, although this program didn’t crash,
    a real-world program would certainly crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The culprit for this behavior is this particular line in the upgrading code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating a lambda expression that captures the `this` pointer. The pointer
    is later used after the object it points to has been destroyed. To avoid this,
    we would need to create and capture a `shared_ptr` object. The safe way to do
    that is with the help of the `std::enable_shared_from_this` class. There are two
    changes that need to be done. The first is to actually derive the `building` class
    from the `std::enable_shared_from_this` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'The second change requires us to call `shared_from_this` in the lambda capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'These are two slight changes to our code but the effect is significant. The
    building object is no longer destroyed before the lambda expression gets executed
    on a separate thread (because there is now an extra shared pointer that refers
    to the same object as the shared pointer created in the main function). As a result,
    we get the output we expected (without any changes to the client code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: You could argue that after the main `function` finishes, we shouldn’t care what
    happens. Mind that this is just a demo program, and in practice, this happens
    in some other function and the program continues to run long after that function
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we conclude the discussion around the curiously recurring template
    pattern. Next, we will look at a technique called **mixins** that is often mixed
    with the CRTP pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mixins are small classes that are designed to add functionality to other classes.
    If you read about mixins, you will often find that the curiously recurring template
    pattern is used to implement mixins in C++. This is an incorrect statement. The
    CRTP helps achieve a similar goal to mixins, but they are different techniques.
    The point of mixins is that they are supposed to add functionality to classes
    without being a base class to them, which is the key to the CRTP pattern. Instead,
    mixins are supposed to inherit from the classes they add functionality to, which
    is the CRTP upside down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the earlier example with knights and mages that could move forth and
    back with the `step_forth` and `step_back` member functions? The `knight` and
    `mage` classes were derived from the `movable_unit` class template that added
    the functions `advance` and `retreat`, which enabled units to move several steps
    forth or back. The same example can be implemented using mixins in a reverse order.
    Here is how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that `knight` and `mage` are now classes that don’t have any
    base class. They both provide the `step_forth` and `step_back` member functions
    just as they did before, when we implemented the CRTP pattern. Now, the `movable_unit`
    class template is derived from one of these classes and defines the `advance`
    and `retreat` functions, which call `step_forth` and `step_back` in a loop. We
    can use them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to what we had with the CRTP pattern, except that now
    we create instances of `movable_unit<knight>` and `movable_unit<mage>` instead
    of `knight` and `mage`. A comparison of the two patterns is shown in the following
    diagram (with CRTP on the left and mixins on the right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Comparison of the CRTP and the mixins patterns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: Comparison of the CRTP and the mixins patterns'
  prefs: []
  type: TYPE_NORMAL
- en: We can combine the static polymorphism achieved with mixins with dynamic polymorphism
    achieved with interfaces and virtual functions. We’ll demonstrate this with the
    help of an example concerning game units that fight. We had an earlier example
    when we discussed the CRTP, where the `knight` and `mage` classes had a member
    function called `attack`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to define multiple attacking styles. For instance, each game
    unit can use either an aggressive or a moderate attacking style. So that means
    four combinations: aggressive and moderate knights, and aggressive and moderate
    mages. On the other hand, both knights and mages could be lone warriors that are
    comfortable to fight alone, or are team players that always fight in a group with
    other units.'
  prefs: []
  type: TYPE_NORMAL
- en: That means we could have lone aggressive knights and lone moderate knights as
    well as team player aggressive knights and team player moderate knights. The same
    applies to mages. As you can see, the number of combinations grows a lot and mixins
    are a good way to provide this added functionality without expanding the `knight`
    and `mage` classes. Finally, we want to be able to treat all these polymorphically
    at runtime. Let’s see how we can do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can define aggressive and moderate fighting styles. These could be
    as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define mixins as the requirement of being able to fight alone or in
    a group. These classes are templates and are derived from their template argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, we need to define the `knight` and `mage` classes. These themselves will
    be mixins for the fighting styles. However, to be able to treat them polymorphically
    at runtime, we derive them from a base `game_unit` class that contains a pure
    virtual method called `attack` that these classes implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: 'The `knight` and `mage` implementation of the `attack` member function makes
    use of the `T::fight` method. You have probably noticed that both the `aggresive_style`
    and `moderate_style` classes on one hand and the `lone_warrior` and `team_warrior`
    mixin classes on the other hand provide such a member function. This means we
    can do the following combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: 'In total, there are 12 combinations that we defined here. And this was all
    possible with only six classes. This shows how mixins help us add functionality
    while keeping the complexity of the code at a reduced level. If we run the code,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: We have looked here at two patterns, CRTP and mixins, that are both intended
    to add additional (common) functionality to other classes. However, although they
    look similar, they have opposite structures and should not be confused with one
    another. An alternative technique to leverage common functionalities from unrelated
    types is called type erasure, which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Type erasure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term `void` pointers (a legacy of the C language, which is to be avoided),
    but true type erasure is achieved with templates. Before we discuss this, let’s
    briefly look at the others.
  prefs: []
  type: TYPE_NORMAL
- en: The most rudimentary form of type erasure is the use of `void` pointers. This
    is typical of C and although possible in C++, it is in no way recommended. It
    is not type-safe and, therefore, error-prone. However, for the sake of the discussion,
    let’s have a look at such an approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we again have `knight` and `mage` types and they both have an attack
    function (a behavior), and we want to treat them in a common way to exhibit this
    behavior. Let’s see the classes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'In a C-like implementation, we could have a function for each of these types,
    taking a `void*` to an object of the type, casting it to the expected type of
    pointer, and then invoking the `attack` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: 'These have a similar signature; the only thing that differs is the name. So,
    we can define a function pointer and then associate an object (or more precisely
    a pointer to an object) with a pointer to the right function handling it. Here
    is how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no information about types in this last snippet. All that has been
    erased using `void` pointers. The `fight` function can be invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: From a C++ perspective, this will probably look odd. It should. In this example,
    I have combined C techniques with C++ classes. Hopefully, we will not see snippets
    of code like this in production. Things will go wrong by a simple typing error
    if you pass a `mage` to the `fight_knight` function or the other way around. Nevertheless,
    it’s possible and is a form of type erasure.
  prefs: []
  type: TYPE_NORMAL
- en: 'An obvious alternative solution in C++ is using polymorphism through inheritance.
    This is the very first solution we saw at the beginning of this chapter. For convenience,
    I’ll reproduce it here again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: The `fight` function can handle `knight` and `mage` objects homogenously. It
    knows nothing of the actual objects whose addresses were passed to it (within
    a `vector`). However, it can be argued that types have not been completely erased.
    Both `knight` and `mage` are `game_unit` and the `fight` function handles anything
    that is a `game_unit`. For another type to be handled by this function, it needs
    to derive from the `game_unit` pure abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: And sometimes that’s not possible. Perhaps we want to treat unrelated types
    in a similar matter (a process called **duck typing**) but we are not able to
    change those types. For instance, we do not own the source code. The solution
    to this problem is true type erasure with templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to see what this pattern looks like, let’s take it step by step
    to understand how the pattern developed, starting with the unrelated `knight`
    and `mage`, and the premise that we cannot modify them. However, we can write
    wrappers around them that would provide a uniform interface to the common functionality
    (behavior):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not need to call the `attack` member function in `game_unit` the same
    as it was in `knight` and `mage`. It can have any name. This choice was purely
    made on the grounds of mimicking the original behavior name. The `fight` function
    takes a collection of pointers to `game_unit`, therefore being able to handle
    both `knight` and `mage` objects homogenously, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: 'The trouble with this solution is that there is a lot of duplicate code. The
    `knight_unit` and `mage_unit` classes are mostly the same. And when other classes
    need to be handled similarly, this duplication increases more. The solution to
    code duplication is using templates. We replace `knight_unit` and `mage_unit`
    with the following class template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one copy of this class in our source code but the compiler will
    instantiate multiple specializations based on its usage. Any type information
    has been erased, with the exception of some type restrictions—the `T` type must
    have a member function called `attack` that takes no arguments. Notice that the
    `fight` function didn’t change at all. The client code needs to be slightly changed
    though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads us to the form of the type erasure pattern by putting the abstract
    base class and wrapper class template within another class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: 'The `game` class contains a collection of `game_unit` objects and has a method
    for adding new wrappers to any game unit (that has an `attack` member function).
    It also has a member function, `fight`, to invoke the common behavior. The client
    code is, this time, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: 'In the type erasure pattern, the abstract base class is called a **concept**
    and the wrapper that inherits from it is called a **model**. If we were to implement
    the type erasure pattern in the established formal manner it would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, `game_unit` was renamed as `unit_concept` and `game_unit_wrapper`
    was renamed as `unit_model`. There is no other change to them apart from the name.
    They are members of a new class called `unit` that stores a pointer to an object
    that implements `unit_concept`; that could be `unit_model<knight>` or `unit_model<mage>`.
    The `unit` class has a template constructor that enables us to create such model
    objects from `knight` and `mage` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also has a public member function, `attack` (again, this can have any name).
    On the other hand, the `fight` function handles `unit` objects and invokes their
    `attack` member function. The client code may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re wondering where this pattern is used in real-world code, there are
    two examples in the standard library itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::function`: This is a general-purpose polymorphic function wrapper that
    enables us to store, copy, and invoke anything that is callable, such as functions,
    lambda expressions, bind expressions, function objects, pointers to member functions,
    and pointers to data members. Here is an example of using `std::function`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::any`: This is a class that represents a container to any value of a type
    that is copy-constructible. An example is used in the following snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Type erasure is an idiom that combines inheritance from object-oriented programming
    with templates to create wrappers that can store any type. In this section, we
    have seen how the pattern looks and how it works, as well as some real-world implementations
    of the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Next in this chapter, we will discuss a technique called tag dispatching.
  prefs: []
  type: TYPE_NORMAL
- en: Tag dispatching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::enable_if` and **SFINAE** and is simple to understand and use. The term
    *tag* describes an empty class that has no members (data), or functions (behavior).
    Such a class is only used to define a parameter (usually the last) of a function
    to decide whether to select it at compile-time, depending on the supplied arguments.
    To better understand this, let’s consider an example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library contains a utility function called `std::advance` that
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in C++17, this is also `constexpr` (more about this, shortly).
    This function increments the given iterator by `n` elements. However, there are
    several categories of iterators (input, output, forward, bidirectional, and random
    access). That means such an operation can be computed differently:'
  prefs: []
  type: TYPE_NORMAL
- en: For input iterators, it could call `operator++` a number of `n` times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For bidirectional iterators, it could call either `operator++` a number of `n`
    times (if `n` is a positive number) or `operator--` a number of `n` times (if
    `n` is a negative number).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For random-access iterators, it can use the `operator+=` to increment it directly
    with `n` elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This implies there can be three different implementations, but it should be
    possible to select at compile-time which one is the best match for the category
    of the iterator it is called for. A solution for this is tag dispatching. And
    the first thing to do is define the tags. As mentioned earlier, tags are empty
    classes. Therefore, tags that correspond to the five iterator types can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly how they are defined in the C++ standard library, in the `std`
    namespace. These tags will be used to define an additional parameter for each
    overload of `std::advance`, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: 'These overloads are defined in a separate (inner) namespace of the `std` namespace
    so that the standard namespace is not polluted with unnecessary definitions. You
    can see here that each of these overloads has three parameters: a reference to
    an iterator, a number of elements to increment (or decrement), and a tag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is provide a definition of an `advance` function that
    is intended for direct use. This function does not have a third parameter but
    calls one of these overloads by determining the category of the iterator it is
    called with. Its implementation may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::iterator_traits` class seen here defines a sort of interface for
    iterator types. For this purpose, it contains several member types, one of them
    being `iterator_category`. This resolves to one of the iterator tags defined earlier,
    such as `std::input_iterator_tag` for input iterators or `std::random_access_iterator_tag`
    for random access iterators. Therefore, based on the category of the supplied
    iterator, it instantiates one of these tag classes, determining the selection
    at compile-time of the appropriate overloaded implementation from the `details`
    namespace. We can invoke the `std::advance` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: The category type of the `std::vector`’s iterators is random access. On the
    other hand, the iterator category type for `std::list` is bidirectional. However,
    we can use a single function that relies on different optimized implementations
    by leveraging the technique of tag dispatching.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to tag dispatching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to C++17, the only alternative to tag dispatching was SFINAE with `enable_if`.
    We have discussed this topic in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*. This is a rather legacy technique that
    has better alternatives in modern C++. These alternatives are **constexpr if**
    and **concepts**. Let’s discuss them one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Using constexpr if
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++11 introduced the concept of `constexpr` values, which are values known at
    compile-time but also `constexpr` functions that are functions that could be evaluated
    at compile-time (if all inputs are compile-time values). In C++14, C++17, and
    C++20, many standard library functions or member functions of standard library
    classes have been changed to be `constexpr`. One of these is `std::advance`, whose
    implementation in C++17 is based on the constexpr if feature, also added in C++17
    (which was discussed in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a possible implementation in C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: Although this implementation still uses the iterator tags that we saw earlier,
    they are no longer used to invoke different overloaded functions but to determine
    the value of some compile-time expressions. The `std::is_base_of` type trait (through
    the `std::is_base_of_v` variable template) is used to determine the type of the
    iterator category at compile-time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation has several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Has a single implementation of the algorithm (in the `std` namespace)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not require multiple overloads with implementation details defined in a
    separate namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client code is unaffected. Therefore, library implementors were able to
    replace the previous version based on tag dispatching with the new version based
    on constexpr if, without affecting any line of code calling `std::advance`.
  prefs: []
  type: TYPE_NORMAL
- en: However, in C++20 there is an even better alternative. Let’s explore it next.
  prefs: []
  type: TYPE_NORMAL
- en: Using concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous chapter was dedicated to constraints and concepts, introduced
    in C++20\. We have seen not only how these features work but also some of the
    concepts that the standard library defines in several headers such as `<concepts>`
    and `<iterator>`. Some of these concepts specify that a type is some iterator
    category. For instance, `std::input_iterator` specifies that a type is an input
    iterator. Similarly, the following concepts are also defined: `std::output_iterator`,
    `std::forward_iterator`, `std::bidirectional_iterator`, `std::random_access_iterator`,
    and `std::contiguous_iterator` (the last one indicating that an iterator is a
    random-access iterator, referring to elements that are stored contiguously in
    memory).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::input_iterator` concept is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: 'Without getting into too many details, it is worth noting that this concept
    is a set of constraints that verify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The iterator is dereferenceable (supports `*i`) and is incrementable (supports
    `++i` and `i++`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterator category is derived from `std::input_iterator_tag`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that the category check is performed within the constraint. Therefore,
    these concepts are still based on the iterator tags, but the technique is significantly
    different than tag dispatching. As a result, in C++20, we could have yet another
    implementation for the `std::advance` algorithm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: There are yet again three different overloads of the advanced function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These overloads are defined in the `std` namespace and do not require a separate
    namespace to hide implementation details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we explicitly wrote several overloads again, this solution is arguably
    easier to read and understand than the one based on constexpr if because the code
    is nicely separated into different units (functions), making it easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Tag dispatching is an important technique for selecting between overloads at
    compile-time. It has its trade-offs but also better alternatives if you are using
    C++17 or C++20\. If your compiler supports concepts, you should prefer this alternative
    for the reasons mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The next pattern we will look at in this chapter is expression templates.
  prefs: []
  type: TYPE_NORMAL
- en: Expression templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Expression templates** are a metaprogramming technique that enables lazy
    evaluation of a computation at compile-time. This helps to avoid inefficient operations
    that occur at runtime. However, this does not come for free, as expression templates
    require more code and can be cumbersome to read or understand. They are often
    used in the implementation of linear algebra libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before seeing how expression templates are implemented, let’s understand what
    is the problem they solve. For this, let’s suppose we want to do some operations
    with matrices, for which we implemented the basic operations, addition, subtraction,
    and multiplication (either of two matrices or of a scalar and a matrix). We can
    have the following expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, `m1`, `m2`, `m3`, and `m4` are matrices; similarly, `r1`,
    `r2`, `r3`, and `r4` are matrices that result from performing the operations on
    the right side. The first operation does not pose any problems: `m1` and `m2`
    are added and the result is assigned to `r1`. However, the second operation is
    different because there are three matrices that are added. That means `m1` and
    `m2` are added first and a temporary is created, which is then added to `m3` and
    the result assigned to `r2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the third operation, there are two temporaries: one for the result of multiplying
    `m1` and `m2` and one for the result of multiplying `m3` and `m4`; these two are
    then added and the result is assigned to `r3`. Finally, the last operation is
    similar to the second, meaning that a temporary object results from the multiplication
    between the scalar `5` and the matrix `m2`, and then this temporary is added to
    `m1` and the result assigned to `r4`.'
  prefs: []
  type: TYPE_NORMAL
- en: The more complex the operation, the more temporaries are generated. This can
    affect performance when the objects are large. Expression templates help to avoid
    this by modeling the computation as a compile-time expression. The entire mathematical
    expression (such as `m1 + 5 * m2`) becomes a single expression template computed
    when the assignment is evaluated and without the need for any temporary object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we will build some examples using vectors not matrices
    because these are simpler data structures, and the point of the exercise is not
    to focus on the representation of data but on the creation of expression templates.
    In the following listing, you can see a minimal implementation of a vector class
    that provides several operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing an instance from an initializer list or from a value representing
    a size (no initializing values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the number of elements in the vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element access with the subscript operator (`[]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks very similar to the `std::vector` standard container, and, in fact,
    it uses this container internally to hold the data. However, this aspect is irrelevant
    to the problem we want to solve. Remember we are using a vector and not a matrix
    because it’s easier to represent in a few lines of code. Having this class, we
    can define the necessary operations: addition and multiplication, both between
    two vectors and between a scalar and a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: 'These implementations are relatively straightforward and should not pose a
    problem to understand at this point. Both the `+` and `*` operators take two vectors
    of potentially different types, such as `vector<int>` and `vector<double>`, and
    return a vector holding elements of a result type. This is determined by the result
    of adding two values of the template types `T` and `U`, using `std::declval`.
    This has been discussed in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*. A similar implementation is available for multiplying
    a scalar and a vector. Having these operators available, we can write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: 'As previously explained, this will create one temporary object while computing
    `v3` and two temporaries while computing `v4`. These are exemplified in the following
    diagrams. The first shows the first computation, `v3 = v1 + a * v2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: A conceptual representation of the first expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: A conceptual representation of the first expression'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second diagram, shown next, presents a conceptual representation of the
    computation of the second expression, `v4 = v1 * v2 + v1 + v2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: A conceptual representation of the second expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: A conceptual representation of the second expression'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid these temporaries, we can rewrite the implementation of the
    `vector` class using the expression templates pattern. This requires several changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining class templates to represent an expression between two objects (such
    as the expression of adding or multiplying two vectors).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the `vector` class and parameterize the container for its internal
    data, which by default would be a `std::vector` as previously but can also be
    an expression template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the implementation of the overloaded `+` and `*` operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how this is done, starting with the vector implementation. Here is
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the operations available in the initial implementation, this
    time we have also defined the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A default constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A conversion constructor from a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A copy constructor from a `vector` containing elements of a potentially different
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A copy-assignment operator from a `vector` containing elements of a potentially
    different type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Member function `data` that provides access to the underlaying container holding
    the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An expression template is a simple class template that stores two operands
    and provides a way to perform the evaluation of the operation. In our case, we
    need to implement expressions for adding two vectors, multiplying two vectors,
    and multiplying a scalar and a vector. Let’s look at the implementation of the
    expression template for adding two vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: This class stores constant references to two vectors (or, in fact, any type
    that overloads the subscript operator and provides a `size` member function).
    The evaluation of the expression occurs in the overloaded subscript operator but
    not for the entire vector; only the elements at the indicated index are added.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this implementation does not handle vectors of different sizes (which
    you can take as an exercise to change). However, it should be easy to understand
    the lazy nature of this approach since the addition operation only occurs when
    invoking the subscript operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The multiplication expression templates for the two operations we need are
    implemented in a similar fashion. The code is shown in the next listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the change is to modify the definition of the overloaded `+`
    and `*` operators, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: Although the code is more complex when implementing this pattern, the client
    code does not need to change. The snippet showed earlier works without any modifications
    but in a lazy manner. The evaluation of each element in the result is triggered
    by the invocation of the subscript operator that occurs in the copy-constructor
    and copy-assignment operator of the vector class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this pattern looks cumbersome to you, there is the alternative of something
    better: the ranges library.'
  prefs: []
  type: TYPE_NORMAL
- en: Using ranges as an alternative to expression templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the major features of C++20 is the ranges library. A *range* is a generalization
    of a container - a class that allows you to iterate over its data (elements).
    A key element of the range library is the views. These are non-owning wrappers
    of other ranges that transform the underlying range through some operation.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, they are lazy-evaluated and the time to construct, copy, or destroy
    them does not depend on the size of the underlying range. The lazy evaluation
    (the fact that transformations are applied to elements at the moment they are
    requested, not when the view is created) is a key feature of the library. However,
    that is exactly what the expression templates are also providing. As a result,
    many uses of the expression templates can be replaced with ranges. Ranges will
    be discussed in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ ranges library is based on the `v1 + a * v2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: There is no need for a custom implementation of a vector class; it just works
    with the `std::vector` container. There is no need to overload any operator also.
    The code should be easy to follow, at least if you have some familiarity with
    the ranges library. First, we create a view that transforms the elements of the
    `v2` vector by multiplying each element with a scalar. Then, a second view is
    created that applies the plus operator on the elements of the `v1` range and the
    view resulting from the previous operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this code cannot be written in C++20 using the standard library,
    because the `zip_with` view has not been included in C++20\. However, this view
    will be available in C++23 under the name `zip_view`. Therefore, in C++23, we
    will be able to write this code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE988]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE989]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE990]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE991]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE992]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE993]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE994]'
  prefs: []
  type: TYPE_PRE
- en: 'To conclude the discussion of the expression templates pattern, you should
    keep in mind the following takeaways: the pattern is designed to provide lazy
    evaluation for costly operations, and it does so at the expense of having to write
    more code (that is also arguably more cumbersome) and increased compile-times
    (since heavy template code will have an impact on that). However, as of C++20,
    a good alternative to this pattern is represented by the ranges library. We will
    learn about this new library in [*Chapter 9*](B18367_09_ePub.xhtml#_idTextAnchor188),
    *The Ranges Library*.'
  prefs: []
  type: TYPE_NORMAL
- en: For the next and last section of this chapter, we will look at type lists.
  prefs: []
  type: TYPE_NORMAL
- en: Typelists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **type list** (also spelled *typelist*) is a compile-time construct that enables
    us to manage a sequence of types. A typelist is somehow similar to a tuple but
    does not store any data. A typelist only carries type information and is used
    exclusively at compile-time for implementing different metaprogramming algorithms,
    type switches, or design patterns such as *Abstract Factory* or *Visitor*.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Although both the *type list* and *typelist* spellings are in use, most of the
    time you will find the term *typelist* in C++ books and articles. Therefore, this
    will be the form we will use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typelists were popularized by Andrei Alexandrescu in his book, *Modern C++
    Design*, published a decade before the release of C++11 (and variadic templates).
    Alexandrescu defined a typelist as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE995]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE996]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE997]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE998]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: 'In his implementation, a typelist is composed of a head—which is a type, and
    a tail—which is another typelist. In order to perform various operations on the
    typelist (which will be discussed shortly) we also need a type to represent the
    end of the typelist. This can be a simple, empty type that Alexandrescu defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: 'Having these two constructs, we can define typelists in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: 'Variadic templates make the implementation of typelists simpler, as shown in
    the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of operations of typelists (such as accessing a type at
    a given index, adding or removing types from the list, and so on) differs significantly
    depending on the selected approach. In this book, we will only consider the variadic
    template version. The advantage of this approach is simplicity at different levels:
    the definition of the typelist is shorter, there is no need for a type to represent
    the end of the list, and defining typelist aliases is also shorter and easier
    to read.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, perhaps many of the problems for which typelists represented the solution
    can be also solved using variadic templates. However, there are still scenarios
    where typelists are required. Here is an example: let’s consider a variadic metafunction
    (a type trait that performs a transformation of types) that does some transformation
    (such as adding the `const` qualifier) to the type template arguments. This metafunction
    defines a member type that represents the input types and one that represents
    the transformed types. If you try to define it as follows, it will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1008]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1009]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1010]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1011]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1012]'
  prefs: []
  type: TYPE_PRE
- en: 'This code produces compiler errors, because the expansion of the parameter
    pack is not possible in this context. This is a topic we discussed in [*Chapter
    3*](B18367_03_ePub.xhtml#_idTextAnchor051), *Variadic Templates*. The solution
    to this is to use a typelist, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1016]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: The change is minimal but produces the expected result. Although this is a good
    example of where typelists are needed, it’s not a typical example of where typelists
    are used. We will look at such an example next.
  prefs: []
  type: TYPE_NORMAL
- en: Using typelists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s worth exploring a more complex example before we look at how to implement
    operations on typelists. This should give you an understanding of the possible
    usage of typelists, although you can always search for more online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the example of the game units. For simplicity, we’ll only consider
    the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: 'A game unit has two data members representing indices (or levels) for attacking
    and defending. We want to operate changes on these members with the help of some
    functors. Two such functions are shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1032]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1033]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1041]'
  prefs: []
  type: TYPE_PRE
- en: 'The first increases the defense index by 20%, while the second increases the
    attack index by two units. Although this is a small example meant to demonstrate
    the use case, you can imagine a larger variety of functors like this that could
    be applied in some well-defined combinations. In our example, however, we want
    to apply these two functors on a `game_unit` object. We’d like to have a function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1042]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1043]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1044]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1045]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1046]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1047]'
  prefs: []
  type: TYPE_PRE
- en: 'This `upgrade_unit` function takes a `game_unit` object and applies the `upgrade_defense`
    and `upgrade_attack` functors to it. For this, it uses another helper functor
    called `apply_functors`. This is a class template that has a single template argument.
    This template argument is a typelist. A possible implementation for the `apply_functors`
    functor is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1048]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1049]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1050]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1051]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1052]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1053]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1054]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1055]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1056]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1057]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1058]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1059]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1060]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1061]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1062]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1063]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1064]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1065]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1066]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1067]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1068]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1069]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1070]'
  prefs: []
  type: TYPE_PRE
- en: 'This class template has an overloaded call operator and two private helper
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply`, which applies the functor from the `I` index of the typelist to a
    `game_unit` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply_all`, which applies all the functors in the typelist to a `game_unit`
    object by using the `apply` function in a pack expansion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the `upgrade_unit` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1071]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1072]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1073]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1074]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1075]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1076]'
  prefs: []
  type: TYPE_PRE
- en: If you paid attention to the implementation of the `apply_functors` class template,
    you will have noticed the use of the `at_t` alias template and the `length_v`
    variable template, which we have not defined yet. We will look at these two and
    more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing operations on typelists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typelist is a type that only carries valuable information at compile-time.
    A typelist acts as a container for other types. When you work with typelists,
    you need to perform various operations, such as counting the types in the list,
    accessing a type at a given index, adding a type at the beginning or the end of
    the list, or the reverse operation, removing a type from the beginning or the
    end of the list, and so on. If you think about it, these are typical operations
    you’d use with a container such as a vector. Therefore, in this section, we’ll
    discuss how to implement the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size`: Determines the size of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`front`: Retrieves the first type in the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`back`: Retrieves the last type in the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`at`: Retrieves the type at the specified index in the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push_back`: Adds a new type to the end of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push_front`: Adds a new type to the beginning of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop_back`: Removes the type at the end of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop_front`: Removes the type at the beginning of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typelist is a compile-time construct. It is an immutable entity. Therefore,
    the operations that add or remove a type do not modify a typelist but create a
    new one. We’ll see that shortly. But first, let’s start with the simplest operation,
    which is retrieving the size of a typelist.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid naming confusion with the `size_t` type, we’ll call this operation
    `lenght_t`, and not `size_t`. We can define this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1077]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1078]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1079]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1080]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1081]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1082]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1083]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1084]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1085]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1086]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1087]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1088]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1089]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1090]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1091]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1092]'
  prefs: []
  type: TYPE_PRE
- en: In the `detail` namespace, we have a class template called `length`. There is
    a primary template (without a definition) and a specialization for a typelist.
    This specialization defines a member type called `type` that is a `std::integral_constant`,
    with a value of the type `std::size_t` representing the number of arguments in
    the parameter pack `Ts`. Furthermore, we have an alias template, `length_h`, that
    is an alias for the member called `type` of the `length` class template. Finally,
    we have a variable template called `length_v` that is initialized from the value
    of the `std::integral_constant` member, which is also called `value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify the correctness of this implementation with the help of some
    `static_assert` statements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1093]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1094]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1095]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1096]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1097]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach used here will be used for defining all the other operations.
    Let’s look next at accessing the front type in the list. This is shown in the
    next listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1098]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1099]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1116]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `detail` namespace, we have a class template called `front_type`. Again,
    we declared a primary template but without a definition. However, we have two
    specializations: one for a typelist that contains at least one type and one for
    an empty typelist. In the former case, the `type` member is aliasing the first
    type in the typelist. In the latter case, there is no type so the `type` member
    is aliasing a type called `empty_type`. This is an empty class whose only role
    is to act as the return type for operations where no type is to be returned. We
    can verify the implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1123]'
  prefs: []
  type: TYPE_PRE
- en: 'If you expect the implementation of the operation for accessing the back type
    to be similar, you will not be disappointed. Here is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1147]'
  prefs: []
  type: TYPE_PRE
- en: 'The only significant difference with this implementation is that there are
    three specializations of the `back_type` class template and there is recursion
    involved. The three specializations are for an empty typelist, a typelist with
    a single type, and a typelist with two or more types. The last one (which is actually
    the first in the previous listing) is using template recursion in the definition
    of its `type` member. We have seen how this works in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*. To ensure we implemented the operation the right
    way we can do some validation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1154]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from accessing the first and last type in a typelist, we are also interested
    in accessing a type at any given index. However, the implementation of this operation
    is less trivial. Let’s see it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1177]'
  prefs: []
  type: TYPE_PRE
- en: 'The `at_t` alias template has two template arguments: an index and a typelist.
    The `at_t` template is an alias for the member type of the `at_type` class template
    from the `detail` namespace. The primary template has three template parameters:
    an index representing the position of the type to retrieve (`I`), another index
    representing the current position in the iteration of the types in the list (`N`),
    and a typelist (`TL`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two specializations of this primary template: one for a typelist
    that contains at least one type and one for an empty typelist. In the latter case,
    the member `type` is aliasing the `empty_type` type. In the former case, the member
    `type` is defined with the help of the `std::conditional_t` metafunction. This
    defines its member `type` as the first type (`T`) when `I == N`, or as the second
    type (`typename at_type<I, N + 1, TL<Ts...>>::type`) when this condition is false.
    Here, again, we employ template recursion, incrementing the value of the second
    index with each iteration. The following `static_assert` statements validate the
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1196]'
  prefs: []
  type: TYPE_PRE
- en: 'The next category of operations to implement is adding a type to the beginning
    and the end of a typelist. We call these `push_back_t` and `push_front_t` and
    their definitions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1221]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on what we have seen so far with the previous operations, these should
    be straightforward to understand. The opposite operations, when we remove the
    first or last type from a typelist, are more complex though. The first one, `pop_front_t`,
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1240]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the primary template, `pop_front_type`, and two specializations: the
    first for a typelist with at least one type, and the second for an empty typelist.
    The latter defines the member `type` as an empty list; the former defines the
    member `type` as a typelist with the tail composed from the typelist argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last operation, removing the last type in a typelist, called `pop_back_t`,
    is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1276]'
  prefs: []
  type: TYPE_PRE
- en: For implementing this operation, we need to start with a typelist and recursively
    construct another typelist, element by element, until we get to the last type
    in the input typelist, which should be omitted. For this, we use a counter that
    tells us how many times we iterated the typelist.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is initiated with the size of the typelist minus one and we need to stop
    when we reach zero. For this reason, the `pop_back_type` class template has four
    specializations, one for the general case when we are at some iteration in the
    typelist, two for the case when the counter reached zero, and one for the case
    when the counter reached the value minus one. This is the case when the initial
    typelist was empty (therefore, `length_t<TL> - 1` would evaluate to -1). Here
    are some asserts that show how to use `pop_back_t` and validate its correctness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1286]'
  prefs: []
  type: TYPE_PRE
- en: With these defined, we have provided a series of operations that are necessary
    for working with typelists. The `length_t` and `at_t` operations were used in
    the example shown earlier with the execution of functors on `game_unit` objects.
    Hopefully, this section provided a helpful introduction to typelists and enabled
    you to understand not only how they are implemented but also how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was dedicated to learning various metaprogramming techniques. We
    started by understanding the differences between dynamic and static polymorphism
    and then looked at the curiously recurring template pattern for implementing the
    latter.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins was another pattern that has a similar purpose as CRTP—adding functionality
    to classes, but unlike CRTP, without modifying them. The third technique we learned
    about was type erasure, which allows similar types that are unrelated to be treated
    generically. In the second part, we learned about tag dispatching – which allow
    us to select between overloads at compile time, and expression templates – which
    enable lazy evaluation of a computation at compile-time to avoid inefficient operations
    that occur at runtime. Lastly, we explored typelists and learned how they are
    used and how we can implement operations with them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the core pillars of the standard template
    library, containers, iterators, and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the typical problems that can be solved by CRTP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are mixins and what is their purpose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is type erasure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is tag dispatching and what are its alternatives?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are expression templates and where are they used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* – Erich Gamma,
    Richard Helm, Ralph Johnson, John Vlissides, p. 163, Addison-Wesley'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Modern C++ Design: Generic Programming and Design Patterns Applied* – Andrei
    Alexandrescu, Addison-Wesley Professional'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mixin-Based Programming in C++* – Yannis Smaragdakis, Don Batory, [https://yanniss.github.io/practical-fmtd.pdf](https://yanniss.github.io/practical-fmtd.pdf%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Curiously Recurring Template Patterns* – James Coplien, [http://sites.google.com/a/gertrudandcope.com/info/Publications/InheritedTemplate.pdf](http://sites.google.com/a/gertrudandcope.com/info/Publications/InheritedTemplate.pdf%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mixin Classes: The Yang of the CRTP* – Jonathan Boccara, [https://www.fluentcpp.com/2017/12/12/mixin-classes-yang-crtp/](https://www.fluentcpp.com/2017/12/12/mixin-classes-yang-crtp/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What the Curiously Recurring Template Pattern can bring to your code* – Jonathan
    Boccara, [https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/](https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Combining Static and Dynamic Polymorphism with C++ Mixin classes* – Michael
    Afanasiev, [https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html](https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why C++ is not just an Object-Oriented Programming Language* – Bjarne Stroustrup,
    [https://www.stroustrup.com/oopsla.pdf](https://www.stroustrup.com/oopsla.pdf%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enable_shared_from_this` *- overview, examples, and internals* – Hitesh Kumar,
    [https://www.nextptr.com/tutorial/ta1414193955/enable_shared_from_this-overview-examples-and-internals](https://www.nextptr.com/tutorial/ta1414193955/enable_shared_from_this-overview-examples-and-internals%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tag dispatch versus concept overloading* – Arthur O’Dwyer, [https://quuxplusone.github.io/blog/2021/06/07/tag-dispatch-and-concept-overloading/](https://quuxplusone.github.io/blog/2021/06/07/tag-dispatch-and-concept-overloading/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++ Expression Templates: An Introduction to the Principles of Expression
    Templates* – Klaus Kreft and Angelika Langer, [http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm](http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*We don’t need no stinking expression templates*, [https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/](https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generic Programming: Typelists and Applications* – Andrei Alexandrescu, [https://www.drdobbs.com/generic-programmingtypelists-and-applica/184403813](https://www.drdobbs.com/generic-programmingtypelists-and-applica/184403813%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Of type lists and type switches* – Bastian Rieck, [https://bastian.rieck.me/blog/posts/2015/type_lists_and_switches/](https://bastian.rieck.me/blog/posts/2015/type_lists_and_switches/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
