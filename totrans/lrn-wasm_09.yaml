- en: Integrating with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modern web leans heavily on Node.js for both development and server-side
    management. With the advent of increasingly complex browser applications that
    perform computationally expensive operations, performance increases can be incredibly
    beneficial. In this chapter, we're going to describe the various ways you can
    integrate WebAssembly with Node.js through the use of various examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal for this chapter is to understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of integrating WebAssembly with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to interact with the Node.js WebAssembly API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to utilize Wasm modules in a project that uses Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write unit tests for WebAssembly modules using `npm` libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Node.js?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting Up a Development
    Environment*, Node.js was described as an asynchronous event-driven JavaScript
    runtime, which is the definition taken from the official website. What Node.js
    represents, however, is a profound shift in the way we build and manage web applications.
    In this section, we will discuss the relationship between WebAssembly and Node.js,
    and why the two technologies complement each other so well.
  prefs: []
  type: TYPE_NORMAL
- en: Seamless integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js runs on Google's V8 JavaScript engine, which powers Google Chrome. Since
    V8's WebAssembly implementation adheres to the *Core Specification*, you can interact
    with a WebAssembly module using the same API as the browser. Instead of performing
    a fetch call for a `.wasm` file, you can use Node.js's `fs` module to read the
    contents into a buffer, then call `instantiate()` on the result.
  prefs: []
  type: TYPE_NORMAL
- en: Complementary technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has limitations on the server side as well. Expensive computation
    or working with large numbers can be optimized with WebAssembly's superior performance.
    As a scripting language, JavaScript excels at automating simple tasks. You could
    write a script to compile C/C++ to a Wasm file, copy it to a `build` folder, and
    see the changes reflected in the browser if you're using a tool like `Browsersync`.
  prefs: []
  type: TYPE_NORMAL
- en: Development with npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js has an extensive ecosystem of tools and libraries in the form of `npm`.
    Sven Sauleau and other members of the open source community have created `webassemblyjs`,
    an extensive suite of tooling for WebAssembly built with Node.js. The `webassemblyjs`
    site at [https://webassembly.js.org](https://webassembly.js.org) includes the
    tagline *Toolchain for WebAssembly*. There are currently over 20 `npm` packages
    to perform various tasks and aid in development, such as an ESLint plugin, an
    AST validator, and a formatter. AssemblyScript, a TypeScript to WebAssembly compiler,
    allows you to write performant code that compiles to a Wasm module without having
    to learn C or C++. The Node.js community is clearly vested in WebAssembly's success.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side WebAssembly with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js can be used in several ways to add value to a WebAssembly project. In
    this section, we're going to walk through an example Node.js application that
    integrates WebAssembly. The application uses Express with some simple routes to
    call functions from a compiled Wasm module.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project reuses some of the code from the application we built in [Chapter
    7](79019325-2d3e-452c-b680-ac90522aa4bf.xhtml), *Creating an Application from
    Scratch* (*Cook the Books*) to demonstrate how Node.js can be used with WebAssembly.
    The code for this section is located in the `/chapter-09-node/server-example`
    folder in the `learn-webassembly` repository. We''re going to review portions
    of the application directly applicable to Node.js. The following structure represents
    the file structure for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With regard to dependencies, the application uses the `express` and `body-parser`
    libraries to set up routes and parse JSON from the body of requests. For data
    management, it uses `lowdb`, a library that provides methods for reading and updating
    a JSON file. The JSON file is located in `/src/assets/db.json` and contains data
    that was slightly modified from the Cook the Books dataset. We're using `nodemon`
    to watch for changes in the `/src` folder and reload the application automatically.
    We're using `rimraf` to manage file deletion. The library is included as a dependency
    in the event that you didn't install it globally in [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting
    Up a Development Environment*. Finally, the `node-fetch` library allows us to
    use the fetch API to make HTTP requests when testing the application.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify functionality in both the JavaScript and C files, the `rawAmount`
    and `cookedAmount` fields were replaced with a single `amount` field, and the
    `category` field is now `categoryId`, which maps to a `categories` array in `db.json`.
  prefs: []
  type: TYPE_NORMAL
- en: Express configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application is loaded in `/src/index.js`. The contents of this file are
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This file sets up a new Express app, adds the `body-parser` middleware, loads
    the mock database and Wasm instance, and assigns routes. Let's move on to discussing
    the difference between instantiating a Wasm module in the browser and Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating a Wasm module with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Wasm files are instantiated in `/src/load-assets.js`. We''re using the
    `memory.wasm` file from Cook the Books, but the `/assets/main.wasm` file is compiled
    from a slightly different version of `main.c`, which is located in the `/lib`
    folder. The `loadWasm()` function performs the same operation as the Wasm initialization
    code from Cook the Books, but the method for passing in the `bufferSource` to
    `WebAssembly.instantiate()` is different. Let''s examine this further by reviewing
    a portion of the code in the `loadWasm()` function of the `load-assets.js file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To elaborate on the differences, here''s some code that instantiates a module
    using `fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When using Node.js, the fetch call is replaced by the `fs.readFileSync()` function
    and the `arrayBuffer()` function is no longer required because `fs.readFileSync()`
    returns a buffer that can be passed directly into the `instantiate()` function.
    Once the Wasm module is instantiated, we can start interacting with the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mock database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `load-assets.js` file also contains a method for creating a mock database
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadDb()` function loads the contents of `/assets/db.json` into an instance
    of `lowdb`. The default function exported from `load-assets.js` calls the `loadWasm()`
    and `loadDb()` functions and returns an object containing the mock database and
    Wasm instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Going forward, I'll use the term database to refer to the `lowdb` instance that
    accesses the `db.json` file. Now that the assets are loaded, let's review how
    the application interacts with them.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the WebAssembly module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interaction with the database and Wasm instance takes place across two files
    in the `/src` folder: `Transaction.js` and `assign-routes.js`. In our example
    application, all communication with the API is performed via HTTP requests. Sending
    a request to a specific endpoint will trigger some interaction with the database/Wasm
    instance on the server. Let''s start by reviewing `Transaction.js`, which interacts
    directly with the database and Wasm instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping interaction in Transaction.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as with Cook the Books, there''s a class that wraps the Wasm interaction
    code and provides a clean interface. The contents of `Transaction.js` are very
    similar to the contents of `/src/store/WasmTransactions.js` from Cook the Books.
    Most of the changes accommodate for the `categoryId` being present in a transaction
    record and a single `amount` field (no more raw and cooked amounts). Additional
    functionality was added to interact with the database. For example, here''s a
    function that edits an existing transaction, both in the database and the linked
    list from the Wasm instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `edit()` function updates the database record that corresponds to the `transactionId`
    argument with the values in the `contents` argument. `this.db` is the database
    instance that was created in the `load-assets.js` file. Since the `categoryId`
    field is available on the `updatedTransaction` record, we can pass it directly
    to `this.wasmInstance._editTransaction()`. It gets passed into the constructor
    when a new instance of `Transaction` is created.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction operations in assign-routes.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `assign-routes.js` file defines routes and adds them to the `express` instance
    (`app`) created in `index.js`. In Express, routes can be defined directly on `app`
    (for example, `app.get()`), or through the use of a `Router`. In this case, a
    `Router` was used to add multiple methods to the same route path. The following
    code, taken from the `assign-routes.js` file, creates a `Router` instance and
    adds two routes: a `GET` route that returns all transactions, and a `POST` route
    that creates a new transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `app.use()` function at the end of the snippet specifies that all routes
    defined on the `transactionsRouter` instance are prefixed with `/api/transactions`.
    If you were running the application locally on port `3000`, you could navigate
    to `http://localhost:3000/api/transactions` in your browser and see an array of
    all the transactions in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the body of the `get()` and `post()` functions, interactions
    with any transaction records are being delegated to the `Transaction` instance
    created in line `3`. That completes our review of pertinent sections of the code
    base. Each of the files contain comments describing the file's functionality and
    purpose, so you may want to review those before moving on to the next section.
    In the next section, we'll build, run, and interact with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we build and test out the project, you''ll need to install the `npm`
    dependencies. Open a terminal within the `/server-example` folder and run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once that's complete, you're ready to move on to the build step.
  prefs: []
  type: TYPE_NORMAL
- en: Building the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the case of this application, building refers to compiling the `lib/main.c`
    to a `.wasm` file using the `emcc` command. Since this is a Node.js project, we
    can use the `scripts` key in our `package.json` file to define Tasks. You can
    still use VS Code''s Tasks feature because it automatically detects the scripts
    from your `package.json` file and presents them in the list of tasks when you
    select Tasks | Run Task... from the menu. The following code contains the contents
    of the `scripts` section in this project''s `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `build` script was split across multiple lines for display purposes, so
    you''d have to combine those lines for valid JSON. The `prebuild` script removes
    the existing Wasm file, and the `build` script runs the `emcc` command with the
    required flags to compile `lib/main.c` and output the result to `src/assets/main.wasm`.
    To run the script, open a terminal within the `/server-example` folder and run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the `/src/assets` folder contains a file named `main.wasm`, the build completed
    successfully. If an error has occurred, the terminal should provide a description
    of the error, as well as a stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: You can create `npm` scripts that run before or after a specific script by creating
    an entry with the same name and prefixing it with `pre` or `post`. For example,
    if you wanted to run a script after the `build` script has completed, you can
    create a script named `"postbuild"` and specify the command you want to run.
  prefs: []
  type: TYPE_NORMAL
- en: Starting and testing out the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re making changes to the application or trying to fix a bug, you could
    use the `watch` script to watch for any changes to the contents of the `/src`
    folder and automatically restart the application if a change was made. Since we''re
    just running and testing out the application, we can use the `start` command instead.
    In the terminal, ensure you''re in the `/server-example` folder and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a message that says `Server is running on port 3000`. You''re
    now able to send HTTP requests to the server. To test the application, open a
    new terminal instance within the `server-example` directory and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This should log out the response body of the `GET` call to the `/api/transactions`
    endpoint. The `requests.js` file contains functionality that allows you to make
    requests to all of the available routes. The `getFetchActionForId()` function
    returns an object with an endpoint and options value, which corresponds to a route
    in the `assign-routes.js` file. The `actionId` is an arbitrary number to simplify
    testing and reduce the amount of typing for running commands. For example, you
    could run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It will log out the sum of all transactions for the *Computer & Internet* category.
    You can pass an additional argument to the `node` command if you want the total
    for a different category. To get the sum of all transactions in the *Insurance*
    category, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Try going through each of the requests (there are eight in total). If you make
    a request that adds, removes, or edits a transaction, you should see the changes
    in the `/src/assets/db.json` file. That's it for the Node.js example project.
    In the next section, we'll utilize Webpack to load and interact with a Wasm module.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side WebAssembly with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications continue to grow in complexity and size. Simply serving up
    a few handwritten HTML, CSS, and JavaScript files is not feasible for large applications.
    To manage this complexity, web developers use bundlers to allow for modularization,
    ensure browser compatibility, and reduce the size of JavaScript files. In this
    section, we're going to be using a popular bundler, Webpack, to utilize Wasm without
    using `emcc`.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example Webpack application extends the functionality of the C code we
    wrote in the *Compiling C without the glue code* section of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*. Instead of showing a blue rectangle bouncing
    around a red background, we''ll show an alien in a spaceship bouncing around the
    Horsehead Nebula. The collision detection functionality has been modified to accommodate
    for bouncing within a rectangle, so the movement of the spaceship will be random.
    The code for this section is located in the `/chapter-09-node/webpack-example`
    folder in the `learn-webassembly` repository. The file structure for the project
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We'll review the Webpack configuration file in a later section. For now, let's
    take a moment to discuss Webpack in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: What is Webpack?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaScript ecosystem has been rapidly evolving over the past several years,
    resulting in new frameworks and libraries popping up constantly. Bundlers came
    about as a way to enable developers to split a JavaScript application into several
    files without having to worry about managing global namespaces, script loading
    order, or an incredibly long list of `<script>` tags in the HTML file. A bundler
    combines all of the files into one and resolves any naming collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack is, at the time of writing, one of the most popular bundlers for frontend
    development. It does much more than combine JavaScript files, however. It also
    performs complex tasks such as code-splitting and tree shaking (dead-code elimination).
    Webpack was designed with a plugin architecture, which resulted in a massive amount
    of community-developed plugins. A search for Webpack on `npm` currently returns
    over 12,000 packages! This exhaustive list of plugins, along with its powerful
    built-in feature set, makes Webpack a full-fledged build tool.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin the application walk-through, open up a terminal within the
    `/webpack-example` folder and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Dependencies overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application uses Version 4 of Webpack (the most recent version as of writing
    this) to build our application. We need to use Webpack plugins to load the various
    file types used in the application and Babel to utilize newer JavaScript features.
    The following snippet lists the `devDependencies` we''re using in the project
    (taken from `package.json`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I specified exact versions for some of the libraries to ensure the application
    builds and runs successfully. Any libraries with a name ending in `-loader` or
    `-plugin` are used in conjunction with Webpack. The `cpp-wasm-loader` library
    allows us to import a C or C++ file directly, without having to compile it to
    Wasm first. Webpack 4 has built-in support for importing `.wasm` files, but you
    can't specify an `importObj` argument, which is required for modules generated
    with Emscripten.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring loaders and plugins in webpack.config.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re using several different file types in addition to JavaScript for the
    application: CSS, SVG, HTML, and so on. Installing the `-loader` dependencies
    is only part of the equation—you also need to tell Webpack how to load them. You
    also need to specify configuration details for any plugins you have installed.
    You can specify the loading and configuration details in a `webpack.config.js`
    file in the root folder of your project. The following snippet contains the contents
    of `/webpack-example/webpack.config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `rules` section tells Webpack which loader to use for a file extension.
    The fourth item in the array handles C/C++ files (note the `test` field value
    containing `c|cpp`). The `HtmlWebpackPlugin` takes the contents of `/src/index.html`,
    adds any required `<script>` tags, minifies it, and creates an `index.html` in
    the `build` folder, which defaults to `/dist`. The `MiniCssExtractPlugin` copies
    any imported CSS into a single CSS file in the `/dist` folder. We'll review how
    to build the project in a later section, so let's move on to the application code,
    starting with the C file.
  prefs: []
  type: TYPE_NORMAL
- en: The C code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we''re allowed to import C and C++ files directly, the C file is located
    within the `/src` folder. This file, `main.c`, contains logic to manage collision
    detection and move the spaceship around the `<canvas>`. The code is based on the
    `without-glue.c` file we created in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*. We''re not going to review the entire file,
    only the sections that have changed and merit explanation. Let''s begin with the
    definitions and declarations section, which includes a new `struct`: `Bounds`.'
  prefs: []
  type: TYPE_NORMAL
- en: Definitions and declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code containing the definitions and declarations sections is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: New properties were added to the existing `Rect` definition to accommodate for
    flexible sizing and tracking movement in the *x* and *y* directions. We defined
    a new `struct`, `Bounds`, and removed the existing `#define` statements because
    the `<canvas>` element is no longer a square with static dimensions. A new instance
    of both elements is declared when the module loads. The dimensional properties
    of these instances are assigned in the `start()` function, which we'll cover next.
  prefs: []
  type: TYPE_NORMAL
- en: The start() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The updated `start()` function, which acts as the entry point to the module,
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Any functions that are called from JavaScript are prepended with the `EMSCRIPTEN_KEEPALIVE`
    statement. We're now passing the width and height of both the `Bounds` and `Rect`
    elements as arguments to the `start()` function, which we assign to the local
    `bounds` and `rect` variables. This allows us to easily change the dimensions
    of either one without having to make any changes to the collision detection logic.
    In the context of this application, the `rect` represents the rectangle in which
    the spaceship image resides. We set the default horizontal and vertical direction
    for the `rect` so the image initially moves to the right and down. Let's move
    on to the `rect` movement/collision detection code.
  prefs: []
  type: TYPE_NORMAL
- en: The updateRectLocation() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code related to collision detection and the `Rect` movement is handled
    in the `updateRectLocation()` function, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The primary difference between this code and the code we wrote in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*, is the collision detection logic. Instead of
    simply tracking the location of the `rect` instance horizontally and changing
    direction when it hits the right boundary, the function now tracks the horizontal
    and vertical directions and manages each independently. Although this isn't the
    most performant algorithm, it does achieve the goal of ensuring the spaceship
    changes direction when it encounters the edge of the `<canvas>`.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only production dependency we're using for the application is Vue. Although
    the application consists of a single component, Vue makes managing data, functions,
    and the component life-cycle much simpler than trying to do it manually. The `index.js`
    file contains the Vue initialization code, while the rendering and application
    logic is in `/src/App.js`. This file has a lot of moving parts, so we're going
    to review the code in chunks, as we did in the previous section. Let's start with
    the `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: The import statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code demonstrates the Webpack loaders in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The loaders we configured in the `webpack.config.js` file understand how to
    handle CSS, C, and image files. Now that we have the required resources available,
    we can start defining our component state.
  prefs: []
  type: TYPE_NORMAL
- en: Component state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code initializes the local state in the `data()` function for
    our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Although the `bounds` and `rect` properties never change, we defined them in
    the local state to keep all the data used by the component in a single location.
    The `speed` property dictates how quickly the spaceship moves across the `<canvas>`
    and has a range of `1` to `10`. The `instance` property is initialized to null,
    but will be used to access the compiled Wasm module's exported functions. Let's
    move on to the Wasm initialization code that compiles the Wasm file and populates
    the `<canvas>`.
  prefs: []
  type: TYPE_NORMAL
- en: Wasm initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to compile the Wasm file and populate the `<canvas>` element is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There are additional functions defined in the `methods` key of the component,
    but for now we'll focus on the code that compiles the imported C file to Wasm.
    After `Image` instances are created for the spaceship and background images, the
    `main.c` file (imported as `.wasm`) is compiled to a Wasm module and the resulting
    `exports` is assigned to `this.instance`. Once these operations complete, the
    `start()` function can be called from the exported Wasm module. Since the `initializeWasm()`
    function calls the `<canvas>` element's `getContext()` function, the component
    needs to be mounted before this function can be called. Let's review the rest
    of the `methods` definitions and the `mounted()` event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Component mounting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The remaining `methods` definitions and `mounted()` event handler function
    are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once the Wasm module is compiled, the `start()` function is accessible on `this.instance`.
    The `bounds` and `rect` dimensions are passed into the `start()` function, and
    then the `loopRectFunction()` is called to start moving the spaceship. The `onActionClick()`
    event handler function pauses or resumes the movement of the spaceship based on
    whether or not it's currently in motion.
  prefs: []
  type: TYPE_NORMAL
- en: The `loopRectMotion()` functions in the same way as the example code from [Chapter
    5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading a WebAssembly
    Module*, except the speed is now adjustable. The `15 - this.speed` calculation,
    which dictates the timeout length, may look a little strange. Since the movement
    speed of the image is based on the amount of time that elapses between function
    calls, increasing this number would actually slow down the spaceship. Consequently,
    `this.speed` is subtracted from `15`, which was chosen because it's slightly greater
    than `10` but won't turn the spaceship into a blur if `this.speed` is increased
    to the maximum. That's it for the component logic; let's move on to the rendering
    section of the code where the `template` is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Component rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The contents of the `template` property, which dictates what to render, are
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since we're using Vue, we can bind the attributes and event handlers of HTML
    elements to properties and methods defined in our component. In addition to a
    PAUSE/RESUME button, there's a range `<input>` that allows you to change the speed.
    By sliding it to the left or right, you're able to slow down or speed up the spaceship
    and see the changes reflected immediately. That concludes our review; let's see
    how Webpack can be used to build or run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `cpp-wasm-loader` library eliminates the need for a build step to
    generate a Wasm module, but we still need to bundle up our application for distribution.
    In the `scripts` section of `package.json`, there''s a `build` and `start` script.
    Running the `build` script executes the `webpack` command that generates the bundle.
    To ensure this is working correctly, open a terminal instance in the `/webpack-example`
    folder and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It may take a minute to build the project the first time you run it. This can
    be attributed to the Wasm compilation step. However, subsequent builds should
    be much faster. If the build was successful, you should see a newly created `/dist`
    folder with these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Testing the build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try out the build to ensure everything is working correctly. Run the
    following command in your terminal instance to start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you navigate to `http://127.0.0.1:8080/index.html` in your browser, you
    should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d3c1c1f-1f92-41e2-a5e6-27673bc221d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Webpack application running in the browser
  prefs: []
  type: TYPE_NORMAL
- en: The spaceship image (taken from [https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg](https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg))
    bounces around within the bounds of the Horsehead Nebula background image (taken
    from [https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg](https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg)).
    When the PAUSE button is pressed, the button's caption changes to RESUME and the
    ship stops moving. Pressing the button again will change the caption back to PAUSE and
    the ship will start moving again. Adjusting the SPEED slider increases or decreases
    the speed of the ship.
  prefs: []
  type: TYPE_NORMAL
- en: Running the start script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application has the `webpack-dev-server` library installed, which operates
    like `Browsersync.` The library uses LiveReloading, which automatically updates
    the application when you make any changes to the files in `/src`. Since we''re
    using a Webpack loader for C and C++ files, the automatic update event will trigger
    if you change the C file as well. Run the following the command to start the application
    and watch for changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A browser window should open automatically when the build completes, and then
    direct you to the running application. To see the live-reloading feature in action,
    try setting the value of the `isRunning` variable in the `setIsRunning()` function
    in `main.c` to false instead of `newIsRunning`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The spaceship should be stuck in the upper-left corner. If you change it back,
    the spaceship starts moving again. In the next section, we will write unit tests
    in JavaScript to test WebAssembly modules.
  prefs: []
  type: TYPE_NORMAL
- en: Testing WebAssembly modules with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well-tested code prevents regression bugs, simplifies refactoring, and alleviates
    some of the frustrations that go along with adding new features. Once you've compiled
    a Wasm module, you should write tests to ensure it's functioning as expected,
    even if you've written tests for C, C++, or Rust code you compiled it from. In
    this section, we'll use **Jest**, a JavaScript testing framework, to test the
    functions in a compiled Wasm module.
  prefs: []
  type: TYPE_NORMAL
- en: The code being tested
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the code used in this example is located in the `/chapter-09-node/testing-example`
    folder. The code and corresponding tests are very simple and are not representative
    of real-world applications, but they''re intended to demonstrate how to use Jest
    for testing. The following code represents the file structure of the `/testing-example`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the C file that we''ll test, `/src/main.c`, is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'All three functions in the file are performing simple mathematical operations.
    The `package.json` file includes a script to compile the C file to a Wasm file
    for testing. Run the following command to compile the C file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There should be a file named `main.wasm` in the `/src` directory. Let's move
    on to describing the testing configuration step.
  prefs: []
  type: TYPE_NORMAL
- en: Testing configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only dependency we''ll use for this example is Jest, a JavaScript testing
    framework built by Facebook. Jest is an excellent choice for testing because it
    includes most of the features you''ll need out of the box, such as coverage, assertions,
    and mocking. In most cases, you can use it with zero configuration, depending
    on the complexity of your application. If you''re interested in learning more,
    check out Jest''s website at [https://jestjs.io](https://jestjs.io). Open a terminal
    instance in the `/chapter-09-node/testing-example` folder and run the following
    command to install Jest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `package.json` file, there are three entries in the `scripts` section:
    `build`, `pretest`, and `test`. The `build` script executes the `emcc` command
    with the required flags to compile `/src/main.c` to `/src/main.wasm`. The `test` script
    executes the `jest` command with the `--verbose flag`, which provides additional
    details for each of the test suites. The `pretest` script simply runs the `build` script
    to ensure `/src/main.wasm` exists prior to running any tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Tests file review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s walk through the test file, located at `/src/__tests__/main.test.js`,
    and review the purpose of each section of code. The first section of the test
    file instantiates the `main.wasm` file and assigns the result to the local `wasmInstance`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Jest provides life-cycle methods to perform any setup or teardown actions prior
    to running tests. You can specify functions to run before or after all of the
    tests (`beforeAll()`/`afterAll()`), or before or after each test (`beforeEach()`/`afterEach()`).
    We need a compiled instance of the Wasm module from which we can call exported
    functions, so we put the instantiation code in the `beforeAll()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re wrapping the entire test suite in a `describe()` block for the file.
    Jest uses a `describe()` function to encapsulate suites of related tests and `test()`
    or `it()` to represent a single test. Here''s a simple example of this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section of code contains all the test suites and tests for each exported
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first `describe()` block, for the `_addTwoNumbers()` function, has two `test()`
    instances to ensure that the function returns the sum of the two numbers passed
    in as arguments. The next two `describe()` blocks, for the `_divideTwoNumbers()`
    and `_findFactorial()` functions, use Jest's `.each` feature, which allows you
    to run the same test with different data. The `expect()` function allows you to
    make assertions on the value passed in as an argument. The `.toBeCloseTo()` assertion
    in the last `_divideTwoNumbers()` test checks whether the result is within two
    decimal places of `3.77`. The rest use the `.toEqual()` assertion to check for
    equality.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests with Jest is relatively simple, and running them is even easier!
    Let's try running our tests and reviewing some of the CLI flags that Jest provides.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the tests, open a terminal instance in the `/chapter-09-node/testing-example`
    folder and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a large number of tests, you could remove the `--verbose` flag
    from the `test` script in `package.json` and only pass the flag to the `npm test`
    command if needed. There are several other CLI flags you can pass to the `jest`
    command. The following list contains some of the more commonly used flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--bail`: Exits the test suite immediately upon the first failing test suite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--coverage`: Collects test coverage and displays it in the terminal after
    the tests have run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--watch`: Watches files for changes and reruns tests related to changed files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can pass these flags to the `npm` test command by adding them after a `--`.
    For example, if you wanted to use the `--bail` flag, you''d run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can view the entire list of CLI options on the official site at [https://jestjs.io/docs/en/cli](https://jestjs.io/docs/en/cli).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the advantages of integrating WebAssembly with
    Node.js and demonstrated how Node.js could be used on the server and client side.
    We evaluated an Express application that uses a Wasm module to perform calculations
    on accounting transactions. We then reviewed a browser-based application that
    utilizes Webpack to import and call functions from a C file without having to
    write any Wasm instantiation code. Finally, we saw how the Jest testing framework
    can be leveraged to test a compiled module and ensure it's functioning correctly.
    In [Chapter 10](93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml), *Advanced Tools and
    Upcoming Features*, we'll cover advanced tools and discuss the features that are
    on the horizon for WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is one of the advantages of integrating WebAssembly with Node.js?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What library does the Express application use to read and write data to a JSON
    file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between loading a module in the browser and in Node.js?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What technique can you use to run an `npm` script before or after an existing
    `npm` script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the task Webpack performs to eliminate dead code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a loader in Webpack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `describe()` and `test()` functions in Jest?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you pass additional CLI flags to the `npm test` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express: [https://expressjs.com](https://expressjs.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webpack: [https://webpack.js.org](https://webpack.js.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jest API: [https://jestjs.io/docs/en/api](https://jestjs.io/docs/en/api)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
