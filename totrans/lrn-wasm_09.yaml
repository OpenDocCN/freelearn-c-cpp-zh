- en: Integrating with Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 Node.js
- en: The modern web leans heavily on Node.js for both development and server-side
    management. With the advent of increasingly complex browser applications that
    perform computationally expensive operations, performance increases can be incredibly
    beneficial. In this chapter, we're going to describe the various ways you can
    integrate WebAssembly with Node.js through the use of various examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络在开发和服务器端管理方面都严重依赖 Node.js。随着越来越复杂的浏览器应用程序执行计算密集型操作的出现，性能提升可以带来极大的好处。在本章中，我们将通过各种示例描述你可以通过使用各种方法将
    WebAssembly 集成到 Node.js 中的各种方式。
- en: 'Our goal for this chapter is to understand the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的目标是理解以下内容：
- en: The advantages of integrating WebAssembly with Node.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 WebAssembly 与 Node.js 集成的优势
- en: How to interact with the Node.js WebAssembly API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与 Node.js WebAssembly API 交互
- en: How to utilize Wasm modules in a project that uses Webpack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在使用 Webpack 的项目中利用 Wasm 模块
- en: How to write unit tests for WebAssembly modules using `npm` libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `npm` 库为 WebAssembly 模块编写单元测试
- en: Why Node.js?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Node.js？
- en: In [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting Up a Development
    Environment*, Node.js was described as an asynchronous event-driven JavaScript
    runtime, which is the definition taken from the official website. What Node.js
    represents, however, is a profound shift in the way we build and manage web applications.
    In this section, we will discuss the relationship between WebAssembly and Node.js,
    and why the two technologies complement each other so well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml)，“设置开发环境”中，Node.js 被描述为异步事件驱动的
    JavaScript 运行时，这是从官方网站上摘取的定义。然而，Node.js 所代表的，是我们构建和管理网络应用方式的深刻转变。在本节中，我们将讨论 WebAssembly
    和 Node.js 之间的关系，以及为什么这两种技术如此完美地互补。
- en: Seamless integration
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无缝集成
- en: Node.js runs on Google's V8 JavaScript engine, which powers Google Chrome. Since
    V8's WebAssembly implementation adheres to the *Core Specification*, you can interact
    with a WebAssembly module using the same API as the browser. Instead of performing
    a fetch call for a `.wasm` file, you can use Node.js's `fs` module to read the
    contents into a buffer, then call `instantiate()` on the result.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 运行在 Google 的 V8 JavaScript 引擎上，该引擎为 Google Chrome 提供动力。由于 V8 的 WebAssembly
    实现遵循 *核心规范*，你可以使用与浏览器相同的 API 与 WebAssembly 模块交互。你不需要为 `.wasm` 文件执行 fetch 调用，而是可以使用
    Node.js 的 `fs` 模块将内容读取到缓冲区中，然后在结果上调用 `instantiate()`。
- en: Complementary technologies
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补充技术
- en: JavaScript has limitations on the server side as well. Expensive computation
    or working with large numbers can be optimized with WebAssembly's superior performance.
    As a scripting language, JavaScript excels at automating simple tasks. You could
    write a script to compile C/C++ to a Wasm file, copy it to a `build` folder, and
    see the changes reflected in the browser if you're using a tool like `Browsersync`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在服务器端也存在局限性。使用 WebAssembly 的卓越性能可以优化昂贵的计算或处理大量数据。作为一个脚本语言，JavaScript
    在自动化简单任务方面表现出色。如果你使用像 `Browsersync` 这样的工具，你可以编写一个脚本来将 C/C++ 编译成 Wasm 文件，将其复制到
    `build` 文件夹，并在浏览器中查看更改。
- en: Development with npm
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 npm 进行开发
- en: Node.js has an extensive ecosystem of tools and libraries in the form of `npm`.
    Sven Sauleau and other members of the open source community have created `webassemblyjs`,
    an extensive suite of tooling for WebAssembly built with Node.js. The `webassemblyjs`
    site at [https://webassembly.js.org](https://webassembly.js.org) includes the
    tagline *Toolchain for WebAssembly*. There are currently over 20 `npm` packages
    to perform various tasks and aid in development, such as an ESLint plugin, an
    AST validator, and a formatter. AssemblyScript, a TypeScript to WebAssembly compiler,
    allows you to write performant code that compiles to a Wasm module without having
    to learn C or C++. The Node.js community is clearly vested in WebAssembly's success.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 拥有庞大的工具和库生态系统，形式为 `npm`。Sven Sauleau 和开源社区的其它成员创建了 `webassemblyjs`，这是一个用
    Node.js 构建的针对 WebAssembly 的工具套件。`webassemblyjs` 网站在 [https://webassembly.js.org](https://webassembly.js.org)
    上的标语是 *WebAssembly 工具链*。目前有超过 20 个 `npm` 包用于执行各种任务并辅助开发，例如 ESLint 插件、AST 验证器和格式化工具。AssemblyScript，一个
    TypeScript 到 WebAssembly 编译器，允许你编写编译成 Wasm 模块的性能代码，而无需学习 C 或 C++。Node.js 社区显然对
    WebAssembly 的成功寄予厚望。
- en: Server-side WebAssembly with Express
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端 WebAssembly 与 Express
- en: Node.js can be used in several ways to add value to a WebAssembly project. In
    this section, we're going to walk through an example Node.js application that
    integrates WebAssembly. The application uses Express with some simple routes to
    call functions from a compiled Wasm module.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 可以以多种方式用于为 WebAssembly 项目增加价值。在本节中，我们将通过一个示例 Node.js 应用程序来展示如何集成 WebAssembly。该应用程序使用
    Express 和一些简单的路由来调用编译的 Wasm 模块中的函数。
- en: Overview of the project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'The project reuses some of the code from the application we built in [Chapter
    7](79019325-2d3e-452c-b680-ac90522aa4bf.xhtml), *Creating an Application from
    Scratch* (*Cook the Books*) to demonstrate how Node.js can be used with WebAssembly.
    The code for this section is located in the `/chapter-09-node/server-example`
    folder in the `learn-webassembly` repository. We''re going to review portions
    of the application directly applicable to Node.js. The following structure represents
    the file structure for the project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目重用了我们在 [第 7 章](79019325-2d3e-452c-b680-ac90522aa4bf.xhtml)，*从头创建应用程序* (*Cook
    the Books*) 中构建的应用程序的一些代码，以展示 Node.js 如何与 WebAssembly 一起使用。本节代码位于 `learn-webassembly`
    存储库的 `/chapter-09-node/server-example` 文件夹中。我们将直接审查适用于 Node.js 的应用程序的部分。以下结构表示项目的文件结构：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With regard to dependencies, the application uses the `express` and `body-parser`
    libraries to set up routes and parse JSON from the body of requests. For data
    management, it uses `lowdb`, a library that provides methods for reading and updating
    a JSON file. The JSON file is located in `/src/assets/db.json` and contains data
    that was slightly modified from the Cook the Books dataset. We're using `nodemon`
    to watch for changes in the `/src` folder and reload the application automatically.
    We're using `rimraf` to manage file deletion. The library is included as a dependency
    in the event that you didn't install it globally in [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting
    Up a Development Environment*. Finally, the `node-fetch` library allows us to
    use the fetch API to make HTTP requests when testing the application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于依赖项，应用程序使用 `express` 和 `body-parser` 库来设置路由并解析请求体的 JSON。对于数据管理，它使用 `lowdb`，这是一个提供读取和更新
    JSON 文件方法的库。JSON 文件位于 `/src/assets/db.json`，包含从 Cook the Books 数据集略微修改后的数据。我们使用
    `nodemon` 来监视 `/src` 文件夹中的更改并自动重新加载应用程序。我们使用 `rimraf` 来管理文件删除。如果未全局安装，该库作为依赖项包含在
    [第 3 章](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml)，*设置开发环境* 中。最后，`node-fetch`
    库允许我们在测试应用程序时使用 fetch API 发送 HTTP 请求。
- en: To simplify functionality in both the JavaScript and C files, the `rawAmount`
    and `cookedAmount` fields were replaced with a single `amount` field, and the
    `category` field is now `categoryId`, which maps to a `categories` array in `db.json`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化 JavaScript 和 C 文件中的功能，将 `rawAmount` 和 `cookedAmount` 字段替换为单个 `amount` 字段，而
    `category` 字段现在是 `categoryId`，它映射到 `db.json` 中的 `categories` 数组。
- en: Express configuration
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express 配置
- en: 'The application is loaded in `/src/index.js`. The contents of this file are
    shown as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序加载在 `/src/index.js` 中。此文件的如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file sets up a new Express app, adds the `body-parser` middleware, loads
    the mock database and Wasm instance, and assigns routes. Let's move on to discussing
    the difference between instantiating a Wasm module in the browser and Node.js.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件设置了一个新的 Express 应用程序，添加了 `body-parser` 中间件，加载了模拟数据库和 Wasm 实例，并分配了路由。让我们继续讨论在浏览器和
    Node.js 中实例化 Wasm 模块的差异。
- en: Instantiating a Wasm module with Node.js
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 实例化 Wasm 模块
- en: 'The Wasm files are instantiated in `/src/load-assets.js`. We''re using the
    `memory.wasm` file from Cook the Books, but the `/assets/main.wasm` file is compiled
    from a slightly different version of `main.c`, which is located in the `/lib`
    folder. The `loadWasm()` function performs the same operation as the Wasm initialization
    code from Cook the Books, but the method for passing in the `bufferSource` to
    `WebAssembly.instantiate()` is different. Let''s examine this further by reviewing
    a portion of the code in the `loadWasm()` function of the `load-assets.js file`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm 文件在 `/src/load-assets.js` 中实例化。我们使用 Cook the Books 的 `memory.wasm` 文件，但
    `/assets/main.wasm` 文件是从位于 `/lib` 文件夹中的 `main.c` 的一个略微不同的版本编译的。`loadWasm()` 函数执行与
    Cook the Books 中的 Wasm 初始化代码相同的操作，但将 `bufferSource` 传递给 `WebAssembly.instantiate()`
    的方法不同。让我们通过审查 `load-assets.js` 文件中的 `loadWasm()` 函数的一部分来进一步探讨这一点：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To elaborate on the differences, here''s some code that instantiates a module
    using `fetch`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐述差异，以下是一些使用 `fetch` 实例化模块的代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When using Node.js, the fetch call is replaced by the `fs.readFileSync()` function
    and the `arrayBuffer()` function is no longer required because `fs.readFileSync()`
    returns a buffer that can be passed directly into the `instantiate()` function.
    Once the Wasm module is instantiated, we can start interacting with the instance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Node.js时，fetch调用被`fs.readFileSync()`函数替换，并且不再需要`arrayBuffer()`函数，因为`fs.readFileSync()`返回一个可以直接传递给`instantiate()`函数的缓冲区。一旦Wasm模块被实例化，我们就可以开始与实例交互。
- en: Creating a mock database
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模拟数据库
- en: 'The `load-assets.js` file also contains a method for creating a mock database
    instance:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`load-assets.js`文件还包含创建模拟数据库实例的方法：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `loadDb()` function loads the contents of `/assets/db.json` into an instance
    of `lowdb`. The default function exported from `load-assets.js` calls the `loadWasm()`
    and `loadDb()` functions and returns an object containing the mock database and
    Wasm instance:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadDb()`函数将`/assets/db.json`的内容加载到`lowdb`的一个实例中。从`load-assets.js`导出的默认函数调用`loadWasm()`和`loadDb()`函数，并返回一个包含模拟数据库和Wasm实例的对象：'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Going forward, I'll use the term database to refer to the `lowdb` instance that
    accesses the `db.json` file. Now that the assets are loaded, let's review how
    the application interacts with them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 今后，我将使用“数据库”一词来指代访问`db.json`文件的`lowdb`实例。现在资产已加载，让我们回顾应用程序如何与它们交互。
- en: Interacting with the WebAssembly module
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与WebAssembly模块的交互
- en: 'Interaction with the database and Wasm instance takes place across two files
    in the `/src` folder: `Transaction.js` and `assign-routes.js`. In our example
    application, all communication with the API is performed via HTTP requests. Sending
    a request to a specific endpoint will trigger some interaction with the database/Wasm
    instance on the server. Let''s start by reviewing `Transaction.js`, which interacts
    directly with the database and Wasm instance.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库和Wasm实例的交互发生在`/src`文件夹中的两个文件中：`Transaction.js`和`assign-routes.js`。在我们的示例应用程序中，所有与API的通信都是通过HTTP请求完成的。向特定端点发送请求将触发服务器上数据库/Wasm实例的一些交互。让我们首先回顾`Transaction.js`，它直接与数据库和Wasm实例交互。
- en: Wrapping interaction in Transaction.js
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Transaction.js中封装交互
- en: 'Just as with Cook the Books, there''s a class that wraps the Wasm interaction
    code and provides a clean interface. The contents of `Transaction.js` are very
    similar to the contents of `/src/store/WasmTransactions.js` from Cook the Books.
    Most of the changes accommodate for the `categoryId` being present in a transaction
    record and a single `amount` field (no more raw and cooked amounts). Additional
    functionality was added to interact with the database. For example, here''s a
    function that edits an existing transaction, both in the database and the linked
    list from the Wasm instance:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Cook the Books一样，有一个类封装了Wasm交互代码，并提供了一个干净的接口。`Transaction.js`的内容与Cook the
    Books中的`/src/store/WasmTransactions.js`的内容非常相似。大部分更改都是为了适应事务记录中存在的`categoryId`和一个单独的`amount`字段（不再有生和熟的数量）。还添加了与数据库交互的功能。例如，这里有一个编辑现有事务的函数，既在数据库中，也在Wasm实例的链表中：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `edit()` function updates the database record that corresponds to the `transactionId`
    argument with the values in the `contents` argument. `this.db` is the database
    instance that was created in the `load-assets.js` file. Since the `categoryId`
    field is available on the `updatedTransaction` record, we can pass it directly
    to `this.wasmInstance._editTransaction()`. It gets passed into the constructor
    when a new instance of `Transaction` is created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit()`函数使用`contents`参数中的值更新与`transactionId`参数对应的数据库记录。`this.db`是在`load-assets.js`文件中创建的数据库实例。由于`categoryId`字段在`updatedTransaction`记录中可用，我们可以直接将其传递给`this.wasmInstance._editTransaction()`。它是在创建`Transaction`的新实例时传递给构造函数的。'
- en: Transaction operations in assign-routes.js
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: assign-routes.js中的事务操作
- en: 'The `assign-routes.js` file defines routes and adds them to the `express` instance
    (`app`) created in `index.js`. In Express, routes can be defined directly on `app`
    (for example, `app.get()`), or through the use of a `Router`. In this case, a
    `Router` was used to add multiple methods to the same route path. The following
    code, taken from the `assign-routes.js` file, creates a `Router` instance and
    adds two routes: a `GET` route that returns all transactions, and a `POST` route
    that creates a new transaction:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign-routes.js` 文件定义了路由并将其添加到在 `index.js` 中创建的 `express` 实例（`app`）。在 Express
    中，路由可以直接在 `app` 上定义（例如，`app.get()`），或者通过使用 `Router`。在这种情况下，使用 `Router` 向相同的路由路径添加了多个方法。以下代码来自
    `assign-routes.js` 文件，创建了一个 `Router` 实例并添加了两个路由：一个返回所有交易的 `GET` 路由，以及一个创建新交易的
    `POST` 路由：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `app.use()` function at the end of the snippet specifies that all routes
    defined on the `transactionsRouter` instance are prefixed with `/api/transactions`.
    If you were running the application locally on port `3000`, you could navigate
    to `http://localhost:3000/api/transactions` in your browser and see an array of
    all the transactions in JSON format.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要中的 `app.use()` 函数指定了所有定义在 `transactionsRouter` 实例上的路由都以前缀 `/api/transactions`
    开头。如果你在本地端口 `3000` 上运行应用，你可以在浏览器中导航到 `http://localhost:3000/api/transactions`
    并看到所有交易的 JSON 格式数组。
- en: As you can see from the body of the `get()` and `post()` functions, interactions
    with any transaction records are being delegated to the `Transaction` instance
    created in line `3`. That completes our review of pertinent sections of the code
    base. Each of the files contain comments describing the file's functionality and
    purpose, so you may want to review those before moving on to the next section.
    In the next section, we'll build, run, and interact with the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从 `get()` 和 `post()` 函数的主体中看到的，与任何交易记录的交互都被委派给了第 `3` 行创建的 `Transaction` 实例。这完成了我们对代码库相关部分的审查。每个文件都包含描述文件功能及目的的注释，因此你可能想在继续下一部分之前先查看这些注释。在下一部分，我们将构建、运行并交互应用。
- en: Building and running the application
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行应用
- en: 'Before we build and test out the project, you''ll need to install the `npm`
    dependencies. Open a terminal within the `/server-example` folder and run the
    following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建和测试项目之前，你需要安装 `npm` 依赖。在 `/server-example` 文件夹内打开终端，并运行以下命令：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once that's complete, you're ready to move on to the build step.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你就可以继续构建步骤了。
- en: Building the application
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用
- en: 'In the case of this application, building refers to compiling the `lib/main.c`
    to a `.wasm` file using the `emcc` command. Since this is a Node.js project, we
    can use the `scripts` key in our `package.json` file to define Tasks. You can
    still use VS Code''s Tasks feature because it automatically detects the scripts
    from your `package.json` file and presents them in the list of tasks when you
    select Tasks | Run Task... from the menu. The following code contains the contents
    of the `scripts` section in this project''s `package.json` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，构建指的是使用 `emcc` 命令将 `lib/main.c` 编译成 `.wasm` 文件。由于这是一个 Node.js 项目，我们可以在
    `package.json` 文件中的 `scripts` 键下定义任务。你仍然可以使用 VS Code 的任务功能，因为它会自动检测 `package.json`
    文件中的脚本，并在你从菜单中选择任务 | 运行任务...时，在任务列表中显示它们。以下代码包含此项目 `package.json` 文件中 `scripts`
    部分的内容：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `build` script was split across multiple lines for display purposes, so
    you''d have to combine those lines for valid JSON. The `prebuild` script removes
    the existing Wasm file, and the `build` script runs the `emcc` command with the
    required flags to compile `lib/main.c` and output the result to `src/assets/main.wasm`.
    To run the script, open a terminal within the `/server-example` folder and run
    the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示目的，`build` 脚本被拆分成了多行，所以你需要将这些行合并以生成有效的 JSON。`prebuild` 脚本会移除现有的 Wasm 文件，而
    `build` 脚本会使用所需的标志运行 `emcc` 命令来编译 `lib/main.c` 并将结果输出到 `src/assets/main.wasm`。要运行脚本，请在
    `/server-example` 文件夹内打开终端，并运行以下命令：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the `/src/assets` folder contains a file named `main.wasm`, the build completed
    successfully. If an error has occurred, the terminal should provide a description
    of the error, as well as a stack trace.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `/src/assets` 文件夹中包含名为 `main.wasm` 的文件，则构建成功完成。如果发生错误，终端应提供错误描述以及堆栈跟踪。
- en: You can create `npm` scripts that run before or after a specific script by creating
    an entry with the same name and prefixing it with `pre` or `post`. For example,
    if you wanted to run a script after the `build` script has completed, you can
    create a script named `"postbuild"` and specify the command you want to run.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建 `npm` 脚本来在特定脚本之前或之后运行，通过创建具有相同名称的条目，并在其前缀中添加 `pre` 或 `post`。例如，如果你想在一个名为
    `build` 的脚本完成后运行一个脚本，你可以创建一个名为 `"postbuild"` 的脚本，并指定你想要运行的命令。
- en: Starting and testing out the application
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动并测试应用程序
- en: 'If you''re making changes to the application or trying to fix a bug, you could
    use the `watch` script to watch for any changes to the contents of the `/src`
    folder and automatically restart the application if a change was made. Since we''re
    just running and testing out the application, we can use the `start` command instead.
    In the terminal, ensure you''re in the `/server-example` folder and run the following
    command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在修改应用程序或尝试修复错误，可以使用 `watch` 脚本来监视 `/src` 文件夹内容的变化，并在有更改时自动重启应用程序。由于我们只是运行和测试应用程序，我们可以使用
    `start` 命令。在终端中，确保你位于 `/server-example` 文件夹内，并运行以下命令：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see a message that says `Server is running on port 3000`. You''re
    now able to send HTTP requests to the server. To test the application, open a
    new terminal instance within the `server-example` directory and run the following
    command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个消息说“服务器正在端口 3000 上运行”。你现在可以向服务器发送 HTTP 请求。为了测试应用程序，在 `server-example`
    目录内打开一个新的终端实例，并运行以下命令：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This should log out the response body of the `GET` call to the `/api/transactions`
    endpoint. The `requests.js` file contains functionality that allows you to make
    requests to all of the available routes. The `getFetchActionForId()` function
    returns an object with an endpoint and options value, which corresponds to a route
    in the `assign-routes.js` file. The `actionId` is an arbitrary number to simplify
    testing and reduce the amount of typing for running commands. For example, you
    could run the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会记录 `/api/transactions` 端点的 `GET` 调用的响应体。`requests.js` 文件包含允许你向所有可用路由发出请求的功能。`getFetchActionForId()`
    函数返回一个包含端点和选项值的对象，这与 `assign-routes.js` 文件中的一个路由相对应。`actionId` 是一个任意数字，用于简化测试并减少运行命令时的输入量。例如，你可以运行以下命令：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It will log out the sum of all transactions for the *Computer & Internet* category.
    You can pass an additional argument to the `node` command if you want the total
    for a different category. To get the sum of all transactions in the *Insurance*
    category, run this command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它将记录 *计算机与互联网* 类别所有交易的总额。如果你想获取不同类别的总额，可以向 `node` 命令传递额外的参数。要获取 *保险* 类别所有交易的总额，运行此命令：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Try going through each of the requests (there are eight in total). If you make
    a request that adds, removes, or edits a transaction, you should see the changes
    in the `/src/assets/db.json` file. That's it for the Node.js example project.
    In the next section, we'll utilize Webpack to load and interact with a Wasm module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试遍历每个请求（总共有八个）。如果你发出一个添加、删除或编辑交易的请求，你应该能在 `/src/assets/db.json` 文件中看到更改。这就是
    Node.js 示例项目的全部内容。在下一节中，我们将利用 Webpack 来加载和交互 Wasm 模块。
- en: Client-side WebAssembly with Webpack
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Webpack 的客户端 WebAssembly
- en: Web applications continue to grow in complexity and size. Simply serving up
    a few handwritten HTML, CSS, and JavaScript files is not feasible for large applications.
    To manage this complexity, web developers use bundlers to allow for modularization,
    ensure browser compatibility, and reduce the size of JavaScript files. In this
    section, we're going to be using a popular bundler, Webpack, to utilize Wasm without
    using `emcc`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序在复杂性和大小上持续增长。仅仅提供一些手写的 HTML、CSS 和 JavaScript 文件对于大型应用程序来说是不切实际的。为了管理这种复杂性，Web
    开发者使用打包器来实现模块化、确保浏览器兼容性并减小 JavaScript 文件的大小。在本节中，我们将使用流行的打包器 Webpack，以不使用 `emcc`
    的方式利用 Wasm。
- en: Overview of the project
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'The example Webpack application extends the functionality of the C code we
    wrote in the *Compiling C without the glue code* section of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*. Instead of showing a blue rectangle bouncing
    around a red background, we''ll show an alien in a spaceship bouncing around the
    Horsehead Nebula. The collision detection functionality has been modified to accommodate
    for bouncing within a rectangle, so the movement of the spaceship will be random.
    The code for this section is located in the `/chapter-09-node/webpack-example`
    folder in the `learn-webassembly` repository. The file structure for the project
    is shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例Webpack应用程序扩展了我们在[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)“编译C语言而无需胶水代码”部分中编写的C代码的功能，即*创建和加载WebAssembly模块*。我们不会展示一个蓝色矩形在红色背景中弹跳，而是展示一个在飞船中弹跳的异形在马头星云中。碰撞检测功能已被修改以适应矩形内的弹跳，因此飞船的运动将是随机的。本节代码位于`learn-webassembly`仓库中的`/chapter-09-node/webpack-example`文件夹中。以下代码显示了项目的文件结构：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We'll review the Webpack configuration file in a later section. For now, let's
    take a moment to discuss Webpack in more detail.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的部分中回顾Webpack配置文件。现在，让我们花点时间更详细地讨论Webpack。
- en: What is Webpack?
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Webpack？
- en: The JavaScript ecosystem has been rapidly evolving over the past several years,
    resulting in new frameworks and libraries popping up constantly. Bundlers came
    about as a way to enable developers to split a JavaScript application into several
    files without having to worry about managing global namespaces, script loading
    order, or an incredibly long list of `<script>` tags in the HTML file. A bundler
    combines all of the files into one and resolves any naming collisions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年中，JavaScript生态系统一直在快速发展，导致新的框架和库不断涌现。打包器作为一种方式出现，使开发者能够将JavaScript应用程序拆分为多个文件，而无需担心管理全局命名空间、脚本加载顺序或在HTML文件中的极其长的`<script>`标签列表。打包器将所有文件合并为一个，并解决任何命名冲突。
- en: Webpack is, at the time of writing, one of the most popular bundlers for frontend
    development. It does much more than combine JavaScript files, however. It also
    performs complex tasks such as code-splitting and tree shaking (dead-code elimination).
    Webpack was designed with a plugin architecture, which resulted in a massive amount
    of community-developed plugins. A search for Webpack on `npm` currently returns
    over 12,000 packages! This exhaustive list of plugins, along with its powerful
    built-in feature set, makes Webpack a full-fledged build tool.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Webpack是前端开发中最受欢迎的打包器之一。然而，它做的不仅仅是合并JavaScript文件。它还执行复杂的任务，如代码拆分和树摇（死代码消除）。Webpack的设计采用了插件架构，这导致了大量社区开发的插件。在`npm`上搜索Webpack目前返回超过12,000个包！这个插件列表的详尽性，加上其强大的内置功能集，使Webpack成为一个完整的构建工具。
- en: Installing and configuring Webpack
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Webpack
- en: 'Before we begin the application walk-through, open up a terminal within the
    `/webpack-example` folder and run the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始应用程序演示之前，请在`/webpack-example`文件夹中打开一个终端，并运行以下命令：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Dependencies overview
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖概述
- en: 'The application uses Version 4 of Webpack (the most recent version as of writing
    this) to build our application. We need to use Webpack plugins to load the various
    file types used in the application and Babel to utilize newer JavaScript features.
    The following snippet lists the `devDependencies` we''re using in the project
    (taken from `package.json`):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序使用Webpack的版本4（撰写本文时的最新版本）来构建我们的应用程序。我们需要使用Webpack插件来加载应用程序中使用的各种文件类型，并使用Babel来利用更新的JavaScript功能。以下代码片段列出了我们在项目中使用的`devDependencies`（从`package.json`中获取）：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I specified exact versions for some of the libraries to ensure the application
    builds and runs successfully. Any libraries with a name ending in `-loader` or
    `-plugin` are used in conjunction with Webpack. The `cpp-wasm-loader` library
    allows us to import a C or C++ file directly, without having to compile it to
    Wasm first. Webpack 4 has built-in support for importing `.wasm` files, but you
    can't specify an `importObj` argument, which is required for modules generated
    with Emscripten.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我为一些库指定了精确的版本，以确保应用程序能够成功构建和运行。任何以`-loader`或`-plugin`结尾的库都是与Webpack一起使用的。`cpp-wasm-loader`库允许我们直接导入C或C++文件，而无需先将其编译成Wasm。Webpack
    4内置了对`.wasm`文件的支持，但你不能指定`importObj`参数，这对于使用Emscripten生成的模块是必需的。
- en: Configuring loaders and plugins in webpack.config.js
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在webpack.config.js中配置加载器和插件
- en: 'We''re using several different file types in addition to JavaScript for the
    application: CSS, SVG, HTML, and so on. Installing the `-loader` dependencies
    is only part of the equation—you also need to tell Webpack how to load them. You
    also need to specify configuration details for any plugins you have installed.
    You can specify the loading and configuration details in a `webpack.config.js`
    file in the root folder of your project. The following snippet contains the contents
    of `/webpack-example/webpack.config.js`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 JavaScript 之外，我们还在应用程序中使用了多种不同的文件类型：CSS、SVG、HTML 等。安装 `-loader` 依赖项只是方程的一部分——你还需要告诉
    Webpack 如何加载它们。你还需要为安装的任何插件指定配置细节。你可以在项目根目录中的 `webpack.config.js` 文件中指定加载和配置细节。以下片段包含
    `/webpack-example/webpack.config.js` 的内容：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `rules` section tells Webpack which loader to use for a file extension.
    The fourth item in the array handles C/C++ files (note the `test` field value
    containing `c|cpp`). The `HtmlWebpackPlugin` takes the contents of `/src/index.html`,
    adds any required `<script>` tags, minifies it, and creates an `index.html` in
    the `build` folder, which defaults to `/dist`. The `MiniCssExtractPlugin` copies
    any imported CSS into a single CSS file in the `/dist` folder. We'll review how
    to build the project in a later section, so let's move on to the application code,
    starting with the C file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`rules` 部分告诉 Webpack 为文件扩展名使用哪个加载器。数组中的第四项处理 C/C++ 文件（注意 `test` 字段值包含 `c|cpp`）。`HtmlWebpackPlugin`
    从 `/src/index.html` 中获取内容，添加任何必需的 `<script>` 标签，压缩它，并在 `build` 文件夹中创建一个 `index.html`
    文件，默认为 `/dist`。`MiniCssExtractPlugin` 将任何导入的 CSS 复制到 `/dist` 文件夹中的一个单独的 CSS 文件中。我们将在后面的部分中回顾如何构建项目，所以让我们继续到应用程序代码，从
    C 文件开始。'
- en: The C code
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C 语言代码
- en: 'Since we''re allowed to import C and C++ files directly, the C file is located
    within the `/src` folder. This file, `main.c`, contains logic to manage collision
    detection and move the spaceship around the `<canvas>`. The code is based on the
    `without-glue.c` file we created in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*. We''re not going to review the entire file,
    only the sections that have changed and merit explanation. Let''s begin with the
    definitions and declarations section, which includes a new `struct`: `Bounds`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以直接导入 C 和 C++ 文件，C 文件位于 `/src` 文件夹中。这个文件，`main.c`，包含管理碰撞检测和在 `<canvas>`
    中移动宇宙飞船的逻辑。代码基于我们在 [第 5 章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)，“创建和加载
    WebAssembly 模块”中创建的 `without-glue.c` 文件。我们不会审查整个文件，只审查已更改且需要解释的部分。让我们从定义和声明部分开始，其中包含一个新的
    `struct`：`Bounds`。
- en: Definitions and declarations
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和声明
- en: 'The code containing the definitions and declarations sections is shown as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 包含定义和声明部分的代码如下所示：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: New properties were added to the existing `Rect` definition to accommodate for
    flexible sizing and tracking movement in the *x* and *y* directions. We defined
    a new `struct`, `Bounds`, and removed the existing `#define` statements because
    the `<canvas>` element is no longer a square with static dimensions. A new instance
    of both elements is declared when the module loads. The dimensional properties
    of these instances are assigned in the `start()` function, which we'll cover next.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '为了适应灵活的大小和跟踪在 *x* 和 *y* 方向上的移动，现有 `Rect` 定义中添加了新属性。我们定义了一个新的 `struct`，`Bounds`，并移除了现有的
    `#define` 语句，因为 `<canvas>` 元素不再是具有静态维度的正方形。当模块加载时，这两个元素都会声明一个新的实例。这些实例的尺寸属性在 `start()`
    函数中分配，我们将在下一部分介绍。 '
- en: The start() function
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`start()` 函数'
- en: 'The updated `start()` function, which acts as the entry point to the module,
    is shown as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 `start()` 函数，它作为模块的入口点，如下所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Any functions that are called from JavaScript are prepended with the `EMSCRIPTEN_KEEPALIVE`
    statement. We're now passing the width and height of both the `Bounds` and `Rect`
    elements as arguments to the `start()` function, which we assign to the local
    `bounds` and `rect` variables. This allows us to easily change the dimensions
    of either one without having to make any changes to the collision detection logic.
    In the context of this application, the `rect` represents the rectangle in which
    the spaceship image resides. We set the default horizontal and vertical direction
    for the `rect` so the image initially moves to the right and down. Let's move
    on to the `rect` movement/collision detection code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JavaScript 中调用的任何函数都带有 `EMSCRIPTEN_KEEPALIVE` 声明。我们现在将 `Bounds` 和 `Rect` 元素的宽度和高度作为参数传递给
    `start()` 函数，并将其分配给局部的 `bounds` 和 `rect` 变量。这使得我们能够轻松地更改任一元素的尺寸，而无需对碰撞检测逻辑进行任何修改。在这个应用程序的上下文中，`rect`
    代表飞船图像所在的矩形。我们为 `rect` 设置了默认的水平方向和垂直方向，使得图像最初向右下方移动。接下来，让我们继续查看 `rect` 移动/碰撞检测代码。
- en: The updateRectLocation() function
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`updateRectLocation()` 函数'
- en: 'The code related to collision detection and the `Rect` movement is handled
    in the `updateRectLocation()` function, which is shown as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与碰撞检测和 `Rect` 移动相关的代码在 `updateRectLocation()` 函数中处理，如下所示：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The primary difference between this code and the code we wrote in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*, is the collision detection logic. Instead of
    simply tracking the location of the `rect` instance horizontally and changing
    direction when it hits the right boundary, the function now tracks the horizontal
    and vertical directions and manages each independently. Although this isn't the
    most performant algorithm, it does achieve the goal of ensuring the spaceship
    changes direction when it encounters the edge of the `<canvas>`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在第 5 章 [创建和加载 WebAssembly 模块](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中编写的代码相比，主要区别在于碰撞检测逻辑。现在，函数不仅跟踪
    `rect` 实例的水平位置，并在碰撞到右边界时改变方向，而是跟踪水平和垂直方向，并分别管理它们。虽然这不是最高效的算法，但它确实实现了确保飞船在遇到 `<canvas>`
    边缘时改变方向的目标。
- en: The JavaScript code
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 代码
- en: The only production dependency we're using for the application is Vue. Although
    the application consists of a single component, Vue makes managing data, functions,
    and the component life-cycle much simpler than trying to do it manually. The `index.js`
    file contains the Vue initialization code, while the rendering and application
    logic is in `/src/App.js`. This file has a lot of moving parts, so we're going
    to review the code in chunks, as we did in the previous section. Let's start with
    the `import` statements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中使用的唯一生产依赖项是 Vue。尽管应用程序由单个组件组成，但 Vue 使得管理数据、函数和组件生命周期比手动操作要简单得多。`index.js`
    文件包含 Vue 初始化代码，而渲染和应用程序逻辑在 `/src/App.js` 中。这个文件有很多部分，所以我们将像上一节那样分块审查代码。让我们从 `import`
    语句开始。
- en: The import statements
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入语句
- en: 'The following code demonstrates the Webpack loaders in action:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了 Webpack 加载器的实际应用：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The loaders we configured in the `webpack.config.js` file understand how to
    handle CSS, C, and image files. Now that we have the required resources available,
    we can start defining our component state.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webpack.config.js` 文件中配置的加载器了解如何处理 CSS、C 和图像文件。现在我们已经有了所需的资源，我们可以开始定义我们的组件状态。
- en: Component state
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件状态
- en: 'The following code initializes the local state in the `data()` function for
    our component:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码初始化了组件的 `data()` 函数中的本地状态：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Although the `bounds` and `rect` properties never change, we defined them in
    the local state to keep all the data used by the component in a single location.
    The `speed` property dictates how quickly the spaceship moves across the `<canvas>`
    and has a range of `1` to `10`. The `instance` property is initialized to null,
    but will be used to access the compiled Wasm module's exported functions. Let's
    move on to the Wasm initialization code that compiles the Wasm file and populates
    the `<canvas>`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `bounds` 和 `rect` 属性从未改变，但我们还是在本地状态中定义了它们，以保持组件使用的所有数据在单个位置。`speed` 属性决定了飞船在
    `<canvas>` 中移动的速度，其范围是 `1` 到 `10`。`instance` 属性初始化为 null，但将用于访问编译后的 Wasm 模块的导出函数。接下来，让我们继续查看编译
    Wasm 文件并填充 `<canvas>` 的 Wasm 初始化代码。
- en: Wasm initialization
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wasm 初始化
- en: 'The code to compile the Wasm file and populate the `<canvas>` element is shown
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编译Wasm文件并填充`<canvas>`元素的代码如下所示：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are additional functions defined in the `methods` key of the component,
    but for now we'll focus on the code that compiles the imported C file to Wasm.
    After `Image` instances are created for the spaceship and background images, the
    `main.c` file (imported as `.wasm`) is compiled to a Wasm module and the resulting
    `exports` is assigned to `this.instance`. Once these operations complete, the
    `start()` function can be called from the exported Wasm module. Since the `initializeWasm()`
    function calls the `<canvas>` element's `getContext()` function, the component
    needs to be mounted before this function can be called. Let's review the rest
    of the `methods` definitions and the `mounted()` event handler.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的`methods`键中定义了额外的函数，但目前为止我们将关注将导入的C文件编译为Wasm的代码。在为飞船和背景图像创建`Image`实例之后，`main.c`文件（以`.wasm`导入）被编译为一个Wasm模块，生成的`exports`被分配给`this.instance`。一旦这些操作完成，就可以从导出的Wasm模块中调用`start()`函数。由于`initializeWasm()`函数调用`<canvas>`元素的`getContext()`函数，因此组件必须在调用此函数之前挂载。让我们回顾一下`methods`定义的其余部分和`mounted()`事件处理器。
- en: Component mounting
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件挂载
- en: 'The remaining `methods` definitions and `mounted()` event handler function
    are shown as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的`methods`定义和`mounted()`事件处理器函数如下所示：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the Wasm module is compiled, the `start()` function is accessible on `this.instance`.
    The `bounds` and `rect` dimensions are passed into the `start()` function, and
    then the `loopRectFunction()` is called to start moving the spaceship. The `onActionClick()`
    event handler function pauses or resumes the movement of the spaceship based on
    whether or not it's currently in motion.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Wasm模块编译完成，`start()`函数在`this.instance`上可访问。将`bounds`和`rect`维度传递给`start()`函数，然后调用`loopRectFunction()`以开始移动飞船。`onActionClick()`事件处理器函数根据飞船是否正在移动暂停或恢复其运动。
- en: The `loopRectMotion()` functions in the same way as the example code from [Chapter
    5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading a WebAssembly
    Module*, except the speed is now adjustable. The `15 - this.speed` calculation,
    which dictates the timeout length, may look a little strange. Since the movement
    speed of the image is based on the amount of time that elapses between function
    calls, increasing this number would actually slow down the spaceship. Consequently,
    `this.speed` is subtracted from `15`, which was chosen because it's slightly greater
    than `10` but won't turn the spaceship into a blur if `this.speed` is increased
    to the maximum. That's it for the component logic; let's move on to the rendering
    section of the code where the `template` is defined.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`loopRectMotion()`函数与[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中的示例代码相同，即*创建和加载WebAssembly模块*，但速度现在是可调节的。决定超时长度的`15
    - this.speed`计算可能看起来有点奇怪。由于图像的运动速度基于函数调用之间经过的时间量，增加这个数字实际上会减慢飞船的速度。因此，`this.speed`从`15`中减去，因为`15`略大于`10`，但如果`this.speed`增加到最大值，它不会使飞船变成模糊。这就是组件逻辑的全部内容；让我们继续到代码的渲染部分，其中定义了`template`。'
- en: Component rendering
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件渲染
- en: 'The contents of the `template` property, which dictates what to render, are
    shown as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 决定渲染内容的`template`属性的值如下所示：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since we're using Vue, we can bind the attributes and event handlers of HTML
    elements to properties and methods defined in our component. In addition to a
    PAUSE/RESUME button, there's a range `<input>` that allows you to change the speed.
    By sliding it to the left or right, you're able to slow down or speed up the spaceship
    and see the changes reflected immediately. That concludes our review; let's see
    how Webpack can be used to build or run the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用Vue，我们可以将HTML元素的属性和事件处理器绑定到我们在组件中定义的属性和方法。除了暂停/恢复按钮外，还有一个范围`<input>`允许你更改速度。通过将其向左或向右滑动，你可以减慢或加快飞船的速度，并立即看到变化。这就完成了我们的回顾；让我们看看Webpack如何被用来构建或运行应用程序。
- en: Building and running the application
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行应用程序
- en: 'Using the `cpp-wasm-loader` library eliminates the need for a build step to
    generate a Wasm module, but we still need to bundle up our application for distribution.
    In the `scripts` section of `package.json`, there''s a `build` and `start` script.
    Running the `build` script executes the `webpack` command that generates the bundle.
    To ensure this is working correctly, open a terminal instance in the `/webpack-example`
    folder and run the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cpp-wasm-loader`库消除了生成Wasm模块的构建步骤的需求，但我们仍然需要打包我们的应用以进行分发。在`package.json`的`scripts`部分中，有一个`build`和`start`脚本。运行`build`脚本将执行生成捆绑包的`webpack`命令。为了确保其正常工作，在`/webpack-example`文件夹中打开一个终端实例并运行以下命令：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It may take a minute to build the project the first time you run it. This can
    be attributed to the Wasm compilation step. However, subsequent builds should
    be much faster. If the build was successful, you should see a newly created `/dist`
    folder with these contents:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行项目时，构建可能需要一分钟。这可以归因于Wasm编译步骤。然而，后续的构建应该会快得多。如果构建成功，你应该会看到一个新创建的`/dist`文件夹，其中包含以下内容：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Testing the build
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试构建
- en: 'Let''s try out the build to ensure everything is working correctly. Run the
    following command in your terminal instance to start the application:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建以确保一切正常工作。在你的终端实例中运行以下命令以启动应用：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you navigate to `http://127.0.0.1:8080/index.html` in your browser, you
    should see this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过浏览器导航到`http://127.0.0.1:8080/index.html`，你应该看到以下内容：
- en: '![](img/9d3c1c1f-1f92-41e2-a5e6-27673bc221d8.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d3c1c1f-1f92-41e2-a5e6-27673bc221d8.png)'
- en: Webpack application running in the browser
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的Webpack应用
- en: The spaceship image (taken from [https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg](https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg))
    bounces around within the bounds of the Horsehead Nebula background image (taken
    from [https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg](https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg)).
    When the PAUSE button is pressed, the button's caption changes to RESUME and the
    ship stops moving. Pressing the button again will change the caption back to PAUSE and
    the ship will start moving again. Adjusting the SPEED slider increases or decreases
    the speed of the ship.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg](https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg)的太空船图像在马头星云背景图像（来自[https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg](https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg)）的范围内弹跳。当按下PAUSE按钮时，按钮的标签会变为RESUME，飞船停止移动。再次按下按钮会将标签变回PAUSE，飞船将再次开始移动。调整SPEED滑块可以增加或减少飞船的速度。
- en: Running the start script
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行启动脚本
- en: 'The application has the `webpack-dev-server` library installed, which operates
    like `Browsersync.` The library uses LiveReloading, which automatically updates
    the application when you make any changes to the files in `/src`. Since we''re
    using a Webpack loader for C and C++ files, the automatic update event will trigger
    if you change the C file as well. Run the following the command to start the application
    and watch for changes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用已安装了`webpack-dev-server`库，它的工作方式类似于`Browsersync`。该库使用LiveReloading，当你对`/src`目录中的文件进行任何更改时，它会自动更新应用。由于我们使用Webpack加载器处理C和C++文件，因此当你更改C文件时，也会触发自动更新事件。运行以下命令以启动应用并监视更改：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A browser window should open automatically when the build completes, and then
    direct you to the running application. To see the live-reloading feature in action,
    try setting the value of the `isRunning` variable in the `setIsRunning()` function
    in `main.c` to false instead of `newIsRunning`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，浏览器窗口应自动打开，并直接导向运行中的应用。要查看实时重新加载功能，尝试将`main.c`中的`setIsRunning()`函数中的`isRunning`变量的值设置为false而不是`newIsRunning`：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The spaceship should be stuck in the upper-left corner. If you change it back,
    the spaceship starts moving again. In the next section, we will write unit tests
    in JavaScript to test WebAssembly modules.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船应该被卡在左上角。如果你将其改回，飞船将再次开始移动。在下一节中，我们将用JavaScript编写单元测试来测试WebAssembly模块。
- en: Testing WebAssembly modules with Jest
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest测试WebAssembly模块
- en: Well-tested code prevents regression bugs, simplifies refactoring, and alleviates
    some of the frustrations that go along with adding new features. Once you've compiled
    a Wasm module, you should write tests to ensure it's functioning as expected,
    even if you've written tests for C, C++, or Rust code you compiled it from. In
    this section, we'll use **Jest**, a JavaScript testing framework, to test the
    functions in a compiled Wasm module.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 经过良好测试的代码可以防止回归错误，简化重构，并减轻添加新功能时的一些挫折感。一旦编译了 Wasm 模块，你应该编写测试来确保它按预期工作，即使你为从
    C、C++ 或 Rust 编译的代码编写了测试。在本节中，我们将使用 **Jest**，一个 JavaScript 测试框架，来测试编译后的 Wasm 模块中的函数。
- en: The code being tested
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在测试的代码
- en: 'All of the code used in this example is located in the `/chapter-09-node/testing-example`
    folder. The code and corresponding tests are very simple and are not representative
    of real-world applications, but they''re intended to demonstrate how to use Jest
    for testing. The following code represents the file structure of the `/testing-example`
    folder:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中使用的所有代码都位于 `/chapter-09-node/testing-example` 文件夹中。代码和相应的测试非常简单，并不代表真实世界的应用，但它们旨在演示如何使用
    Jest 进行测试。以下代码表示 `/testing-example` 文件夹的文件结构：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The contents of the C file that we''ll test, `/src/main.c`, is shown as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测试的 C 文件的内容，`/src/main.c`，如下所示：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All three functions in the file are performing simple mathematical operations.
    The `package.json` file includes a script to compile the C file to a Wasm file
    for testing. Run the following command to compile the C file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的三个函数都在执行简单的数学运算。`package.json` 文件包含一个脚本来编译 C 文件到 Wasm 文件以进行测试。运行以下命令来编译
    C 文件：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There should be a file named `main.wasm` in the `/src` directory. Let's move
    on to describing the testing configuration step.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src` 目录中应该有一个名为 `main.wasm` 的文件。让我们继续描述测试配置步骤。'
- en: Testing configuration
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试配置
- en: 'The only dependency we''ll use for this example is Jest, a JavaScript testing
    framework built by Facebook. Jest is an excellent choice for testing because it
    includes most of the features you''ll need out of the box, such as coverage, assertions,
    and mocking. In most cases, you can use it with zero configuration, depending
    on the complexity of your application. If you''re interested in learning more,
    check out Jest''s website at [https://jestjs.io](https://jestjs.io). Open a terminal
    instance in the `/chapter-09-node/testing-example` folder and run the following
    command to install Jest:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中我们将使用的唯一依赖项是 Jest，这是一个由 Facebook 构建的 JavaScript 测试框架。Jest 是一个出色的测试选择，因为它包含了大多数你需要的开箱即用的功能，如覆盖率、断言和模拟。在大多数情况下，你可以根据应用程序的复杂度进行零配置使用它。如果你有兴趣了解更多，请访问
    Jest 的网站 [https://jestjs.io](https://jestjs.io)。在 `/chapter-09-node/testing-example`
    文件夹中打开一个终端实例，并运行以下命令来安装 Jest：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `package.json` file, there are three entries in the `scripts` section:
    `build`, `pretest`, and `test`. The `build` script executes the `emcc` command
    with the required flags to compile `/src/main.c` to `/src/main.wasm`. The `test` script
    executes the `jest` command with the `--verbose flag`, which provides additional
    details for each of the test suites. The `pretest` script simply runs the `build` script
    to ensure `/src/main.wasm` exists prior to running any tests.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `package.json` 文件中，`scripts` 部分有三个条目：`build`、`pretest` 和 `test`。`build` 脚本使用所需的标志执行
    `emcc` 命令，将 `/src/main.c` 编译为 `/src/main.wasm`。`test` 脚本使用 `--verbose` 标志执行 `jest`
    命令，为每个测试套件提供额外的详细信息。`pretest` 脚本简单地运行 `build` 脚本，以确保在运行任何测试之前 `/src/main.wasm`
    存在。
- en: Tests file review
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试文件回顾
- en: 'Let''s walk through the test file, located at `/src/__tests__/main.test.js`,
    and review the purpose of each section of code. The first section of the test
    file instantiates the `main.wasm` file and assigns the result to the local `wasmInstance`
    variable:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遍历位于 `/src/__tests__/main.test.js` 的测试文件，并回顾代码每个部分的用途。测试文件的第一部分实例化了 `main.wasm`
    文件，并将结果赋值给局部变量 `wasmInstance`：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Jest provides life-cycle methods to perform any setup or teardown actions prior
    to running tests. You can specify functions to run before or after all of the
    tests (`beforeAll()`/`afterAll()`), or before or after each test (`beforeEach()`/`afterEach()`).
    We need a compiled instance of the Wasm module from which we can call exported
    functions, so we put the instantiation code in the `beforeAll()` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Jest提供了生命周期方法，在运行测试之前执行任何设置或清理操作。你可以指定在所有测试之前或之后运行的功能（`beforeAll()`/`afterAll()`），或者在每次测试之前或之后运行的功能（`beforeEach()`/`afterEach()`）。我们需要一个Wasm模块的编译实例，我们可以从中调用导出函数，因此我们将实例化代码放在`beforeAll()`函数中。
- en: 'We''re wrapping the entire test suite in a `describe()` block for the file.
    Jest uses a `describe()` function to encapsulate suites of related tests and `test()`
    or `it()` to represent a single test. Here''s a simple example of this concept:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整个测试套件包裹在一个`describe()`块中，用于该文件。Jest使用`describe()`函数来封装一系列相关的测试，使用`test()`或`it()`来表示单个测试。以下是一个简单示例来展示这个概念：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next section of code contains all the test suites and tests for each exported
    function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码部分包含了所有导出函数的测试套件和测试：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first `describe()` block, for the `_addTwoNumbers()` function, has two `test()`
    instances to ensure that the function returns the sum of the two numbers passed
    in as arguments. The next two `describe()` blocks, for the `_divideTwoNumbers()`
    and `_findFactorial()` functions, use Jest's `.each` feature, which allows you
    to run the same test with different data. The `expect()` function allows you to
    make assertions on the value passed in as an argument. The `.toBeCloseTo()` assertion
    in the last `_divideTwoNumbers()` test checks whether the result is within two
    decimal places of `3.77`. The rest use the `.toEqual()` assertion to check for
    equality.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`describe()`块是为`_addTwoNumbers()`函数设计的，包含两个`test()`实例，以确保该函数返回传入参数的两个数的和。接下来的两个`describe()`块是为`_divideTwoNumbers()`和`_findFactorial()`函数设计的，使用了Jest的`.each`功能，允许你使用不同的数据运行相同的测试。`expect()`函数允许你对传入的参数值进行断言。最后一个`_divideTwoNumbers()`测试中的`.toBeCloseTo()`断言检查结果是否在`3.77`的两位小数范围内。其余的则使用`.toEqual()`断言来检查相等性。
- en: Writing tests with Jest is relatively simple, and running them is even easier!
    Let's try running our tests and reviewing some of the CLI flags that Jest provides.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jest编写测试相对简单，运行它们甚至更简单！让我们尝试运行我们的测试并回顾Jest提供的某些CLI标志。
- en: Running the tests
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'To run the tests, open a terminal instance in the `/chapter-09-node/testing-example`
    folder and run the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请在`/chapter-09-node/testing-example`文件夹中打开一个终端实例，并运行以下命令：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should see the following output in your terminal:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端中看到以下输出：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you have a large number of tests, you could remove the `--verbose` flag
    from the `test` script in `package.json` and only pass the flag to the `npm test`
    command if needed. There are several other CLI flags you can pass to the `jest`
    command. The following list contains some of the more commonly used flags:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多测试，你可以从`package.json`中的`test`脚本中移除`--verbose`标志，并在需要时才将标志传递给`npm test`命令。你可以将几个其他CLI标志传递给`jest`命令。以下列表包含了一些更常用的标志：
- en: '`--bail`: Exits the test suite immediately upon the first failing test suite'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--bail`：在第一个失败的测试套件后立即退出测试套件'
- en: '`--coverage`: Collects test coverage and displays it in the terminal after
    the tests have run'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--coverage`：收集测试覆盖率，并在测试运行后显示在终端中'
- en: '`--watch`: Watches files for changes and reruns tests related to changed files'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--watch`：监视文件的变化，并在相关文件更改时重新运行测试'
- en: 'You can pass these flags to the `npm` test command by adding them after a `--`.
    For example, if you wanted to use the `--bail` flag, you''d run this command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`--`之后添加这些标志来将它们传递给`npm`测试命令。例如，如果你想使用`--bail`标志，你会运行以下命令：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can view the entire list of CLI options on the official site at [https://jestjs.io/docs/en/cli](https://jestjs.io/docs/en/cli).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方网站上查看完整的CLI选项列表：[https://jestjs.io/docs/en/cli](https://jestjs.io/docs/en/cli)。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the advantages of integrating WebAssembly with
    Node.js and demonstrated how Node.js could be used on the server and client side.
    We evaluated an Express application that uses a Wasm module to perform calculations
    on accounting transactions. We then reviewed a browser-based application that
    utilizes Webpack to import and call functions from a C file without having to
    write any Wasm instantiation code. Finally, we saw how the Jest testing framework
    can be leveraged to test a compiled module and ensure it's functioning correctly.
    In [Chapter 10](93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml), *Advanced Tools and
    Upcoming Features*, we'll cover advanced tools and discuss the features that are
    on the horizon for WebAssembly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了将 WebAssembly 与 Node.js 集成的优势，并展示了如何在使用服务器和客户端时使用 Node.js。我们评估了一个使用
    Wasm 模块对会计交易进行计算的表达式应用。然后，我们回顾了一个基于浏览器的应用，该应用利用 Webpack 从 C 文件中导入和调用函数，而无需编写任何
    Wasm 实例化代码。最后，我们看到了如何利用 Jest 测试框架来测试编译后的模块，并确保其正确运行。在[第 10 章](93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml)，*高级工具和即将推出的功能*中，我们将介绍高级工具并讨论
    WebAssembly 即将推出的功能。
- en: Questions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is one of the advantages of integrating WebAssembly with Node.js?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 WebAssembly 与 Node.js 集成的一个优点是什么？
- en: What library does the Express application use to read and write data to a JSON
    file?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Express 应用程序使用哪个库来读取和写入 JSON 文件的数据？
- en: What is the difference between loading a module in the browser and in Node.js?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器和 Node.js 中加载模块有什么区别？
- en: What technique can you use to run an `npm` script before or after an existing
    `npm` script?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么技术来在现有的 `npm` 脚本之前或之后运行一个 `npm` 脚本？
- en: What is the name of the task Webpack performs to eliminate dead code?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack 执行的消除死代码的任务叫什么名字？
- en: What is the purpose of a loader in Webpack?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack 中的加载器有什么作用？
- en: What is the difference between the `describe()` and `test()` functions in Jest?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jest 中的 `describe()` 和 `test()` 函数有什么区别？
- en: How do you pass additional CLI flags to the `npm test` command?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何向 `npm test` 命令传递额外的 CLI 标志？
- en: Further reading
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Express: [https://expressjs.com](https://expressjs.com)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express: [https://expressjs.com](https://expressjs.com)
- en: Webpack: [https://webpack.js.org](https://webpack.js.org)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack: [https://webpack.js.org](https://webpack.js.org)
- en: Jest API: [https://jestjs.io/docs/en/api](https://jestjs.io/docs/en/api)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest API: [https://jestjs.io/docs/en/api](https://jestjs.io/docs/en/api)
