<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-95"><a id="_idTextAnchor096"/>6</h1>
<h1 id="_idParaDest-96"><a id="_idTextAnchor097"/>Writing Smart Pointers</h1>
<p>In <a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a>, we examined the standard smart pointers at our disposal, with emphasis on the most important ones: <code>unique_ptr&lt;T&gt;</code> and <code>shared_ptr&lt;T&gt;</code>. These types are precious and important tools in every contemporary C++ programmer’s toolbox, and using them when appropriate leads to programs that are smaller, faster, and simpler than they would be with most handwritten alternatives.</p>
<p>This book aims to discuss how to manage memory in a C++ program. For that reason, in this chapter, we will write simple versions of both <code>unique_ptr&lt;T&gt;</code> and <code>shared_ptr&lt;T&gt;</code> to show ways in which one could write naïve-yet-workable versions of these types if needed. We <em class="italic">strongly</em> recommend that you use the standard versions in practice, not those in this book (at least in production code): standard versions have been thoroughly tested, optimized, and used by a multitude of programmers to good effect. The reason we write “homemade” flavors here is simply to develop an intuition as to how one could write such as type: there still exist companies using pre-C++11 compilers, sometimes for reasonable reasons, and there might be reasons in some settings to write a smart pointer inspired by the standard ones yet slightly different.</p>
<p>We will then examine some niches not covered by the standard smart pointers, either because they are deemed simple enough that users can roll out their own, they are deemed specialized enough that they should be covered through third-party libraries, or there is no clear path to standardizing them yet.</p>
<p>To summarize, in this chapter, we will do the following:</p>
<ul>
<li>Take a brief look at ownership semantics, those of the standard smart pointers as well as others that we could – and sometimes will – implement ourselves.</li>
<li>Implement our own naïve-yet-usable version of <code>std::unique_ptr</code> in order to grasp some of the techniques this might entail.</li>
<li>Implement our own naïve-yet-usable version of <code>std::shared_ptr</code>. Note that by “usable” here we mean usable in simple contexts, as a full implementation of something such as <code>std::shared_ptr</code> is significantly more complex than what a book such as this one can reasonably cover.</li>
<li>Implement a non-standard smart pointer with single ownership and duplication semantics, showing different techniques to achieve this objective.</li>
<li>Implement two distinct non-owning “smart” pointers that are very lightweight types yet help write better and safer code.</li>
</ul>
<p>After reading this chapter, we should have a better grasp of the techniques involved in writing types that syntactically behave as pointers but provide (or simply clarify) ownership semantics. The techniques used should be in large part reusable to other types of problems, memory-management related or not.</p>
<p>Does that sound like a plan? Let’s get to it then!</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor098"/>Technical requirements</h1>
<p><a id="_idTextAnchor099"/>You can find the code files for this chapter in the book’s GitHub repository here: <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter6">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter6</a>.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor100"/>Ownership semantics</h1>
<p>Smart pointers<a id="_idIndexMarker324"/> are all about clarifying ownership over indirectly accessed resources. If we restrict ourselves to the standard facilities, smart or not-so-smart, what we have is the following:</p>
<table class="T---Table _idGenTablePara-1" id="table001">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Type</strong></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Niche</strong></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><code>unique_ptr&lt;T&gt;</code></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Ownership semantics</strong>: Single ownership.</p>
<p><strong class="bold">Notable special member functions</strong>: Non-copyable. The destructor is responsible for destroying the pointee.</p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><code>shared_ptr&lt;T&gt;</code></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Ownership semantics</strong>: Shared ownership.</p>
<p><strong class="bold">Notable special member functions</strong>: Copying, assigning, and destroying update a shared use count. The destructor of the last co-owner is responsible for destroying both the pointee and the use count.</p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><code>T*</code></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Ownership semantics</strong>: No ownership is defined in the type system (ownership rules have to be inscribed in user code).</p>
<p><strong class="bold">Notable special member functions</strong>: Not applicable (this is a fundamental type).</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1 – Usage category per pointer type</p>
<p>It’s a small zoo, all <a id="_idIndexMarker325"/>things considered. What are the other kinds of semantics we could envision in order to fill this table? Well, there could be the following:</p>
<ul>
<li>An <code>observer_ptr&lt;T&gt;</code> type that behaves like <code>T*</code> but makes it more difficult to accidentally claim ownership with such operations as applying <code>delete</code> on the pointer (accidents happen indeed)</li>
<li>A <code>non_null_ptr&lt;T&gt;</code> type that behaves like <code>T*</code> but for which a <code>null</code> pointer never occurs, simplifying client code</li>
<li>A <code>remote_ptr&lt;T&gt;</code> type that behaves like a proxy to remote pointees</li>
<li>A <code>dup_ptr&lt;T&gt;</code> type that implements single ownership of the pointee, as <code>unique_ptr&lt;T&gt;</code> does, but is copyable and duplicates the pointee when <code>dup_ptr&lt;T&gt;</code> is copied, and so on</li>
</ul>
<p>We will not implement all of these (the <code>remote_ptr&lt;T&gt;</code> case in particular, interesting as it is, falls outside the scope of this book, and there are numerous other exotic semantics we could entertain that you are welcome to implement based on the ideas you will find in this chapter), but we will write a few. The important aspect in each case is to define clearly what the intended semantics are, ensure they are not already covered by an existing type, and make sure we implement them appropriately.</p>
<p>Let’s start with a simple implementation of what is perhaps the best-known standard smart pointer: <code>unique_ptr</code>.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor101"/>Writing your own (naïve) unique_ptr</h1>
<p>We will first <a id="_idIndexMarker326"/>try a simple, homegrown version of <code>std::unique_ptr&lt;T&gt;</code>. As mentioned at the beginning of this chapter, our goal is to develop an intuition for the kind of code required to write such a type and not to encourage you to try to replace the standard facilities: they exist, they work, they are tested, use them. Oh, and they use many cool tricks we cannot explore in this book as we want to keep the book’s size under control!</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/>Type signature</h2>
<p>As <a id="_idIndexMarker327"/>mentioned in <a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a>, <code>unique_ptr&lt;T&gt;</code> does not really exist as the type is, in fact, <code>unique_ptr&lt;T,D&gt;</code>, where <code>D</code> defaults to <code>default_deleter&lt;T&gt;</code>.</p>
<p>We will cover both forms (scalar and array) of <code>unique_ptr</code>. The reason for these two specializations is that for <code>T[]</code>, we will want <code>unique_ptr</code> to expose <code>operator[]</code> but we will not want to expose this for a scalar <code>T</code> type.</p>
<p>Let’s start with the basic deleter types we will offer. Note that users can supply other deleter types if needed as long as they use the same signature for <code>operator()</code>:</p>
<pre class="source-code">
namespace managing_memory_book {
   // basic deleter types
   template &lt;class T&gt;
   struct deleter_pointer_wrapper {
      void (*pf)(T*);
      deleter_pointer_wrapper(void (*pf)(T*)) : pf{ pf } {
      }
      void operator()(T* p) const { pf(p); }
   };
   template &lt;class T&gt;
   struct default_deleter {
      void operator()(T* p) const { delete p; }
   };
   template &lt;class T&gt;
   struct default_deleter&lt;T[]&gt; {
      void operator()(T* p) const { delete[] p; }
   };
   // ...
}</pre> <p>What <a id="_idIndexMarker328"/>we have so far are three deleter types that are callable in the same way and that are all class types (the reason for this will become evident soon but know that there’s sometimes value in uniformity). The odd one is <code>deleter_pointer_wrapper&lt;T&gt;</code>, which wraps a copyable state (a function pointer) but otherwise behaves like the other two: when called on <code>T*</code>, it applies some (user-supplied) function to that pointer.</p>
<p>The next step will be to choose the form of <code>unique_ptr&lt;T,D&gt;</code>. We will expect most deleters to be stateless and <a id="_idIndexMarker329"/>use <code>deleter_pointer_wrapper&lt;T&gt;</code>. To choose between these two options, we will need to detect whether <code>D</code> is a function pointer or not, which we will achieve using our own <code>is_deleter_function_candidate&lt;T&gt;</code> trait.</p>
<p>The part of our implementation that detects deleter function candidates is the following:</p>
<pre class="source-code">
#include &lt;type_traits&gt;
namespace managing_memory_book {
   // ...
   template &lt;class T&gt;
   struct is_deleter_function_candidate
      : std::false_type {};
   template &lt;class T&gt;
   struct is_deleter_function_candidate&lt;void (*)(T*)&gt;
      : std::true_type {};
   template &lt;class T&gt;
   constexpr auto is_deleter_function_candidate_v =
      is_deleter_function_candidate&lt;T&gt;::value;
   // ...
}</pre> <p>This bit is <a id="_idIndexMarker330"/>probably self-explanatory, but the idea is that most types are not candidates to be deleter functions, but functions of the <code>void(*)(T*)</code> type are.</p>
<p>We then get to the general <code>unique_ptr&lt;T&gt;</code> type, used for scalars. We will use our deleter function detection trait to conditionally choose between <code>D</code> types and <code>deleter_pointer_wrapper&lt;T&gt;</code> as the base class for our type, and cast this to a pointer to that base in order to release the resource in our destructor:</p>
<pre class="source-code">
namespace managing_memory_book {
   // ...
   // unique_ptr general template
   template &lt;class T, class D = default_deleter&lt;T&gt;&gt;
   class unique_ptr : std::conditional_t &lt;
      is_deleter_function_candidate_v&lt;D&gt;,
      deleter_pointer_wrapper&lt;T&gt;, D
   &gt; {
      using deleter_type = std::conditional_t &lt;
         is_deleter_function_candidate_v&lt;D&gt;,
         deleter_pointer_wrapper&lt;T&gt;,
         D
      &gt;;
      T* p = nullptr;
   public:
      unique_ptr() = default;
      unique_ptr(T* p) : p{ p } {
      }
      unique_ptr(T* p, void (*pf)(T*))
         : deleter_type{ pf }, p{ p } {
      }
      ~unique_ptr() {
         (*static_cast&lt;deleter_type*&gt;(this))(p);
      }
   };
   // ...
}</pre> <p>The same <a id="_idIndexMarker331"/>approach, essentially, is taken for the <code>T[]</code> specialization of our type:</p>
<pre class="source-code">
namespace managing_memory_book {
   // ...
   // unique_ptr specialization for arrays
   template &lt;class T, class D&gt;
   class unique_ptr&lt;T[], D&gt; : std::conditional_t &lt;
      is_deleter_function_candidate_v&lt;D&gt;,
      deleter_pointer_wrapper&lt;T&gt;,
      D
   &gt; {
      using deleter_type = std::conditional_t &lt;
         is_deleter_function_candidate_v&lt;D&gt;,
         deleter_pointer_wrapper&lt;T&gt;,
         D
      &gt;;
      T* p = nullptr;
   public:
      unique_ptr() = default;
      unique_ptr(T* p) : p{ p } {
      }
      unique_ptr(T* p, void (*pf)(T*))
         : deleter_type{ pf }, p{ p } {
      }
      ~unique_ptr() {
         (*static_cast&lt;deleter_type*&gt;(this))(p);
      }
   };
}</pre> <p>Notice that a<a id="_idIndexMarker332"/> default <code>unique_ptr</code> will behave conceptually like a <code>null</code> pointer, something that should be unsurprising to most. Now that we have the basic idea in place, let’s explore the semantics specific to <code>unique_ptr</code>.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor103"/>Special member functions</h2>
<p>The code<a id="_idIndexMarker333"/> for the special member functions will be the same for both the scalar and the array forms of <code>unique_ptr</code>. We have already looked at the destructor and the default constructor in the previous section, so let’s look at the other four, in pairs:</p>
<ul>
<li>We want the type to be non-copyable, as it represents sole ownership of the pointee (if it was copyable, would ownership of the pointee belong to the original or the copy?)</li>
<li>We want move operations to implement the transfer of ownership</li>
</ul>
<p>The code for both the general case and its array specialization will be as follows (note that the code uses <code>std::exchange()</code> and <code>std::swap()</code>, both found in the <code>&lt;</code><code>utility&gt;</code> header):</p>
<pre class="source-code">
// ...
      unique_ptr(const unique_ptr&amp;) = delete;
      unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
      void swap(unique_ptr &amp;other) noexcept {
         using std::swap;
         swap(p, other.p);
      }
      unique_ptr(unique_ptr &amp;&amp;other) noexcept
         : p{ std::exchange(other.p, nullptr) } {
      }
      unique_ptr&amp; operator=(unique_ptr &amp;&amp;other) noexcept {
         unique_ptr{ std::move(other) }.swap(*this);
         return *this;
      }
// ...</pre> <p>Most of this should be self-evident by this point. You might notice the use of <code>std::exchange()</code>, which has the effect of copying <code>other.p</code> to <code>this-&gt;p</code> and then copying <code>nullptr</code> to <code>other.p</code>, implementing the transfer of ownership as expected. Note that move operations for our type are trivial and never throw, both of which are highly desirable properties.</p>
<p>There are some<a id="_idIndexMarker334"/> operations that will be implemented in both the general case and the array case, namely, <code>operator bool</code> (<code>true</code> only if the object does not model a <code>null</code> pointer), <code>empty()</code> (<code>true</code> only if the object does model a <code>null</code> pointer), as well as <code>operator==()</code> and <code>operator!=()</code>. These are essentially trivial to implement. The other member function we will want to expose is <code>get()</code> in both its <code>const</code> and non-<code>const</code> versions in order to expose the underlying pointer for client code that needs to interact with lower-level functions such as system calls:</p>
<pre class="source-code">
// ...
      bool empty() const noexcept { return !p; }
      operator bool() const noexcept { return !empty(); }
      bool operator==(const unique_ptr &amp;other)
         const noexcept {
         return p == other.p;
      }
      // inferred from operator==() since C++20
      bool operator!=(const unique_ptr &amp;other)
         const noexcept {
         return !(*this == other);
      }
      T *get() noexcept { return p; }
      const T *get() const noexcept { return p; }
// ...</pre> <p>As mentioned in the comments in the preceding code excerpt, one does not need to explicitly implement <code>operator!=()</code> since C++20 as long as <code>operator==()</code> offers the <a id="_idIndexMarker335"/>expected signature. The compiler will synthesize <code>operator!=()</code> from <code>operator==()</code>, quite simply.</p>
<p>Now, let’s take a look at how the <code>operator*()</code>, <code>operator-&gt;()</code>, and <code>operator[]()</code> pointer-like functions are implemented.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/>Pointer-like functions</h2>
<p>The <a id="_idIndexMarker336"/>pointer-like functions are different for the scalar case and the array case. For pointer-to-scalar, we will want to implement <code>operator*()</code> and <code>operator-&gt;()</code>:</p>
<pre class="source-code">
// ...
      T&amp; operator*() noexcept { return *p; }
      const T&amp; operator*() const noexcept { return *p; }
      T* operator-&gt;() noexcept { return p; }
      const T* operator-&gt;() const noexcept { return p; }
// ...</pre> <p>The <code>operator-&gt;()</code> member function is a strange beast: when used on an object, it will be reinvoked on the returned object (and again on that returned object, and so on) until something returns a raw pointer, at which point the compiler will know what to do. It’s a very powerful mechanism.</p>
<p>For pointer-to-array (the <code>unique_ptr&lt;T[]&gt;</code> specialization), we will want to implement <code>operator[]</code>, which will make more sense than either <code>operator*()</code> or <code>operator-&gt;()</code>:</p>
<pre class="source-code">
// ...
      T&amp; operator[](std::size_t n) noexcept {
         return p[n];
      }
      const T&amp; operator[](std::size_t n) const noexcept {
         return p[n];
      }
// ...</pre> <p>You might<a id="_idIndexMarker337"/> notice the apparent duplication of these member functions as each one is exposed in both a <code>const</code> and non-<code>const</code> form, a “trend” started by the <code>get()</code> member function a bit earlier. This is a <em class="italic">syntactic</em> resemblance as they are <em class="italic">semantically</em> different: in particular, only the <code>const</code> form is available through a <code>const </code><code>unique_ptr&lt;T&gt;</code> object.</p>
<p>If you have a C++23 compiler, you can make it so the compiler will synthesize the forms you use in practice given a properly written set of template member functions:</p>
<pre class="source-code">
// the following is for both the array and non-array cases
<strong class="bold">template &lt;class U&gt;</strong>
   <strong class="bold">decltype(auto)</strong> get(<strong class="bold">this U &amp;&amp; self</strong>) noexcept {
      return <strong class="bold">self.p</strong>;
   }
// the following two are only for the non-array case
<strong class="bold">template &lt;class U&gt;</strong>
   <strong class="bold">decltype(auto)</strong> operator*(<strong class="bold">this U &amp;&amp; self</strong>) noexcept {
      return <strong class="bold">*(self.p)</strong>;
   }
<strong class="bold">template &lt;class U&gt;</strong>
   <strong class="bold">decltype(auto)</strong> operator-&gt;(<strong class="bold">this U &amp;&amp; self</strong>) noexcept {
      return <strong class="bold">self.p</strong>;
   }
// the following is only for the array case
<strong class="bold">template &lt;class U&gt;</strong>
   <strong class="bold">decltype(auto)</strong> operator[](<strong class="bold">this U &amp;&amp; self</strong>,
                             std::size_t n) noexcept {
   return <strong class="bold">self.p[n]</strong>;
}</pre> <p>This reduces the <a id="_idIndexMarker338"/>number of member functions we have to write by half. How does this work? Well, C++23 introduces the “deduced <code>this</code>” mechanism that allows one to explicitly mark the first argument of a member function with the <code>this</code> keyword. Doing so and combining it with a forwarding reference (the <code>U&amp;&amp;</code> type) lets the compiler deduce the <code>const</code>-ness (or lack thereof) of <code>this</code>, in effect, expressing both the <code>const</code> and non-<code>const</code> versions in a single function. Note the <code>decltype(auto)</code> return types that accompany these functions, which infer both <a id="_idIndexMarker339"/>the <code>return</code> statement.</p>
<p>And that’s it! We now have a simple, yet functional <code>unique_ptr&lt;T&gt;</code> implementation that works for most use cases.</p>
<p>Of course, as nice as it is, <code>unique_ptr&lt;T&gt;</code> is not a panacea and there are other needs to be covered in real programs. Let’s move on to a simplified implementation of <code>shared_ptr&lt;T&gt;</code> to see how we could implement shared ownership semantics.</p>
<p>A simple program that uses our homemade <code>unique_ptr&lt;T&gt;</code> with a default deleter would be as follows:</p>
<pre class="source-code">
// ... (our own unique_ptr&lt;T&gt; goes here...)
struct X {};
int main() {
   unique_ptr&lt;X&gt; p{ new X };
} // X::~X() called here</pre> <p>Another that uses a custom deleter would be as follows:</p>
<pre class="source-code">
// ... (our own unique_ptr&lt;T&gt; goes here...)
class X {
   ~X(){}
public:
   static void destroy(X *p) { delete p; }
};
int main() {
   unique_ptr&lt;X, &amp;X::destroy&gt; p{ new X };
} // X::destroy(p.get()) called here</pre> <h1 id="_idParaDest-103"><a id="_idTextAnchor105"/>Writing your own (naïve) shared_ptr</h1>
<p>A <code>shared_ptr&lt;T&gt;</code> type is a <a id="_idIndexMarker340"/>difficult beast to implement and a harder beast yet to optimize. The invitation to use the standard version of existing smart pointers is stronger in this case than it was for <code>unique_ptr&lt;T&gt;</code>: this type is hard to get right, and the standard version benefits from years of experience and testing. Only use the naïve version in this section for experimentation (it works and does the job for simple cases, but writing an industrial-strength implementation is major-league work).</p>
<p>The main difficulty when writing a <code>shared_ptr</code> is that it’s a type with two responsibilities: it co-owns both the pointee and the usage counter, requiring some measure of care, especially with respect to exception safety. The single responsibility principle of classical object-oriented programming is a sound principle: a type with a single responsibility is exceedingly simpler to get right than a type with two or more responsibilities.</p>
<p>To keep our proposition simple, we will eschew many details of the standard <code>shared_ptr</code> contract, limiting ourselves to managing a scalar <code>T</code>. Let’s take this type step by step:</p>
<pre class="source-code">
#include &lt;atomic&gt;
#include &lt;utility&gt;
namespace managing_memory_book {
   // naïve shared_ptr
   template &lt;class T&gt;
   class shared_ptr {
      T* p = nullptr;
      std::atomic&lt;long long&gt; *ctr = nullptr;
      // ...</pre> <p>As mentioned <a id="_idIndexMarker341"/>previously, <code>shared_ptr&lt;T&gt;</code> is responsible for <code>T*</code> and a pointer to a client counter, both of which need to be managed and shared between co-owners. Note that our shared counter is a pointer to an atomic integral since <code>shared_ptr&lt;T&gt;</code> is particularly relevant in multithreaded cases where one does not know which of the threads will be the last user of the object. For that reason, operations such as incrementing and decrementing the counter require synchronization to avoid incurring a <em class="italic">data race</em>.</p>
<p class="callout-heading">Avoiding data races</p>
<p class="callout">If a program meets a situation where a given object is (a) accessed concurrently by at least two threads, (b) at least one of these accesses is a write, and (c) there is no synchronization, then that program has what we <a id="_idIndexMarker342"/>call a <strong class="bold">data race</strong> and we essentially lose the capacity to reason about it from the source code. This is a really bad situation.</p>
<p class="callout">In our case, operations on the shared counter will most probably be done concurrently and, as such, they have to be synchronized. This explains our use of the low-level synchronization objects that are atomic integrals as counters.</p>
<p>Constructing a <code>shared_ptr&lt;T&gt;</code> object can be tricky:</p>
<ul>
<li>By default, we will define <code>shared_ptr&lt;T&gt;</code> to be empty, thus conceptually equivalent to a <code>null</code> pointer.</li>
<li>The constructor of <code>shared_ptr&lt;T&gt;</code> that takes <code>T*</code> as an argument represents the act of <em class="italic">taking ownership</em> of the pointee. For that reason, if an exception is thrown when allocating the counter, that pointee is destroyed.</li>
<li>The copy constructor will represent <em class="italic">sharing ownership</em> of the pointee, making sure to consider the case where the source object models a <code>null</code> pointer.</li>
<li>The move constructor models the <em class="italic">transfer of ownership</em>. As is often the case for move operations, it’s very fast and it shows highly predictable behavior.</li>
</ul>
<p>As can be seen<a id="_idIndexMarker343"/> from the following code excerpt, with a type that has more than one responsibility, even construction is a delicate endeavor. In the constructor that takes <code>T*</code>, we might need to allocate the shared counter, which might throw, a situation we need to manage. In the copy constructor, we need to take into account that the argument might model an empty <code>shared_ptr&lt;T&gt;</code>, in which case the shared counter would be <code>null</code>:</p>
<pre class="source-code">
      // ...
   public:
      shared_ptr() = default;
      shared_ptr(T* p) : p{ p } {
         if(p) try {
            ctr = new std::atomic&lt;long long&gt;{ 1LL };
         } catch(...) {
            delete p;
            throw;
         }
      }
      shared_ptr(const shared_ptr &amp;other)
         : p{ other.p }, ctr{ other.ctr } {
         if(ctr) ++(*ctr);
      }
      shared_ptr(shared_ptr &amp;&amp;other) noexcept
         : p{ std::exchange(other.p, nullptr) },
           ctr{ std::exchange(other.ctr, nullptr) } {
      }
      bool empty() const noexcept { return !p; }
      operator bool() const noexcept { return !empty(); }
// ...</pre> <p>The <code>empty()</code>and <code>operator bool()</code> member functions have been included in that excerpt since these functions directly tie into the way the default constructor (the empty state of this type) is expressed.</p>
<p>The <a id="_idIndexMarker344"/>assignment operator is unsurprising: copy assignment models the act of releasing control of the currently held resource and sharing the resource of its argument, whereas move assignment models the act of releasing control of the currently held resource and transferring control of the resource held by the argument to the assigned-to object:</p>
<pre class="source-code">
      // ...
      void swap(shared_ptr &amp;other) noexcept {
         using std::swap;
         swap(p, other.p);
         swap(ctr, other.ctr);
      }
      shared_ptr&amp; operator=(const shared_ptr &amp;other) {
         shared_ptr{ other }.swap(*this);
         return *this;
      }
      shared_ptr&amp; operator=(shared_ptr &amp;&amp;other) noexcept {
         shared_ptr{ std::move(other) }.swap(*this);
         return *this;
      }
      // ...</pre> <p>Destruction is probably the trickiest aspect of this type. We want to make sure that the last owner of the pointee destroys it, to avoid immortal objects. The key point is that <code>shared_ptr&lt;T&gt;</code> should<a id="_idIndexMarker345"/> only destroy the pointed-to <code>T</code> object if it was the last user of that object.</p>
<p>There are at least two “self-evident” naïve algorithms that do not work. One is <em class="italic">If </em><code>ctr</code><em class="italic"> is not null, then if </em><code>*ctr==1</code><em class="italic">, delete </em><code>p</code><em class="italic"> and delete </em><code>ctr</code>. This algorithm allows the case where two threads enter the destructor concurrently with <code>*ctr==2</code>. In that case, it is possible that neither thread sees <code>*ctr==1</code>, and the pointees are never destroyed:</p>
<div><div><img alt="Figure 6.1 – Race condition leading to an immortal object" src="img/B21071_06_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Race condition leading to an immortal object</p>
<p>The other is <em class="italic">If </em><code>ctr</code><em class="italic"> is not null, then decrement </em><code>*ctr</code><em class="italic">. If </em><code>*ctr==0</code><em class="italic">, delete </em><code>p</code><em class="italic"> and delete </em><code>ctr</code>. This <a id="_idIndexMarker346"/>algorithm allows the case where two threads enter the destructor concurrently with <code>*ctr==2</code>, and then both concurrently decrement <code>*ctr</code> leading to the possibility of both seeing <code>*ctr==0</code>, resulting in a double deletion of the pointees:</p>
<div><div><img alt="Figure 6.2 – Race condition leading to double deletion of the object" src="img/B21071_06_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Race condition leading to double deletion of the object</p>
<p>Both cases are bad, albeit for different reasons, so we need to do better. The difficult part of the process is ensuring that the executing thread can be made aware that it is the one that made it so <code>*ctr</code> became zero. The general solution to such a problem requires enclosing two steps (changing the value of a variable only if it had a known-beforehand value and being informed that this write did or did not happen) in a single operation, something that must be supported by at least one hardware operation on a multicore machine.</p>
<p>C++ offers abstractions over these essential hardware operations through atomics. One such atomic <a id="_idIndexMarker347"/>operation is named <code>compare_exchange_weak()</code>, which takes the <code>expected</code> value (what is believed to be in the variable) and the <code>desired</code> value (what one seeks to write to that variable, but only if it holds <code>expected</code>), and returns <code>true</code> only if the <em class="italic">write</em> actually happened. For convenience, <code>expected</code> is taken by reference and updated with the value actually held by the object at that time, since this function is usually called in a loop until a successful write of <code>desired</code> actually occurs, which involves re-reading <code>expected</code> every time to update the function’s view of the variable’s current state.</p>
<p class="callout-heading">A dance with pictures</p>
<p class="callout">This <code>expected</code> and <code>desired</code> dance can be seen as taking pictures. A thread wants to decrement <code>*ctr</code>, but <code>*ctr</code> holds a mutable state and is accessed concurrently, which means its value can change at any time. Thus, we take a picture (<code>expected</code>) in a local variable under our control. We base the value we want to write (<code>desired</code>) on that local picture that we know did not change. Then, we try to act based on that (potentially obsolete) knowledge and see whether our assumption (that <code>*ctr</code> holds <code>expected</code>) is held. This lets us know that we were the ones to write <code>desired</code> in <code>*ctr</code>.</p>
<p>With this knowledge, a possible implementation of the destructor would be the following:</p>
<pre class="source-code">
      // ...
      ~shared_ptr() {
         if(ctr) {
            auto expected = ctr-&gt;load();
            auto desired = expected - 1;
            while(ctr-&gt;compare_exchange_weak(expected,
                                             desired))
                desired = expected - 1;
            if(desired == 0) { // I was the last user of *p
               delete p;
               delete ctr;
            }
         }
      }
      // ...</pre> <p>After the loop, we <a id="_idIndexMarker348"/>know that we wrote <code>desired</code> when <code>*ctr</code> held <code>expected</code>, thus if <code>desired</code> was <code>0</code> (implying <code>expected</code> was <code>1</code>), we know we were the last user of that pointee. Yes, it’s subtle. And this is only a toy version of <code>shared_ptr&lt;T&gt;</code>. We could optimize it in many ways, but that goes beyond the scope of this book.</p>
<p class="callout-heading">A simpler solution</p>
<p class="callout">The solution shown here with <code>compare_exchange_weak()</code> is one of many options at our disposal. It was preferred for this book because it’s an interesting approach for a general solution to the concurrent update problem and opens up optimization opportunities if you are comfortable with memory order constraints (which we will not go into here). In this specific case, we could have replaced the loop with something like <code>if((*ctr)-- == 1)</code>, as if one decrements <code>*ctr</code> atomically and the value previously held was <code>1</code>, then we know for a fact that <code>*ctr</code> is now <code>0</code>.</p>
<p>The other important member functions of our <code>shared_ptr&lt;T&gt;</code> implementation involve comparison (<code>operator==</code> and <code>operator!=</code>), the <code>get()</code> member functions that let one obtain the underlying, raw <code>T*</code> for code that needs it, and the indirection operators that are <code>operator*()</code> and <code>operator-&gt;()</code>:</p>
<pre class="source-code">
      // ...
      bool operator==(const shared_ptr &amp;other)
         const noexcept { return p == other.p; }
      // inferred from operator==() since C++20
      bool operator!=(const shared_ptr &amp;other)
         const noexcept { return !(*this == other); }
      T *get() noexcept { return p; }
      const T *get() const noexcept { return p; }
      T&amp; operator*() noexcept { return *p; }
      const T&amp; operator*() const noexcept { return *p; }
      T* operator-&gt;() noexcept { return p; }
      const T* operator-&gt;() const noexcept { return p; }
   };
}</pre> <p>If you want to, feel<a id="_idIndexMarker349"/> free to apply the “deduced <code>this</code>” C++23 feature shown in the <code>unique_ptr</code> section earlier to simplify this code. Also remember that in C++20, <code>operator!=()</code> will be inferred from <code>operator==()</code> and does not need to be written explicitly in the source code.</p>
<p>A very simple example of client code for this smart pointer would be the following:</p>
<pre class="source-code">
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;iostream&gt;
using namespace std::literals;
struct X {
   int n;
   X(int n) : n{ n } {}
   ~X() { std::cout &lt;&lt; "X::~X()\n"; }
};
int main() {
   using managing_memory_book::shared_ptr;
   std::mt19937 prng{ std::random_device{}() };
   std::uniform_int_distribution&lt;int&gt; die{ 200, 300 };
   shared_ptr&lt;X&gt; p{ new X{ 3 } };
   using std::chrono::milliseconds; // shortcut
   std::thread th0{ [p, dt = die(prng)] {
      std::this_thread::sleep_for(milliseconds{dt});
      std::cout &lt;&lt; "end of th0, p-&gt;n : " &lt;&lt; p-&gt;n &lt;&lt; '\n';
   } };
   std::thread th1{ [p, dt = die(prng)] {
      std::this_thread::sleep_for(milliseconds{dt});
      std::cout &lt;&lt; "end of th1, p-&gt;n : " &lt;&lt; p-&gt;n &lt;&lt; '\n';
   } };
   th1.detach();
   th0.detach();
   std::this_thread::sleep_for(350ms);
   std::cout &lt;&lt; "end main()\n";
}</pre> <p>In this <a id="_idIndexMarker350"/>example, <code>th0</code> and <code>th1</code> both sleep for a pseudorandom number of milliseconds, then display something and conclude execution, so we cannot know in advance which of <code>th0</code> and <code>th1</code> will conclude first; both threads are detached, which means there is no later point at which we will call <code>join()</code> on them, so we cannot suppose that <code>main()</code> is the last user of the shared resource.</p>
<p>The example is contrived to keep it simple, and it bears repeating that as <code>shared_ptr&lt;T&gt;</code> is significantly more costly to use than <code>unique_ptr&lt;T&gt;</code> would be, one will generally prefer the latter over the former when there is a clear last owner of the resource.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>A few words on make_shared()</h2>
<p>It is possible <a id="_idIndexMarker351"/>that when reading about C++ in general and <code>shared_ptr&lt;T&gt;</code> in particular, you might have read that, whenever possible, it is recommended practice to replace this:</p>
<pre class="source-code">
std::shared_ptr&lt;X&gt; p{ new X { /* ... args ... */ };</pre> <p>Replace it with the following:</p>
<pre class="source-code">
auto p= std::make_shared&lt;X&gt;( /* ... args ... */ );</pre> <p>If that is the case, you might be wondering (a) why this is recommended practice, and (b) why we have not addressed it yet. The answer to (a) we can provide now, but the answer to (b) is that we will need to wait until we reach <a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a> to have the tools and knowledge required to implement such a facility.</p>
<p>To understand why we recommend preferring the <code>make_shared&lt;T&gt;()</code> factory function to a direct call to the <code>shared_ptr&lt;T&gt;</code> constructor, the key idea is that with the <code>shared_ptr&lt;T&gt;</code> constructor, the <code>T</code> object is allocated by client code, and given to <code>shared_ptr&lt;T&gt;</code> under construction, which takes ownership of that pointer and allocates a shared counter <em class="italic">separately</em>. We then end up with two allocations (the <code>T</code> object and the counter), probably on separate cache lines.</p>
<p>Now, if we go through <code>make_shared&lt;T&gt;()</code>, this factory function is responsible for allocating both the <code>T</code> object <em class="italic">and</em> the counter, perfectly forwarding the arguments received by the function to the <code>T</code> constructor. Since the same function performs both allocations, it can fuse them in a single allocation of a memory block that contains both the <code>T</code> object and the counter, <em class="italic">putting them both on the same cache line</em>. This can lead to enhanced performance characteristics if a single thread tends to read from both pointers (<code>T*</code> and the counter) in a short time span, but (as can sometimes be the case) can be hurtful if another thread observes frequent changes to the counter’s value. As is often the case in optimization-related situations, measure and make sure what works well in general is also good for your own, specific use cases.</p>
<p>Clearly, to achieve this optimization, we need to be able to create such a block (conceptually, a struct containing <code>T</code> and an atomic integral) and make sure that <code>shared_ptr&lt;T&gt;</code> can contain either representation (two separate pointers or a pointer to a block with two objects) while remaining usable and efficient. Controlled use of the tricks seen in <a href="B21071_02.xhtml#_idTextAnchor027"><em class="italic">Chapter 2</em></a> and <a href="B21071_03.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a> will be helpful when we get there.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Writing a policy-based duplicating pointer</h1>
<p>Let’s leave aside the<a id="_idIndexMarker352"/> standard smart pointers for a moment. Suppose we seek to write a smart pointer type whose semantics fit neither the sole ownership mold of <code>std::unique_ptr&lt;T&gt;</code> nor the shared ownership mold of <code>std::shared_ptr&lt;T&gt;</code>. For the sake of this example, suppose more specifically that we want single ownership semantics but, unlike <code>std::unique_ptr&lt;T&gt;</code>, which is movable but non-copyable, we want duplication of the pointer to lead to duplication of the pointee. What can we do?</p>
<p>Well, this is C++, so we can of course write our own. Let’s call this new smart pointer type of ours <code>dup_ptr&lt;T&gt;</code> (for “duplicating pointer”, or “pointer that duplicates the pointee”). Since we examined how one could implement sole ownership through our homemade <code>unique_ptr&lt;T&gt;</code> earlier in this chapter, this section will mostly focus on the question of duplicating the pointee.</p>
<p>What do we mean by duplication? Well, there are two expected cases: copying an object of a non-polymorphic type and copying an object of a polymorphic type, with polymorphic meaning “with at least one <code>virtual</code> member function” for the sake of this example. Of course, programmers, being highly inventive creatures, know that someone will end up with more exotic situations so we will try to take care of the aforementioned “expected cases” and leave a door open for those with unusual applications.</p>
<p>Why is there a difference between polymorphic and non-polymorphic types? Consider the following program:</p>
<pre class="source-code">
struct X { int n; };
struct B {
   int n;
   B(int n) : n{ n } {}
   virtual ~B() = default;
};
struct D0 : B {
   D0(int n) : B{ n } { /* ... */ }
   // ...
};
struct D1 : B {
   D1(int n) : B{ n } { /* ... */ }
   // ...
};
// precondition: p != nullptr (to keep things simple)
X* duplicate(X *p) {
   return new X{ *p }; // Ok
}
// precondition: p != nullptr (to keep things simple)
B* duplicate(B *p) {
   return new B{ *p }; // Bad idea!
}
#include &lt;memory&gt;
int main() {
   using std::unique_ptr;
   X x{ 3 };
   unique_ptr&lt;X&gt; px { duplicate(&amp;x) };
   D0 d0{ 4 };
   unique_ptr&lt;B&gt; pb{ duplicate(&amp;d0) }; // trouble ahead
}</pre> <p>We can <a id="_idIndexMarker353"/>suppose that the <code>duplicate(X*)</code> function can safely create an object of the <code>X</code> type since <code>X</code> has no <code>virtual</code> member function and, as such, is probably not meant to serve as a public base class. However, there is a high probability that <code>duplicate(B*)</code> does the wrong thing by calling the constructor of <code>B</code>, as <code>B*</code> passed as an argument could be <code>B</code> or a pointer to an object of any class derived from <code>B</code> (here, <code>D0*</code>). Hence, calling <code>new B{ *p };</code> only constructs the base part, slicing away any state from the pointed-to object and resulting in a probably incorrect program.</p>
<p>As is well<a id="_idIndexMarker354"/> known in object-oriented programming circles, the customary way to duplicate an object of a polymorphic type is through <em class="italic">subjective duplication</em>, otherwise<a id="_idIndexMarker355"/> known as <code>virtual</code> member function, the only entity that can really claim to know the type of the pointee is… the pointee itself.</p>
<p>What <code>dup_ptr&lt;T&gt;</code> will do, then, is to pick a <em class="italic">duplication policy</em> based on the characteristics of <code>T</code>: by default, if <code>T</code> is polymorphic, then we will duplicate through cloning; otherwise, we will duplicate through copying. Of course, we will let the client code specify a custom duplication mechanism if needed.</p>
<p>We will explore three approaches to this selection of a default duplication policy: an intrusive approach based on interfaces, a non-intrusive approach based on traits and compile-time detection of a cloning member function using C++17 features, and another non-intrusive approach based on C++20 concepts.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor108"/>Detection through interfaces</h2>
<p>One thing <a id="_idIndexMarker356"/>we could do in user code is impose that cloneable types implement a specific interface, as in this example:</p>
<pre class="source-code">
struct cloneable {
   virtual cloneable * clone() const = 0;
   virtual ~cloneable() = default;
};</pre> <p>Such a solution is probably not standardization-worthy: it is intrusive, imposes some overhead (we are assuming that cloneable types will be polymorphic types, something that is likely but not mandatory), and so on. It can be a solution for your own code base, of course. Applying this idea to a revisitation of the example that mishandled duplication of a polymorphic type, earlier, we end up with the following:</p>
<pre class="source-code">
<strong class="bold">// ... type cloneable</strong>
struct X { int n; };
struct B : <strong class="bold">cloneable { // every B is cloneable</strong>
   int n;
   B(int n) : n{ n } {}
   virtual ~B() = default;
   B * clone()
<strong class="bold">protected: // cloneable types are meaningfully copied</strong>
<strong class="bold">           // in a subjective manner</strong>
<strong class="bold">   B(const B&amp;) = default;</strong>
};
struct D0 : B {
   D0(int n) : B{ n } { /* ... */ }
   <strong class="bold">D0* clone() const override { return new D0{ *this }; }</strong>
   // ...
};
struct D1 : B {
   D1(int n) : B{ n } { /* ... */ }
   <strong class="bold">D1* clone() const override { return new D1{ *this }; }</strong>
   // ...
};</pre> <p>Now, suppose<a id="_idIndexMarker357"/> we want to develop a skeleton of <code>dup_ptr&lt;T&gt;</code> that copies types that are not derived from <code>cloneable</code> and clones types that are. To that effect, we can use the <code>std::conditional</code> type trait and choose between two function object types, a <code>Copier</code> type that copies and a <code>Cloner</code> type that clones:</p>
<pre class="source-code">
<strong class="bold">// ... type cloneable</strong>
<strong class="bold">struct Copier {</strong>
<strong class="bold">   template &lt;class T&gt; T* operator()(const T *p) const {</strong>
<strong class="bold">      return new T{ *p };</strong>
<strong class="bold">   }</strong>
<strong class="bold">};</strong>
<strong class="bold">struct Cloner {</strong>
<strong class="bold">   template &lt;class T&gt; T* operator()(const T *p) const {</strong>
<strong class="bold">      return p-&gt;clone();</strong>
<strong class="bold">   }</strong>
<strong class="bold">};</strong>
#include &lt;type_traits&gt;
template &lt;class T,
          <strong class="bold">class Dup = std::conditional_t&lt;</strong>
<strong class="bold">             std::is_base_of_v&lt;cloneable, T&gt;,</strong>
<strong class="bold">             Cloner, Copier</strong>
<strong class="bold">          &gt;&gt;</strong>
class dup_ptr {
   T *p{};
   // use an object of type <strong class="bold">Dup</strong> when duplication is
   // required: copy constructor and copy assignment
   // ...
public:
   dup_ptr(const dup_ptr &amp;other)
      : p{ other.empty()? nullptr <strong class="bold">: Dup{}(other.p)</strong> } {
   }
   // ...
};</pre> <p>This <a id="_idIndexMarker358"/>implementation supposes a stateless (no member variables) <code>Dup</code> type, which is highly probable but should be documented in practice (if we accept stateful <code>Dup</code> types, we need to instantiate a <code>Dup</code> object and write code to copy and move that object, leading to a much more involved implementation). With this implementation, any type that derives from <code>cloneable</code> will be cloned and other types will be copied, unless the user code supplies an exotic implementation of the <code>Dup</code> type.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor109"/>Detection through traits</h2>
<p>If we do not <a id="_idIndexMarker359"/>want to impose a base class to our <code>cloneable</code> types, we can use type traits to detect the presence of a <code>const</code>-qualified <code>clone()</code> member function and suppose this is a reasonable claim that cloning is a better choice than copying. Note that this non-intrusiveness supposes an unspoken agreement on the meaning of <code>clone()</code>.</p>
<p>We can achieve this in many ways, but the cleanest and most general one probably uses Dr. Walter Brown’s <code>std::void_t</code> type, found in <code>&lt;type_traits&gt;</code> since C++17:</p>
<pre class="source-code">
<strong class="bold">// types Cloner and Copier (see above)</strong>
<strong class="bold">template &lt;class, class = void&gt;</strong>
<strong class="bold">   struct has_clone : std::false_type { };</strong>
<strong class="bold">template &lt;class T&gt;</strong>
<strong class="bold">   struct has_clone &lt;T, std::void_t&lt;</strong>
<strong class="bold">      decltype(std::declval&lt;const T*&gt;()-&gt;clone())</strong>
<strong class="bold">   &gt;&gt; : std::true_type { };</strong>
<strong class="bold">template &lt;class T&gt;</strong>
<strong class="bold">   constexpr bool has_clone_v = has_clone&lt;T&gt;::value;</strong>
template &lt;class T, <strong class="bold">class Dup = std::conditional_t&lt;</strong>
<strong class="bold">             has_clone_v&lt;T&gt;, Cloner, Copier</strong>
&gt;&gt; class dup_ptr {
   T *p{};
public:
   // ...
   dup_ptr(const dup_ptr &amp;other)
      : p{ other.empty()? nullptr <strong class="bold">: Dup{}(other.p)</strong> } {
   }
   // ...
};</pre> <p>The <code>std::void_t</code> type is a brilliant piece of work that lets knowledgeable people simulate, in a<a id="_idIndexMarker360"/> limited manner but for general expressions, what <code>requires</code> has allowed since C++20. The way to read this example is as follows:</p>
<ul>
<li>In general, <code>has_clone&lt;T&gt;::value</code> is <code>false</code></li>
<li>For any <code>T</code> type for which <code>p-&gt;clone()</code> for some <code>const T*</code> object <code>p</code>, <code>has_clone&lt;T&gt;::value</code> is <code>true</code></li>
</ul>
<p>Once the <code>Dup</code> type has been chosen, normal operations continue. The advantage of this implementation over the previous one is that this one checks for the existence of a suitably written <code>clone()</code> member function, whereas the previous one checks for the existence of a specific base class. Implementing a function is a lighter contract than deriving from a specific base class.</p>
<p class="callout-heading">A word on std::void_t</p>
<p class="callout">The <code>std::void_t</code> type is a <a id="_idIndexMarker361"/>brilliant piece of work. Using it relies on <code>has_clone&lt;T&gt;</code> is <code>false</code> for most types but is <code>true</code> when expression <code>p-&gt;clone()</code> is valid for some <code>const T*</code> object <code>p</code>. That we can easily test the validity of any expression even before concepts came into their own is just beautiful, and we owe Dr. Walter Brown much for this gem (among many other gems).</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor110"/>Detection through concepts</h2>
<p>Since C++20, tricks <a id="_idIndexMarker363"/>such as <code>std::void_t</code> are less useful than they were since concepts are now part of the language’s type system. Through concepts, we can define a <code>cloneable</code> type, <code>T</code>, to be something for which a call to <code>clone()</code> is well-formed on <code>const T*</code> and yields something that is convertible to <code>T*</code>.</p>
<p>With this, we have the following:</p>
<pre class="source-code">
<strong class="bold">template &lt;class T&gt;</strong>
<strong class="bold">   concept cloneable = requires(const T *p) {</strong>
<strong class="bold">      { p-&gt;clone() } -&gt; std::convertible_to&lt;T*&gt;;</strong>
<strong class="bold">   };</strong>
template &lt;class T, <strong class="bold">class Dup = std::conditional_t&lt;</strong>
<strong class="bold">            cloneable&lt;T&gt;, Cloner, Copier</strong>
&gt;&gt; class dup_ptr {
   T *p{};
public:
   // ...
   dup_ptr(const dup_ptr &amp;other)
      : p{ other.empty()? nullptr <strong class="bold">: Dup{}(other.p)</strong> } {
   }
   // ...
};</pre> <p>Concepts, like traits, are a non-intrusive solution to this problem. Where traits are a programming technique, however, they are ingrained in the type system and we can (for example) write code that’s specialized for <code>cloneable&lt;T&gt;</code> and code that is not. In our case, the fact that we want to leave the door open for types that use neither the copy constructor nor a <code>clone()</code> member function suggests that the current setup, which lets <a id="_idIndexMarker364"/>client code supply other duplication mechanisms, is probably preferable.</p>
<p class="callout-heading">C++26</p>
<p class="callout">C++26 will contain two standard types named <code>std::indirect</code> and <code>std::polymorphic</code> that will cover a niche close to the one described by this <code>dup_ptr</code>. It was voted in on February 15 2025.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>Some not-so-smart yet useful smart pointers</h1>
<p>So we have standard smart pointers, such as <code>unique_ptr&lt;T&gt;</code> (single ownership) and <code>shared_ptr&lt;T&gt;</code> (shared ownership), and we can write our own for more exotic situations (we examined <code>dup_ptr&lt;T&gt;</code> where we have single ownership but duplication of the pointee when the pointer is duplicated). Are there other common semantics we might want to ensconce in the type system of our program?</p>
<p>Well, there are at least two “easy” ones one could think of: implementing a “never null” semantic and implementing an “only observing” semantic.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>A non_null_ptr type</h2>
<p>Let’s go<a id="_idIndexMarker365"/> back to an earlier example where we wrote the following:</p>
<pre class="source-code">
// ...
<strong class="bold">// precondition: p != nullptr (to keep things simple)</strong>
X* duplicate(X *p) {
   return new X{ *p }; // Ok
}
// ...</pre> <p>Note the comment, which puts the burden of not supplying a null pointer on user code. We could have approached this constraint in many other ways, including the following:</p>
<ul>
<li>Asserting <code>!p</code></li>
<li>Calling <code>std::abort()</code> if <code>!p</code></li>
<li>Calling <code>std::terminate()</code> if <code>!p</code></li>
<li>Throwing if <code>!p</code>, and so on</li>
</ul>
<p>The important thing is that if we care about pointers being non-null, and if we inject <code>if(!p)</code> tests in our runtime code, we are probably doing something wrong as this could (or should?) be part of the type system: <em class="italic">this function only accepts non-null pointers</em>. Code speaks louder than comments.</p>
<p>This idea <a id="_idIndexMarker366"/>appears in some commercial libraries (for example, <code>gsl::non_null&lt;T&gt;</code> from the guideline support library offered by some major compiler vendors) and is easy to implement as long as one has a clear way of signaling errors. For the sake of the example, we will suppose that this clear way is throwing an exception:</p>
<pre class="source-code">
class invalid_pointer {};
template &lt;class T&gt;
   class non_null_ptr {
      T *p;
   public:
      <strong class="bold">non_null_ptr(T *p) : p{ p } {</strong>
<strong class="bold">         if (!p) throw invalid_pointer{};</strong>
<strong class="bold">      }</strong>
<strong class="bold">      T* get() const { return p; }</strong>
      constexpr operator bool() const noexcept {
         return true;
      }
   // ...</pre> <p>Using this type, any function that accepts a <code>non_null_ptr&lt;T&gt;</code> argument knows that the <code>T*</code> pointer therein will be non-null, relieving client code from the burden of validation. This makes <code>non_null_ptr&lt;T&gt;</code> a beautiful type for the interface of functions that expect a non-null <code>T*</code>.</p>
<p>The rest of this class is mostly trivial to write at this point. The key peculiarity is that <code>non_null_ptr&lt;T&gt;</code> will not expose a default constructor, as that constructor would have to initialize the <code>p</code> data member to some default value (probably <code>nullptr</code>) but the <code>non_null_ptr&lt;T&gt;</code> type models a non-null pointer, which would lead to nonsensical code.</p>
<p>In terms of <a id="_idIndexMarker367"/>usage, take a look at this:</p>
<pre class="source-code">
struct X { int n; };
class invalid {};
int extract_value(<strong class="bold">const X *p) {</strong>
<strong class="bold">   if(!p) throw invalid{};</strong>
<strong class="bold">   return p-&gt;n;</strong>
}
#include &lt;iostream&gt;
int main() try {
   X x{ 3 };
   std::cout &lt;&lt; extract_value(&amp;x) &lt;&lt; '\n'
             &lt;&lt; extract_value(nullptr) &lt;&lt; '\n';
} catch(invalid) {
   std::cerr &lt;&lt; "oops\n";
}</pre> <p>Now, compare it with this, supposing that <code>non_null_ptr&lt;T&gt;</code> throws when constructed with a null pointer:</p>
<pre class="source-code">
<strong class="bold">// definition of the non_null_ptr type (omitted)</strong>
struct X { int n; };
int extract_value(<strong class="bold">const non_null_ptr&lt;X&gt; &amp;p) {</strong>
<strong class="bold">   return p-&gt;n; // no need for validation as it stems</strong>
<strong class="bold">                // from the type system itself</strong>
}
#include &lt;iostream&gt;
int main() try {
   X x{ 3 };
   std::cout &lt;&lt; extract_value(&amp;x) &lt;&lt; '\n'
             &lt;&lt; extract_value(nullptr) &lt;&lt; '\n';
} catch(...) {
   std::cerr &lt;&lt; "oops\n";
}</pre> <p>The two <a id="_idIndexMarker368"/>main advantages of <code>non_null_ptr&lt;T&gt;</code> over <code>T*</code> in this case are that the type system documents the intent better with <code>non_null_ptr&lt;T&gt;</code> (with <code>T*</code>, a null pointer might be fine, but with <code>non_null_ptr&lt;T&gt;</code>, it is clearly not) and that the called functions can proceed without validating, the validation being (again) ingrained in the type system. Using a richer type than <code>T*</code> makes both caller code and called code better.</p>
<p>What if the called function needs <code>T*</code>? This can happen, for example, in the case where it needs to call a C function. Well, then, use the <code>non_null_ptr&lt;T&gt;</code> object’s <code>get()</code> member function. C++ is nothing if not pragmatic.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor113"/>An observer_ptr type</h2>
<p>How <a id="_idIndexMarker369"/>about having a very dumb smart pointer type named <code>observer_ptr&lt;T&gt;</code> that solely cares about expressing the idea that that “smart” pointer is, indeed, <em class="italic">not</em> a pointer, in the sense that operations that would apply to a raw pointer are restricted on that type. The canonical issue is that applying <code>delete</code> on <code>T*</code> would work but applying <code>delete</code> on <code>observer_ptr&lt;T&gt;</code> would not since <code>observer_ptr&lt;T&gt;</code> is… not a pointer. Indeed, consider the following:</p>
<pre class="source-code">
class X { /* ... */ };
void f(<strong class="bold">X *p) {</strong>
<strong class="bold">   // use *p</strong>
   // we passed a raw pointer to f(), so f() should
   // observe it, not own it
<strong class="bold">   </strong><strong class="bold">delete p; // wait! You're not supposed to do that!</strong>
}</pre> <p>You <a id="_idIndexMarker370"/>might say, as the comment states, “But that function’s not supposed to do that! It does not own <code>*p</code>!” but, well, mistakes happen, as do misunderstandings. In this case, the impact of misunderstandings is made worse by the fact that nothing in the argument’s type states that applying <code>operator delete</code> to <code>p</code> is incorrect!</p>
<p>Now, let’s change the signature slightly:</p>
<pre class="source-code">
class X { /* ... */ };
void f(<strong class="bold">observer_ptr&lt;X&gt; p) {</strong>
<strong class="bold">   // use *p</strong>
<strong class="bold">   // delete p; // nope, does not compile</strong>
}</pre> <p>The “use <code>*p</code>” comment remains the same in both versions. The <code>observer_ptr&lt;T&gt;</code> type offers almost trivial versions of all reasonable operators and member functions (<code>get()</code>, <code>operator*()</code>, <code>operator-&gt;()</code>, <code>empty()</code>, and so on) so usage of <code>T*</code> and of <code>observer_ptr&lt;T&gt;</code> should be mostly equivalent in user code; the only difference is in misguided uses such as applying <code>delete</code> or performing pointer arithmetic.</p>
<p>Sometimes, just clarifying intent in a function interface makes code better.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor114"/>Summary</h1>
<p>In <a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a>, we spent some time on the proper usage of standard smart pointers. In the current chapter, we “dirtied our hands,” so to speak, and we wrote homemade (and simplified) versions of <code>unique_ptr&lt;T&gt;</code> and <code>shared_ptr&lt;T&gt;</code>. As mentioned more than once, this is meant as an educational exploration, as your library vendor assuredly provides significantly better (more complete, more performant, better tested, etc.) implementations in both cases.</p>
<p>In this chapter, we also explored the possibility of providing homemade smart pointer types, with a policy-based <code>dup_ptr&lt;T&gt;</code> based on three distinct approaches to the selection of a duplication algorithm. The intent was to show that it can be done, how it can be done, and how we can provide reasonable, usable defaults without blocking user code with more exotic requirements.</p>
<p>Toward the end of this chapter, we examined some relatively simple (but useful) smart (well, lightly smart) pointers that can be used at the edges of functions (typically, as argument types) to make semantic requirements implicit through the type system instead of forcing user code to enforce these requirements explicitly… and sometimes fail to do so.</p>
<p>Unsurprisingly, memory management is not limited to smart pointers. In the next chapter, we will explore how the <code>new</code>, <code>new[]</code>, <code>delete</code>, and <code>delete[]</code> operators work, how we can implement them ourselves, and why we sometimes want to do so.</p>
</div>


<div><h1 id="_idParaDest-113" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor115"/>Part 3: Taking Control (of Memory Management Mechanisms)</h1>
<p>In this part, we will delve somewhat deeper and examine ways in which you can take over some of the core memory allocation mechanisms in the C++ language and customize them to your needs. We will see how you can control what operators such as new and delete do, how to use specialized knowledge to obtain specific execution properties, and how these operators can be used in innovative ways. We will also use this knowledge for a few real-life applications and to achieve fast, sometimes extremely fast, memory management operations.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a>, <em class="italic">Overloading Memory Allocation Operators</em></li>
<li><a href="B21071_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a>, <em class="italic">Writing a Naïve Leak Detector</em></li>
<li><a href="B21071_09.xhtml#_idTextAnchor141"><em class="italic">Chapter 9</em></a>, <em class="italic">Atypical Allocation Mechanisms</em></li>
<li><a href="B21071_10.xhtml#_idTextAnchor153"><em class="italic">Chapter 10</em></a>, <em class="italic">Arena-Based Memory Management and Other Optimizations</em></li>
<li><a href="B21071_11.xhtml#_idTextAnchor163"><em class="italic">Chapter 11</em></a>, <em class="italic">Deferred Reclamation</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>