<html><head></head><body>
<div epub:type="chapter" id="_idContainer022">
<h1 class="chapter-number" id="_idParaDest-95"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-96"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.2.1">Writing Smart Pointers</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we examined the standard smart pointers at our disposal, with emphasis on the most important ones: </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.7.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">These types are precious and important tools in every contemporary C++ programmer’s toolbox, and using them when appropriate leads to programs that are smaller, faster, and simpler than they would be with most </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">handwritten alternatives.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">This book aims to discuss how to manage memory in a C++ program. </span><span class="koboSpan" id="kobo.11.2">For that reason, in this chapter, we will write simple versions of both </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.13.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.15.1"> to show ways in which one could write naïve-yet-workable versions of these types if needed. </span><span class="koboSpan" id="kobo.15.2">We </span><em class="italic"><span class="koboSpan" id="kobo.16.1">strongly</span></em><span class="koboSpan" id="kobo.17.1"> recommend that you use the standard versions in practice, not those in this book (at least in production code): standard versions have been thoroughly tested, optimized, and used by a multitude of programmers to good effect. </span><span class="koboSpan" id="kobo.17.2">The reason we write “homemade” flavors here is simply to develop an intuition as to how one could write such as type: there still exist companies using pre-C++11 compilers, sometimes for reasonable reasons, and there might be reasons in some settings to write a smart pointer inspired by the standard ones yet </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">slightly different.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">We will then examine some niches not covered by the standard smart pointers, either because they are deemed simple enough that users can roll out their own, they are deemed specialized enough that they should be covered through third-party libraries, or there is no clear path to standardizing </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">them yet.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">To summarize, in this chapter, we will do </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Take a brief look at ownership semantics, those of the standard smart pointers as well as others that we could – and sometimes will – </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">implement ourselves.</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Implement our own naïve-yet-usable version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.27.1"> in order to grasp some of the techniques this </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">might entail.</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Implement our own naïve-yet-usable version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">Note that by “usable” here we mean usable in simple contexts, as a full implementation of something such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.33.1"> is significantly more complex than what a book such as this one can </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">reasonably cover.</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Implement a non-standard smart pointer with single ownership and duplication semantics, showing different techniques to achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">this objective.</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Implement two distinct non-owning “smart” pointers that are very lightweight types yet help write better and </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">safer code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.39.1">After reading this chapter, we should have a better grasp of the techniques involved in writing types that syntactically behave as pointers but provide (or simply clarify) ownership semantics. </span><span class="koboSpan" id="kobo.39.2">The techniques used should be in large part reusable to other types of problems, memory-management related </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Does that sound like a plan? </span><span class="koboSpan" id="kobo.41.2">Let’s get to </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">it then!</span></span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.43.1">Technical requirements</span></h1>
<p><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.44.1">You can find the code files for this chapter in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter6"><span class="No-Break"><span class="koboSpan" id="kobo.46.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter6</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.47.1">.</span></span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.48.1">Ownership semantics</span></h1>
<p><span class="koboSpan" id="kobo.49.1">Smart pointers</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.50.1"> are all about clarifying ownership over indirectly accessed resources. </span><span class="koboSpan" id="kobo.50.2">If we restrict ourselves to the standard facilities, smart or not-so-smart, what we have is </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the following:</span></span></p>
<table class="T---Table _idGenTablePara-1" id="table001">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.52.1">Type</span></strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.53.1">Niche</span></strong></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">unique_ptr&lt;T&gt;</span></strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.55.1">Ownership semantics</span></strong><span class="koboSpan" id="kobo.56.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">Single ownership.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.58.1">Notable special member functions</span></strong><span class="koboSpan" id="kobo.59.1">: Non-copyable. </span><span class="koboSpan" id="kobo.59.2">The destructor is responsible for destroying </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">the pointee.</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">shared_ptr&lt;T&gt;</span></strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.62.1">Ownership semantics</span></strong><span class="koboSpan" id="kobo.63.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">Shared ownership.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.65.1">Notable special member functions</span></strong><span class="koboSpan" id="kobo.66.1">: Copying, assigning, and destroying update a shared use count. </span><span class="koboSpan" id="kobo.66.2">The destructor of the last co-owner is responsible for destroying both the pointee and the </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">use count.</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">T*</span></strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.69.1">Ownership semantics</span></strong><span class="koboSpan" id="kobo.70.1">: No ownership is defined in the type system (ownership rules have to be inscribed in </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">user code).</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.72.1">Notable special member functions</span></strong><span class="koboSpan" id="kobo.73.1">: Not applicable (this is a </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">fundamental type).</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.75.1">Table 6.1 – Usage category per pointer type</span></p>
<p><span class="koboSpan" id="kobo.76.1">It’s a small zoo, all </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.77.1">things considered. </span><span class="koboSpan" id="kobo.77.2">What are the other kinds of semantics we could envision in order to fill this table? </span><span class="koboSpan" id="kobo.77.3">Well, there could be </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.79.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">observer_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.81.1"> type that behaves like </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">T*</span></strong><span class="koboSpan" id="kobo.83.1"> but makes it more difficult to accidentally claim ownership with such operations as applying </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">delete</span></strong><span class="koboSpan" id="kobo.85.1"> on the pointer (accidents </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">happen indeed)</span></span></li>
<li><span class="koboSpan" id="kobo.87.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">non_null_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.89.1"> type that behaves like </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">T*</span></strong><span class="koboSpan" id="kobo.91.1"> but for which a </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">null</span></strong><span class="koboSpan" id="kobo.93.1"> pointer never occurs, simplifying </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">client code</span></span></li>
<li><span class="koboSpan" id="kobo.95.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">remote_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.97.1"> type that behaves like a proxy to </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">remote pointees</span></span></li>
<li><span class="koboSpan" id="kobo.99.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">dup_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.101.1"> type that implements single ownership of the pointee, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.103.1"> does, but is copyable and duplicates the pointee when </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">dup_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.105.1"> is copied, and </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">so on</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.107.1">We will not implement all of these (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">remote_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.109.1"> case in particular, interesting as it is, falls outside the scope of this book, and there are numerous other exotic semantics we could entertain that you are welcome to implement based on the ideas you will find in this chapter), but we will write a few. </span><span class="koboSpan" id="kobo.109.2">The important aspect in each case is to define clearly what the intended semantics are, ensure they are not already covered by an existing type, and make sure we implement </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">them appropriately.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">Let’s start with a simple implementation of what is perhaps the best-known standard smart </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">pointer: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">unique_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">.</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.115.1">Writing your own (naïve) unique_ptr</span></h1>
<p><span class="koboSpan" id="kobo.116.1">We will first </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.117.1">try a simple, homegrown version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">As mentioned at the beginning of this chapter, our goal is to develop an intuition for the kind of code required to write such a type and not to encourage you to try to replace the standard facilities: they exist, they work, they are tested, use them. </span><span class="koboSpan" id="kobo.119.3">Oh, and they use many cool tricks we cannot explore in this book as we want to keep the book’s size </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">under control!</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.121.1">Type signature</span></h2>
<p><span class="koboSpan" id="kobo.122.1">As </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.123.1">mentioned in </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.124.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.125.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.127.1"> does not really exist as the type is, in fact, </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">unique_ptr&lt;T,D&gt;</span></strong><span class="koboSpan" id="kobo.129.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">D</span></strong><span class="koboSpan" id="kobo.131.1"> defaults </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">default_deleter&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">We will cover both forms (scalar and array) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.137.1">. </span><span class="koboSpan" id="kobo.137.2">The reason for these two specializations is that for </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">T[]</span></strong><span class="koboSpan" id="kobo.139.1">, we will want </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.141.1"> to expose </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">operator[]</span></strong><span class="koboSpan" id="kobo.143.1"> but we will not want to expose this for a scalar </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">T</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">Let’s start with the basic deleter types we will offer. </span><span class="koboSpan" id="kobo.146.2">Note that users can supply other deleter types if needed as long as they use the same signature </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">operator()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">
namespace managing_memory_book {
   // basic deleter types
   template &lt;class T&gt;
   struct deleter_pointer_wrapper {
      void (*pf)(T*);
      deleter_pointer_wrapper(void (*pf)(T*)) : pf{ pf } {
      }
      void operator()(T* p) const { pf(p); }
   };
   template &lt;class T&gt;
   struct default_deleter {
      void operator()(T* p) const { delete p; }
   };
   template &lt;class T&gt;
   struct default_deleter&lt;T[]&gt; {
      void operator()(T* p) const { delete[] p; }
   };
   // ...
</span><span class="koboSpan" id="kobo.150.2">}</span></pre> <p><span class="koboSpan" id="kobo.151.1">What </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.152.1">we have so far are three deleter types that are callable in the same way and that are all class types (the reason for this will become evident soon but know that there’s sometimes value in uniformity). </span><span class="koboSpan" id="kobo.152.2">The odd one is </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">deleter_pointer_wrapper&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.154.1">, which wraps a copyable state (a function pointer) but otherwise behaves like the other two: when called on </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">T*</span></strong><span class="koboSpan" id="kobo.156.1">, it applies some (user-supplied) function to </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">that pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">The next step will be to choose the form of </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">unique_ptr&lt;T,D&gt;</span></strong><span class="koboSpan" id="kobo.160.1">. </span><span class="koboSpan" id="kobo.160.2">We will expect most deleters to be stateless and </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.161.1">use </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">empty base optimization</span></strong><span class="koboSpan" id="kobo.163.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.164.1">EBO</span></strong><span class="koboSpan" id="kobo.165.1">) to our advantage by deriving from our deleter type. </span><span class="koboSpan" id="kobo.165.2">The one exception will be when the deleter is a function pointer, as we cannot use such a type as a base class; in that case, we will instead derive from </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">deleter_pointer_wrapper&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">To choose between these two options, we will need to detect whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">D</span></strong><span class="koboSpan" id="kobo.169.1"> is a function pointer or not, which we will achieve using our own </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">is_deleter_function_candidate&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> trait.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">The part of our implementation that detects deleter function candidates is </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
#include &lt;type_traits&gt;
namespace managing_memory_book {
   // ...
</span><span class="koboSpan" id="kobo.174.2">   template &lt;class T&gt;
   struct is_deleter_function_candidate
      : std::false_type {};
   template &lt;class T&gt;
   struct is_deleter_function_candidate&lt;void (*)(T*)&gt;
      : std::true_type {};
   template &lt;class T&gt;
   constexpr auto is_deleter_function_candidate_v =
      is_deleter_function_candidate&lt;T&gt;::value;
   // ...
</span><span class="koboSpan" id="kobo.174.3">}</span></pre> <p><span class="koboSpan" id="kobo.175.1">This bit is </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.176.1">probably self-explanatory, but the idea is that most types are not candidates to be deleter functions, but functions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">void(*)(T*)</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.178.1">type are.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">We then get to the general </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.181.1"> type, used for scalars. </span><span class="koboSpan" id="kobo.181.2">We will use our deleter function detection trait to conditionally choose between </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">D</span></strong><span class="koboSpan" id="kobo.183.1"> types and </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">deleter_pointer_wrapper&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.185.1"> as the base class for our type, and cast this to a pointer to that base in order to release the resource in </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">our destructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
namespace managing_memory_book {
   // ...
</span><span class="koboSpan" id="kobo.187.2">   // unique_ptr general template
   template &lt;class T, class D = default_deleter&lt;T&gt;&gt;
   class unique_ptr : std::conditional_t &lt;
      is_deleter_function_candidate_v&lt;D&gt;,
      deleter_pointer_wrapper&lt;T&gt;, D
   &gt; {
      using deleter_type = std::conditional_t &lt;
         is_deleter_function_candidate_v&lt;D&gt;,
         deleter_pointer_wrapper&lt;T&gt;,
         D
      &gt;;
      T* p = nullptr;
   public:
      unique_ptr() = default;
      unique_ptr(T* p) : p{ p } {
      }
      unique_ptr(T* p, void (*pf)(T*))
         : deleter_type{ pf }, p{ p } {
      }
      ~unique_ptr() {
         (*static_cast&lt;deleter_type*&gt;(this))(p);
      }
   };
   // ...
</span><span class="koboSpan" id="kobo.187.3">}</span></pre> <p><span class="koboSpan" id="kobo.188.1">The same </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.189.1">approach, essentially, is taken for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">T[]</span></strong><span class="koboSpan" id="kobo.191.1"> specialization of </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">our type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.193.1">
namespace managing_memory_book {
   // ...
</span><span class="koboSpan" id="kobo.193.2">   // unique_ptr specialization for arrays
   template &lt;class T, class D&gt;
   class unique_ptr&lt;T[], D&gt; : std::conditional_t &lt;
      is_deleter_function_candidate_v&lt;D&gt;,
      deleter_pointer_wrapper&lt;T&gt;,
      D
   &gt; {
      using deleter_type = std::conditional_t &lt;
         is_deleter_function_candidate_v&lt;D&gt;,
         deleter_pointer_wrapper&lt;T&gt;,
         D
      &gt;;
      T* p = nullptr;
   public:
      unique_ptr() = default;
      unique_ptr(T* p) : p{ p } {
      }
      unique_ptr(T* p, void (*pf)(T*))
         : deleter_type{ pf }, p{ p } {
      }
      ~unique_ptr() {
         (*static_cast&lt;deleter_type*&gt;(this))(p);
      }
   };
}</span></pre> <p><span class="koboSpan" id="kobo.194.1">Notice that a</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.195.1"> default </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.197.1"> will behave conceptually like a </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">null</span></strong><span class="koboSpan" id="kobo.199.1"> pointer, something that should be unsurprising to most. </span><span class="koboSpan" id="kobo.199.2">Now that we have the basic idea in place, let’s explore the semantics specific </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">unique_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.203.1">Special member functions</span></h2>
<p><span class="koboSpan" id="kobo.204.1">The code</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.205.1"> for the special member functions will be the same for both the scalar and the array forms of </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.207.1">. </span><span class="koboSpan" id="kobo.207.2">We have already looked at the destructor and the default constructor in the previous section, so let’s look at the other four, </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">in pairs:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.209.1">We want the type to be non-copyable, as it represents sole ownership of the pointee (if it was copyable, would ownership of the pointee belong to the original or </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">the copy?)</span></span></li>
<li><span class="koboSpan" id="kobo.211.1">We want move operations to implement the transfer </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">of ownership</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.213.1">The code for both the general case and its array specialization will be as follows (note that the code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">std::exchange()</span></strong><span class="koboSpan" id="kobo.215.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">std::swap()</span></strong><span class="koboSpan" id="kobo.217.1">, both found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">utility&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1"> header):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
// ...
</span><span class="koboSpan" id="kobo.221.2">      unique_ptr(const unique_ptr&amp;) = delete;
      unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
      void swap(unique_ptr &amp;other) noexcept {
         using std::swap;
         swap(p, other.p);
      }
      unique_ptr(unique_ptr &amp;&amp;other) noexcept
         : p{ std::exchange(other.p, nullptr) } {
      }
      unique_ptr&amp; operator=(unique_ptr &amp;&amp;other) noexcept {
         unique_ptr{ std::move(other) }.swap(*this);
         return *this;
      }
// ...</span></pre> <p><span class="koboSpan" id="kobo.222.1">Most of this should be self-evident by this point. </span><span class="koboSpan" id="kobo.222.2">You might notice the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">std::exchange()</span></strong><span class="koboSpan" id="kobo.224.1">, which has the effect of copying </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">other.p</span></strong><span class="koboSpan" id="kobo.226.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">this-&gt;p</span></strong><span class="koboSpan" id="kobo.228.1"> and then copying </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">nullptr</span></strong><span class="koboSpan" id="kobo.230.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">other.p</span></strong><span class="koboSpan" id="kobo.232.1">, implementing the transfer of ownership as expected. </span><span class="koboSpan" id="kobo.232.2">Note that move operations for our type are trivial and never throw, both of which are highly </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">desirable properties.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">There are some</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.235.1"> operations that will be implemented in both the general case and the array case, namely, </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">operator bool</span></strong><span class="koboSpan" id="kobo.237.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">true</span></strong><span class="koboSpan" id="kobo.239.1"> only if the object does not model a </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">null</span></strong><span class="koboSpan" id="kobo.241.1"> pointer), </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">empty()</span></strong><span class="koboSpan" id="kobo.243.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">true</span></strong><span class="koboSpan" id="kobo.245.1"> only if the object does model a </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">null</span></strong><span class="koboSpan" id="kobo.247.1"> pointer), as well as </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">operator==()</span></strong><span class="koboSpan" id="kobo.249.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">operator!=()</span></strong><span class="koboSpan" id="kobo.251.1">. </span><span class="koboSpan" id="kobo.251.2">These are essentially trivial to implement. </span><span class="koboSpan" id="kobo.251.3">The other member function we will want to expose is </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">get()</span></strong><span class="koboSpan" id="kobo.253.1"> in both its </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">const</span></strong><span class="koboSpan" id="kobo.255.1"> and non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">const</span></strong><span class="koboSpan" id="kobo.257.1"> versions in order to expose the underlying pointer for client code that needs to interact with lower-level functions such as </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">system calls:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
// ...
</span><span class="koboSpan" id="kobo.259.2">      bool empty() const noexcept { return !p; }
      operator bool() const noexcept { return !empty(); }
      bool operator==(const unique_ptr &amp;other)
         const noexcept {
         return p == other.p;
      }
      // inferred from operator==() since C++20
      bool operator!=(const unique_ptr &amp;other)
         const noexcept {
         return !(*this == other);
      }
      T *get() noexcept { return p; }
      const T *get() const noexcept { return p; }
// ...</span></pre> <p><span class="koboSpan" id="kobo.260.1">As mentioned in the comments in the preceding code excerpt, one does not need to explicitly implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">operator!=()</span></strong><span class="koboSpan" id="kobo.262.1"> since C++20 as long as </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">operator==()</span></strong><span class="koboSpan" id="kobo.264.1"> offers the </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.265.1">expected signature. </span><span class="koboSpan" id="kobo.265.2">The compiler will synthesize </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">operator!=()</span></strong><span class="koboSpan" id="kobo.267.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">operator==()</span></strong><span class="koboSpan" id="kobo.269.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">quite simply.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">Now, let’s take a look at how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">operator*()</span></strong><span class="koboSpan" id="kobo.273.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">operator-&gt;()</span></strong><span class="koboSpan" id="kobo.275.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">operator[]()</span></strong><span class="koboSpan" id="kobo.277.1"> pointer-like functions </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">are implemented.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.279.1">Pointer-like functions</span></h2>
<p><span class="koboSpan" id="kobo.280.1">The </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.281.1">pointer-like functions are different for the scalar case and the array case. </span><span class="koboSpan" id="kobo.281.2">For pointer-to-scalar, we will want to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">operator*()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.283.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">operator-&gt;()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
// ...
</span><span class="koboSpan" id="kobo.286.2">      T&amp; operator*() noexcept { return *p; }
      const T&amp; operator*() const noexcept { return *p; }
      T* operator-&gt;() noexcept { return p; }
      const T* operator-&gt;() const noexcept { return p; }
// ...</span></pre> <p><span class="koboSpan" id="kobo.287.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">operator-&gt;()</span></strong><span class="koboSpan" id="kobo.289.1"> member function is a strange beast: when used on an object, it will be reinvoked on the returned object (and again on that returned object, and so on) until something returns a raw pointer, at which point the compiler will know what to do. </span><span class="koboSpan" id="kobo.289.2">It’s a very </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">powerful mechanism.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">For pointer-to-array (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">unique_ptr&lt;T[]&gt;</span></strong><span class="koboSpan" id="kobo.293.1"> specialization), we will want to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">operator[]</span></strong><span class="koboSpan" id="kobo.295.1">, which will make more sense than either </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">operator*()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.297.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">operator-&gt;()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.300.1">
// ...
</span><span class="koboSpan" id="kobo.300.2">      T&amp; operator[](std::size_t n) noexcept {
         return p[n];
      }
      const T&amp; operator[](std::size_t n) const noexcept {
         return p[n];
      }
// ...</span></pre> <p><span class="koboSpan" id="kobo.301.1">You might</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.302.1"> notice the apparent duplication of these member functions as each one is exposed in both a </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">const</span></strong><span class="koboSpan" id="kobo.304.1"> and non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">const</span></strong><span class="koboSpan" id="kobo.306.1"> form, a “trend” started by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">get()</span></strong><span class="koboSpan" id="kobo.308.1"> member function a bit earlier. </span><span class="koboSpan" id="kobo.308.2">This is a </span><em class="italic"><span class="koboSpan" id="kobo.309.1">syntactic</span></em><span class="koboSpan" id="kobo.310.1"> resemblance as they are </span><em class="italic"><span class="koboSpan" id="kobo.311.1">semantically</span></em><span class="koboSpan" id="kobo.312.1"> different: in particular, only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">const</span></strong><span class="koboSpan" id="kobo.314.1"> form is available through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">const </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">unique_ptr&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">If you have a C++23 compiler, you can make it so the compiler will synthesize the forms you use in practice given a properly written set of template </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">member functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
// the following is for both the array and non-array cases
</span><strong class="bold"><span class="koboSpan" id="kobo.321.1">template &lt;class U&gt;</span></strong><span class="koboSpan" id="kobo.322.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">decltype(auto)</span></strong><span class="koboSpan" id="kobo.324.1"> get(</span><strong class="bold"><span class="koboSpan" id="kobo.325.1">this U &amp;&amp; self</span></strong><span class="koboSpan" id="kobo.326.1">) noexcept {
      return </span><strong class="bold"><span class="koboSpan" id="kobo.327.1">self.p</span></strong><span class="koboSpan" id="kobo.328.1">;
   }
// the following two are only for the non-array case
</span><strong class="bold"><span class="koboSpan" id="kobo.329.1">template &lt;class U&gt;</span></strong><span class="koboSpan" id="kobo.330.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">decltype(auto)</span></strong><span class="koboSpan" id="kobo.332.1"> operator*(</span><strong class="bold"><span class="koboSpan" id="kobo.333.1">this U &amp;&amp; self</span></strong><span class="koboSpan" id="kobo.334.1">) noexcept {
      return </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">*(self.p)</span></strong><span class="koboSpan" id="kobo.336.1">;
   }
</span><strong class="bold"><span class="koboSpan" id="kobo.337.1">template &lt;class U&gt;</span></strong><span class="koboSpan" id="kobo.338.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">decltype(auto)</span></strong><span class="koboSpan" id="kobo.340.1"> operator-&gt;(</span><strong class="bold"><span class="koboSpan" id="kobo.341.1">this U &amp;&amp; self</span></strong><span class="koboSpan" id="kobo.342.1">) noexcept {
      return </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">self.p</span></strong><span class="koboSpan" id="kobo.344.1">;
   }
// the following is only for the array case
</span><strong class="bold"><span class="koboSpan" id="kobo.345.1">template &lt;class U&gt;</span></strong><span class="koboSpan" id="kobo.346.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.347.1">decltype(auto)</span></strong><span class="koboSpan" id="kobo.348.1"> operator[](</span><strong class="bold"><span class="koboSpan" id="kobo.349.1">this U &amp;&amp; self</span></strong><span class="koboSpan" id="kobo.350.1">,
                             std::size_t n) noexcept {
   return </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">self.p[n]</span></strong><span class="koboSpan" id="kobo.352.1">;
}</span></pre> <p><span class="koboSpan" id="kobo.353.1">This reduces the </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.354.1">number of member functions we have to write by half. </span><span class="koboSpan" id="kobo.354.2">How does this work? </span><span class="koboSpan" id="kobo.354.3">Well, C++23 introduces the “deduced </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">this</span></strong><span class="koboSpan" id="kobo.356.1">” mechanism that allows one to explicitly mark the first argument of a member function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">this</span></strong><span class="koboSpan" id="kobo.358.1"> keyword. </span><span class="koboSpan" id="kobo.358.2">Doing so and combining it with a forwarding reference (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">U&amp;&amp;</span></strong><span class="koboSpan" id="kobo.360.1"> type) lets the compiler deduce the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">const</span></strong><span class="koboSpan" id="kobo.362.1">-ness (or lack thereof) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">this</span></strong><span class="koboSpan" id="kobo.364.1">, in effect, expressing both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">const</span></strong><span class="koboSpan" id="kobo.366.1"> and non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">const</span></strong><span class="koboSpan" id="kobo.368.1"> versions in a single function. </span><span class="koboSpan" id="kobo.368.2">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">decltype(auto)</span></strong><span class="koboSpan" id="kobo.370.1"> return types that accompany these functions, which infer both </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.371.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">cv-qualifications</span></strong><span class="koboSpan" id="kobo.373.1"> (discussed in </span><a href="B21071_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.374.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.375.1">) and reference-ness of the return type based on the type of the expression evaluated in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">return</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.377.1"> statement.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">And that’s it! </span><span class="koboSpan" id="kobo.378.2">We now have a simple, yet functional </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.380.1"> implementation that works for most </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">Of course, as nice as it is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.384.1"> is not a panacea and there are other needs to be covered in real programs. </span><span class="koboSpan" id="kobo.384.2">Let’s move on to a simplified implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.386.1"> to see how we could implement shared </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">ownership semantics.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">A simple program that uses our homemade </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.390.1"> with a default deleter would be </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
// ... </span><span class="koboSpan" id="kobo.392.2">(our own unique_ptr&lt;T&gt; goes here...)
struct X {};
int main() {
   unique_ptr&lt;X&gt; p{ new X };
} // X::~X() called here</span></pre> <p><span class="koboSpan" id="kobo.393.1">Another that uses a custom deleter would be </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.395.1">
// ... </span><span class="koboSpan" id="kobo.395.2">(our own unique_ptr&lt;T&gt; goes here...)
class X {
   ~X(){}
public:
   static void destroy(X *p) { delete p; }
};
int main() {
   unique_ptr&lt;X, &amp;X::destroy&gt; p{ new X };
} // X::destroy(p.get()) called here</span></pre> <h1 id="_idParaDest-103"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.396.1">Writing your own (naïve) shared_ptr</span></h1>
<p><span class="koboSpan" id="kobo.397.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.399.1"> type is a </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.400.1">difficult beast to implement and a harder beast yet to optimize. </span><span class="koboSpan" id="kobo.400.2">The invitation to use the standard version of existing smart pointers is stronger in this case than it was for </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.402.1">: this type is hard to get right, and the standard version benefits from years of experience and testing. </span><span class="koboSpan" id="kobo.402.2">Only use the naïve version in this section for experimentation (it works and does the job for simple cases, but writing an industrial-strength implementation is </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">major-league work).</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">The main difficulty when writing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">shared_ptr</span></strong><span class="koboSpan" id="kobo.406.1"> is that it’s a type with two responsibilities: it co-owns both the pointee and the usage counter, requiring some measure of care, especially with respect to exception safety. </span><span class="koboSpan" id="kobo.406.2">The single responsibility principle of classical object-oriented programming is a sound principle: a type with a single responsibility is exceedingly simpler to get right than a type with two or </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">more responsibilities.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">To keep our proposition simple, we will eschew many details of the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">shared_ptr</span></strong><span class="koboSpan" id="kobo.410.1"> contract, limiting ourselves to managing a scalar </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">T</span></strong><span class="koboSpan" id="kobo.412.1">. </span><span class="koboSpan" id="kobo.412.2">Let’s take this type step </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">by step:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.414.1">
#include &lt;atomic&gt;
#include &lt;utility&gt;
namespace managing_memory_book {
   // naïve shared_ptr
   template &lt;class T&gt;
   class shared_ptr {
      T* p = nullptr;
      std::atomic&lt;long long&gt; *ctr = nullptr;
      // ...</span></pre> <p><span class="koboSpan" id="kobo.415.1">As mentioned </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.416.1">previously, </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.418.1"> is responsible for </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">T*</span></strong><span class="koboSpan" id="kobo.420.1"> and a pointer to a client counter, both of which need to be managed and shared between co-owners. </span><span class="koboSpan" id="kobo.420.2">Note that our shared counter is a pointer to an atomic integral since </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.422.1"> is particularly relevant in multithreaded cases where one does not know which of the threads will be the last user of the object. </span><span class="koboSpan" id="kobo.422.2">For that reason, operations such as incrementing and decrementing the counter require synchronization to avoid incurring a </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.423.1">data race</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.425.1">Avoiding data races</span></p>
<p class="callout"><span class="koboSpan" id="kobo.426.1">If a program meets a situation where a given object is (a) accessed concurrently by at least two threads, (b) at least one of these accesses is a write, and (c) there is no synchronization, then that program has what we </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.427.1">call a </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">data race</span></strong><span class="koboSpan" id="kobo.429.1"> and we essentially lose the capacity to reason about it from the source code. </span><span class="koboSpan" id="kobo.429.2">This is a really </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">bad situation.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.431.1">In our case, operations on the shared counter will most probably be done concurrently and, as such, they have to be synchronized. </span><span class="koboSpan" id="kobo.431.2">This explains our use of the low-level synchronization objects that are atomic integrals </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">as counters.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">Constructing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.435.1"> object can </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">be tricky:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.437.1">By default, we will define </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.439.1"> to be empty, thus conceptually equivalent to a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.441.1"> pointer.</span></span></li>
<li><span class="koboSpan" id="kobo.442.1">The constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.444.1"> that takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">T*</span></strong><span class="koboSpan" id="kobo.446.1"> as an argument represents the act of </span><em class="italic"><span class="koboSpan" id="kobo.447.1">taking ownership</span></em><span class="koboSpan" id="kobo.448.1"> of the pointee. </span><span class="koboSpan" id="kobo.448.2">For that reason, if an exception is thrown when allocating the counter, that pointee </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">is destroyed.</span></span></li>
<li><span class="koboSpan" id="kobo.450.1">The copy constructor will represent </span><em class="italic"><span class="koboSpan" id="kobo.451.1">sharing ownership</span></em><span class="koboSpan" id="kobo.452.1"> of the pointee, making sure to consider the case where the source object models a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.454.1"> pointer.</span></span></li>
<li><span class="koboSpan" id="kobo.455.1">The move constructor models the </span><em class="italic"><span class="koboSpan" id="kobo.456.1">transfer of ownership</span></em><span class="koboSpan" id="kobo.457.1">. </span><span class="koboSpan" id="kobo.457.2">As is often the case for move operations, it’s very fast and it shows highly </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">predictable behavior.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.459.1">As can be seen</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.460.1"> from the following code excerpt, with a type that has more than one responsibility, even construction is a delicate endeavor. </span><span class="koboSpan" id="kobo.460.2">In the constructor that takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">T*</span></strong><span class="koboSpan" id="kobo.462.1">, we might need to allocate the shared counter, which might throw, a situation we need to manage. </span><span class="koboSpan" id="kobo.462.2">In the copy constructor, we need to take into account that the argument might model an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.464.1">, in which case the shared counter would </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
      // ...
</span><span class="koboSpan" id="kobo.468.2">   public:
      shared_ptr() = default;
      shared_ptr(T* p) : p{ p } {
         if(p) try {
            ctr = new std::atomic&lt;long long&gt;{ 1LL };
         } catch(...) {
            delete p;
            throw;
         }
      }
      shared_ptr(const shared_ptr &amp;other)
         : p{ other.p }, ctr{ other.ctr } {
         if(ctr) ++(*ctr);
      }
      shared_ptr(shared_ptr &amp;&amp;other) noexcept
         : p{ std::exchange(other.p, nullptr) },
           ctr{ std::exchange(other.ctr, nullptr) } {
      }
      bool empty() const noexcept { return !p; }
      operator bool() const noexcept { return !empty(); }
// ...</span></pre> <p><span class="koboSpan" id="kobo.469.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">empty()</span></strong><span class="koboSpan" id="kobo.471.1">and </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">operator bool()</span></strong><span class="koboSpan" id="kobo.473.1"> member functions have been included in that excerpt since these functions directly tie into the way the default constructor (the empty state of this type) </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">is expressed.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">The </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.476.1">assignment operator is unsurprising: copy assignment models the act of releasing control of the currently held resource and sharing the resource of its argument, whereas move assignment models the act of releasing control of the currently held resource and transferring control of the resource held by the argument to the </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">assigned-to object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.478.1">
      // ...
</span><span class="koboSpan" id="kobo.478.2">      void swap(shared_ptr &amp;other) noexcept {
         using std::swap;
         swap(p, other.p);
         swap(ctr, other.ctr);
      }
      shared_ptr&amp; operator=(const shared_ptr &amp;other) {
         shared_ptr{ other }.swap(*this);
         return *this;
      }
      shared_ptr&amp; operator=(shared_ptr &amp;&amp;other) noexcept {
         shared_ptr{ std::move(other) }.swap(*this);
         return *this;
      }
      // ...</span></pre> <p><span class="koboSpan" id="kobo.479.1">Destruction is probably the trickiest aspect of this type. </span><span class="koboSpan" id="kobo.479.2">We want to make sure that the last owner of the pointee destroys it, to avoid immortal objects. </span><span class="koboSpan" id="kobo.479.3">The key point is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.481.1"> should</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.482.1"> only destroy the pointed-to </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">T</span></strong><span class="koboSpan" id="kobo.484.1"> object if it was the last user of </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">that object.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">There are at least two “self-evident” naïve algorithms that do not work. </span><span class="koboSpan" id="kobo.486.2">One is </span><em class="italic"><span class="koboSpan" id="kobo.487.1">If </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">ctr</span></strong><em class="italic"><span class="koboSpan" id="kobo.489.1"> is not null, then if </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">*ctr==1</span></strong><em class="italic"><span class="koboSpan" id="kobo.491.1">, delete </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">p</span></strong><em class="italic"><span class="koboSpan" id="kobo.493.1"> and delete </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">ctr</span></strong><span class="koboSpan" id="kobo.495.1">. </span><span class="koboSpan" id="kobo.495.2">This algorithm allows the case where two threads enter the destructor concurrently with </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">*ctr==2</span></strong><span class="koboSpan" id="kobo.497.1">. </span><span class="koboSpan" id="kobo.497.2">In that case, it is possible that neither thread sees </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">*ctr==1</span></strong><span class="koboSpan" id="kobo.499.1">, and the pointees are </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">never destroyed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.501.1"><img alt="Figure 6.1 – Race condition leading to an immortal object" src="image/B21071_06_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.502.1">Figure 6.1 – Race condition leading to an immortal object</span></p>
<p><span class="koboSpan" id="kobo.503.1">The other is </span><em class="italic"><span class="koboSpan" id="kobo.504.1">If </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">ctr</span></strong><em class="italic"><span class="koboSpan" id="kobo.506.1"> is not null, then decrement </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">*ctr</span></strong><em class="italic"><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">If </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">*ctr==0</span></strong><em class="italic"><span class="koboSpan" id="kobo.510.1">, delete </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">p</span></strong><em class="italic"><span class="koboSpan" id="kobo.512.1"> and delete </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">ctr</span></strong><span class="koboSpan" id="kobo.514.1">. </span><span class="koboSpan" id="kobo.514.2">This </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.515.1">algorithm allows the case where two threads enter the destructor concurrently with </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">*ctr==2</span></strong><span class="koboSpan" id="kobo.517.1">, and then both concurrently decrement </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">*ctr</span></strong><span class="koboSpan" id="kobo.519.1"> leading to the possibility of both seeing </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">*ctr==0</span></strong><span class="koboSpan" id="kobo.521.1">, resulting in a double deletion of </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">the pointees:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.523.1"><img alt="Figure 6.2 – Race condition leading to double deletion of the object" src="image/B21071_06_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.524.1">Figure 6.2 – Race condition leading to double deletion of the object</span></p>
<p><span class="koboSpan" id="kobo.525.1">Both cases are bad, albeit for different reasons, so we need to do better. </span><span class="koboSpan" id="kobo.525.2">The difficult part of the process is ensuring that the executing thread can be made aware that it is the one that made it so </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">*ctr</span></strong><span class="koboSpan" id="kobo.527.1"> became zero. </span><span class="koboSpan" id="kobo.527.2">The general solution to such a problem requires enclosing two steps (changing the value of a variable only if it had a known-beforehand value and being informed that this write did or did not happen) in a single operation, something that must be supported by at least one hardware operation on a </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">multicore machine.</span></span></p>
<p><span class="koboSpan" id="kobo.529.1">C++ offers abstractions over these essential hardware operations through atomics. </span><span class="koboSpan" id="kobo.529.2">One such atomic </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.530.1">operation is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">compare_exchange_weak()</span></strong><span class="koboSpan" id="kobo.532.1">, which takes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">expected</span></strong><span class="koboSpan" id="kobo.534.1"> value (what is believed to be in the variable) and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">desired</span></strong><span class="koboSpan" id="kobo.536.1"> value (what one seeks to write to that variable, but only if it holds </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">expected</span></strong><span class="koboSpan" id="kobo.538.1">), and returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">true</span></strong><span class="koboSpan" id="kobo.540.1"> only if the </span><em class="italic"><span class="koboSpan" id="kobo.541.1">write</span></em><span class="koboSpan" id="kobo.542.1"> actually happened. </span><span class="koboSpan" id="kobo.542.2">For convenience, </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">expected</span></strong><span class="koboSpan" id="kobo.544.1"> is taken by reference and updated with the value actually held by the object at that time, since this function is usually called in a loop until a successful write of </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">desired</span></strong><span class="koboSpan" id="kobo.546.1"> actually occurs, which involves re-reading </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">expected</span></strong><span class="koboSpan" id="kobo.548.1"> every time to update the function’s view of the variable’s </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">current state.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.550.1">A dance with pictures</span></p>
<p class="callout"><span class="koboSpan" id="kobo.551.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">expected</span></strong><span class="koboSpan" id="kobo.553.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">desired</span></strong><span class="koboSpan" id="kobo.555.1"> dance can be seen as taking pictures. </span><span class="koboSpan" id="kobo.555.2">A thread wants to decrement </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">*ctr</span></strong><span class="koboSpan" id="kobo.557.1">, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">*ctr</span></strong><span class="koboSpan" id="kobo.559.1"> holds a mutable state and is accessed concurrently, which means its value can change at any time. </span><span class="koboSpan" id="kobo.559.2">Thus, we take a picture (</span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">expected</span></strong><span class="koboSpan" id="kobo.561.1">) in a local variable under our control. </span><span class="koboSpan" id="kobo.561.2">We base the value we want to write (</span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">desired</span></strong><span class="koboSpan" id="kobo.563.1">) on that local picture that we know did not change. </span><span class="koboSpan" id="kobo.563.2">Then, we try to act based on that (potentially obsolete) knowledge and see whether our assumption (that </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">*ctr</span></strong><span class="koboSpan" id="kobo.565.1"> holds </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">expected</span></strong><span class="koboSpan" id="kobo.567.1">) is held. </span><span class="koboSpan" id="kobo.567.2">This lets us know that we were the ones to write </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">desired</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.569.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">*ctr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">With this knowledge, a possible implementation of the destructor would be </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
      // ...
</span><span class="koboSpan" id="kobo.574.2">      ~shared_ptr() {
         if(ctr) {
            auto expected = ctr-&gt;load();
            auto desired = expected - 1;
            while(ctr-&gt;compare_exchange_weak(expected,
                                             desired))
                desired = expected - 1;
            if(desired == 0) { // I was the last user of *p
               delete p;
               delete ctr;
            }
         }
      }
      // ...</span></pre> <p><span class="koboSpan" id="kobo.575.1">After the loop, we </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.576.1">know that we wrote </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">desired</span></strong><span class="koboSpan" id="kobo.578.1"> when </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">*ctr</span></strong><span class="koboSpan" id="kobo.580.1"> held </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">expected</span></strong><span class="koboSpan" id="kobo.582.1">, thus if </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">desired</span></strong><span class="koboSpan" id="kobo.584.1"> was </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">0</span></strong><span class="koboSpan" id="kobo.586.1"> (implying </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">expected</span></strong><span class="koboSpan" id="kobo.588.1"> was </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">1</span></strong><span class="koboSpan" id="kobo.590.1">), we know we were the last user of that pointee. </span><span class="koboSpan" id="kobo.590.2">Yes, it’s subtle. </span><span class="koboSpan" id="kobo.590.3">And this is only a toy version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.592.1">. </span><span class="koboSpan" id="kobo.592.2">We could optimize it in many ways, but that goes beyond the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">this book.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.594.1">A simpler solution</span></p>
<p class="callout"><span class="koboSpan" id="kobo.595.1">The solution shown here with </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">compare_exchange_weak()</span></strong><span class="koboSpan" id="kobo.597.1"> is one of many options at our disposal. </span><span class="koboSpan" id="kobo.597.2">It was preferred for this book because it’s an interesting approach for a general solution to the concurrent update problem and opens up optimization opportunities if you are comfortable with memory order constraints (which we will not go into here). </span><span class="koboSpan" id="kobo.597.3">In this specific case, we could have replaced the loop with something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">if((*ctr)-- == 1)</span></strong><span class="koboSpan" id="kobo.599.1">, as if one decrements </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">*ctr</span></strong><span class="koboSpan" id="kobo.601.1"> atomically and the value previously held was </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">1</span></strong><span class="koboSpan" id="kobo.603.1">, then we know for a fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">*ctr</span></strong><span class="koboSpan" id="kobo.605.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">now </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.609.1">The other important member functions of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.611.1"> implementation involve comparison (</span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">operator==</span></strong><span class="koboSpan" id="kobo.613.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">operator!=</span></strong><span class="koboSpan" id="kobo.615.1">), the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">get()</span></strong><span class="koboSpan" id="kobo.617.1"> member functions that let one obtain the underlying, raw </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">T*</span></strong><span class="koboSpan" id="kobo.619.1"> for code that needs it, and the indirection operators that are </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">operator*()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.621.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">operator-&gt;()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.624.1">
      // ...
</span><span class="koboSpan" id="kobo.624.2">      bool operator==(const shared_ptr &amp;other)
         const noexcept { return p == other.p; }
      // inferred from operator==() since C++20
      bool operator!=(const shared_ptr &amp;other)
         const noexcept { return !(*this == other); }
      T *get() noexcept { return p; }
      const T *get() const noexcept { return p; }
      T&amp; operator*() noexcept { return *p; }
      const T&amp; operator*() const noexcept { return *p; }
      T* operator-&gt;() noexcept { return p; }
      const T* operator-&gt;() const noexcept { return p; }
   };
}</span></pre> <p><span class="koboSpan" id="kobo.625.1">If you want to, feel</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.626.1"> free to apply the “deduced </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">this</span></strong><span class="koboSpan" id="kobo.628.1">” C++23 feature shown in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.630.1"> section earlier to simplify this code. </span><span class="koboSpan" id="kobo.630.2">Also remember that in C++20, </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">operator!=()</span></strong><span class="koboSpan" id="kobo.632.1"> will be inferred from </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">operator==()</span></strong><span class="koboSpan" id="kobo.634.1"> and does not need to be written explicitly in the </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">source code.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">A very simple example of client code for this smart pointer would be </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;iostream&gt;
using namespace std::literals;
struct X {
   int n;
   X(int n) : n{ n } {}
   ~X() { std::cout &lt;&lt; "X::~X()\n"; }
};
int main() {
   using managing_memory_book::shared_ptr;
   std::mt19937 prng{ std::random_device{}() };
   std::uniform_int_distribution&lt;int&gt; die{ 200, 300 };
   shared_ptr&lt;X&gt; p{ new X{ 3 } };
   using std::chrono::milliseconds; // shortcut
   std::thread th0{ [p, dt = die(prng)] {
      std::this_thread::sleep_for(milliseconds{dt});
      std::cout &lt;&lt; "end of th0, p-&gt;n : " &lt;&lt; p-&gt;n &lt;&lt; '\n';
   } };
   std::thread th1{ [p, dt = die(prng)] {
      std::this_thread::sleep_for(milliseconds{dt});
      std::cout &lt;&lt; "end of th1, p-&gt;n : " &lt;&lt; p-&gt;n &lt;&lt; '\n';
   } };
   th1.detach();
   th0.detach();
   std::this_thread::sleep_for(350ms);
   std::cout &lt;&lt; "end main()\n";
}</span></pre> <p><span class="koboSpan" id="kobo.639.1">In this </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.640.1">example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">th0</span></strong><span class="koboSpan" id="kobo.642.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">th1</span></strong><span class="koboSpan" id="kobo.644.1"> both sleep for a pseudorandom number of milliseconds, then display something and conclude execution, so we cannot know in advance which of </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">th0</span></strong><span class="koboSpan" id="kobo.646.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">th1</span></strong><span class="koboSpan" id="kobo.648.1"> will conclude first; both threads are detached, which means there is no later point at which we will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">join()</span></strong><span class="koboSpan" id="kobo.650.1"> on them, so we cannot suppose that </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">main()</span></strong><span class="koboSpan" id="kobo.652.1"> is the last user of the </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">shared resource.</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">The example is contrived to keep it simple, and it bears repeating that as </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.656.1"> is significantly more costly to use than </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.658.1"> would be, one will generally prefer the latter over the former when there is a clear last owner of </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">the resource.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.660.1">A few words on make_shared()</span></h2>
<p><span class="koboSpan" id="kobo.661.1">It is possible </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.662.1">that when reading about C++ in general and </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.664.1"> in particular, you might have read that, whenever possible, it is recommended practice to </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">replace this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.666.1">
std::shared_ptr&lt;X&gt; p{ new X { /* ... </span><span class="koboSpan" id="kobo.666.2">args ... </span><span class="koboSpan" id="kobo.666.3">*/ };</span></pre> <p><span class="koboSpan" id="kobo.667.1">Replace it with </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.669.1">
auto p= std::make_shared&lt;X&gt;( /* ... </span><span class="koboSpan" id="kobo.669.2">args ... </span><span class="koboSpan" id="kobo.669.3">*/ );</span></pre> <p><span class="koboSpan" id="kobo.670.1">If that is the case, you might be wondering (a) why this is recommended practice, and (b) why we have not addressed it yet. </span><span class="koboSpan" id="kobo.670.2">The answer to (a) we can provide now, but the answer to (b) is that we will need to wait until we reach </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.671.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.672.1"> to have the tools and knowledge required to implement such </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">a facility.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">To understand why we recommend preferring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">make_shared&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.676.1"> factory function to a direct call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.678.1"> constructor, the key idea is that with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.680.1"> constructor, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">T</span></strong><span class="koboSpan" id="kobo.682.1"> object is allocated by client code, and given to </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.684.1"> under construction, which takes ownership of that pointer and allocates a shared counter </span><em class="italic"><span class="koboSpan" id="kobo.685.1">separately</span></em><span class="koboSpan" id="kobo.686.1">. </span><span class="koboSpan" id="kobo.686.2">We then end up with two allocations (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">T</span></strong><span class="koboSpan" id="kobo.688.1"> object and the counter), probably on separate </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">cache lines.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">Now, if we go through </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">make_shared&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.692.1">, this factory function is responsible for allocating both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">T</span></strong><span class="koboSpan" id="kobo.694.1"> object </span><em class="italic"><span class="koboSpan" id="kobo.695.1">and</span></em><span class="koboSpan" id="kobo.696.1"> the counter, perfectly forwarding the arguments received by the function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">T</span></strong><span class="koboSpan" id="kobo.698.1"> constructor. </span><span class="koboSpan" id="kobo.698.2">Since the same function performs both allocations, it can fuse them in a single allocation of a memory block that contains both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">T</span></strong><span class="koboSpan" id="kobo.700.1"> object and the counter, </span><em class="italic"><span class="koboSpan" id="kobo.701.1">putting them both on the same cache line</span></em><span class="koboSpan" id="kobo.702.1">. </span><span class="koboSpan" id="kobo.702.2">This can lead to enhanced performance characteristics if a single thread tends to read from both pointers (</span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">T*</span></strong><span class="koboSpan" id="kobo.704.1"> and the counter) in a short time span, but (as can sometimes be the case) can be hurtful if another thread observes frequent changes to the counter’s value. </span><span class="koboSpan" id="kobo.704.2">As is often the case in optimization-related situations, measure and make sure what works well in general is also good for your own, specific </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">Clearly, to achieve this optimization, we need to be able to create such a block (conceptually, a struct containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">T</span></strong><span class="koboSpan" id="kobo.708.1"> and an atomic integral) and make sure that </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.710.1"> can contain either representation (two separate pointers or a pointer to a block with two objects) while remaining usable and efficient. </span><span class="koboSpan" id="kobo.710.2">Controlled use of the tricks seen in </span><a href="B21071_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.711.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.712.1"> and </span><a href="B21071_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.713.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.714.1"> will be helpful when we </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">get there.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.716.1">Writing a policy-based duplicating pointer</span></h1>
<p><span class="koboSpan" id="kobo.717.1">Let’s leave aside the</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.718.1"> standard smart pointers for a moment. </span><span class="koboSpan" id="kobo.718.2">Suppose we seek to write a smart pointer type whose semantics fit neither the sole ownership mold of </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.720.1"> nor the shared ownership mold of </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">std::shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.722.1">. </span><span class="koboSpan" id="kobo.722.2">For the sake of this example, suppose more specifically that we want single ownership semantics but, unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.724.1">, which is movable but non-copyable, we want duplication of the pointer to lead to duplication of the pointee. </span><span class="koboSpan" id="kobo.724.2">What can </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">we do?</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">Well, this is C++, so we can of course write our own. </span><span class="koboSpan" id="kobo.726.2">Let’s call this new smart pointer type of ours </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">dup_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.728.1"> (for “duplicating pointer”, or “pointer that duplicates the pointee”). </span><span class="koboSpan" id="kobo.728.2">Since we examined how one could implement sole ownership through our homemade </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.730.1"> earlier in this chapter, this section will mostly focus on the question of duplicating </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">the pointee.</span></span></p>
<p><span class="koboSpan" id="kobo.732.1">What do we mean by duplication? </span><span class="koboSpan" id="kobo.732.2">Well, there are two expected cases: copying an object of a non-polymorphic type and copying an object of a polymorphic type, with polymorphic meaning “with at least one </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">virtual</span></strong><span class="koboSpan" id="kobo.734.1"> member function” for the sake of this example. </span><span class="koboSpan" id="kobo.734.2">Of course, programmers, being highly inventive creatures, know that someone will end up with more exotic situations so we will try to take care of the aforementioned “expected cases” and leave a door open for those with </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">unusual applications.</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">Why is there a difference between polymorphic and non-polymorphic types? </span><span class="koboSpan" id="kobo.736.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">following program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.738.1">
struct X { int n; };
struct B {
   int n;
   B(int n) : n{ n } {}
   virtual ~B() = default;
};
struct D0 : B {
   D0(int n) : B{ n } { /* ... </span><span class="koboSpan" id="kobo.738.2">*/ }
   // ...
</span><span class="koboSpan" id="kobo.738.3">};
struct D1 : B {
   D1(int n) : B{ n } { /* ... </span><span class="koboSpan" id="kobo.738.4">*/ }
   // ...
</span><span class="koboSpan" id="kobo.738.5">};
// precondition: p != nullptr (to keep things simple)
X* duplicate(X *p) {
   return new X{ *p }; // Ok
}
// precondition: p != nullptr (to keep things simple)
B* duplicate(B *p) {
   return new B{ *p }; // Bad idea!
</span><span class="koboSpan" id="kobo.738.6">}
#include &lt;memory&gt;
int main() {
   using std::unique_ptr;
   X x{ 3 };
   unique_ptr&lt;X&gt; px { duplicate(&amp;x) };
   D0 d0{ 4 };
   unique_ptr&lt;B&gt; pb{ duplicate(&amp;d0) }; // trouble ahead
}</span></pre> <p><span class="koboSpan" id="kobo.739.1">We can </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.740.1">suppose that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">duplicate(X*)</span></strong><span class="koboSpan" id="kobo.742.1"> function can safely create an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">X</span></strong><span class="koboSpan" id="kobo.744.1"> type since </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">X</span></strong><span class="koboSpan" id="kobo.746.1"> has no </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">virtual</span></strong><span class="koboSpan" id="kobo.748.1"> member function and, as such, is probably not meant to serve as a public base class. </span><span class="koboSpan" id="kobo.748.2">However, there is a high probability that </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">duplicate(B*)</span></strong><span class="koboSpan" id="kobo.750.1"> does the wrong thing by calling the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">B</span></strong><span class="koboSpan" id="kobo.752.1">, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">B*</span></strong><span class="koboSpan" id="kobo.754.1"> passed as an argument could be </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">B</span></strong><span class="koboSpan" id="kobo.756.1"> or a pointer to an object of any class derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">B</span></strong><span class="koboSpan" id="kobo.758.1"> (here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">D0*</span></strong><span class="koboSpan" id="kobo.760.1">). </span><span class="koboSpan" id="kobo.760.2">Hence, calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">new B{ *p };</span></strong><span class="koboSpan" id="kobo.762.1"> only constructs the base part, slicing away any state from the pointed-to object and resulting in a probably </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">incorrect program.</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">As is well</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.765.1"> known in object-oriented programming circles, the customary way to duplicate an object of a polymorphic type is through </span><em class="italic"><span class="koboSpan" id="kobo.766.1">subjective duplication</span></em><span class="koboSpan" id="kobo.767.1">, otherwise</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.768.1"> known as </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">cloning</span></strong><span class="koboSpan" id="kobo.770.1">. </span><span class="koboSpan" id="kobo.770.2">Expressed informally, when one holds a pointer to an object with at least one </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">virtual</span></strong><span class="koboSpan" id="kobo.772.1"> member function, the only entity that can really claim to know the type of the pointee is… the </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">pointee itself.</span></span></p>
<p><span class="koboSpan" id="kobo.774.1">What </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">dup_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.776.1"> will do, then, is to pick a </span><em class="italic"><span class="koboSpan" id="kobo.777.1">duplication policy</span></em><span class="koboSpan" id="kobo.778.1"> based on the characteristics of </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">T</span></strong><span class="koboSpan" id="kobo.780.1">: by default, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">T</span></strong><span class="koboSpan" id="kobo.782.1"> is polymorphic, then we will duplicate through cloning; otherwise, we will duplicate through copying. </span><span class="koboSpan" id="kobo.782.2">Of course, we will let the client code specify a custom duplication mechanism </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.784.1">We will explore three approaches to this selection of a default duplication policy: an intrusive approach based on interfaces, a non-intrusive approach based on traits and compile-time detection of a cloning member function using C++17 features, and another non-intrusive approach based on </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">C++20 concepts.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.786.1">Detection through interfaces</span></h2>
<p><span class="koboSpan" id="kobo.787.1">One thing </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.788.1">we could do in user code is impose that cloneable types implement a specific interface, as in </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.790.1">
struct cloneable {
   virtual cloneable * clone() const = 0;
   virtual ~cloneable() = default;
};</span></pre> <p><span class="koboSpan" id="kobo.791.1">Such a solution is probably not standardization-worthy: it is intrusive, imposes some overhead (we are assuming that cloneable types will be polymorphic types, something that is likely but not mandatory), and so on. </span><span class="koboSpan" id="kobo.791.2">It can be a solution for your own code base, of course. </span><span class="koboSpan" id="kobo.791.3">Applying this idea to a revisitation of the example that mishandled duplication of a polymorphic type, earlier, we end up with </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.793.1">// ... </span><span class="koboSpan" id="kobo.793.2">type cloneable</span></strong><span class="koboSpan" id="kobo.794.1">
struct X { int n; };
struct B : </span><strong class="bold"><span class="koboSpan" id="kobo.795.1">cloneable { // every B is cloneable</span></strong><span class="koboSpan" id="kobo.796.1">
   int n;
   B(int n) : n{ n } {}
   virtual ~B() = default;
   B * clone()
</span><strong class="bold"><span class="koboSpan" id="kobo.797.1">protected: // cloneable types are meaningfully copied</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.798.1">           // in a subjective manner</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.799.1">   B(const B&amp;) = default;</span></strong><span class="koboSpan" id="kobo.800.1">
};
struct D0 : B {
   D0(int n) : B{ n } { /* ... </span><span class="koboSpan" id="kobo.800.2">*/ }
   </span><strong class="bold"><span class="koboSpan" id="kobo.801.1">D0* clone() const override { return new D0{ *this }; }</span></strong><span class="koboSpan" id="kobo.802.1">
   // ...
</span><span class="koboSpan" id="kobo.802.2">};
struct D1 : B {
   D1(int n) : B{ n } { /* ... </span><span class="koboSpan" id="kobo.802.3">*/ }
   </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">D1* clone() const override { return new D1{ *this }; }</span></strong><span class="koboSpan" id="kobo.804.1">
   // ...
</span><span class="koboSpan" id="kobo.804.2">};</span></pre> <p><span class="koboSpan" id="kobo.805.1">Now, suppose</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.806.1"> we want to develop a skeleton of </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">dup_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.808.1"> that copies types that are not derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">cloneable</span></strong><span class="koboSpan" id="kobo.810.1"> and clones types that are. </span><span class="koboSpan" id="kobo.810.2">To that effect, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">std::conditional</span></strong><span class="koboSpan" id="kobo.812.1"> type trait and choose between two function object types, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">Copier</span></strong><span class="koboSpan" id="kobo.814.1"> type that copies and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">Cloner</span></strong><span class="koboSpan" id="kobo.816.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">that clones:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.818.1">// ... </span><span class="koboSpan" id="kobo.818.2">type cloneable</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.819.1">struct Copier {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.820.1">   template &lt;class T&gt; T* operator()(const T *p) const {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.821.1">      return new T{ *p };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.822.1">   }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.823.1">};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.824.1">struct Cloner {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.825.1">   template &lt;class T&gt; T* operator()(const T *p) const {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.826.1">      return p-&gt;clone();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.827.1">   }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.828.1">};</span></strong><span class="koboSpan" id="kobo.829.1">
#include &lt;type_traits&gt;
template &lt;class T,
          </span><strong class="bold"><span class="koboSpan" id="kobo.830.1">class Dup = std::conditional_t&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.831.1">             std::is_base_of_v&lt;cloneable, T&gt;,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.832.1">             Cloner, Copier</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.833.1">          &gt;&gt;</span></strong><span class="koboSpan" id="kobo.834.1">
class dup_ptr {
   T *p{};
   // use an object of type </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">Dup</span></strong><span class="koboSpan" id="kobo.836.1"> when duplication is
   // required: copy constructor and copy assignment
   // ...
</span><span class="koboSpan" id="kobo.836.2">public:
   dup_ptr(const dup_ptr &amp;other)
      : p{ other.empty()? </span><span class="koboSpan" id="kobo.836.3">nullptr </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">: Dup{}(other.p)</span></strong><span class="koboSpan" id="kobo.838.1"> } {
   }
   // ...
</span><span class="koboSpan" id="kobo.838.2">};</span></pre> <p><span class="koboSpan" id="kobo.839.1">This </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.840.1">implementation supposes a stateless (no member variables) </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">Dup</span></strong><span class="koboSpan" id="kobo.842.1"> type, which is highly probable but should be documented in practice (if we accept stateful </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">Dup</span></strong><span class="koboSpan" id="kobo.844.1"> types, we need to instantiate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">Dup</span></strong><span class="koboSpan" id="kobo.846.1"> object and write code to copy and move that object, leading to a much more involved implementation). </span><span class="koboSpan" id="kobo.846.2">With this implementation, any type that derives from </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">cloneable</span></strong><span class="koboSpan" id="kobo.848.1"> will be cloned and other types will be copied, unless the user code supplies an exotic implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">Dup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.850.1"> type.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.851.1">Detection through traits</span></h2>
<p><span class="koboSpan" id="kobo.852.1">If we do not </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.853.1">want to impose a base class to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">cloneable</span></strong><span class="koboSpan" id="kobo.855.1"> types, we can use type traits to detect the presence of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">const</span></strong><span class="koboSpan" id="kobo.857.1">-qualified </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">clone()</span></strong><span class="koboSpan" id="kobo.859.1"> member function and suppose this is a reasonable claim that cloning is a better choice than copying. </span><span class="koboSpan" id="kobo.859.2">Note that this non-intrusiveness supposes an unspoken agreement on the meaning </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">clone()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.863.1">We can achieve this in many ways, but the cleanest and most general one probably uses Dr. </span><span class="koboSpan" id="kobo.863.2">Walter Brown’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">std::void_t</span></strong><span class="koboSpan" id="kobo.865.1"> type, found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">&lt;type_traits&gt;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.867.1">since C++17:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.868.1">// types Cloner and Copier (see above)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.869.1">template &lt;class, class = void&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.870.1">   struct has_clone : std::false_type { };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.871.1">template &lt;class T&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.872.1">   struct has_clone &lt;T, std::void_t&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.873.1">      decltype(std::declval&lt;const T*&gt;()-&gt;clone())</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.874.1">   &gt;&gt; : std::true_type { };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.875.1">template &lt;class T&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.876.1">   constexpr bool has_clone_v = has_clone&lt;T&gt;::value;</span></strong><span class="koboSpan" id="kobo.877.1">
template &lt;class T, </span><strong class="bold"><span class="koboSpan" id="kobo.878.1">class Dup = std::conditional_t&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.879.1">             has_clone_v&lt;T&gt;, Cloner, Copier</span></strong><span class="koboSpan" id="kobo.880.1">
&gt;&gt; class dup_ptr {
   T *p{};
public:
   // ...
</span><span class="koboSpan" id="kobo.880.2">   dup_ptr(const dup_ptr &amp;other)
      : p{ other.empty()? </span><span class="koboSpan" id="kobo.880.3">nullptr </span><strong class="bold"><span class="koboSpan" id="kobo.881.1">: Dup{}(other.p)</span></strong><span class="koboSpan" id="kobo.882.1"> } {
   }
   // ...
</span><span class="koboSpan" id="kobo.882.2">};</span></pre> <p><span class="koboSpan" id="kobo.883.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">std::void_t</span></strong><span class="koboSpan" id="kobo.885.1"> type is a brilliant piece of work that lets knowledgeable people simulate, in a</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.886.1"> limited manner but for general expressions, what </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">requires</span></strong><span class="koboSpan" id="kobo.888.1"> has allowed since C++20. </span><span class="koboSpan" id="kobo.888.2">The way to read this example is </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.890.1">In general, </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">has_clone&lt;T&gt;::value</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.892.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">false</span></strong></span></li>
<li><span class="koboSpan" id="kobo.894.1">For any </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">T</span></strong><span class="koboSpan" id="kobo.896.1"> type for which </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">p-&gt;clone()</span></strong><span class="koboSpan" id="kobo.898.1"> for some </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">const T*</span></strong><span class="koboSpan" id="kobo.900.1"> object </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">p</span></strong><span class="koboSpan" id="kobo.902.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">has_clone&lt;T&gt;::value</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.904.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">true</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.906.1">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">Dup</span></strong><span class="koboSpan" id="kobo.908.1"> type has been chosen, normal operations continue. </span><span class="koboSpan" id="kobo.908.2">The advantage of this implementation over the previous one is that this one checks for the existence of a suitably written </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">clone()</span></strong><span class="koboSpan" id="kobo.910.1"> member function, whereas the previous one checks for the existence of a specific base class. </span><span class="koboSpan" id="kobo.910.2">Implementing a function is a lighter contract than deriving from a specific </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">base class.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.912.1">A word on std::void_t</span></p>
<p class="callout"><span class="koboSpan" id="kobo.913.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">std::void_t</span></strong><span class="koboSpan" id="kobo.915.1"> type is a </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.916.1">brilliant piece of work. </span><span class="koboSpan" id="kobo.916.2">Using it relies on </span><strong class="bold"><span class="koboSpan" id="kobo.917.1">substitution failure is not an error</span></strong><span class="koboSpan" id="kobo.918.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.919.1">SFINAE</span></strong><span class="koboSpan" id="kobo.920.1">) to</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.921.1"> choose between a basic, general implementation that says “no” and a specialized version that says “yes” when some expression is well-formed. </span><span class="koboSpan" id="kobo.921.2">In our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">has_clone&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.923.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">false</span></strong><span class="koboSpan" id="kobo.925.1"> for most types but is </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">true</span></strong><span class="koboSpan" id="kobo.927.1"> when expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">p-&gt;clone()</span></strong><span class="koboSpan" id="kobo.929.1"> is valid for some </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">const T*</span></strong><span class="koboSpan" id="kobo.931.1"> object </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">p</span></strong><span class="koboSpan" id="kobo.933.1">. </span><span class="koboSpan" id="kobo.933.2">That we can easily test the validity of any expression even before concepts came into their own is just beautiful, and we owe Dr. </span><span class="koboSpan" id="kobo.933.3">Walter Brown much for this gem (among many </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">other gems).</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.935.1">Detection through concepts</span></h2>
<p><span class="koboSpan" id="kobo.936.1">Since C++20, tricks </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.937.1">such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">std::void_t</span></strong><span class="koboSpan" id="kobo.939.1"> are less useful than they were since concepts are now part of the language’s type system. </span><span class="koboSpan" id="kobo.939.2">Through concepts, we can define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">cloneable</span></strong><span class="koboSpan" id="kobo.941.1"> type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">T</span></strong><span class="koboSpan" id="kobo.943.1">, to be something for which a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">clone()</span></strong><span class="koboSpan" id="kobo.945.1"> is well-formed on </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">const T*</span></strong><span class="koboSpan" id="kobo.947.1"> and yields something that is convertible </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">T*</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.951.1">With this, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.953.1">template &lt;class T&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.954.1">   concept cloneable = requires(const T *p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.955.1">      { p-&gt;clone() } -&gt; std::convertible_to&lt;T*&gt;;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.956.1">   };</span></strong><span class="koboSpan" id="kobo.957.1">
template &lt;class T, </span><strong class="bold"><span class="koboSpan" id="kobo.958.1">class Dup = std::conditional_t&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.959.1">            cloneable&lt;T&gt;, Cloner, Copier</span></strong><span class="koboSpan" id="kobo.960.1">
&gt;&gt; class dup_ptr {
   T *p{};
public:
   // ...
</span><span class="koboSpan" id="kobo.960.2">   dup_ptr(const dup_ptr &amp;other)
      : p{ other.empty()? </span><span class="koboSpan" id="kobo.960.3">nullptr </span><strong class="bold"><span class="koboSpan" id="kobo.961.1">: Dup{}(other.p)</span></strong><span class="koboSpan" id="kobo.962.1"> } {
   }
   // ...
</span><span class="koboSpan" id="kobo.962.2">};</span></pre> <p><span class="koboSpan" id="kobo.963.1">Concepts, like traits, are a non-intrusive solution to this problem. </span><span class="koboSpan" id="kobo.963.2">Where traits are a programming technique, however, they are ingrained in the type system and we can (for example) write code that’s specialized for </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">cloneable&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.965.1"> and code that is not. </span><span class="koboSpan" id="kobo.965.2">In our case, the fact that we want to leave the door open for types that use neither the copy constructor nor a </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">clone()</span></strong><span class="koboSpan" id="kobo.967.1"> member function suggests that the current setup, which lets </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.968.1">client code supply other duplication mechanisms, is </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">probably preferable.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.970.1">C++26</span></p>
<p class="callout"><span class="koboSpan" id="kobo.971.1">C++26 will contain two standard types named </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">std::indirect</span></strong><span class="koboSpan" id="kobo.973.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">std::polymorphic</span></strong><span class="koboSpan" id="kobo.975.1"> that will cover a niche close to the one described by this </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">dup_ptr</span></strong><span class="koboSpan" id="kobo.977.1">. </span><span class="koboSpan" id="kobo.977.2">It was voted in on February </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">15 2025.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.979.1">Some not-so-smart yet useful smart pointers</span></h1>
<p><span class="koboSpan" id="kobo.980.1">So we have standard smart pointers, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.982.1"> (single ownership) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.984.1"> (shared ownership), and we can write our own for more exotic situations (we examined </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">dup_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.986.1"> where we have single ownership but duplication of the pointee when the pointer is duplicated). </span><span class="koboSpan" id="kobo.986.2">Are there other common semantics we might want to ensconce in the type system of </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">our program?</span></span></p>
<p><span class="koboSpan" id="kobo.988.1">Well, there are at least two “easy” ones one could think of: implementing a “never null” semantic and implementing an “only </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">observing” semantic.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.990.1">A non_null_ptr type</span></h2>
<p><span class="koboSpan" id="kobo.991.1">Let’s go</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.992.1"> back to an earlier example where we wrote </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.994.1">
// ...
</span><strong class="bold"><span class="koboSpan" id="kobo.995.1">// precondition: p != nullptr (to keep things simple)</span></strong><span class="koboSpan" id="kobo.996.1">
X* duplicate(X *p) {
   return new X{ *p }; // Ok
}
// ...</span></pre> <p><span class="koboSpan" id="kobo.997.1">Note the comment, which puts the burden of not supplying a null pointer on user code. </span><span class="koboSpan" id="kobo.997.2">We could have approached this constraint in many other ways, including </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.999.1">Asserting </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">!p</span></strong></span></li>
<li><span class="koboSpan" id="kobo.1001.1">Calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">std::abort()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1003.1">if </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">!p</span></strong></span></li>
<li><span class="koboSpan" id="kobo.1005.1">Calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">std::terminate()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1007.1">if </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">!p</span></strong></span></li>
<li><span class="koboSpan" id="kobo.1009.1">Throwing if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">!p</span></strong><span class="koboSpan" id="kobo.1011.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">so on</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1013.1">The important thing is that if we care about pointers being non-null, and if we inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">if(!p)</span></strong><span class="koboSpan" id="kobo.1015.1"> tests in our runtime code, we are probably doing something wrong as this could (or should?) be part of the type system: </span><em class="italic"><span class="koboSpan" id="kobo.1016.1">this function only accepts non-null pointers</span></em><span class="koboSpan" id="kobo.1017.1">. </span><span class="koboSpan" id="kobo.1017.2">Code speaks louder </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">than comments.</span></span></p>
<p><span class="koboSpan" id="kobo.1019.1">This idea </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.1020.1">appears in some commercial libraries (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">gsl::non_null&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1022.1"> from the guideline support library offered by some major compiler vendors) and is easy to implement as long as one has a clear way of signaling errors. </span><span class="koboSpan" id="kobo.1022.2">For the sake of the example, we will suppose that this clear way is throwing </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">an exception:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1024.1">
class invalid_pointer {};
template &lt;class T&gt;
   class non_null_ptr {
      T *p;
   public:
      </span><strong class="bold"><span class="koboSpan" id="kobo.1025.1">non_null_ptr(T *p) : p{ p } {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1026.1">         if (!p) throw invalid_pointer{};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1027.1">      }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1028.1">      T* get() const { return p; }</span></strong><span class="koboSpan" id="kobo.1029.1">
      constexpr operator bool() const noexcept {
         return true;
      }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1030.1">Using this type, any function that accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">non_null_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1032.1"> argument knows that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">T*</span></strong><span class="koboSpan" id="kobo.1034.1"> pointer therein will be non-null, relieving client code from the burden of validation. </span><span class="koboSpan" id="kobo.1034.2">This makes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">non_null_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1036.1"> a beautiful type for the interface of functions that expect a </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">non-null </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">T*</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1040.1">The rest of this class is mostly trivial to write at this point. </span><span class="koboSpan" id="kobo.1040.2">The key peculiarity is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">non_null_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1042.1"> will not expose a default constructor, as that constructor would have to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">p</span></strong><span class="koboSpan" id="kobo.1044.1"> data member to some default value (probably </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">nullptr</span></strong><span class="koboSpan" id="kobo.1046.1">) but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">non_null_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1048.1"> type models a non-null pointer, which would lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">nonsensical code.</span></span></p>
<p><span class="koboSpan" id="kobo.1050.1">In terms of </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.1051.1">usage, take a look </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">at this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
struct X { int n; };
class invalid {};
int extract_value(</span><strong class="bold"><span class="koboSpan" id="kobo.1054.1">const X *p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1055.1">   if(!p) throw invalid{};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1056.1">   return p-&gt;n;</span></strong><span class="koboSpan" id="kobo.1057.1">
}
#include &lt;iostream&gt;
int main() try {
   X x{ 3 };
   std::cout &lt;&lt; extract_value(&amp;x) &lt;&lt; '\n'
             &lt;&lt; extract_value(nullptr) &lt;&lt; '\n';
} catch(invalid) {
   std::cerr &lt;&lt; "oops\n";
}</span></pre> <p><span class="koboSpan" id="kobo.1058.1">Now, compare it with this, supposing that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">non_null_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1060.1"> throws when constructed with a </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">null pointer:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1062.1">// definition of the non_null_ptr type (omitted)</span></strong><span class="koboSpan" id="kobo.1063.1">
struct X { int n; };
int extract_value(</span><strong class="bold"><span class="koboSpan" id="kobo.1064.1">const non_null_ptr&lt;X&gt; &amp;p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1065.1">   return p-&gt;n; // no need for validation as it stems</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1066.1">                // from the type system itself</span></strong><span class="koboSpan" id="kobo.1067.1">
}
#include &lt;iostream&gt;
int main() try {
   X x{ 3 };
   std::cout &lt;&lt; extract_value(&amp;x) &lt;&lt; '\n'
             &lt;&lt; extract_value(nullptr) &lt;&lt; '\n';
} catch(...) {
   std::cerr &lt;&lt; "oops\n";
}</span></pre> <p><span class="koboSpan" id="kobo.1068.1">The two </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.1069.1">main advantages of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">non_null_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1071.1"> over </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">T*</span></strong><span class="koboSpan" id="kobo.1073.1"> in this case are that the type system documents the intent better with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">non_null_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1075.1"> (with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">T*</span></strong><span class="koboSpan" id="kobo.1077.1">, a null pointer might be fine, but with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">non_null_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1079.1">, it is clearly not) and that the called functions can proceed without validating, the validation being (again) ingrained in the type system. </span><span class="koboSpan" id="kobo.1079.2">Using a richer type than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">T*</span></strong><span class="koboSpan" id="kobo.1081.1"> makes both caller code and called </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">code better.</span></span></p>
<p><span class="koboSpan" id="kobo.1083.1">What if the called function needs </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">T*</span></strong><span class="koboSpan" id="kobo.1085.1">? </span><span class="koboSpan" id="kobo.1085.2">This can happen, for example, in the case where it needs to call a C function. </span><span class="koboSpan" id="kobo.1085.3">Well, then, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">non_null_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1087.1"> object’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">get()</span></strong><span class="koboSpan" id="kobo.1089.1"> member function. </span><span class="koboSpan" id="kobo.1089.2">C++ is nothing if </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">not pragmatic.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.1091.1">An observer_ptr type</span></h2>
<p><span class="koboSpan" id="kobo.1092.1">How </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.1093.1">about having a very dumb smart pointer type named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">observer_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1095.1"> that solely cares about expressing the idea that that “smart” pointer is, indeed, </span><em class="italic"><span class="koboSpan" id="kobo.1096.1">not</span></em><span class="koboSpan" id="kobo.1097.1"> a pointer, in the sense that operations that would apply to a raw pointer are restricted on that type. </span><span class="koboSpan" id="kobo.1097.2">The canonical issue is that applying </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">delete</span></strong><span class="koboSpan" id="kobo.1099.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">T*</span></strong><span class="koboSpan" id="kobo.1101.1"> would work but applying </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">delete</span></strong><span class="koboSpan" id="kobo.1103.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">observer_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1105.1"> would not since </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">observer_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1107.1"> is… not a pointer. </span><span class="koboSpan" id="kobo.1107.2">Indeed, consider </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1109.1">
class X { /* ... </span><span class="koboSpan" id="kobo.1109.2">*/ };
void f(</span><strong class="bold"><span class="koboSpan" id="kobo.1110.1">X *p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1111.1">   // use *p</span></strong><span class="koboSpan" id="kobo.1112.1">
   // we passed a raw pointer to f(), so f() should
   // observe it, not own it
</span><strong class="bold"><span class="koboSpan" id="kobo.1113.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1114.1">delete p; // wait! </span><span class="koboSpan" id="kobo.1114.2">You're not supposed to do that!</span></strong><span class="koboSpan" id="kobo.1115.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1116.1">You </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.1117.1">might say, as the comment states, “But that function’s not supposed to do that! </span><span class="koboSpan" id="kobo.1117.2">It does not own </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">*p</span></strong><span class="koboSpan" id="kobo.1119.1">!” </span><span class="koboSpan" id="kobo.1119.2">but, well, mistakes happen, as do misunderstandings. </span><span class="koboSpan" id="kobo.1119.3">In this case, the impact of misunderstandings is made worse by the fact that nothing in the argument’s type states that applying </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">operator delete</span></strong><span class="koboSpan" id="kobo.1121.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">p</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1123.1">is incorrect!</span></span></p>
<p><span class="koboSpan" id="kobo.1124.1">Now, let’s change the </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">signature slightly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1126.1">
class X { /* ... </span><span class="koboSpan" id="kobo.1126.2">*/ };
void f(</span><strong class="bold"><span class="koboSpan" id="kobo.1127.1">observer_ptr&lt;X&gt; p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1128.1">   // use *p</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1129.1">   // delete p; // nope, does not compile</span></strong><span class="koboSpan" id="kobo.1130.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1131.1">The “use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">*p</span></strong><span class="koboSpan" id="kobo.1133.1">” comment remains the same in both versions. </span><span class="koboSpan" id="kobo.1133.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">observer_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1135.1"> type offers almost trivial versions of all reasonable operators and member functions (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">get()</span></strong><span class="koboSpan" id="kobo.1137.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">operator*()</span></strong><span class="koboSpan" id="kobo.1139.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">operator-&gt;()</span></strong><span class="koboSpan" id="kobo.1141.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">empty()</span></strong><span class="koboSpan" id="kobo.1143.1">, and so on) so usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">T*</span></strong><span class="koboSpan" id="kobo.1145.1"> and of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">observer_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1147.1"> should be mostly equivalent in user code; the only difference is in misguided uses such as applying </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">delete</span></strong><span class="koboSpan" id="kobo.1149.1"> or performing </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">pointer arithmetic.</span></span></p>
<p><span class="koboSpan" id="kobo.1151.1">Sometimes, just clarifying intent in a function interface makes </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">code better.</span></span></p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.1153.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1154.1">In </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1155.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.1156.1">, we spent some time on the proper usage of standard smart pointers. </span><span class="koboSpan" id="kobo.1156.2">In the current chapter, we “dirtied our hands,” so to speak, and we wrote homemade (and simplified) versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1158.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1160.1">. </span><span class="koboSpan" id="kobo.1160.2">As mentioned more than once, this is meant as an educational exploration, as your library vendor assuredly provides significantly better (more complete, more performant, better tested, etc.) implementations in </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">both cases.</span></span></p>
<p><span class="koboSpan" id="kobo.1162.1">In this chapter, we also explored the possibility of providing homemade smart pointer types, with a policy-based </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">dup_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1164.1"> based on three distinct approaches to the selection of a duplication algorithm. </span><span class="koboSpan" id="kobo.1164.2">The intent was to show that it can be done, how it can be done, and how we can provide reasonable, usable defaults without blocking user code with more </span><span class="No-Break"><span class="koboSpan" id="kobo.1165.1">exotic requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.1166.1">Toward the end of this chapter, we examined some relatively simple (but useful) smart (well, lightly smart) pointers that can be used at the edges of functions (typically, as argument types) to make semantic requirements implicit through the type system instead of forcing user code to enforce these requirements explicitly… and sometimes fail to </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.1168.1">Unsurprisingly, memory management is not limited to smart pointers. </span><span class="koboSpan" id="kobo.1168.2">In the next chapter, we will explore how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">new</span></strong><span class="koboSpan" id="kobo.1170.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">new[]</span></strong><span class="koboSpan" id="kobo.1172.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">delete</span></strong><span class="koboSpan" id="kobo.1174.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">delete[]</span></strong><span class="koboSpan" id="kobo.1176.1"> operators work, how we can implement them ourselves, and why we sometimes want to </span><span class="No-Break"><span class="koboSpan" id="kobo.1177.1">do so.</span></span></p>
</div>


<div class="Content" epub:type="part" id="_idContainer023">
<h1 id="_idParaDest-113" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.1.1">Part 3: Taking Control (of Memory Management Mechanisms)</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, we will delve somewhat deeper and examine ways in which you can take over some of the core memory allocation mechanisms in the C++ language and customize them to your needs. </span><span class="koboSpan" id="kobo.2.2">We will see how you can control what operators such as new and delete do, how to use specialized knowledge to obtain specific execution properties, and how these operators can be used in innovative ways. </span><span class="koboSpan" id="kobo.2.3">We will also use this knowledge for a few real-life applications and to achieve fast, sometimes extremely fast, memory </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">management operations.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Overloading Memory Allocation Operators</span></em></li>
<li><a href="B21071_08.xhtml#_idTextAnchor128"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Writing a Naïve Leak Detector</span></em></li>
<li><a href="B21071_09.xhtml#_idTextAnchor141"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Atypical Allocation Mechanisms</span></em></li>
<li><a href="B21071_10.xhtml#_idTextAnchor153"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Arena-Based Memory Management and Other Optimizations</span></em></li>
<li><a href="B21071_11.xhtml#_idTextAnchor163"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.19.1">, </span><em class="italic"><span class="koboSpan" id="kobo.20.1">Deferred Reclamation</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer024">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer025">
</div>
</div>
</body></html>