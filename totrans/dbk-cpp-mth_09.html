<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-97">
    <a id="_idTextAnchor096">
    </a>
    
     9
    
   </h1>
   <h1 id="_idParaDest-98">
    <a id="_idTextAnchor097">
    </a>
    
     C++ Is Beautiful
    
   </h1>
   <p class="italic-heading">
    <em class="italic">
     
      According to the mirror on
     
    </em>
    
     <em class="italic">
      
       the wall
      
     </em>
    
   </p>
   <p>
    
     Dear reader.
    
    
     In this chapter, we won’t be focusing on teaching you specific concepts, techniques, or practical skills.
    
    
     Instead, our goal is to guide you through a different kind of experience, one that allows you to step back from the details and immerse yourself in the aesthetic aspects
    
    
     
      of coding.
     
    
   </p>
   <p>
    
     This chapter is designed to inspire you to see code in a new light, to recognize the patterns, symmetry, and even the poetry that can emerge when we write code with thoughtfulness
    
    
     
      and care.
     
    
   </p>
   <p>
    
     Beauty is a unique and personal experience because it arises from the intricate interplay of individual perception, emotional resonance, cultural influences, and personal identity.
    
    
     Each person interprets beauty through their own sensory and cognitive filters, shaped by their life experiences, memories, and cultural background.
    
    
     Emotional connections, mood, and personal taste further influence what one finds beautiful, making it a deeply subjective experience that reflects one’s unique perspective on
    
    
     
      the world.
     
    
   </p>
   <p>
    
     Some may find beauty in the fiery hues of a sunset over a Mediterranean island, while others might appreciate the crisp, cold allure of Scandinavian fjords.
    
    
     It is
    
    
     
      all personal.
     
    
   </p>
   <p>
    
     So, while there may not be concrete lessons or objectives in this chapter, it offers a unique opportunity to connect with the craft of coding on a more emotional and intellectual level.
    
    
     Through this journey, we hope you’ll come to see code not just as a means to an end but as something inherently beautiful in its
    
    
     
      own right.
     
    
   </p>
   <p>
    
     In this chapter, you will experience that
    
    
     
      there is:
     
    
   </p>
   <ul>
    <li>
     
      Nothing new to
     
     
      
       learn here...
      
     
    </li>
    <li>
     
      ...
     
     
      except the appreciation
     
     
      
       of beauty...
      
     
    </li>
    <li>
     
      ...
     
     
      while crafting code with techniques in mind that may disqualify you from ever sitting in front of a keyboard while writing professional code in an
     
     
      
       enterprise environment
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-99">
    <a id="_idTextAnchor098">
    </a>
    
     In search of beauty
    
   </h1>
   <p>
    
     Each programming language is a unique work of art, beautifully distinct in its design, philosophy, and the possibilities it offers; just as diverse are the programmers who use them, each bringing their own preferences, creativity, and personality to
    
    
     
      the craft.
     
    
   </p>
   <p>
    
     Some developers are drawn to the elegant simplicity and structure of Python, relishing the clarity and expressiveness that its neatly organized whitespace brings to their code.
    
    
     Others, however, find their joy in languages such as Forth, where they can freely push and pop the stack with precision having full control and conciseness of such low-level manipulation, while seemingly enjoying the challenge of constructing powerful systems with minimalistic syntax.
    
    
     Now really, is there anyone using
    
    
     
      Forth anymore?
     
    
   </p>
   <p>
    
     And then there are the bold adventurers who embrace the enigmatic world of Lisp, using its infamous long list of insipid and stubborn parenthesis.
    
    
     To these programmers, the apparent monotony of the syntax is a gateway to a rich and expressive metaprogramming landscape, where they can manipulate code as data in ways that feel almost alchemical, not to mention that they have direct access
    
    
     
      to Emacs.
     
    
   </p>
   <p>
    
     Last but not least, there are those of us, the tribe of C++ programmers, who think the magical beauty of a program can fully be expressed by the
    
    
     
      following line:
     
    
   </p>
   <pre class="source-code">
auto main()-&gt;int{return&lt;:]&lt;class _&gt;(_)-&gt;_&lt;%return 7;}(1);%&gt;</pre>
   <p>
    
     What
    
    <a id="_idIndexMarker314">
    </a>
    
     more C++ beauty do we need on this planet?
    
    
     A line of code that looks like a series of winking smileys, and in the end, it returns the lucky number seven to the caller.
    
    
     There is not a huge amount of technicality lying in the preceding code, just a plain lambda returning a number, and to confuse you, dear reader, we have used the trailing returning type for the
    
    <strong class="source-inline">
     
      main
     
    </strong>
    
     , because
    
    
     
      why not?
     
    
   </p>
   <p>
    
     Also, to add an even higher level of obscurity to our snippet, we have used, just for the sheer beauty of them, the infamous C++ digraphs.
    
    
     Unfortunately for them, the notorious trigraphs were deprecated in C++17 so we could not use them to spice up our code snippet.
    
    
     Actually, we could have used them, but we just
    
    
     
      wouldn’t dare.
     
    
   </p>
   <p>
    
     All that mayhem and confusion done in one line only.
    
    
     The real question that comes is can we make this even more
    
    
     
      cumbersome
     
    
    
     beautiful for you, dear reader, to read?
    
    
     And certainly, the answer to this certain question is a certain yes.
    
    
     And can we build it?
    
    
     Yes, we can!
    
    
     Almost...
    
    
     But firstly, we just have to get rid of the numbers,
    
    
     
      because hey...
     
    
   </p>
   <h2 id="_idParaDest-100">
    <a id="_idTextAnchor099">
    </a>
    
     Who likes numbers?
    
   </h2>
   <p>
    
     ...
    
    
     or more specifically, who needs numbers?
    
    
     Numbers can be highly confusing to people due to their
    
    <a id="_idIndexMarker315">
    </a>
    
     abstract nature, and the fact that we don’t really need them in our everyday
    
    <a id="_idIndexMarker316">
    </a>
    
     mundane life, which does not require higher-level thinking and the ability to grasp symbolic representations, makes them
    
    
     
      almost meaningless.
     
    
   </p>
   <p>
    
     Maybe this is why some tribes in the Amazon jungle didn’t even invent all of them (yes, I’m pointing at you, Munduruku tribe
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_09.xhtml#footnote-025">
       
        1
       
      </a>
     
    
    
     ).
    
    
     You have notions for none, one, two, up to five ...
    
    
     and then many.
    
    
     If it is enough for you, I can live
    
    
     
      with it.
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_09.xhtml#footnote-025-backlink">
      
       1
      
     </a>
     
      https://www.amazon.com/Alexs-Adventures-Numberland-Alex-Bellos/dp/1408809591
     
    </p>
   </div>
   <p>
    
     Let’s apply the ancient wisdom of the Amerindian people to our programming quest: to come up with the most beautiful C++ code snippet the world can see today.
    
    
     So, let’s get rid of those pesky numbers, keeping just 0 and 1 (for the sake of the almighty bits so that they don’t feel excluded), and let’s go tribal with the following
    
    
     
      code snippet:
     
    
   </p>
   <pre class="source-code">
#define __(...)sizeof(int[]){0,\
                               ##__VA_ARGS__}/sizeof(int)-1
auto main()-&gt;int{return&lt;:]&lt;class _&gt;(_)-&gt;_&lt;%return
__(_(), _(), _(), _(), _(), _(), _()) ;}(__());%&gt;</pre>
   <p>
    
     Oh, the sheer beauty of it.
    
    
     It brings tears of joy to our eyes, doesn’t it?
    
    
     Arguably, some picky programmers might have made some vitriolic comments about readability, maintainability, standard compliance, and so on...
    
    
     especially if they are using Microsoft’s (tiny, squishy) C++ compiler, which flatly refuses to compile the preceding code.
    
    
     But we rejoice with trembling that we made one of the compilers break, while all the other major players happily digest it
    
    
     
      and compile.
     
    
   </p>
   <p>
    
     But the code unfortunately contains a lot of duplicates, which we don’t really like.
    
    
     Nor do we need duplicates, so we should also get rid of at least one of them, shouldn’t we?
    
    
     Or all of them,
    
    
     
      why not?
     
    
   </p>
   <p>
    
     Because that is the real beauty of the C++ language.
    
    
     The capability to always redefine yourself, to provide a better version of the code at all costs, not considering the sacrifice made.
    
    
     Death
    
    <a id="_idIndexMarker317">
    </a>
    
     to readability.
    
    
     Death to maintainability!
    
    
     Long live the free code of chaos, mayhem,
    
    
     
      and confusion!
     
    
   </p>
   <p>
    
     So, brave warriors, our quest has been laid, prepare arms (I mean keyboards), and let’s save those bytes, just like the following code snippet
    
    
     
      shows us:
     
    
   </p>
   <pre class="source-code">
#define $$ sizeof
#define $ return
#define $_ int
#define __(...)$$($_[]){0,##__VA_ARGS__}/$$($_)-1
auto main()-&gt;$_&lt;%$&lt;::&gt;&lt;class _&gt;(_)-&gt;_&lt;%$
__(_(), _(), _(), _(), _(), _(), _()) ;%&gt;(__());%&gt;</pre>
   <p>
    
     Just look again at the sheer beauty of it.
    
    
     Again, the power of C++ shines through the dark clouds, like a thousand supernovae, and makes possible everything our heart desires, such as replacing a key element of the language, for example, the
    
    <strong class="source-inline">
     
      return
     
    </strong>
    
     keyword with a
    
    <strong class="source-inline">
     
      $
     
    </strong>
    
     sign.
    
    
     Not that it is part of the standard character set the language specified as the valid character set, but we will have a discussion about this, and some bears, a little
    
    
     
      bit later.
     
    
   </p>
   <p>
    
     But look at the bright side of the glass.
    
    
     At least we did not write the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
#define return(...) main
#define main(...) int
main(7)(return(7))(){
    return 7;
}</pre>
   <p>
    
     We have to admit, we contemplated writing it and adding it to the book, but after a glimpse at the future, we just thought that everything has its limits.
    
    
     Even the resilience of the most seasoned developers when it comes to nonsense (but regardless,
    
    
     
      fun) code.
     
    
   </p>
   <p>
    
     This is highly possibly the most evil piece of code we will present in this book because the level of evilness is comparable to the level of pain felt when you try to write a properly parenthesized Lisp program.
    
    
     Because what happens if you remove a parenthesis because there are too many, or, God forbid, add another one because you think it’d be a great idea?
    
    
     Believe me, dear reader, just
    
    
     
      don’t dare.
     
    
   </p>
   <p>
    
     So, please pretend that the preceding code is not in the book, and even if it is, you haven’t seen it.
    
    
     And even if you have seen it, you wouldn’t dare change the number of parenthesis
    
    
     
      in it.
     
    
   </p>
   <p>
    
     Enough of
    
    <a id="_idIndexMarker318">
    </a>
    
     the piece of evilness; now it is time to return to our previous code, which is in the competition for the most beautiful piece of C++ code this book
    
    
     
      can present.
     
    
   </p>
   <p>
    
     If only we could make it just a bit shorter, more concise, and more expressive, such as removing those ugly
    
    <strong class="source-inline">
     
      define
     
    </strong>
    
     and replacing them with something that expresses more beauty, more ...
    
    
     like
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
#ifndef MINK
#define MINK
#include __FILE__
DD $$ sizeof
DD $ return
DD $_ int
DD _$ _()
DD __(_...)$$($_[]){0,##_}/$$($_)-1
auto main()-&gt;$_&lt;%$&lt;::&gt;&lt;class _&gt;(_)-&gt;
$_&lt;%$ __(_$,_(),_$,_(),_$,_(),_$) ;%&gt;(__());%&gt;
#endif
#ifdef MINK
#define CAT(x, y) CAT_I(x, y)
#define CAT_I(x, y) x ## y
#define HH CAT(%, :)
#define DD HH define
#endif</pre>
   <p>
    
     Oh, it really hurts my eyes.
    
    
     Sorry about it, and apologies beforehand, but we cannot make this any more beautiful without incurring a very serious headache for
    
    
     
      the authors.
     
    
   </p>
   <p>
    
     While reading
    
    <a id="_idIndexMarker319">
    </a>
    
     this, we suddenly realize that just because there is already an obfuscated C code competition, we don’t really need to overdo its C++ counterpart.
    
    
     C++ by definition can be obfuscated enough without us actively trying to obfuscate it, but now, after presenting the preceding chimera, we actively owe an apology and an explanation to you, dear reader (on the other end, chimeras can be beautiful too; you just need to have the right eye
    
    
     
      for it).
     
    
   </p>
   <p>
    
     The first substantial observation we are concluding is that this code cannot be compiled by itself.
    
    
     If we try it, GCC will give errors,
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
error: stray '%:' in program
   15 | #define HH CAT(%, :)</pre>
   <p>
    
     ICC will complain,
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
error: "#" not expected here
  DD $$ sizeof</pre>
   <p>
    
     MSVC does not like that, as you
    
    
     
      can see:
     
    
   </p>
   <pre class="source-code">
error C2121: '#': invalid character: possibly the result of a macro expansion</pre>
   <p>
    
     Clang isn’t
    
    
     
      successful either:
     
    
   </p>
   <pre class="source-code">
error: expected unqualified-id
    4 | DD $$ sizeof
      | ^</pre>
   <p>
    
     So, basically, the compilers have commonly agreed that they cannot agree on a common error message or a reason for failure, but at least none of them can compile that piece of code.
    
    
     There are a few very on-the-point error messages, such as
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     is possibly the result of a macro expansion (but the author of these lines would like to see a macro that expands to
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     because
    
    <strong class="source-inline">
     
      #define D #
     
    </strong>
    
     is just not working regardless of
    
    <strong class="source-inline">
     
      D
     
    </strong>
    
     ) or another message concerning that stray
    
    <strong class="source-inline">
     
      %:
     
    </strong>
    
     in
    
    
     
      the program.
     
    
   </p>
   <p>
    
     All this
    
    <a id="_idIndexMarker320">
    </a>
    
     macro expansion and so on just leads us in the direction of macros.
    
    
     If you, dear reader, are not familiar with C or C++ macros, please go grab a book on them, such as
    
    <em class="italic">
     
      The C++ Programming Language
     
    </em>
    
     , by Bjarne Stroustrop, because this book (the one you are reading right now) deals only with macros of mythical fame, while that one (i.e.,
    
    <em class="italic">
     
      the
     
    </em>
    
     C++ book written by the father and creator of the language) teaches you to not to use them unless you really, really have to.
    
    
     And even
    
    
     
      then, sparsely.
     
    
   </p>
   <p>
    
     But back to our code.
    
    
     All decent compilers have the means to provide the result of the preprocessed C++ file, so let’s examine it for our program.
    
    
     By invoking
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     with the
    
    <strong class="source-inline">
     
      –E
     
    </strong>
    
     flag (or Clang with the same flag, or MSVC with the
    
    <strong class="source-inline">
     
      /P
     
    </strong>
    
     flag if you use the command line for it; otherwise, they will be accessible from the build directory of the project you are working on in Visual Studio), we get the
    
    
     
      following listing:
     
    
   </p>
   <pre class="source-code">
%: define $$ sizeof
%: define $ return
%: define $_ int
%: define _$ _()
%: define __(_...)$$($_[]){0,##_}/$$($_)-1
auto main()-&gt;$_&lt;%$&lt;::&gt;&lt;class _&gt;(_)-&gt;
$_&lt;%$ __(_$,_(),_$,_(),_$,_(),_$) ;%&gt;(__());%&gt;</pre>
   <p>
    
     We just show what is necessary for now and skip the compiler-specific line info, which is also added to the preprocessed output.
    
    
     So, as we can see, the preprocessed output looks like a very valid C++ file (albeit not very readable)...
    
    
     to our surprise, however, we can see several
    
    <strong class="source-inline">
     
      define
     
    </strong>
    
     directives actively present in the file.
    
    
     They are prepended by the
    
    <strong class="source-inline">
     
      %:
     
    </strong>
    
     symbol, which, after digraph substitution, will be transformed into the hashtag symbol (
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     ) and yield a
    
    
     
      valid program.
     
    
   </p>
   <p>
    
     In order to further understand what is happening here, we must understand how the compiler deals
    
    
     
      with macros.
     
    
   </p>
   <p>
    
     The C compiler (and of course C++ too)
    
    <a id="_idIndexMarker321">
    </a>
    
     expands macros through a methodical process managed by the preprocessor, beginning with tokenizing the source code and identifying macros for substitution.
    
    
     For object-like macros, a straightforward text replacement occurs, whereas function-like macros involve substituting the arguments provided in the macro invocation.
    
    
     Function-like macros (the ones that have a pair of parentheses) undergo an argument prescan, where macro arguments are fully expanded before being substituted into the macro body.
    
    
     This prescan ensures that nested macro calls within arguments are expanded correctly and that the final macro body is rescanned to catch any further macros
    
    
     
      for expansion.
     
    
   </p>
   <p>
    
     However, the prescan does not apply when arguments are stringized or concatenated, nor does it affect macros that are already marked as ineligible for re-expansion.
    
    
     This behavior mandates that in order to have proper expansion, we force the compiler to do a second pass on the concatenation macros, as
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
#define CAT(x, y) CAT_I(x, y)
#define CAT_I(x, y) x ## y</pre>
   <p>
    
     The preceding snippet ensures that all the required arguments are
    
    
     
      properly expanded.
     
    
   </p>
   <p>
    
     Special macros such as
    
    <strong class="source-inline">
     
      __LINE__
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      __TIME__
     
    </strong>
    
     are treated uniquely to prevent further unintended expansions.
    
    
     After all expansions are complete, the preprocessor ensures that no eligible macros are left unexpanded before passing the final code to the compiler.
    
    
     This comprehensive process ensures that macros are expanded efficiently and correctly, even in complex scenarios involving nested macros and
    
    
     
      stringification operations.
     
    
   </p>
   <p>
    
     Now that we have tried to explain how the macro substitution works on a level that is not that obvious for the first time, it is time to get back and finally compile our program.
    
    
     As you can remember, the preprocessed source still contained some statements that had
    
    <strong class="source-inline">
     
      define
     
    </strong>
    
     directives
    
    
     
      in them.
     
    
   </p>
   <p>
    
     Now, armed with this knowledge, we will reveal an arcane piece of knowledge to you, dear reader.
    
    
     In the end, this is a book about the mysticism of C++.
    
    
     This arcane piece of knowledge is something
    
    <a id="_idIndexMarker322">
    </a>
    
     called
    
    <strong class="bold">
     
      double preprocessing
     
    </strong>
    
     .
    
    
     Before continuing, however, a small detour on how the compiler deals with
    
    
     
      your code.
     
    
   </p>
   <p>
    
     During the initial stages of compiling a C++ source file, the compiler first undergoes preprocessing and compilation.
    
    
     In the preprocessing phase, the compiler expands macros (just like we have presented previously), processes conditional compilation directives (
    
    <strong class="source-inline">
     
      #ifdef
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      #ifndef
     
    </strong>
    
     , etc.), includes header files, and removes comments, resulting in a complete translation unit with all external files and macros fully resolved.
    
    
     Following this, in
    
    <a id="_idIndexMarker323">
    </a>
    
     the compilation phase, the preprocessed code is broken down into tokens during a phase called lexical analysis, which are then checked against the language’s syntax rules to
    
    <a id="_idIndexMarker324">
    </a>
    
     construct
    
    <a id="_idIndexMarker325">
    </a>
    
     a
    
    <strong class="bold">
     
      parse tree
     
    </strong>
    
     or
    
    <strong class="bold">
     
      abstract syntax
     
    </strong>
    
     <strong class="bold">
      
       tree
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       AST
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     This is followed by the phase called semantic analysis, where the compiler verifies the correct usage of types, variables, and functions, and potentially performs early optimizations.
    
    
     Finally, the compiler translates the AST into an
    
    <strong class="bold">
     
      intermediate representation
     
    </strong>
    
     (
    
    <strong class="bold">
     
      IR
     
    </strong>
    
     ), setting
    
    <a id="_idIndexMarker326">
    </a>
    
     the stage for further optimization and eventual machine code generation, but this is way out of the topics covered in this book.
    
    
     However, we would like to direct those of you who are interested in this topic to the famous “Dragon book”, also known as
    
    <em class="italic">
     
      Compilers: Principles, Techniques, and Tools
     
    </em>
    
     , by Alfred Aho, Jeffrey Ullman, Ravi Sethi, and Monica Lam.
    
    
     That is the go-to book for every programmer interested in developing a compiler, or just simply interested in learning about
    
    
     
      the techniques.
     
    
   </p>
   <p>
    
     But back to our double preprocessing technique.
    
    
     By using this technique, we will pass in the previous preprocessed source file into a compiler, using a technique known in Linux as piping and on Windows
    
    
     
      as hacking.
     
    
   </p>
   <p>
    
     The following is the Windows command that
    
    
     
      accomplishes this:
     
    
   </p>
   <pre class="console">
cl /P test.cpp &amp; cl /Tp test.i</pre>
   <p>
    
     The first part is producing the preprocessed file, which, in Visual C++ land, usually has the
    
    <strong class="source-inline">
     
      .i
     
    </strong>
    
     extension and the second part will take the preprocessed output, place it in
    
    <strong class="source-inline">
     
      test.i
     
    </strong>
    
     , and compile it as a C++ file (the
    
    <strong class="source-inline">
     
      /Tp
     
    </strong>
    
     switch is responsible for this).
    
    
     The result of this is the expected
    
    <strong class="source-inline">
     
      test.exe
     
    </strong>
    
     , which, after execution, performs exactly
    
    
     
      as desired.
     
    
   </p>
   <p>
    
     Under Linux, the sequence of commands is also
    
    
     
      very similar:
     
    
   </p>
   <pre class="console">
clang++ -E test.cpp | g++ -w -x c++ -std=c++20 -</pre>
   <p>
    
     The first part, before the pipe, produces the preprocessed code using
    
    <strong class="source-inline">
     
      clang++
     
    </strong>
    
     , which, using Linux pipe magic, is sent into
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     , because why not ☺.
    
    
     For this simple scenario, it wouldn’t have mattered if we had used the other way around, because these two compilers go hand in hand and they share the basic command-line options, such as
    
    <strong class="source-inline">
     
      –x c++
     
    </strong>
    
     to specify that the code it would compile is some sort of C++ code, or the version of the C++ standard this code complies to.
    
    
     The most important argument to the second compiler call is the last
    
    <strong class="source-inline">
     
      -
     
    </strong>
    
     sign, which tells the compiler to read the code from the stdin, instead of
    
    
     
      a file.
     
    
   </p>
   <p>
    
     And that’s it.
    
    
     Using
    
    <a id="_idIndexMarker327">
    </a>
    
     this arcane technique, we can compile code that we thought would be impossible, but...
    
    
     please don’t use it.
    
    
     This code is marginal insanity; it is presented just because this book is about unconventional, mythical techniques, targeting the advanced C++ programmer community, so don’t let this piece ruin your programming style, or scare you away from the keyboard.
    
    
     We wouldn’t want to lose our readers halfway through the book.
    
    
     Instead of focusing on this, in the upcoming chapter, let’s occupy our minds with
    
    
     
      sheer nothingness.
     
    
   </p>
   <h1 id="_idParaDest-101">
    <a id="_idTextAnchor100">
    </a>
    
     The definition of zero
    
   </h1>
   <p>
    
     Zero is
    
    <a id="_idIndexMarker328">
    </a>
    
     unique among numbers.
    
    
     The concept was present in ancient Egypt, and traces of it were found in ancient Babylon as a placeholder in their number system, but it wasn’t treated as a true number at
    
    
     
      that point.
     
    
   </p>
   <p>
    
     The ancient Greeks have had some resentment towards it because, regardless that they knew its importance, initially, due to some philosophical constraints, they didn’t use it as a proper number, because not, to be or not to be, but how can nothing be, that was the question in the ancient Agora.
    
   </p>
   <p>
    
     The breakthrough came in India around the 5th century CE when mathematician Brahmagupta defined zero as a number and established rules for its arithmetic use.
    
    
     This concept spread to the Islamic world, notably through the works of Al-Khwarizmi, and then to Europe, where Fibonacci played a key role in its adoption in the 12th century.
    
    
     Thank
    
    
     
      you, Wikipedia.
     
    
   </p>
   <p>
    
     Zero has several important properties: it is the additive identity, meaning adding zero to any number leaves the number unchanged.
    
    
     Multiplying any number by zero results in zero, and division by zero is undefined.
    
    
     Zero is an even number and serves as a neutral element on the number line, being neither positive nor negative.
    
    
     In exponents, raising zero to any positive power gives zero, while any non-zero number raised to the power of zero
    
    
     
      equals one.
     
    
   </p>
   <p>
    
     These properties make zero fundamental in mathematics, and with this, we can all agree that zero is one of the most important (if not the most important) numbers that ever existed; its place is up right next to π, or
    
    <em class="italic">
     
      e
     
    </em>
    
     , or
    
    <em class="italic">
     
      i
     
    </em>
    
     , which we all know is the square root of all evil,
    
    
     
      or –1.
     
    
   </p>
   <p>
    
     Now we have presented concrete proof that there is no other number like zero, we also give the following statement: C++ is a unique language.
    
    
     In its latest iteration, as of 2024, at the current time, in C++, there are six different ways to initialize a value to zero, honoring the fact that zero is the most important number.
    
    
     Ever.
    
    
     Just see
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
int z;
int main()
{
    int z1 = 0;
    int z2(0);
    int z3{0};
    int z4 = {0};
    int z5{};
    int z6();
}</pre>
   <p>
    
     Let’s break it down, line
    
    <a id="_idIndexMarker329">
    </a>
    
     by line, as there are not that
    
    
     
      many lines:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       int z;
      
     </strong>
     
      – Here, a global variable,
     
     <strong class="source-inline">
      
       z
      
     </strong>
     
      , of the
     
     <strong class="source-inline">
      
       int
      
     </strong>
     
      type is declared.
     
     
      Since it’s a global variable, it is automatically initialized to
     
     <strong class="source-inline">
      
       0
      
     </strong>
     
      by the compiler (if a global
     
     <strong class="source-inline">
      
       int
      
     </strong>
     
      variable isn’t explicitly initialized, it defaults to zero).
     
     
      This is something we
     
     
      
       can trust.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       int z1 = 0;
      
     </strong>
     
      – Copy initialization.
     
     
      The
     
     <strong class="source-inline">
      
       z1
      
     </strong>
     
      variable is declared as an
     
     <strong class="source-inline">
      
       int
      
     </strong>
     
      type and initialized to
     
     <strong class="source-inline">
      
       0
      
     </strong>
     
      using copy initialization.
     
     
      This involves assigning the value of
     
     <strong class="source-inline">
      
       0
      
     </strong>
     
      to
     
     <strong class="source-inline">
      
       z1
      
     </strong>
     
      after it
     
     
      
       is created.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       int z2(0);
      
     </strong>
     
      – Direct initialization.
     
     
      The
     
     <strong class="source-inline">
      
       z2
      
     </strong>
     
      variable is declared and initialized to
     
     <strong class="source-inline">
      
       0
      
     </strong>
     
      using direct initialization, which involves passing the value of
     
     <strong class="source-inline">
      
       0
      
     </strong>
     
      directly to the constructor of the
     
     <strong class="source-inline">
      
       int
      
     </strong>
     
      type.
     
     
      Not that it has any, but you get
     
     
      
       the idea.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       int z3{0};
      
     </strong>
     
      – Brace initialization (uniform initialization).
     
     
      The
     
     <strong class="source-inline">
      
       z3
      
     </strong>
     
      variable is declared and initialized to
     
     <strong class="source-inline">
      
       0
      
     </strong>
     
      using brace initialization.
     
     
      It helps prevent issues such as narrowing conversions and provides a consistent syntax for initializing different types.
     
     
      This is a peculiar initialization, and we will get back to this syntax a bit later in the
     
     
      
       next chapter.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       int z4 = {0};
      
     </strong>
     
      – Copy list initialization.
     
     
      The
     
     <strong class="source-inline">
      
       z4
      
     </strong>
     
      variable is declared and initialized to
     
     <strong class="source-inline">
      
       0
      
     </strong>
     
      using copy list initialization, a combination of copy initialization and brace initialization.
     
     
      It’s similar to
     
     <strong class="source-inline">
      
       z3
      
     </strong>
     
      but explicitly uses the assignment syntax, and when we talk about simple things such as numbers, there is really
     
     
      
       no difference.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       int z5{};
      
     </strong>
     
      – Value initialization.
     
     
      The
     
     <strong class="source-inline">
      
       z5
      
     </strong>
     
      variable is initialized using empty braces,
     
     <strong class="source-inline">
      
       {}
      
     </strong>
     
      , known as value initialization.
     
     
      For fundamental types such as
     
     <strong class="source-inline">
      
       int
      
     </strong>
     
      , this results in
     
     <strong class="source-inline">
      
       z5
      
     </strong>
     
      being initialized to
     
     <strong class="source-inline">
      
       0
      
     </strong>
     
      .
     
     
      This method is often used to ensure that a variable is zero-initialized without explicitly assigning
     
     
      
       a value.
      
     
    </li>
   </ul>
   <p>
    
     Isn’t it beautiful, the
    
    <a id="_idIndexMarker330">
    </a>
    
     amount of consideration that was put into making a variable correspond to the number zero?
    
    
     So, one might just ask: why are the local variables of C++ not initialized to zero (or their default value), just
    
    
     
      in case?
     
    
   </p>
   <p>
    
     The answer to this question is partly historical and partly pragmatic.
    
    
     Since C++ is based on C, and C was designed to be as close to the metal (silicone) as possible, the compiler did not waste precious processor cycles to initialize a value to their default value, if at some stage later it was used to set to a different value needed by the programmer.
    
    
     Elementary, dear reader, as one of the most famous detectives
    
    
     
      would say.
     
    
   </p>
   <p>
    
     Last but not least, without me providing any more details, I really hope you have recognized the most vexing parse in
    
    
     <strong class="source-inline">
      
       int z6();
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The “most vexing parse” is a term used to describe a specific issue in C++ involving the declaration of objects that can be misinterpreted by the compiler due to ambiguities in the syntax.
    
    
     It usually arises when you declare a variable using parentheses, which can sometimes be interpreted as a function declaration rather than a variable definition, just like in our
    
    
     
      specific example.
     
    
   </p>
   <h1 id="_idParaDest-102">
    <a id="_idTextAnchor101">
    </a>
    
     A parenthesis concerning parentheses
    
   </h1>
   <p>
    
     Now that we are here, we have to mention that there were quite a lot of mentions of parenthesis in this chapter.
    
    
     So, we are presenting possibly the most important pair of parentheses
    
    <a id="_idIndexMarker331">
    </a>
    
     you can encounter during the course of
    
    
     
      this book.
     
    
   </p>
   <p>
    
     Please look at the following
    
    
     
      two functions:
     
    
   </p>
   <pre class="source-code">
static int y;
decltype(auto) number(int x) {
    return y;
}
decltype(auto) reference(int x) {
    return (y);
}</pre>
   <p>
    
     Those two
    
    <a id="_idIndexMarker332">
    </a>
    
     functions look almost identical, except for the tiny pair of parentheses around the
    
    <strong class="source-inline">
     
      return
     
    </strong>
    
     value.
    
    
     But the presence of those two parentheses makes the biggest difference.
    
    
     The weird-looking
    
    <strong class="source-inline">
     
      decltype(auto)
     
    </strong>
    
     introduced in C++14 is a type specifier that combines the functionality of
    
    <strong class="source-inline">
     
      decltype
     
    </strong>
    
     with automatic type deduction, allowing you to declare a variable with a type that is determined by the expression it is initialized with, while also retaining certain properties of that expression.
    
    
     Unlike
    
    <strong class="source-inline">
     
      auto
     
    </strong>
    
     , which deduces types based on value categories,
    
    <strong class="source-inline">
     
      decltype(auto)
     
    </strong>
    
     retains the value category (e.g., reference or non-reference) of the expression it is
    
    
     
      based on.
     
    
   </p>
   <p>
    
     More mundanely, the function number returns an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     , while the function reference
    
    
     
      returns
     
    
    
     <strong class="source-inline">
      
       int&amp;
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In order to verify the correctness of what we previously wrote, the following code snippets can be of
    
    
     
      great help:
     
    
   </p>
   <pre class="source-code">
using namespace std;
if (is_reference&lt;decltype(number(42))&gt;::value) {
    cout &lt;&lt; "Reference to ";
    cout &lt;&lt; typeid(typename 
remove_reference&lt;decltype(number(42))&gt;::type).name() &lt;&lt; endl;
} else {
    cout &lt;&lt; "Not a reference: " &lt;&lt; typeid(decltype(number(42))).name() &lt;&lt; endl;
}</pre>
   <p>
    
     The preceding code snippet examines the return type provided by the
    
    <strong class="source-inline">
     
      number
     
    </strong>
    
     function.
    
    
     As the name hastily suggests, it will return, well...
    
    
     a number.
    
    
     When compiled with MSVC and executed, the following is the output of
    
    
     
      the code:
     
    
   </p>
   <pre class="source-code">
Not a reference: int</pre>
   <p>
    
     The
    
    <a id="_idIndexMarker333">
    </a>
    
     other compilers also have the same behavior, except they do not print out the full type of the variable, because
    
    <strong class="source-inline">
     
      gcc
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     for the
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     type just return a single
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     and that wouldn’t have been
    
    
     
      so spectacular.
     
    
   </p>
   <p>
    
     Now, let’s examine the following sequence
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
if (is_reference&lt;decltype(reference(42))&gt;::value) {
    cout &lt;&lt; "Reference to: ";
    cout &lt;&lt; typeid(typename 
remove_reference&lt;decltype(reference(42))&gt;::type).name() &lt;&lt; endl;
} else {
    cout &lt;&lt; "Not a reference: " &lt;&lt; typeid(decltype(number(42))).name() &lt;&lt; endl;
}</pre>
   <p>
    
     This is almost identical to the one before this, except that it uses the
    
    <strong class="source-inline">
     
      reference
     
    </strong>
    
     method instead of
    
    <strong class="source-inline">
     
      number
     
    </strong>
    
     .
    
    
     Not surprisingly, the result of the execution is (again, appealing to MSVC)
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
Reference to: int</pre>
   <p>
    
     So, with the preceding code, we have just proved that a pair of extra parentheses combined with
    
    <strong class="source-inline">
     
      decltype(auto)
     
    </strong>
    
     can provide some spectacular outcomes.
    
    
     Be warned.
    
    
     Let’s say we omit
    
    <strong class="source-inline">
     
      decltype
     
    </strong>
    
     , such as in the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
auto reference(int x) {
    return (y);
}</pre>
   <p>
    
     The compiler then ignores the parentheses and just returns a normal number.
    
    
     The C++ standard specifies this behavior in the
    
    <strong class="source-inline">
     
      [dcl.type.decltype]
     
    </strong>
    
     section and the authors warmly
    
    <a id="_idIndexMarker334">
    </a>
    
     recommend reading through it, in order to have a full understanding of what happens behind the scenes and a valid reasoning
    
    
     
      for it.
     
    
   </p>
   <p>
    
     Now, because we are C++ programmers, always in pursuit of speed, high-quality, and clear code, you could ask why we had to duplicate the code to identify whether we have a reference or not.
    
    
     Wouldn’t it have been perfectly valid to write something like
    
    
     
      the following?
     
    
   </p>
   <pre class="source-code">
template &lt;typename T&gt;
void printType(T&amp;&amp; var) {
    if (std::is_reference&lt;T&gt;::value) {
        if (std::is_lvalue_reference&lt;T&gt;::value) {
            printf("lvalue ref ");
        } else {
            printf("rvalue ref ");
        }
        printf("%s\n", (typeid(typename
                  std::remove_reference&lt;T&gt;::type).name()));
    } else {
        printf("%s\n", typeid(var).name());
    }
}</pre>
   <p>
    
     This is almost the same as above-above (above-above is like above, but refers to one above before the actual above), except that we have added an extra check to verify the type of the reference (and also removed
    
    <strong class="source-inline">
     
      std::cout
     
    </strong>
    
     in favor of
    
    <strong class="source-inline">
     
      printf
     
    </strong>
    
     because it generates much cleaner assembly code, and also put it in the body of a function).
    
    
     Indeed, let’s say we put it into this context and call
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
printType(number(42));
printType(reference(42));</pre>
   <p>
    
     We get the correct and
    
    
     
      expected output:
     
    
   </p>
   <pre class="source-code">
int
lvalue ref int</pre>
   <p>
    
     As a side note, we
    
    <a id="_idIndexMarker335">
    </a>
    
     get the same result with other, not-that-tiny-and-squishy
    
    
     
      compilers, too.
     
    
   </p>
   <p>
    
     This function template uses a forwarding reference (
    
    <strong class="source-inline">
     
      T&amp;&amp; var
     
    </strong>
    
     ) to handle both
    
    <strong class="source-inline">
     
      lvalue
     
    </strong>
    <strong class="bold">
    </strong>
    
     and
    
    <strong class="source-inline">
     
      rvalue
     
    </strong>
    
     references, making it capable of deducing and preserving the reference type of the passed variable.
    
    
     By using the type traits library, we check whether
    
    <strong class="source-inline">
     
      T
     
    </strong>
    
     is a reference type using
    
    <strong class="source-inline">
     
      is_reference&lt;T&gt;::value
     
    </strong>
    
     , and further distinguish between
    
    <strong class="source-inline">
     
      lvalue
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      rvalue
     
    </strong>
    
     references
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       is_lvalue_reference&lt;T&gt;::value
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     If it’s a reference, we print whether it’s an
    
    <strong class="source-inline">
     
      lvalue
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      rvalue
     
    </strong>
    
     reference along with the type of the variable without the reference
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       remove_reference&lt;T&gt;::type
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     If it’s not a reference, we directly print the type of the variable.
    
    
     This approach works because of the perfect forwarding mechanics in C++, allowing
    
    <strong class="source-inline">
     
      T
     
    </strong>
    
     to be deduced as the exact type of the passed variable, preserving its
    
    
     
      reference nature.
     
    
   </p>
   <p>
    
     Please note that it was mandatory to use the forwarding reference,
    
    <strong class="source-inline">
     
      T&amp;&amp; var
     
    </strong>
    
     ; if we had used just
    
    <strong class="source-inline">
     
      T var
     
    </strong>
    
     , it would not work the same way for reference types.
    
    
     This is because, in this form,
    
    <strong class="source-inline">
     
      T
     
    </strong>
    
     would have been deduced as a non-reference type, so
    
    <strong class="source-inline">
     
      var
     
    </strong>
    
     inside the function would have been always a copy of the original argument, not
    
    
     
      a reference.
     
    
   </p>
   <p>
    
     As an extra goodie for you, dear reader, here are some extracts of the assembly output of one of the compilers (GCC, in our case).
    
    
     You can see how it generates two distinct functions, and most importantly, what goes inside
    
    
     
      those functions:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-3">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <pre class="source-code">
<code>void printType &lt;int&gt;(int&amp;&amp;):</code></pre>
      </td>
      <td class="No-Table-Style">
       <pre class="source-code">
<code>void printType &lt;int&amp;&gt;(int&amp;):</code></pre>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <pre class="source-code">
<code>push rbp</code></pre>
       <pre class="source-code">
<code>mov rbp, rsp</code></pre>
       <pre class="source-code">
<code>sub rsp, 16</code></pre>
       <pre class="source-code">
<code>mov QWORD PTR [rbp-8], rdi</code></pre>
       <pre class="source-code">
<code>mov edi, OFFSET</code></pre>
       <pre class="source-code">
<code>         FLAT:typeinfo</code></pre>
       <pre class="source-code">
<code>call std::type_info::name()</code></pre>
       <pre class="source-code">
<code>mov rdi, rax</code></pre>
       <pre class="source-code">
<code>call puts</code></pre>
       <pre class="source-code">
<code>nop</code></pre>
       <pre class="source-code">
<code>leave</code></pre>
       <pre class="source-code">
<code>ret</code></pre>
      </td>
      <td class="No-Table-Style">
       <pre class="source-code">
<code>push rbp</code></pre>
       <pre class="source-code">
<code>mov rbp, rsp</code></pre>
       <pre class="source-code">
<code>sub rsp, 16</code></pre>
       <pre class="source-code">
<code>mov QWORD PTR [rbp-8], rdi</code></pre>
       <pre class="source-code">
<code>mov edi, OFFSET FLAT:.LC0</code></pre>
       <pre class="source-code">
<code>mov eax, 0</code></pre>
       <pre class="source-code">
<code>call printf</code></pre>
       <pre class="source-code">
<code>mov edi, OFFSET</code></pre>
       <pre class="source-code">
<code>         FLAT:typeinfo</code></pre>
       <pre class="source-code">
<code>call std::type_info::name() mov rdi, rax</code></pre>
       <pre class="source-code">
<code>call puts</code></pre>
       <pre class="source-code">
<code>nop</code></pre>
       <pre class="source-code">
<code>leave</code></pre>
       <pre class="source-code">
<code>ret</code></pre>
       <pre class="source-code">
<code>.LC0:</code></pre>
       <pre class="source-code">
<code> .string "lvalue ref "</code></pre>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 9.1: Comparing the assembly listings of various printType instantiations
    
   </p>
   <p>
    
     We can see
    
    <a id="_idIndexMarker336">
    </a>
    
     two instantiations of the
    
    <strong class="source-inline">
     
      printType
     
    </strong>
    
     function for each of the types returned by the two functions, and how in each of them the various calls to the type traits were successfully implemented at the source code level, thus leading to the removal of unnecessary branches.
    
    
     We can also observe the removal of the unnecessary strings (nowhere is
    
    <strong class="source-inline">
     
      "rvalue ref"
     
    </strong>
    
     found in the generated code because the compiler identified that the branch containing it is nowhere to be found in the
    
    
     
      final code).
     
    
   </p>
   <p>
    
     Isn’t
    
    
     
      C++ beautiful?
     
    
   </p>
   <h1 id="_idParaDest-103">
    <a id="_idTextAnchor102">
    </a>
    
     C++uties
    
   </h1>
   <p>
    
     It is time that
    
    <a id="_idIndexMarker337">
    </a>
    
     the author of these lines has to admit something.
    
    
     He’s tired of ugly code trying to win the C++ beauty contest.
    
    
     Regardless of how hard we try to convince ourselves that the code we presented a few sections before is beautiful and is worth remembering, well, it is not.
    
    
     It is ugly and horrible, and please forget, dear reader, that you ever had to read something like
    
    
     
      that.
     
     
      Apologies.
     
    
   </p>
   <p>
    
     From this point on, we solemnly promise that we are up to no more mischief and will treat you only with beautiful code.
    
    
     No more ugly macros, no more shady substitutions, no more arcane techniques.
    
    
     Just pure, joyful,
    
    
     
      lovable C++.
     
    
   </p>
   <p>
    
     As a result of this reinvention of ourselves (as the writer of beautiful C++ code), we present you the next program, which possibly is the cutest one you can get your
    
    
     
      hands on:
     
    
   </p>
   <div><div><img alt="img" role="presentation" src="img/B22235_09_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Figure">
    
    
   </p>
   <p>
    
     Please bear with us, for the sake of brevity, we have omitted the includes for
    
    <strong class="source-inline">
     
      std::string
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      std::cout
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      std::unique_ptr
     
    </strong>
    
     .
    
    
     Who said C++ can’t
    
    
     
      be cute?
     
    
   </p>
   <p>
    
     But sadly, the preceding code is not widely recognized as being standard C++ (seemingly, there is no clear consensus among compiler developers on which Unicode identifiers to consider valid in the source code, regardless of
    
    <strong class="source-inline">
     
      [tab:lex.name.allowed]
     
    </strong>
    
     in the latest C++ standard), but not all hope is lost, as GCC accepts it.
    
    
     Maybe there was a bear hugger in the ranks of
    
    
     
      their developers.
     
    
   </p>
   <p>
    
     As a side note, the
    
    <a id="_idIndexMarker338">
    </a>
    
     code presented does not do too much, just feeds some bears with their proper meal, considering their nutrition needs, dietary requirements, and affiliations with various dietary patterns and current culinary trends present in Bearland.
    
    
     Didn’t we deliver a cute program, a possible contender to the winner of the most beautiful
    
    
     
      C++ code?
     
    
   </p>
   <p>
    
     There are a good number of books we encourage our dear esteemed readers to read, if they want their programs to follow common sense guidelines, be readable, stable, easily maintainable and up to the latest standards.
    
    
     Sadly none of those books detail how to write fun programs, because writing fun programs, or writing programs for fun involves a different mindset, and is rarely done for profit.
    
   </p>
   <p>
    
     Programming can be an art form, producing code that surprises and delights, having code can include Easter eggs, humorous output, applying playful user interaction, or unusual visualizations.
    
    
     Playfulness could be as simple as using emojis as identifiers (as in our bear example) or making quirky applications with oddball logic.
    
    
     Fun programming often rejects the rigidity of formal practices in favor of creative solutions that may be inefficient or overly complex just for the sake of enjoyment, such as crafting an obfuscated piece of code, just because we find it to
    
    
     
      be fun.
     
    
   </p>
   <p>
    
     Fun in programming can also come from solving intriguing puzzles or exploring unconventional programming paradigms (functional, esoteric languages such as Brainfuck or LOLCODE), or building projects purely out
    
    
     
      of curiosity.
     
    
   </p>
   <p>
    
     While formal books on “beautiful” or “clean” code emphasize correctness, safety, and readability, fun programming opens the door to spontaneity, art, and entertainment, so no wonder that our last happening for this chapter is taking part in the last one.
    
    
     It is short, it is cute, and it looks like something out of a fairy tale.
    
    
     With bears.
    
    
     Because who doesn’t
    
    
     
      like bears?
     
    
   </p>
   <h1 id="_idParaDest-104">
    <a id="_idTextAnchor103">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     Not all that is shining is gold, and not every piece of code that seems exciting and bears complex features is necessarily of high quality.
    
    
     The allure of shiny, intricate code can sometimes overshadow the fundamental qualities that define good programming practices.
    
    
     Good, stable code is frequently characterized by its straightforwardness and predictability rather than its flair.
    
    
     This type of code may seem unremarkable or mundane compared to more fun constructs, but it is precisely this simplicity that ensures robustness and ease of understanding.
    
    
     When you have to, please try to write boring, simple code, as it will be much easier to read in half a year from now, but every time you can afford to, please squeeze in a bear or two in your fun side project.
    
    
     Unless you plan to read
    
    
     
      it, too.
     
    
   </p>
   <p>
    
     In our next chapter, Alex will go on a crusade to advocate the proper use of modern C++ libraries, in order to debunk the myth that C++ libraries are also stuck in the
    
    
     
      Stone Age.
     
    
   </p>
  </div>
 </body></html>