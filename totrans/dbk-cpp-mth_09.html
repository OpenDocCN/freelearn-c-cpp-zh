<html><head></head><body>
  <div id="_idContainer035">
   <h1 class="chapter-number" id="_idParaDest-97">
    <a id="_idTextAnchor096">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     9
    </span>
   </h1>
   <h1 id="_idParaDest-98">
    <a id="_idTextAnchor097">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     C++ Is Beautiful
    </span>
   </h1>
   <p class="italic-heading">
    <em class="italic">
     <span class="koboSpan" id="kobo.3.1">
      According to the mirror on
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.4.1">
       the wall
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     Dear reader.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     In this chapter, we won’t be focusing on teaching you specific concepts, techniques, or practical skills.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     Instead, our goal is to guide you through a different kind of experience, one that allows you to step back from the details and immerse yourself in the aesthetic aspects
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      of coding.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     This chapter is designed to inspire you to see code in a new light, to recognize the patterns, symmetry, and even the poetry that can emerge when we write code with thoughtfulness
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      and care.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     Beauty is a unique and personal experience because it arises from the intricate interplay of individual perception, emotional resonance, cultural influences, and personal identity.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     Each person interprets beauty through their own sensory and cognitive filters, shaped by their life experiences, memories, and cultural background.
    </span>
    <span class="koboSpan" id="kobo.9.3">
     Emotional connections, mood, and personal taste further influence what one finds beautiful, making it a deeply subjective experience that reflects one’s unique perspective on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      the world.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     Some may find beauty in the fiery hues of a sunset over a Mediterranean island, while others might appreciate the crisp, cold allure of Scandinavian fjords.
    </span>
    <span class="koboSpan" id="kobo.11.2">
     It is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      all personal.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.13.1">
     So, while there may not be concrete lessons or objectives in this chapter, it offers a unique opportunity to connect with the craft of coding on a more emotional and intellectual level.
    </span>
    <span class="koboSpan" id="kobo.13.2">
     Through this journey, we hope you’ll come to see code not just as a means to an end but as something inherently beautiful in its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      own right.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.15.1">
     In this chapter, you will experience that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.16.1">
      there is:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      Nothing new to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       learn here...
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      ...
     </span>
     <span class="koboSpan" id="kobo.19.2">
      except the appreciation
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       of beauty...
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.21.1">
      ...
     </span>
     <span class="koboSpan" id="kobo.21.2">
      while crafting code with techniques in mind that may disqualify you from ever sitting in front of a keyboard while writing professional code in an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       enterprise environment
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-99">
    <a id="_idTextAnchor098">
    </a>
    <span class="koboSpan" id="kobo.23.1">
     In search of beauty
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.24.1">
     Each programming language is a unique work of art, beautifully distinct in its design, philosophy, and the possibilities it offers; just as diverse are the programmers who use them, each bringing their own preferences, creativity, and personality to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      the craft.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     Some developers are drawn to the elegant simplicity and structure of Python, relishing the clarity and expressiveness that its neatly organized whitespace brings to their code.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     Others, however, find their joy in languages such as Forth, where they can freely push and pop the stack with precision having full control and conciseness of such low-level manipulation, while seemingly enjoying the challenge of constructing powerful systems with minimalistic syntax.
    </span>
    <span class="koboSpan" id="kobo.26.3">
     Now really, is there anyone using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      Forth anymore?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     And then there are the bold adventurers who embrace the enigmatic world of Lisp, using its infamous long list of insipid and stubborn parenthesis.
    </span>
    <span class="koboSpan" id="kobo.28.2">
     To these programmers, the apparent monotony of the syntax is a gateway to a rich and expressive metaprogramming landscape, where they can manipulate code as data in ways that feel almost alchemical, not to mention that they have direct access
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      to Emacs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.30.1">
     Last but not least, there are those of us, the tribe of C++ programmers, who think the magical beauty of a program can fully be expressed by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.31.1">
      following line:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.32.1">
auto main()-&gt;int{return&lt;:]&lt;class _&gt;(_)-&gt;_&lt;%return 7;}(1);%&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.33.1">
     What
    </span>
    <a id="_idIndexMarker314">
    </a>
    <span class="koboSpan" id="kobo.34.1">
     more C++ beauty do we need on this planet?
    </span>
    <span class="koboSpan" id="kobo.34.2">
     A line of code that looks like a series of winking smileys, and in the end, it returns the lucky number seven to the caller.
    </span>
    <span class="koboSpan" id="kobo.34.3">
     There is not a huge amount of technicality lying in the preceding code, just a plain lambda returning a number, and to confuse you, dear reader, we have used the trailing returning type for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.35.1">
      main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.36.1">
     , because
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      why not?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.38.1">
     Also, to add an even higher level of obscurity to our snippet, we have used, just for the sheer beauty of them, the infamous C++ digraphs.
    </span>
    <span class="koboSpan" id="kobo.38.2">
     Unfortunately for them, the notorious trigraphs were deprecated in C++17 so we could not use them to spice up our code snippet.
    </span>
    <span class="koboSpan" id="kobo.38.3">
     Actually, we could have used them, but we just
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      wouldn’t dare.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     All that mayhem and confusion done in one line only.
    </span>
    <span class="koboSpan" id="kobo.40.2">
     The real question that comes is can we make this even more
    </span>
    <span class="strikethrough">
     <span class="koboSpan" id="kobo.41.1">
      cumbersome
     </span>
    </span>
    <span class="koboSpan" id="kobo.42.1">
     beautiful for you, dear reader, to read?
    </span>
    <span class="koboSpan" id="kobo.42.2">
     And certainly, the answer to this certain question is a certain yes.
    </span>
    <span class="koboSpan" id="kobo.42.3">
     And can we build it?
    </span>
    <span class="koboSpan" id="kobo.42.4">
     Yes, we can!
    </span>
    <span class="koboSpan" id="kobo.42.5">
     Almost...
    </span>
    <span class="koboSpan" id="kobo.42.6">
     But firstly, we just have to get rid of the numbers,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.43.1">
      because hey...
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-100">
    <a id="_idTextAnchor099">
    </a>
    <span class="koboSpan" id="kobo.44.1">
     Who likes numbers?
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     ...
    </span>
    <span class="koboSpan" id="kobo.45.2">
     or more specifically, who needs numbers?
    </span>
    <span class="koboSpan" id="kobo.45.3">
     Numbers can be highly confusing to people due to their
    </span>
    <a id="_idIndexMarker315">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     abstract nature, and the fact that we don’t really need them in our everyday
    </span>
    <a id="_idIndexMarker316">
    </a>
    <span class="koboSpan" id="kobo.47.1">
     mundane life, which does not require higher-level thinking and the ability to grasp symbolic representations, makes them
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.48.1">
      almost meaningless.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.49.1">
     Maybe this is why some tribes in the Amazon jungle didn’t even invent all of them (yes, I’m pointing at you, Munduruku tribe
    </span>
    <span class="superscript">
     <span id="footnote-025-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_09.xhtml#footnote-025">
       <span class="koboSpan" id="kobo.50.1">
        1
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.51.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.51.2">
     You have notions for none, one, two, up to five ...
    </span>
    <span class="koboSpan" id="kobo.51.3">
     and then many.
    </span>
    <span class="koboSpan" id="kobo.51.4">
     If it is enough for you, I can live
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      with it.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-025">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_09.xhtml#footnote-025-backlink">
      <span class="koboSpan" id="kobo.53.1">
       1
      </span>
     </a>
     <span class="koboSpan" id="kobo.54.1">
      https://www.amazon.com/Alexs-Adventures-Numberland-Alex-Bellos/dp/1408809591
     </span>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.55.1">
     Let’s apply the ancient wisdom of the Amerindian people to our programming quest: to come up with the most beautiful C++ code snippet the world can see today.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     So, let’s get rid of those pesky numbers, keeping just 0 and 1 (for the sake of the almighty bits so that they don’t feel excluded), and let’s go tribal with the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      code snippet:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.57.1">
#define __(...)sizeof(int[]){0,\
                               ##__VA_ARGS__}/sizeof(int)-1
auto main()-&gt;int{return&lt;:]&lt;class _&gt;(_)-&gt;_&lt;%return
__(_(), _(), _(), _(), _(), _(), _()) ;}(__());%&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     Oh, the sheer beauty of it.
    </span>
    <span class="koboSpan" id="kobo.58.2">
     It brings tears of joy to our eyes, doesn’t it?
    </span>
    <span class="koboSpan" id="kobo.58.3">
     Arguably, some picky programmers might have made some vitriolic comments about readability, maintainability, standard compliance, and so on...
    </span>
    <span class="koboSpan" id="kobo.58.4">
     especially if they are using Microsoft’s (tiny, squishy) C++ compiler, which flatly refuses to compile the preceding code.
    </span>
    <span class="koboSpan" id="kobo.58.5">
     But we rejoice with trembling that we made one of the compilers break, while all the other major players happily digest it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.59.1">
      and compile.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.60.1">
     But the code unfortunately contains a lot of duplicates, which we don’t really like.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     Nor do we need duplicates, so we should also get rid of at least one of them, shouldn’t we?
    </span>
    <span class="koboSpan" id="kobo.60.3">
     Or all of them,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      why not?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.62.1">
     Because that is the real beauty of the C++ language.
    </span>
    <span class="koboSpan" id="kobo.62.2">
     The capability to always redefine yourself, to provide a better version of the code at all costs, not considering the sacrifice made.
    </span>
    <span class="koboSpan" id="kobo.62.3">
     Death
    </span>
    <a id="_idIndexMarker317">
    </a>
    <span class="koboSpan" id="kobo.63.1">
     to readability.
    </span>
    <span class="koboSpan" id="kobo.63.2">
     Death to maintainability!
    </span>
    <span class="koboSpan" id="kobo.63.3">
     Long live the free code of chaos, mayhem,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.64.1">
      and confusion!
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     So, brave warriors, our quest has been laid, prepare arms (I mean keyboards), and let’s save those bytes, just like the following code snippet
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.66.1">
      shows us:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.67.1">
#define $$ sizeof
#define $ return
#define $_ int
#define __(...)$$($_[]){0,##__VA_ARGS__}/$$($_)-1
auto main()-&gt;$_&lt;%$&lt;::&gt;&lt;class _&gt;(_)-&gt;_&lt;%$
__(_(), _(), _(), _(), _(), _(), _()) ;%&gt;(__());%&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.68.1">
     Just look again at the sheer beauty of it.
    </span>
    <span class="koboSpan" id="kobo.68.2">
     Again, the power of C++ shines through the dark clouds, like a thousand supernovae, and makes possible everything our heart desires, such as replacing a key element of the language, for example, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.69.1">
      return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.70.1">
     keyword with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.71.1">
      $
     </span>
    </strong>
    <span class="koboSpan" id="kobo.72.1">
     sign.
    </span>
    <span class="koboSpan" id="kobo.72.2">
     Not that it is part of the standard character set the language specified as the valid character set, but we will have a discussion about this, and some bears, a little
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      bit later.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     But look at the bright side of the glass.
    </span>
    <span class="koboSpan" id="kobo.74.2">
     At least we did not write the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.75.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.76.1">
#define return(...) main
#define main(...) int
main(7)(return(7))(){
    return 7;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.77.1">
     We have to admit, we contemplated writing it and adding it to the book, but after a glimpse at the future, we just thought that everything has its limits.
    </span>
    <span class="koboSpan" id="kobo.77.2">
     Even the resilience of the most seasoned developers when it comes to nonsense (but regardless,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.78.1">
      fun) code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     This is highly possibly the most evil piece of code we will present in this book because the level of evilness is comparable to the level of pain felt when you try to write a properly parenthesized Lisp program.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     Because what happens if you remove a parenthesis because there are too many, or, God forbid, add another one because you think it’d be a great idea?
    </span>
    <span class="koboSpan" id="kobo.79.3">
     Believe me, dear reader, just
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.80.1">
      don’t dare.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.81.1">
     So, please pretend that the preceding code is not in the book, and even if it is, you haven’t seen it.
    </span>
    <span class="koboSpan" id="kobo.81.2">
     And even if you have seen it, you wouldn’t dare change the number of parenthesis
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      in it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.83.1">
     Enough of
    </span>
    <a id="_idIndexMarker318">
    </a>
    <span class="koboSpan" id="kobo.84.1">
     the piece of evilness; now it is time to return to our previous code, which is in the competition for the most beautiful piece of C++ code this book
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.85.1">
      can present.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.86.1">
     If only we could make it just a bit shorter, more concise, and more expressive, such as removing those ugly
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.87.1">
      define
     </span>
    </strong>
    <span class="koboSpan" id="kobo.88.1">
     and replacing them with something that expresses more beauty, more ...
    </span>
    <span class="koboSpan" id="kobo.88.2">
     like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.89.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.90.1">
#ifndef MINK
#define MINK
#include __FILE__
DD $$ sizeof
DD $ return
DD $_ int
DD _$ _()
DD __(_...)$$($_[]){0,##_}/$$($_)-1
auto main()-&gt;$_&lt;%$&lt;::&gt;&lt;class _&gt;(_)-&gt;
$_&lt;%$ __(_$,_(),_$,_(),_$,_(),_$) ;%&gt;(__());%&gt;
#endif
#ifdef MINK
#define CAT(x, y) CAT_I(x, y)
#define CAT_I(x, y) x ## y
#define HH CAT(%, :)
#define DD HH define
#endif</span></pre>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     Oh, it really hurts my eyes.
    </span>
    <span class="koboSpan" id="kobo.91.2">
     Sorry about it, and apologies beforehand, but we cannot make this any more beautiful without incurring a very serious headache for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.92.1">
      the authors.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.93.1">
     While reading
    </span>
    <a id="_idIndexMarker319">
    </a>
    <span class="koboSpan" id="kobo.94.1">
     this, we suddenly realize that just because there is already an obfuscated C code competition, we don’t really need to overdo its C++ counterpart.
    </span>
    <span class="koboSpan" id="kobo.94.2">
     C++ by definition can be obfuscated enough without us actively trying to obfuscate it, but now, after presenting the preceding chimera, we actively owe an apology and an explanation to you, dear reader (on the other end, chimeras can be beautiful too; you just need to have the right eye
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.95.1">
      for it).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.96.1">
     The first substantial observation we are concluding is that this code cannot be compiled by itself.
    </span>
    <span class="koboSpan" id="kobo.96.2">
     If we try it, GCC will give errors,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.97.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.98.1">
error: stray '%:' in program
   15 | #define HH CAT(%, :)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     ICC will complain,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.101.1">
error: "#" not expected here
  DD $$ sizeof</span></pre>
   <p>
    <span class="koboSpan" id="kobo.102.1">
     MSVC does not like that, as you
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      can see:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.104.1">
error C2121: '#': invalid character: possibly the result of a macro expansion</span></pre>
   <p>
    <span class="koboSpan" id="kobo.105.1">
     Clang isn’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.106.1">
      successful either:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.107.1">
error: expected unqualified-id
    4 | DD $$ sizeof
      | ^</span></pre>
   <p>
    <span class="koboSpan" id="kobo.108.1">
     So, basically, the compilers have commonly agreed that they cannot agree on a common error message or a reason for failure, but at least none of them can compile that piece of code.
    </span>
    <span class="koboSpan" id="kobo.108.2">
     There are a few very on-the-point error messages, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.109.1">
      #
     </span>
    </strong>
    <span class="koboSpan" id="kobo.110.1">
     is possibly the result of a macro expansion (but the author of these lines would like to see a macro that expands to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.111.1">
      #
     </span>
    </strong>
    <span class="koboSpan" id="kobo.112.1">
     because
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.113.1">
      #define D #
     </span>
    </strong>
    <span class="koboSpan" id="kobo.114.1">
     is just not working regardless of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.115.1">
      D
     </span>
    </strong>
    <span class="koboSpan" id="kobo.116.1">
     ) or another message concerning that stray
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.117.1">
      %:
     </span>
    </strong>
    <span class="koboSpan" id="kobo.118.1">
     in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.119.1">
      the program.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.120.1">
     All this
    </span>
    <a id="_idIndexMarker320">
    </a>
    <span class="koboSpan" id="kobo.121.1">
     macro expansion and so on just leads us in the direction of macros.
    </span>
    <span class="koboSpan" id="kobo.121.2">
     If you, dear reader, are not familiar with C or C++ macros, please go grab a book on them, such as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.122.1">
      The C++ Programming Language
     </span>
    </em>
    <span class="koboSpan" id="kobo.123.1">
     , by Bjarne Stroustrop, because this book (the one you are reading right now) deals only with macros of mythical fame, while that one (i.e.,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.124.1">
      the
     </span>
    </em>
    <span class="koboSpan" id="kobo.125.1">
     C++ book written by the father and creator of the language) teaches you to not to use them unless you really, really have to.
    </span>
    <span class="koboSpan" id="kobo.125.2">
     And even
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.126.1">
      then, sparsely.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.127.1">
     But back to our code.
    </span>
    <span class="koboSpan" id="kobo.127.2">
     All decent compilers have the means to provide the result of the preprocessed C++ file, so let’s examine it for our program.
    </span>
    <span class="koboSpan" id="kobo.127.3">
     By invoking
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.128.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.129.1">
     with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.130.1">
      –E
     </span>
    </strong>
    <span class="koboSpan" id="kobo.131.1">
     flag (or Clang with the same flag, or MSVC with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.132.1">
      /P
     </span>
    </strong>
    <span class="koboSpan" id="kobo.133.1">
     flag if you use the command line for it; otherwise, they will be accessible from the build directory of the project you are working on in Visual Studio), we get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      following listing:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.135.1">
%: define $$ sizeof
%: define $ return
%: define $_ int
%: define _$ _()
%: define __(_...)$$($_[]){0,##_}/$$($_)-1
auto main()-&gt;$_&lt;%$&lt;::&gt;&lt;class _&gt;(_)-&gt;
$_&lt;%$ __(_$,_(),_$,_(),_$,_(),_$) ;%&gt;(__());%&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     We just show what is necessary for now and skip the compiler-specific line info, which is also added to the preprocessed output.
    </span>
    <span class="koboSpan" id="kobo.136.2">
     So, as we can see, the preprocessed output looks like a very valid C++ file (albeit not very readable)...
    </span>
    <span class="koboSpan" id="kobo.136.3">
     to our surprise, however, we can see several
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.137.1">
      define
     </span>
    </strong>
    <span class="koboSpan" id="kobo.138.1">
     directives actively present in the file.
    </span>
    <span class="koboSpan" id="kobo.138.2">
     They are prepended by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.139.1">
      %:
     </span>
    </strong>
    <span class="koboSpan" id="kobo.140.1">
     symbol, which, after digraph substitution, will be transformed into the hashtag symbol (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.141.1">
      #
     </span>
    </strong>
    <span class="koboSpan" id="kobo.142.1">
     ) and yield a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.143.1">
      valid program.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.144.1">
     In order to further understand what is happening here, we must understand how the compiler deals
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      with macros.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.146.1">
     The C compiler (and of course C++ too)
    </span>
    <a id="_idIndexMarker321">
    </a>
    <span class="koboSpan" id="kobo.147.1">
     expands macros through a methodical process managed by the preprocessor, beginning with tokenizing the source code and identifying macros for substitution.
    </span>
    <span class="koboSpan" id="kobo.147.2">
     For object-like macros, a straightforward text replacement occurs, whereas function-like macros involve substituting the arguments provided in the macro invocation.
    </span>
    <span class="koboSpan" id="kobo.147.3">
     Function-like macros (the ones that have a pair of parentheses) undergo an argument prescan, where macro arguments are fully expanded before being substituted into the macro body.
    </span>
    <span class="koboSpan" id="kobo.147.4">
     This prescan ensures that nested macro calls within arguments are expanded correctly and that the final macro body is rescanned to catch any further macros
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.148.1">
      for expansion.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.149.1">
     However, the prescan does not apply when arguments are stringized or concatenated, nor does it affect macros that are already marked as ineligible for re-expansion.
    </span>
    <span class="koboSpan" id="kobo.149.2">
     This behavior mandates that in order to have proper expansion, we force the compiler to do a second pass on the concatenation macros, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.150.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.151.1">
#define CAT(x, y) CAT_I(x, y)
#define CAT_I(x, y) x ## y</span></pre>
   <p>
    <span class="koboSpan" id="kobo.152.1">
     The preceding snippet ensures that all the required arguments are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.153.1">
      properly expanded.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.154.1">
     Special macros such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.155.1">
      __LINE__
     </span>
    </strong>
    <span class="koboSpan" id="kobo.156.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.157.1">
      __TIME__
     </span>
    </strong>
    <span class="koboSpan" id="kobo.158.1">
     are treated uniquely to prevent further unintended expansions.
    </span>
    <span class="koboSpan" id="kobo.158.2">
     After all expansions are complete, the preprocessor ensures that no eligible macros are left unexpanded before passing the final code to the compiler.
    </span>
    <span class="koboSpan" id="kobo.158.3">
     This comprehensive process ensures that macros are expanded efficiently and correctly, even in complex scenarios involving nested macros and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.159.1">
      stringification operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.160.1">
     Now that we have tried to explain how the macro substitution works on a level that is not that obvious for the first time, it is time to get back and finally compile our program.
    </span>
    <span class="koboSpan" id="kobo.160.2">
     As you can remember, the preprocessed source still contained some statements that had
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.161.1">
      define
     </span>
    </strong>
    <span class="koboSpan" id="kobo.162.1">
     directives
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.163.1">
      in them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.164.1">
     Now, armed with this knowledge, we will reveal an arcane piece of knowledge to you, dear reader.
    </span>
    <span class="koboSpan" id="kobo.164.2">
     In the end, this is a book about the mysticism of C++.
    </span>
    <span class="koboSpan" id="kobo.164.3">
     This arcane piece of knowledge is something
    </span>
    <a id="_idIndexMarker322">
    </a>
    <span class="koboSpan" id="kobo.165.1">
     called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.166.1">
      double preprocessing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     .
    </span>
    <span class="koboSpan" id="kobo.167.2">
     Before continuing, however, a small detour on how the compiler deals with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.168.1">
      your code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.169.1">
     During the initial stages of compiling a C++ source file, the compiler first undergoes preprocessing and compilation.
    </span>
    <span class="koboSpan" id="kobo.169.2">
     In the preprocessing phase, the compiler expands macros (just like we have presented previously), processes conditional compilation directives (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.170.1">
      #ifdef
     </span>
    </strong>
    <span class="koboSpan" id="kobo.171.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.172.1">
      #ifndef
     </span>
    </strong>
    <span class="koboSpan" id="kobo.173.1">
     , etc.), includes header files, and removes comments, resulting in a complete translation unit with all external files and macros fully resolved.
    </span>
    <span class="koboSpan" id="kobo.173.2">
     Following this, in
    </span>
    <a id="_idIndexMarker323">
    </a>
    <span class="koboSpan" id="kobo.174.1">
     the compilation phase, the preprocessed code is broken down into tokens during a phase called lexical analysis, which are then checked against the language’s syntax rules to
    </span>
    <a id="_idIndexMarker324">
    </a>
    <span class="koboSpan" id="kobo.175.1">
     construct
    </span>
    <a id="_idIndexMarker325">
    </a>
    <span class="koboSpan" id="kobo.176.1">
     a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.177.1">
      parse tree
     </span>
    </strong>
    <span class="koboSpan" id="kobo.178.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.179.1">
      abstract syntax
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.180.1">
       tree
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.181.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.182.1">
       AST
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.183.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.184.1">
     This is followed by the phase called semantic analysis, where the compiler verifies the correct usage of types, variables, and functions, and potentially performs early optimizations.
    </span>
    <span class="koboSpan" id="kobo.184.2">
     Finally, the compiler translates the AST into an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.185.1">
      intermediate representation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.186.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.187.1">
      IR
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     ), setting
    </span>
    <a id="_idIndexMarker326">
    </a>
    <span class="koboSpan" id="kobo.189.1">
     the stage for further optimization and eventual machine code generation, but this is way out of the topics covered in this book.
    </span>
    <span class="koboSpan" id="kobo.189.2">
     However, we would like to direct those of you who are interested in this topic to the famous “Dragon book”, also known as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.190.1">
      Compilers: Principles, Techniques, and Tools
     </span>
    </em>
    <span class="koboSpan" id="kobo.191.1">
     , by Alfred Aho, Jeffrey Ullman, Ravi Sethi, and Monica Lam.
    </span>
    <span class="koboSpan" id="kobo.191.2">
     That is the go-to book for every programmer interested in developing a compiler, or just simply interested in learning about
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.192.1">
      the techniques.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.193.1">
     But back to our double preprocessing technique.
    </span>
    <span class="koboSpan" id="kobo.193.2">
     By using this technique, we will pass in the previous preprocessed source file into a compiler, using a technique known in Linux as piping and on Windows
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.194.1">
      as hacking.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.195.1">
     The following is the Windows command that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      accomplishes this:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.197.1">
cl /P test.cpp &amp; cl /Tp test.i</span></pre>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     The first part is producing the preprocessed file, which, in Visual C++ land, usually has the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.199.1">
      .i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.200.1">
     extension and the second part will take the preprocessed output, place it in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.201.1">
      test.i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.202.1">
     , and compile it as a C++ file (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.203.1">
      /Tp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     switch is responsible for this).
    </span>
    <span class="koboSpan" id="kobo.204.2">
     The result of this is the expected
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.205.1">
      test.exe
     </span>
    </strong>
    <span class="koboSpan" id="kobo.206.1">
     , which, after execution, performs exactly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      as desired.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.208.1">
     Under Linux, the sequence of commands is also
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.209.1">
      very similar:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.210.1">
clang++ -E test.cpp | g++ -w -x c++ -std=c++20 -</span></pre>
   <p>
    <span class="koboSpan" id="kobo.211.1">
     The first part, before the pipe, produces the preprocessed code using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.212.1">
      clang++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.213.1">
     , which, using Linux pipe magic, is sent into
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.214.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.215.1">
     , because why not ☺.
    </span>
    <span class="koboSpan" id="kobo.215.2">
     For this simple scenario, it wouldn’t have mattered if we had used the other way around, because these two compilers go hand in hand and they share the basic command-line options, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.216.1">
      –x c++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.217.1">
     to specify that the code it would compile is some sort of C++ code, or the version of the C++ standard this code complies to.
    </span>
    <span class="koboSpan" id="kobo.217.2">
     The most important argument to the second compiler call is the last
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.218.1">
      -
     </span>
    </strong>
    <span class="koboSpan" id="kobo.219.1">
     sign, which tells the compiler to read the code from the stdin, instead of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.220.1">
      a file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.221.1">
     And that’s it.
    </span>
    <span class="koboSpan" id="kobo.221.2">
     Using
    </span>
    <a id="_idIndexMarker327">
    </a>
    <span class="koboSpan" id="kobo.222.1">
     this arcane technique, we can compile code that we thought would be impossible, but...
    </span>
    <span class="koboSpan" id="kobo.222.2">
     please don’t use it.
    </span>
    <span class="koboSpan" id="kobo.222.3">
     This code is marginal insanity; it is presented just because this book is about unconventional, mythical techniques, targeting the advanced C++ programmer community, so don’t let this piece ruin your programming style, or scare you away from the keyboard.
    </span>
    <span class="koboSpan" id="kobo.222.4">
     We wouldn’t want to lose our readers halfway through the book.
    </span>
    <span class="koboSpan" id="kobo.222.5">
     Instead of focusing on this, in the upcoming chapter, let’s occupy our minds with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.223.1">
      sheer nothingness.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-101">
    <a id="_idTextAnchor100">
    </a>
    <span class="koboSpan" id="kobo.224.1">
     The definition of zero
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.225.1">
     Zero is
    </span>
    <a id="_idIndexMarker328">
    </a>
    <span class="koboSpan" id="kobo.226.1">
     unique among numbers.
    </span>
    <span class="koboSpan" id="kobo.226.2">
     The concept was present in ancient Egypt, and traces of it were found in ancient Babylon as a placeholder in their number system, but it wasn’t treated as a true number at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.227.1">
      that point.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.228.1">
     The ancient Greeks have had some resentment towards it because, regardless that they knew its importance, initially, due to some philosophical constraints, they didn’t use it as a proper number, because not, to be or not to be, but how can nothing be, that was the question in the ancient Agora.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.229.1">
     The breakthrough came in India around the 5th century CE when mathematician Brahmagupta defined zero as a number and established rules for its arithmetic use.
    </span>
    <span class="koboSpan" id="kobo.229.2">
     This concept spread to the Islamic world, notably through the works of Al-Khwarizmi, and then to Europe, where Fibonacci played a key role in its adoption in the 12th century.
    </span>
    <span class="koboSpan" id="kobo.229.3">
     Thank
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      you, Wikipedia.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.231.1">
     Zero has several important properties: it is the additive identity, meaning adding zero to any number leaves the number unchanged.
    </span>
    <span class="koboSpan" id="kobo.231.2">
     Multiplying any number by zero results in zero, and division by zero is undefined.
    </span>
    <span class="koboSpan" id="kobo.231.3">
     Zero is an even number and serves as a neutral element on the number line, being neither positive nor negative.
    </span>
    <span class="koboSpan" id="kobo.231.4">
     In exponents, raising zero to any positive power gives zero, while any non-zero number raised to the power of zero
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.232.1">
      equals one.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.233.1">
     These properties make zero fundamental in mathematics, and with this, we can all agree that zero is one of the most important (if not the most important) numbers that ever existed; its place is up right next to π, or
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.234.1">
      e
     </span>
    </em>
    <span class="koboSpan" id="kobo.235.1">
     , or
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.236.1">
      i
     </span>
    </em>
    <span class="koboSpan" id="kobo.237.1">
     , which we all know is the square root of all evil,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.238.1">
      or –1.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.239.1">
     Now we have presented concrete proof that there is no other number like zero, we also give the following statement: C++ is a unique language.
    </span>
    <span class="koboSpan" id="kobo.239.2">
     In its latest iteration, as of 2024, at the current time, in C++, there are six different ways to initialize a value to zero, honoring the fact that zero is the most important number.
    </span>
    <span class="koboSpan" id="kobo.239.3">
     Ever.
    </span>
    <span class="koboSpan" id="kobo.239.4">
     Just see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.240.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.241.1">
int z;
int main()
{
    int z1 = 0;
    int z2(0);
    int z3{0};
    int z4 = {0};
    int z5{};
    int z6();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.242.1">
     Let’s break it down, line
    </span>
    <a id="_idIndexMarker329">
    </a>
    <span class="koboSpan" id="kobo.243.1">
     by line, as there are not that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.244.1">
      many lines:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.245.1">
       int z;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.246.1">
      – Here, a global variable,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.247.1">
       z
      </span>
     </strong>
     <span class="koboSpan" id="kobo.248.1">
      , of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.249.1">
       int
      </span>
     </strong>
     <span class="koboSpan" id="kobo.250.1">
      type is declared.
     </span>
     <span class="koboSpan" id="kobo.250.2">
      Since it’s a global variable, it is automatically initialized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.251.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.252.1">
      by the compiler (if a global
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.253.1">
       int
      </span>
     </strong>
     <span class="koboSpan" id="kobo.254.1">
      variable isn’t explicitly initialized, it defaults to zero).
     </span>
     <span class="koboSpan" id="kobo.254.2">
      This is something we
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.255.1">
       can trust.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.256.1">
       int z1 = 0;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.257.1">
      – Copy initialization.
     </span>
     <span class="koboSpan" id="kobo.257.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.258.1">
       z1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.259.1">
      variable is declared as an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.260.1">
       int
      </span>
     </strong>
     <span class="koboSpan" id="kobo.261.1">
      type and initialized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.262.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.263.1">
      using copy initialization.
     </span>
     <span class="koboSpan" id="kobo.263.2">
      This involves assigning the value of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.264.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.265.1">
      to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.266.1">
       z1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.267.1">
      after it
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.268.1">
       is created.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.269.1">
       int z2(0);
      </span>
     </strong>
     <span class="koboSpan" id="kobo.270.1">
      – Direct initialization.
     </span>
     <span class="koboSpan" id="kobo.270.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.271.1">
       z2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.272.1">
      variable is declared and initialized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.273.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.274.1">
      using direct initialization, which involves passing the value of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.275.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.276.1">
      directly to the constructor of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.277.1">
       int
      </span>
     </strong>
     <span class="koboSpan" id="kobo.278.1">
      type.
     </span>
     <span class="koboSpan" id="kobo.278.2">
      Not that it has any, but you get
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.279.1">
       the idea.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.280.1">
       int z3{0};
      </span>
     </strong>
     <span class="koboSpan" id="kobo.281.1">
      – Brace initialization (uniform initialization).
     </span>
     <span class="koboSpan" id="kobo.281.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.282.1">
       z3
      </span>
     </strong>
     <span class="koboSpan" id="kobo.283.1">
      variable is declared and initialized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.284.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.285.1">
      using brace initialization.
     </span>
     <span class="koboSpan" id="kobo.285.2">
      It helps prevent issues such as narrowing conversions and provides a consistent syntax for initializing different types.
     </span>
     <span class="koboSpan" id="kobo.285.3">
      This is a peculiar initialization, and we will get back to this syntax a bit later in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.286.1">
       next chapter.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.287.1">
       int z4 = {0};
      </span>
     </strong>
     <span class="koboSpan" id="kobo.288.1">
      – Copy list initialization.
     </span>
     <span class="koboSpan" id="kobo.288.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.289.1">
       z4
      </span>
     </strong>
     <span class="koboSpan" id="kobo.290.1">
      variable is declared and initialized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.291.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.292.1">
      using copy list initialization, a combination of copy initialization and brace initialization.
     </span>
     <span class="koboSpan" id="kobo.292.2">
      It’s similar to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.293.1">
       z3
      </span>
     </strong>
     <span class="koboSpan" id="kobo.294.1">
      but explicitly uses the assignment syntax, and when we talk about simple things such as numbers, there is really
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.295.1">
       no difference.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.296.1">
       int z5{};
      </span>
     </strong>
     <span class="koboSpan" id="kobo.297.1">
      – Value initialization.
     </span>
     <span class="koboSpan" id="kobo.297.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.298.1">
       z5
      </span>
     </strong>
     <span class="koboSpan" id="kobo.299.1">
      variable is initialized using empty braces,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.300.1">
       {}
      </span>
     </strong>
     <span class="koboSpan" id="kobo.301.1">
      , known as value initialization.
     </span>
     <span class="koboSpan" id="kobo.301.2">
      For fundamental types such as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.302.1">
       int
      </span>
     </strong>
     <span class="koboSpan" id="kobo.303.1">
      , this results in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.304.1">
       z5
      </span>
     </strong>
     <span class="koboSpan" id="kobo.305.1">
      being initialized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.306.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.307.1">
      .
     </span>
     <span class="koboSpan" id="kobo.307.2">
      This method is often used to ensure that a variable is zero-initialized without explicitly assigning
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.308.1">
       a value.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.309.1">
     Isn’t it beautiful, the
    </span>
    <a id="_idIndexMarker330">
    </a>
    <span class="koboSpan" id="kobo.310.1">
     amount of consideration that was put into making a variable correspond to the number zero?
    </span>
    <span class="koboSpan" id="kobo.310.2">
     So, one might just ask: why are the local variables of C++ not initialized to zero (or their default value), just
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.311.1">
      in case?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.312.1">
     The answer to this question is partly historical and partly pragmatic.
    </span>
    <span class="koboSpan" id="kobo.312.2">
     Since C++ is based on C, and C was designed to be as close to the metal (silicone) as possible, the compiler did not waste precious processor cycles to initialize a value to their default value, if at some stage later it was used to set to a different value needed by the programmer.
    </span>
    <span class="koboSpan" id="kobo.312.3">
     Elementary, dear reader, as one of the most famous detectives
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      would say.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.314.1">
     Last but not least, without me providing any more details, I really hope you have recognized the most vexing parse in
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.315.1">
       int z6();
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.316.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     The “most vexing parse” is a term used to describe a specific issue in C++ involving the declaration of objects that can be misinterpreted by the compiler due to ambiguities in the syntax.
    </span>
    <span class="koboSpan" id="kobo.317.2">
     It usually arises when you declare a variable using parentheses, which can sometimes be interpreted as a function declaration rather than a variable definition, just like in our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.318.1">
      specific example.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-102">
    <a id="_idTextAnchor101">
    </a>
    <span class="koboSpan" id="kobo.319.1">
     A parenthesis concerning parentheses
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.320.1">
     Now that we are here, we have to mention that there were quite a lot of mentions of parenthesis in this chapter.
    </span>
    <span class="koboSpan" id="kobo.320.2">
     So, we are presenting possibly the most important pair of parentheses
    </span>
    <a id="_idIndexMarker331">
    </a>
    <span class="koboSpan" id="kobo.321.1">
     you can encounter during the course of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      this book.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.323.1">
     Please look at the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.324.1">
      two functions:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.325.1">
static int y;
decltype(auto) number(int x) {
    return y;
}
decltype(auto) reference(int x) {
    return (y);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.326.1">
     Those two
    </span>
    <a id="_idIndexMarker332">
    </a>
    <span class="koboSpan" id="kobo.327.1">
     functions look almost identical, except for the tiny pair of parentheses around the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.328.1">
      return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.329.1">
     value.
    </span>
    <span class="koboSpan" id="kobo.329.2">
     But the presence of those two parentheses makes the biggest difference.
    </span>
    <span class="koboSpan" id="kobo.329.3">
     The weird-looking
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.330.1">
      decltype(auto)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.331.1">
     introduced in C++14 is a type specifier that combines the functionality of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.332.1">
      decltype
     </span>
    </strong>
    <span class="koboSpan" id="kobo.333.1">
     with automatic type deduction, allowing you to declare a variable with a type that is determined by the expression it is initialized with, while also retaining certain properties of that expression.
    </span>
    <span class="koboSpan" id="kobo.333.2">
     Unlike
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.334.1">
      auto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.335.1">
     , which deduces types based on value categories,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.336.1">
      decltype(auto)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.337.1">
     retains the value category (e.g., reference or non-reference) of the expression it is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      based on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.339.1">
     More mundanely, the function number returns an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.340.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.341.1">
     , while the function reference
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      returns
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.343.1">
       int&amp;
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.344.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.345.1">
     In order to verify the correctness of what we previously wrote, the following code snippets can be of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.346.1">
      great help:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.347.1">
using namespace std;
if (is_reference&lt;decltype(number(42))&gt;::value) {
    cout &lt;&lt; "Reference to ";
    cout &lt;&lt; typeid(typename 
remove_reference&lt;decltype(number(42))&gt;::type).name() &lt;&lt; endl;
} else {
    cout &lt;&lt; "Not a reference: " &lt;&lt; typeid(decltype(number(42))).name() &lt;&lt; endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     The preceding code snippet examines the return type provided by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.349.1">
      number
     </span>
    </strong>
    <span class="koboSpan" id="kobo.350.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.350.2">
     As the name hastily suggests, it will return, well...
    </span>
    <span class="koboSpan" id="kobo.350.3">
     a number.
    </span>
    <span class="koboSpan" id="kobo.350.4">
     When compiled with MSVC and executed, the following is the output of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.351.1">
      the code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.352.1">
Not a reference: int</span></pre>
   <p>
    <span class="koboSpan" id="kobo.353.1">
     The
    </span>
    <a id="_idIndexMarker333">
    </a>
    <span class="koboSpan" id="kobo.354.1">
     other compilers also have the same behavior, except they do not print out the full type of the variable, because
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.355.1">
      gcc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.356.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.357.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.358.1">
     for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.359.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.360.1">
     type just return a single
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.361.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.362.1">
     and that wouldn’t have been
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.363.1">
      so spectacular.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.364.1">
     Now, let’s examine the following sequence
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      of code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.366.1">
if (is_reference&lt;decltype(reference(42))&gt;::value) {
    cout &lt;&lt; "Reference to: ";
    cout &lt;&lt; typeid(typename 
remove_reference&lt;decltype(reference(42))&gt;::type).name() &lt;&lt; endl;
} else {
    cout &lt;&lt; "Not a reference: " &lt;&lt; typeid(decltype(number(42))).name() &lt;&lt; endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.367.1">
     This is almost identical to the one before this, except that it uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.368.1">
      reference
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     method instead of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.370.1">
      number
     </span>
    </strong>
    <span class="koboSpan" id="kobo.371.1">
     .
    </span>
    <span class="koboSpan" id="kobo.371.2">
     Not surprisingly, the result of the execution is (again, appealing to MSVC)
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.372.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.373.1">
Reference to: int</span></pre>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     So, with the preceding code, we have just proved that a pair of extra parentheses combined with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.375.1">
      decltype(auto)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.376.1">
     can provide some spectacular outcomes.
    </span>
    <span class="koboSpan" id="kobo.376.2">
     Be warned.
    </span>
    <span class="koboSpan" id="kobo.376.3">
     Let’s say we omit
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.377.1">
      decltype
     </span>
    </strong>
    <span class="koboSpan" id="kobo.378.1">
     , such as in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.379.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.380.1">
auto reference(int x) {
    return (y);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.381.1">
     The compiler then ignores the parentheses and just returns a normal number.
    </span>
    <span class="koboSpan" id="kobo.381.2">
     The C++ standard specifies this behavior in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.382.1">
      [dcl.type.decltype]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.383.1">
     section and the authors warmly
    </span>
    <a id="_idIndexMarker334">
    </a>
    <span class="koboSpan" id="kobo.384.1">
     recommend reading through it, in order to have a full understanding of what happens behind the scenes and a valid reasoning
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.385.1">
      for it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.386.1">
     Now, because we are C++ programmers, always in pursuit of speed, high-quality, and clear code, you could ask why we had to duplicate the code to identify whether we have a reference or not.
    </span>
    <span class="koboSpan" id="kobo.386.2">
     Wouldn’t it have been perfectly valid to write something like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.387.1">
      the following?
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.388.1">
template &lt;typename T&gt;
void printType(T&amp;&amp; var) {
    if (std::is_reference&lt;T&gt;::value) {
        if (std::is_lvalue_reference&lt;T&gt;::value) {
            printf("lvalue ref ");
        } else {
            printf("rvalue ref ");
        }
        printf("%s\n", (typeid(typename
                  std::remove_reference&lt;T&gt;::type).name()));
    } else {
        printf("%s\n", typeid(var).name());
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.389.1">
     This is almost the same as above-above (above-above is like above, but refers to one above before the actual above), except that we have added an extra check to verify the type of the reference (and also removed
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.390.1">
      std::cout
     </span>
    </strong>
    <span class="koboSpan" id="kobo.391.1">
     in favor of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.392.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.393.1">
     because it generates much cleaner assembly code, and also put it in the body of a function).
    </span>
    <span class="koboSpan" id="kobo.393.2">
     Indeed, let’s say we put it into this context and call
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.394.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.395.1">
printType(number(42));
printType(reference(42));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.396.1">
     We get the correct and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.397.1">
      expected output:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.398.1">
int
lvalue ref int</span></pre>
   <p>
    <span class="koboSpan" id="kobo.399.1">
     As a side note, we
    </span>
    <a id="_idIndexMarker335">
    </a>
    <span class="koboSpan" id="kobo.400.1">
     get the same result with other, not-that-tiny-and-squishy
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.401.1">
      compilers, too.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.402.1">
     This function template uses a forwarding reference (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.403.1">
      T&amp;&amp; var
     </span>
    </strong>
    <span class="koboSpan" id="kobo.404.1">
     ) to handle both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.405.1">
      lvalue
     </span>
    </strong>
    <strong class="bold">
    </strong>
    <span class="koboSpan" id="kobo.406.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.407.1">
      rvalue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.408.1">
     references, making it capable of deducing and preserving the reference type of the passed variable.
    </span>
    <span class="koboSpan" id="kobo.408.2">
     By using the type traits library, we check whether
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.409.1">
      T
     </span>
    </strong>
    <span class="koboSpan" id="kobo.410.1">
     is a reference type using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.411.1">
      is_reference&lt;T&gt;::value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.412.1">
     , and further distinguish between
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.413.1">
      lvalue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.414.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.415.1">
      rvalue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.416.1">
     references
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.417.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.418.1">
       is_lvalue_reference&lt;T&gt;::value
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.419.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.420.1">
     If it’s a reference, we print whether it’s an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.421.1">
      lvalue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.422.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.423.1">
      rvalue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.424.1">
     reference along with the type of the variable without the reference
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.425.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.426.1">
       remove_reference&lt;T&gt;::type
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.428.1">
     If it’s not a reference, we directly print the type of the variable.
    </span>
    <span class="koboSpan" id="kobo.428.2">
     This approach works because of the perfect forwarding mechanics in C++, allowing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.429.1">
      T
     </span>
    </strong>
    <span class="koboSpan" id="kobo.430.1">
     to be deduced as the exact type of the passed variable, preserving its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.431.1">
      reference nature.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.432.1">
     Please note that it was mandatory to use the forwarding reference,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.433.1">
      T&amp;&amp; var
     </span>
    </strong>
    <span class="koboSpan" id="kobo.434.1">
     ; if we had used just
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.435.1">
      T var
     </span>
    </strong>
    <span class="koboSpan" id="kobo.436.1">
     , it would not work the same way for reference types.
    </span>
    <span class="koboSpan" id="kobo.436.2">
     This is because, in this form,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.437.1">
      T
     </span>
    </strong>
    <span class="koboSpan" id="kobo.438.1">
     would have been deduced as a non-reference type, so
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.439.1">
      var
     </span>
    </strong>
    <span class="koboSpan" id="kobo.440.1">
     inside the function would have been always a copy of the original argument, not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.441.1">
      a reference.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.442.1">
     As an extra goodie for you, dear reader, here are some extracts of the assembly output of one of the compilers (GCC, in our case).
    </span>
    <span class="koboSpan" id="kobo.442.2">
     You can see how it generates two distinct functions, and most importantly, what goes inside
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.443.1">
      those functions:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-3">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.444.1">void printType &lt;int&gt;(int&amp;&amp;):</span></strong></pre>
      </td>
      <td class="No-Table-Style">
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.445.1">void printType &lt;int&amp;&gt;(int&amp;):</span></strong></pre>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.446.1">push rbp</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.447.1">mov rbp, rsp</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.448.1">sub rsp, 16</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.449.1">mov QWORD PTR [rbp-8], rdi</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.450.1">mov edi, OFFSET</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.451.1">         FLAT:typeinfo</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.452.1">call std::type_info::name()</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.453.1">mov rdi, rax</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.454.1">call puts</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.455.1">nop</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.456.1">leave</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.457.1">ret</span></strong></pre>
      </td>
      <td class="No-Table-Style">
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.458.1">push rbp</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.459.1">mov rbp, rsp</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.460.1">sub rsp, 16</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.461.1">mov QWORD PTR [rbp-8], rdi</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.462.1">mov edi, OFFSET FLAT:.LC0</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.463.1">mov eax, 0</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.464.1">call printf</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.465.1">mov edi, OFFSET</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.466.1">         FLAT:typeinfo</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.467.1">call std::type_info::name() mov rdi, rax</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.468.1">call puts</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.469.1">nop</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.470.1">leave</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.471.1">ret</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.472.1">.LC0:</span></strong></pre>
       <pre class="source-code">
<strong class="source-inline" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.473.1"> .string "lvalue ref "</span></strong></pre>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.474.1">
     Table 9.1: Comparing the assembly listings of various printType instantiations
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.475.1">
     We can see
    </span>
    <a id="_idIndexMarker336">
    </a>
    <span class="koboSpan" id="kobo.476.1">
     two instantiations of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.477.1">
      printType
     </span>
    </strong>
    <span class="koboSpan" id="kobo.478.1">
     function for each of the types returned by the two functions, and how in each of them the various calls to the type traits were successfully implemented at the source code level, thus leading to the removal of unnecessary branches.
    </span>
    <span class="koboSpan" id="kobo.478.2">
     We can also observe the removal of the unnecessary strings (nowhere is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.479.1">
      "rvalue ref"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.480.1">
     found in the generated code because the compiler identified that the branch containing it is nowhere to be found in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.481.1">
      final code).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.482.1">
     Isn’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.483.1">
      C++ beautiful?
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-103">
    <a id="_idTextAnchor102">
    </a>
    <span class="koboSpan" id="kobo.484.1">
     C++uties
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.485.1">
     It is time that
    </span>
    <a id="_idIndexMarker337">
    </a>
    <span class="koboSpan" id="kobo.486.1">
     the author of these lines has to admit something.
    </span>
    <span class="koboSpan" id="kobo.486.2">
     He’s tired of ugly code trying to win the C++ beauty contest.
    </span>
    <span class="koboSpan" id="kobo.486.3">
     Regardless of how hard we try to convince ourselves that the code we presented a few sections before is beautiful and is worth remembering, well, it is not.
    </span>
    <span class="koboSpan" id="kobo.486.4">
     It is ugly and horrible, and please forget, dear reader, that you ever had to read something like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.487.1">
      that.
     </span>
     <span class="koboSpan" id="kobo.487.2">
      Apologies.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.488.1">
     From this point on, we solemnly promise that we are up to no more mischief and will treat you only with beautiful code.
    </span>
    <span class="koboSpan" id="kobo.488.2">
     No more ugly macros, no more shady substitutions, no more arcane techniques.
    </span>
    <span class="koboSpan" id="kobo.488.3">
     Just pure, joyful,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.489.1">
      lovable C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.490.1">
     As a result of this reinvention of ourselves (as the writer of beautiful C++ code), we present you the next program, which possibly is the cutest one you can get your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.491.1">
      hands on:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer034">
     <span class="koboSpan" id="kobo.492.1">
      <img alt="img" role="presentation" src="image/B22235_09_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Figure">
    <span lang="en-US" xml:lang="en-US">
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.493.1">
     Please bear with us, for the sake of brevity, we have omitted the includes for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.494.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.496.1">
      std::cout
     </span>
    </strong>
    <span class="koboSpan" id="kobo.497.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.498.1">
      std::unique_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.499.1">
     .
    </span>
    <span class="koboSpan" id="kobo.499.2">
     Who said C++ can’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.500.1">
      be cute?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.501.1">
     But sadly, the preceding code is not widely recognized as being standard C++ (seemingly, there is no clear consensus among compiler developers on which Unicode identifiers to consider valid in the source code, regardless of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.502.1">
      [tab:lex.name.allowed]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.503.1">
     in the latest C++ standard), but not all hope is lost, as GCC accepts it.
    </span>
    <span class="koboSpan" id="kobo.503.2">
     Maybe there was a bear hugger in the ranks of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.504.1">
      their developers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.505.1">
     As a side note, the
    </span>
    <a id="_idIndexMarker338">
    </a>
    <span class="koboSpan" id="kobo.506.1">
     code presented does not do too much, just feeds some bears with their proper meal, considering their nutrition needs, dietary requirements, and affiliations with various dietary patterns and current culinary trends present in Bearland.
    </span>
    <span class="koboSpan" id="kobo.506.2">
     Didn’t we deliver a cute program, a possible contender to the winner of the most beautiful
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.507.1">
      C++ code?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.508.1">
     There are a good number of books we encourage our dear esteemed readers to read, if they want their programs to follow common sense guidelines, be readable, stable, easily maintainable and up to the latest standards.
    </span>
    <span class="koboSpan" id="kobo.508.2">
     Sadly none of those books detail how to write fun programs, because writing fun programs, or writing programs for fun involves a different mindset, and is rarely done for profit.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.509.1">
     Programming can be an art form, producing code that surprises and delights, having code can include Easter eggs, humorous output, applying playful user interaction, or unusual visualizations.
    </span>
    <span class="koboSpan" id="kobo.509.2">
     Playfulness could be as simple as using emojis as identifiers (as in our bear example) or making quirky applications with oddball logic.
    </span>
    <span class="koboSpan" id="kobo.509.3">
     Fun programming often rejects the rigidity of formal practices in favor of creative solutions that may be inefficient or overly complex just for the sake of enjoyment, such as crafting an obfuscated piece of code, just because we find it to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.510.1">
      be fun.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.511.1">
     Fun in programming can also come from solving intriguing puzzles or exploring unconventional programming paradigms (functional, esoteric languages such as Brainfuck or LOLCODE), or building projects purely out
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.512.1">
      of curiosity.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.513.1">
     While formal books on “beautiful” or “clean” code emphasize correctness, safety, and readability, fun programming opens the door to spontaneity, art, and entertainment, so no wonder that our last happening for this chapter is taking part in the last one.
    </span>
    <span class="koboSpan" id="kobo.513.2">
     It is short, it is cute, and it looks like something out of a fairy tale.
    </span>
    <span class="koboSpan" id="kobo.513.3">
     With bears.
    </span>
    <span class="koboSpan" id="kobo.513.4">
     Because who doesn’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.514.1">
      like bears?
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-104">
    <a id="_idTextAnchor103">
    </a>
    <span class="koboSpan" id="kobo.515.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.516.1">
     Not all that is shining is gold, and not every piece of code that seems exciting and bears complex features is necessarily of high quality.
    </span>
    <span class="koboSpan" id="kobo.516.2">
     The allure of shiny, intricate code can sometimes overshadow the fundamental qualities that define good programming practices.
    </span>
    <span class="koboSpan" id="kobo.516.3">
     Good, stable code is frequently characterized by its straightforwardness and predictability rather than its flair.
    </span>
    <span class="koboSpan" id="kobo.516.4">
     This type of code may seem unremarkable or mundane compared to more fun constructs, but it is precisely this simplicity that ensures robustness and ease of understanding.
    </span>
    <span class="koboSpan" id="kobo.516.5">
     When you have to, please try to write boring, simple code, as it will be much easier to read in half a year from now, but every time you can afford to, please squeeze in a bear or two in your fun side project.
    </span>
    <span class="koboSpan" id="kobo.516.6">
     Unless you plan to read
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.517.1">
      it, too.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.518.1">
     In our next chapter, Alex will go on a crusade to advocate the proper use of modern C++ libraries, in order to debunk the myth that C++ libraries are also stuck in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.519.1">
      Stone Age.
     </span>
    </span>
   </p>
  </div>
 </body></html>