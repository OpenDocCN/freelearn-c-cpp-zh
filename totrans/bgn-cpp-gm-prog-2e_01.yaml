- en: Preface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前言
- en: This book is all about offering you a fun introduction to the world of game
    programming, C++, and the OpenGL-powered SFML using five fun, fully playable games
    of increasing difficulty and advancing features. These games are an addictive,
    frantic two-button tapper, a Pong game, a multilevel zombie survival shooter,
    a split-screen multiplayer puzzle platformer, and a shooter game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在以有趣的方式为你介绍游戏编程、C++以及OpenGL驱动的SFML的世界，通过五个难度递增、功能不断升级的有趣、可玩的游戏来实现。这些游戏包括一个上瘾的、急速的双按钮敲击游戏、一个Pong游戏、一个多级僵尸生存射击游戏、一个分屏多人解谜平台游戏和一个射击游戏。
- en: With this improved and extended second edition, we will start with the very
    basics of programming, such as variables, loops, and conditions, and you will
    become more skillful with each game as you move through the key C++ topics, such
    as **object-oriented programming** (**OOP**), C++ pointers, and an introduction
    to the **Standard Template Library** (**STL**). While building these games, you
    will also learn exciting game programming concepts, such as particle effects,
    directional sound (spatialization), OpenGL programmable Shaders, how to spawn
    thousands of objects, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个改进和扩展的第二版中，我们将从编程的基础开始，例如变量、循环和条件，随着你通过关键C++主题，如**面向对象编程**（**OOP**）、C++指针以及**标准模板库**（**STL**）的介绍，你将变得越来越熟练。在构建这些游戏的过程中，你还将学习到令人兴奋的游戏编程概念，例如粒子效果、方向性声音（空间化）、OpenGL可编程着色器、如何生成成千上万的对象等等。
- en: Who this book is for
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这本书面向的对象
- en: 'This book is perfect for you if any of the following describes you: You have
    no C++ programming knowledge whatsoever, or need a beginner level refresher course,
    if you want to learn to build games or just use games as an engaging way to learn
    C++, if you have aspirations to publish a game one day, perhaps on Steam, or if
    you just want to have loads of fun and impress friends with your creations.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你符合以下任何一种情况，这本书非常适合你：你完全没有任何C++编程知识，或者需要入门级别的复习课程；你想学习如何构建游戏，或者只是想将游戏作为一种有趣的学习C++的方式；如果你有有一天发布游戏的抱负，也许是在Steam上，或者你只是想尽情享受乐趣，并用你的创作给朋友们留下深刻印象。
- en: What this book covers
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书涵盖的内容
- en: '[*Chapter 1*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017), *C++, SFML,
    Visual Studio, and Starting the First Game*, represents quite a hefty first chapter,
    but we will learn absolutely everything we need in order to have the first part
    of our first game up and running. Here is what we will do: Find out about the
    games we will build, discover C++, find out about Microsoft Visual C++, explore
    SFML and its relationship with C++, set up the development environment, plan and
    prepare for the first game project, Timber!!!, write the first C++ code in the
    book, and make a runnable game that draws a background.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第1章*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017)，*C++、SFML、Visual Studio和开始第一个游戏*，是一个相当庞大的第一章，但我们将学习所有我们需要的东西，以便让我们的第一个游戏的第一部分能够运行起来。以下是我们要做的事情：了解我们将要构建的游戏，了解C++，了解微软Visual
    C++，了解SFML及其与C++的关系，设置开发环境，计划和准备第一个游戏项目Timber!!!，在书中编写第一段C++代码，并制作一个可以运行的游戏，该游戏可以绘制背景。'
- en: '[*Chapter* *2*](B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070), *Variables,
    Operators, and Decisions – Animating Sprites*, covers quite a bit more drawing
    on screen and, in order to achieve this, we will need to learn some of the basics
    of C++. We will learn how to use variables to remember and manipulate values,
    and we will also begin to add more graphics to the game. As the chapter progresses,
    we will see how we can manipulate these values to animate the graphics. These
    values are known as variables.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第2章*](B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070)，*变量、运算符和决策 – 动画精灵*，涉及更多的屏幕绘制，为了实现这一点，我们需要学习一些C++的基础知识。我们将学习如何使用变量来记住和操作值，我们还将开始为游戏添加更多图形。随着章节的推进，我们将看到如何操作这些值来动画化图形。这些值被称为变量。'
- en: '[*Chapter 3*](B14278_03_Final_AG_ePub.xhtml#_idTextAnchor098), *C++ Strings
    and SFML Time – Player Input and HUD*, continues with the Timber!!! game. We will
    spend half the chapter learning how to manipulate text and display it on the screen,
    and the other half looking at timing and how a visual time bar can inform the
    player and create a sense of urgency in the game. We will cover the following:
    Pausing and restarting the game, C++ Strings, SFML Text and SFML Font classes,
    adding an HUD to Timber!!!, and adding a time bar to Timber!!!.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第3章*](B14278_03_Final_AG_ePub.xhtml#_idTextAnchor098)，*C++ 字符串和 SFML 时间 –
    玩家输入和 HUD*，继续介绍 Timber!!! 游戏。我们将用一半的章节学习如何操作文本并在屏幕上显示它，另一半将探讨时间管理以及如何通过视觉时间条来告知玩家并营造游戏的紧迫感。我们将涵盖以下内容：暂停和重新启动游戏，C++
    字符串，SFML 文本和 SFML 字体类，为 Timber!!! 添加 HUD，以及为 Timber!!! 添加时间条。'
- en: '[*Chapter 4*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*, Loops, Arrays,
    Switches, Enumerations, and Functions – Implementing Game Mechanics*, probably
    has more C++ information than any other chapter in the book. It is packed with
    fundamental concepts that will improve our understanding enormously. It will also
    begin to shed light on some of the murky areas we have been skipping over a little
    bit, such as functions and the game loop. Once we have explored a whole list of
    C++ language necessities, we will then use everything we know to make the main
    game mechanics—the tree branches—move. By the end of this chapter, we will be
    ready for the final phase and the completion of Timber!!!. This is what we will
    explore in this chapter: Loops, arrays, making decisions with switches, enumerations,
    getting started with functions, and creating and moving the tree branches.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第4章*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*，循环、数组、开关、枚举和函数 – 实现游戏机制*，可能比书中任何其他章节都包含更多的
    C++ 信息。它充满了将极大地提高我们理解的基本概念。它还将开始揭示我们之前略过的一些模糊区域，例如函数和游戏循环。一旦我们探索了整个 C++ 语言必需品列表，我们就会利用我们所知道的一切来制作主要游戏机制——树枝——移动。到本章结束时，我们将为最终阶段和
    Timber!!! 的完成做好准备。这是我们将在本章中探讨的内容：循环、数组、使用开关做出决策、枚举、开始使用函数，以及创建和移动树枝。'
- en: '[*Chapter 5*](B14278_05_Final_AG_ePub.xhtml#_idTextAnchor138), *Collisions,
    Sound, and End Conditions – Making the Game Playable*, constitutes the final phase
    of the first project. By the end of this chapter, you will have your first completed
    game. Once you have Timber!!! up and running, be sure to read the final section
    of this chapter as it will suggest ways to make the game better. In this chapter,
    we will cover the following topics: Adding the remainder of the sprites, handling
    the player input, animating the flying log, handling death, adding sound effects,
    adding features, and improving Timber!!!.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第5章*](B14278_05_Final_AG_ePub.xhtml#_idTextAnchor138)，*碰撞、声音和结束条件 – 使游戏可玩*，构成了第一个项目的最后阶段。到本章结束时，你将拥有你的第一个完成的游戏。一旦
    Timber!!! 运行起来，请务必阅读本章的最后部分，因为它将建议如何使游戏变得更好。在本章中，我们将涵盖以下主题：添加剩余的精灵，处理玩家输入，动画飞行木块，处理死亡，添加音效，添加功能，并改进
    Timber!!!。'
- en: '[*Chapter 6*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154), *Object-Oriented
    Programming – Starting the Pong Game*, contains quite a large amount of theory,
    but the theory will give us the knowledge to start using OOP to powerful effect.
    Furthermore, we will not waste any time in putting that theory to good use coding
    the next project, a Pong game. We get to look behind the scenes at how we can
    create new types that we use as objects by coding a class. We will first look
    at a simplified Pong scenario to learn some class basics, and then we will start
    again and code a Pong game for real using the principles we have learned.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第6章*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154)，*面向对象编程 – 开始 Pong 游戏*，包含相当大量的理论，但理论将为我们提供使用
    OOP 强力效果的知识。此外，我们不会浪费时间将理论应用于编码下一个项目，一个 Pong 游戏。我们将了解如何通过编写一个类来创建新类型，这些类型作为对象使用。我们将首先查看一个简化的
    Pong 场景来学习一些类的基本知识，然后我们将重新开始并使用我们学到的原则来编写一个真正的 Pong 游戏。'
- en: '[*Chapter 7*](B14278_07_Final_AG_ePub.xhtml#_idTextAnchor175), *Dynamic Collision
    Detection and Physics – Finishing the Pong Game*, explains how to code our second
    class. We will see that although the ball is obviously quite different from the
    bat, we will use the exact same techniques to encapsulate the appearance and functionality
    of a ball inside a `Ball` class, as we did with the bat and the `Bat` class. We
    will then add the finishing touches to the Pong game by coding some dynamic collision
    detection and score keeping. This may sound complicated, but, as we are coming
    to expect, SFML will make things much easier than they otherwise would be.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第7章*](B14278_07_Final_AG_ePub.xhtml#_idTextAnchor175)，*动态碰撞检测和物理 – 完成乒乓球游戏*，解释了如何编写我们的第二个类。我们将看到，尽管球显然与球拍有很大不同，但我们仍然会使用完全相同的技术，将球的外观和功能封装在
    `Ball` 类中，就像我们处理球拍和 `Bat` 类一样。然后，我们将通过编写一些动态碰撞检测和计分来完善乒乓球游戏。这听起来可能很复杂，但正如我们所期待的，SFML
    将使事情比其他方式更容易。'
- en: '[*Chapter 8*](B14278_08_Final_AG_ePub.xhtml#_idTextAnchor183)*, SFML Views
    – Starting the Zombie Shooter Game*, explains how this project makes even more
    use of OOP, and to a powerful effect. We will also be exploring the SFML `View`
    class. This versatile class will enable us to easily divide our game up into layers
    for different aspects of the game. In the Zombie Shooter project, we will have
    a layer for the HUD and a layer for the main game. This will be necessary because,
    as the game world expands each time the player clears a wave of zombies, eventually,
    the game world will be bigger than the screen and will need to scroll. The use
    of the View class will prevent the text from the HUD from scrolling with the background.
    In the next project, we will take things even further and create a co-op split-screen
    game with the SFML View class doing most of the hard work. This is what we will
    do in this chapter: Plan the Zombie Arena game, code the `Player` class, learn
    about the SFML View class, and build the Zombie Arena game engine, putting the
    player class to work.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第8章*](B14278_08_Final_AG_ePub.xhtml#_idTextAnchor183)*，SFML 视图 – 开始僵尸射击游戏*，解释了该项目如何更充分地利用面向对象编程（OOP），并取得了显著的效果。我们还将探讨
    SFML 的 `View` 类。这个多功能的类将使我们能够轻松地将游戏分层，以适应游戏的不同方面。在僵尸射击项目中，我们将有一个用于HUD的层和一个用于主游戏的层。这是必要的，因为随着游戏世界的每次扩展，玩家清除一波僵尸后，游戏世界最终将比屏幕大，需要滚动。使用视图类可以防止HUD中的文本与背景一起滚动。在下一个项目中，我们将更进一步，使用
    SFML 视图类创建一个合作分屏游戏，视图类将完成大部分繁重的工作。这就是本章我们将要完成的内容：规划僵尸竞技场游戏，编写 `Player` 类，学习 SFML
    视图类，并构建僵尸竞技场游戏引擎，使玩家类发挥作用。'
- en: '[*Chapter 9*](B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200), *C++ References,
    Sprite Sheets, and Vertex Arrays*, explores C++ references, which allow us to
    work on variables and objects that are otherwise out of scope. In addition, references
    will help us to avoid having to pass large objects between functions, which is
    a slow process. It is a slow process because each time we do this, a copy of the
    variable or object must be made. Armed with this new knowledge about references,
    we will look at the SFML `VertexArray` class, which allows us to build up a large
    image that can be very quickly and efficiently drawn to the screen using multiple
    parts in a single image file. By the end of the chapter, we will have a scalable,
    random, scrolling background, using references and a `VertexArray` object.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第9章*](B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200)，*C++ 引用、精灵图集和顶点数组*，探讨了C++引用，它允许我们处理那些通常不在作用域内的变量和对象。此外，引用将帮助我们避免在函数之间传递大型对象，这是一个缓慢的过程。这是因为每次我们这样做时，都必须创建变量或对象的副本。掌握了关于引用的新知识后，我们将研究
    SFML 的 `VertexArray` 类，它允许我们构建一个大型图像，可以通过单个图像文件中的多个部分快速高效地绘制到屏幕上。到本章结束时，我们将使用引用和
    `VertexArray` 对象构建一个可伸缩的、随机的、滚动的背景。'
- en: '[*Chapter 10*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214), *Pointers,
    the Standard Template Library, and Texture Management*, first covers the fundamental
    C++ topic of pointers. Pointers are variables that hold a memory address. Typically,
    a pointer will hold the memory address of another variable. This sounds a bit
    like a reference, but we will see how they are much more powerful, and we will
    use a pointer to handle an ever-expanding horde of zombies. We will also learn
    about the STL, which is a collection of classes that allow us to quickly and easily
    implement common data management techniques. Once we understand the basics of
    the STL, we will be able to use that newly acquired knowledge to manage all the
    textures from the game, because if we have 1,000 zombies, we don''t really want
    to load a copy of a zombie graphic into the GPU for each and every one. We will
    also dig a little deeper into OOP and use a static function, which is a function
    of a class that can be called without an instance of the class. At the same time,
    we will see how we can design a class to ensure that only one instance can ever
    exist. This is ideal when we need to guarantee that different parts of our code
    will use the same data.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第10章*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214)，*指针、标准模板库和纹理管理*，首先介绍了C++的基本主题——指针。指针是存储内存地址的变量。通常，指针将存储另一个变量的内存地址。这听起来有点像引用，但我们将看到它们要强大得多，我们将使用指针来处理不断增长的僵尸群。我们还将了解STL，它是一组类，允许我们快速轻松地实现常见的数据管理技术。一旦我们理解了STL的基础，我们就能使用新获得的知识来管理游戏中的所有纹理，因为如果我们有1,000个僵尸，我们真的不希望为每个僵尸加载一个图形副本到GPU中。我们还将更深入地探讨面向对象编程，并使用静态函数，这是一个可以在没有类实例的情况下调用的类函数。同时，我们将看到如何设计一个类，以确保只能存在一个实例。当我们需要确保代码的不同部分使用相同的数据时，这是理想的。'
- en: '[*Chapter 11*](B14278_11_Final_AG_ePub.xhtml#_idTextAnchor249), *Collision
    Detection, Pickups, and Bullets*, explains how we have implemented the main visual
    aspects of our game so far. We have a controllable character running around in
    an arena full of zombies that chase him. The problem is that they don''t interact
    with one another. A zombie can wonder right through the player without leaving
    a scratch. We need to detect collisions between the zombies and the player. If
    the zombies are going to be able to injure and eventually kill the player, it
    is only fair that we give the player some bullets for his gun. We will then need
    to make sure that the bullets can hit and kill the zombies. At the same time,
    if we are writing collision detection code for bullets, zombies, and the player,
    it would be a good time to add a class for health and ammo pickups as well.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第11章*](B14278_11_Final_AG_ePub.xhtml#_idTextAnchor249)，*碰撞检测、拾取和子弹*，解释了到目前为止我们是如何实现游戏的主要视觉方面的。我们有一个可控的角色在一个满是僵尸的竞技场中奔跑，这些僵尸会追逐他。问题是它们之间没有互动。一个僵尸可以毫无阻碍地穿过玩家而不会留下任何痕迹。我们需要检测僵尸和玩家之间的碰撞。如果僵尸能够伤害并最终杀死玩家，那么给玩家一些子弹是公平的。然后我们需要确保子弹能够击中和杀死僵尸。同时，如果我们正在编写子弹、僵尸和玩家的碰撞检测代码，那么添加一个用于健康和弹药拾取的类也是一个好时机。'
- en: '[*Chapter 12*](B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272), *Layering Views
    and Implementing the HUD*, is the chapter where we will get to see the real value
    of SFML Views. We will add a large array of SFML `Text` objects and manipulate
    them, as we did before in the Timber project and the Pong project. What is new
    is that we will draw the HUD using a second View instance. This way, the HUD will
    stay neatly positioned over the top of the main game action, regardless of what
    the background, player, zombies, and other game objects are doing.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第12章*](B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272)，*分层视图和实现HUD*，是我们将看到SFML视图真正价值的章节。我们将添加大量SFML
    `Text` 对象，并像在Timber项目和Pong项目中那样操作它们。新的地方在于，我们将使用第二个视图实例来绘制HUD。这样，无论背景、玩家、僵尸和其他游戏对象在做什么，HUD都会整齐地定位在主要游戏动作的上方。'
- en: '[*Chapter 13*](B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279), *Sound Effects,
    File I/O, and Finishing the Game*, demonstrates how we can easily manipulate files
    stored on the hard drive using the C++ standard library, and we will also add
    sound effects. Of course, we know how to add sound effects, but we will discuss
    exactly where in the code the calls to the play function will go. We will also
    tie up a few loose ends to make the game complete. In this chapter, we will do
    the following: Save and load the hi-score using file input and file output, add
    sound effects to allow the player to level up, and create never-ending multiple
    waves.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第13章*](B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279), *音效、文件输入/输出和完成游戏*，展示了我们如何使用C++标准库轻松地操作硬盘上存储的文件，并且我们还将添加音效。当然，我们知道如何添加音效，但我们将讨论代码中调用播放函数的确切位置。我们还将解决一些悬而未决的问题，使游戏完整。在本章中，我们将做以下事情：使用文件输入和文件输出保存和加载高分，添加音效以允许玩家升级，并创建无限循环的多波次。'
- en: '[*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292), *Abstraction
    and Code Management – Making Better Use of OOP*, focuses on getting the Thomas
    Was Alone project started, especially exploring how the code will be structured
    to make better use of OOP. Here are the details of the topics that will be covered
    in this chapter: The final project, Thomas Was Late, is introduced, including
    the gameplay features and project assets, and a detailed discussion is provided
    of how we will improve the structure of the code compared to previous projects,
    code the Thomas Was Late game engine, and implement the split-screen functionality.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第14章*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292), *抽象和代码管理 – 更好地利用面向对象编程*，专注于启动托马斯独自一个项目，特别是探索代码将如何结构化以更好地利用面向对象编程。以下是本章将涵盖的主题的详细信息：介绍了最终项目，托马斯迟到，包括游戏玩法功能和项目资产，并详细讨论了与之前项目相比，我们将如何改进代码结构，编写托马斯迟到游戏引擎，并实现分屏功能。'
- en: '[*Chapter 15*](B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306), *Advanced OOP
    – Inheritance and Polymorphism*, extends our knowledge of OOP further by looking
    at the slightly more advanced concepts of inheritance and polymorphism. We will
    then be able to use this new knowledge to implement the star characters of our
    game, Thomas and Bob. Here is what we will cover in this chapter: Learn how to
    extend and modify a class using inheritance, treat an object of a class as if
    it is more than one type of class by using polymorphism, learn about abstract
    classes and how designing classes that are never instantiated can actually be
    useful, build an abstract `PlayableCharacter` class, put inheritance to work with
    the `Thomas` and `Bob` classes, and add Thomas and Bob to the game project.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第15章*](B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306), *高级面向对象编程 – 继承和多态*，通过探讨稍微高级一些的继承和多态概念，进一步扩展了我们对于面向对象编程的知识。然后，我们将能够运用这些新知识来实现游戏中的主角，托马斯和鲍勃。以下是本章将涵盖的内容：学习如何通过继承扩展和修改一个类，通过使用多态将一个类的对象视为多种类型的类，了解抽象类以及设计永远不会实例化的类实际上可能是有用的，构建一个抽象的
    `PlayableCharacter` 类，将继承应用于 `Thomas` 和 `Bob` 类，并将托马斯和鲍勃添加到游戏项目中。'
- en: '[*Chapter 16*](B14278_16_Final_AG_ePub.xhtml#_idTextAnchor327), *Building Playable
    Levels and Collision Detection*, will probably prove to be one of the most satisfying
    chapters of this project. The reason for this is that by the end of it, we will
    have a playable game. Although there will still be features to implement (sound,
    particle effects, HUD, and shader effects), Bob and Thomas will be able to run,
    jump, and explore the world. Furthermore, you will be able to create your very
    own level designs of any size or complexity by simply making platforms and obstacles
    in a text file. We will achieve all this by covering these topics: Exploring how
    to design levels in a text file, building a `LevelManager` class that will load
    levels from a text file, convert them into data that our game can use and keep
    track of the level details, such as spawn position, current level, and allowed
    time limit, update the game engine to use `LevelManager`, and code a polymorphic
    function to handle the collision detection for both Bob and Thomas.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第16章*](B14278_16_Final_AG_ePub.xhtml#_idTextAnchor327)，*构建可玩关卡和碰撞检测*，可能会证明是本项目中最令人满意的一章。原因在于，到那时，我们将拥有一个可玩的游戏。尽管仍有一些功能需要实现（声音、粒子效果、HUD和着色器效果），Bob和Thomas将能够跑步、跳跃和探索世界。此外，你只需在文本文件中创建平台和障碍物，就可以简单地创建任何大小或复杂性的自己的关卡设计。我们将通过以下主题实现所有这些：探索如何在文本文件中设计关卡，构建一个`LevelManager`类，从文本文件中加载关卡，将它们转换为我们的游戏可以使用的数据，并跟踪关卡细节，如出生位置、当前关卡和允许的时间限制，更新游戏引擎以使用`LevelManager`，并编写一个多态函数来处理Bob和Thomas的碰撞检测。'
- en: '[*Chapter 17*](B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340), *Sound Spatialization
    and the HUD*, adds all the sound effects and the HUD. We have done this in both
    previous projects, but we will do things a bit differently this time. We will
    explore the concept of sound spatialization and how SFML makes this otherwise
    complicated concept nice and easy. In addition, we will build an HUD class to
    encapsulate our code that draws information to the screen. We will complete the
    tasks in the following order: What spatialization is, how SFML handles spatialization,
    building a `SoundManager` class, deploying emitters, using the `SoundManager`
    class, and building and then using an HUD class.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第17章*](B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340)，*声音空间化和HUD*，添加了所有声音效果和HUD。我们已经在之前的两个项目中这样做过，但这次我们会有些不同。我们将探讨声音空间化的概念以及SFML如何使这个原本复杂的概念变得简单易行。此外，我们将构建一个HUD类来封装我们绘制到屏幕上的代码。我们将按以下顺序完成任务：空间化的定义，SFML如何处理空间化，构建一个`SoundManager`类，部署发射器，使用`SoundManager`类，以及构建和使用一个HUD类。'
- en: '[*Chapter 18*](B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356), *Particle Systems
    and Shaders*, examines what a particle system is and then proceeds to code one
    into our game. We will scratch the surface of the topic of OpenGL shaders and
    see how writing code in another language **OpenGL Shading Language** (**GLSL**),
    which can be run directly on the graphics card, can lead to smooth graphical effects
    that might otherwise be impossible. As usual, we will also use our new skills
    and knowledge to enhance the current project.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第18章*](B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356)，*粒子系统和着色器*，探讨了粒子系统是什么，然后继续将其编码到我们的游戏中。我们将浅析OpenGL着色器这一主题，并看看使用另一种语言**OpenGL着色语言**（**GLSL**），它可以直接在图形卡上运行，如何产生可能在其他情况下无法实现的平滑图形效果。像往常一样，我们也将利用我们新的技能和知识来增强当前项目。'
- en: '[*Chapter 19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372), *Game Programming
    Design Patterns – Starting the Space Invaders ++ Game*, introduces the final project.
    As you have come to expect by now, this project will take a significant step forward
    in learning new C++ techniques. The next four chapters will look at topics including
    smart pointers, C++ assertions, using a gamepad controller, debugging using Visual
    Studio, casting pointers of a base class to become pointers of a specific derived
    class, debugging, and taking a first look at design patterns. The author is surmising
    that if you are going to make deep, large-scale games in C++, then design patterns
    are going to be a big part of your learning agenda in the months and years ahead.
    In order to introduce this vital topic, I have chosen a relatively simple, but
    fun, game to serve as an example. Let''s find out a bit more about the Space Invaders
    ++ game, and then we can move on to the topic of design patterns and why we need
    them. In this hefty chapter, we will cover the following topics: Finding out about
    Space Invaders ++ and why it has been chosen for the final project, learning what
    design patterns are and why they matter to game developers, studying the design
    patterns in the Space Invaders ++ project that will be used over the next four
    chapters, getting started on the Space Invaders ++ project, and coding numerous
    classes to begin to flesh out the game.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第19章*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372)，*游戏编程设计模式 – 开始Space
    Invaders ++游戏*，介绍了最终项目。正如你现在所期望的，这个项目将学习新的C++技术迈出重要一步。接下来的四章将探讨包括智能指针、C++断言、使用游戏手柄控制器、使用Visual
    Studio进行调试、将基类指针转换为特定派生类指针、调试以及初步了解设计模式等主题。作者推测，如果你打算用C++制作深度、大规模的游戏，那么设计模式将是你在未来几个月和几年学习计划中的一个重要部分。为了介绍这个至关重要的主题，我选择了一个相对简单但有趣的游戏作为例子。让我们更深入地了解一下Space
    Invaders ++游戏，然后我们可以继续讨论设计模式及其必要性。在本章中，我们将涵盖以下主题：了解Space Invaders ++及其为何被选为最终项目，学习设计模式是什么以及为什么它们对游戏开发者很重要，研究在接下来的四章中将在Space
    Invaders ++项目中使用的各种设计模式，开始Space Invaders ++项目，并编写许多类以开始完善游戏。'
- en: '[*Chapter 20*](B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414), *Game Objects
    and Components*, covers all the coding related to the Entity-Component pattern
    we discussed at the beginning of the previous chapter. This means we will code
    the base component class that all the other components will be derived from. We
    will also put to good use our new knowledge of smart pointers so that we don''t
    have to concern ourselves with keeping track of the memory we allocate for these
    components. We will also code the `GameObject` class in this chapter. Here is
    a list of the sections in this chapter: Preparing to code the components, coding
    the component base class, coding the collider components, coding the graphics
    components, coding the update components, and coding the `GameObject` class.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第20章*](B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414)，*游戏对象和组件*，涵盖了我们在上一章开头讨论的实体-组件模式的所有编码。这意味着我们将编写所有其他组件都将从中派生的基本组件类。我们还将充分利用我们关于智能指针的新知识，这样我们就不必担心跟踪为这些组件分配的内存。我们还将在本章中编写`GameObject`类。以下是本章的章节列表：准备编写组件，编写组件基类，编写碰撞组件，编写图形组件，编写更新组件，以及编写`GameObject`类。'
- en: '[*Chapter 21*](B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432), *File I/O and
    the Game Object Factory*, explains how a `GameObject` gets into the `m_GameObjects`
    vector used in the game. We will see how we can describe individual objects and
    an entire level in a text file. We will write code to interpret the text and then
    load up values into a class that will be a blueprint for a game object. We will
    code a class called `LevelManager` that oversees the whole process, starting from
    the initial request to load a level sent from an `InputHandler` via the `ScreenManager`,
    right through to the factory pattern class that assembles a game object from components
    and delivers it to the `LevelManager` class neatly packed away in the `m_GameObjects`
    vector.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第21章*](B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432)，*文件I/O和游戏对象工厂*，解释了`GameObject`如何进入游戏中使用的`m_GameObjects`向量。我们将看到如何在一个文本文件中描述单个对象和整个关卡。我们将编写代码来解释文本，然后将值加载到一个将成为游戏对象蓝图
    的类中。我们将编写一个名为`LevelManager`的类，它将监督整个过程，从`InputHandler`通过`ScreenManager`发送的初始请求加载关卡开始，一直到使用工厂模式从组件组装游戏对象并将其整齐地打包到`m_GameObjects`向量中的`LevelManager`类。'
- en: '[*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445), *Using Game
    Objects and Building a Game*, constitutes the final stage of the Space Invaders
    ++ project. We will learn how to receive input from a gamepad using SFML to do
    all the hard work, and we will also code a class that will handle communication
    between the invaders and the `GameScreen` class, as well as the player and the
    `GameScreen` class. The class will allow the player and the invaders to spawn
    bullets, but the exact same technique could be used for any kind of communication
    that you need between different parts of your own game, so it is useful to know.
    The final part of the game (as usual) will be collision detection and the logic
    of the game itself. Once Space Invaders ++ is up and running, we will learn how
    to use the Visual Studio debugger, which will be invaluable when you are designing
    your own logic because it allows you to step through your code a line at a time
    and see the value of variables. It is also a useful tool for studying the flow
    of execution of the patterns we have assembled over the course of this project.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第22章*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445)，*使用游戏对象和构建游戏*，构成了Space
    Invaders ++项目的最后阶段。我们将学习如何使用SFML从游戏手柄接收输入来完成所有困难的工作，我们还将编写一个类来处理入侵者和`GameScreen`类之间的通信，以及玩家和`GameScreen`类之间的通信。这个类将允许玩家和入侵者发射子弹，但同样的技术也可以用于您游戏中不同部分之间所需的任何类型的通信，因此了解它是很有用的。游戏的最后部分（就像往常一样）将是碰撞检测和游戏本身的逻辑。一旦Space
    Invaders ++运行起来，我们将学习如何使用Visual Studio调试器，这在您设计自己的逻辑时将非常有价值，因为它允许您逐行执行代码并查看变量的值。它也是研究我们在整个项目过程中构建的模式执行流程的有用工具。'
- en: '[*Chapter 23*](B14278_23_Final_AG_ePub.xhtml#_idTextAnchor457), *Before You
    Go...*, brings our journey to an end. When you first opened this big doorstop
    of a book, the back page probably seemed like a long way off. But it wasn''t too
    tough, I hope? The point is that you are here now and hopefully, you have a good
    insight into how to build games using C++. It might surprise you to hear that
    even after all these hundreds of pages, we have only dipped our toes into C++.
    Even the topics we did cover could be covered in more depth and there are numerous,
    some quite significant, topics that we haven''t even mentioned. With this in mind,
    let''s take a look at what might be next.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第23章*](B14278_23_Final_AG_ePub.xhtml#_idTextAnchor457)，*在离开之前...*，结束了我们的旅程。当您第一次打开这本书时，可能觉得最后一页似乎还很遥远。但希望这并不太难？重点是您现在在这里，并且希望您对如何使用C++构建游戏有了深刻的理解。听到即使在这数百页之后，我们才刚刚涉足C++，可能会让您感到惊讶。甚至我们涵盖的主题也可以更深入地探讨，而且还有许多，其中一些相当重要，我们甚至没有提及。考虑到这一点，让我们看看接下来可能是什么。'
- en: To get the most out of this book
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了充分利用这本书
- en: 'The following requirements need to be satisfied:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 需要满足以下要求：
- en: Windows 7 Service Pack 1, Windows 8, or Windows 10
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 7 Service Pack 1、Windows 8或Windows 10
- en: 1.6 GHz or faster processor
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.6 GHz或更快的处理器
- en: 1 GB of RAM (for x86) or 2 GB of RAM (for x64)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 GB的RAM（x86架构）或2 GB的RAM（x64架构）
- en: 15 GB of available hard disk space
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 15 GB的可用硬盘空间
- en: 5400 RPM hard disk drive
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5400 RPM的硬盘驱动器
- en: DirectX 9-capable video card that runs at 1024 x 768 or higher display resolution
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有DirectX 9功能的显卡，支持1024 x 768或更高显示分辨率
- en: All the software used in this book is free. Obtaining and installing the software
    is covered step by step within the book. The book uses Visual Studio for Windows
    throughout, but experienced Linux and Mac users will probably have no trouble
    running the code and following the instructions using their favorite programming
    environment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的所有软件都是免费的。获取和安装软件的步骤在书中都有详细说明。本书在Windows上使用Visual Studio，但经验丰富的Linux和Mac用户在使用他们喜欢的编程环境运行代码和遵循说明时可能不会有任何困难。
- en: Download the example code files
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载示例代码文件
- en: You can download the example code files for this book from your account at [www.packt.com](http://www.packt.com).
    If you purchased this book elsewhere, you can visit [www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[www.packt.com](http://www.packt.com)的账户下载本书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'You can download the code files by following these steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤下载代码文件：
- en: Log in or register at [http://www.packt.com](http://www.packt.com).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[http://www.packt.com](http://www.packt.com)登录或注册。
- en: Select the **Support** tab.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**支持**选项卡。
- en: Click on **Code Downloads**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**代码下载**。
- en: Enter the name of the book in the **Search** box and follow the on screen instructions.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**搜索**框中输入书名，并遵循屏幕上的说明。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 文件下载后，请确保使用最新版本解压缩或提取文件夹：
- en: WinRAR / 7-Zip for Windows
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinRAR / 7-Zip for Windows
- en: Zipeg / iZip / UnRarX for Mac
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipeg / iZip / UnRarX for Mac
- en: 7-Zip / PeaZip for Linux
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7-Zip / PeaZip for Linux
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Beginning-Cpp-Game-Programming-Second-Edition](https://github.com/PacktPublishing/Beginning-Cpp-Game-Programming-Second-Edition).
    In case there's an update to the code, it will be updated on the existing GitHub
    repository.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码包也托管在GitHub上，网址为[https://github.com/PacktPublishing/Beginning-Cpp-Game-Programming-Second-Edition](https://github.com/PacktPublishing/Beginning-Cpp-Game-Programming-Second-Edition)。如果代码有更新，它将在现有的GitHub仓库中更新。
- en: We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有其他来自我们丰富图书和视频目录的代码包可供在[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)获取。查看它们吧！
- en: Download the color images
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载彩色图片
- en: 'We also provide a PDF file that has color images of the screenshots/diagrams
    used in this book. You can download it here: [https://static.packt-cdn.com/downloads/9781838648572_ColorImages.pdf](https://static.packt-cdn.com/downloads/9781838648572_ColorImages.pdf).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一份包含本书中使用的截图/图表的彩色图片的PDF文件。您可以从这里下载：[https://static.packt-cdn.com/downloads/9781838648572_ColorImages.pdf](https://static.packt-cdn.com/downloads/9781838648572_ColorImages.pdf)。
- en: Conventions used
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用的约定
- en: There are a number of text conventions used throughout this book.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用了多种文本约定。
- en: '`CodeInText`: Indicates code words in text, database table names, folder names,
    filenames, file extensions, pathnames, dummy URLs, user input, and Twitter handles.
    For example: "My main project directory is `D:\VS Projects\Timber`."'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`CodeInText`: 表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟URL、用户输入和Twitter昵称。例如：“我的主要项目目录是
    `D:\VS Projects\Timber`。”'
- en: 'A block of code is set as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块设置如下：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we wish to draw your attention to a particular part of a code block, the
    relevant lines or items are set in bold:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望引起你对代码块中特定部分的注意时，相关的行或项目将以粗体显示：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Bold**: Indicates a new term, an important word, or words that you see on
    screen. For example, words in menus or dialog boxes appear in the text like this.
    Here is an example: "Click on the **Create a new project** button."'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**粗体**: 表示新术语、重要单词或你在屏幕上看到的单词。例如，菜单或对话框中的单词在文本中显示如下。以下是一个例子：“点击**创建新项目**按钮。”'
- en: Important note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Warnings or important notes appear like this.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 警告或重要提示如下所示。
- en: Tip
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Tips and tricks appear like this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 小技巧和技巧如下所示。
- en: Get in touch
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系我们
- en: Feedback from our readers is always welcome.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们欢迎读者的反馈。
- en: '**General feedback**: If you have questions about any aspect of this book, mention
    the book title in the subject of your message and email us at [customercare@packtpub.com](mailto:customercare@packtpub.com).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**一般反馈**: 如果你对本书的任何方面有疑问，请在邮件主题中提及书名，并通过[customercare@packtpub.com](mailto:customercare@packtpub.com)给我们发送邮件。'
- en: '**Errata**: Although we have taken every care to ensure the accuracy of our
    content, mistakes do happen. If you have found a mistake in this book, we would
    be grateful if you would report this to us. Please visit [www.packtpub.com/support/errata](http://www.packtpub.com/support/errata),
    selecting your book, clicking on the Errata Submission Form link, and entering
    the details.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**勘误**: 尽管我们已经尽一切努力确保内容的准确性，但错误仍然可能发生。如果你在这本书中发现了错误，我们将不胜感激，如果你能向我们报告这个错误。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)，选择你的书，点击勘误提交表单链接，并输入详细信息。'
- en: '**Piracy**: If you come across any illegal copies of our works in any form
    on the internet, we would be grateful if you would provide us with the location
    address or website name. Please contact us at [copyright@packt.com](mailto:copyright@packt.com)
    with a link to the material.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**盗版**: 如果你在互联网上以任何形式遇到我们作品的非法副本，如果你能提供位置地址或网站名称，我们将不胜感激。请通过[版权@packt.com](mailto:copyright@packt.com)与我们联系，并提供材料的链接。'
- en: '**If you are interested in becoming an author**: If there is a topic that you
    have expertise in, and you are interested in either writing or contributing to
    a book, please visit [authors.packtpub.com](http://authors.packtpub.com).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您有兴趣成为作者**：如果您在某个领域有专业知识，并且您有兴趣撰写或为书籍做出贡献，请访问 [authors.packtpub.com](http://authors.packtpub.com)。'
- en: Reviews
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评论
- en: Please leave a review. Once you have read and used this book, why not leave
    a review on the site that you purchased it from? Potential readers can then see
    and use your unbiased opinion to make purchase decisions, we at Packt can understand
    what you think about our products, and our authors can see your feedback on their
    book. Thank you!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请留下评论。一旦您阅读并使用了这本书，为何不在您购买它的网站上留下评论呢？潜在读者可以查看并使用您的客观意见来做出购买决定，我们Packt可以了解您对我们产品的看法，而我们的作者也可以看到他们对书籍的反馈。谢谢！
- en: For more information about Packt, please visit [packt.com](http://packt.com).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Packt的更多信息，请访问 [packt.com](http://packt.com)。
