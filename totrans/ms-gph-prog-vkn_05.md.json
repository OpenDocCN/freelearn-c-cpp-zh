["```cpp\nvkEnumerateDeviceExtensionProperties( \n    vulkan_physical_device, nullptr, \n        &device_extension_count, extensions );\nfor ( size_t i = 0; i < device_extension_count; i++ ) {\n    if ( !strcmp( extensions[ i ].extensionName, \n         VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME ) ) {\n             timeline_semaphore_extension_present = true;\n             continue;\n         }\n}\n```", "```cpp\nVkPhysicalDeviceFeatures2 physical_features2 { \nVK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 };\nvoid* current_pnext = nullptr;\nVkPhysicalDeviceTimelineSemaphoreFeatures timeline_sempahore_features{ VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES  };\nif ( timeline_semaphore_extension_present ) {\n    timeline_sempahore_features.pNext = current_pnext;\n    current_pnext = &timeline_sempahore_features;\n}\nphysical_features2.pNext = current_pnext;\nvkGetPhysicalDeviceFeatures2( vulkan_physical_device, \n    &physical_features2 );\n```", "```cpp\nif ( timeline_semaphore_extension_present ) {\n    device_extensions.push( \n        VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME );\n}\n```", "```cpp\nVkDeviceCreateInfo device_create_info { \n    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO };\ndevice_create_info.enabledExtensionCount = \n    device_extensions.size;  \ndevice_create_info.ppEnabledExtensionNames = \n    device_extensions.data; \ndevice_create_info.pNext = &physical_features2;\nvkCreateDevice( vulkan_physical_device, \n    &device_create_info, vulkan_allocation_callbacks, \n        &vulkan_device );\n```", "```cpp\nVkSemaphoreCreateInfo semaphore_info{ \n    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO };\n```", "```cpp\nVkSemaphoreTypeCreateInfo semaphore_type_info{ \n    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO };\nsemaphore_type_info.semaphoreType = \n    VK_SEMAPHORE_TYPE_TIMELINE;\nsemaphore_info.pNext = &semaphore_type_info;\nFinally, we call the create function:\nvkCreateSemaphore( vulkan_device, &semaphore_info, \n    vulkan_allocation_callbacks, &vulkan_timeline_semaphore );\n```", "```cpp\nu64 timeline_value = …;\n\nVkSemaphoreWaitInfo semaphore_wait_info{ \n    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO };\nsemaphore_wait_info.semaphoreCount = 1;\nsemaphore_wait_info.pSemaphores = \n    &vulkan_timeline_semaphore;\nsemaphore_wait_info.pValues = &timeline_value;\n\nvkWaitSemaphores( vulkan_device, &semaphore_wait_info, \n                  timeout );\n```", "```cpp\nVkSemaphoreSubmitInfoKHR wait_semaphores[]{\n    { VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR, nullptr, \n       vulkan_image_acquired_semaphore, 0, \n       VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR,\n       0 },\n    { VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR, nullptr, \n       vulkan_timeline_semaphore, absolute_frame - ( \n       k_max_frames - 1 ), \n       VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR , 0 }\n};\n```", "```cpp\nVkSemaphoreSubmitInfoKHR signal_semaphores[]{\n    { VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR, nullptr, \n       *render_complete_semaphore, 0, \n       VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR, \n       0 },\n    { VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR, nullptr, \n       vulkan_timeline_semaphore, absolute_frame + 1, \n       VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR \n       , 0 }\n};\n```", "```cpp\nVkSubmitInfo2KHR submit_info{ \n    VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR };\nsubmit_info.waitSemaphoreInfoCount = 2;\nsubmit_info.pWaitSemaphoreInfos = wait_semaphores;\nsubmit_info.commandBufferInfoCount = \n    num_queued_command_buffers;\nsubmit_info.pCommandBufferInfos = command_buffer_info;\nsubmit_info.signalSemaphoreInfoCount = 2;\nsubmit_info.pSignalSemaphoreInfos = signal_semaphores;\n\nqueue_submit2( vulkan_main_queue, 1, &submit_info, \n    VK_NULL_HANDLE );\n```", "```cpp\nCommandBuffer* cb = gpu.get_command_buffer( 0, \ngpu.current_frame, true );\n```", "```cpp\nbool has_wait_semaphore = last_compute_semaphore_value > 0;\nVkSemaphoreSubmitInfoKHR wait_semaphores[]{\n    { VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR, nullptr, \n       vulkan_compute_semaphore, \n       last_compute_semaphore_value, \n       VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR, 0 }\n};\n\nlast_compute_semaphore_value++;\n\nVkSemaphoreSubmitInfoKHR signal_semaphores[]{\n    { VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR, nullptr, \n       vulkan_compute_semaphore, \n       last_compute_semaphore_value, \n       VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR, 0 },\n};\n```", "```cpp\nVkCommandBufferSubmitInfoKHR command_buffer_info{ \n    VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR };\ncommand_buffer_info.commandBuffer = \n    command_buffer->vk_command_buffer;\n\nVkSubmitInfo2KHR submit_info{ \n    VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR };\nsubmit_info.waitSemaphoreInfoCount = \n    has_wait_semaphore ? 1 : 0;\nsubmit_info.pWaitSemaphoreInfos = wait_semaphores;\nsubmit_info.commandBufferInfoCount = 1;\nsubmit_info.signalSemaphoreInfoCount = 1;\nsubmit_info.pSignalSemaphoreInfos = signal_semaphores;\n\nqueue_submit2( vulkan_compute_queue, 1, &submit_info, \n    VK_NULL_HANDLE );\n```", "```cpp\nbool wait_for_compute_semaphore = ( \n    last_compute_semaphore_value > 0 ) && has_async_work; \nVkSemaphoreSubmitInfoKHR wait_semaphores[]{\n    { VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR, nullptr, \n       vulkan_image_acquired_semaphore, 0, \n       VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR, \n       0 },\n    { VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR, nullptr, \n       vulkan_compute_semaphore, \n       last_compute_semaphore_value, \n       VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR, \n       0 },\n    { VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR, nullptr, \n       vulkan_graphics_semaphore, \n       absolute_frame - ( k_max_frames - 1 ), \n       VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR , 0 },\n};\n```", "```cpp\nlayout (local_size_x = 8, local_size_y = 8, \nlocal_size_z = 1) in;\n```", "```cpp\ngpu_commands->dispatch( ceilu32( renderer->\n    gpu->swapchain_width * 1.f / 8 ), \n      ceilu32( renderer->gpu->swapchain_height * 1.f / 8 ), \n      1 );\n```", "```cpp\nshader_invocation_count = total_pixels / 64\n```", "```cpp\nglobal_group_size_x = width / 8\nglobal_group_size_y = height / 8\n```", "```cpp\nlocal_thread_group_count = 64\nshader_invocation_count = global_group_size_x * \n    global_group_size_y\ntotal_pixels =  shader_invocation_count * \n    local_thread_group_count\n```", "```cpp\nivec3 pos = ivec3( gl_GlobalInvocationID.xyz );\n```", "```cpp\n// code\nMemoryBarrier()\n// all threads have run the code before the barrier\n```", "```cpp\nfor each physics mesh in the scene:\n    for each vertex in the mesh:\n        compute the force applied to the vertex\n    // We need two loops because each vertex references \n       other vertices position\n    // First we need to compute the force applied to each \n       vertex, \n    // and only after update each vertex position\n       for each vertex in the mesh:\n    update the vertex position and store its velocity\n\n    update the mesh normals and tangents\n    copy the vertices to the GPU\n```", "```cpp\nBufferCreation creation{ };\nsizet buffer_size = positions.size * sizeof( vec3s );\ncreation.set( flags, ResourceUsageType::Immutable, \n    buffer_size ).set_data( positions.data )\n        .set_name( nullptr ).set_persistent( true );\n\nBufferResource* cpu_buffer = renderer->\n    create_buffer( creation );\ncpu_buffers.push( *cpu_buffer );\n```", "```cpp\ncreation.reset().set( flags, ResourceUsageType::Immutable, \n    buffer_size ).set_device_only( true )\n        .set_name( \"position_attribute_buffer\" );\n\nBufferResource* gpu_buffer = renderer->\n    create_buffer( creation );\ngpu_buffers.push( *gpu_buffer );\n```", "```cpp\nasync_loader->request_buffer_copy( cpu_buffer->handle, \n                                   gpu_buffer->handle );\n```", "```cpp\nDescriptorSetLayoutHandle physics_layout = renderer->\n    gpu->get_descriptor_set_layout\n        ( cloth_technique->passes[ 0 ].pipeline, \n            k_material_descriptor_set_index );\nds_creation.reset().buffer( physics_cb, 0 )\n    .buffer( mesh.physics_mesh->gpu_buffer, 1 )\n    .buffer( mesh.position_buffer, 2 )\n    .buffer( mesh.normal_buffer, 3 )\n    .buffer( mesh.index_buffer, 4 )\n    .set_layout( physics_layout );\n\nmesh.physics_mesh->descriptor_set = renderer->\n    gpu->create_descriptor_set( ds_creation );\n```", "```cpp\nlayout ( std140, set = MATERIAL_SET, binding = 0 ) uniform \n    PhysicsData {\n    ...\n};\n\nlayout ( set = MATERIAL_SET, binding = 1 ) buffer \n    PhysicsMesh {\n        uint index_count;\n        uint vertex_count;\n\n    PhysicsVertex physics_vertices[];\n};\n\nlayout ( set = MATERIAL_SET, binding = 2 ) buffer \n    PositionData {\n        float positions[];\n};\n\nlayout ( set = MATERIAL_SET, binding = 3 ) buffer \n    NormalData {\n        float normals[];\n};\n\nlayout ( set = MATERIAL_SET, binding = 4 ) readonly buffer \n    IndexData {\n        uint indices[];\n};\n```", "```cpp\nstruct MeshVertex {\n    vec3 position;\n    vec3 normal;\n    vec3 tangent;\n};\n\nlayout ( set = MATERIAL_SET, binding = 2 ) buffer MeshData {\n    MeshVertex mesh_vertices[];\n};\n```", "```cpp\nvec3 spring_force = vec3( 0, 0, 0 );\n\nfor ( uint j = 0; j < physics_vertices[ v ]\n    .joint_count; ++j ) {\n        pull_direction = ...;\n        spring_force += pull_direction;\n}\n\nvec3 viscous_damping = physics_vertices[ v ]\n    .velocity * -spring_damping;\n\nvec3 viscous_velocity = ...;\n\nvec3 force = g * m;\nforce -= spring_force;\nforce += viscous_damping;\nforce += viscous_velocity;\n\nphysics_vertices[ v ].force = force;\n```", "```cpp\nvec3 previous_position = physics_vertices[ v ]\n    .previous_position;\nvec3 current_position = physics_vertices[ v ].position;\n\nvec3 new_position = ...;\n\nphysics_vertices[ v ].position = new_position;\nphysics_vertices[ v ].previous_position = current_position;\n\nphysics_vertices[ v ].velocity = new_position - current_position;\n```", "```cpp\nfor ( uint v = 0; v < vertex_count; ++v ) {\n     positions[ v * 3 + 0 ] = physics_vertices[ v ]\n         .position.x;\n     positions[ v * 3 + 1 ] = physics_vertices[ v ]\n         .position.y;\n     positions[ v * 3 + 2 ] = physics_vertices[ v ]\n         .position.z;\n}\n```"]