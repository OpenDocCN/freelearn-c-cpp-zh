- en: Running Parallel Execution Using Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed template metaprogramming that will make
    a code in compile-time execution. It will also improve the flow control of our
    code since we can refactor the flow using the template. Now, in this chapter,
    we will talk about concurrency in C++, where we have to control the flow again
    when we run two or more processes simultaneously. In this chapter, we will discuss
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running single as well as multiple threads in C++ programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing the thread to avoid a deadlock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **handle** resource in Windows to create a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many programming languages have provided support for concurrency today. Instead
    of sequentially, the computation of the code is executed during overlapping time
    periods in concurrent programming. It will make our program responsive since the
    code doesn't need to wait until all computation is finished. Let's suppose we
    want to develop a program that can play a video and download a huge video file
    at the same time. Without the concurrency technique, we have to wait for the video
    to be downloaded successfully before we can play another video file. By using
    this technique, we can split these two tasks, playing and downloading a video,
    then run them together concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Before C++11 was announced, the C++ programmer depended on `Boost::thread` to
    create a concurrent program using the multithreading technique. In multithreading,
    we split up the process into the smallest sequence and run these small processes
    concurrently. Now, in the C++11 library, we get the `thread` class to address
    our need for concurrency using the multithreading technique.
  prefs: []
  type: TYPE_NORMAL
- en: Processing a single threading code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the `thread` class, we just need to create an instance of `std::thread`
    and pass the function name as the argument. We then call `std::join()` to pause
    the process until the selected thread finishes its process. Let''s take a look
    at the following `singlethread.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we have a function named `threadProc()`,
    and we pass it into the `thread1` initialization in the `main()` function. After
    initialization, we call the `join()` method to execute the `thread1` object. The
    output that we will see on the console should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86d5d8c0-8176-4e09-8737-4e31bd48ba43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have successfully run a thread in our code. Now, let''s add a piece of code
    in the `main()` function that will iterate a line of code. We will run them together
    concurrently. The code for `singlethread2.cpp` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we add a `for` loop to iterate some code
    and to run it concurrently with `thread1`. To make sense of it, we add a `for`
    loop in the `threadProc()` function as well. Let''s take a look at the following
    screenshot to figure out what output we will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8aa03435-bafd-4bef-a608-028751070653.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the `threadProc()` function and the code in the `main()` function
    is run together concurrently. Some of you may get a different result, but it's
    okay since the result cannot be predicted because it depends on the device itself.
    However, for now, we have been able to run two processes concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: I ran the preceding code multiple times to get the output we see in the preceding
    screenshot. You might see different order in between the `threadProc()` and `main()`
    function or get a messy output since the flow of the thread is unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: Processing a multithreading code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the multithread technique, we run two or more threads concurrently. Let''s
    suppose we are running five threads simultaneously. We can use the following `multithread.cpp`
    code that will store these five threads in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After we initialize these five threads based on the preceding code, we will
    run the `join()` method for all threads to execute them. By using the `join()`
    method, the program will wait for all processes in the calling threads to be finished,
    then continue the next process if any. The result we see in the console is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/808eb931-b775-4816-b4c6-e756f8d99112.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we see that all five threads have been successfully
    executed. We can also initialize the thread using the Lambda expression. The following
    `lambdathread.cpp` code is refactored from the preceding code which uses Lambda
    instead of creating a separated function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no significant change if we see the `lambdathread.cpp` code comparing
    with the `multithread.cpp` code. However, since the function will only be called
    once, it''s better to use Lambda so it is easier to maintain it. The output we
    will see on the console is like the following screenshot, not much different compared
    to the `multithread.cpp` code output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/533c3423-6bf0-450e-99a6-6988f42d3d61.png)'
  prefs: []
  type: TYPE_IMG
- en: Although we retrieve the same output when running `lambdathread.cpp` comparing
    with the `multithread.cpp` code, we have a clear code when we initialize the thread
    using the Lambda expression. We don't need to create another method to be passed
    to `Thread`, for instance, `threadProc()`, since this method is actually used
    only once.
  prefs: []
  type: TYPE_NORMAL
- en: Again, note that the result you see on your screen might be different from the
    screenshot I gave.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing the threads using mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of now, we have successfully executed a multithreading code. However, a problem
    will occur if we consume a shared object and manipulate it inside the thread.
    It is called **synchronization**. In this section, we will try to avoid this problem
    by applying a `mutex` technique.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding synchronization issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier, in this section, we have to ensure that the shared
    object we run in the thread gives the correct value when it is executing. Let''s
    suppose we have a global variable named `counter` and we plan to increase its
    value in all the five threads we have. Each thread will execute `10000` times
    increment iteration, so we expect to get `50000` as a result for all five threads.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the following screenshot we may get on the console
    when we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0d31bea-b6e2-49db-acff-172784871ce3.png)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, based on the preceding screenshot, we don't get what we expect.
    This happens because an incrementation process is not an atomic operation since
    the atomic operation will guarantee the isolation of the concurrent process.
  prefs: []
  type: TYPE_NORMAL
- en: If you get a different output, don't worry, we are still on the right track
    as this program demonstrates synchronization issues, as you will see next.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we trace the output deeper, we will see that there are two threads that
    execute exactly the same value for the `counter` variable, as we can see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f7a5eff-9464-4f99-b4e6-3bb1f2553f25.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the thread with ID `2504` and `5524` access the counter variable
    when its value is `44143`. That's why we retrieve an unexpected result when we
    run the preceding code. Now we need to make the increment operation to become
    an atomic operation that will be executed without any other processes being able
    to read or change the state that is read or changed during the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we can use the `mutex` class to make our counter variable
    `thread-safe`. It means that before the thread accesses the counter variable,
    it has to ensure that the variable is not accessed by others threads. We can use
    the `lock()` and `unlock()` methods in the `mutex` class to lock and unlock the
    targeted variable. Let''s take a look at the following `mutex.cpp` code to demonstrate
    `mutex` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, before the code increments the `counter`
    variable, it calls the `lock()` method. And after that, it calls the `unlock()`
    method to notify the other threads that the `counter` variable is free to manipulate
    now. If we run the preceding code, we should see the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e60f03b-94fb-43c7-aa0e-2e9ede5261b2.png)'
  prefs: []
  type: TYPE_IMG
- en: By using the `mutex` class, now we retrieve the result we expect, as we can
    see in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Unlocking the variable automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now know how to lock the variable to ensure that no two threads working
    on the same value simultaneously retrieve the correct value from it. However,
    the problem will occur if an exception is thrown before the thread calls the `unlock()`
    method. The program will be completely locked if the state of the variable remains
    locked. To solve this problem, we can use `lock_guard<mutex>` to lock the variable
    and to ensure that it will be unlocked at the end of the scope no matter what
    happens. The following piece of code is refactored from the preceding code by
    adding the `lock_guard<mutex>` functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding `automutex.cpp` code, it calls `lock_guard
    <mutex> guard(mtx)` before it increments the `counter` variable. If we run the
    code, we will get exactly the same output with the `mutex.cpp` code. However,
    now we have a program that won't be locked unpredictably.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding deadlock using recursive mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we used `lock_guard` to ensure that the variable is
    not accessed by more than one thread. However, we will still face a problem if
    more than one `lock_guard` obtains the lock. In the following piece of code, we
    have two functions that will call `lock_guard`--`Multiplexer()` and `Divisor()`.
    Besides them, we also have a function that will call these two functions--`RunAll()`
    that will call `lock_guard` first before calling the two functions. The code should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will successfully compile the following piece of code. However, if we run
    the preceding code, an error will occur since the program won''t exit due to the
    **deadlock**. It is because the same mutex cannot be acquired by multiple threads
    twice. When the `RunAll()` function is invoked, it acquires the `lock` object.
    The `Multiplexer()` function inside the `RunAll()` function wants to acquire `lock`
    as well. However, `lock` has been locked by the `RunAll()` function. To solve
    this problem, we can replace `lock_guard<mutex>` with `lock_guard<recursive_mutex>`,
    as you can see in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can successfully compile and run the preceding code. We can use the
    `lock_guard<recursive_mutex>` class that will allow mutex to be locked more than
    once without getting to the deadlock. The following screenshot will be seen on
    the console when we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7faafdd2-15bc-4f57-82ca-d50df7296692.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we know we need to use one recursive `mutex` if we want to call functions
    that lock the same `mutex` recursively.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the thread processing in a Windows operating system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move to a specific operating system that is widely used by many user computers,
    that is Windows. Our code must need to be run on some commercial platform from
    a leading OS vendor, such as Microsoft. So, we will now run the thread in Windows
    OS. In this OS, the thread is a kernel resource, which means it is an object that
    is created and owned by the OS kernel and lives in the kernel. The kernel itself
    is a core program that has complete control over everything in the system. In
    this section, we will develop a thread in Windows OS so our program can work well
    in this OS.
  prefs: []
  type: TYPE_NORMAL
- en: Working with handle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Windows operating system, handle is an abstract reference value to a
    resource. In this discussion, we will use the abstract reference to hold the thread.
    Let''s suppose we have a `threadProc()` function that will be called inside a
    thread which is held in the `hnd` variable. The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, we use the `CreateThread()` function provided
    by the `windows.h` header to generate a thread. For now, we just pass the `nullptr`
    value as the default parameter, except `threadProc` as a function that we will
    call from the thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we initialize the handle of the thread, we can ensure that the `hnd`
    variable contains the handle of the thread, then invokes the `WaitForSingleObject()`
    function. It is similar to the `join()` method we used in the preceding section
    that will run the thread and wait until the thread is finished. Since the thread
    handle is a resource we use, don''t forget to release it by using the `CloseHandle()`
    function. If we run the preceding code, we will see the following output on the
    console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b74afe83-9bdb-431b-b75f-7a7da30e77ba.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we have successfully run the thread since we've got the expected
    process from the `threadProc()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to a unique handle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, to ease our programming process, we will create a class named `NullHandle`
    that will automatically release the resource each time we no longer need it. It
    will be constructed from the `UniqueHandle` class, which we will develop as well.
    These classes can be found in the `uniquehandle.h` file. The implementation of
    `UniqueHandle` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we have a complete implementation of the `UniqueHandle` class
    that can be instanced and will automatically close the handle from its destructor.
    To use `NullHandle` object, we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `NullHandleCharacteristics` struct is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s refactor our preceding `threadhandle.cpp` code. We will replace
    `HANDLE` with `NullHandle`, so it will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create a new function named `WaitOneThread()` to call the thread
    itself and wait until it finishes. The implementation should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `WaitOneThread()` function, we can know whether or not the thread
    has been run. The `WinException` struct can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the following piece of code to the `main()` function after
    we initialize the `hnd` HANDLE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding code, we call the `WaitOneThread()` function
    and pass `0` as the `ms` parameter to find out the status of the `WaitForSingleObject()`
    function call. We can pass the `INFINITE` value to it to call the thread and wait
    for it until it finishes. The following is the `threaduniquehandle.cpp` code that
    is refactored from the `threadhandle.cpp` code and has consumed the `UniqueHandle`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the output we should see on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70059c6e-2e41-4913-86c8-d05ada792004.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, we don't have the `Before running
    thread` line on it. It's because we will get the `WAIT_TIMEOUT` output each time
    the thread is not called. And still, we have successfully executed the code in
    the `threadProc()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After playing with thread in Windows, let''s try another concurrency type--`Event`.
    It is an action that can be triggered by the system. To know further about it,
    let''s take a look at the following code snippet where we create a new class named
    `Event` that implements `UniqueHandle` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding `Event` class implementation, we have the `Set()`,
    `Clear()`, and `Wait()` methods to set an event, clear an event, and wait for
    the event to complete respectively. We have two event types, which are automatic
    reset and manual reset, which are declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create content in the `main()` function. We will instance the
    `Event` class first, then we will check the event signaling. If it''s not signaled,
    we will set the event. On the contrary, we will clear the event. The code will
    be the following `event.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, here is what the code does:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates the instance of the `Event` class in the `main()` function and manually
    resets the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It invokes the `CheckEventSignaling()` function to find out the status of the
    event by passing the `Wait()` function to the `CheckEventSignaling()` function,
    which in turn calls the `WaitForSingleObject()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It invokes the `Set()` and `Reset()` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now run the preceding `event.cpp` code. You will see the following output on
    the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/72bfd423-0b5b-4915-9711-490b1b27b46f.png)'
  prefs: []
  type: TYPE_IMG
- en: If we take a look at the preceding screenshot, at first, the initialization
    of the `Event` class is not signaled. We then set the event, and it is now signaled
    as the status from the `CheckEventSignaling()` method. Here, we can say that we
    can check the status of the signaled event by calling the `WaitForSingleObject()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Calling an event from a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s use thread to call the `Event` class. However, before that, we
    have to be able to wrap more than one thread, call them together, and wait until
    their processes are finished. The following code block is a `Wrap()` function
    that will pack the threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will call the preceding `Wrap()` function when we join all the threads.
    So, we will need another function named `WaitAllThreads()`, as we can see in the
    following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create our full code that will run the two threads using the following
    `eventthread.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, if we run the preceding `eventthread.cpp` code, we will see the following
    output on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a60a3d6-c786-4791-b43d-797e4d01e1e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have successfully triggered an `Event`, so it can be set to become signaled
    and can be cleared to become unsignaled in the `event.cpp` code. We have also
    successfully wrapped more than one thread, then called them together in the `eventthread.cpp`
    code. Now, let''s concatenate these two codes so we can access the event from
    the thread. The code should be like the following `eventthread2.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `eventthread2.cpp` code, we try to trigger the event using
    the thread. We initialize two `NullHandle` object threads at first. Then, we set
    the event and call the `Sleep()` function to make the event active. The `WaitAllThreads()`
    function then invokes the `threadProc()` function and runs each thread. This will
    trigger the event by calling the `ev.Wait()` function. The threads will be run
    then. The following screenshot is the output we will see on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94bc604a-76c4-49b3-9325-383479e5379f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding code is the event that we set manually to reset the event. This
    means that we have to state when we clear the event. Now, we pass `AutoReset`
    to the event instance. We will also modify the `threadProc()` function a little
    bit. The following piece of code is `eventthread3.cpp` that we are talking about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we move the `Set()` method of the event
    from the `main()` function to the `threadProc()` function. Now, every time the
    `threadProc()` function is invoked, the event is set automatically. The following
    screenshot is the output we should see on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3e50f9d-5157-4271-a317-35d79fff8152.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned a concept of C++ concurrency in this chapter. We now can process
    a single thread as well as multithreads. We can also synchronize the multithreads
    so it can run smoothly; therefore, we can avoid synchronization issues and deadlock.
    Lastly, we can consume the handle resource in Windows to create a thread and trigger
    the event using that event.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will apply all we have learned in the previous chapters
    to produce an application in a functional way. It will also explain how to test
    an application that is built using the C++ language.
  prefs: []
  type: TYPE_NORMAL
