["```cpp\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \n      Dodgeball, meta = (AllowPrivateAccess = \"true\"))\n    class USphereComponent* SphereComponent;\n    ```", "```cpp\n    #include \"Components/SphereComponent.h\"\n    ```", "```cpp\n    SphereComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"Sphere \n      Collision\"));\n    ```", "```cpp\n    SphereComponent->SetSphereRadius(35.f);\n    ```", "```cpp\n    SphereComponent->SetCollisionProfileName(FName(\"Dodgeball\"));\n    ```", "```cpp\n    SphereComponent->SetSimulatePhysics(true);\n    ```", "```cpp\n    //Simulation generates Hit events\n    SphereComponent->SetNotifyRigidBodyCollision(true);\n    ```", "```cpp\n    UFUNCTION()\n    void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, \n      UPrimitiveComponent* OtherComp, FVector \n      NormalImpulse, const \n      FHitResult& Hit);\n    ```", "```cpp\n    void ADodgeballProjectile::OnHit(UPrimitiveComponent * \n      HitComp, AActor * OtherActor, UPrimitiveComponent * \n      OtherComp, FVector NormalImpulse, const FHitResult & \n      Hit)\n    {\n      if (Cast<ADodgeballCharacter>(OtherActor) != \n      nullptr)\n      {\n        Destroy();\n      }\n    }\n    ```", "```cpp\n#include \"DodgeballCharacter.h\"\n```", "```cpp\n    // Listen to the OnComponentHit event by binding it to \n    // our function\n    SphereComponent->OnComponentHit.AddDynamic(this, \n      &ADodgeballProjectile::OnHit);\n    ```", "```cpp\n    // Set this Sphere Component as the root component,\n    // otherwise collision won't behave properly\n    RootComponent = SphereComponent;\n    ```", "```cpp\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \n      Dodgeball, meta = (AllowPrivateAccess = \"true\"))\n    class UProjectileMovementComponent* ProjectileMovement;\n    ```", "```cpp\n    #include \"GameFramework/ProjectileMovementComponent.h\"\n    ```", "```cpp\n    ProjectileMovement = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT(\"Pro\n      jectile Movement\"));\n    ```", "```cpp\n    ProjectileMovement->InitialSpeed = 1500.f;\n    ```", "```cpp\nGetWorld()->SpawnActor<NameOfC++Class>(ClassReference, \n  SpawnLocation, SpawnRotation);\n```", "```cpp\n    // Change the rotation of the character to face the \n    // given actor\n    // Returns whether the given actor can be seen\n    bool LookAtActor(AActor* TargetActor);\n    ```", "```cpp\n    bool AEnemyCharacter::LookAtActor(AActor * TargetActor)\n    {\n      if (TargetActor == nullptr) return false;\n      if (CanSeeActor(TargetActor))\n      {\n        FVector Start = GetActorLocation();\n        FVector End = TargetActor->GetActorLocation();\n        // Calculate the necessary rotation for the Start \n        // point to face the End point\n        FRotator LookAtRotation = \n        UKismetMathLibrary::FindLookAtRotation(\n        Start, End);\n        //Set the enemy's rotation to that rotation\n        SetActorRotation(LookAtRotation);\n        return true;\n      }\n      return false;\n    }\n    ```", "```cpp\n    //Whether the enemy can see the player this frame\n    bool bCanSeePlayer = false;\n    //Whether the enemy could see the player last frame\n    bool bPreviousCanSeePlayer = false;\n    ```", "```cpp\n    // Look at the player character every frame\n    bCanSeePlayer = LookAtActor(PlayerCharacter);\n    ```", "```cpp\n    bPreviousCanSeePlayer = bCanSeePlayer;\n    ```", "```cpp\n    bCanSeePlayer = LookAtActor(PlayerCharacter);\n    if (bCanSeePlayer != bPreviousCanSeePlayer)\n    {\n    }\n    bPreviousCanSeePlayer = bCanSeePlayer;\n    ```", "```cpp\n    if (bCanSeePlayer != bPreviousCanSeePlayer)\n    {\n      if (bCanSeePlayer)\n      {\n        //Start throwing dodgeballs\n      }\n      else\n      {\n        //Stop throwing dodgeballs\n      }\n    }\n    ```", "```cpp\n        FTimerHandle ThrowTimerHandle;\n        ```", "```cpp\n        float ThrowingInterval = 2.f;\n        ```", "```cpp\n        float ThrowingDelay = 0.5f;\n        ```", "```cpp\n        void ThrowDodgeball();\n        ```", "```cpp\n#include \"TimerManager.h\"\n```", "```cpp\n    GetWorldTimerManager()\n    ```", "```cpp\nif (bCanSeePlayer)\n{\n  //Start throwing dodgeballs\n  GetWorldTimerManager().SetTimer(ThrowTimerHandle,\n  this,\n  &AEnemyCharacter::ThrowDodgeball,ThrowingInterval,\n  true,\n  ThrowingDelay);\n}\n```", "```cpp\n    else\n    {\n      //Stop throwing dodgeballs\n      GetWorldTimerManager().ClearTimer(ThrowTimerHandle);\n    }\n    ```", "```cpp\n    //The class used to spawn a dodgeball object\n    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = \n      Dodgeball)\n    TSubclassOf<class ADodgeballProjectile> DodgeballClass;\n    ```", "```cpp\n    #include \"DodgeballProjectile.h\"\n    ```", "```cpp\n    void AEnemyCharacter::ThrowDodgeball()\n    {\n      if (DodgeballClass == nullptr)\n      {\n        return;\n      }\n    }\n    ```", "```cpp\n    FVector ForwardVector = GetActorForwardVector();\n    float SpawnDistance = 40.f;\n    FVector SpawnLocation = GetActorLocation() + (ForwardVector * \n      SpawnDistance);\n    //Spawn new dodgeball\n    GetWorld()->SpawnActor<ADodgeballProjectile>(DodgeballClass, \n      SpawnLocation, GetActorRotation());\n    ```", "```cpp\n    void ADodgeballProjectile::BeginPlay()\n    {\n      Super::BeginPlay();\n\n      SetLifeSpan(5.f);\n    }\n    ```", "```cpp\n        private:\n        UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Wall, \n          meta = (AllowPrivateAccess = \"true\"))\n        class USceneComponent* RootScene;\n        ```", "```cpp\n        AWall::AWall()\n        {\n          // Set this actor to call Tick() every frame.  You \n          // can turn this off to improve performance if you \n          // don't need it.\n          PrimaryActorTick.bCanEverTick = true;\n          RootScene = CreateDefaultSubobject<USceneComponent>(\n          TEXT(\"Root\"));\n          RootComponent = RootScene;\n        }\n        ```", "```cpp\n        private:\n        UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \n          VictoryBox, meta = (AllowPrivateAccess = \"true\"))\n        class USceneComponent* RootScene;\n        ```", "```cpp\n        AVictoryBox::AVictoryBox()\n        {\n          // Set this actor to call Tick() every frame.  You \n          // can turn this off to improve performance if you \n          // don't need it.\n          PrimaryActorTick.bCanEverTick = true;\n          RootScene = \n          CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n          RootComponent = RootScene;\n        }\n        ```", "```cpp\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \n      VictoryBox, meta = (AllowPrivateAccess = \"true\"))\n    class UBoxComponent* CollisionBox;\n    ```", "```cpp\n    #include \"Components/BoxComponent.h\"\n    ```", "```cpp\n    RootScene = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n    RootComponent = RootScene;\n    CollisionBox = \n      CreateDefaultSubobject<UBoxComponent>(\n      TEXT(\"Collision Box\"));\n    ```", "```cpp\n    CollisionBox->SetupAttachment(RootComponent);\n    ```", "```cpp\n    CollisionBox->SetBoxExtent(FVector(60.0f, 60.0f, 60.0f));\n    ```", "```cpp\n    CollisionBox->SetRelativeLocation(FVector(0.0f, 0.0f, \n      120.0f));\n    ```", "```cpp\n    UFUNCTION()\n    void OnBeginOverlap(UPrimitiveComponent* OverlappedComp, \n      AActor* OtherActor, UPrimitiveComponent* OtherComp, \n      int32 \n      OtherBodyIndex, bool bFromSweep, const FHitResult& \n      SweepResult);\n    ```", "```cpp\n    CollisionBox->OnComponentBeginOverlap.AddDynamic(this, \n      &AVictoryBox::OnBeginOverlap);\n    ```", "```cpp\n    #include \"DodgeballCharacter.h\" \n    void AVictoryBox::OnBeginOverlap(UPrimitiveComponent * \n      OverlappedComp, AActor * OtherActor, \n      UPrimitiveComponent * \n      OtherComp, int32 OtherBodyIndex, bool bFromSweep, \n      const \n      FHitResult & SweepResult)\n    {\n      if (Cast<ADodgeballCharacter>(OtherActor))\n      {\n      }\n    }\n    ```", "```cpp\n    #include \"Kismet/KismetSystemLibrary.h\"\n    ```", "```cpp\n    UKismetSystemLibrary::QuitGame(GetWorld(),\n      nullptr,\n      EQuitPreference::Quit,\n      true);\n    ```", "```cpp\n    FORCEINLINE class UProjectileMovementComponent* \n      GetProjectileMovementComponent() const\n    {\n      return ProjectileMovement;\n    }\n    ```"]