["```cpp\n$ ninja opt\n```", "```cpp\nPreservedAnalyses\nSimpleMulOpt::run(Function &F, FunctionAnalysisManager &FAM) {\n  for (auto &I : instructions(F)) {\n    if (auto *BinOp = dyn_cast<BinaryOperator>(&I) &&\n        BinOp->getOpcode() == Instruction::Mul) {\n      auto *LHS = BinOp->getOperand(0),\n           *RHS = BinOp->getOperand(1);\n      // `BinOp` is a multiplication, `LHS` and `RHS` are its\n      // operands, now trying to optimize this instruction…\n      …\n    }\n  }\n  …\n}\n```", "```cpp\n// (extracted from the previous snippet)\n…\nauto *LHS = BinOp->getOperand(0),\n     *RHS = BinOp->getOperand(1);\nerrs() << \"Found a multiplication with operands \";\nLHS->printAsOperand(errs());\nerrs() << \" and \";\nRHS->printAsOperand(errs());\n…\n```", "```cpp\n#include \"llvm/Support/Debug.h\"\n#define DEBUG_TYPE \"simple-mul-opt\"\n…\nauto *LHS = BinOp->getOperand(0),\n     *RHS = BinOp->getOperand(1);\nLLVM_DEBUG(dbgs() << \"Found a multiplication with operands \");\nLLVM_DEBUG(LHS->printAsOperand(dbgs()));\nLLVM_DEBUG(dbgs() << \" and \");\nLLVM_DEBUG(RHS->printAsOperand(dbgs()));\n…\n```", "```cpp\n$ opt -O3 -debug -load-pass-plugin=… …\n```", "```cpp\n$ opt -O3 -debug-only=simple-mul-opt -load-pass-plugin=… …\n```", "```cpp\n$ opt -O3 -debug-only=sroa,simple-mul-opt -load-pass-plugin=… …\n```", "```cpp\n…\n#define DEBUG_TYPE \"simple-mul-opt\"\nauto *LHS = BinOp->getOperand(0),\n     *RHS = BinOp->getOperand(1);\nLLVM_DEBUG(dbgs() << \"Found a multiplication instruction\");\nDEBUG_WITH_TYPE(\"simple-mul-opt-lhs\",\n               LHS->printAsOperand(dbgs() << \"LHS operand: \"));\nDEBUG_WITH_TYPE(\"simple-mul-opt-rhs\",\n               RHS->printAsOperand(dbgs() << \"RHS operand: \"));\n…\n```", "```cpp\n#define DEBUG_TYPE \"simple-mul-opt\"\nPreservedAnalyses\nSimpleMulOpt::run(Function &F, FunctionAnalysisManager &FAM) {\n  unsigned NumMul = 0;\n  for (auto &I : instructions(F)) {\n    if (auto *BinOp = dyn_cast<BinaryOperator>(&I) &&\n        BinOp->getOpcode() == Instruction::Mul) {\n      ++NumMul;\n      …\n    }\n  }\n  LLVM_DEBUG(dbgs() << \"Number of multiplication: \" << NumMul);\n  …\n}\n```", "```cpp\n#include \"llvm/ADT/Statistic.h\"\n#define DEBUG_TYPE \"simple-mul-opt\"\nSTATISTIC(NumMul, \"Number of multiplications processed\");\nPreservedAnalyses\nSimpleMulOpt::run(Function &F, FunctionAnalysisManager &FAM) {\n  for (auto &I : instructions(F)) {\n    if (auto *BinOp = dyn_cast<BinaryOperator>(&I) &&\n        BinOp->getOpcode() == Instruction::Mul) {\n      ++NumMul;\n      …\n    }\n  }\n  …\n}\n```", "```cpp\n$ opt -stats –load-pass-plugin=… …\n===-------------------------------===\n      … Statistics Collected …\n===-------------------------------===\n87 simple-mul-opt - Number of multiplications processed\n$\n```", "```cpp\n$ opt -stats –load-pass-plugin=… --passes=\"sroa,simple-mult-opt\" …\n===-------------------------------===\n      … Statistics Collected …\n===-------------------------------===\n94  simple-mul-opt - Number of multiplications processed\n87  simple-mul-opt - Number of none-power-of-two constant operands\n100 sroa           - Number of alloca partition uses rewritten\n34  sroa           - Number of instructions deleted\n…\n$\n```", "```cpp\n$ opt -stats -stats-json –load-pass-plugin=… …\n{\n        \"simple-mul-opt.NumMul\": 87\n}\n$\n```", "```cpp\n$ opt -stats -stats-json -info-output-file=my_stats.json …\n$ cat my_stats.json\n{\n        \"simple-mul-opt.NumMul\": 87\n}\n$\n```", "```cpp\nint foo(int *a, int N) {\n  int x = a[5];\n  for (int i = 0; i < N; i += 3) {\n    a[i] += 2;\n    x = a[5];\n  }\n  return x;\n}\n```", "```cpp\nint foo(int *a, int N) {\n  for (int i = 0; i < N; i += 3) {\n    a[i] += 2;\n  }\n  return a[5];\n}\n```", "```cpp\n$ opt -licm input.ll –pass-remarks-output=licm_remarks.yaml …\n$ cat licm_remarks.yaml\n…\n--- !Missed\nPass:            licm\nName:            LoadWithLoopInvariantAddressInvalidated\nFunction:        foo\nArgs:\n  - String:          failed to move load with loop-invariant address because the loop may invalidate its value\n...\n$\n```", "```cpp\n…\nfor (auto &I : instructions(F)) {\n  if (auto *BinOp = dyn_cast<BinaryOperator>(&I))\n    if (BinOp->getOpcode() == Instruction::Mul) {\n      auto *LHS = BinOp->getOperand(0),\n           *RHS = BinOp->getOperand(1);\n      // Has no constant operand\n      if (!isa<Constant>(RHS)) continue;\n      const APInt &Const = cast<ConstantInt>(RHS)->getValue();\n      // Constant operand is not power of two\n      if (!Const.isPowerOf2()) continue;\n      …\n    }\n}\n```", "```cpp\n    #include \"llvm/Analysis/OptimizationRemarkEmitter.h\"\n    PreservedAnalyses\n    SimpleMulOpt::run(Function &F, FunctionAnalysisManager &FAM) {\n      OptimizationRemarkEmitter &ORE\n        = FAM.getResult<OptimizationRemarkEmitterAnalysis>(F);\n      …\n    }\n    ```", "```cpp\n    #include \"OptimizationRemarkEmitter::emit method takes a lambda function as the argument. This lambda function will be invoked to emit an optimization remark object if the optimization remark feature is turned on (via the –pass-remarks-output command-line option we've seen previously, for example).\n    ```", "```cpp\n    define i32 @bar(i32 %0) {\n      %2 = mul nsw i32 %0, 3\n      %3 = mul nsw i32 8, %3\n      ret %3\n    }\n    ```", "```cpp\n    $ opt –load-pass-plugin=… –passes=\"simple-mul-opt\" \\\n          SimpleMulOpt bailed out because it couldn't find a constant operand on one of the (multiplication) instructions. The Args section shows a detailed reason for this.With this information, we realize that `SimpleMulOpt` is unable to optimize a multiplication whose *first* operand (LHS operand) is a power-of-two constant, albeit a proper optimization opportunity. Thus, we can now fix the implementation of `SimpleMulOpt` to check if *either* of the operands is constant, as follows:\n\n    ```", "```cpp\n\n    You have now learned how to emit optimization remarks in an LLVM Pass and how to use the generated report to discover potential optimization opportunities.\n    ```", "```cpp\n    int foo(int *a, int N) {\n      for (int i = 0; i < N; i += 3) {\n        a[i] += 2;\n      }\n      return a[5];\n    }\n    ```", "```cpp\n    $ clang -O3 -foptimization-record-file is the command-line option used to generate an optimization remark file with the given filename.\n    ```", "```cpp\n    $ opt-viewer.py --source-dir=$PWD \\ \n    --target-dir=licm_remark licm.remark.yaml\n    ```", "```cpp\n#include \"llvm/Support/Timer.h\"\n…\nTimer T(\"MyTimer\", \"A simple timer\");\nT.startTimer();\n// Do some time-consuming works…\nT.stopTimer();\n```", "```cpp\nTimer T(…);\n…\nTimeRecord TR = T.getTotalTime();\nTR.print(TR, errs());\n```", "```cpp\n===---------------------------------------------------------===\n                     Miscellaneous Ungrouped Timers\n===---------------------------------------------------------===\n   ---User Time---   --User+System--   ---Wall Time---  --- Name ---\n   0.0002 (100.0%)   0.0002 (100.0%)   0.0002 (100.0%)  A simple timer\n   0.0002 (100.0%)   0.0002 (100.0%)   0.0002 (100.0%)  Total\n   0.0002 (100.0%)   0.0002 (100.0%)   0.0002 (100.0%)\n```", "```cpp\nTimerGroup TG(\"MyTimerGroup\", \"My collection of timers\");\nTimer T(\"MyTimer\", \"A simple timer\", TG);\nT.startTimer();\n// Do some time-consuming works…\nT.stopTimer();\nTimer T2(\"MyTimer2\", \"Yet another simple timer\", TG);\nT2.startTimer();\n// Do some time-consuming works…\nT2.stopTimer();\nTG.print(errs());\n```", "```cpp\n===---------------------------------------------------------===\n                    My collection of timers\n===---------------------------------------------------------===\n  Total Execution Time: 0.0004 seconds (0.0004 wall clock)\n   ---User Time---   --User+System--   ---Wall Time---  --- Name ---\n   0.0002 ( 62.8%)   0.0002 ( 62.8%)   0.0002 ( 62.8%)  A simple timer\n   0.0001 ( 37.2%)   0.0001 ( 37.2%)   0.0001 ( 37.2%)  Yet another simple timer\n   0.0004 (100.0%)   0.0004 (100.0%)   0.0004 (100.0%)  Total\n```", "```cpp\nTimerGroup TG(\"MyTimerGroup\", \"My collection of timers\");\n{\n  Timer T(\"MyTimer\", \"A simple timer\", TG);\n  TimeRegion TR(T);\n  // Do some time-consuming works…\n}\n{\n  Timer T(\"MyTimer2\", \"Yet another simple timer\", TG);\n  TimeRegion TR(T);\n  // Do some time-consuming works…\n}\nTG.print(errs());\n```", "```cpp\nTimeTraceScope OuterTimeScope(\"TheOuterScope\");\nfor (int i = 0; i < 50; ++i) {\n  {\n    TimeTraceScope InnerTimeScope(\"TheInnerScope\");\n    foo();\n  }\n  bar();\n}\n```", "```cpp\n$ opt –passes=\"…\" -time-trace -time-trace-file=my_trace.json …\n```", "```cpp\n$ clang -O3 -ftime-trace -c foo.c\n```", "```cpp\n#include \"llvm/Support/Error.h\"\n#include <system_error>\n// In the header file…\nstruct FileNotFoundError : public ErrorInfo<FileNoteFoundError> {\n  StringRef FileName;\n  explicit FileNotFoundError(StringRef Name) : FileName(Name)    {}\n  static char ID;\n  std::error_code convertToErrorCode() const override {\n    return std::errc::no_such_file_or_directory;\n  }\n  void log(raw_ostream &OS) const override {\n    OS << FileName << \": No such file\";\n  }\n};\n// In the CPP file…\nchar FileNotFoundError::ID = 0;\n```", "```cpp\nError NoSuchFileErr = make_error<FileNotFoundError>(\"foo.txt\");\n```", "```cpp\nProgram aborted due to an unhandled Error:\nfoo.txt: No such file\n```", "```cpp\nError readFile(StringRef FileName) {\n  if (openFile(FileName)) {\n    // Success\n    // Read the file content…\n    return ErrorSuccess();\n  } else\n    return make_error<FileNotFoundError>(FileName);\n}\n```", "```cpp\nError E = readFile(…);\nif (E) {\n  // TODO: Handle the error\n} else {\n  // Success!\n}\n```", "```cpp\nError E = readFile(…);\nif (E) {\n  Error UnhandledErr = handleErrors(\n    std::move(E),\n    [&](const FileNotFoundError &NotFound) {\n      NotFound.log(errs() << \"Error occurred: \");\n      errs() << \"\\n\";\n    });\n  …\n}\n```", "```cpp\nError readFile(StringRef FileName) {\n  if (openFile(FileName)) {\n    // Success\n    …\n    if (Buffer.empty())\n      return make_error<FileEmptyError>();\n    else\n      return ErrorSuccess();\n  } else\n    return make_error<FileNotFoundError>(FileName);\n}\n```", "```cpp\nError E = readFile(…);\nif (E) {\n  Error UnhandledErr = handleErrors(\n    std::move(E),\n    [&](const FileNotFoundError &NotFound) {…});\n  UnhandledErr = handleErrors(\n    std::move(UnhandledErr),\n    [&](const FileEmptyError &IsEmpty) {…});\n  …\n}\n```", "```cpp\nError E = readFile(…);\nif (E) {\n  Error UnhandledErr = handleErrors(\n    std::move(E),\n    [&](const FileNotFoundError &NotFound) {…},\n    [&](const FileEmptyError &IsEmpty) {…});\n  …\n}\n```", "```cpp\nError E = readFile(…);\nif (E) {\n  switch (E) {\n  case FileNotFoundError: …\n  case FileEmptyError: …\n  default:\n    // generate the UnhandledError\n  }\n}\n```", "```cpp\n    if (E) {\n      Error UnhandledErr = handleErrors(\n        std::move(E),\n        [&](const FileNotFoundError &NotFound) {…},\n        [&](const FileEmptyError &IsEmpty) {…});\n      UnhandledErr still contains an error, the cantFail function will abort the program execution and print an error message.\n    ```", "```cpp\n    if (E) {\n      handleAllErrors will still abort the program execution, just like what we have seen previously.\n    ```", "```cpp\n#include \"llvm/Support/JSON.h\"\n using namespace llvm;\n…\n// `InputStr` has the type of `StringRef`\nExpected<json::Value> JsonOrErr = json::parse(InputStr);\nif (JsonOrErr) {\n  // Success!\n  json::Value &Json = *JsonOrErr;\n  …\n} else {\n  // Something goes wrong…\n  Error Err = JsonOrErr.takeError();\n  // Start to handle `Err`…\n}\n```", "```cpp\nif (JsonOrErr) {\n  // Success!\n  …\n} else {\n  // Something goes wrong…\n  if (JsonOrErr.errorIsA<FileNotFoundError>()) {\n    …\n  }\n}\n```", "```cpp\nExpected<std::string> readFile(StringRef FileName) {\n  if (openFile(FileName)) {\n    std::string Content;\n    // Reading the file…\n    return Content;\n  } else\n    return make_error<FileNotFoundError>(FileName);\n}\n```", "```cpp\n#include \"llvm/Support/MemoryBuffer.h\"\n…\nErrorOr<std::unique_ptr<MemoryBuffer>> ErrOrBuffer\n  = MemoryBuffer::getFile(\"foo.txt\");\nif (ErrOrBuffer) {\n  // Success!\n  std::unique_ptr<MemoryBuffer> &MB = *ErrOrBuffer;\n} else {\n  // Something goes wrong…\n  std::error_code EC = ErrOrBuffer.getError();\n  …\n}\n```", "```cpp\n#include <system_error>\nErrorOr<std::string> readFile(StringRef FileName) {\n  if (openFile(FileName)) {\n    std::string Content;\n    // Reading the file…\n    return Content;\n  } else\n    return std::errc::no_such_file_or_directory;\n}\n```"]