<html><head></head><body>
		<div id="_idContainer317">
			<h1 class="chapter-number" id="_idParaDest-343"><a id="_idTextAnchor740"/>15</h1>
			<h1 id="_idParaDest-344"><a id="_idTextAnchor741"/>Using the File System</h1>
			<p>In the early days, arcade games would never store the progress of players. Every time you put in a quarter, the game would start from zero, unless there was a system that would let you buy more lives within the same run. But in general, you could not return the day after and start playing where you left off the <span class="No-Break">day before.</span></p>
			<p>Even early console games had limited functionality in terms of saving your progress. Some games would have a code system with which you got a secret code from the moment you had beaten a level. Later, you could use this code to start directly from there. But these games still didn’t really save <span class="No-Break">your progress.</span></p>
			<p>This restriction was partly because storage space, like hard drives or flash memory, was very expensive. Nowadays, almost every computer and console comes standard with a few hundred gigabytes, if not terabytes, of storage. Saving data has become very cheap and easy and players have come to expect that some kind of progress is tracked between <span class="No-Break">play sessions.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>What is the <span class="No-Break">file system?</span></li>
				<li>Creating a <span class="No-Break">save system</span></li>
			</ul>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor742"/>Technical requirements</h1>
			<p>As with every chapter, you can find the final code in the GitHub repository in the subfolder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter15"><span class="No-Break">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter15</span></a></p>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor743"/>What is the file system?</h1>
			<p>A <a id="_idIndexMarker855"/>file system is a system that manages files, their contents, as well as the metadata of these files. For example, a file system would manage in what folders the files are stored. It makes sure that we can access these files to read the content and metadata and write new data back. For Godot, this means that Godot Engine manages all resources that we could need in our game, from scenes to scripts, as well as images <span class="No-Break">and sounds.</span></p>
			<p class="callout-heading">Metadata</p>
			<p class="callout">When we have data, such as a text file, it is often accompanied by <a id="_idIndexMarker856"/>metadata. This is data about the data. While the text file contains the actual data, that is, the text, the metadata contains information such as the date of creation, who the author was, where it is stored, and what accounts have access to <span class="No-Break">the file.</span></p>
			<p>Let’s start our exploration of file systems with file paths in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor744"/>File paths</h2>
			<p>To be able to locate a <a id="_idIndexMarker857"/>file, the file system gives a unique path to each file. On our computer, we can find files through folders, also called directories, where we store them in a nice order. This path could look like this on a <span class="No-Break">Windows-based system:</span></p>
			<pre class="source-code">
C:\Users\user_name\Documents\my_text_file.txt</pre>			<p>Or it could look like this on macOS and <span class="No-Break">Linux-based systems:</span></p>
			<pre class="source-code">
~/Documents/my_text_file.txt</pre>			<p>For resource and other project-related files, Godot Engine’s paths work relative to the position where the project’s <strong class="source-inline">project.godot</strong> file is located. This file’s path is considered as the root directory. The paths within the Godot file system to access resource files always start with <strong class="source-inline">res://</strong>. To access one of the files within the project, for example, a path could look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
res://parts/player/player.tscn</pre>			<p class="callout-heading">Important note</p>
			<p class="callout">For convenience and compatibility, the Godot file system always uses forward slashes (<strong class="source-inline">/</strong>). Even on Windows-based systems, where the backward slash (<strong class="source-inline">\</strong>) is <span class="No-Break">normally used.</span></p>
			<p>We actually already used one of these paths when we preloaded the projectiles in <a href="B19358_10.xhtml#_idTextAnchor632"><span class="No-Break"><em class="italic">Chapter 10</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor745"/>User path</h2>
			<p>The fact that we can easily <a id="_idIndexMarker858"/>access all project files using the <strong class="source-inline">res://</strong> path is very convenient, but there is a problem. We cannot write to any file in the <strong class="source-inline">res://</strong> domain; when the game is running from an exported build, we can only read files from it. To help developers out with this problem, Godot Engine provides another root path, <strong class="source-inline">user://</strong>, which files can be written to and then <span class="No-Break">read from.</span></p>
			<p>Godot Engine automatically makes a folder somewhere on the computer to store this user data. The location of this folder is dependent on the system the game is running on, so it will be at a different for <span class="No-Break">each OS:</span></p>
			<ul>
				<li>Windows: <strong class="source-inline">%</strong><span class="No-Break"><strong class="source-inline">APPDATA%\Godot\app_userdata\&lt;project name&gt;</strong></span></li>
				<li>macOS: <strong class="source-inline"> ~/Library/Application Support/Godot/app_userdata/ &lt;</strong><span class="No-Break"><strong class="source-inline">project name&gt;</strong></span></li>
				<li>Linux: <strong class="source-inline">~/.local/share/godot/app_userdata/ &lt;</strong><span class="No-Break"><strong class="source-inline">project name&gt;</strong></span></li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">In the project settings, we can even specify where to locate this folder for each of the three OSs, but that is not needed for now, as Godot handles this for us and hides the folders away <span class="No-Break">somewhere safe.</span></p>
			<p>You can access the <strong class="source-inline">user://</strong> folder for a given project by opening up the <strong class="bold">Project</strong> menu and choosing <strong class="bold">Open User </strong><span class="No-Break"><strong class="bold">Data Folder</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer314">
					<img alt="Figure 15.1 - Open User Data Folder takes us to the user:// folder" src="image/B19358_15_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 - Open User Data Folder takes us to the user:// folder</p>
			<p>The <strong class="source-inline">user://</strong> path is <a id="_idIndexMarker859"/>what we are going to use to write our save data to in the next section of this chapter. So, let’s get to the actual implementation of our own little <span class="No-Break">save system.</span></p>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor746"/>Creating a save system</h1>
			<p>In theory, all we need<a id="_idIndexMarker860"/> to do is open a file, write the data we want to save to it, and then, later on, read that same file whenever we need the data. As it turns out, in the Godot Engine, it is indeed easy to read and <span class="No-Break">write files.</span></p>
			<p>We’re first going to see how to write to an <span class="No-Break">external file.</span></p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor747"/>Writing data to the disk</h2>
			<p>Let’s get to it by <a id="_idIndexMarker861"/>creating a new script called <strong class="source-inline">save_manager.gd</strong> under the <strong class="source-inline">autoloads</strong> folder. Then, to save data, put this code in <span class="No-Break">the script:</span></p>
			<pre class="source-code">
extends Node
const SAVE_FILE_PATH: String = "user://save_data.json"
var save_data: Dictionary = {
   "highscore": 0
}
func write_save_data():
   var json_string: String = <strong class="bold">JSON.stringify</strong>(save_data)
   var save_file: FileAccess = <strong class="bold">FileAccess.open</strong>(SAVE_FILE_PATH, FileAccess.WRITE)
   if save_file == null:
      print("Could not open save file.")
      return
   save_file.<strong class="bold">store_string</strong>(json_string)</pre>			<p>At the top of the script, we define a dictionary, called <strong class="source-inline">save_data</strong>, that we’ll use to store all the data in. For now, it only contains <strong class="source-inline">highscore</strong>. If we want to access the saved data later on during the game, we can just use <span class="No-Break">this variable.</span></p>
			<p>Then we<a id="_idIndexMarker862"/> have the <strong class="source-inline">write_save_data()</strong> function, which actually writes our data to a file. This function starts by converting our <strong class="source-inline">save_data</strong> dictionary to a JSON string using the <span class="No-Break"><strong class="source-inline">JSON.stringify()</strong></span><span class="No-Break"> function.</span></p>
			<p class="callout-heading">The JSON standard</p>
			<p class="callout">JSON is a<a id="_idIndexMarker863"/> data format that is widely used on the web and other platforms. The name <strong class="bold">JSON</strong> stands for <strong class="bold">JavaScript Object Notation</strong>. It is a very lightweight way of storing data and has the added benefit of being easy to read and adjust once our data is stored in <span class="No-Break">the file.</span></p>
			<p>Next, we use the <strong class="source-inline">FileAccess</strong> class to open the file in which we would like to write our data. We stored the path to the file as a constant, <strong class="source-inline">SAVE_FILE_PATH</strong>, at the top of the script. Because we want to write to the file, we need to open it with write access by providing <strong class="source-inline">File.Access.WRITE</strong> to the <strong class="source-inline">open()</strong> function. This mode of accessing the file will also create the file for us if it doesn’t exist yet. The opened file gets stored in the <span class="No-Break"><strong class="source-inline">save_file</strong></span><span class="No-Break"> variable.</span></p>
			<p>Next, we check whether <strong class="source-inline">save_file</strong> opened properly. If, for any reason, the file could not be opened, this variable’s value will be <strong class="source-inline">null</strong> and we should stop executing <span class="No-Break">the function.</span></p>
			<p class="callout-heading">More information</p>
			<p class="callout">For more on the <strong class="source-inline">FileAccess</strong> class, check out the<a id="_idIndexMarker864"/> official <span class="No-Break">documentation: </span><a href="https://docs.godotengine.org/en/stable/classes/class_fileaccess.html"><span class="No-Break">https://docs.godotengine.org/en/stable/classes/class_fileaccess.html</span></a><span class="No-Break">.</span></p>
			<p>The last thing <a id="_idIndexMarker865"/>we need to do, when the file is properly opened, is actually write the JSON data to it. We do this using <strong class="source-inline">store_string()</strong> on <strong class="source-inline">save_file</strong>, passing <span class="No-Break">along </span><span class="No-Break"><strong class="source-inline">json_string</strong></span><span class="No-Break">.</span></p>
			<p>That is all we need to write data to a file in the <strong class="source-inline">user://</strong> folder. Now we can write a function that reads this data <span class="No-Break">back in.</span></p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor748"/>Reading data from disk</h2>
			<p>To read data<a id="_idIndexMarker866"/> from the <strong class="source-inline">user://</strong> folder, we follow the same steps as writing it, but in reverse. Add this function to the <span class="No-Break"><strong class="source-inline">save_manager.gd</strong></span><span class="No-Break"> script:</span></p>
			<pre class="source-code">
func read_save_data():
   var save_file: FileAccess = FileAccess.<strong class="bold">open</strong>(SAVE_FILE_PATH, FileAccess.READ)
   if save_file == null:
      print("Could not open save file.")
      return
   var file_content: String = save_file.<strong class="bold">get_as_text</strong>()
   save_data = <strong class="bold">JSON.parse_string</strong>(file_content)</pre>			<p>The <strong class="source-inline">read_save_data</strong> function loads the saved file and parses the content so that we can use it in the game. Firstly,  we open the saved file with <strong class="source-inline">FileAccess.open</strong>, providing the file’s path and <strong class="source-inline">FileAccess.READ</strong> to indicate that we only want to read it. After this, we check to make sure the file is opened properly, else we need to exit the <span class="No-Break">function again.</span></p>
			<p>Next, we read out the complete file as a string into a variable called <strong class="source-inline">file_content</strong>. We’ll have to parse this string from the JSON format it was saved in, to the format that GDScript can handle, a dictionary. The parsed value is directly stored in the <strong class="source-inline">save_data</strong> variable that we defined in the <span class="No-Break">previous section.</span></p>
			<p class="callout-heading">More information</p>
			<p class="callout">For more on saving and loading data in Godot Engine, check out the official <span class="No-Break">documentation: </span><a href="https://docs.godotengine.org/en/stable/tutorials/io/saving_games.html"><span class="No-Break">https://docs.godotengine.org/en/stable/tutorials/io/saving_games.html</span></a><span class="No-Break">.</span></p>
			<p>This is great, we have two functions that are able to write and read the saved data for our little game. Now we still need to add some functions to make sure the script is usable by <span class="No-Break">the game.</span></p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor749"/>Preparing the save manager for use in the game</h2>
			<p>The save<a id="_idIndexMarker867"/> manager is almost ready, but we still need to add these <span class="No-Break">two functions:</span></p>
			<pre class="source-code">
func _ready():
   read_save_data()
func save_highscore(new_highscore: float):
   save_data.highscore = new_highscore
   write_save_data()</pre>			<p>The first function, the <strong class="source-inline">_ready()</strong> function, makes sure that we load the saved data from the moment the player starts up <span class="No-Break">the game.</span></p>
			<p>The second function adds a convenient way of storing a new high score. It adds the new high score to the <strong class="source-inline">save_data</strong> dictionary and then writes the data <span class="No-Break">to disk.</span></p>
			<p>Now, to make sure we can access the save manager from anywhere, add this script to the project’s autoloads. What we want is for our save manager to be the first autoload that gets executed, which will make sure that the saved data gets loaded before any other part of the game executes. To do this, make sure the <strong class="source-inline">save_manager.gd</strong> script is at the top of the list of autoloads. You can do this by dragging and dropping the entry of <strong class="bold">SaveManager</strong> or by clicking the arrows on the right until it is at <span class="No-Break">the top.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer315">
					<img alt="Figure 15.2 - Make sure SaveManager is the first autoload in the list" src="image/B19358_15_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 - Make sure SaveManager is the first autoload in the list</p>
			<p>With this script finished and in place as an autoload, we can finally hook up the game to use it. Let’s do that in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor750"/>Adjusting the game to use the save manager</h2>
			<p>Now, all we need to do<a id="_idIndexMarker868"/> is to get the high score from <strong class="bold">SaveManager</strong> when we load the <strong class="source-inline">highscore_manager.gd</strong> script and save the high score every time the player attains a new one. Add the following <strong class="source-inline">_ready</strong> function to the <strong class="source-inline">highscore_manager</strong><strong class="source-inline">.gd</strong> script and add the <strong class="source-inline">SaveManager.save_highscore()</strong> <span class="No-Break">function call:</span></p>
			<pre class="source-code">
func _ready():
   <strong class="bold">highscore = SaveManager.save_data.highscore</strong>
func set_new_highscore(value: int):
   if value &gt; highscore:
      highscore = value
      <strong class="bold">SaveManager.save_highscore(highscore)</strong></pre>			<p>With these in place, we can finally play the game a bit, get a high score, close the game, and, when we reopen it, see our previous high score <span class="No-Break">come up.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer316">
					<img alt="Figure 15.3 - The high score gets loaded when we open the game" src="image/B19358_15_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 - The high score gets loaded when we open the game</p>
			<p>Now our game is really ready for users to strive over beating their high score over multiple days without having to keep track of it themselves. In the next section, we’ll take a glance at the actual content of the save <span class="No-Break">file itself.</span></p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor751"/>Having a look at the save file</h2>
			<p>For now, we have treated the<a id="_idIndexMarker869"/> save file as a black box, without knowing its actual contents. We save data to it, in JSON format, and read it back in, parsing it back to data that is usable <span class="No-Break">by GDScript.</span></p>
			<p class="callout-heading">Black box</p>
			<p class="callout">We say we interact with a black box when we don’t have an idea of how the thing itself actually works. We provide the system with input and it spits out <span class="No-Break">some output.</span></p>
			<p>Of course, we can also take a look at the contents of the save file with a text editor, such as Notepad on Windows. Just open the <strong class="source-inline">user://</strong> folder, as we did in the <em class="italic">User path</em> section, earlier in this chapter. From here, open up the <strong class="source-inline">save_data.save</strong> file that we created in the <span class="No-Break">save manager.</span></p>
			<p>You’ll see that the data within this file is very easily readable, and looks a lot like the actual dictionary that we defined in the <strong class="source-inline">save_manager.gd</strong> script. This is because JSON also has a notion of the dictionary data structure and the syntax is very similar to that of dictionaries in GDScript. The file looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{"highscore":56}</pre>			<p>If you want, you can change the save data from here and cheat, by filling in an impossibly high score. Unfortunately, users will also be able to do this if they know where to look for the <span class="No-Break">save file.</span></p>
			<p class="callout-heading">More information</p>
			<p class="callout">There are ways to encrypt save files, but these are out of the scope of this book. See the  official documentation for <span class="No-Break">more: </span><a href="https://docs.godotengine.org/en/stable/classes/class_fileaccess.html#class-fileaccess-method-open-encrypted"><span class="No-Break">https://docs.godotengine.org/en/stable/classes/class_fileaccess.html#class-fileaccess-method-open-encrypted</span></a><span class="No-Break">.</span></p>
			<p>Awesome, with our game saving the player’s high score, we have come to the end of this chapter. There are still many tricks to be learned about loading and saving the game state, but for now, this will <span class="No-Break">surely do.</span></p>
			<h1 id="_idParaDest-355"><a id="_idTextAnchor752"/>Summary</h1>
			<p>In this chapter, we learned all about the file system of Godot and computers in general. It allowed us to write a little save system that keeps the high score of our game and loads it every time we start up <span class="No-Break">the game.</span></p>
			<p>This was the last chapter for this part of the book. Over the course of the last five chapters, we took a deeper dive into programming concepts, patterns, and the <span class="No-Break">file system.</span></p>
			<p>You are all ready to go and develop some games of your own. But before you do so, I want to give you some last pointers and steps on what to do next in the last chapter of this book. See<a id="_idTextAnchor753"/> <span class="No-Break">you there.</span></p>
			<h1 id="_idParaDest-356"><a id="_idTextAnchor754"/>Quiz time</h1>
			<ul>
				<li>What is the difference between the <strong class="source-inline">res://</strong> and <strong class="source-inline">user://</strong> file paths within <span class="No-Break">Godot Engine?</span></li>
				<li>To save data, we used the JSON format. Is JSON a format unique to Godot Engine? In what other domain is the JSON format <span class="No-Break">widely used?</span></li>
			</ul>
		</div>
	</body></html>