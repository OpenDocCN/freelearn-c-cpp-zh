["```cpp\n166.58.155.136\n```", "```cpp\ne9fd:da7d:474d:dedb:d152:dce2:1294:2560\n```", "```cpp\n166.58.155.136:5904\ne9fd:da7d:474d:dedb:d152:dce2:1294:25605904.\n\t\t\tNow that we know about the basic mechanisms of computer networking, such as the different layers and how IP addresses work, we are able to start implementing multiplayer into our game. So, let’s give that a shot!\n\t\t\tSetting up the base networking code\n\t\t\tIn the *A crash course in computer networking* section, we saw that we wanted to set up a client-server network architecture and that we could use IP addresses and ports to find computers over the internet. In this section, we’ll start implementing this.\n\t\t\tWe’re going to make our multiplayer game work like this: every time you start playing, it spins up a server in the background. This way, anyone can join after one person starts the match.\n\t\t\tCreating the client-server connection\n\t\t\tIf we want to connect our players through a client-server model, we need to be able to set up one computer as a server and the others as clients that connect to this server. Let’s start by writing some code.\n\n\t\t\t\t1.  In the `menu.gd` script, add a constant at the top that indicates which port we want to use:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  Now add these two functions to the bottom of the script:\n\n    ```", "```cpp\n\n    The `host_game()` function will use the `ENetMultiplayerPeer` class to create a new server using the `create_server()` function that is defined on it. To create this server, we only have to specify on which port we want to receive the data. Once this is done, we check whether the connection status is disconnected; if we are not connected, then we need to return from the function. We can check the connection status using the `get_connection_status()` function on the `peer` object.\n\n    \t\t\t\t3.  Lastly, we set this peer as `multiplayer_peer`, which is defined on the multiplayer global variable.\n\n    The `connect_to_game()` function does largely the same but creates a client using the `create_client()` function on the `ENetMultiplayerPeer` `peer` object. The `create_client()` function takes an IP address and port. These will, of course, be the IP address and port of the server.\n\n\t\t\tWith these two functions in place, we can add some more UI to connect to the right server.\n\t\t\tAdding UI\n\t\t\tNow, for the menu, we want to be able to start a game that will set up a server or input an IP address to join an already hosted game. We won’t have to let the player choose a port, both because it’s less of a hassle for the player and because we don’t want them to accidentally choose an invalid port number. We, the programmers, decide we are going to use port `7890`.\n\t\t\t![Figure 11.6 – The main menu with an input field to specify an IP address](img/B19358_11_06.jpg)\n\n\t\t\tFigure 11.6 – The main menu with an input field to specify an IP address\n\n\t\t\t\t1.  Open up the `menu.tscn` scene.\n\t\t\t\t2.  Add a `LineEdit` node in `VBoxContainer`, which holds the play and exit buttons, and rename it `IpAddressLineEdit`.\n\t\t\t\t3.  Place `IpAddressLineEdit` under the `PlayButton` node, but not as a child.\n\n\t\t\t![Figure 11.7 – The main menu scene tree with the added IpAddressLineEdit](img/B19358_11_07.jpg)\n\n\t\t\tFigure 11.7 – The main menu scene tree with the added IpAddressLineEdit\n\n\t\t\t\t1.  Select the `IpAddressLineEdit` node and set `IP ADDRESS`. This will show some placeholder text that will get replaced the moment the user puts anything into the line edit.\n\n\t\t\t![Figure 11.8 – Setting Placeholder Text in a LineEdit node](img/B19358_11_08.jpg)\n\n\t\t\tFigure 11.8 – Setting Placeholder Text in a LineEdit node\n\n\t\t\t\t1.  Now, in the `menu.gd` script, cache the `IpAddressLineEdit` at the top:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  Lastly, we need to change the `_on_play_button_pressed()` function to host or connect to a game:\n\n    ```", "```cpp\n\n\t\t\tWith all this in place, we have all that is needed to set up the client-server architecture. One computer will be the server and the others, the clients. Before we dive into the things we have to change in the code of the game itself, such as spawning playable characters for every person joining and then making sure the position of each player is synchronized between each computer, we can try out what we have already created.\n\t\t\tRunning multiple debug instances at the same time\n\t\t\tTo debug a multiplayer game, we need to be able to run our game multiple times in debug mode. Luckily, Godot Engine has a handy feature that allows us to run as many instances of our game as we want at the same time.\n\n\t\t\t\t1.  Click **Debug** in the top menu bar.\n\t\t\t\t2.  Under the **Run Multiple Instances** menu, choose **Run** **2 Instances**.\n\n\t\t\t![Figure 11.9 – In the Debug dropdown menu, we set the number of instances we want to run](img/B19358_11_09.jpg)\n\n\t\t\tFigure 11.9 – In the Debug dropdown menu, we set the number of instances we want to run\n\n\t\t\t\t1.  Run the project. This will make two instances of the game pop up at the same time.\n\t\t\t\t2.  In one instance, just press **Play**. The game should start up normally.\n\t\t\t\t3.  In the other instance, type `::1` in the IP address input field and then press **Play**.\n\n\t\t\t![Figure 11.10 – Specifying the ::1 IP address will loop back to the same computer](img/B19358_11_10.jpg)\n\n\t\t\tFigure 11.10 – Specifying the ::1 IP address will loop back to the same computer\n\t\t\tUnfortunately, you won’t see anything special happen. We still need to account for multiple players in our game code, but normally, there should be no errors in the bottom **Debug** panel.\n\t\t\tLocal host IP address\n\t\t\tThere is a special IP address that does not go to another computer but rather loops back to the same computer again. In the IPv6 format, this address is `::1`, and for IPv4, it is `127.0.0.1`.\n\t\t\tYou’ll also see that there are now multiple tabs in the **Debug** panel, one for each instance of the game. This way, we will be able to debug each separately.\n\t\t\t![Figure 11.11 – When running multiple instances, we’ll also have multiple Debug tabs](img/B19358_11_11.jpg)\n\n\t\t\tFigure 11.11 – When running multiple instances, we’ll also have multiple Debug tabs\n\t\t\tNow that we are able to create a server and connect clients, let’s start by making our game multiplayer compatible and synchronizing spawned scenes between both games.\n\t\t\tSynchronizing different clients\n\t\t\tUntil now, we learned about computer networking and set up a connection between multiple instances of our game. The next step is to change the scenes and code within our game to account for multiple players. We want to accomplish two things:\n\n\t\t\t\t*   Firstly, if the server instances a new scene, such as a new projectile, we want that scene to be instanced on every client\n\t\t\t\t*   Secondly, we want to synchronize values, such as the position of each player character, between all clients\n\n\t\t\tWe’ll first look at which Godot Engine nodes can help us achieve these two goals while updating the player character to be used in multiplayer. After that, we’ll update the entity spawner, enemy, collectible, and projectile scenes, too. Most of these changes will be quite small.\n\t\t\tUpdating the player scene for multiplayer\n\t\t\tBecause the player is the most important entity in the game, let’s start by updating them for multiplayer. This way, we can quickly make sure everything is working correctly, too.\n\t\t\tUsing MultiplayerSpawner to spawn player scenes\n\t\t\tTo synchronize instanced scenes between the server and the clients, Godot Engine has a node called `MultiplayerSpawner`. It will listen to the scenes that are getting added to the scene tree and will replicate them on each of the other clients, too. Let’s add one to the main game scene:\n\n\t\t\t\t1.  Open the `main.tscn` scene.\n\t\t\t\t2.  Under the root `MultiplayerSpawner` node, and call it `PlayerMultiplayerSpawner`, because it will be spawning new player characters.\n\n\t\t\t![Figure 11.12 – The main.tscn scene tree with an added PlayerMultiplayerSpawner](img/B19358_11_12.jpg)\n\n\t\t\tFigure 11.12 – The main.tscn scene tree with an added PlayerMultiplayerSpawner\n\n\t\t\t\t1.  Now, in the inspector window for `PlayerMultiplayerSpawner`, press `player.tscn` scene into that element.\n\n\t\t\t![Figure 11.13 – Add the player.tscn scene as an element in PlayerMultiplayerSpawner](img/B19358_11_13.jpg)\n\n\t\t\tFigure 11.13 – Add the player.tscn scene as an element in PlayerMultiplayerSpawner\n\n\t\t\t\t1.  Now, to specify positions at which our players can spawn, add `Node2D`, called `PlayerStartPositions`, under the `Main` node with different `Marker2D` nodes where we can spawn players. Place each marker at a good spot to start a player from.\n\n\t\t\t![Figure 11.14 – The PlayerStartPositions node with Marker2D to spawn players at](img/B19358_11_14.jpg)\n\n\t\t\tFigure 11.14 – The PlayerStartPositions node with Marker2D to spawn players at\n\n\t\t\t\t1.  In the `main.gd` script, we’ll cache the player scene in an export variable. So, add the following line of code at the top and drag the `player.tscn` scene into this export variable in the inspector, too:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  Also, cache the `PlayerMultiplayerSpawner` node in a variable called `_player_multiplayer_spawner` and `PlayerStartPositions` in a variable called `_player_start_positions`:\n\n    ```", "```cpp\n\n    \t\t\t\t3.  We’ll also add a variable at the top of the script that specifies what position we will spawn the next player at. With this variable, we will select which `Marker2D` to use as to location to spawn each player at:\n\n    ```", "```cpp\n    func add_player(id: int):\n       _player_multiplayer_spawner.spawn(id)\n    func spawn_player(id: int):\n       var player: Player = player_scene.instantiate()\n       player.multiplayer_id = id\n       player.died.connect(_on_player_died)\n       var spawn_marker: Marker2D = _player_start_positions.get_childr(_player_spawn_index)\n       player.position = spawn_marker.position\n       _player_spawn_index = (_player_spawn_index + 1) % _player_start_positions.get_child_count()\n       return player\n    ```", "```cpp\n\n    \t\t\t\t4.  To use these functions, we’ll add a `_ready()` function to the `main.gd` script:\n\n    ```", "```cpp\n\n    \t\t\t\t5.  Lastly, but very importantly, delete the `Player` node that is already in the `main.tscn` scene. We do this because we’ll spawn each player character from code and so they don’t need the node to be in there already.\n\n\t\t\tIn the `add_player()` function, we simply ask `_player_multiplayer_spawner` to spawn a new instance of the player scene.\n\t\t\tThen, in the `spawn_player()` function, which will be used by the `PlayerMultiplayerSpawner` to spawn new `Player` scenes, we instantiate a new player scene and set its `multiplayer_id` property to the  ID that we received as a parameter. This ID is used to determine which client owns that particular player node. We’ll use it in the next section. Afterward, we must return the new player instance so that the `PlayerMultiplayerSpawner` can handle the rest for us.\n\t\t\tWe use the `_player_spawn_index` variable to select which `Marker2D` to select in `PlayerStartPositions`. After each player spawned, we increment this variable with `1` and make sure it loops back around with the `%` operator. This makes sure that we don’t spawn players on top of each other.\n\t\t\tIn the `_ready()` function, first, we set `spawn_function` for `_player_multiplayer_spawner` to be the `spawn_player()` function that we defined. This way, the multiplayer spawner knows how to create new instances of the player scene.\n\t\t\tThen, you see that we check the `multiplayer` object if this code is being run on the server, using `multiplayer.is_server()`. This `is_server()` function returns `true` if the code is run on the server.\n\t\t\tIf we are running on the server, we do the following:\n\n```", "```cpp\n\n\t\t\t`peer_connected` is a signal that is thrown by the `multiplayer` object when a new peer (a new client) connects to the server. Instead of connecting through the editor, like we used to do for detecting whether the player is close to the collectibles, we directly call the `connect()` function on this signal and pass along the function that we want to execute when a player connects to the server, which is the `add_player()` function.\n\t\t\tAfter connecting to the `peer_connected` signal, we call the `add_player()` function with `1` as `id`, which is the default ID for the server.\n\t\t\tWe will not yet be able to run the game for now, first, we need to update the player scene.\n\t\t\tUpdating the player code for multiplayer\n\t\t\tWhen you try running the game with multiple instances at the end of the last section, you will notice that there are some things off, mainly that, on each client separately, you control both players at the same time.\n\t\t\tThis behavior happens because, although we spawn a player per client, all code gets run all the time on each client separately. We have to specify that the movement code for each player character should only be run on the client associated with that player character, not all at once on all clients. Afterward, we should synchronize the position to the server.\n\t\t\tWe’ll do this by setting the **multiplayer authority** of the player character node. This authority “owns” this node and decides how it behaves.\n\t\t\tSo, let’s alter our code so the players work properly:\n\n\t\t\t\t1.  Firstly, add the `multiplayer_id` variable that we used in the last section somewhere at the top of the `player.gd` script:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  Add an `_enter_tree()` function; this function is a life cycle function that gets called when the node enters the tree, right before the `_ready()` function. In this function, we set the multiplayer authority to the client that has the same ID as `multiplayer_id` of this player node:\n\n    ```", "```cpp\n\n    \t\t\t\t3.  Cache the `CameraPosition` node at the top of the script:\n\n    ```", "```cpp\n\n    \t\t\t\t4.  Now, update the `_ready()` function like this:\n\n    ```", "```cpp\n\n\t\t\tIn *step 2*, we set the multiplayer authority for a node, which means that we determine which client is the owner of this node. For most nodes in multiplayer, the server should be the owner. But the player character is so important to each client that we give the authority of each to their respective client.\n\t\t\tAfter that, we use `multiplayer.is_server()` to stop `_shoot_timer` when we are not running on the server. This way, we make sure that projectiles only get spawned on the server side and replicated to all clients from there.\n\t\t\tNext, we use `is_multiplayer_authority()` to check whether we are the authority of this specific player node. If we are not, we free `_camera_position`. We don’t need multiple cameras, only the one that is used to track the player we want to see, and we also disable the `_physics_process()` function. Only the client that owns this node will have to calculate this player’s position and then report back to the server where the player is.\n\t\t\tDisabling the _process() and _physics_process() functions\n\t\t\tBy default, the `_process()` and `_physics_process()` functions get called on each frame and physics frames, respectively. However, we can choose to enable or disable them manually by calling `set_process()` and `set_physics_process()` along with a Boolean that says whether they should run or not.\n\t\t\tAfter all this, you can run the game with multiple instances, like we saw in the *Running multiple debug instances at the same time* section, and you should see a second player spawn! Each player is able to move properly, but their positions are unfortunately not synchronized. We’ll do that next.\n\t\t\tSynchronizing the players’ positions and health\n\t\t\tWe can spawn scenes across clients and determine on which client certain pieces of code should run. The last piece of the puzzle is to synchronize certain variables, like the position and health of our players. Luckily, this is actually very easy to do using the `MultiplayerSynchronizer` node. We are going to use two of these, one for the position and one for the health. Although one synchronizer can synchronize multiple variables, we want the position to be managed by each client individually and the health to be managed by the server:\n\n\t\t\t\t1.  In the `player.tscn` scene, add two `MultiplayerSynchronizer` nodes under the root `Player` node. Call on `PositionMultiplayerSynchronizer` and the other `HealthMultiplayerSynchronizer`.\n\n\t\t\t![Figure 11.15 – The player.tscn scene tree after adding two MultiplayerSynchronizer nodes](img/B19358_11_15.jpg)\n\n\t\t\tFigure 11.15 – The player.tscn scene tree after adding two MultiplayerSynchronizer nodes\n\n\t\t\t\t1.  Select `PositionMultiplayerSynchronizer` and a new panel should appear at the bottom of the editor.\n\n\t\t\t![Figure 11.16 – The Replication panel that opens up when selecting MultiplayerSynchronizer](img/B19358_11_16.jpg)\n\n\t\t\tFigure 11.16 – The Replication panel that opens up when selecting MultiplayerSynchronizer\n\n\t\t\t\t1.  Here, press **+ Add property** **to synchronize**.\n\t\t\t\t2.  Select the `Player` node and press **OK**.\n\n\t\t\t![Figure 11.17 – Select the Player node to synchronize one of its values](img/B19358_11_17.jpg)\n\n\t\t\tFigure 11.17 – Select the Player node to synchronize one of its values\n\n\t\t\t\t1.  Now, search for the `position` property and press **Open**.\n\n\t\t\t![Figure 11.18 – Select the position property to synchronize its value](img/B19358_11_18.jpg)\n\n\t\t\tFigure 11.18 – Select the position property to synchronize its value\n\n\t\t\t\t1.  Do *steps 2* to *5* again but add the `health` property to `HealthMultiplayerSynchronizer` this time.\n\n\t\t\t![Figure 11.19 – The Replication panel tracking the position value of the Player node](img/B19358_11_19.jpg)\n\n\t\t\tFigure 11.19 – The Replication panel tracking the position value of the Player node\n\n\t\t\t\t1.  Now, update the `_enter_tree()` function of the player so that we give the multiplayer authority of `HealthMultiplayerSpawner` to the server:\n\n    ```", "```cpp\n\n\t\t\tThat is all we need to do to synchronize values between different clients. `MultiplayerSynchronizer` simply tracks them for us.\n\t\t\tRunning two instances of the game and connecting them finally shows that if we move one player character in one client, it also moves that player character in the other client.\n\t\t\tNow that we updated the hardest scene to multiplayer, the player scene, we have all the knowledge to do the same for the remaining scenes. Let’s dive in so that we have a complete multiplayer game at the end!\n\t\t\tSynchronizing EntitySpawner\n\t\t\tTo make sure the enemy and health potion scenes are spawned on each client when the entity spawner wants to, we’ll have to make a few little adjustments to the `EnitySpawner` scene:\n\n\t\t\t\t1.  In the `entity_spawner.tscn` scene, add a `MultiplayerSpawner` node.\n\n\t\t\t![Figure 11.20 – The EntitySpawner scene tree after adding MultiplayerSpawner](img/B19358_11_20.jpg)\n\n\t\t\tFigure 11.20 – The EntitySpawner scene tree after adding MultiplayerSpawner\n\n\t\t\t\t1.  In the `entity_spawner.gd` script, cache the `MultiplayerSpawner` node:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  Then, in the `_ready()` function, let’s add the scene this spawner uses to this `MultiplayerSpawner` node and only start the timer if we are running on the server. This ensures that not every client is spawning new entities, only the server:\n\n    ```", "```cpp\n\n    \t\t\t\t3.  One last thing we need to do is change the exact way we add the `new_entity` to the scene. So, change the line with `add_child(new_entity)` to the following:\n\n    ```", "```cpp\n\n\t\t\tIn *step 3*, we add a spawnable scene to the `MultiplayerSpawner` node. This is very convenient as now we can add any scene on the fly.\n\t\t\tIn *step 4*, we supply the Boolean `true` as a second parameter to the `add_child()` function, next to the node that we want to add to the scene tree. This indicates that we want to use human-readable names for each node, names that are easy for humans to read. When we don’t set this Boolean to `true`, the engine will pick a name for the node. These names look like `@Node2D@2`. These are reserved names that cannot be synchronized using a `MultiplayerSpawner` node. When we do set this Boolean to `true`, each new instance gets nicely named, for example, `Enemy2`, `Enemy3`, and so on. In a multiplayer scenario, this is important for the server to properly synchronize scenes and values between them.\n\t\t\tNow that we can synchronize the spawned entities of enemies and collectibles between clients, let’s synchronize their behavior, too.\n\t\t\tSynchronizing the enemy and collectibles\n\t\t\tFor both the enemy and all collectibles, making them work with multiplayer is quite easy and straightforward:\n\n\t\t\t\t1.  Add `MultiplayerSynchronizer` to the `enemy.tscn` and `collectible.tscn`.\n\n\t\t\t![Figure 11.21 – The scene tree of the Collectible after adding MultiplayerSynchronizer](img/B19358_11_21.jpg)\n\n\t\t\tFigure 11.21 – The scene tree of the Collectible after adding MultiplayerSynchronizer\n\n\t\t\t\t1.  Now, add the `position` property of the root node in the **Replication** menu at the bottom.\n\n\t\t\t![Figure 11.22 – The Replication panel tracking the position of the Collectible node](img/B19358_11_22.jpg)\n\n\t\t\tFigure 11.22 – The Replication panel tracking the position of the Collectible node\n\t\t\tThat is about it for `Collectible`, while for `Enemy`, we need to do some last things in the code:\n\n\t\t\t\t1.  Cache `PlayerDetectionArea` at the top of the `enemy.gd` script:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  Now, update the `_ready()` function like this:\n\n    ```", "```cpp\n\n\t\t\tThe first thing we do in the `_ready()` function of the enemy is disable the `_physics_process()` function and `_player_detection_area` if we are not running them from the server. This makes sure that enemies are fully controlled by the server.\n\t\t\tThe `Area2D` nodes have a property, `monitoring`, that stops looking for collisions with other areas or bodies when set to `false`. This is what we are using here to disable `_player_detection_area` on other clients than the server.\n\t\t\tLastly, we want to be able to target any of the players in the game, so we change how to target a player. The `pick_random()` function on an array will pick any element within that array at random and return it. This is ideal for picking a random player within the scene!\n\t\t\tLet’s now look at how we can synchronize the projectiles.\n\t\t\tSynchronizing the projectile\n\t\t\tThe last scene we need to synchronize between the multiple clients is the one of the projectiles. So, let’s do that with the following steps:\n\n\t\t\t\t1.  In the `projectile.tscn` scene, add `MultiplayerSynchronizer`.\n\n\t\t\t![Figure 11.23 – The scene tree of Projectile after adding MultiplayerSynchronizer](img/B19358_11_23.jpg)\n\n\t\t\tFigure 11.23 – The scene tree of Projectile after adding MultiplayerSynchronizer\n\n\t\t\t\t1.  This time, synchronize both the `position` and `rotation` properties.\n\n\t\t\t![Figure 11.24 – The Replication panel tracking the position and rotation of the Projectile node](img/B19358_11_24.jpg)\n\n\t\t\tFigure 11.24 – The Replication panel tracking the position and rotation of the Projectile node\n\t\t\tCache `EnemyDetectionArea` at the top of the `projectile.gd` script:\n\n```", "```cpp\n\n\t\t\t\t1.  Now, add a `_ready()` function as follows:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  We need to change the way the projectile is added to the scene within the `player.gd` script from `get_parent().add_child(new_projectile)` to the following:\n\n    ```", "```cpp\n\n\t\t\tImportant note\n\t\t\tRemember that the last parameter of the `add_child()` function is a Boolean that determines that the name of the new node should be human readable.\n\n\t\t\t\t1.  Lastly, we need to make sure that the `projectile.tscn` scene is replicated in the main scene, just like we did for the `player.tscn` scene. Add a `MultiplayerSpawner` node in the `main.tscn`, call it `ProjectileMultiplayerSpawner`, and add `projectile.tscn` in **Auto** **Spawn List**.\n\n\t\t\t![Figure 11.25 – Main scene with ProjectilMultiplayerSpawner with the projectile.tscn scene](img/B19358_11_25.jpg)\n\n\t\t\tFigure 11.25 – Main scene with ProjectilMultiplayerSpawner with the projectile.tscn scene\n\t\t\tThat is it for the `Projectile` scene and thereby all the scenes important to playing the game itself! You can now run multiple instances of the game and everything within the game should be synchronized. The last thing we’ll need to look at is synchronizing the timers within the game and the game-over menu for both players.\n\t\t\tFixing the timer and end game\n\t\t\tThe last thing we need to adjust for multiplayer is the timer that times our run and the end of the game, stopping the entity spawners and showing the game-over menu. So, let’s get started on this last effort.\n\t\t\tSynchronizing the timer\n\t\t\tTo synchronize the score timer, we simply have to do the following three things:\n\n\t\t\t\t1.  Add `MultiplayerSynchronizer` to the `main.tscn` scene.\n\n\t\t\t![Figure 11.26 – The Main scene tree after adding MultiplayerSynchronizer](img/B19358_11_26.jpg)\n\n\t\t\tFigure 11.26 – The Main scene tree after adding MultiplayerSynchronizer\n\n\t\t\t\t1.  Synchronize the `_time` property of the `Main` node.\n\n\t\t\t![Figure 11.27 – The Replication panel tracking the _time property of the Main node](img/B19358_11_27.jpg)\n\n\t\t\tFigure 11.27 – The Replication panel tracking the _time property of the Main node\n\n\t\t\t\t1.  Now, disable the `_process()` function from within `_ready()` if we are not running on the server:\n\n    ```", "```cpp\n\n\t\t\tThat is all we need to do synchronize the timer across all clients.\n\t\t\tSynchronizing the end of the game\n\t\t\tTo make sure that when the game ends, it ends for all clients, let’s do the following:\n\n\t\t\t\t1.  In the `main.gd` script, let’s connect to each player character’s `died` signal in the `add_player()` function:\n\n    ```", "```cpp\n    func _on_player_died() -> void:\n       end_game.rpc()\n    @rpc(\"authority\", \"reliable\", \"call_local\")\n    func end_game():\n       _game_over_menu.show()\n       _enemy_spawner.stop_timer()\n       _health_potion_spawner.stop_timer()\n       set_process(false)\n       Highscore.set_new_highscore(_time)\n    ```", "```cpp\n\n    \t\t\t\t2.  Then, in the `menu.gd` script, change the `_ready()` function to the following:\n\n    ```", "```cpp\n\n\t\t\tIn the first step, we simply connect to each player’s `died` signal through code.\n\t\t\tImportant note\n\t\t\tNote that only the server connects to the `died` signal because it is the server that manages the game loop.\n\t\t\tIn the second step, we do something very interesting. We call the `end_game()` function through **RPC**, which means that we call it on every client at the same time!\n\t\t\tImportant note\n\t\t\t**Remote procedure call** (**RPC**) is a protocol that makes functions directly callable over different clients. This makes it easy to execute the same code on all connected instances of the game at the same time.\n\t\t\tYou can see that we use the `@rpc` annotation right before the `end_game()` function. This is to indicate how we would like this function to be handled when calling on every client at once. The strings we pass it along mean the following:\n\n\t\t\t\t*   `\"authority\"`: Only the one with authority, the server, in this case, can call this function.\n\t\t\t\t*   `\"reliable\"`: We want this command to be sent reliably over the network, using TCP.\n\t\t\t\t*   `\"``call_local\"`: This function, when called, should be executed on all clients, including the one that called it.\n\n\t\t\tThis means that the game-over menu will be shown on every client from the moment one of the players dies.\n\t\t\tIn the third step, we simply close the multiplayer connection, when there is one, and we open up the main menu. This way, we make sure we don’t stay connected while we are not playing anymore.\n\t\t\tNow that the whole game is ready to be played in multiplayer, let’s get started on actually running it on multiple machines at the same time!\n\t\t\tRunning the game on multiple computers\n\t\t\tUntil this point, we’ve been running multiple instances of our game on the same machine. But the strength of multiplayer comes from playing with multiple people over multiple machines.\n\t\t\tIn this section, we’ll start off by showing the server’s IP address on screen and then look into how we can run a debug instance on multiple computers at the same time so they can connect.\n\t\t\tShowing the IP address of the server\n\t\t\tWe have been using `::1` as the IP address that loops back to the same computer so that we can debug our game. However, before we can connect to another computer over a network, we need to know their real IP address. To do this, we’ll show the server’s IP address on the screen when they are hosting a game.\n\t\t\t![Figure 11.28 – The server has an IP address displayed at the bottom of the screen to connect](img/B19358_11_28.jpg)\n\n\t\t\tFigure 11.28 – The server has an IP address displayed at the bottom of the screen to connect\n\t\t\tIn *Figure 11**.28*, you can see that we want to show the IP address at the bottom of the screen. Let’s get to it:\n\n\t\t\t\t1.  In the `main.tscn` scene, add `CenterContainer` with `Label` as a child, just like we did for the timer. Give them names like in *Figure 11**.29*.\n\n\t\t\t![Figure 11.29 – The CanvasLayer node with NetworkUI](img/B19358_11_29.jpg)\n\n\t\t\tFigure 11.29 – The CanvasLayer node with NetworkUI\n\n\t\t\t\t1.  Now, in the `main.gd` script, cache `IPLabel` at the top:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  Next, add this function that shows the local IP address:\n\n    ```", "```cpp\n\n    \t\t\t\t3.  Now, call this function in the `_ready()` function, but only if we’re running on the server:\n\n    ```", "```cpp\n\n\t\t\tDon’t worry too much about the implementation of the `show_local_ip_address()` function. The basis is that it will search for the local IP address by scanning all the network addresses of the current computer and saving the ones that start with `\"10.\"`, `\"172.16.\"`, or `\"192.168.\"`, which are the know beginnings for local IP addresses. The reasons why it works are a little obscure and beyond the scope of this book.\n\t\t\tNow that we know what IP address the server has, let’s see how we can actually set everything up to connect two computers together.\n\t\t\tConnecting from another computer\n\t\t\tThe big caveat for now, which we already mentioned in the introduction of the chapter, is that we will not be able to play over the real worldwide internet. This is because of multiple security reasons; you wouldn’t want strangers to have direct access to your computer. However, we will be able to play on the same local network. This means that two computers that are connected to the same router, the same Wi-Fi network, and so forth, will be able to connect to each other in the game! All we’ll have to do is the following:\n\n\t\t\t\t1.  Transfer the complete Godot project to another computer. You can do this any way you like. With a USB, using an online platform such as Dropbox, Google,Drive, or any other means of transferring files.\n\t\t\t\t2.  Make sure both computers are connected to the same local network.\n\t\t\t\t3.  Open the project in the same Godot Engine version as you are using.\n\t\t\t\t4.  Run a debug instance of the game on each computer.\n\t\t\t\t5.  Press play on one computer, making it the server. Use the IP address the server displays to connect to the other clients.\n\n\t\t\tNow, you should be able to play together over the network!\n\t\t\tThat is all for connecting multiple computers. We’ll proceed with a summary of the chapter, but first, here are some additional exercises to solidify our knowledge.\n\t\t\tAdditional exercises – Sharpening the axe\n\n\t\t\t\t1.  When the game ended, we got a menu with a `add_player()` function for each pair that is connected in the `_ready()` function of the `main.gd` script. You can get a list of all the peer IDs with `multiplayer.get_peers()`.\n\n\t\t\tSummary\n\t\t\tThe joy in playing video games is sharing the experience and nothing makes that easier than directly playing together!\n\t\t\tIn this chapter, we started by taking a crash course in computer networking where we learned the basics of how computer networks, such as the internet, work. After this, we started to implement multiplayer into our own game using the `MultiplayerSpawner` and `MultiplayerSynchronizer` node. Lastly, we tried out playing the game over a real network.\n\t\t\tThis chapter marks the end of *Part 2* of the book, where we focused on learning how to develop our game and doing so. Starting from the next chapter, we’ll learn how to export a game, go a little deeper into more advanced programming topics, and see how we can save or load the game.\n\t\t\tQuiz time\n\n\t\t\t\t*   What is the difference between the TCP and UDP?\n\t\t\t\t*   If we take the example of a residence with flats, where the port number is the flat number, what does the IP address represent?\n\t\t\t\t*   What did we use `MultiplayerSpawner` for?\n\t\t\t\t*   What did we use `MultiplayerSynchronizer` for?\n\t\t\t\t*   What function would we use to check whether the current script is running on the server?\n\n```"]