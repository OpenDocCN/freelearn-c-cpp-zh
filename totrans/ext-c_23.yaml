- en: Chapter 23
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 23 章
- en: Build Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建系统
- en: For us programmers, building a project and running its various components is the
    first step in developing a new feature or fixing a reported bug in a project.
    In fact, this is not limited to C or C++; almost any project with a component
    written in a compiled programming language, such as C, C++, Java, or Go, needs to
    be built first.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们程序员来说，构建项目并运行其各种组件是开发新功能或修复项目中报告的错误的第一个步骤。实际上，这不仅仅限于 C 或 C++；几乎任何包含用编译型编程语言（如
    C、C++、Java 或 Go）编写的组件的项目，都需要首先进行构建。
- en: Therefore, being able to build a software project quickly and easily is a fundamental
    demand required by almost any party working in the software production pipeline,
    whether they be developers, testers, integrators, DevOps engineers, or even customer
    support.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，能够快速轻松地构建软件项目是几乎任何在软件生产流程中工作的一方的基本需求，无论是开发者、测试人员、集成人员、DevOps 工程师，甚至是客户支持人员。
- en: More than that, when you join a team as a newbie, the first thing you do is to build
    the code base that you are going to work on. Considering all this, then, it's
    clear that addressing the ability to build a software project is justified, given
    its importance within the software development process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，当你作为一个新手加入一个团队时，你做的第一件事就是构建你将要工作的代码库。考虑到所有这些，很明显，解决构建软件项目的能力是合理的，鉴于它在软件开发过程中的重要性。
- en: Programmers need to build code bases frequently in order to see the results
    of their changes. Building a project with only a few source files seems to be
    easy and fast, but when the number of source files grows (and believe me, it happens),
    building a code base frequently becomes a real obstacle to development tasks.
    Therefore, a proper mechanism for building a software project is crucial.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员需要频繁地构建代码库以查看他们更改的结果。仅使用少量源文件构建项目似乎既简单又快捷，但当源文件数量增加（相信我，这种情况会发生）时，频繁构建代码库就变成了开发任务的真正障碍。因此，一个适当的软件项目构建机制至关重要。
- en: People used to write shell scripts to build a huge number of source files. Even though
    it worked, it took a lot of effort and maintenance to keep the scripts general
    enough to be used in various software projects. Following that, around 1976 at
    Bell Labs, the first (or, at least, one of the earliest ones) *build system*,
    named *Make*, was developed and it was used in internal projects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 人们过去常常编写 shell 脚本来构建大量的源文件。尽管它有效，但需要大量的努力和维护来保持脚本足够通用，以便在各种软件项目中使用。随后，大约在 1976
    年，贝尔实验室开发了第一个（或者至少是其中之一）名为 *Make* 的 *构建系统*，并在内部项目中使用。
- en: After that, Make was used on a massive scale in all C and C++ projects, and even in
    other projects in which C/C++ were n-ot the main languages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，Make 在所有 C 和 C++ 项目中得到了大规模的应用，甚至在其他 C/C++ 不是主要语言的项目中也是如此。
- en: 'In this chapter, we are going to talk about widely used *build systems* and
    *build script generators* for C and C++ projects. As part of this chapter, we
    will talk about the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论广泛使用的 C 和 C++ 项目的 *构建系统* 和 *构建脚本生成器*。作为本章的一部分，我们将讨论以下主题：
- en: First, we will look at what build systems are and what they are good for.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将探讨什么是构建系统以及它们有什么好处。
- en: Then, we will cover what Make is and how Makefiles should be used.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将介绍 Make 是什么以及如何使用 Makefile。
- en: CMake is the next topic. You will read about build script generators and you
    will learn how to write simple `CMakeLists.txt` files.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 是下一个主题。你将了解构建脚本生成器，并学习如何编写简单的 `CMakeLists.txt` 文件。
- en: We'll see what Ninja is and how it is different from Make.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将了解 Ninja 是什么以及它与 Make 的区别。
- en: The chapter will also explore how CMake should be used to generate Ninja build
    scripts.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章还将探讨如何使用 CMake 生成 Ninja 构建脚本。
- en: We'll delve into what Bazel is and how it should be used. You will learn about
    `WORKSPACE` and `BUILD` files and how they should be written in a simple use case.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将深入研究 Bazel 是什么以及如何使用它。你将了解 `WORKSPACE` 和 `BUILD` 文件，以及在一个简单的用例中应该如何编写它们。
- en: Finally, you will be given links to some already-published comparisons of various
    build systems.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你将获得一些已发布的各种构建系统比较的链接。
- en: Note that the build tools used in this chapter all need to be installed on your
    system beforehand. Proper resources and documentation should be available on the
    internet, since these build tools are being used on a massive scale.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中使用的所有构建工具都需要事先安装在你的系统上。由于这些构建工具正在大规模使用，因此互联网上应有适当资源和文档。
- en: In the first section, we are going to explore what a build system actually is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们将探讨构建系统实际上是什么。
- en: What is a build system?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是构建系统？
- en: Put simply, a build system is a set of programs and companion text files that
    collectively build a software code base. Nowadays, every programming language
    has its own set of build systems. For instance, in Java, you have *Ant*, *Maven*,
    *Gradle*, and so on. But what does "building a code base" mean?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，构建系统是一组程序和配套的文本文件，它们共同构建一个软件代码库。如今，每种编程语言都有自己的构建系统。例如，在Java中，有*Ant*、*Maven*、*Gradle*等等。但“构建代码库”究竟是什么意思呢？
- en: Building a code base means producing final products from source files. For example,
    for a C code base, the final products can be executable files, shared object files,
    or static libraries, and the goal of a C build system is to produce these products
    out of the C source files found in the code base. The details of the operations
    needed for this purpose depend heavily on the programming language or the languages
    involved in the code base.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构建代码库意味着从源文件中生成最终产品。例如，对于一个C代码库，最终产品可以是可执行文件、共享对象文件或静态库，而C构建系统的目标就是从代码库中找到的C源文件生成这些产品。为此目的所需的操作细节在很大程度上取决于编程语言或代码库中涉及的语言。
- en: Many modern build systems, especially in projects written in a *JVM language*
    such as Java or Scala, provide an extra service.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代构建系统，尤其是在用*JVM语言*（如Java或Scala）编写的项目中，提供额外的服务。
- en: They do *dependency management* as well. This means that the build system detects
    the dependencies of the target code base, and it downloads all of them and uses
    the downloaded artifacts during the *build process*. This is very handy, especially
    if there are a great many dependencies in a project, which is usually the case
    in big code bases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也进行*依赖管理*。这意味着构建系统检测目标代码库的依赖关系，并下载所有这些依赖关系，在*构建过程*中使用下载的工件。这非常方便，尤其是在项目中有很多依赖关系的情况下，这在大型代码库中通常是常见的情况。
- en: For instance, *Maven* is one of the most famous building systems for Java projects;
    it uses XML files and supports dependency management. Unfortunately, we don't
    have great tools for dependency management in C/C++ projects. Why we haven't got
    Maven-like build systems for C/C++ projects yet is a matter for debate, but the
    fact that they have not been developed yet could be a sign that we don't need
    them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*Maven*是Java项目中最著名的构建系统之一；它使用XML文件并支持依赖管理。不幸的是，我们在C/C++项目中没有很好的依赖管理工具。为什么我们还没有得到类似Maven的构建系统，这是一个值得讨论的问题，但它们尚未开发的事实可能表明我们并不需要它们。
- en: Another aspect of a build system is the ability to build a huge project with
    multiple modules inside. Of course, this is possible using shell scripts and writing
    recursive *Makefiles* that go through any level of modules, but we are talking
    about the intrinsic support of such a demand. Unfortunately, Make does not offer
    this intrinsically. Another famous build tool, CMake, does offer that, however.
    We will talk more about this in the section dedicated to CMake.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统的另一个方面是能够构建包含多个模块的大型项目。当然，这可以通过使用shell脚本和编写递归的*Makefiles*来实现，这些Makefiles可以遍历任何级别的模块，但我们谈论的是对这种需求的原生支持。不幸的是，Make并不提供这种原生支持。另一个著名的构建工具CMake则提供了这种支持。我们将在专门介绍CMake的章节中进一步讨论这个问题。
- en: As of today, many projects still use Make as their default build system, however,
    through using CMake. Indeed, this is one of the points that makes CMake very important,
    and you need to learn it before joining a C/C++ project. Note that CMake is not
    limited to C and C++ and can be used in projects using various programming languages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，许多项目仍然使用Make作为它们的默认构建系统，然而，通过使用CMake。事实上，这是使CMake非常重要的一个点，在加入C/C++项目之前，你需要学习它。请注意，CMake不仅限于C和C++，也可以用于使用各种编程语言的项目。
- en: In the following section, we are going to discuss the Make build system and
    how it builds a project. We will give an example of a multi-module C project and
    use it throughout this chapter to demonstrate how various build systems can be
    used to build this project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Make构建系统以及它是如何构建项目的。我们将给出一个多模块C项目的示例，并在本章中用它来展示如何使用各种构建系统构建这个项目。
- en: Make
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Make
- en: The Make build system uses Makefiles. A Makefile is a text file with the name
    "Makefile" (exactly this and without any extension) in a source directory, and
    it contains *build targets* and commands that tell Make how to build the current
    code base.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Make构建系统使用Makefile。Makefile是一个名为 "Makefile"（确切地说是这个名字，没有任何扩展名）的文本文件，位于源目录中，它包含
    *构建目标* 和命令，告诉Make如何构建当前的代码库。
- en: Let's start with a simple multi-module C project and equip it with Make. The
    following shell box shows the files and directories found in the project. As you
    can see, it has one module named `calc`, and another module named `exec` is using it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的多模块C项目开始，并为其配备Make。以下shell box显示了项目中的文件和目录。如您所见，它有一个名为 `calc` 的模块，还有一个名为
    `exec` 的模块正在使用它。
- en: 'The output of the `calc` module would be a static object library, and the output
    of the `exec` module is an executable file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc`模块的输出将是一个静态对象库，而`exec`模块的输出是一个可执行文件：'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Shell Box 23-1: The files and directories found in the target project'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 23-1：目标项目中的文件和目录
- en: 'If we want to build the above project without using a build system, we must
    run the following commands in order to build its products. Note that we have used
    Linux as the target platform for this project:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在没有使用构建系统的情况下构建上述项目，我们必须按以下顺序运行以下命令。请注意，我们已将Linux作为此项目的目标平台：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Shell Box 23-2: Building the target project'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 23-2: 构建目标项目'
- en: 'As you can see, the project has two artifacts: a static library, `libcalc.a`,
    and an executable file, `ex23_1.out`. If you don''t know how to compile a C project,
    or the preceding commands are strange to you, please read *Chapter 2*, *Compilation
    and Linking*, and *Chapter 3*, *Object Files*.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，项目有两个工件：一个静态库，`libcalc.a`，和一个可执行文件，`ex23_1.out`。如果您不知道如何编译C项目，或者前面的命令对您来说很陌生，请阅读
    *第2章*，*编译和链接*，以及 *第3章*，*目标文件*。
- en: The first command in *Shell Box 23-2* creates a directory named out. This directory
    is supposed to contain all the relocatable object files and the final products.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shell Box 23-2* 中的第一个命令创建了一个名为out的目录。这个目录应该包含所有可重定位目标文件和最终产品。'
- en: Following that, the next three commands use `gcc` to compile the source files
    in the `calc` directory and produce their corresponding relocatable object files.
    Then, these object files are used in the fifth command to produce the static library `libcalc.a`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，接下来的三个命令使用 `gcc` 编译 `calc` 目录中的源文件，并生成它们相应的可重定位目标文件。然后，这些目标文件在第五个命令中使用，以生成静态库
    `libcalc.a`。
- en: Finally, the last two commands compile the file `main.c` from the exec directory
    and finally link it together with `libcalc.a` to produce the final executable
    file, `ex23_1.out`. Note that all these files are put inside the out directory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后两个命令从exec目录编译文件 `main.c`，并将其与 `libcalc.a` 链接在一起，生成最终的执行文件，`ex23_1.out`。请注意，所有这些文件都放在out目录内。
- en: 'The preceding commands can grow as the number of source files grows. We could
    maintain the preceding commands in a shell script file called a *build script*,
    but there are some aspects that we should think about beforehand:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令会随着源文件数量的增加而增长。我们可以将前面的命令保存在一个名为 *build script* 的shell脚本文件中，但有一些方面我们在事先应该考虑：
- en: Are we going to run the same commands on all platforms? There are some details
    that differ in various compilers and environments; therefore, the commands might
    vary from one system to another. In the simplest scenario, we should maintain
    different shell scripts for different platforms. Then, it effectively means that
    our script is not *portable*.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否将在所有平台上运行相同的命令？不同的编译器和环境中有一些细节是不同的；因此，命令可能因系统而异。在最简单的情况下，我们应该为不同的平台维护不同的shell脚本。那么，这意味着我们的脚本不是
    *可移植的*。
- en: What happens when a new directory or a new module is added to the project? Do
    we need to change the build script?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当项目添加新的目录或新的模块时会发生什么？我们需要更改构建脚本吗？
- en: What happens to the build script if we add new source files?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们添加新的源文件，构建脚本会发生什么？
- en: What happens if we need a new product, like a new library or a new executable
    file?
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要一个新的产品，比如一个新的库或一个新的可执行文件，会发生什么？
- en: A good build system should handle all or most of the situations covered above.
    Let's present our first Makefile. This file is going to build the above project
    and generate its products. All the files written for build systems, in this section
    and the following sections, can be used to build this particular project and nothing
    more than that.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的构建系统应该处理上述所有或大多数情况。让我们展示我们的第一个 Makefile。此文件将构建上述项目并生成其产品。本节和以下各节中编写的所有用于构建系统的文件都可以用来构建这个特定的项目，而不会涉及更多。
- en: 'The following code box shows the content of the simplest Makefile that we can
    write for the above project:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了我们可以为上述项目编写的最简单的 Makefile 的内容：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 23-1 [Makefile-very-simple]: A very simple Makefile written for the
    target project'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 23-1 [Makefile-very-simple]：为特定项目编写的非常简单的 Makefile
- en: 'The preceding Makefile contains two targets: `build` and `clean`. Targets have
    a set of commands, which should be executed when the target is summoned. This
    set of commands is called the *recipe* of the target.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 Makefile 包含两个目标：`build` 和 `clean`。目标有一组命令，当调用目标时应该执行这些命令。这组命令被称为目标的 *配方*。
- en: In order to run the commands in a Makefile, we need to use the `make` command.
    You need to tell the `make` command which target to run, but if you leave it empty,
    make always executes the first target.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行 Makefile 中的命令，我们需要使用 `make` 命令。你需要告诉 `make` 命令要运行哪个目标，但如果留空，make 总是执行第一个目标。
- en: 'To build the preceding project using the Makefile, it is enough to copy the
    lines from *Code Box 23-1* to a file named `Makefile` and put it in the root of
    the project. The content of the project''s directory should be similar to what
    we see in the following shell box:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Makefile 构建前面的项目，只需将 *代码框 23-1* 中的行复制到名为 `Makefile` 的文件中，并将其放在项目的根目录下。项目的目录内容应类似于以下
    shell 框中所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 23-3: The files and directories found in the target project after
    adding the Makefile'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 23-3：在添加 Makefile 后在目标项目中找到的文件和目录
- en: Following that, you can just run the make command. The `make` program automatically
    looks for the `Makefile` file in the current directory and executes its first
    target. If we wanted to run the `clean` target, we would have to use the `make
    clean` command. The `clean` target can be used to remove the files produced as
    part of the build process, and this way, we can start a fresh build from scratch.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你只需运行 make 命令。`make` 程序会自动在当前目录中查找 `Makefile` 文件并执行其第一个目标。如果我们想运行 `clean`
    目标，我们必须使用 `make clean` 命令。`clean` 目标可以用来删除构建过程中产生的文件，这样我们就可以从头开始进行全新的构建。
- en: 'The following shell box shows the result of running the `make` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 框显示了运行 `make` 命令的结果：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 23-4: Building the target project using the very simple Makefile'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 23-4：使用非常简单的 Makefile 构建目标项目
- en: You might ask, "What is the difference between a build script (written in a
    shell script), and the above Makefile?" You'd be right to ask this! The preceding
    Makefile does not represent the way we usually use Make to build our projects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“构建脚本（用 shell 脚本编写的）和上面的 Makefile 之间有什么区别？”你提出这个问题是正确的！前面的 Makefile 并不代表我们通常使用
    Make 构建项目的方式。
- en: In fact, the preceding Makefile is a naive usage of the Make build system, and
    it doesn't benefit from the features we know that Make has to offer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，前面的 Makefile 是对 Make 构建系统的天真使用，它没有从 Make 提供的已知特性中受益。
- en: In other words, so far, a Makefile has been remarkably similar to a shell script,
    and we could still just use shell scripting (though, of course, that would involve
    more effort). Now we get to the point where Makefiles become interesting and really
    different.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，到目前为止，Makefile 与 shell 脚本非常相似，我们仍然可以使用 shell 脚本（尽管当然这会涉及更多的工作）。现在我们到了 Makefile
    变得有趣并且真正不同的地方。
- en: 'The following Makefile is still simple, but it introduces more of the aspects
    of the Make build system that we are interested in:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 Makefile 仍然很简单，但它介绍了我们感兴趣的 Make 构建系统的更多方面：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 23-2 [Makefile-simple]: A new, but still simple, Makefile written
    for the target project'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 23-2 [Makefile-simple]：为特定项目编写的新的但仍然简单的 Makefile
- en: As you can see, we can declare a variable in a Makefile and use it in various
    places, just as we have declared CC in the preceding code box. Variables, together
    with conditions in a Makefile, allow us to write flexible build instructions with
    less effort than it takes to write a shell script that would achieve the same flexibility.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以在Makefile中声明一个变量并在多个地方使用它，就像我们在先前的代码框中声明的CC一样。变量，加上Makefile中的条件，允许我们用比编写一个能够实现相同灵活性的shell脚本更少的努力来编写灵活的构建指令。
- en: Another cool feature of Makefiles is the ability to include other Makefiles.
    This way, you can benefit from existing Makefiles that you have written in your
    previous projects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile的另一个酷特性是能够包含其他Makefile。这样，你可以从你之前项目中编写的现有Makefile中受益。
- en: 'As you can see in the preceding Makefile, each Makefile can have several targets.
    Targets start at the beginning of a line and end with a colon, ":". One tab character
    *must* be used to indent all the instructions within a target (the recipe) in
    order to make them recognizable by the `make` program. Here is the cool thing
    about targets: they can be dependent on the other targets.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在先前的Makefile中看到的，每个Makefile可以有多个目标。目标从行的开头开始，以冒号“:”结束。必须使用一个制表符字符来缩进目标（即配方）内的所有指令，以便让`make`程序能够识别。关于目标的一个酷地方是：它们可以依赖于其他目标。
- en: For example, in the preceding Makefile, the `build` target depends on the `prereq`,
    `out /main.o`, and `out/libcalc.a` targets. Then, whenever the `build` target
    is invoked, first, its depending targets will be checked, and if they are not
    yet produced, then those targets will be invoked first. Now, if you pay more attention
    to the targets in the preceding Makefile, you should be able to see the flow of
    execution between targets.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在先前的Makefile中，`build`目标依赖于`prereq`、`out /main.o`和`out/libcalc.a`目标。然后，每当调用`build`目标时，首先会检查其依赖的目标，如果它们尚未生成，那么这些目标将首先被调用。现在，如果你更仔细地观察先前的Makefile中的目标，你应该能够看到目标之间的执行流程。
- en: This is definitely something that we miss in a shell script; a lot of control
    flow mechanisms (loops, conditions, and so on) would be needed to make a shell
    script work like this. Makefiles are less verbose and more declarative, and that
    is why we use them. We want to only declare what needs to be built, and we do
    not need to know about the path it takes to get built. While this is not totally
    achieved by using Make, it is a start to having a fully featured build system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是我们在一个shell脚本中缺少的东西；为了使shell脚本像这样工作，我们需要很多控制流机制（循环、条件等等）。Makefile比shell脚本更简洁，更声明式，这就是我们使用它的原因。我们只想声明需要构建的内容，而不需要知道构建路径。虽然使用Make并不能完全实现这一点，但它是一个拥有完整功能的构建系统的起点。
- en: Another feature of the targets in a Makefile is that if they are referring to
    a file or a directory on the disk, such as `out/multiply.o`, the `make` program
    checks for recent modifications to that file or directory, and if there is no
    modification since the last build, it skips that target. This is also true for
    the dependency of `out/multiply.o`, which is `calc/multiply.c`. If the source
    file, `calc/multiply.c`, has not been changed recently and it has been compiled
    before, it doesn't make sense to compile it again. This is again a feature that
    you cannot simply obtain by writing shell scripts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile中目标的另一个特性是，如果它们引用的是磁盘上的文件或目录，例如`out/multiply.o`，`make`程序会检查该文件或目录的最新修改，如果没有自上次构建以来的修改，它将跳过该目标。这也适用于`out/multiply.o`的依赖项`calc/multiply.c`。如果源文件`calc/multiply.c`最近没有更改并且已经编译过，再次编译它就没有意义了。这又是一个你不能仅仅通过编写shell脚本就能获得的功能。
- en: By having this feature, you only compile the source files that have been modified
    from the last build, and this reduces a huge amount of compilation for sources
    that have not been changed since the last build. Of course, this feature will
    work after having the whole project compiled at least once. After that, only modified
    sources will trigger a compilation or linkage.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个特性，你只编译自上次构建以来已修改的源文件，这大大减少了自上次构建以来未更改的源文件的编译量。当然，这个特性在至少编译整个项目一次之后才会工作。之后，只有修改过的源文件才会触发编译或链接。
- en: Another crucial point in the preceding Makefile is the `calc/calc.h` target.
    As you can see, there are multiple targets, mostly source files, that are dependent
    on the header file, `calc/calc.h`. Therefore, based on the functionality we explained
    before, a simple modification to the header file can trigger multiple compilations
    for the source files depending on that header file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Makefile中还有一个关键点，即`calc/calc.h`目标。正如你所见，有多个目标，主要是源文件，依赖于头文件`calc/calc.h`。因此，根据我们之前解释的功能，对头文件的简单修改可以触发依赖于该头文件的源文件的多次编译。
- en: This is exactly why we try to include only the required header files in a source
    file, and use forward declarations wherever possible instead of inclusion. Forward
    declarations are not usually made in source files because there, we often demand
    access to the actual definition of a structure or a function, but it can be easily
    done in header files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们试图在源文件中只包含所需的头文件，并在可能的情况下使用前向声明而不是包含的原因。前向声明通常不在源文件中制作，因为在那里，我们通常需要访问结构或函数的实际定义，但在头文件中可以轻松完成。
- en: Having a lot of dependencies between header files usually leads to build disasters.
    Even a small modification to a header file included by many other header files,
    and eventually included by many source files, can trigger building the whole project
    or something on that scale. This will effectively reduce the quality of development
    as well as lead to a developer having to wait for minutes between builds.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件之间有很多依赖通常会导致构建灾难。即使是包含在许多其他头文件中，最终被许多源文件包含的一个头文件的微小修改，也可能触发整个项目或类似规模的构建。这将有效降低开发质量，并导致开发者需要在构建之间等待数分钟。
- en: The preceding Makefile is still too verbose. We have to change the targets whenever
    we add a new source file. We expect to change the Makefile upon adding a new source
    file, but not by adding a new target and changing the overall structure of a Makefile.
    This effectively prevents us from reusing the same Makefile in another project
    similar to the current one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Makefile仍然过于冗长。每当我们添加一个新的源文件时，我们必须更改目标。我们期望在添加新的源文件时更改Makefile，而不是通过添加新的目标并改变Makefile的整体结构。这实际上阻止了我们重用相同的Makefile在另一个类似当前项目的项目中。
- en: More than that, many targets follow the same pattern, and we can benefit from
    the *pattern matching* feature available in Make to reduce the number of targets
    and write less code in a Makefile. This is another super feature of Make whose
    effect you cannot easily achieve by writing shell scripts.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，许多目标遵循相同的模式，我们可以利用Make中可用的*模式匹配*功能来减少目标数量，并在Makefile中编写更少的代码。这是Make的另一个超级特性，其效果你很难通过编写shell脚本轻易实现。
- en: 'The following Makefile will be our last one for this project, but still is
    not the best Makefile that a Make professional can write:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Makefile将是本项目中的最后一个，但仍然不是一位Make专家能写出的最佳Makefile：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 23-3 [Makefile-by-pattern]: A new Makefile written for the target
    project that uses pattern matching'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框23-3 [Makefile-by-pattern]：为针对目标项目编写的新Makefile，使用模式匹配
- en: The preceding Makefile uses pattern matching in its targets. The variable `OBJ`
    keeps a list of the expected relocatable object files, and it is used in all other
    places when a list of object files is needed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Makefile在其目标中使用模式匹配。变量`OBJ`保存预期可重定位目标文件的列表，并在需要目标文件列表的所有其他地方使用。
- en: This is not a book on how Make's pattern matching works, but you can see that
    there are a bunch of wildcard characters, such as `%`, `$<`, and `$@`, that are
    used in the patterns.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于Make的模式匹配如何工作的书，但你可以看到，有一些通配符，如`%`、`$<`和`$@`，在模式中使用。
- en: Running the preceding Makefile will produce the same results as the other Makefiles,
    but we can benefit from the various nice features that Make offers, and eventually
    have a reusable and maintainable Make script.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的Makefile将产生与其他Makefile相同的结果，但我们可以从Make提供的各种优秀功能中受益，并最终拥有一个可重用和维护的Make脚本。
- en: 'The following shell box shows how to run the preceding Makefile and what the
    output is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的shell框展示了如何运行前面的Makefile以及输出结果：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 23-5: Building the target project using the final Makefile'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Shell框23-5：使用最终Makefile构建目标项目
- en: In the following sections, we will be talking about CMake, a great tool for
    generating true Makefiles. In fact, a while after Make became popular, a new generation
    of build tools emerged, *build script generators*, which could generate Makefiles
    or scripts from other build systems based on a given description. CMake is one
    of them, and it is probably the most popular one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论CMake，这是一个用于生成真正的Makefiles的出色工具。事实上，在Make变得流行之后，新一代的构建工具出现了，*构建脚本生成器*，可以从给定的描述中生成Makefiles或其他构建系统的脚本。CMake就是其中之一，它可能是最受欢迎的。
- en: '**Note**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'Here is the main link to read more about GNU Make, which is the implementation
    of Make made [for the GNU project: https://www.gnu.org/software/make/manual](https://www.gnu.org/software/make/manual/html_node/index.html)/html_node/index.html.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是阅读更多关于GNU Make的主要链接，它是为GNU项目制作的Make的实现：[GNU Make：https://www.gnu.org/software/make/manual/html_node/index.html](https://www.gnu.org/software/make/manual/html_node/index.html)/html_node/index.html。
- en: CMake – not a build system!
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMake – 并非一个构建系统！
- en: CMake is a build script generator and acts as a generator for other build systems
    such as Make and Ninja. It is a tedious and complex job to write effective and
    cross-platform Makefiles. CMake or similar tools, like *Autotools*, are developed
    to deliver finely tuned cross-platform build scripts such as Makefiles or Ninja
    build files. Note that Ninja is another build system and will be introduced in
    the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: CMake是一个构建脚本生成器，并作为其他构建系统（如Make和Ninja）的生成器。编写有效的跨平台Makefiles是一项繁琐且复杂的工作。CMake或类似工具，如*Autotools*，被开发出来以提供精心调校的跨平台构建脚本，如Makefiles或Ninja构建文件。请注意，Ninja是另一个构建系统，将在下一节中介绍。
- en: '**Note**:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'You can read more [about Autotools here: https://www.gnu.org/software/automake/manual/html_node/Aut](https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html)otools-Introduction.html.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里阅读更多关于Autotools的信息：[Autotools：https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html](https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html)。
- en: Dependency management is also important, which is not delivered through Makefiles.
    These generator tools can also check for installed dependencies and won't generate
    the build scripts if a required dependency is missing from the system. Checking
    the compilers and their versions, and finding their locations, their supported
    features, and so on is all part of what these tools do before generating a build
    script.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理也很重要，这不是通过Makefiles实现的。这些生成工具还可以检查已安装的依赖项，如果系统中缺少所需的依赖项，则不会生成构建脚本。检查编译器和它们的版本，以及找到它们的位置、它们支持的功能等等，都是这些工具在生成构建脚本之前所做的工作的一部分。
- en: Like Make, which looks for a file named `Makefile`, CMake looks for a file named
    `CMakeLists.txt`. Wherever you find this file in a project, it means that CMake
    can be used to generate proper Makefiles. Fortunately, and unlike Make, CMake
    supports nested modules. In other words, you can have multiple `CMakeLists.txt`
    in other directories as part of your project and all of them can be found and
    proper Makefiles would be generated for all of them, just by running CMake in
    the root of your project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Make，它会寻找名为`Makefile`的文件，CMake会寻找名为`CMakeLists.txt`的文件。无论你在项目中找到这个文件的位置，都意味着CMake可以使用来生成适当的Makefiles。幸运的是，与Make不同，CMake支持嵌套模块。换句话说，你可以在其他目录中拥有多个`CMakeLists.txt`文件作为项目的一部分，并且只需在项目根目录中运行CMake，就可以找到它们并为它们生成适当的Makefiles。
- en: 'Let''s continue this section by adding CMake support to our example project.
    For this purpose, we add three `CMakeLists.txt` files. Next, you can see the hierarchy
    of the project after adding these files:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加CMake支持到我们的示例项目来继续本节。为此，我们添加了三个`CMakeLists.txt`文件。接下来，你可以看到添加这些文件后项目的层次结构：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Shell Box 23-6: The project hierarchy after introducing three CMakeLists.txt
    files'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 23-6：引入三个CMakeLists.txt文件后的项目层次结构
- en: 'As you can see, we have three `CMakeLists.txt` files: one in the root directory,
    one in the `calc` directory, and the other one in the `exec` directory. The following
    code box shows the content of the `CMakeLists.txt` file found in the root directory.
    As you can see, it adds subdirectories of `calc` and `exec`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有三个`CMakeLists.txt`文件：一个在根目录中，一个在`calc`目录中，另一个在`exec`目录中。下面的代码框显示了在根目录中找到的`CMakeLists.txt`文件的内容。如你所见，它添加了`calc`和`exec`的子目录。
- en: 'These subdirectories must have a `CMakeLists.txt` file inside and, in fact,
    they do, according to our setup:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子目录必须包含一个`CMakeLists.txt`文件，实际上，根据我们的设置，它们确实包含：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 23-4 [CMakeLists.txt]: The CMakeLists.txt file found in the root directory
    of the project'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 23-4 [CMakeLists.txt]: 在项目根目录中找到的 CMakeLists.txt 文件'
- en: 'The preceding CMake file adds the `calc` directory to the `include` directories
    that will be used by the C compiler when compiling the source files. Like we said before,
    it also adds two subdirectories: `calc` and `exec`. These directories have their
    own `CMakeLists.txt` files that explain how to compile their content. The following
    is the `CMakeLists.txt` file found in the `calc` directory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 CMake 文件将 `calc` 目录添加到编译源文件时编译器将使用的 `include` 目录中。正如我们之前所说的，它还添加了两个子目录：`calc`
    和 `exec`。这些目录有自己的 `CMakeLists.txt` 文件，解释了如何编译它们的内容。以下是在 `calc` 目录中找到的 `CMakeLists.txt`
    文件：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 23-5 [calc/CMakeLists.txt]: The CMakeLists.txt file found in the calc
    directory'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 23-5 [calc/CMakeLists.txt]: 在 calc 目录中找到的 CMakeLists.txt 文件'
- en: As you can see, it is just a simple *target declaration* for the `calc` target,
    meaning that we need to have a static library named `calc` (actually `libcalc.a`
    after build) that should contain the corresponding relocatable object files for
    the source files, `add.c`, `subtract.c`, and `multiply.c`. Note that CMake targets
    usually represent the final products of a code base. Therefore, specifically for
    the `calc` module, we have only one product, which is a static library.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只是一个简单的 *目标声明*，针对 `calc` 目标，这意味着我们需要一个名为 `calc` 的静态库（实际上在构建后为 `libcalc.a`），该库应包含对应于源文件
    `add.c`、`subtract.c` 和 `multiply.c` 的可重定位目标文件。请注意，CMake 目标通常代表代码库的最终产品。因此，对于 `calc`
    模块，我们只有一个产品，即一个静态库。
- en: As you can see, nothing else is specified for the `calc` target. For instance,
    we didn't specify the extension of the static library or the filename of the library
    (even though we could). All other configurations required to build this module
    are either inherited from the parent `CMakeLists.txt` file or have been obtained
    from the default configuration of CMake itself.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于 `calc` 目标没有指定其他内容。例如，我们没有指定静态库的扩展名或库的文件名（尽管我们可以）。构建此模块所需的所有其他配置要么是从父
    `CMakeLists.txt` 文件继承的，要么是从 CMake 本身的默认配置中获得的。
- en: For example, we know that the extension for shared object files is different
    on Linux and macOS. Therefore, if the target is a shared library, there is no
    need to specify the extension as part of the target declaration. CMake is able
    to handle this very platform-specific difference, and the final shared object
    file will have the correct extension based on the platform that it is being built
    on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们知道在 Linux 和 macOS 上共享对象文件的扩展名不同。因此，如果目标是共享库，就没有必要在目标声明中指定扩展名。CMake 能够处理这种非常平台特定的差异，并且最终共享对象文件将根据构建的平台具有正确的扩展名。
- en: 'The following `CMakeLists.txt` file is the one found in the `exec` directory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `CMakeLists.txt` 文件是在 `exec` 目录中找到的：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 23-6 [exec/CMakeLists.txt]: The CMakeLists.txt file found in the exec
    directory'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 23-6 [exec/CMakeLists.txt]: 在 exec 目录中找到的 CMakeLists.txt 文件'
- en: As you can see, the target declared in the preceding `CMakeLists.txt` is an
    executable, and it should be linked to the `calc` target that is already declared
    in another `CMakeLists.txt` file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面 `CMakeLists.txt` 中声明的目标是可执行文件，并且它应该链接到另一个 `CMakeLists.txt` 文件中已经声明的
    `calc` 目标。
- en: This really gives you the power to create libraries in one corner of your project
    and use them in another corner just by writing some directives.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上给了您在项目的某个角落创建库，并在另一个角落使用它们的能力，只需编写一些指令即可。
- en: Now it's time to show you how to generate a Makefile based on the `CMakeLists.txt`
    file found in the root directory. Note that we do this in a separate directory
    named `build` in order to have the resulting relocatable and final object files
    kept separated from the actual sources.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向您展示如何根据根目录中找到的 `CMakeLists.txt` 文件生成 Makefile。请注意，我们在名为 `build` 的单独目录中这样做，以便将生成的可重定位和最终目标文件与实际源文件保持分离。
- en: If you're using a **source control management** (**SCM**) system like *git*,
    you can ignore the `build` directory because it should be generated on each platform
    separately. The only files that matter are the `CMakeLists.txt` files, which are
    always kept in a source control repository.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 **源代码管理**（**SCM**）系统如 *git*，您可以忽略 `build` 目录，因为它应该在每个平台上单独生成。唯一重要的文件是
    `CMakeLists.txt` 文件，这些文件始终保存在源代码控制仓库中。
- en: 'The following shell box demonstrates how to generate build scripts (in this
    case, a Makefile) for the `CMakeLists.txt` file found in the root directory:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell box演示了如何为根目录中找到的`CMakeLists.txt`文件生成构建脚本（在这种情况下，是一个Makefile）：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Shell Box 23-7: Generating a Makefile based on the CMakeLists.txt file found
    in the root directory'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 23-7：基于根目录中找到的CMakeLists.txt文件生成Makefile
- en: As you can see from the output, the CMake command has been able to detect the
    working compilers, their ABI info (for more on ABI, refer to *Chapter 3*, *Object
    Files*), their features, and so on, and finally it has generated a Makefile in
    the `build` directory.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中看到的，CMake命令已经能够检测到工作编译器、它们的ABI信息（关于ABI的更多信息，请参阅*第3章*，*目标文件*）、它们的功能等等，最后它在`build`目录中生成了一个Makefile。
- en: '**Note**:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: In *Shell Box 23-7*, we assumed that we could have had the `build` directory
    in place; therefore, we removed all of its content first.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Shell Box 23-7*中，我们假设我们可以在`build`目录中；因此，我们首先删除了其所有内容。
- en: 'You can see the content of the `build` directory and the generated Makefile:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`build`目录的内容和生成的Makefile：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Shell Box 23-8: Generated Makefile in the build directory'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 23-8：在build目录中生成的Makefile
- en: Now that you've got a Makefile in your `build` directory, you're free to run
    the make command. It will take care of the compilation and display its progress
    nicely for you.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在`build`目录中有了Makefile，您可以自由地运行make命令。它将负责编译，并为您优雅地显示进度。
- en: 'Note that you should be in the `build` directory before running the `make`
    command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在运行`make`命令之前，您应该在`build`目录中：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Shell Box 23-9: Executing the generated Makefile'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 23-9：执行生成的Makefile
- en: Currently, many big projects use CMake, and you can build their sources by using
    more or less the same commands that we've shown in the previous shell boxes. *Vim*
    is one such project. Even CMake itself is built using CMake after having a minimum
    CMake system built by Autotools! CMake now has lots of versions and features and
    it would take a whole book to discuss them in extensive detail.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，许多大型项目使用CMake，您可以使用我们在之前的shell boxes中展示的大致相同的命令来构建它们的源代码。"Vim"就是这样一个项目。甚至CMake本身也是在使用由Autotools构建的最小CMake系统之后，用CMake构建的！CMake现在有很多版本和功能，要详细讨论它们需要一本书。
- en: '**Note**:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'The following link is the official documentation of the latest version of CMake
    and it can help you to get an idea of how it [works and what features it has:
    https://cmake.](https://cmake.org/cmake/help/latest/index.html)org/cmake/help/latest/index.html.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接是最新版本CMake的官方文档，它可以帮助您了解它[如何工作以及它有哪些功能：https://cmake.](https://cmake.org/cmake/help/latest/index.html)org/cmake/help/latest/index.html。
- en: As a final note in this section, CMake can create build script files for Microsoft
    Visual Studio, Apple's Xcode, and other development environments.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，CMake可以为Microsoft Visual Studio、Apple的Xcode和其他开发环境创建构建脚本文件。
- en: In the following section, we will be discussing the Ninja build system, a fast
    alternative to Make that has been gaining momentum recently. We also explain how
    CMake can be used to generate Ninja build script files instead of Makefiles.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Ninja构建系统，这是一个比Make更快的替代方案，最近正逐渐流行起来。我们还将解释如何使用CMake生成Ninja构建脚本文件而不是Makefile。
- en: Ninja
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ninja
- en: Ninja is an alternative to Make. I hesitate to call it a replacement, but it
    is a faster alternative. It achieves its high performance by removing some of
    the features that Make offers, such as string manipulation, loops, and pattern
    matching.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Ninja是Make的替代品。我犹豫是否称它为替代品，但它是更快的替代品。它通过移除Make提供的一些功能（如字符串操作、循环和模式匹配）来实现高性能。
- en: Ninja has less overhead by removing these features, and because of that, it
    is not wise to write Ninja build scripts from scratch.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除这些功能，Ninja减少了开销，因此从头开始编写Ninja构建脚本并不是明智之举。
- en: Writing Ninja scripts can be compared to writing shell scripts, the downsides
    of which we explained in the previous section. That's why it is recommended to use
    it together with a build script generator tool like CMake.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Ninja脚本可以与编写shell脚本相比较，我们之前章节中解释了其缺点。这就是为什么建议与CMake这样的构建脚本生成工具一起使用。
- en: In this section, we show how Ninja can be used when Ninja build scripts are
    generated by CMake. Therefore, in this section, we won't go through the syntax
    of Ninja, as we did for Makefiles. That's because we are not going to write them
    ourselves; instead, we are going to ask CMake to generate them for us.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示当Ninja构建脚本由CMake生成时如何使用Ninja。因此，在本节中，我们不会像对Makefile那样介绍Ninja的语法。这是因为我们不会自己编写它们；相反，我们将要求CMake为我们生成它们。
- en: '**Note**:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'For more information on Ninja syntax, please follow this link: https://ninja-build.org/manual.html#_writing_your_own_ninja_files.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于Ninja语法的知识，请点击此链接：[https://ninja-build.org/manual.html#_writing_your_own_ninja_files](https://ninja-build.org/manual.html#_writing_your_own_ninja_files).
- en: 'As we explained before, it is best to use a build script generator to produce
    Ninja build script files. In the following shell box, you can see how to use CMake
    to generate a Ninja build script, `build.ninja`, instead of a Makefile for our
    target project:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所解释的，最好使用构建脚本生成器来生成Ninja构建脚本文件。在下面的shell框中，您可以查看如何使用CMake生成Ninja构建脚本，`build.ninja`，而不是为我们的目标项目生成Makefile：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Shell Box 23-10: Generating build.ninja based on CMakeLists.txt found in the
    root directory'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 23-10：基于根目录中找到的CMakeLists.txt生成build.ninja
- en: 'As you can see, we have passed the option `-GNinja` to let CMake know that
    we are demanding Ninja build script files instead of Makefiles. CMake generates
    the `build.ninja` file and you can find it in the `build` directory as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经传递了选项`-GNinja`来让CMake知道我们要求的是Ninja构建脚本文件而不是Makefile。CMake生成`build.ninja`文件，您可以在以下`build`目录中找到它：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Shell Box 23-11: Generated build.ninja in the build directory'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 23-11：在build目录中生成的build.ninja
- en: 'To compile the project, it is enough to run the `ninja` command as follows.
    Note that just as the `make` program looks for the `Makefile` in the current directory,
    the `ninja` program looks for `build.ninja` in the current directory:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译项目，只需运行以下`ninja`命令即可。请注意，就像`make`程序在当前目录中查找`Makefile`一样，`ninja`程序在当前目录中查找`build.ninja`：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Shell Box 23-12: Executing generated build.ninja'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 23-12：执行生成的build.ninja
- en: In the following section, we are going to talk about *Bazel*, another build
    system that can be used for building C and C++ projects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将讨论*Bazel*，这是另一个可以用于构建C和C++项目的构建系统。
- en: Bazel
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bazel
- en: Bazel is a build system developed at Google to address the internal need to
    have a fast and scalable build system that can build any project no matter what
    the programming language is. Bazel supports building C, C++, Java, Go, and Objective-C
    projects. More than that, it can be used to build Android and iOS projects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Bazel是Google开发的一个构建系统，旨在解决内部需要有一个快速且可扩展的构建系统，无论编程语言是什么，都能构建任何项目。Bazel支持构建C、C++、Java、Go和Objective-C项目。不仅如此，它还可以用于构建Android和iOS项目。
- en: Bazel became open source around 2015\. It is a build system, so it can be compared
    with Make and Ninja, but not CMake. Almost all of Google's open source projects
    use Bazel for their builds. For example, we can name *Bazel* itself, *gRPC*, *Angular*,
    *Kubernetes*, and *TensorFlow*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Bazel大约在2015年成为开源软件。它是一个构建系统，因此它可以与Make和Ninja进行比较，但不能与CMake相比。几乎所有的Google开源项目都使用Bazel进行构建。例如，我们可以提到*Bazel*本身、*gRPC*、*Angular*、*Kubernetes*和*TensorFlow*。
- en: Bazel is written in Java. It is famous for parallel and scalable builds, and
    it really makes a difference in big projects. Parallel builds are also available
    in Make and Ninja, both by passing the `-j` option (Ninja is parallel by default,
    however).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Bazel是用Java编写的。它以并行和可扩展的构建而闻名，在大项目中确实能带来很大的差异。Make和Ninja都支持并行构建，通过传递`-j`选项（Ninja默认是并行的）。
- en: '**Note**:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'The official docume[ntation of Bazel can be found here: https://docs.bazel.buil](https://docs.bazel.build/versions/master/bazel-overview.html)d/versions/master/bazel-overview.html.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Bazel的官方文档可以在以下链接找到：[https://docs.bazel.build/versions/master/bazel-overview.html](https://docs.bazel.build/versions/master/bazel-overview.html).
- en: 'The way to use Bazel is similar to what we did for Make and Ninja. Bazel requires
    two kinds of files to be present in a project: `WORKSPACE` and `BUILD` files.
    The `WORKSPACE` file should be in the root directory, and the `BUILD` files should
    be put into the modules that should be built as part of the same workspace (or
    project). This is more or less similar to the case with CMake, where we had three
    `CMakeLists.txt` files distributed in the project, but note that, here, Bazel
    itself is the build system and we are not going to generate any build script for
    another build system.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bazel 的方式与我们对 Make 和 Ninja 所做的方式类似。Bazel 需要在一个项目中存在两种类型的文件：`WORKSPACE` 和
    `BUILD` 文件。`WORKSPACE` 文件应该在根目录中，而 `BUILD` 文件应该放入作为同一工作区（或项目）一部分的模块中。这在大约程度上类似于
    CMake 的情况，我们有三份 `CMakeLists.txt` 文件分布在项目中，但请注意，在这里，Bazel 本身是构建系统，我们不会为另一个构建系统生成任何构建脚本。
- en: 'If we want to add the Bazel support to our project, we should obtain the following
    hierarchy in the project:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将 Bazel 支持添加到我们的项目中，我们应该在项目中获得以下层次结构：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Shell Box 23-13: The project hierarchy after introducing Bazel files'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 23-13：引入 Bazel 文件后的项目层次结构
- en: The content of the `WORKSPACE` file would be empty in our example. It is usually used
    to indicate the root of the code base. Note that you need to refer to the documentation
    to see how these files, `WORKSPACE` and `BUILD`, should be propagated throughout
    the code base if you have even more nested and deeper modules.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`WORKSPACE` 文件的内容将是空的。它通常用于指示代码库的根目录。请注意，如果您有更多嵌套和更深的模块，您需要参考文档以了解这些文件（`WORKSPACE`
    和 `BUILD`）应该如何在整个代码库中传播。
- en: 'The content of the `BUILD` file indicates the targets that should be built
    in that directory (or module). The following code box shows the `BUILD` file for
    the `calc` module:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`BUILD` 文件的内容表明了在该目录（或模块）中应该构建的目标。以下代码框显示了 `calc` 模块的 `BUILD` 文件：'
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Code Box 23-7 [calc/BUILD]: The BUILD file found in the calc directory'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 23-7 [calc/BUILD]：calc 目录中找到的 BUILD 文件
- en: As you see, a new target, `calc`, is declared. It is a static library and contains
    the three source files found in the directory. The library is also visible to
    the targets residing in the `exec` directory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一个新的目标 `calc` 被声明。它是一个静态库，包含目录中找到的三个源文件。该库对 `exec` 目录中的目标也是可见的。
- en: 'Let''s look at the `BUILD` file in the exec directory:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 exec 目录中的 `BUILD` 文件：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Code Box 23-8 [exec/BUILD]: The BUILD file found in the exec directory'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 23-8 [exec/BUILD]：exec 目录中找到的 BUILD 文件
- en: 'With the preceding files in their places, we can now run Bazel and build the
    project. You need to go to the project''s root directory. Note that there is no
    need to have a build directory as we did for CMake:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些文件放置到位后，我们现在可以运行 Bazel 并构建项目。您需要进入项目的根目录。请注意，与 CMake 一样，我们不需要有构建目录：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Shell Box 23-14: Building the example project using Bazel'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 23-14：使用 Bazel 构建示例项目
- en: 'Now, if you look at the `bazel-bin` directory found in the root directory,
    you should be able to find the products:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您查看根目录中找到的 `bazel-bin` 目录，您应该能够找到产品：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Shell Box 23-15: The content of bazel-bin after running the build'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 23-15：构建后 bazel-bin 的内容
- en: As you can see in the preceding list, the project is built successfully, and
    the products have been located.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的列表中所见，项目已成功构建，产品已被定位。
- en: In the next section, we are going to close our discussion in this chapter and
    compare various build systems that exist for C and C++ projects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将结束本章的讨论，并比较现有的 C 和 C++ 项目构建系统。
- en: Comparing build systems
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较构建系统
- en: In this chapter, we tried to introduce three of the most well-known and widely
    used build systems. We also introduced CMake as a build script generator. You
    should know that there are other build systems that can be used to build C and
    C++ projects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们尝试介绍了三种最著名和最广泛使用的构建系统。我们还介绍了 CMake 作为构建脚本生成器。您应该知道还有其他构建系统可以用于构建 C 和
    C++ 项目。
- en: Note that your choice of build system should be considered as a long-term commitment;
    if you start a project with a specific build system, it would take significant
    effort to change it to another one.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您对构建系统的选择应被视为一项长期承诺；如果您以特定的构建系统开始一个项目，将其更改为另一个系统将需要大量的努力。
- en: Build systems can be compared based on various properties. Dependency management,
    being able to handle a complex hierarchy of nested projects, build speed, scalability,
    integration with existing services, flexibility to add a new logic, and so on
    can all be used to make a fair comparison. I'm not going to finish this book with
    a comparison of build systems because it is a tedious job to do, and, more than
    that, there are already some great online articles covering the topic.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统可以根据各种属性进行比较。依赖管理、能够处理复杂的嵌套项目层次结构、构建速度、可扩展性、与现有服务的集成、添加新逻辑的灵活性等等，都可以用来进行公平的比较。我不会用构建系统的比较来结束这本书，因为这是一项繁琐的工作，而且更重要的是，已经有了一些关于这个主题的优秀在线文章。
- en: 'A nice Wiki page on Bitbucket that does a pros/cons comparison on available
    build systems, together with build script [generator systems can be found here:
    https://bitbucket.o](https://bitbucket.org/scons/scons/wiki/SconsVsOtherBuildTools)rg/scons/scons/wiki/SconsVsOtherBuildTools.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bitbucket上有一个很好的Wiki页面，对可用的构建系统进行了优缺点比较，以及构建脚本生成系统，可以在这里找到：[https://bitbucket.org/scons/scons/wiki/SconsVsOtherBuildTools](https://bitbucket.org/scons/scons/wiki/SconsVsOtherBuildTools)。
- en: Note that the result of a comparison can be different for anyone. You should
    choose a build system based on your project's requirements and the resources available
    to you. The following links lead to supplementary resources that can [be used
    for further study and comparison:](https://www.reddit.com/r/cpp/comments/8zm66h/an_overview_of_build_systems_mostly_for_c_projects/)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，比较的结果可能因人而异。你应该根据你项目的需求和可用的资源来选择构建系统。以下链接提供了可用于进一步研究和比较的补充资源：[https://www.reddit.com/r/cpp/comments/8zm66h/an_overview_of_build_systems_mostly_for_c_projects/](https://www.reddit.com/r/cpp/comments/8zm66h/an_overview_of_build_systems_mostly_for_c_projects/)
- en: '[https://www.reddit.com/r/cpp/comments/8zm66h/an_overv](https://www.reddit.com/r/cpp/comments/8zm66h/an_overview_of_build_systems_mostly_for_c_projects/)i[ew_of_build_systems_mostly_for_c_projects/](https://github.com/LoopPerfect/buckaroo/wiki/Build-Systems-Comparison)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.reddit.com/r/cpp/comments/8zm66h/an_overview_of_build_systems_mostly_for_c_projects/](https://www.reddit.com/r/cpp/comments/8zm66h/an_overview_of_build_systems_mostly_for_c_projects/)[i](https://github.com/LoopPerfect/buckaroo/wiki/Build-Systems-Comparison)[ew_of_build_systems_mostly_for_c_projects/](https://github.com/LoopPerfect/buckaroo/wiki/Build-Systems-Comparison)'
- en: '[https://github.com/LoopPer](https://github.com/LoopPerfect/buckaroo/wiki/Build-Systems-Comparison)f[ect/buckaroo/wiki/Build-Systems-Comparison](https://medium.com/@julienjorge/an-overview-of-build-systems-mostly-for-c-projects-ac9931494444)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/LoopPer](https://github.com/LoopPerfect/buckaroo/wiki/Build-Systems-Comparison)f[ect/buckaroo/wiki/Build-Systems-Comparison](https://medium.com/@julienjorge/an-overview-of-build-systems-mostly-for-c-projects-ac9931494444)'
- en: '[https://medium.com/@julienjorge/an-overview-of-build](https://medium.com/@julienjorge/an-overview-of-build-systems-mostly-for-c-projects-ac9931494444)-systems-mostly-for-c-projects-ac9931494444'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://medium.com/@julienjorge/an-overview-of-build](https://medium.com/@julienjorge/an-overview-of-build-systems-mostly-for-c-projects-ac9931494444)-systems-mostly-for-c-projects-ac9931494444'
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed the common build tools available for building
    a C or C++ project. As part of this chapter:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了用于构建C或C++项目的常用构建工具。作为本章的一部分：
- en: We discussed the need for a build system.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了构建系统的必要性。
- en: We introduced Make, one of the oldest build systems available for C and C++
    projects.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了Make，这是可用于C和C++项目的最古老的构建系统之一。
- en: We introduced Autotools and CMake, two famous build script generators.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了Autotools和CMake，两种著名的构建脚本生成器。
- en: We showed how CMake can be used to generate the required Makefiles.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了如何使用CMake生成所需的Makefiles。
- en: We discussed Ninja and we showed how CMake can be used to generate Ninja build
    scripts.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了Ninja，并展示了如何使用CMake生成Ninja构建脚本。
- en: We demonstrated how Bazel can be used to build a C project.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了如何使用Bazel构建C项目。
- en: Finally, we provided some links to a number of online discussions regarding
    the comparison of various build systems.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们提供了一些链接，指向关于各种构建系统比较的在线讨论。
- en: Epilogue
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结语
- en: And the final words ...
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的话 ...
- en: If you are reading this, it means that our journey has come to an end! We went
    through several topics and concepts as part of this book, and I hope that the
    journey has made you a better C programmer. Of course, it cannot give you the
    experience; you must obtain that by working on various projects. The methods and
    tips we discussed in this book will ramp up your level of expertise, and this
    will enable you to work on more serious projects. Now you know more about software
    systems, from a broader point of view, and possess a top-notch knowledge about
    the internal workings.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这篇文档，这意味着我们的旅程已经结束！作为本书的一部分，我们探讨了几个主题和概念，我希望这次旅程能让你成为一个更好的C程序员。当然，它不能给你带来经验；你必须通过参与各种项目来获得。本书中讨论的方法和技巧将提升你的专业水平，这将使你能够参与更复杂的项目。现在你对软件系统有了更深入的了解，从更广阔的角度来看，并且对内部运作有了顶尖的知识。
- en: Though this book was heavier and lengthier than your usual read, it still could
    not cover all the topics found within C, C++, and system programming. Therefore,
    a weight remains on my shoulders; the journey is not yet done! I would like to
    continue to work on more Extreme topics, maybe more specific areas, such as Asynchronous
    I/O, Advanced Data Structures, Socket Programming, Distributed Systems, Kernel
    Development, and Functional Programming, in time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书比你的常规阅读更厚重、更长，但它仍然无法涵盖C、C++和系统编程中所有的话题。因此，我肩上仍然有一份责任；旅程还没有结束！我希望能继续研究更多极端话题，也许更具体的领域，比如异步I/O、高级数据结构、套接字编程、分布式系统、内核开发和函数式编程，在适当的时候。
- en: Hope to see you again on the next journey!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在下次旅程中再次见到你！
- en: Kamran
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Kamran
