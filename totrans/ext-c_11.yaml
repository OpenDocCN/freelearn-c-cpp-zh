- en: Chapter 11
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章
- en: System Calls and Kernels
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调用和内核
- en: In the previous chapter, we discussed the history of Unix and its onion-like
    architecture. We also introduced and talked about the POSIX and SUS standards
    governing the shell ring in Unix, before explaining how the C standard library
    is there to provide common functionalities exposed by a Unix-compliant system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 Unix 的历史及其洋葱式架构。我们还介绍了 POSIX 和 SUS 标准，这些标准规范了 Unix 中 shell 环的运作，然后在解释
    C 标准库如何提供 Unix 兼容系统暴露的常用功能之前。
- en: In this chapter, we are going to continue our discussion of the *system call
    interface* and the Unix *kernel*. This will give us a complete insight into how
    a Unix system works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续讨论 *系统调用接口* 和 Unix *内核*。这将让我们对 Unix 系统的工作方式有一个完整的了解。
- en: After reading this chapter, you will be able to analyze the system calls a program
    invokes, you will be able to explain how the process lives and evolves inside
    the Unix environment, and you will also be able to use system calls directly or
    through libc. We'll also talk about Unix kernel development and show you how you
    can add a new system call to the Linux kernel and how it can be invoked from the
    shell ring.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，你将能够分析程序调用的系统调用，你将能够解释进程如何在 Unix 环境中生存和演变，你还将能够直接或通过 libc 使用系统调用。我们还将讨论
    Unix 内核开发，并展示你如何向 Linux 内核添加新的系统调用以及如何从 shell 环中调用它。
- en: In the last part of this chapter, we will talk about *monolithic* kernels and
    *microkernels* and how they differ. We will introduce the Linux kernel as a monolithic
    kernel, and we will write a *kernel module* for it that can be loaded and unloaded
    dynamically.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将讨论 *单一内核* 和 *微内核* 以及它们之间的区别。我们将介绍 Linux 内核作为一个单一内核，并为其编写一个可以动态加载和卸载的
    *内核模块*。
- en: Let's start this chapter by talking about system calls.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以讨论系统调用开始本章。
- en: System calls
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调用
- en: In the previous chapter, we briefly explained what a system call is. In this
    section, we want to take a deeper look and explain the mechanism that is used
    behind system calls to transfer the execution from a user process to the kernel
    process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要解释了什么是系统调用。在本节中，我们想要更深入地探讨并解释系统调用背后的机制，即从用户进程到内核进程的执行转移机制。
- en: However, before we do that, we need to explain a bit more about both the kernel
    space and the user space, because this will be beneficial in our understanding
    of how the system calls work behind the scenes. We will also write a simple system
    call to gain some ideas about kernel development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们这样做之前，我们需要对内核空间和用户空间进行更多的解释，因为这将有助于我们理解系统调用在幕后是如何工作的。我们还将编写一个简单的系统调用来获得一些关于内核开发的思路。
- en: What we're about to do is crucial if you want to be able to write a new system
    call when you're going to add a new functionality into the kernel that wasn't
    there before. It also gives you a better understanding of the kernel space and
    how it differs from the user space because, in reality, they are very different.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将要做的事情对于你想要在向内核添加之前不存在的新功能时编写新的系统调用至关重要。这也让你更好地理解内核空间以及它与用户空间的不同，因为实际上，它们是非常不同的。
- en: System calls under the microscope
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用的显微镜下
- en: As we discussed in the previous chapter, a separation happens when moving from
    the shell ring into the kernel ring. You find that whatever resides in the first
    two rings, the user application and the shell, belongs to the user space. Likewise,
    what ever appears in the kernel ring or the hardware ring belongs to the kernel
    space.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的，当从 shell 环移动到内核环时，会发生分离。你会发现位于前两个环中的任何内容，即用户应用程序和 shell，都属于用户空间。同样，出现在内核环或硬件环中的任何内容都属于内核空间。
- en: There is one rule about this separation, and that is nothing in the two most
    inner rings – kernel and hardware – can be accessed directly by the user space.
    In other words, no processes in the user space can access the hardware, internal
    kernel data structures, and algorithms directly. Instead, they should be accessed
    via system calls.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种分离有一条规则，那就是在两个最内层的环——内核和硬件——中的任何内容都不能被用户空间直接访问。换句话说，用户空间中的任何进程都不能直接访问硬件、内部内核数据结构和算法。相反，它们应该通过系统调用进行访问。
- en: That said you may think that it seems a little contradictory to whatever you
    know and have experienced about Unix-like operating systems, such as Linux. If
    you don't see the issue, let me explain it to you. It seems to be a contradiction
    because, for instance, when a program reads some bytes from a network socket,
    it is not the program that actually reads those bytes from the network adapter.
    It is the kernel that reads the bytes and copies them to the user space, and then
    the program can pick them up and use them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你可能认为这与你对类 Unix 操作系统（如 Linux）所知和所经历的东西似乎有些矛盾。如果你看不到问题，让我为你解释一下。这似乎是一种矛盾，因为例如，当程序从网络套接字读取一些字节时，实际上读取这些字节的不是程序，而是内核读取字节并将它们复制到用户空间，然后程序可以取回并使用它们。
- en: We can clarify this by going through all the steps taken from the user space
    to the kernel space and vice versa in an example. When you want to read a file
    from a hard disk drive, you write a program in the user application ring. Your
    program uses a libc I/O function called `fread` (or another similar function)
    and will eventually be running as a process in the user space. When the program
    makes a call to the `fread` function, the implementation behind libc gets triggered.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个例子来明确这一点，即从用户空间到内核空间以及相反方向的所有步骤。当你想从硬盘驱动器读取文件时，你会在用户应用程序环中编写一个程序。你的程序使用一个名为`fread`的
    libc I/O 函数（或另一个类似函数），最终作为用户空间中的进程运行。当程序调用`fread`函数时，libc背后的实现被触发。
- en: So far, everything is still in the user process. Then, the `fread` implementation
    eventually invokes a system call, while `fread` is receiving an already opened
    *file descriptor* as the first argument, the address of a buffer allocated in
    the process's memory, which is in the user space, as the second argument, and
    the length of the buffer as the third argument.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切仍然在用户进程中。然后，`fread`实现最终调用一个系统调用，而`fread`接收一个已经打开的*文件描述符*作为第一个参数，作为第二个参数，是分配在进程内存中的缓冲区的地址，该缓冲区位于用户空间，作为第三个参数，是缓冲区的长度。
- en: When the system call is triggered by the libc implementation, the kernel gets
    control of execution on behalf of the user process. It receives the arguments
    from the user space and keeps them in the kernel space. Then, it is the kernel
    that reads from the file by accessing the filesystem unit inside the kernel (as
    can be seen in *Figure 10-5* in the previous chapter).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统调用由 libc 实现触发时，内核代表用户进程控制执行。它从用户空间接收参数并将它们保存在内核空间中。然后，内核通过访问内核内部的文件系统单元来读取文件（如前一章中*图10-5*所示）。
- en: When the `read` operation is complete in the kernel ring, the read data will
    be copied to the buffer in the user space, as specified by the second augment
    when calling the `fread` function, and the system call leaves and returns the
    control of execution to the user process. Meanwhile, the user process usually
    waits while the system call is busy with the operation. In this case, the system
    call is blocking.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核环中的`read`操作完成时，读取的数据将被复制到由调用`fread`函数时指定的用户空间中的缓冲区，系统调用随后离开并将执行控制权返回给用户进程。同时，用户进程通常会在系统调用忙于操作时等待。在这种情况下，系统调用是阻塞的。
- en: 'There are some important things to note about this scenario:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种情况，有一些重要的事情需要注意：
- en: We only have one kernel that performs all the logic behind system calls.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只有一个内核执行系统调用背后的所有逻辑。
- en: If the system call is *blocking*, when that system call is in progress, the
    caller user process has to wait while the system call is busy and has not finished.
    Conversely, if the system call is *non-blocking*, the system call returns very
    quickly, but the user process has to make extra system calls to check if the results
    are available.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系统调用是*阻塞的*，当系统调用正在进行时，调用者用户进程必须等待，直到系统调用繁忙并完成。相反，如果系统调用是*非阻塞的*，系统调用会非常快地返回，但用户进程必须进行额外的系统调用以检查结果是否可用。
- en: Arguments together with input and output data will be copied from/to user space.
    Since the actual values are copied, system calls are supposed to be designed in
    such a way that they accept tiny variables and pointers as input arguments.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数以及输入和输出数据将从用户空间复制到/从用户空间。由于实际值被复制，系统调用应该设计成接受小的变量和指针作为输入参数。
- en: The kernel has full privileged access to all resources of a system. Therefore,
    there should be a mechanism to check if the user process is able to make such
    a system call. In this scenario, if the user is not the owner of the file, `fread`
    should fail with an error about the lack of required permissions.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核可以完全访问系统的所有资源。因此，应该有一个机制来检查用户进程是否能够执行这样的系统调用。在这种情况下，如果用户不是文件的所有者，`fread` 应该因为缺少所需权限而失败。
- en: A similar separation exists between the memory dedicated to the user space and
    the kernel space. User processes can only access the user space memory. Multiple
    transfers might be required in order to fulfil a certain system call.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间和内核空间之间也存在类似的分离。用户进程只能访问用户空间内存。为了完成某个系统调用，可能需要多次传输。
- en: Before we move onto the next section, I want to ask you a question. How does
    a system call transfer the control of execution to the kernel? Take a minute to
    think about that, because in the next section we're going to work on the answer
    to it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，我想问你一个问题。系统调用是如何将执行控制权传递给内核的？花一分钟时间思考一下，因为在下一节中，我们将努力找到这个问题的答案。
- en: Bypassing standard C – calling a system call directly
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 越过标准 C – 直接调用系统调用
- en: Before answering the raised question, let's go through an example that bypasses
    the standard C library and calls a system call directly. In other words, the program
    calls a system call without going through the shell ring. As we have noted before,
    this is considered an anti-pattern, but when certain system calls are not exposed
    through libc, a user application can call the system calls directly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答提出的问题之前，让我们通过一个绕过标准 C 库并直接调用系统调用的示例。换句话说，程序调用系统调用而不通过 shell 环。正如我们之前所提到的，这被认为是一种反模式，但当某些系统调用没有通过
    libc 暴露时，用户应用程序可以直接调用系统调用。
- en: In every Unix system, there is a specific method for invoking system calls directly.
    For example, in Linux, there is a function called `syscall` located in the `<sys/syscall.h>`
    header file that can be used for this purpose.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 Unix 系统中，都有一个特定的方法可以直接调用系统调用。例如，在 Linux 中，有一个名为 `syscall` 的函数，位于 `<sys/syscall.h>`
    头文件中，可以用于此目的。
- en: 'The following code box, *example 11.1*, is a different Hello World example
    that does not use libc to print to the standard output. In other words, the example
    does not use the `printf` function that can be found as part of shell ring and
    the POSIX standard. Instead, it invokes a specific system call directly, hence
    the code is only compilable on Linux machines, not other Unix systems. In other
    words, the code is not portable between various Unix flavors:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框，*示例 11.1*，是一个不同的 Hello World 示例，它不使用 libc 将内容打印到标准输出。换句话说，该示例不使用作为 shell
    环和 POSIX 标准一部分的 `printf` 函数。相反，它直接调用特定的系统调用，因此代码只能在 Linux 机器上编译，不能在其他 Unix 系统上编译。换句话说，代码在各种
    Unix 版本之间不可移植：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 11-1 [ExtremeC_examples_chapter11_1.c]: A different Hello World example
    that invokes the write system call directly'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 11-1 [ExtremeC_examples_chapter11_1.c]：一个不同的 Hello World 示例，它直接调用 write
    系统调用
- en: As the first statement in the preceding code box, we have to define `_GNU_SOURCE`
    to indicate that we are going to use parts of the **GNU C Library** (**glibc**)
    that are not part of POSIX, or SUS standards. This breaks the portability of the
    program, and because of that, you may not be able to compile your code on another
    Unix machine. In the second `include` statement, we include one of the glibc-specific
    header files that doesn't exist in other POSIX systems using implementations other
    than glibc as their main libc backbone.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前面代码框中的第一个语句，我们必须定义 `_GNU_SOURCE` 以指示我们将使用不属于 POSIX 或 SUS 标准的 **GNU C 库**（**glibc**）的部分。这会破坏程序的可移植性，因此，你可能无法在其他
    Unix 机器上编译你的代码。在第二个 `include` 语句中，我们包含了一个 glibc 特定的头文件，该文件在其他使用 glibc 作为主要 libc
    核心的 POSIX 系统中不存在。
- en: In the `main` function, we make a system call by calling the `syscall` function.
    First of all, we have to specify the system call by passing a number. This is
    an integer that refers to a specific system call. Every system call has its own
    unique specific *system call number* in Linux.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们通过调用 `syscall` 函数来执行系统调用。首先，我们必须通过传递一个数字来指定系统调用。这是一个整数，它指向一个特定的系统调用。每个系统调用在
    Linux 中都有一个独特的特定 *系统调用号*。
- en: In the example code, the `__R_write` constant has been passed instead of the
    system call number, and we don't know its exact numerical value. After looking
    it up in the `unistd.h` header file, apparently 64 is the number of the `write`
    system call.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: After passing the system call number, we should pass the arguments that are
    required for the system call.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Note that, despite the fact that the preceding code is very simple, and it just
    contains a simple function call, you should know that `syscall` is not an ordinary
    function. It is an assembly procedure that fills some proper CPU registers and
    actually transfers the control of execution from the user space to the kernel
    space. We will talk about this shortly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'For `write`, we need to pass three arguments: the file descriptor, which here
    is `1` to refer to the standard output; the second is the *pointer to a buffer*
    allocated in the user space; and finally, the *length of bytes* that should be
    copied from the buffer.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of *example 11.1*, compiled and run in Ubuntu 18.04.1
    using `gcc`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Shell Box 11-1: The output of example 11.1'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to use `strace`, introduced in the previous chapter, to see
    the actual system calls that *example 11.1* has invoked. The output of `strace`,
    shown as follows, demonstrates that the program has invoked the desired system
    call:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Shell Box 11-2: The output of strace while running example 11.1'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: As you can see as a bold in *Shell Box 11-2*, the system call has been recorded
    by `strace`. Look at the return value, which is `13`. It means that the system
    call has successfully written 13 bytes into the given file, the standard output
    in this case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: A user application should never try to use system calls directly. There are
    usually steps that should be taken before and after calling the system call. Libc
    implementations do these steps. When you're not going to use libc, you have to
    do these steps yourself, and you must know that these steps vary from one Unix
    system to another.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Inside the syscall function
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, what happens inside the `syscall` function? Note that the current
    discussion is only applicable to glibc and not to the rest of the libc implementations.
    Firstly, we need to find `syscall` in glibc. Here is the link to the `syscall`
    [definition: https://github.com/lattera/glibc/blob/master/sysdeps/unix/sysv/linux/x86](https://github.com/lattera/glibc/blob/master/sysdeps/unix/sysv/linux/x86_64/syscall.S)_64/syscall.S.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: If you open the preceding link in a browser, you will see that this function
    is written in assembly language.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Assembly language can be used together with C statements in a C source file.
    In fact, this is one of the great features of C that makes it suitable for writing
    an operating system. For the `syscall` function, we have a declaration written
    in C, but the definition is in assembly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the source code you find as part of `syscall.S`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code Box 11-2: The definition of the syscall function in glibc'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: These instructions are short and simple despite the fact that making a system
    call in this way seems to be more complex. The usage comment explains that a system
    call in glibc can be provided up to six arguments in each invocation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管以这种方式进行系统调用似乎更复杂，但这些指令简短且简单。使用注释解释说，在glibc中，每次调用可以提供多达六个参数的系统调用。
- en: What this means is that if the underlying kernel supports system calls with
    more than six arguments, glibc cannot provide certain kernel functionalities,
    and it should be changed to support them. Fortunately, six arguments have been
    fine in most cases, and for system calls that need more than six arguments, we
    can pass pointers to structure variables allocated in the user space memory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果底层内核支持具有超过六个参数的系统调用，glibc无法提供某些内核功能，并且应该修改以支持它们。幸运的是，在大多数情况下，六个参数已经足够了，对于需要超过六个参数的系统调用，我们可以传递在用户空间内存中分配的结构变量的指针。
- en: In the preceding code box, after the `movq` instructions, the assembly code
    calls the `syscall` subroutine. It simply generates an *interrupt*, which allows
    a specific part of the kernel, which is waiting for such interrupts, to wake up
    and handle the interrupt.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码框中，在`movq`指令之后，汇编代码调用`syscall`子程序。它只是生成一个*中断*，这允许内核中等待此类中断的特定部分唤醒并处理中断。
- en: As you can see on the first line of the `syscall` procedure, the system call
    number is moved to the `%rax` register. On the following lines, we are copying
    other arguments into the different registers. When the system call interrupt is
    fired, the kernel's interrupt handler unit picks up the call and gathers the system
    call number and the arguments. Then it searches its *system call table* to find
    the appropriate function that should be invoked on the kernel side.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在`syscall`过程的第 一行所看到的，系统调用号被移动到`%rax`寄存器。在接下来的几行中，我们将其他参数复制到不同的寄存器中。当系统调用中断被触发时，内核的中断处理单元接收到调用并收集系统调用号和参数。然后它搜索其*系统调用表*以找到应在内核端调用的适当函数。
- en: An interesting point is that, by the time the interrupt handler is being executed
    in the CPU, the user code that has initiated the system call has left the CPU,
    and the kernel is doing the job. This is the main mechanism behind system calls.
    When you initiate a system call, the CPU changes its mode, and the kernel instructions
    are fetched into the CPU and the user space application is no longer being executed.
    That's basically why we say that the kernel performs the logic behind the system
    call on behalf of the user application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的观点是，当中断处理程序在CPU中执行时，已经离开CPU的发起系统调用的用户代码，内核正在执行这项工作。这是系统调用背后的主要机制。当你发起一个系统调用时，CPU会改变其模式，内核指令被加载到CPU中，用户空间应用程序不再被执行。这就是我们说内核代表用户应用程序执行系统调用逻辑背后的逻辑的基本原因。
- en: In the next section, we're going to give an example of this by writing a system
    call that prints a hello message. It can be considered a progressive version of
    *example 11.1* that accepts an input string and returns a greeting string.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过编写一个打印hello消息的系统调用来给出一个例子。它可以被认为是*示例11.1*的渐进版本，它接受一个输入字符串并返回一个问候字符串。
- en: Add a system call to Linux
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Linux添加系统调用
- en: In this section, we are going to add a new system call to the system call table
    of an existing Unix-like kernel. This may be the first time that most of you reading
    this book have written C code that is supposed to be run within the kernel space.
    All of the past examples that we wrote in previous chapters, and almost all of
    the codes that we will write in future chapters, run in the user space.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向现有类Unix内核的系统调用表中添加一个新的系统调用。这可能是有很多读者阅读这本书时第一次编写的应该在内核空间运行的C代码。我们之前章节中编写的所有示例，以及我们将在未来章节中编写的几乎所有代码，都是在用户空间运行的。
- en: In fact, most of the programs we write are meant to be running in the user space.
    In fact, this is what we call *C programming* or *C development*. However, if
    we are going to write a C program that is supposed to run in the kernel space,
    we use a different name; we call it *kernel development*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们编写的绝大多数程序都是打算在用户空间运行的。事实上，这就是我们所说的*C编程*或*C开发*。然而，如果我们打算编写一个应该在内核空间运行的C程序，我们使用一个不同的名称；我们称之为*内核开发*。
- en: We are going through the next example, *example 11.2*, but before that we need
    to explore the kernel environment to see how it is different from the user space.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在分析下一个示例，*示例 11.2*，但在那之前，我们需要探索内核环境，看看它与用户空间有何不同。
- en: Kernel development
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核开发
- en: This section will be beneficial to those of you who are seeking to be a kernel
    developer or a security researcher in the field of operating systems. In the first
    part, before jumping to the system call itself, we want to explain the differences
    between the kernel development and the ordinary C development.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本节对那些希望成为内核开发者或操作系统领域的安全研究员的你们来说将是有益的。在第一部分，在跳转到系统调用本身之前，我们想要解释内核开发与普通 C 开发之间的差异。
- en: The development of kernels is different from the development of ordinary C programs
    in a number of ways. Before looking at the differences, one thing we should note
    is that C development usually takes place in the user space.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的开发与普通 C 程序的开发在许多方面都不同。在探讨这些差异之前，我们应该注意的一点是，C 开发通常发生在用户空间。
- en: 'In the following list, we have provided six of the key differences between
    the development efforts happening in the kernel and the user space:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们提供了内核和用户空间开发过程中六个关键差异：
- en: There is only one kernel process that runs everything. This simply means that
    if your code causes a crash in the kernel, you probably need to reboot the machine
    and let the kernel become initialized again. So, with the kernel process, the
    development cost is very high, and you cannot try various solutions without rebooting
    the machine, which you can do very easily for user space programs while working
    on them. Upon a crash in the kernel, a *kernel crash dump* is generated, which
    can be used to diagnose the cause.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个内核进程在运行一切。这仅仅意味着如果你的代码在内核中导致崩溃，你可能需要重新启动机器并让内核重新初始化。因此，与内核进程相关，开发成本非常高，你不能在不重启机器的情况下尝试各种解决方案，而你可以在处理用户空间程序时轻松地这样做。在内核崩溃时，会生成一个*内核崩溃转储*，可以用来诊断原因。
- en: In the kernel ring, there is no C standard library like glibc! In other words,
    this is a realm in which SUS and POSIX standards are no longer valid. So, you
    cannot include any libc header files, such as `stdio.h` or `string.h`. In this
    case, you have a dedicated set of functions that should be used for various operations.
    These functions are usually located in *kernel headers* and can be different from
    one Unix flavor to another because there is no standardization in this field.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内核环中没有像 glibc 这样的 C 标准库！换句话说，这是一个 SUS 和 POSIX 标准不再有效的领域。因此，你不能包含任何 libc 头文件，例如
    `stdio.h` 或 `string.h`。在这种情况下，你有一组专门用于各种操作的函数。这些函数通常位于 *内核头文件* 中，并且可能因 Unix 版本的不同而不同，因为在这个领域没有标准化。
- en: As an example, if you are doing kernel development in Linux, you may use `printk`
    to write a message into the kernel's *message buffer*. However, in FreeBSD, you
    need to use the `printf` family of functions, which are different from the libc
    `printf` functions. You will find these `printf` functions in the `<sys/system.h>`
    header file in a FreeBSD system. The equivalent function while doing XNU kernel
    development is `os_log`. Note that XNU is the kernel of macOS.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果你在 Linux 上进行内核开发，你可能使用 `printk` 将消息写入内核的 *消息缓冲区*。然而，在 FreeBSD 中，你需要使用 `printf`
    函数族，这些函数与 libc 的 `printf` 函数不同。你可以在 FreeBSD 系统的 `<sys/system.h>` 头文件中找到这些 `printf`
    函数。在 XNU 内核开发中对应的函数是 `os_log`。请注意，XNU 是 macOS 的内核。
- en: You can read or modify files in the kernel, but not using libc functions. Each
    Unix kernel has its own method of accessing files inside the kernel ring. This
    is the same for all functionalities exposed through libc.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在内核中读取或修改文件，但不能使用 libc 函数。每个 Unix 内核都有自己的方法来访问内核环内的文件。这对于通过 libc 暴露的所有功能都是相同的。
- en: You have full access to the physical memory and many other services in the kernel
    ring. So, writing secure and reliable code is very important.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以完全访问内核环中的物理内存和许多其他服务。因此，编写安全可靠代码非常重要。
- en: There is no system call mechanism in the kernel. System calls are the main user
    space mechanism to enable user processes to communicate with the kernel ring.
    So, once you're in the kernel, there is no need for it.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核中没有系统调用机制。系统调用是用户空间中使用户进程能够与内核环通信的主要机制。因此，一旦你处于内核中，就不再需要它。
- en: The kernel process is created by copying the kernel image into the physical
    memory, performed by the *boot loader*. You cannot add a new system call without
    having to create the kernel image from scratch and reload it again by rebooting
    the system. In kernels that support *kernel modules*, you can easily add or remove
    a module when the kernel is up and running, but you cannot do the same with system
    calls.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核进程是通过将内核镜像复制到物理内存中创建的，由 *引导加载程序* 执行。您不能在不从头创建内核镜像并重新引导系统重新加载的情况下添加新的系统调用。在支持
    *内核模块* 的内核中，您可以在内核运行时轻松添加或删除模块，但您不能对系统调用做同样的事情。
- en: As you can see with the points we've just listed, kernel development takes place
    in a different flow compared to the ordinary C development. Testing written logic
    is not an easy task, and buggy code can cause a system crash.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所看到的，与普通的 C 开发相比，内核开发发生在不同的流程中。测试编写的逻辑不是一件容易的事情，有缺陷的代码可能导致系统崩溃。
- en: In the next section, we will do our first kernel development by adding a new
    system call. We're doing this not because it's common to add a system call when
    you want to introduce a new functionality into the kernel, but we're going to
    give it a try in order to get familiar with kernel development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过添加一个新的系统调用来进行我们的第一次内核开发。我们这样做并不是因为当你想在内核中引入新的功能时，添加系统调用是常见的，但我们是想通过尝试来熟悉内核开发。
- en: Writing a Hello World system call for Linux
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 Linux 编写一个 Hello World 系统调用
- en: In this section, we're going to write a new system call for Linux. There are
    many great sources on the internet that explain how to add a system call to an
    existing Linux kernel, but the following forum post, *Adding a Hello World System
    Call to Linux Kernel* – available at https://medium.com/anubhav-shrimal/adding-a-hello-world-system-call-to-linux-kernel-dad32875872
    – was used as the basis to build my own system call in Linux.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为 Linux 编写一个新的系统调用。互联网上有许多优秀的资源解释了如何向现有的 Linux 内核添加系统调用，但以下论坛帖子，*将 Hello
    World 系统调用添加到 Linux 内核* – 可在 https://medium.com/anubhav-shrimal/adding-a-hello-world-system-call-to-linux-kernel-dad32875872
    找到 – 被用作构建我在 Linux 中自己的系统调用的基础。
- en: '*Example 11.2* is an advanced version of *example 11.1* that uses a different
    and custom system call, which we are going to write in this section. The new system
    call receives four arguments. The first two are for the input name and the second
    two are for the greeting string output. Our system call accepts a name using its
    first two arguments, one `char` pointer addressing an already allocated buffer
    in the user space and one integer as the buffer''s length, and returns the greeting
    string using its second two arguments, a pointer that is different from the input
    buffer and is again allocated in the user space and another integer as its length.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11.2* 是 *示例 11.1* 的一个高级版本，它使用了一个不同且定制的系统调用，我们将在本节中编写。新的系统调用接收四个参数。前两个参数用于输入名称，后两个参数用于输出问候字符串。我们的系统调用通过其前两个参数接受一个名称，一个指向用户空间中已分配缓冲区的
    `char` 指针和一个表示缓冲区长度的整数，并使用其第二个两个参数返回问候字符串，一个不同于输入缓冲区的指针，并且再次在用户空间中分配，以及一个表示其长度的整数。'
- en: '**WARNING**:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：'
- en: Please don't perform this experiment in a Linux installation that is supposed
    to be used for work or home usage purposes. Run the following commands on an experimental
    machine, which is strongly recommended to be a virtual machine. You can easily
    create virtual machines by using emulator applications such as VirtualBox or VMware.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要在打算用于工作或家庭用途的 Linux 安装上执行此实验。请在实验机器上运行以下命令，强烈建议使用虚拟机。您可以通过使用仿真应用程序（如 VirtualBox
    或 VMware）轻松创建虚拟机。
- en: The following instructions have the potential to corrupt your system and make
    you lose part, if not all, of your data if they are used inappropriately or in
    the wrong order. Always consider some backup solutions to make a copy of your
    data if you're going to run the following commands on a none-experimental machine.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不恰当地或以错误的顺序使用以下说明，它们可能会损坏您的系统，并导致您丢失部分甚至全部数据。如果您打算在非实验机器上运行以下命令，请始终考虑一些备份解决方案，以复制您的数据。
- en: First of all, we need to download the latest source code of the Linux kernel.
    We will use the Linux GitHub repository to clone its source code and then we will
    pick a specific release. Version 5.3 was released on 15 September 2019, and so
    we're going to use this version for this example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要下载 Linux 内核的最新源代码。我们将使用 Linux GitHub 仓库来克隆其源代码，然后我们将选择一个特定的发布版本。版本 5.3
    于 2019 年 9 月 15 日发布，因此我们将使用这个版本进行本示例。
- en: '**Note**:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Linux is a kernel. It means that it can only be installed in the kernel ring
    in a Unix-like operating system, but a *Linux distribution* is a different thing.
    A Linux distribution has a specific version of the Linux kernel in its kernel
    ring and a specific version of GNU libc and Bash (or GNU shell) in its shell ring.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 是一个内核。这意味着它只能安装在类 Unix 操作系统的内核环中，但 *Linux 发行版* 是另一回事。Linux 发行版在其内核环中有一个特定的
    Linux 内核版本，在其 shell 环中有一个特定的 GNU libc 和 Bash（或 GNU shell）版本。
- en: Each Linux distribution is usually shipped with a complete list of user applications
    in its external rings. So, we can say a Linux distribution is a complete operating
    system. Note that, *Linux distribution*, *Linux distro*, and *Linux flavor* all
    refer to the same thing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Linux 发行版通常都附带其外部环中完整的用户应用程序列表。因此，我们可以说 Linux 发行版是一个完整的操作系统。请注意，*Linux 发行版*、*Linux
    distro* 和 *Linux flavor* 都指的是同一件事。
- en: In this example, I'm using the Ubuntu 18.04.1 Linux distribution on a 64-bit
    machine.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我正在使用 64 位机器上的 Ubuntu 18.04.1 Linux 发行版。
- en: 'Before we start, it''s vital to make sure that the prerequisite packages are
    installed by running the following commands:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，确保通过运行以下命令安装了先决条件软件包是非常重要的：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 11-3: Installing the prerequisite packages required for example 11.2'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 11-3：安装示例 11.2 所需的先决条件软件包
- en: 'Some notes about the preceding instructions: `apt` is the main package manager
    in Debian-based Linux distributions, while `sudo` is a utility program that we
    use to run a command in *superuser* mode. It is available on almost every Unix-like
    operating system.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面指令的一些说明：`apt` 是基于 Debian 的 Linux 发行版中的主要软件包管理器，而 `sudo` 是一个我们用来以 *超级用户*
    模式运行命令的实用程序。它在几乎每个类 Unix 操作系统中都可用。
- en: 'The next step is to clone the Linux GitHub repository. We also need to check
    out the release 5.3 after cloning the repository. The version can be checked out
    by using the release tag name, as you can see in the following commands:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是克隆 Linux GitHub 仓库。在克隆仓库之后，我们还需要检出版本 5.3。可以通过使用发布标签名称来检出版本，如下面的命令所示：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shell Box 11-4: Cloning the Linux kernel and checking out version 5.3'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 11-4：克隆 Linux 内核并检出版本 5.3
- en: 'Now, if you look at the files in the root directory, you will see lots of files
    and directories that combined build up the Linux kernel code base:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看根目录中的文件，你会看到很多文件和目录，它们组合起来构成了 Linux 内核代码库：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Shell Box 11-5: The content of the Linux kernel code base'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 11-5：Linux 内核代码库的内容
- en: 'As you can see, there are directories that might seem familiar: `fs`, `mm`,
    `net`, `arch`, and so on. I should point out that we are not going to give more
    details on each of these directories as it can vary massively from a kernel to
    another, but one common feature is that all kernels follow almost the same internal
    structure.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一些目录可能看起来很熟悉：`fs`、`mm`、`net`、`arch` 等。我应该指出，我们不会对每个这些目录的详细信息进行更多说明，因为它们可以从一个内核到另一个内核有很大的不同，但一个共同的特点是所有内核几乎都遵循相同的内部结构。
- en: Now that we have the kernel source, we should begin to add our new Hello World
    system call. However, before we do that, we need to choose a unique numerical
    identifier for our system call; in this case, I give it the name `hello_world`,
    and I choose `999` as its number.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了内核源代码，我们应该开始添加我们新的 Hello World 系统调用。然而，在我们这样做之前，我们需要为我们的系统调用选择一个唯一的数值标识符；在这种情况下，我给它命名为
    `hello_world`，并选择 `999` 作为它的编号。
- en: 'Firstly, we need to add the system call function declaration to the end of
    the `include/linux/syscalls.h` header file. After this modification, the file
    should look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将系统调用函数声明添加到 `include/linux/syscalls.h` 头文件末尾。经过这次修改后，文件应该看起来像这样：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Code Box 11-3 [include/linux/syscalls.h]: Declaration of the new Hello World
    system call'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 11-3 [include/linux/syscalls.h]：新的 Hello World 系统调用的声明
- en: The description at the top says that this is a header file that contains the
    Linux `syscall` interfaces, which are not *architecture specific*. This means
    that on all architectures, Linux exposes the same set of system calls.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的描述说明这是一个包含 Linux `syscall` 接口的头文件，这些接口不是 *架构特定的*。这意味着在所有架构上，Linux 都暴露了相同的一组系统调用。
- en: At the end of the file, we have declared our system call function, which accepts
    four arguments. As we have explained before, the first two arguments are the input
    string and its length, and the second two arguments are the output string and
    its length.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，我们声明了我们的系统调用函数，它接受四个参数。正如我们之前解释的，前两个参数是输入字符串及其长度，后两个参数是输出字符串及其长度。
- en: Note that input arguments are `const`, but the output arguments are not. Additionally,
    the `__user` identifier means that the pointers are pointing to memory addresses
    within the user space. As you can see, every system call has an integer value
    being returned as part of its function signature, which will actually be its execution
    result. The range of returned values and their meanings is different from one
    system call to another. In the case of our system call, `0` means success and
    any other number is a failure.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输入参数是 `const`，但输出参数不是。此外，`__user` 标识符表示指针指向用户空间内的内存地址。正如你所见，每个系统调用都有整数返回值作为其函数签名的一部分，这实际上是它的执行结果。返回值的范围及其含义因系统调用而异。在我们的系统调用中，`0`
    表示成功，任何其他数字都表示失败。
- en: 'We now need to define our system call. To do this, we must first create a folder
    named `hello_world` in the root directory, which we accomplish using the following
    commands:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义我们的系统调用。为此，我们必须首先在根目录下创建一个名为 `hello_world` 的文件夹，我们使用以下命令来完成：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Shell Box 11-6: Creating the hello_world directory'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-6：创建 hello_world 目录
- en: 'Next, we create a file named `sys_hello_world.c` inside the `hello_world` directory.
    The contents of this file should be as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `hello_world` 目录内创建一个名为 `sys_hello_world.c` 的文件。该文件的 内容应如下所示：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 11-4: The definition of the Hello World system call'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 11-4：Hello World 系统调用的定义
- en: In the *Code Box 11-4*, we have used the `SYSCALL_DEFINE4` macro to define our
    function definition, with the `DEFINE4` suffix simply meaning that it accepts
    four arguments.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *代码框 11-4* 中，我们使用了 `SYSCALL_DEFINE4` 宏来定义我们的函数定义，其中 `DEFINE4` 后缀仅仅意味着它接受四个参数。
- en: At the beginning of the function body, we have declared two-character arrays
    on the top of the kernel Stack. Much like ordinary processes, the kernel process
    has an address space that contains a Stack. After we've achieved that, we copy
    the data from the user space into the kernel space. Following that, we create
    the greeting message by concatenating some strings. This string is still in the
    kernel memory. Finally, we copy back the message to the user space and make it available
    for the caller process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体的开头，我们在内核栈顶部声明了两个字符数组。与普通进程类似，内核进程有一个包含栈的地址空间。在完成这一步之后，我们将用户空间的数据复制到内核空间。随后，我们通过连接一些字符串来创建问候信息。这个字符串仍然在内核内存中。最后，我们将消息复制回用户空间，使其对调用进程可用。
- en: In the case of errors, appropriate error numbers are returned in order to let
    the caller process know about the result of the system call.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现错误的情况下，会返回适当的错误号，以便让调用进程知道系统调用的结果。
- en: The next step to make our system call work is to update one more table. There
    is only one system call table for both x86 and x64 architectures, and the newly
    added system calls should be added to this table to become exposed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的系统调用工作下一步是更新另一个表。x86 和 x64 架构只有一个系统调用表，新添加的系统调用应该添加到这个表中以供暴露。
- en: Only after this step the system calls are available in x86 and x64 machines.
    To add the system call to the table, we need to add `hello_word` and its function
    name, `sys_hello_world`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 只有完成这一步后，系统调用才在 x86 和 x64 机器上可用。要将系统调用添加到表中，我们需要添加 `hello_word` 和其函数名 `sys_hello_world`。
- en: 'To do this, open the `arch/x86/entry/syscalls/syscall_64.tbl` file and add
    the following line to the end of the file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，打开 `arch/x86/entry/syscalls/syscall_64.tbl` 文件，并在文件末尾添加以下行：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 11-5: Adding the newly added Hello World system call to the system
    call table'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 11-5：将新添加的 Hello World 系统调用添加到系统调用表
- en: 'After the modification, the file should look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后，文件应如下所示：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Shell Box 11-7: Hello World system call added to the system call table'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-7：Hello World 系统调用添加到系统调用表
- en: Note the `__x64_` prefix in the name of the system call. This is an indication
    that the system call is only exposed in x64 systems.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意系统调用名称中的`__x64_`前缀。这是系统调用仅在x64系统中公开的指示。
- en: 'The Linux kernel uses the Make build system to compile all the source files
    and build the final kernel image. Moving on, you must make a file named `Makefile`
    in the `hello_world` directory. Its content, which is a single line of text, should
    be the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核使用Make构建系统编译所有源文件并构建最终的内核映像。接下来，您必须在`hello_world`目录中创建一个名为`Makefile`的文件。其内容，即一行文本，应该是以下内容：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 11-6: Makefile of the Hello World system call'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框11-6：Hello World系统调用的Makefile
- en: 'Then, you need to add `hello_world` directory to the main `Makefile` in the
    root directory. Change to the kernel''s root directory, open the `Makefile` file,
    and find the following line:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要将`hello_world`目录添加到根目录中的主`Makefile`中。切换到内核的根目录，打开`Makefile`文件，找到以下行：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 11-7: The target line that should be modified in the root Makefile'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框11-7：应在根Makefile中修改的目标行
- en: Add `hello_world/` to this list. All of these directories are simply the directories
    that should be built as part of the kernel.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将`hello_world/`添加到该列表中。所有这些目录都是应该作为内核构建部分构建的目录。
- en: 'We need to add the directory of the Hello World system call in order to include
    it in the build process and have it included in the final kernel image. The line
    should look like the following code after the modification:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加Hello World系统调用的目录，以便将其包含在构建过程中，并在最终的内核映像中包含它。修改后，该行应类似于以下代码：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code Box 11-8: The target line after modification'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框11-8：修改后的目标行
- en: The next step is to build the kernel.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是构建内核。
- en: Building the kernel
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建内核
- en: To build the kernel, we must first go back to the kernel's root directory because
    before we start to build the kernel, you need to provide a configuration. A configuration
    has a list of features and units that should be built as part of the build process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建内核，我们首先必须回到内核的根目录，因为在我们开始构建内核之前，您需要提供一个配置。配置包含应作为构建过程一部分构建的功能和单元列表。
- en: 'The following command tries to make the target configuration based on the current
    Linux kernel''s configuration. It uses the existing values in your kernel and
    asks you about confirmation if a newer configuration value exists in the kernel
    we are trying to build. If it does, you can simply accept all newer versions by
    just pressing the `Enter` key:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令尝试根据当前Linux内核的配置创建目标配置。它使用您内核中的现有值，并在我们试图构建的内核中存在较新的配置值时询问您进行确认。如果存在，您只需按`Enter`键即可简单地接受所有较新版本：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Shell Box 11-8: Creating a kernel configuration based on the current running
    kernel'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Shell框11-8：基于当前运行内核创建内核配置
- en: Now you can start the build process. Since the Linux kernel contains a lot of
    source files, the build can take hours to complete. Therefore, we need to run
    the compilations in parallel.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以开始构建过程。由于Linux内核包含大量源文件，构建可能需要数小时才能完成。因此，我们需要并行运行编译。
- en: 'If you''re using a virtual machine, please configure your machine to have more
    than one core in order to have an effective boost in the build process:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用虚拟机，请配置您的机器具有超过一个核心，以便在构建过程中获得有效的提升：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Shell Box 11-9: Output of the kernel build. Please note the line indicating
    the compilation of the Hello World system call'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Shell框11-9：内核构建的输出。请注意指示编译Hello World系统调用的行
- en: '**Note**:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Make sure that you have installed the prerequisite packages introduced in the
    very first part of this section; otherwise, you will get compilation errors.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经安装了本节第一部分介绍的先决条件软件包；否则，您将遇到编译错误。
- en: 'As you can see, the build process has started with four jobs trying to compile
    C files in parallel. You need to wait for it to complete. When it''s finished,
    you can easily install the new kernel and reboot the machine:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，构建过程已经开始，有四个作业正在并行尝试编译C文件。您需要等待其完成。完成后，您可以轻松地安装新的内核并重新启动机器：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Shell Box 11-10: Creating and installing the new kernel image'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Shell框11-10：创建和安装新的内核映像
- en: 'As you can see, a new kernel image for the version 5.3.0 has been created and
    installed. Now we ''re ready to reboot the system. Don''t forget to check the
    current kernel''s version before rebooting if you don''t know it. In my case,
    my version is `4.15.0-36-generic`. I''ve used the following commands to find it
    out:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，已经创建并安装了一个版本为 5.3.0 的新内核映像。现在我们准备好重启系统了。如果你不知道当前的内核版本，在重启之前不要忘记检查它。在我的情况下，我的版本是
    `4.15.0-36-generic`。我使用了以下命令来找出它：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Shell Box 11-11: Checking the version of the currently installed kernel'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-11：检查当前安装的内核版本
- en: 'Now, reboot the system using the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令重启系统：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Shell Box 11-12: Rebooting the system'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-12：重启系统
- en: 'While the system is booting up, the new kernel image will be picked up and
    used. Note that boot loaders won''t pick up the older kernels; therefore, if you''ve
    had a kernel with version above 5.3, you are going to need to load the built kernel
    image manually. This link can help you with that: https://askubuntu.com/questions/82140/how-can-i-boot-with-an-older-kernel-version.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统启动时，新的内核映像将被选中并使用。请注意，引导加载程序不会选择旧内核；因此，如果你有一个版本高于 5.3 的内核，你需要手动加载构建的内核映像。这个链接可以帮助你：https://askubuntu.com/questions/82140/how-can-i-boot-with-an-older-kernel-version.
- en: 'When the operating system boot is complete, you should have the new kernel
    running. Check the version. It must look like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统启动完成时，你应该有新的内核正在运行。检查版本。它必须看起来像这样：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Shell Box 11-13: Checking the kernel version after the reboot.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-13：重启后检查内核版本
- en: 'If everything has gone well, the new kernel should be in place. Now we can
    continue to write a C program that invokes our newly added Hello World system
    call. It will be very similar to *example 11.1*, that called the `write` system
    call. You can find *example 11.2* next:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，新的内核应该已经就位。现在我们可以继续编写一个调用我们新添加的 Hello World 系统调用的 C 程序。它将非常类似于 *示例 11.1*，它调用了
    `write` 系统调用。你可以在下面找到 *示例 11.2*：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Code Box 11-9 [ExtremeC_examples_chapter11_2.c]: Example 11.2 invoking the
    newly added Hello World system call'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 11-9 [ExtremeC_examples_chapter11_2.c]：示例 11.2 调用新添加的 Hello World 系统调用
- en: As you can see, we have invoked the system call with the number `999`. We pass
    `Kam` as the input, and we expect to receive `Hello Kam!` as the greeting message.
    The program waits for the result and prints the message buffer that is filled
    by the system call in the kernel space.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用数字 `999` 调用了系统调用。我们传递 `Kam` 作为输入，并期望收到 `Hello Kam!` 作为问候消息。程序等待结果并在内核空间中打印由系统调用填充的消息缓冲区。
- en: 'In the following code, we build and run the example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们构建并运行了示例：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Shell Box 11-14: Compiling and running example 11.2'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-14：编译和运行示例 11.2
- en: 'After running the example, and if you look at the kernel logs using the `dmesg`
    command, you will see the generated logs using `printk`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，如果你使用 `dmesg` 命令查看内核日志，你会看到使用 `printk` 生成的日志：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Shell Box 11-15: Using dmesg to see the logs generated by the Hello World system
    call'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-15：使用 dmesg 查看 Hello World 系统调用生成的日志
- en: 'If you run *example 11.2* with `strace`, you can see that it actually calls
    system call `999`. You can see it in the line starting with `syscall_0x3e7(...)`.
    Note that `0x3e7` is the hexadecimal value for 999:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `strace` 运行 *示例 11.2*，你可以看到它实际上调用了系统调用 `999`。你可以在以 `syscall_0x3e7(...)`
    开头的行中看到它。请注意，`0x3e7` 是 999 的十六进制值：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Shell Box 11-16: Monitoring the system calls made by example 11.2'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-16：监控示例 11.2 所做的系统调用
- en: 'In *Shell Box 11-16*, you can see that `syscall_0x3e7` has been called and
    `0` has been returned. If you change the code in *example 11.2* to pass a name
    with more than 64 bytes, you will receive an error. Let''s change the example
    and run it again:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Shell 框 11-16* 中，你可以看到已经调用了 `syscall_0x3e7` 并返回了 `0`。如果你将 *示例 11.2* 中的代码修改为传递一个超过
    64 字节的名称，你会收到一个错误。让我们修改示例并再次运行它：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Code Box 11-10: Passing a long message (more than 64 bytes) to our Hello World
    system call'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 11-10：向我们的 Hello World 系统调用传递一个长消息（超过 64 字节）
- en: 'Let''s compile and run it again:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次编译和运行它：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Shell Box 11-17: Compiling and running example 11.2 after the modification'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-17：修改后编译和运行示例 11.2
- en: 'As you see, the system call returns `-1` based on the logic we have written
    for it. Running with `strace` also shows that system call has returned `-1`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，系统调用根据我们为其编写的逻辑返回 `-1`。使用 `strace` 运行也显示系统调用返回了 `-1`：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Shell Box 11-18: Monitoring the system calls made by example 11.2 after the
    modification'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-18：监控修改后示例 11.2 所做的系统调用
- en: In the next section, we talk about the approaches we can take in designing kernels.
    As part of our discussion, we introduce the kernel modules and explore how they
    are used in kernel development.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论设计内核可以采取的方法。作为我们讨论的一部分，我们介绍了内核模块，并探讨了它们在内核开发中的应用。
- en: Unix kernels
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix 内核
- en: In this section, we are going to talk about the architectures that Unix kernels
    have been developed with throughout the last 30 years. Before talking about the
    different types of kernels, and there are not very many, we should know that there
    is no standardization about the way a kernel should be designed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论过去30年中Unix内核所采用的架构。在讨论不同类型的内核之前——实际上种类并不多——我们应该知道，关于内核应该如何设计并没有标准化。
- en: The best practices that we have obtained are based on our experiences over the
    years, and they have led us to a high-level picture of the internal units in a
    Unix kernel, which results in illustrations such as *Figure 10-5* in the previous
    chapter. Therefore, each kernel is somewhat different in comparison to another.
    The main thing that all of them have in common is that they should expose their
    functionalities through a system call interface. However, every kernel has its
    own way of handling system calls.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得的最佳实践是基于多年的经验，它们引导我们形成了Unix内核内部单元的高级视图，这在上一章的*图10-5*中有所体现。因此，每个内核与另一个内核相比都有所不同。它们共同的主要特点是它们应该通过系统调用接口来暴露其功能。然而，每个内核都有自己处理系统调用的独特方式。
- en: This variety and the debates around it have made it one of the hottest computer
    architecture-related topics of the 1990s, with large groups of people taking part
    in these debates – the *Tanenbaum-Torvalds* debate being considered the most famous one.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多样性和围绕它的争论使它成为20世纪90年代最热门的计算机架构相关话题之一，有大量的人参与这些争论——其中*坦能鲍姆-托瓦尔斯*辩论被认为是其中最著名的一次。
- en: 'We are not going to go into the details of these debates, but we want to talk
    a bit about the two major dominant architectures for designing a Unix kernel:
    *monolithic* and *microkernel*. There are still other architectures, such as *hybrid
    kernels*, *nanokernels*, and *exokernels*, all of which have their own specific
    usages.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入这些辩论的细节，但我们要简要谈谈设计Unix内核的两种主要主导架构：*单核*和*微核*。仍然存在其他架构，如*混合内核*、*纳米内核*和*外核*，它们都有自己特定的用途。
- en: We, however, are going to focus on monolithic kernels and microkernels by creating
    a comparison so that we can learn about their characteristics.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将通过创建一个比较来关注单核内核和微内核，以便我们可以了解它们的特性。
- en: Monolithic kernels versus microkernels
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单核内核与微内核
- en: In the previous chapter where we looked at Unix architecture, we described the
    kernel as a single process containing many units, but in reality, we were actually
    talking about a monolithic kernel.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论Unix架构时，将内核描述为包含许多单元的单个进程，但实际上我们实际上是在谈论一个单核内核。
- en: A monolithic kernel is made up of one kernel process with one address space
    that contains multiple smaller units within the same process. Microkernels take
    the opposite approach. A microkernel is a minimal kernel process that tries to
    push out services such as filesystem, device drivers, and process management to
    the user space in order to make the kernel process smaller and thinner.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 单核内核由一个内核进程和一个地址空间组成，该地址空间包含在同一进程内的多个较小的单元。微内核则采取相反的方法。微内核是一个最小的内核进程，它试图将文件系统、设备驱动程序和进程管理等服务推到用户空间，以使内核进程更小、更薄。
- en: Both of these architectures have advantages and disadvantages, and as a result,
    they've been the topic of one of the most famous debates in the history of operating
    systems. It goes back to 1992, just after the release of the first version of
    Linux. A debate was started on *Usenet* by a post written by **Andrew S. Tanenbaum**.
    The debate is known as the Tanenbaum-Torvalds debate. You can read more at https://en.wikipedia.org/wiki/Tanenbaum–Torvalds_debate.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种架构都有其优缺点，因此它们成为了操作系统历史上最著名的辩论之一。它始于1992年，Linux第一个版本发布之后不久。由**安德鲁·S·坦能鲍姆**撰写的一篇帖子在*Usenet*上引发了一场辩论。这场辩论被称为坦能鲍姆-托瓦尔斯辩论。你可以在https://en.wikipedia.org/wiki/Tanenbaum–Torvalds_debate了解更多信息。
- en: That post was the starting point for a flame war between the Linux creator **Linus
    Torvalds** and Tanenbaum and a bunch of other enthusiasts, who later became the
    first Linux developers. They were debating the nature of monolithic kernels and
    microkernels. Many different aspects of kernel design and the influence of hardware
    architecture on kernel design were discussed as part of this flame war.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 那篇帖子是Linux创建者**林纳斯·托瓦兹**与谭宁邦以及其他一些爱好者之间引发激烈争论的起点，这些人后来成为了第一批Linux开发者。他们正在辩论单核内核和微内核的本质。在这次激烈争论中，讨论了许多内核设计和硬件架构对内核设计的影响的不同方面。
- en: Further discussion of the debates and topics described would be lengthy and
    complex and therefore beyond the scope of this book, but we want to compare these
    two approaches and let you get familiar with the advantages and disadvantages
    of each approach.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对所描述的辩论和主题的进一步讨论将会很长且复杂，因此超出了本书的范围，但我们想比较这两种方法，并让您熟悉每种方法的优缺点。
- en: 'The following is a list of differences between monolithic kernels and microkernels:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是比较单核内核和微内核之间差异的列表：
- en: A monolithic kernel is made up of a single process containing all the services
    provided by the kernel. Most early Unix kernels were developed like this, and
    it is considered to be an old approach. Microkernels are different because they
    have separate processes for every service the kernel offers.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单核内核由一个包含内核提供所有服务的单个进程组成。大多数早期的Unix内核都是这样开发的，这被认为是一种老方法。微内核与之不同，因为内核提供的每个服务都有单独的进程。
- en: A monolithic kernel process resides in the kernel space, whereas the *server
    processes* in a microkernel are usually in the user space. Server processes are
    those processes that provide the kernel's functionalities, such as memory management,
    filesystem, and so on. Microkernels are different in that they let server processes
    be in the user space. This means some operating systems are more microkernel-like
    than the others.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单核内核进程位于内核空间，而微内核中的*服务器进程*通常位于用户空间。服务器进程是那些提供内核功能的过程，例如内存管理、文件系统等。微内核与之不同，它们允许服务器进程位于用户空间。这意味着一些操作系统比其他操作系统更类似于微内核。
- en: Monolithic kernels are usually faster. That's because all kernel services are
    performed inside the kernel process, but microkernels need to do some *message
    passing* between the user space and the kernel space, hence more system calls
    and context switches.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单核内核通常更快。这是因为所有内核服务都在内核进程中执行，但微内核需要在用户空间和内核空间之间进行一些*消息传递*，因此需要更多的系统调用和上下文切换。
- en: In a monolithic kernel, all device drivers are loaded into the kernel. Therefore,
    device drivers written by third-party vendors will be run as a part of the kernel.
    Any flaw in any device driver or any other unit inside the kernel may lead to
    a kernel crash. This is not the case with microkernels because all of the device
    drivers and many other units are run in the user space, which we could hypothesize
    as the reason why monolithic kernels are not used in mission-critical projects.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单核内核中，所有设备驱动程序都加载到内核中。因此，第三方供应商编写的设备驱动程序将作为内核的一部分运行。任何设备驱动程序或内核内部其他单元的任何缺陷都可能导致内核崩溃。这与微内核的情况不同，因为所有的设备驱动程序和许多其他单元都在用户空间中运行，我们可以假设这就是为什么单核内核没有被用于关键任务项目的原因。
- en: In monolithic kernels, injecting a small piece of malicious code is enough to
    compromise the whole kernel, and subsequently the whole system. However, this
    can't happen easily in a microkernel because many server processes are in the
    user space, and only a minimal set of critical functionalities are concentrated
    in the kernel space.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单核内核中，注入一小段恶意代码就足以破坏整个内核，进而破坏整个系统。然而，在微内核中这种情况不太可能发生，因为许多服务器进程位于用户空间，只有最小的一组关键功能集中在内核空间。
- en: In a monolithic kernel, even a simple change to the kernel source needs the
    whole kernel to be compiled again, and a new kernel image should be generated.
    Loading the new image also requires the machine to be rebooted. But changes in
    a microkernel can lead to a compilation of only a specific server process, and
    probably loading the new functionality without rebooting the system. In monolithic
    kernels, a similar functionality can be obtained to some extent using kernel modules.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单一内核中，即使是内核源代码的简单更改也需要重新编译整个内核，并生成新的内核映像。加载新的映像还需要重新启动机器。但在微内核中，更改可以导致仅编译特定的服务器进程，并且可能在不重新启动系统的情况下加载新的功能。在单一内核中，可以通过内核模块在一定程度上获得类似的功能。
- en: MINIX is one of the best-known examples of microkernels. It was written by Andrew
    S. Tanenbaum and was initiated as an educational operating system. Linus Torvalds
    used MINIX as his development environment to write his own kernel, called Linux,
    in 1991 for the 80386 microprocessor.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: MINIX 是微内核最著名的例子之一。它是由 Andrew S. Tanenbaum 编写的，最初是一个教育操作系统。Linus Torvalds 在
    1991 年为 80386 微处理器编写自己的内核 Linux 时，使用了 MINIX 作为他的开发环境。
- en: As Linux has been the biggest and most successful defender of monolithic kernels
    for nearly 30 years, we're going to talk more about Linux in the next section.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linux 几乎是近 30 年来最大的、最成功的单一内核捍卫者，我们将在下一节中更多地讨论 Linux。
- en: Linux
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux
- en: You've already been introduced to the Linux kernel in the previous section of
    this chapter, when we were developing a new system call for it. In this section,
    we want to focus a bit more on the fact that Linux is monolithic and that every
    kernel functionality is inside the kernel.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的部分，当我们为它开发一个新的系统调用时，你已经了解了 Linux 内核。在本节中，我们想更多地关注 Linux 是单一内核的事实，以及每个内核功能都在内核内部。
- en: However, there should be a way to add a new functionality to the kernel without
    needing it to be recompiled. New functionalities cannot be added to the kernel
    as new system calls simply because, as you saw, by adding a new system call, many
    fundamental files need to be changed, and this means we need to recompile the
    kernel in order to have the new functionalities.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应该有一种方法可以在不重新编译内核的情况下添加新的功能。由于，正如你所看到的，添加一个新的系统调用需要更改许多基本文件，这意味着我们需要重新编译内核以获得新的功能。
- en: The new approach is different. In this technique, kernel modules are written
    and plugged into the kernel dynamically, which we will discuss in the first section,
    before moving on to writing a kernel module for Linux.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 新的方法是不同的。在这种技术中，内核模块被编写并动态地插入内核中，我们将在第一部分讨论这一点，然后再继续编写 Linux 内核模块。
- en: Kernel modules
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核模块
- en: Monolithic kernels are usually equipped with another facility that enables kernel
    developers to hot-plug new functionalities into an up-and-running kernel. These
    pluggable units are called kernel modules. These are not the same as server processes
    in microkernels.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 单一内核通常配备另一个设施，使内核开发者能够将新的功能热插拔到正在运行的内核中。这些可插入单元被称为内核模块。这些与微内核中的服务器进程不同。
- en: Unlike server processes in a microkernel, which are in fact separate processes
    using IPC techniques to communicate with each other, kernel modules are *kernel
    object files* that are already compiled and can be loaded dynamically into the
    kernel process. These kernel object files can either become statically built as
    part of the kernel image or become loaded dynamically when the kernel is up and
    running.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与微内核中的服务器进程不同，微内核中的服务器进程实际上是使用 IPC 技术相互通信的独立进程，内核模块是已经编译好的内核对象文件，可以动态地加载到内核进程中。这些内核对象文件可以成为内核映像的一部分静态构建，或者当内核正在运行时动态加载。
- en: Note that the kernel object files are twin concepts to the ordinary object files
    produced in C development.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，内核对象文件是 C 开发中产生的普通对象文件的双胞胎概念。
- en: It's worth noting again that if the kernel module does something bad inside
    the kernel, a *kernel crash* can happen.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 值得再次注意的是，如果内核模块在内核内部做了一些坏事，可能会发生内核崩溃。
- en: 'The way you communicate with kernel modules is different from system calls,
    and they cannot be used by calling a function or using a given API. Generally,
    there are three ways to communicate with a kernel module in Linux and some similar
    operating systems:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与系统调用不同，与内核模块的通信方式不同，不能通过调用函数或使用给定的 API 来使用。通常，在 Linux 和一些类似操作系统中，与内核模块通信有三种方式：
- en: '**Device files in the /dev directory**: Kernel modules are mainly developed
    to be used by device drivers, and that''s why devices are the most common way
    to communicate with kernel modules. As we explained in the previous chapter, devices
    are accessible as device files located in the `/dev` directory. You can read from
    and write to these files and, using them, you can send and receive data to/from
    the modules.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/dev 目录中的设备文件**：内核模块主要是为了被设备驱动程序使用而开发的，这也是为什么设备是与内核模块通信的最常见方式。正如我们在上一章中解释的，设备作为位于
    `/dev` 目录中的设备文件是可访问的。你可以从这些文件中读取和写入，并使用它们，你可以向/从模块发送和接收数据。'
- en: '**Entries in procfs**: Entries in the `/proc` directory can be used to read
    meta-information about a specific kernel module. These files can also be used
    to pass meta-information or control commands to a kernel module. We shortly demonstrate
    the usage of procfs in the next example, *example 11.3*, as part of the following
    section.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**procfs 中的条目**：`/proc` 目录中的条目可以用来读取特定内核模块的元信息。这些文件也可以用来传递元信息或控制命令给内核模块。我们将在下一示例中简要演示
    procfs 的用法，即 *示例 11.3*，作为以下部分的内容。'
- en: '**Entries in sysfs**: This is another filesystem in Linux that allows scripts
    and users to control user processes and other kernel-related units, such as kernel
    modules. It can be considered as a new version of procfs.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sysfs 中的条目**：这是 Linux 中的另一个文件系统，允许脚本和用户控制用户进程以及其他与内核相关的单元，例如内核模块。它可以被认为是
    procfs 的新版本。'
- en: In fact, the best way to see a kernel module is to write one, which is what
    we are going to do in the next section, where we write a Hello World kernel module
    for Linux. Note that kernel modules are not limited to Linux; monolithic kernels
    such as FreeBSD also benefit from the kernel module mechanism.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，最好的方法是编写一个内核模块，这正是我们在下一节将要做的，我们将为 Linux 编写一个 Hello World 内核模块。请注意，内核模块不仅限于
    Linux；像 FreeBSD 这样的单核内核也受益于内核模块机制。
- en: Adding a kernel module to Linux
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将内核模块添加到 Linux
- en: In this section, we are going to write a new kernel module for Linux. This is
    the Hello World kernel module, which creates an entry in procfs. Then, using this
    entry, we read the greeting string.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个新的 Linux 内核模块。这是一个 Hello World 内核模块，它在 procfs 中创建一个条目。然后，使用这个条目，我们读取问候字符串。
- en: In this section, you will become familiar with writing a kernel module, compiling
    it, loading it into the kernel, unloading it from the kernel, and reading data
    from a procfs entry. The main purpose of this example is to get your hands dirty
    with writing a kernel module and, as a result more development can be done by
    yourself.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将熟悉编写内核模块、编译它、将其加载到内核中、从内核中卸载它以及从 procfs 条目中读取数据。本示例的主要目的是让你亲自动手编写内核模块，从而可以自己进行更多开发。
- en: '**Note**:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Kernel modules are compiled into kernel object files that can be loaded directly
    into the kernel at run-time. There is no need to reboot the system after loading
    the kernel module object file as long as it doesn't do something bad in the kernel
    that leads to a kernel crash. That's also true for unloading the kernel module.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块被编译成可以在运行时直接加载到内核中的内核对象文件。只要内核模块对象文件没有在内核中做任何导致内核崩溃的坏事，就不需要重新启动系统。卸载内核模块也是如此。
- en: 'The first step is to create a directory that is supposed to contain all files
    related to the kernel module. We name it `ex11_3` since this is the third example
    in this chapter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个目录，该目录将包含所有与内核模块相关的文件。我们将其命名为 `ex11_3`，因为这是本章的第三个示例：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Shell Box 11-19: Making the root directory for example 11.3'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 11-19：为示例 11.3 创建根目录
- en: 'Then, create a file named `hwkm.c`, which is just an acronym made up of the
    first letters of "Hello World Kernel Module," with the following content:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为 `hwkm.c` 的文件，它只是由 "Hello World Kernel Module" 的首字母组成的缩写，其内容如下：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Code Box 11-11 [ex11_3/hwkm.c]: The Hello World kernel module'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 11-11 [ex11_3/hwkm.c]：Hello World 内核模块
- en: Using the two last statements in *Code Box 11-11*, we have registered the module's
    initialization and exit callbacks. These functions are called when the module
    is being loaded and unloaded respectively. The initialization callback is the
    first code to be executed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *代码框 11-11* 中的最后两条语句，我们已经注册了模块的初始化和退出回调函数。这些函数分别在模块加载和卸载时被调用。初始化回调是首先执行的代码。
- en: As you can see inside the `hwkm_init` function, it creates a file named `hwkm`
    inside the `/proc` directory. There is also an exit callback. Inside the `hwkm_exit`
    function, it removes the `hwkm` file from the `/proc` path. The `/proc/hwkm` file
    is the contact point for the user space to be able to communicate with the kernel
    module.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 `hwkm_init` 函数内部所见，它会在 `/proc` 目录下创建一个名为 `hwkm` 的文件。还有一个退出回调。在 `hwkm_exit`
    函数内部，它会从 `/proc` 路径中删除 `hwkm` 文件。`/proc/hwkm` 文件是用户空间与内核模块通信的接触点。
- en: The `proc_file_read` function is the read callback function. This function is
    called when the user space tries to read the `/proc/hwkm` file. As you will soon
    see, we use the `cat` utility program to read the file. It simply copies the `Hello
    World From Kernel Module!` string to the user space.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc_file_read` 函数是读取回调函数。当用户空间尝试读取 `/proc/hwkm` 文件时，会调用此函数。您很快就会看到，我们使用 `cat`
    工具程序来读取文件。它简单地将 `Hello World From Kernel Module!` 字符串复制到用户空间。'
- en: Note that at this stage, the code written inside a kernel module has total access
    to almost anything inside the kernel, and it can leak out any kind of information
    to the user space. This is a major security issue, and further reading about the
    best practices for writing a secure kernel module should be undertaken.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个阶段，内核模块内部编写的代码几乎可以访问内核内部的任何内容，并且它可以向用户空间泄露任何类型的信息。这是一个主要的安全问题，应该进一步阅读有关编写安全内核模块的最佳实践的资料。
- en: To compile the preceding code, we need to use an appropriate compiler, including
    possibly linking it with the appropriate libraries. In order to make life easier,
    we create a file named `Makefile` that will trigger the necessary build tools
    in order to build the kernel module.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译前面的代码，我们需要使用适当的编译器，可能还需要将其与适当的库链接。为了使生活更简单，我们创建了一个名为 `Makefile` 的文件，该文件将触发必要的构建工具以构建内核模块。
- en: 'The following code box shows the content of the `Makefile`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了 `Makefile` 的内容：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Code Box 11-12: Makefile of the Hello World kernel module'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 11-12：Hello World 内核模块的 Makefile
- en: 'Then, we can run the `make` command. The following shell box demonstrates this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行 `make` 命令。以下 shell 窗口演示了这一点：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Shell Box 11-20: Building the Hello World kernel module'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 11-20：构建 Hello World 内核模块
- en: As you can see, the compiler compiles the code and produces an object file.
    Then, it continues by linking the object file with other libraries to create a
    `.ko` file. Now, if you look at the generated files, you find a file named `hwkm.ko`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编译器编译代码并生成一个对象文件。然后，它继续将对象文件与其他库链接以创建一个 `.ko` 文件。现在，如果您查看生成的文件，您会发现一个名为
    `hwkm.ko` 的文件。
- en: Notice the `.ko` extension, which simply means that the output file is a kernel
    object file. It is something like a shared library that can be dynamically loaded
    into the kernel and become running.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `.ko` 扩展名，它仅仅意味着输出文件是一个内核对象文件。它就像一个可以动态加载到内核并运行的共享库。
- en: Please note that in *Shell Box 11-20*, the build process has produced a warning
    message. It says that the module has no license associated with it. It is a highly
    recommended practice to generate licensed modules when developing or deploying
    kernel modules in test and production environments.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 *Shell Box 11-20* 中，构建过程生成了一个警告消息。它表示该模块没有与之关联的许可证。在开发和部署内核模块的测试和生产环境中，生成授权模块是一种高度推荐的做法。
- en: 'The following shell box shows the list of files that can be found after building
    the kernel module:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 窗口显示了构建内核模块后可以找到的文件列表：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Shell Box 11-21: List of existing files after building the Hello World kernel
    module'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 11-21：构建 Hello World 内核模块后的现有文件列表
- en: '**Note**:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: We have used module build tools from Linux kernel version 5.3.0 You might get
    a compilation error if you compile this example using a kernel version below 3.10.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 Linux 内核版本 5.3.0 的模块构建工具。如果您使用低于 3.10 的内核版本编译此示例，可能会得到编译错误。
- en: 'To load the `hwkm` kernel module, we use the `insmod` command in Linux, which
    simply loads and installs the kernel module, as we have done in the following
    shell box:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载 `hwkm` 内核模块，我们使用 Linux 中的 `insmod` 命令，它简单地加载并安装内核模块，就像我们在以下 shell 窗口中做的那样：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Shell Box 11-22: Loading and installing the Hello World kernel module'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 11-22：加载和安装 Hello World 内核模块
- en: 'Now, if you look at the kernel logs, you will see the lines that are produced
    by the initializer function. Just use the `dmesg` command to see the latest kernel
    logs, which is what we have done next:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您查看内核日志，您将看到由初始化函数产生的行。只需使用 `dmesg` 命令查看最新的内核日志，这是我们接下来要做的：
- en: '[PRE34]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Shell Box 11-23: Checking the kernel log messages after installing the kernel
    module'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 11-23：安装内核模块后的内核日志消息检查
- en: 'Now, the module has been loaded, and the `/proc/hwkm` file should have been
    created. We can read it now by using the `cat` command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，模块已经加载，应该已经创建了 `/proc/hwkm` 文件。我们可以通过使用 `cat` 命令来读取它：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Shell Box 11-24: Reading the/proc/hwkm file using cat'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 11-24：使用 cat 读取 /proc/hwkm 文件
- en: As you can see in the preceding shell box, we have read the file twice, and
    both times, it returns the same `Hello World From Kernel Module!` string. Note
    that the string is copied into the user space by the kernel module, and the `cat`
    program has just printed it to the standard output.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的 shell 窗口中看到的，我们读取了文件两次，两次都返回了相同的 `Hello World From Kernel Module!` 字符串。请注意，该字符串是由内核模块复制到用户空间的，而
    `cat` 程序只是将其打印到标准输出。
- en: 'When it comes to unloading the module, we can use the `rmmod` command in Linux,
    as we have done next:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到卸载模块时，我们可以使用 Linux 中的 `rmmod` 命令，就像我们接下来要做的：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Shell Box 11-25: Unloading the Hello World kernel module'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 11-25：卸载 Hello World 内核模块
- en: 'Now that the module has been unloaded, look at the kernel logs again to see
    the goodbye message:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模块已经卸载，再次查看内核日志以查看再见信息：
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Shell Box 11-26: Checking the kernel log messages after unloading the kernel
    module'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 11-26：卸载内核模块后的内核日志消息检查
- en: As you saw in the preceding example, kernel modules are very handy when it comes
    to writing kernel codes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的示例中看到的，内核模块在编写内核代码时非常方便。
- en: 'To finish off this chapter, I believe it would be helpful to give you a list
    of the features that we have seen so far regarding kernel modules:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，我相信提供一个关于我们迄今为止所看到的内核模块功能的列表将会有所帮助：
- en: Kernel modules can be loaded and unloaded without needing to reboot the machine.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核模块可以在不重新启动机器的情况下加载和卸载。
- en: When loaded, they become part of the kernel and can access any unit or structure
    within the kernel. This can be thought of as a vulnerability, but a Linux kernel
    can be protected against installing unwanted modules.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当加载时，它们成为内核的一部分，可以访问内核中的任何单元或结构。这可以被认为是一个漏洞，但 Linux 内核可以保护自己免受安装不受欢迎的模块的影响。
- en: In the case of kernel modules, you only need to compile their source code. But
    for system calls, you have to compile the whole kernel, which can easily take
    an hour of your time.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内核模块的情况下，您只需要编译它们的源代码。但对于系统调用，您必须编译整个内核，这可能会占用您一个小时的时间。
- en: Finally, kernel modules can be handy when you are going to develop a code that
    needs to be run within the kernel behind a system call. The logic that is going
    to be exposed using a system call can be loaded into the kernel using a kernel
    module first, and after being developed and tested properly, it can go behind
    a real system call.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您要开发需要在系统调用背后运行的代码时，内核模块可能很有用。将要使用系统调用暴露的逻辑可以先通过内核模块加载到内核中，经过适当的开发和测试后，它可以放在真正的系统调用后面。
- en: Developing system calls from scratch can be a tedious job because you have to reboot
    your machine countless times. Having the logic firstly written and tested as part
    of a kernel module can ease the pain of kernel development. Note that if your
    code is trying to cause a kernel crash, it doesn't matter if it is in a kernel
    module or behind a system call; it causes a kernel crash and you must reboot your
    machine.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始开发系统调用可能是一项繁琐的工作，因为您不得不无数次地重新启动您的机器。将逻辑首先作为内核模块的一部分编写和测试可以减轻内核开发的痛苦。请注意，如果您的代码试图导致内核崩溃，无论是内核模块还是系统调用之后，都会导致内核崩溃，您必须重新启动您的机器。
- en: In this section, we talked about various types of kernels. We also showed how
    a kernel module can be used within a monolithic kernel to have transient kernel
    logic by loading and unloading it dynamically.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了各种类型的内核。我们还展示了如何在单核内核中通过动态加载和卸载来使用内核模块实现瞬态内核逻辑。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'We''ve now completed our two-chapter discussion about Unix. In this chapter,
    we learned about the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了关于 Unix 的两章讨论。在本章中，我们学习了以下内容：
- en: What a system call is and how it exposes a certain functionality
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用是什么以及它是如何暴露特定功能的
- en: What happens behind the invocation of a system call
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用调用背后的发生情况
- en: How a certain system call can be invoked from C code directly
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何直接从C代码中调用某个系统调用
- en: How to add a new system call to an existing Unix-like kernel (Linux) and how
    to recompile the kernel
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向现有的类Unix内核（Linux）添加一个新的系统调用以及如何重新编译内核
- en: What a monolithic kernel is and how it differs from a microkernel
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是单核内核以及它与微内核的区别
- en: How kernel modules work within a monolithic kernel and how to write a new kernel
    module for Linux
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核模块如何在单核内核中工作以及如何为Linux编写一个新的内核模块
- en: In the following chapter, we're going to talk about the C standards and the
    most recent version of C, C18\. You will become familiar with the new features
    introduced as part of it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论C标准以及最新的C标准版本，C18。您将熟悉其中引入的新特性。
