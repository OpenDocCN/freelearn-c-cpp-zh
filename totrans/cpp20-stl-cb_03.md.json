["```cpp\ntemplate<typename Tc, typename Tv>\nvoid remove_value(Tc & c, const Tv v) {\n    auto remove_it = std::remove(c.begin(), c.end(), v);\n    c.erase(remove_it, c.end());\n}\n```", "```cpp\nstd::erase(c, 5);   // same as remove_value() function\n```", "```cpp\nstd::erase_if(c, [](auto x) { return x % 2 == 0; });\n```", "```cpp\nerase(container, value); \n```", "```cpp\nerase_if(container, predicate); \n```", "```cpp\n    void printc(auto & r) {\n        cout << format(\"size({}) \", r.size());\n        for( auto & e : r ) cout << format(\"{} \", e);\n        cout << \"\\n\";\n    }\n    ```", "```cpp\n    vector v{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    printc(v);\n    ```", "```cpp\nsize: 10: 0 1 2 3 4 5 6 7 8 9\n```", "```cpp\nerase(v, 5);\nprintc(v);\n```", "```cpp\nsize: 9: 0 1 2 3 4 6 7 8 9\n```", "```cpp\n    list l{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    printc(l);\n    erase(l, 5);\n    printc(l);\n    ```", "```cpp\nsize: 10: 0 1 2 3 4 5 6 7 8 9\nsize: 9: 0 1 2 3 4 6 7 8 9\n```", "```cpp\n    vector v{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    printc(v);\n    erase_if(v, [](auto x) { return x % 2 == 0; });\n    printc(v);\n    ```", "```cpp\nsize: 10: 0 1 2 3 4 5 6 7 8 9\nsize: 5: 1 3 5 7 9\n```", "```cpp\n    void print_assoc(auto& r) {\n        cout << format(\"size: {}: \", r.size());\n        for( auto& [k, v] : r ) cout << format(\"{}:{} \",\n            k, v);\n        cout << \"\\n\";\n    }\n    int main() {\n        map<int, string> m{ {1, \"uno\"}, {2, \"dos\"},\n            {3, \"tres\"}, {4, \"quatro\"}, {5, \"cinco\"} };\n        print_assoc(m);\n        erase_if(m, \n            [](auto& p) { auto& [k, v] = p;\n            return k % 2 == 0; }\n        );\n        print_assoc(m);\n    }\n    ```", "```cpp\nsize: 5: 1:uno 2:dos 3:tres 4:quatro 5:cinco\nsize: 3: 1:uno 3:tres 5:cinco\n```", "```cpp\ntemplate<typename Tc, typename Tv>\nvoid remove_value(Tc & c, const Tv v) {\n    auto remove_it = std::remove(c.begin(), c.end(), v);\n    c.erase(remove_it, c.end());\n}\n```", "```cpp\nvector vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n```", "```cpp\nc.erase(remove_it, c.end());\n```", "```cpp\n    void printc(auto & r) {\n        cout << format(\"size({}) \", r.size());\n        for( auto & e : r ) cout << format(\"{} \", e);\n        cout << '\\n';\n    }\n    ```", "```cpp\n    int main() {\n        vector v{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        printc(v);\n    }\n    ```", "```cpp\nsize(10) 0 1 2 3 4 5 6 7 8 9\n```", "```cpp\n    template<typename T>\n    void quick_delete(T& v, size_t idx) {\n        if (idx < v.size()) {\n            v[idx] = move(v.back());\n            v.pop_back();\n        }\n    }\n    ```", "```cpp\n    template<typename T>\n    void quick_delete(T& v, typename T::iterator it) {\n        if (it < v.end()) {\n            *it = move(v.back());\n            v.pop_back();\n        }\n    }\n    ```", "```cpp\n    int main() {\n        vector v{ 12, 196, 47, 38, 19 };\n        printc(v);\n        auto it = std::ranges::find(v, 47);\n        quick_delete(v, it);\n        printc(v);\n        quick_delete(v, 1);\n        printc(v);\n    }\n    ```", "```cpp\nsize(5) 12 196 47 38 19\nsize(4) 12 196 19 38\nsize(3) 12 38 19\n```", "```cpp\nvector v{ 19, 71, 47, 192, 4004 };\nauto & i = v[2];\n```", "```cpp\nauto & i = v.at(2);\n```", "```cpp\n    int main() {\n        vector v{ 19, 71, 47, 192, 4004 };\n        auto & i = v[2];\n        cout << format(\"element is {}\\n\", i);\n    }\n    ```", "```cpp\nelement is 47\n```", "```cpp\n    vector v{ 19, 71, 47, 192, 4004 };\n    auto & i = v[5];\n    cout << format(\"element is {}\\n\", i);\n    element is 0\n    ```", "```cpp\n    vector v{ 19, 71, 47, 192, 4004 };\n    v[5] = 2001;\n    auto & i = v[5];\n    cout << format(\"element is {}\\n\", i);\n    element is 2001\n    ```", "```cpp\n    vector v{ 19, 71, 47, 192, 4004 };\n    auto & i = v.at(5);\n    cout << format(\"element is {}\\n\", i);\n    ```", "```cpp\nterminate called after throwing an instance of 'std::out_of_range'\n  what():  vector::_M_range_check: __n (which is 5) >= this->size() (which is 5)\nAborted\n```", "```cpp\nint main() {\n    vector v{ 19, 71, 47, 192, 4004 };\n    try {\n        v.at(5) = 2001;\n    } catch (const std::out_of_range & e) {\n        std::cout <<\n            format(\"Ouch!\\n{}\\n\", e.what());\n    }\n    cout << format(\"end element is {}\\n\", v.back());\n}\n```", "```cpp\nOuch!\nvector::_M_range_check: __n (which is 5) >= this->size() (which is 5)\nend element is 4004\n```", "```cpp\n    using Vstr = std::vector<std::string>;\n    ```", "```cpp\n    // print a vector\n    void printv(const auto& v) {\n        for(const auto& e : v) {\n            cout << format(\"{} \", e);\n        }\n        cout << \"\\n\";\n    }\n    // is it sorted? \n    void psorted(const Vstr& v) {\n        if(std::ranges::is_sorted(v)) cout<< \"sorted: \";\n        else cout << \"unsorted: \";\n        printv(v);\n    }\n    ```", "```cpp\n    int main() {\n        Vstr v{ \n            \"Miles\",\n            \"Hendrix\",\n            \"Beatles\",\n            \"Zappa\",\n            \"Shostakovich\"\n        };\n        psorted(v);\n    }\n    ```", "```cpp\nunsorted: Miles Hendrix Beatles Zappa Shostakovich\n```", "```cpp\n    std::ranges::sort(v);\n    psorted(v);\n    ```", "```cpp\nsorted: Beatles Hendrix Miles Shostakovich Zappa\n```", "```cpp\n    void insert_sorted(Vstr& v, const string& s) {\n        const auto pos{ std::ranges::lower_bound(v, s) };\n        v.insert(pos, s);\n    }\n    ```", "```cpp\n    insert_sorted(v, \"Ella\");\n    insert_sorted(v, \"Stones\");\n    ```", "```cpp\nsorted: Beatles Ella Hendrix Miles Shostakovich Stones Zappa\n```", "```cpp\nvoid insert_sorted(Vstr& v, const string& s) {\n    const auto pos{ std::ranges::lower_bound(v, s) };\n    v.insert(pos, s);\n}\n```", "```cpp\ntemplate<typename C, typename E>\nvoid insert_sorted(C& c, const E& e) {\n    const auto pos{ std::ranges::lower_bound(c, e) };\n    c.insert(pos, e);\n}\n```", "```cpp\nmap<string, string> m;\n```", "```cpp\nm[\"Miles\"] = \"Trumpet\"\n```", "```cpp\nm.insert(pair<string,string>(\"Hendrix\", \"Guitar\"));\n```", "```cpp\nm.emplace(\"Krupa\", \"Drums\");\n```", "```cpp\n    struct BigThing {\n        string v_;\n        BigThing(const char * v) : v_(v) {\n            cout << format(\"BigThing constructed {}\\n\", v_);\n        }\n    };\n    using Mymap = map<string, BigThing>;\n    ```", "```cpp\n    void printm(Mymap& m) {\n        for(auto& [k, v] : m) {\n            cout << format(\"[{}:{}] \", k, v.v_);\n        }\n        cout << \"\\n\";\n    }\n    ```", "```cpp\n    int main() {\n        Mymap m;\n        m.emplace(\"Miles\", \"Trumpet\");\n        m.emplace(\"Hendrix\", \"Guitar\");\n        m.emplace(\"Krupa\", \"Drums\");\n        m.emplace(\"Zappa\", \"Guitar\");\n        m.emplace(\"Liszt\", \"Piano\");\n        printm(m);\n    } \n    ```", "```cpp\nBigThing constructed Trumpet\nBigThing constructed Guitar\nBigThing constructed Drums\nBigThing constructed Guitar\nBigThing constructed Piano\n[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Guitar]\n```", "```cpp\n    Mymap m;\n    m.try_emplace(\"Miles\", \"Trumpet\");\n    m.try_emplace(\"Hendrix\", \"Guitar\");\n    m.try_emplace(\"Krupa\", \"Drums\");\n    m.try_emplace(\"Zappa\", \"Guitar\");\n    m.try_emplace(\"Liszt\", \"Piano\");\n    printm(m);\n    ```", "```cpp\nBigThing constructed Trumpet\nBigThing constructed Guitar\nBigThing constructed Drums\nBigThing constructed Guitar\nBigThing constructed Piano\n[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Guitar]\n```", "```cpp\n    cout << \"emplace(Hendrix)\\n\";\n    m.emplace(\"Hendrix\", \"Singer\");\n    cout << \"try_emplace(Zappa)\\n\";\n    m.try_emplace(\"Zappa\", \"Composer\"); \n    printm(m); \n    ```", "```cpp\nemplace(Hendrix)\nBigThing constructed Singer\ntry_emplace(Zappa)\n[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Guitar] \n```", "```cpp\npair<iterator, bool> try_emplace( const Key& k, Args&&... args );\n```", "```cpp\npair<iterator,bool> emplace( Args&&... args );\n```", "```cpp\nm.emplace(\"Miles\", \"Trumpet\");\nm.try_emplace(\"Miles\", \"Trumpet\");\n```", "```cpp\nconst char * key{\"Zappa\"};\nconst char * payload{\"Composer\"};\nif(auto [it, success] = m.try_emplace(key, payload);\n        !success) {\n    cout << \"update\\n\";\n    it->second = payload;\n}\nprintm(m);\n```", "```cpp\nupdate\nBigThing constructed Composer\n[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Composer]\n```", "```cpp\nusing Mymap = unordered_map<string, BigThing>; \n```", "```cpp\nmap<int, string> mymap {\n    {1, \"foo\"}, {2, \"bar\"}, {3, \"baz\"}\n};\nauto it = mymap.begin(); \nit->first = 47;\n```", "```cpp\nerror: assignment of read-only member ...\n    5 |     it->first = 47;\n      |     ~~~~~~~~~~^~~~\n```", "```cpp\n    using Racermap = map<unsigned int, string>;\n    ```", "```cpp\n    void printm(const Racermap &m)\n    {\n        cout << \"Rank:\\n\";\n        for (const auto& [rank, racer] : m) {\n            cout << format(\"{}:{}\\n\", rank, racer);\n        }\n    }\n    ```", "```cpp\n    int main() {\n        Racermap racers {\n            {1, \"Mario\"}, {2, \"Luigi\"}, {3, \"Bowser\"},\n            {4, \"Peach\"}, {5, \"Donkey Kong Jr\"}\n        };\n        printm(racers);\n        node_swap(racers, 3, 5);\n        printm(racers);\n    }\n    ```", "```cpp\n    template<typename M, typename K>\n    bool node_swap(M & m, K k1, K k2) {\n        auto node1{ m.extract(k1) };\n        auto node2{ m.extract(k2) };\n        if(node1.empty() || node2.empty()) {\n            return false;\n        }\n        swap(node1.key(), node2.key());\n        m.insert(move(node1));\n        m.insert(move(node2));\n        return true;\n    }\n    ```", "```cpp\nRank:\n1:Mario\n2:Luigi\n3:Bowser\n4:Peach\n5:Donkey Kong Jr\nRank:\n1:Mario\n2:Luigi\n3:Donkey Kong Jr\n4:Peach\n5:Bowser\n```", "```cpp\n    auto node{ mapthing.extract(key) };\n    if(node.empty()) {\n        // node handle is empty\n    }\n    ```", "```cpp\n    node_type extract(const key_type& x);\n    node_type extract(const_iterator position);\n    ```", "```cpp\nauto node_x{ racers.extract(racers.begin()) };\nnode_x.key() = 5;  // 5 is Donkey Kong Jr\nauto status = racers.insert(move(node_x));\nif(!status.inserted) {\n    cout << format(\"insert failed, dup key: {}\",\n        status.position->second);\n    exit(1);\n}\n```", "```cpp\ninsert failed, dup key: Donkey Kong Jr\n```", "```cpp\n    struct Coord {\n        int x{};\n        int y{};\n    };\n    ```", "```cpp\n    using Coordmap = unordered_map<Coord, int>;\n    ```", "```cpp\n    bool operator==(const Coord& lhs, const Coord& rhs) {\n        return lhs.x == rhs.x && lhs.y == rhs.y;\n    }\n    ```", "```cpp\n    namespace std {\n        template<>\n        struct hash<Coord> {\n            size_t operator()(const Coord& c) const {\n                return static_cast<size_t>(c.x)\n                     + static_cast<size_t>(c.y);\n            }\n        };\n    }\n    ```", "```cpp\n    void print_Coordmap(const Coordmap& m) {\n        for (const auto& [key, value] : m) {\n            cout << format(\"{{ ({}, {}): {} }} \",\n                key.x, key.y, value);\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\n    int main() {\n        Coordmap m {\n            { {0, 0}, 1 },\n            { {0, 1}, 2 },\n            { {2, 1}, 3 } \n        };\n        print_Coordmap(m);\n    }\n    ```", "```cpp\n{ (2, 1): 3 } { (0, 1): 2 } { (0, 0): 1 }\n```", "```cpp\n    Coord k{ 0, 1 };\n    cout << format(\"{{ ({}, {}): {} }}\\n\", k.x, k.y, m.at(k));\n    ```", "```cpp\n{ (0, 1): 2 }\n```", "```cpp\nstd::unordered_map<key_type, value_type> my_map;\n```", "```cpp\ntemplate<\n    class Key,\n    class T,\n    class Hash = std::hash<Key>,\n    class KeyEqual = std::equal_to<Key>,\n    class Allocator = std::allocator< std::pair<const Key, \n      T> >\n> class unordered_map;\n```", "```cpp\nstd::unordered_map<coord, value_type, my_hash_type> my_map;\n```", "```cpp\n    using input_it = istream_iterator<string>;\n    ```", "```cpp\n    int main() {\n        set<string> words;\n    ```", "```cpp\n    input_it it{ cin };\n    input_it end{};\n    ```", "```cpp\n    copy(it, end, inserter(words, words.end()));\n    ```", "```cpp\n    for(const string & w : words) {\n        cout << format(\"{} \", w);\n    }\n    cout << '\\n';\n    ```", "```cpp\n    $ echo \"a a a b c this that this foo foo foo\" | ./set-words\n    a b c foo that this\n    ```", "```cpp\nistream_iterator<string> it{ cin };\n```", "```cpp\nistream_iterator<string> end{};\n```", "```cpp\ncopy(it, end, inserter(words, words.end()));\n```", "```cpp\n    class RPN {\n        deque<double> deq_{};\n        constexpr static double zero_{0.0};\n        constexpr static double inf_ \n            { std::numeric_limits<double>::infinity() };\n    ...  // public and private members go here\n    };\n    ```", "```cpp\n    public:\n        // process an operand/operator\n        double op(const string & s) {\n            if(is_numeric(s)) {\n                double v{stod(s, nullptr)};\n                deq_.push_front(v);\n                return v;\n            }\n            else return optor(s);\n        }\n        // empty the stack\n        void clear() {\n            deq_.clear();\n        }\n        // print the stack\n        string get_stack_string() const {\n            string s{};\n            for(auto v : deq_) {\n                s += format(\"{} \", v);\n            }\n            return s;\n        }\n    ```", "```cpp\n        pair<double, double> pop_get2() {\n            if(deq_.size() < 2) return {zero_, zero_};\n            double v1{deq_.front()};\n            deq_.pop_front();\n            double v2{deq_.front()};\n            deq_.pop_front();\n            return {v2, v1};\n        }\n    ```", "```cpp\n        bool is_numeric(const string& s) {\n            for(const char c : s) {\n                if(c != '.' && !std::isdigit(c)) return \n                  false;\n            }\n            return true;\n        }\n    ```", "```cpp\n    double optor(const string& op) {\n        map<string, double (*)(double, double)> opmap {\n            {\"+\", [](double l, double r){ return l + r; }},\n            {\"-\", [](double l, double r){ return l - r; }},\n            {\"*\", [](double l, double r){ return l * r; }},\n            {\"/\", [](double l, double r){ return l / r; }},\n            {\"^\", [](double l, double r)\n                { return pow(l, r); }},\n            {\"%\", [](double l, double r)\n                { return fmod(l, r); }}\n        };\n        if(opmap.find(op) == m.end()) return zero_;\n        auto [l, r] = pop_get2();\n        // don’t divide by zero\n        if(op == \"/\" && r == zero_) deq_.push_front(inf_);\n        else deq_.push_front(opmap.at(op)(l, r));\n        return deq_.front();\n    }\n    ```", "```cpp\n    int main() {\n        RPN rpn;\n        for(string o{}; cin >> o; ) {\n            rpn.op(o);\n            auto stack_str{rpn.get_stack_string()};\n            cout << format(\"{}: {}\\n\", o, stack_str);\n        }\n    }\n    ```", "```cpp\n    $ echo \"9 6 * 2 3 * +\" | ./rpn\n    9: 9\n    6: 6 9\n    *: 54\n    2: 2 54\n    3: 3 2 54\n    *: 6 54\n    +: 60\n    ```", "```cpp\n    if(is_numeric(s)) {\n        double v{stod(s, nullptr)};\n        deq_.push_front(v);\n        return v;\n    }\n```", "```cpp\n    pair<double, double> pop_get2() {\n        if(deq_.size() < 2) return {zero_, zero_};\n        double v1{deq_.front()};\n        deq_.pop_front();\n        double v2{deq_.front()};\n        deq_.pop_front();\n        return {v2, v1};\n    }\n```", "```cpp\n    map<string, double (*)(double, double)> opmap {\n        {\"+\", [](double l, double r){ return l + r; }},\n        {\"-\", [](double l, double r){ return l - r; }},\n        {\"*\", [](double l, double r){ return l * r; }},\n        {\"/\", [](double l, double r){ return l / r; }},\n        {\"^\", [](double l, double r){ return pow(l, r); }},\n        {\"%\", [](double l, double r){ return fmod(l, r); }}\n    };\n```", "```cpp\n    if(opmap.find(op) == opmap.end()) return zero_;\n```", "```cpp\n    opmap.at(op)(l, r)\n```", "```cpp\n    deq_.push_front(opmap.at(op)(l, r));\n```", "```cpp\nint main() {\n    RPN rpn;\n    vector<string> opv{ \"9\", \"6\", \"*\", \"2\", \"3\", \"*\", \"+\" \n      };\n    for(auto o : opv) {\n        rpn.op(o);\n        auto stack_str{rpn.get_stack_string()};\n        cout << format(\"{}: {}\\n\", o, stack_str);\n    }\n}\n```", "```cpp\n9: 9\n6: 6 9\n*: 54\n2: 2 54\n3: 3 2 54\n*: 6 54\n+: 60\n```", "```cpp\n    namespace ranges = std::ranges;\n    namespace regex_constants = std::regex_constants;\n    ```", "```cpp\n    namespace bw {\n        constexpr const char * re{\"(\\\\w+)\"};\n    }\n    ```", "```cpp\n    int main() {\n        map<string, int> wordmap{};    \n        vector<pair<string, int>> wordvec{};\n        regex word_re(bw::re);\n        size_t total_words{};\n    ```", "```cpp\n    for(string s{}; cin >> s; ) {\n        auto words_begin{\n            sregex_iterator(s.begin(), s.end(), word_re) };\n        auto words_end{ sregex_iterator() };\n        for(auto r_it{words_begin}; r_it != words_end; \n          ++r_it) {\n            smatch match{ *r_it };\n            auto word_str{match.str()};\n            ranges::transform(word_str, word_str.begin(),\n                [](unsigned char c){ return tolower(c); });\n            auto [map_it, result] =\n                wordmap.try_emplace(word_str, 0);\n            auto & [w, count] = *map_it;\n            ++total_words;\n            ++count;\n        }\n    }\n    ```", "```cpp\n        auto unique_words = wordmap.size();\n        wordvec.reserve(unique_words);\n        ranges::move(wordmap, back_inserter(wordvec));\n        ranges::sort(wordvec, [](const auto& a, const \n          auto& b) { \n            if(a.second != b.second)\n                return (a.second > b.second);\n            return (a.first < b.first);\n        });\n        cout << format(\"unique word count: {}\\n\", \n          total_words);\n        cout << format(\"unique word count: {}\\n\", \n          unique_words);\n    ```", "```cpp\n        for(int limit{20}; auto& [w, count] : wordvec) {\n            cout << format(\"{}: {}\\n\", count, w);\n            if(--limit == 0) break;\n        }\n    }\n    ```", "```cpp\n    $ ./word-count < the-raven.txt\n    total word count: 1098\n    unique word count: 439\n    56: the\n    38: and\n    32: i\n    24: my\n    21: of\n    17: that\n    17: this\n    15: a\n    14: door\n    11: chamber\n    11: is\n    11: nevermore\n    10: bird\n    10: on\n    10: raven\n    9: me\n    8: at\n    8: from\n    8: in\n    8: lenore\n    ```", "```cpp\n    bool is_eos(const string_view & str) {\n        constexpr const char * end_punct{ \".!?\" };\n        for(auto c : str) {\n            if(strchr(end_punct, c) != nullptr) return \n              true;\n        }\n        return false;\n    }\n    ```", "```cpp\n    vector<vector<string>> vv_sentences{vector<string>{}};\n    ```", "```cpp\n    for(string s{}; cin >> s; ) {\n        vv_sentences.back().emplace_back(s);\n        if(is_eos(s)) {\n          vv_sentences.emplace_back(vector<string>{});\n        }\n    }\n    ```", "```cpp\n        // delete back if empty\n        if(vv_sentences.back().empty()) \n            vv_sentences.pop_back();\n    ```", "```cpp\n        sort(vv_sentences, [](const auto& l, \n            const auto& r) {\n                return l.size() > r.size();\n            });\n    ```", "```cpp\n        constexpr int WLIMIT{10};\n        for(auto& v : vv_sentences) {\n            size_t size = v.size();\n            size_t limit{WLIMIT};\n            cout << format(\"{}: \", size);\n            for(auto& s : v) {\n                cout << format(\"{} \", s);\n                if(--limit == 0) {\n                    if(size > WLIMIT) cout << \"...\";\n                    break;\n                }\n            }\n            cout << '\\n';\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\n    $ ./sentences < sentences.txt\n    27: It can be useful for a writer to make sure ...\n    19: Whenever another container type seems appropriate, but is missing one ...\n    18: If you need something ordered, it's often best to use ...\n    17: The inner vector stores the words of a sentence, and ...\n    16: In this case, however, since we need a descending sort, ...\n    16: In this case, where we need our output sorted in ...\n    15: As you'll see, this affords a lot of flexibility while ...\n    12: Let's build a tool that evaluates a text file for ...\n    11: The vector is generally the most flexible of the STL ...\n    9: Choosing the appropriate container key when using the STL.\n    7: This recipe uses a vector of vectors.\n    ```", "```cpp\nbool is_eos(const string_view & str) {\n    constexpr const char * end_punct{ \".!?\" };\n    for(auto c : str) {\n        if(strchr(end_punct, c) != nullptr) return true;\n    }\n    return false;\n}\n```", "```cpp\nfor(string s{}; cin >> s; ) {\n    ...\n}\n```", "```cpp\nvector<vector<string>> vv_sentences{vector<string>{}};\n```", "```cpp\nvv_sentences.back().emplace_back(s);\n```", "```cpp\nvv_sentences.emplace_back(vector<string>{});\n```", "```cpp\n    using todomap = multimap<int, string>;\n    ```", "```cpp\n    void rprint(todomap& todo) {\n        for(auto it = todo.rbegin(); it != todo.rend(); \n          ++it) {\n            cout << format(\"{}: {}\\n\", it->first, \n              it->second);\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\n    int main()\n    {\n        todomap todo {\n            {1, \"wash dishes\"},\n            {0, \"watch teevee\"},\n            {2, \"do homework\"},\n            {0, \"read comics\"}\n        };\n        rprint(todo);\n    }\n    ```", "```cpp\n    $ ./todo\n    2: do homework\n    1: wash dishes\n    0: read comics\n    0: watch teevee\n    ```", "```cpp\nvoid rprint(todomap& todo) {\n    for(auto it = todo.rbegin(); it != todo.rend(); ++it) {\n        cout << format(\"{}: {}\\n\", it->first, it->second);\n    }\n    cout << '\\n';\n}\n```"]