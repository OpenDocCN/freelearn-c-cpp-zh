<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor112"/>5</h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Working with Lua Tables</h1>
<p>In this chapter, we will continue to improve our Lua executor to work with tables. Many of the mechanisms are extensions of the learnings from the previous chapter. You will also learn about <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) in Lua and how to call Lua object methods. In all, Lua objects are Lua tables by nature.</p>
<p>We will cover the following topics:</p>
<ul>
<li>Working with Lua table entries</li>
<li>Working with Lua arrays</li>
<li>OOP in Lua</li>
<li>Working with Lua table functions</li>
</ul>
<h1 id="_idParaDest-114"><a id="_idTextAnchor114"/>Technical requirements</h1>
<p>Here are the technical requirements for this chapter:</p>
<ul>
<li>You can access the source code for this chapter at <a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter05">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter05</a>.</li>
<li>You can understand and execute the code in the <code>begin</code> folder from the preceding GitHub link. If you haven’t already done so, please try to do the exercises in the previous chapter on your own, or at least understand the solutions in the <code>begin</code> folder.</li>
<li>You can understand the <code>Makefile</code> located in GitHub and can build the projects. Alternatively, you can use your own way to build the source code.</li>
</ul>
<h1 id="_idParaDest-115"><a id="_idTextAnchor115"/>Working with Lua table entries</h1>
<p>A <strong class="bold">table entry</strong> is the key-value <a id="_idIndexMarker235"/>pair for a table element. Lua table keys <a id="_idIndexMarker236"/>can be of many data types – for example, of function type. For practical reasons, especially when integrating with C++, we only consider string keys and integer keys.</p>
<p>In <code>script.lua</code>, add a simple table as follows:</p>
<pre class="source-code">
position = { x = 0, y = 0 }</pre>
<p><code>position</code> is indexed by strings. We will learn how to read from and write to it in C++.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Getting a table entry value</h2>
<p>Up until now, in C++ code, we <a id="_idIndexMarker237"/>have only used one piece of information to locate a value in Lua. Consider how we implemented <code>LuaExecutor::getGlobal</code> and <code>LuaExecutor::call</code>. To locate a global variable or to call a function, we pass the name of the variable or the function to a Lua library method.</p>
<p>To work with a table entry, we would need two pieces of information – the table and the table entry key. First, we need to locate the table; after that, we can use the entry key to work on the entry value.</p>
<p>The Lua library method to get an entry value is declared as follows:</p>
<pre class="source-code">
int lua_gettable(lua_State *L, int index);</pre>
<p>Wait! We analyzed that we would need two pieces of information to locate a table entry, no? How is it possible that <code>lua_gettable</code> only takes one meaningful argument, <code>index</code>, besides the Lua state, <code>L</code>? Remember the Lua stack? The top of the stack is commonly used to pass additional information. To quote the Lua reference manual, <code>lua_gettable</code> does the following:</p>
<p class="author-quote"><em class="italic">Pushes onto the stack the value</em> <code>t[k]</code><em class="italic">, whe<a id="_idTextAnchor117"/>re </em><code>t</code> <em class="italic">is the value at the given</em> <code>index</code> <em class="italic">and</em> <code>k</code> <em class="italic">is the value on the top of the stack. This function pops the key from the stack, pushing the resulting value in its place. (</em><a href="https://www.lua.org/manual/5.4/manual.xhtml#lua_gettable">https://www.lua.org/manual/5.4/manual.xhtml#lua_gettable</a><em class="italic">)</em></p>
<p>As explained, the two keys are both located in the Lua stack. As seen in <em class="italic">Figure 5</em><em class="italic">.1</em>, before the call, the table entry key must be at the top of the stack, while the table can be in any other position in the stack. This is a Lua design decision. Since you may work on the same table from time to time, you can keep the table reference somewhere in the stack to avoid repeatedly pushing it onto the stack for each access:</p>
<div><div><img alt="Figure 5.1 – lua_gettable" height="736" src="img/B20927_05_01.jpg" width="906"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – lua_gettable</p>
<p>After understanding<a id="_idIndexMarker238"/> the mechanism, it’s time to make a design decision. How should we implement the table access in C++? Here are some possibilities:</p>
<ul>
<li>We can push the table onto the stack and keep it there. For example, if we are working with a complex table, we can implement a C++ class to load the table at the bottom of the stack and have the C++ object work exclusively with the table.</li>
<li>We can push the table onto the stack whenever we need to and pop it immediately after it’s no longer needed. This works well if the C++ class is working with many Lua values and it is not a performance concern to push the Lua table each time.</li>
</ul>
<p>Since we are implementing a general Lua executor, we will choose the latter option. In <code>LuaExecutor.h</code>, declare the following function:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    LuaValue getTable(const std::string &amp;table,
                      const std::string &amp;key);
};</pre>
<p>It takes the table<a id="_idIndexMarker239"/> name and the table entry key name and returns a <code>LuaValue</code> instance. We are only concerned about the string-type key at the moment. In <code>LuaExecutor.cc</code>, implement it as follows:</p>
<pre class="source-code">
LuaValue LuaExecutor::getTable(
    const std::string &amp;table, const std::string &amp;key)
{
    int type = lua_getglobal(L, table.c_str());
    assert(LUA_TTABLE == type);
    lua_pushstring(L, key.c_str());
    lua_gettable(L, -2);
    auto value = popValue();
    lua_pop(L, 1);
    return value;
}</pre>
<p>The code is doing the following things to get a table entry value:</p>
<ol>
<li>It pushes the table reference onto the top of the stack with <code>lua_getglobal</code>.</li>
<li>It pushes the table entry key onto the top of the stack with <code>lua_pushstring</code>. Now, the table is the second from the top.</li>
<li>It calls <code>lua_gettable</code> to pop the entry key and push the entry value. Now, the entry value is at the top of the stack.</li>
<li>It pops the top of the stack as a <code>LuaValue</code> with <code>LuaExecutor::popValue</code>. Now, the top of the stack is again the table reference.</li>
<li>It pops the table with <code>lua_pop</code>, as it’s no longer needed.</li>
<li>It returns the table entry value.</li>
</ol>
<p>In this implementation, we limit ourselves to only working with tables in the global scope. This is <a id="_idIndexMarker240"/>because we are implementing a general Lua executor. For special use cases, you can implement specific C++ classes.</p>
<p>Now, let’s see how to set a table entry value.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor118"/>Setting a table entry value</h2>
<p>The Lua library<a id="_idIndexMarker241"/> function to set a table entry value is declared as follows:</p>
<pre class="source-code">
void lua_settable(lua_State *L, int index);</pre>
<p>And the quote from the Lua reference manual explains it well:</p>
<p class="author-quote"><em class="italic">Does the equivalent to</em> <code>t[k] = v</code><em class="italic">, <a id="_idTextAnchor119"/>where</em> <code>t</code> <em class="italic">is the value at the given index</em>, <code>v</code> <em class="italic">is the value on the top of the stack, and</em> <code>k</code> <em class="italic">is the value just below the top. Pops both the key and the value from the stack. (</em><a href="https://www.lua.org/manual/5.4/manual.xhtml#lua_settable">https://www.lua.org/manual/5.4/manual.xhtml#lua_settable</a><em class="italic">)</em></p>
<p>This can be seen in <em class="italic">Figure 5</em><em class="italic">.2</em>. Now, we need to push both the entry key and the entry value onto the Lua stack:</p>
<div><div><img alt="Figure 5.2 – lua_settable" height="737" src="img/B20927_05_02.jpg" width="901"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – lua_settable</p>
<p>In <code>LuaExecutor.h</code>, add the <a id="_idIndexMarker242"/>function declaration, as follows:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    void setTable(const std::string &amp;table,
                  const std::string &amp;key,
                  const LuaValue &amp;value);
};</pre>
<p>We are passing the value as a <code>LuaValue</code>. In <code>LuaExecutor.cc</code>, implement it as follows:</p>
<pre class="source-code">
void LuaExecutor::setTable(const std::string &amp;table,
    const std::string &amp;key, const LuaValue &amp;value)
{
    int type = lua_getglobal(L, table.c_str());
    assert(LUA_TTABLE == type);
    lua_pushstring(L, key.c_str());
    pushValue(value);
    lua_settable(L, -3);
    lua_pop(L, 1);
}</pre>
<p>The code is explained in the following steps:</p>
<ol>
<li>It pushes the table reference onto the top of the stack with <code>lua_getglobal</code>.</li>
<li>It pushes the table entry key onto the stack with <code>lua_pushstring</code>.</li>
<li>It pushes the table entry value onto the stack with <code>LuaExecutor::pushValue</code>. Now, the table reference is the third from the top of the stack.</li>
<li>It sets the table entry with <code>lua_settable</code>. This also pops the top two items from the stack.</li>
<li>It pops the table with <code>lua_pop</code>. The table is pushed onto the stack in <em class="italic">step 1</em>.</li>
</ol>
<p>Next, let’s test our<a id="_idIndexMarker243"/> implementations so far.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor120"/>Testing table operations with string keys</h2>
<p>In <code>main.cpp</code>, add the <a id="_idIndexMarker244"/>following helper <a id="_idIndexMarker245"/>function to print out a <code>position</code> table:</p>
<pre class="source-code">
void dumpPosition(LuaExecutor *lua)
{
    auto x = lua-&gt;getTable("position", "x");
    auto y = lua-&gt;getTable("position", "y");
    std::cout &lt;&lt; "x=" &lt;&lt; std::get&lt;LuaNumber&gt;(x).value
              &lt;&lt; ", y=" &lt;&lt; std::get&lt;LuaNumber&gt;(y).value
              &lt;&lt; std::endl;
}</pre>
<p><code>dumpPosition</code> calls <code>LuaExecutor::getTable</code>, which we have just implemented, to get and print the <code>x</code> field and the <code>y</code> field. In <code>main()</code>, change the test code as follows:</p>
<pre class="source-code">
dumpPositon(lua.get());
lua-&gt;setTable("position", "x", LuaNumber::make(3));
lua-&gt;setTable("position", "y", LuaNumber::make(4));
dumpPositon(lua.get());</pre>
<p>This first prints a <code>position</code> table, then changes <code>position.x</code> to <code>3</code> and <code>position.y</code> to <code>4</code> and prints the table again. If you have done everything correctly, you should see <a id="_idIndexMarker246"/>the following<a id="_idIndexMarker247"/> output:</p>
<pre class="source-code">
x=0, y=0
x=3, y=4</pre>
<p>Next, let’s learn how to work with integer types of table keys.</p>
<p class="callout-heading">Do you remember?</p>
<p class="callout">If a Lua table uses integer keys exclusively, what else can the table be called?</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor121"/>Working with Lua arrays</h1>
<p>Yes – a Lua table <a id="_idIndexMarker248"/>with only integer keys is called an array or a sequence. In <code>script.lua</code>, add the following array:</p>
<pre class="source-code">
seq = { 0, 0, 0 }</pre>
<p>From the C++ side, compared with string keys, the only difference is the data type of the keys. It’s straightforward to overload the <code>getTable</code> and <code>setTable</code> functions by using integer keys. In <code>LuaExecutor.h</code>, add the following declarations:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    LuaValue getTable(const std::string &amp;table,
                      int index);
    void setTable(const std::string &amp;table,
                  int index,
                  const LuaValue &amp;value);
};</pre>
<p><code>index</code> is the Lua array index – starting from 1. Do not confuse this with the Lua stack index. In the Lua executor’s public APIs, there should be no mention of the Lua stack or Lua state.</p>
<p>One way to implement them is to copy the string key version, and instead of calling <code>lua_pushstring(L, key.c_str())</code>, call <code>lua_pushinteger(L, index)</code>. This will work. But <a id="_idIndexMarker249"/>what’s the point of repeating ourselves if this is what we would do? Is there another trick?</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>Using array index optimization</h2>
<p>Lua puts lots of <a id="_idIndexMarker250"/>emphasis on speed. Because an array is a common form of a Lua table, the Lua library provides special functions to work with arrays, as seen here:</p>
<pre class="source-code">
void lua_geti(lua_State *L, int index, int key);
void lua_seti(lua_State *L, int index, int key);</pre>
<p>These functions accept two pieces of information. The <code>index</code> argument is the position of the table in the Lua stack. The <code>key</code> argument is the array index, as it is also the table entry key. Compared with using <code>lua_gettable</code> and <code>lua_settable</code>, you no longer need to push the table entry key onto the stack. <code>lua_seti</code> expects the value to be at the top of the stack.</p>
<p>Now, let’s implement the <code>getTable</code> function for arrays. In <code>LuaExecutor.cc</code>, add the code as follows:</p>
<pre class="source-code">
LuaValue LuaExecutor::getTable(
    const std::string &amp;table, int index)
{
    int type = lua_getglobal(L, table.c_str());
    assert(LUA_TTABLE == type);
    lua_geti(L, -1, index);
    auto value = popValue();
    lua_pop(L, 1);
    return value;
}</pre>
<p>The code is <a id="_idIndexMarker251"/>doing the following:</p>
<ol>
<li>It gets the table from a global variable and pushes its reference onto the top of the stack.</li>
<li>It calls <code>lua_geti</code> with the specified array index. The Lua library will push the value onto the stack.</li>
<li>It pops the value as a <code>LuaValue</code> with <code>LuaExecutor::popValue</code>.</li>
<li>It pops the table reference.</li>
<li>It returns the value.</li>
</ol>
<p>This does not need to push the array index onto the stack at all. Similarly, implement the <code>setTable</code> function for arrays. In <code>LuaExecutor.cc</code>, add the following code:</p>
<pre class="source-code">
void LuaExecutor::setTable(const std::string &amp;table,
    int index, const LuaValue &amp;value)
{
    int type = lua_getglobal(L, table.c_str());
    assert(LUA_TTABLE == type);
    pushValue(value);
    lua_seti(L, -2, index);
    lua_pop(L, 1);
}</pre>
<p>The previous code is explained as follows:</p>
<ol>
<li>It gets the table from a global variable and pushes its reference onto the top of the stack.</li>
<li>It pushes the value for the <code>index</code> array position with <code>LuaExecutor::pushValue</code>. Now, the table reference is second from the top of the stack.</li>
<li>It calls <code>lua_seti</code> to set the array position value. It also pops the value from the stack. Now, the table reference is again at the top of the stack.</li>
<li>It pops <a id="_idIndexMarker252"/>the table reference.</li>
</ol>
<p>Next, let’s test this.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Testing the array index optimization</h2>
<p>In <code>main.cpp</code>, add another<a id="_idIndexMarker253"/> helper function to print a <code>seq</code> Lua array, as follows:</p>
<pre class="source-code">
void dumpSeq(LuaExecutor *lua)
{
    auto v1 = lua-&gt;getTable("seq", 1);
    auto v2 = lua-&gt;getTable("seq", 2);
    auto v3 = lua-&gt;getTable("seq", 3);
    std::cout &lt;&lt; "seq={"
              &lt;&lt; std::get&lt;LuaNumber&gt;(v1).value &lt;&lt; ", "
              &lt;&lt; std::get&lt;LuaNumber&gt;(v2).value &lt;&lt; ", "
              &lt;&lt; std::get&lt;LuaNumber&gt;(v3).value &lt;&lt; "}"
              &lt;&lt; std::endl;
}</pre>
<p>This uses <code>LuaExecutor::getTable</code> with integer keys. Replace the test code in <code>main()</code> with the following:</p>
<pre class="source-code">
dumpSeq(lua.get());
lua-&gt;setTable("seq", 1, LuaNumber::make(3));
lua-&gt;setTable("seq", 2, LuaNumber::make(9));
lua-&gt;setTable("seq", 3, LuaNumber::make(27));
dumpSeq(lua.get());</pre>
<p>This changes the <code>seq</code> array to <code>{ 3, 9, 27 }</code>. If you have done everything correctly, you should see the output as follows:</p>
<pre class="source-code">
seq={0, 0, 0}
seq={3, 9, 27}</pre>
<p>Well done, Lua, for the optimization. And well done, yourself, for making it this far. But how about string<a id="_idIndexMarker254"/> keys? In real-world scenarios, more often than not, a Lua table is not an array.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/>Revisiting string keys</h2>
<p>When we first <a id="_idIndexMarker255"/>learned to use a string key to access the Lua table, we chose the longer journey to push the key onto the stack. This is because it is a general mechanism, and once learned, you can change to use another data type as table keys.</p>
<p>It is fair to expect an optimization for string keys as well. Here are the Lua library functions for this:</p>
<pre class="source-code">
int lua_getfield(
    lua_State *L, int index, const char *k);
void lua_setfield(
    lua_State *L, int index, const char *k);</pre>
<p>These functions work similarly to <code>lua_geti</code> and <code>lua_seti</code>. <code>lua_getfield</code> also returns the type of the table entry value. At the end of this chapter, you will get homework to rewrite <code>LuaExecutor</code> with them. You can also choose to do it right now.</p>
<p>Before learning <a id="_idIndexMarker256"/>how to call a function from a Lua table, let’s write a Lua class. Lua tables with functions are more like C++ objects.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor125"/>OOP in Lua</h1>
<p>OOP in Lua is different <a id="_idIndexMarker257"/>than that in C++. In C++, you define a class and create instances of the class. The classes defined are unique types at the language level.</p>
<p>In Lua, there is no native class concept. OOP in Lua is prototype-based. This is more like JavaScript if you are familiar with it. For a Lua table, if an entry is not present, you can instruct Lua to check another table for it, which acts as the prototype for the table you are explicitly referencing.</p>
<p>For ease of understanding, it’s fine to call this prototype table the “class” and the table the “object”. Or, you can call the relationship “inheritance.” Although prototype and class are two <a id="_idIndexMarker258"/>different <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) methodologies, sometimes people use the two terms interchangeably.</p>
<p>Let’s write a class that we will use to learn how to call Lua table functions. Suppose we want to keep a list of places we want to go and note whether we have visited them. In <code>script.lua</code>, define a table to be used as the prototype as follows:</p>
<pre class="source-code">
Destinations = { places = {} }
setmetatable(Destinations.places, {
    __newindex = function (t, k, v)
        print("You cannot use Destinations directly")
    end,
})</pre>
<p>We defined a table named <code>Destinations</code>. It contains a map named <code>places</code> to track locations and keep a tab on whether or not they were visited. The key will be the places we want to go, and the value will be <em class="italic">Booleans</em>. We<a id="_idIndexMarker259"/> will define table functions after we have explained how we can use <strong class="bold">metatables</strong> to achieve OO behavior.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Using Lua metatables to achieve inheritance</h2>
<p>Since <code>Destinations</code> is first<a id="_idIndexMarker260"/> of all a <a id="_idIndexMarker261"/>plain table, by default you can modify its <code>places</code> entry. How can we prevent users from using it directly? Probably you already know or have guessed. We need to set a Lua metatable. We can use <code>setmetatable</code> to overwrite some operations on the tables. This is comparable to operator overloading in C++.</p>
<p>In our case, we <a id="_idIndexMarker262"/>set the <code>__newindex</code> <code>Destinations.places</code> to a function that does nothing but print an error message. <code>__newindex</code> is called when we assign to an absent table key. This is similar to overloading the C++ subscript operator. We could go to more extremes, but it’s fine with this simple limitation to show an attitude.</p>
<p>There is also an <code>__index</code> metamethod we can provide that is used to access absent table keys. This is how we can achieve inheritance behavior. Suppose that we have a table named <code>dst</code> that uses <code>Destinations</code> as its prototype. When we call <code>dst.wish()</code> to add a city to the wish list, what Lua is really doing is first looking up the function via <code>dst["wish"]</code>. Since <code>dst</code> does not have a <code>wish</code> method, Lua calls the <code>__index</code> metamethod, in which we can call the <code>wish</code> method in the <code>Destinations</code> table. This is how <code>Destinations</code> acts as the prototype for <code>dst</code>.</p>
<p>To see it in action, in <code>script.lua</code>, add a constructor for <code>Destinations</code> to create new instances:</p>
<pre class="source-code">
function Destinations.new(global_name)
    local obj = { places = {} }
    setmetatable(obj, {__index = Destinations})
    if global_name then _G[global_name] = obj end
    return obj
end</pre>
<p>The <code>new</code> method involves the following steps:</p>
<ol>
<li>It creates a new <code>obj</code> local table with an entry named <code>places</code>, matching the prototype table.</li>
<li>It sets <code>obj</code>’s <code>__index</code> metamethod as the <code>Destination</code> table. This is another syntax sugar that you can use to set a table as the metamethod. Then, Lua will redirect the lookup for absent keys to the prototype table directly.</li>
<li>It assigns the newly created object to a global variable if <code>global_name</code> is provided. Global variables are held in the unique table, <code>_G</code>. If we used the code purely in Lua, we<a id="_idIndexMarker263"/> wouldn’t need this step. This is to make the new object easily accessible in C++.</li>
<li>It returns the new object.</li>
</ol>
<p class="callout-heading">More about design decisions</p>
<p class="callout">We provided an option <a id="_idIndexMarker264"/>to set a global variable in an object creator. This is a bit unusual and can be considered to cause a side effect from a constructor. You should not blindly copy this paradigm. Consider the following options:</p>
<p class="callout">You need to create a Lua executor, do something, and then let it go. This is like invoking a shell command. Most examples in this book use Lua in this way. There is little chance of abusing the global scope. So, assigning the object to a global variable is convenient and efficient.</p>
<p class="callout">You need to work with a Lua executor heavily for many things. Then, you can implement a special C++ function to create and keep the table in the stack, and another function to remove it later.</p>
<p class="callout">You need to work with a table object exclusively. You might create it in C++’s constructor and keep the table at the bottom of the Lua stack, as pointed out earlier in this chapter.</p>
<p class="callout">Better yet, do not use Lua tables at all. In this book, we need to learn how to integrate Lua tables with C++ so that you can do very complex interactions when you need to. But maybe you could divide the C++ domain and the Lua domain more cleanly, and they only send each other simple instructions and results.</p>
<p>With object<a id="_idIndexMarker265"/> construction sorted out, we can implement its member functions to make <code>Destinations</code> complete.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor127"/>Implementing Lua class member functions</h2>
<p>For a fully functional <a id="_idIndexMarker266"/>destination wish list, we need methods to add a place to the wish list. Mark a place visited and check the status of the wish list. Let’s define the wish list modifying functions first. In <code>script.lua</code>, add the following code:</p>
<pre class="source-code">
function Destinations:wish(...)
    for _, place in ipairs{...} do
        self.places[place] = false
    end
end
function Destinations:went(...)
    for _, place in ipairs{...} do
        self.places[place] = true
    end
end</pre>
<p>The <code>wish</code> function takes a variable number of arguments, adds them to the <code>places</code> map as keys, and sets their values as <code>false</code> to indicate an unvisited state. The <code>went</code> function is similar and marks its arguments as visited.</p>
<p>The colon operator (<code>:</code>) is a syntax sugar to pass the table as the <code>self</code> parameter to the function. For example, our declaration of the <code>wish</code> function is equivalent to the following:</p>
<pre class="source-code">
function Destinations.wish(self, ...)</pre>
<p>Here, <code>self</code> will be the table referenced to call the <code>wish</code> method. This <code>self</code> argument is how most OOP languages work. C++ hides it from you and passes a <code>this</code> pointer to the compiled member methods. Python needs <code>self</code> as the first argument explicitly in member function definitions, with no syntax sugar available. But when calling the Python member functions, you do not need to pass <code>self</code> explicitly.</p>
<p>Next, implement the <a id="_idIndexMarker267"/>wish list query functions in <code>script.lua</code> as follows:</p>
<pre class="source-code">
function Destinations:list_visited()
    local result = {}
    for place, visited in pairs(self.places) do
        if visited then result[#result + 1] = place end
    end
    return table.unpack(result)
end
function Destinations:list_unvisited()
    local result = {}
    for place, visited in pairs(self.places) do
        if not visited then
            result[#result + 1] = place
        end
    end
    return table.unpack(result)
end</pre>
<p>These functions list visited places and unvisited places respectively.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor128"/>Testing it out</h2>
<p>You can <a id="_idIndexMarker268"/>test the <code>Destinations</code> class in a Lua interpreter to make sure it is implemented correctly before using it in C++. Here’s an example:</p>
<pre class="source-code">
Lua 5.4.6  Copyright (C) 1994-2023 Lua.org, PUC-Rio
&gt; dofile("script.lua")
&gt; dst = Destinations.new()
&gt; dst:wish("London", "Paris", "Amsterdam")
&gt; dst:went("Paris")
&gt; dst:list_visited()
Paris
&gt; dst:list_unvisited()
London  Amsterdam</pre>
<p>You can add some cities to the wish list, mark one as visited, and print out the list.</p>
<p>With a Lua class ready, we can learn how to call Lua table functions from C++.</p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor129"/>Working with Lua table functions</h1>
<p>For our Lua executor, we<a id="_idIndexMarker269"/> want to call table functions with the same level of support as calling global functions. Similar to <code>call</code> and <code>vcall</code>, we can define two functions named <code>tcall</code> and <code>vtcall</code> that call table functions and return a single value and a list of values respectively.</p>
<p>We need to add two more pieces of information to the new C++ member functions – namely, the following:</p>
<ul>
<li>The table name, which is obvious</li>
<li>Whether we should pass the <code>self</code> argument to the table function</li>
</ul>
<p>More on the latter point:</p>
<ul>
<li>When the table function does not refer <code>self</code> and is used like C++ static member functions, we do not need to pass <code>self</code></li>
<li>When the table function refers <code>self</code> and is used like C++ member functions, we need to pass <code>self</code></li>
</ul>
<p>Let’s implement <a id="_idIndexMarker270"/>the code to reinforce what we have just talked about.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor130"/>Implementing table function support</h2>
<p>In <code>LuaExecutor.h</code>, add <a id="_idIndexMarker271"/>the following declarations:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    template &lt;typename... Ts&gt;
    LuaValue tcall(
        const std::string &amp;table,
        const std::string &amp;function,
        bool shouldPassSelf,
        const Ts &amp;...params);
    template &lt;typename... Ts&gt;
    std::vector&lt;LuaValue&gt; vtcall(
        const std::string &amp;table,
        const std::string &amp;function,
        bool shouldPassSelf,
        const Ts &amp;...params);
};</pre>
<p><code>table</code> is the table name. <code>function</code> is the function name, which is a key in the table. <code>shouldPassSelf</code> denotes whether we should pass the table as the first argument to the table function. <code>params</code> is a list of function arguments.</p>
<p>Next, let’s code the <code>tcall</code> function in <code>LuaExecutor.h</code> as follows; note that the parameter<a id="_idIndexMarker272"/> list has been omitted to save space:</p>
<pre class="source-code">
template &lt;typename... Ts&gt;
LuaValue LuaExecutor::tcall(...)
{
    int type = lua_getglobal(L, table.c_str());
    assert(LUA_TTABLE == type);
    type = lua_getfield(L, -1, function.c_str());
    assert(LUA_TFUNCTION == type);
    if (shouldPassSelf) {
        lua_getglobal(L, table.c_str());
    }
    for (auto param :
        std::initializer_list&lt;LuaValue&gt;{params...}) {
        pushValue(param);
    }
    int nparams = sizeof...(params) +
        (shouldPassSelf ? 1 : 0);
    pcall(nparams, 1);
    auto result = popValue();
    lua_pop(L, 1);
    return result;
}</pre>
<p>In the previous listing, it’s doing six steps separated by newlines, as follows:</p>
<ol>
<li>It gets a global table and pushes it onto the stack.</li>
<li>It pushes the table function onto the stack. We are using the <code>lua_getfield</code> shortcut.</li>
<li>It pushes the table reference onto the stack again, if <code>shouldPassSelf</code> is <code>true</code>.</li>
<li>It pushes the remaining function arguments.</li>
<li>It calls the table function. Pay attention to the number of parameters passed.</li>
<li>It pops the table function result, pops the table reference pushed in <em class="italic">step 1</em>, and returns the function result.</li>
</ol>
<p>If you have done your homework for the previous chapter, you can insert <code>dumpStack();</code> at the newlines and see how the Lua stack changes.</p>
<p>Take a moment to digest the <code>vcall</code> implementation. And now, you need to implement <code>vtcall</code> on your own.</p>
<p class="callout-heading">Tips</p>
<p class="callout">Reference <code>vcall</code> and <code>tcall</code>. Pay special attention to getting the count of returned values and where you should put <code>int stackSz = </code><code>lua_gettop(L);</code>.</p>
<p>You can test if <a id="_idIndexMarker273"/>you have implemented <code>vtcall</code> correctly with the test code that follows.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor131"/>Testing it out</h2>
<p>We will work with<a id="_idIndexMarker274"/> the Lua <code>Destinations</code> class in C++. In <code>main.cpp</code>, replace the test code with the following:</p>
<pre class="source-code">
lua-&gt;tcall("Destinations", "new", false,
    LuaString::make("dst"));
lua-&gt;tcall("dst", "wish", true,
    LuaString::make("London"),
    LuaString::make("Paris"),
    LuaString::make("Amsterdam"));
lua-&gt;tcall("dst", "went", true,
    LuaString::make("Paris"));
auto visited = lua-&gt;vtcall(
    "dst", "list_visited", true);
auto unvisited = lua-&gt;vtcall(
    "dst", "list_unvisited", true);</pre>
<p>This is doing the same thing as when we tested <code>Destinations</code> in the interactive Lua interpreter. An explanation for this is provided here:</p>
<ol>
<li>It creates an instance of the class and stores the object in the <code>dst</code> global variable. In the <code>lua-&gt;tcall</code> invocation we set <code>shouldPassSelf</code> as <code>false</code>.</li>
<li>It adds three<a id="_idIndexMarker275"/> cities to the wish list of <code>dst</code>. From now on, we are working with <code>dst</code> and are passing the instance as a <code>self</code> argument to the table functions.</li>
<li>It marks <code>Paris</code> as <code>visited</code>.</li>
<li>It gets a list of visited cities.</li>
<li>It gets a list of unvisited cities.</li>
</ol>
<p>Add the following lines to print the <code>visited</code> and <code>unvisited</code> lists:</p>
<pre class="source-code">
std::cout &lt;&lt; "Visited:" &lt;&lt; std::endl;
for (auto place : visited) {
    std::cout &lt;&lt; std::get&lt;LuaString&gt;(place).value
              &lt;&lt; std::endl;
}
std::cout &lt;&lt; "Unvisited:" &lt;&lt; std::endl;
for (auto place : unvisited) {
    std::cout &lt;&lt; std::get&lt;LuaString&gt;(place).value
              &lt;&lt; std::endl;
}</pre>
<p>Compile and run the code. If you have done everything correctly, you should see an output as follows:</p>
<pre class="source-code">
Visited:
Paris
Unvisited:
London
Amsterdam</pre>
<p>Congratulations! You<a id="_idIndexMarker276"/> have implemented in C++ a mechanism to call Lua table functions. This is by far the most complex logic we have learned!</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor132"/>Summary</h1>
<p>In this chapter, we learned how to work with Lua tables in C++. We also touched on OOP in Lua and how it differs from that in C++.</p>
<p>We also explored some design decisions and why <code>LuaExecutor</code> is implemented in the way it is. It is designed to learn how to integrate Lua with C++, with a structure that can be broken down into chapters.</p>
<p>By now, you can use <code>LuaExecutor</code> to call most Lua scripts, although it has some limitations. For example, we do not support passing another table, except <code>self</code>,  as a parameter to a function. You can try to implement such a function on your own, but it is likely not a good idea. It is better to keep the communication between Lua and C++ simple.</p>
<p>Take your time to experiment and practice what we have learned. The focus so far is on how to call Lua code from C++. In the next chapter, we will start to learn how to call C++ code from Lua.</p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor133"/>Exercises</h1>
<ol>
<li>Rewrite the string key overload version of <code>LuaExecutor::getTable</code> and <code>LuaExecutor::setTable</code>. Use the <code>lua_getfield</code> and <code>lua_setfield</code> Lua library functions. You can use the same test code in this chapter to test whether you have implemented them correctly.</li>
<li>Implement <code>LuaExecutor::vtcall</code>. You should have already done so whether you have reached this point.</li>
</ol>
</div>
</div>

<div><div><h1 id="_idParaDest-132" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor134"/>Part 3 – Calling C++ from Lua</h1>
<p>With your knowledge of calling Lua from C++, in this part, you will continue to learn how to call C++ from Lua.</p>
<p>You will start by learning how to implement and export a C++ function that can be called from Lua scripts. Then, the complexity will increase step by step. You will export a C++ class as a Lua module and improve the process of how it is exported. Finally, you will have a general module exporter that can help you to export any C++ class to Lua.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><em class="italic">Chapter 6</em>, <em class="italic">How to Call C++ from Lua</em></li>
<li><em class="italic">Chapter 7</em>, <em class="italic">Working with C++ Types</em></li>
<li><em class="italic">Chapter 8</em>, <em class="italic">Abstracting a C++ Type Exporter</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>