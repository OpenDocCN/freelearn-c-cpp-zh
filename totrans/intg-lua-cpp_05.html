<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor112"/>5</h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Working with Lua Tables</h1>
<p>In this chapter, we will continue to improve our Lua executor to work with tables. Many of the mechanisms are extensions of the learnings from the previous chapter. You will also learn about <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) in Lua and how to call Lua object methods. In all, Lua objects are Lua tables <span class="No-Break">by nature.</span></p>
<p>We will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Working with Lua <span class="No-Break">table entries</span></li>
<li>Working with <span class="No-Break">Lua arrays</span></li>
<li>OOP <span class="No-Break">in Lua</span></li>
<li>Working with Lua <span class="No-Break">table functions</span></li>
</ul>
<h1 id="_idParaDest-114"><a id="_idTextAnchor114"/>Technical requirements</h1>
<p>Here are the technical requirements for <span class="No-Break">this chapter:</span></p>
<ul>
<li>You can access the source code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter05</span></a><span class="No-Break">.</span></li>
<li>You can understand and execute the code in the <strong class="source-inline">begin</strong> folder from the preceding GitHub link. If you haven’t already done so, please try to do the exercises in the previous chapter on your own, or at least understand the solutions in the <span class="No-Break"><strong class="source-inline">begin</strong></span><span class="No-Break"> folder.</span></li>
<li>You can understand the <strong class="source-inline">Makefile</strong> located in GitHub and can build the projects. Alternatively, you can use your own way to build the <span class="No-Break">source code.</span></li>
</ul>
<h1 id="_idParaDest-115"><a id="_idTextAnchor115"/>Working with Lua table entries</h1>
<p>A <strong class="bold">table entry</strong> is the key-value <a id="_idIndexMarker235"/>pair for a table element. Lua table keys <a id="_idIndexMarker236"/>can be of many data types – for example, of function type. For practical reasons, especially when integrating with C++, we only consider string keys and <span class="No-Break">integer keys.</span></p>
<p>In <strong class="source-inline">script.lua</strong>, add a simple table <span class="No-Break">as follows:</span></p>
<pre class="source-code">
position = { x = 0, y = 0 }</pre>
<p><strong class="source-inline">position</strong> is indexed by strings. We will learn how to read from and write to it <span class="No-Break">in C++.</span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Getting a table entry value</h2>
<p>Up until now, in C++ code, we <a id="_idIndexMarker237"/>have only used one piece of information to locate a value in Lua. Consider how we implemented <strong class="source-inline">LuaExecutor::getGlobal</strong> and <strong class="source-inline">LuaExecutor::call</strong>. To locate a global variable or to call a function, we pass the name of the variable or the function to a Lua <span class="No-Break">library method.</span></p>
<p>To work with a table entry, we would need two pieces of information – the table and the table entry key. First, we need to locate the table; after that, we can use the entry key to work on the <span class="No-Break">entry value.</span></p>
<p>The Lua library method to get an entry value is declared <span class="No-Break">as follows:</span></p>
<pre class="source-code">
int lua_gettable(lua_State *L, int index);</pre>
<p>Wait! We analyzed that we would need two pieces of information to locate a table entry, no? How is it possible that <strong class="source-inline">lua_gettable</strong> only takes one meaningful argument, <strong class="source-inline">index</strong>, besides the Lua state, <strong class="source-inline">L</strong>? Remember the Lua stack? The top of the stack is commonly used to pass additional information. To quote the Lua reference manual, <strong class="source-inline">lua_gettable</strong> does <span class="No-Break">the following:</span></p>
<p class="author-quote"><em class="italic">Pushes onto the stack the value</em> <strong class="source-inline">t[k]</strong><em class="italic">, whe<a id="_idTextAnchor117"/>re </em><strong class="source-inline">t</strong> <em class="italic">is the value at the given</em> <strong class="source-inline">index</strong> <em class="italic">and</em> <strong class="source-inline">k</strong> <em class="italic">is the value on the top of the stack. This function pops the key from the stack, pushing the resulting value in its place. (</em><a href="https://www.lua.org/manual/5.4/manual.xhtml#lua_gettable">https://www.lua.org/manual/5.4/manual.xhtml#lua_gettable</a><em class="italic">)</em></p>
<p>As explained, the two keys are both located in the Lua stack. As seen in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.1</em>, before the call, the table entry key must be at the top of the stack, while the table can be in any other position in the stack. This is a Lua design decision. Since you may work on the same table from time to time, you can keep the table reference somewhere in the stack to avoid repeatedly pushing it onto the stack for <span class="No-Break">each access:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<img alt="Figure 5.1 – lua_gettable" height="736" src="image/B20927_05_01.jpg" width="906"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – lua_gettable</p>
<p>After understanding<a id="_idIndexMarker238"/> the mechanism, it’s time to make a design decision. How should we implement the table access in C++? Here are <span class="No-Break">some possibilities:</span></p>
<ul>
<li>We can push the table onto the stack and keep it there. For example, if we are working with a complex table, we can implement a C++ class to load the table at the bottom of the stack and have the C++ object work exclusively with <span class="No-Break">the table.</span></li>
<li>We can push the table onto the stack whenever we need to and pop it immediately after it’s no longer needed. This works well if the C++ class is working with many Lua values and it is not a performance concern to push the Lua table <span class="No-Break">each time.</span></li>
</ul>
<p>Since we are implementing a general Lua executor, we will choose the latter option. In <strong class="source-inline">LuaExecutor.h</strong>, declare the <span class="No-Break">following function:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    LuaValue getTable(const std::string &amp;table,
                      const std::string &amp;key);
};</pre>
<p>It takes the table<a id="_idIndexMarker239"/> name and the table entry key name and returns a <strong class="source-inline">LuaValue</strong> instance. We are only concerned about the string-type key at the moment. In <strong class="source-inline">LuaExecutor.cc</strong>, implement it <span class="No-Break">as follows:</span></p>
<pre class="source-code">
LuaValue LuaExecutor::getTable(
    const std::string &amp;table, const std::string &amp;key)
{
    int type = lua_getglobal(L, table.c_str());
    assert(LUA_TTABLE == type);
    lua_pushstring(L, key.c_str());
    lua_gettable(L, -2);
    auto value = popValue();
    lua_pop(L, 1);
    return value;
}</pre>
<p>The code is doing the following things to get a table <span class="No-Break">entry value:</span></p>
<ol>
<li>It pushes the table reference onto the top of the stack <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">lua_getglobal</strong></span><span class="No-Break">.</span></li>
<li>It pushes the table entry key onto the top of the stack with <strong class="source-inline">lua_pushstring</strong>. Now, the table is the second from <span class="No-Break">the top.</span></li>
<li>It calls <strong class="source-inline">lua_gettable</strong> to pop the entry key and push the entry value. Now, the entry value is at the top of <span class="No-Break">the stack.</span></li>
<li>It pops the top of the stack as a <strong class="source-inline">LuaValue</strong> with <strong class="source-inline">LuaExecutor::popValue</strong>. Now, the top of the stack is again the <span class="No-Break">table reference.</span></li>
<li>It pops the table with <strong class="source-inline">lua_pop</strong>, as it’s no <span class="No-Break">longer needed.</span></li>
<li>It returns the table <span class="No-Break">entry value.</span></li>
</ol>
<p>In this implementation, we limit ourselves to only working with tables in the global scope. This is <a id="_idIndexMarker240"/>because we are implementing a general Lua executor. For special use cases, you can implement specific <span class="No-Break">C++ classes.</span></p>
<p>Now, let’s see how to set a table <span class="No-Break">entry value.</span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor118"/>Setting a table entry value</h2>
<p>The Lua library<a id="_idIndexMarker241"/> function to set a table entry value is declared <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void lua_settable(lua_State *L, int index);</pre>
<p>And the quote from the Lua reference manual explains <span class="No-Break">it well:</span></p>
<p class="author-quote"><em class="italic">Does the equivalent to</em> <strong class="source-inline">t[k] = v</strong><em class="italic">, <a id="_idTextAnchor119"/>where</em> <strong class="source-inline">t</strong> <em class="italic">is the value at the given index</em>, <strong class="source-inline">v</strong> <em class="italic">is the value on the top of the stack, and</em> <strong class="source-inline">k</strong> <em class="italic">is the value just below the top. Pops both the key and the value from the stack. (</em><a href="https://www.lua.org/manual/5.4/manual.xhtml#lua_settable">https://www.lua.org/manual/5.4/manual.xhtml#lua_settable</a><em class="italic">)</em></p>
<p>This can be seen in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.2</em>. Now, we need to push both the entry key and the entry value onto the <span class="No-Break">Lua stack:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 5.2 – lua_settable" height="737" src="image/B20927_05_02.jpg" width="901"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – lua_settable</p>
<p>In <strong class="source-inline">LuaExecutor.h</strong>, add the <a id="_idIndexMarker242"/>function declaration, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    void setTable(const std::string &amp;table,
                  const std::string &amp;key,
                  const LuaValue &amp;value);
};</pre>
<p>We are passing the value as a <strong class="source-inline">LuaValue</strong>. In <strong class="source-inline">LuaExecutor.cc</strong>, implement it <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void LuaExecutor::setTable(const std::string &amp;table,
    const std::string &amp;key, const LuaValue &amp;value)
{
    int type = lua_getglobal(L, table.c_str());
    assert(LUA_TTABLE == type);
    lua_pushstring(L, key.c_str());
    pushValue(value);
    lua_settable(L, -3);
    lua_pop(L, 1);
}</pre>
<p>The code is explained in the <span class="No-Break">following steps:</span></p>
<ol>
<li>It pushes the table reference onto the top of the stack <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">lua_getglobal</strong></span><span class="No-Break">.</span></li>
<li>It pushes the table entry key onto the stack <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">lua_pushstring</strong></span><span class="No-Break">.</span></li>
<li>It pushes the table entry value onto the stack with <strong class="source-inline">LuaExecutor::pushValue</strong>. Now, the table reference is the third from the top of <span class="No-Break">the stack.</span></li>
<li>It sets the table entry with <strong class="source-inline">lua_settable</strong>. This also pops the top two items from <span class="No-Break">the stack.</span></li>
<li>It pops the table with <strong class="source-inline">lua_pop</strong>. The table is pushed onto the stack in <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">.</span></li>
</ol>
<p>Next, let’s test our<a id="_idIndexMarker243"/> implementations <span class="No-Break">so far.</span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor120"/>Testing table operations with string keys</h2>
<p>In <strong class="source-inline">main.cpp</strong>, add the <a id="_idIndexMarker244"/>following helper <a id="_idIndexMarker245"/>function to print out a <span class="No-Break"><strong class="source-inline">position</strong></span><span class="No-Break"> table:</span></p>
<pre class="source-code">
void dumpPosition(LuaExecutor *lua)
{
    auto x = lua-&gt;getTable("position", "x");
    auto y = lua-&gt;getTable("position", "y");
    std::cout &lt;&lt; "x=" &lt;&lt; std::get&lt;LuaNumber&gt;(x).value
              &lt;&lt; ", y=" &lt;&lt; std::get&lt;LuaNumber&gt;(y).value
              &lt;&lt; std::endl;
}</pre>
<p><strong class="source-inline">dumpPosition</strong> calls <strong class="source-inline">LuaExecutor::getTable</strong>, which we have just implemented, to get and print the <strong class="source-inline">x</strong> field and the <strong class="source-inline">y</strong> field. In <strong class="source-inline">main()</strong>, change the test code <span class="No-Break">as follows:</span></p>
<pre class="source-code">
dumpPositon(lua.get());
lua-&gt;setTable("position", "x", LuaNumber::make(3));
lua-&gt;setTable("position", "y", LuaNumber::make(4));
dumpPositon(lua.get());</pre>
<p>This first prints a <strong class="source-inline">position</strong> table, then changes <strong class="source-inline">position.x</strong> to <strong class="source-inline">3</strong> and <strong class="source-inline">position.y</strong> to <strong class="source-inline">4</strong> and prints the table again. If you have done everything correctly, you should see <a id="_idIndexMarker246"/>the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker247"/></span><span class="No-Break"> output:</span></p>
<pre class="source-code">
x=0, y=0
x=3, y=4</pre>
<p>Next, let’s learn how to work with integer types of <span class="No-Break">table keys.</span></p>
<p class="callout-heading">Do you remember?</p>
<p class="callout">If a Lua table uses integer keys exclusively, what else can the table <span class="No-Break">be called?</span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor121"/>Working with Lua arrays</h1>
<p>Yes – a Lua table <a id="_idIndexMarker248"/>with only integer keys is called an array or a sequence. In <strong class="source-inline">script.lua</strong>, add the <span class="No-Break">following array:</span></p>
<pre class="source-code">
seq = { 0, 0, 0 }</pre>
<p>From the C++ side, compared with string keys, the only difference is the data type of the keys. It’s straightforward to overload the <strong class="source-inline">getTable</strong> and <strong class="source-inline">setTable</strong> functions by using integer keys. In <strong class="source-inline">LuaExecutor.h</strong>, add the <span class="No-Break">following declarations:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    LuaValue getTable(const std::string &amp;table,
                      int index);
    void setTable(const std::string &amp;table,
                  int index,
                  const LuaValue &amp;value);
};</pre>
<p><strong class="source-inline">index</strong> is the Lua array index – starting from 1. Do not confuse this with the Lua stack index. In the Lua executor’s public APIs, there should be no mention of the Lua stack or <span class="No-Break">Lua state.</span></p>
<p>One way to implement them is to copy the string key version, and instead of calling <strong class="source-inline">lua_pushstring(L, key.c_str())</strong>, call <strong class="source-inline">lua_pushinteger(L, index)</strong>. This will work. But <a id="_idIndexMarker249"/>what’s the point of repeating ourselves if this is what we would do? Is there <span class="No-Break">another trick?</span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>Using array index optimization</h2>
<p>Lua puts lots of <a id="_idIndexMarker250"/>emphasis on speed. Because an array is a common form of a Lua table, the Lua library provides special functions to work with arrays, as <span class="No-Break">seen here:</span></p>
<pre class="source-code">
void lua_geti(lua_State *L, int index, int key);
void lua_seti(lua_State *L, int index, int key);</pre>
<p>These functions accept two pieces of information. The <strong class="source-inline">index</strong> argument is the position of the table in the Lua stack. The <strong class="source-inline">key</strong> argument is the array index, as it is also the table entry key. Compared with using <strong class="source-inline">lua_gettable</strong> and <strong class="source-inline">lua_settable</strong>, you no longer need to push the table entry key onto the stack. <strong class="source-inline">lua_seti</strong> expects the value to be at the top of <span class="No-Break">the stack.</span></p>
<p>Now, let’s implement the <strong class="source-inline">getTable</strong> function for arrays. In <strong class="source-inline">LuaExecutor.cc</strong>, add the code <span class="No-Break">as follows:</span></p>
<pre class="source-code">
LuaValue LuaExecutor::getTable(
    const std::string &amp;table, int index)
{
    int type = lua_getglobal(L, table.c_str());
    assert(LUA_TTABLE == type);
    lua_geti(L, -1, index);
    auto value = popValue();
    lua_pop(L, 1);
    return value;
}</pre>
<p>The code is <a id="_idIndexMarker251"/>doing <span class="No-Break">the following:</span></p>
<ol>
<li>It gets the table from a global variable and pushes its reference onto the top of <span class="No-Break">the stack.</span></li>
<li>It calls <strong class="source-inline">lua_geti</strong> with the specified array index. The Lua library will push the value onto <span class="No-Break">the stack.</span></li>
<li>It pops the value as a <strong class="source-inline">LuaValue</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">LuaExecutor::popValue</strong></span><span class="No-Break">.</span></li>
<li>It pops the <span class="No-Break">table reference.</span></li>
<li>It returns <span class="No-Break">the value.</span></li>
</ol>
<p>This does not need to push the array index onto the stack at all. Similarly, implement the <strong class="source-inline">setTable</strong> function for arrays. In <strong class="source-inline">LuaExecutor.cc</strong>, add the <span class="No-Break">following code:</span></p>
<pre class="source-code">
void LuaExecutor::setTable(const std::string &amp;table,
    int index, const LuaValue &amp;value)
{
    int type = lua_getglobal(L, table.c_str());
    assert(LUA_TTABLE == type);
    pushValue(value);
    lua_seti(L, -2, index);
    lua_pop(L, 1);
}</pre>
<p>The previous code is explained <span class="No-Break">as follows:</span></p>
<ol>
<li>It gets the table from a global variable and pushes its reference onto the top of <span class="No-Break">the stack.</span></li>
<li>It pushes the value for the <strong class="source-inline">index</strong> array position with <strong class="source-inline">LuaExecutor::pushValue</strong>. Now, the table reference is second from the top of <span class="No-Break">the stack.</span></li>
<li>It calls <strong class="source-inline">lua_seti</strong> to set the array position value. It also pops the value from the stack. Now, the table reference is again at the top of <span class="No-Break">the stack.</span></li>
<li>It pops <a id="_idIndexMarker252"/>the <span class="No-Break">table reference.</span></li>
</ol>
<p>Next, let’s <span class="No-Break">test this.</span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Testing the array index optimization</h2>
<p>In <strong class="source-inline">main.cpp</strong>, add another<a id="_idIndexMarker253"/> helper function to print a <strong class="source-inline">seq</strong> Lua array, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void dumpSeq(LuaExecutor *lua)
{
    auto v1 = lua-&gt;getTable("seq", 1);
    auto v2 = lua-&gt;getTable("seq", 2);
    auto v3 = lua-&gt;getTable("seq", 3);
    std::cout &lt;&lt; "seq={"
              &lt;&lt; std::get&lt;LuaNumber&gt;(v1).value &lt;&lt; ", "
              &lt;&lt; std::get&lt;LuaNumber&gt;(v2).value &lt;&lt; ", "
              &lt;&lt; std::get&lt;LuaNumber&gt;(v3).value &lt;&lt; "}"
              &lt;&lt; std::endl;
}</pre>
<p>This uses <strong class="source-inline">LuaExecutor::getTable</strong> with integer keys. Replace the test code in <strong class="source-inline">main()</strong> with <span class="No-Break">the following:</span></p>
<pre class="source-code">
dumpSeq(lua.get());
lua-&gt;setTable("seq", 1, LuaNumber::make(3));
lua-&gt;setTable("seq", 2, LuaNumber::make(9));
lua-&gt;setTable("seq", 3, LuaNumber::make(27));
dumpSeq(lua.get());</pre>
<p>This changes the <strong class="source-inline">seq</strong> array to <strong class="source-inline">{ 3, 9, 27 }</strong>. If you have done everything correctly, you should see the output <span class="No-Break">as follows:</span></p>
<pre class="source-code">
seq={0, 0, 0}
seq={3, 9, 27}</pre>
<p>Well done, Lua, for the optimization. And well done, yourself, for making it this far. But how about string<a id="_idIndexMarker254"/> keys? In real-world scenarios, more often than not, a Lua table is not <span class="No-Break">an array.</span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/>Revisiting string keys</h2>
<p>When we first <a id="_idIndexMarker255"/>learned to use a string key to access the Lua table, we chose the longer journey to push the key onto the stack. This is because it is a general mechanism, and once learned, you can change to use another data type as <span class="No-Break">table keys.</span></p>
<p>It is fair to expect an optimization for string keys as well. Here are the Lua library functions <span class="No-Break">for this:</span></p>
<pre class="source-code">
int lua_getfield(
    lua_State *L, int index, const char *k);
void lua_setfield(
    lua_State *L, int index, const char *k);</pre>
<p>These functions work similarly to <strong class="source-inline">lua_geti</strong> and <strong class="source-inline">lua_seti</strong>. <strong class="source-inline">lua_getfield</strong> also returns the type of the table entry value. At the end of this chapter, you will get homework to rewrite <strong class="source-inline">LuaExecutor</strong> with them. You can also choose to do it <span class="No-Break">right now.</span></p>
<p>Before learning <a id="_idIndexMarker256"/>how to call a function from a Lua table, let’s write a Lua class. Lua tables with functions are more like <span class="No-Break">C++ objects.</span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor125"/>OOP in Lua</h1>
<p>OOP in Lua is different <a id="_idIndexMarker257"/>than that in C++. In C++, you define a class and create instances of the class. The classes defined are unique types at the <span class="No-Break">language level.</span></p>
<p>In Lua, there is no native class concept. OOP in Lua is prototype-based. This is more like JavaScript if you are familiar with it. For a Lua table, if an entry is not present, you can instruct Lua to check another table for it, which acts as the prototype for the table you are <span class="No-Break">explicitly referencing.</span></p>
<p>For ease of understanding, it’s fine to call this prototype table the “class” and the table the “object”. Or, you can call the relationship “inheritance.” Although prototype and class are two <a id="_idIndexMarker258"/>different <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) methodologies, sometimes people use the two <span class="No-Break">terms interchangeably.</span></p>
<p>Let’s write a class that we will use to learn how to call Lua table functions. Suppose we want to keep a list of places we want to go and note whether we have visited them. In <strong class="source-inline">script.lua</strong>, define a table to be used as the prototype <span class="No-Break">as follows:</span></p>
<pre class="source-code">
Destinations = { places = {} }
setmetatable(Destinations.places, {
    __newindex = function (t, k, v)
        print("You cannot use Destinations directly")
    end,
})</pre>
<p>We defined a table named <strong class="source-inline">Destinations</strong>. It contains a map named <strong class="source-inline">places</strong> to track locations and keep a tab on whether or not they were visited. The key will be the places we want to go, and the value will be <em class="italic">Booleans</em>. We<a id="_idIndexMarker259"/> will define table functions after we have explained how we can use <strong class="bold">metatables</strong> to achieve <span class="No-Break">OO behavior.</span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Using Lua metatables to achieve inheritance</h2>
<p>Since <strong class="source-inline">Destinations</strong> is first<a id="_idIndexMarker260"/> of all a <a id="_idIndexMarker261"/>plain table, by default you can modify its <strong class="source-inline">places</strong> entry. How can we prevent users from using it directly? Probably you already know or have guessed. We need to set a Lua metatable. We can use <strong class="source-inline">setmetatable</strong> to overwrite some operations on the tables. This is comparable to operator overloading <span class="No-Break">in C++.</span></p>
<p>In our case, we <a id="_idIndexMarker262"/>set the <strong class="source-inline">__newindex</strong> <strong class="bold">metamethod</strong> for <strong class="source-inline">Destinations.places</strong> to a function that does nothing but print an error message. <strong class="source-inline">__newindex</strong> is called when we assign to an absent table key. This is similar to overloading the C++ subscript operator. We could go to more extremes, but it’s fine with this simple limitation to show <span class="No-Break">an attitude.</span></p>
<p>There is also an <strong class="source-inline">__index</strong> metamethod we can provide that is used to access absent table keys. This is how we can achieve inheritance behavior. Suppose that we have a table named <strong class="source-inline">dst</strong> that uses <strong class="source-inline">Destinations</strong> as its prototype. When we call <strong class="source-inline">dst.wish()</strong> to add a city to the wish list, what Lua is really doing is first looking up the function via <strong class="source-inline">dst["wish"]</strong>. Since <strong class="source-inline">dst</strong> does not have a <strong class="source-inline">wish</strong> method, Lua calls the <strong class="source-inline">__index</strong> metamethod, in which we can call the <strong class="source-inline">wish</strong> method in the <strong class="source-inline">Destinations</strong> table. This is how <strong class="source-inline">Destinations</strong> acts as the prototype <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">dst</strong></span><span class="No-Break">.</span></p>
<p>To see it in action, in <strong class="source-inline">script.lua</strong>, add a constructor for <strong class="source-inline">Destinations</strong> to create <span class="No-Break">new instances:</span></p>
<pre class="source-code">
function Destinations.new(global_name)
    local obj = { places = {} }
    setmetatable(obj, {__index = Destinations})
    if global_name then _G[global_name] = obj end
    return obj
end</pre>
<p>The <strong class="source-inline">new</strong> method involves the <span class="No-Break">following steps:</span></p>
<ol>
<li>It creates a new <strong class="source-inline">obj</strong> local table with an entry named <strong class="source-inline">places</strong>, matching the <span class="No-Break">prototype table.</span></li>
<li>It sets <strong class="source-inline">obj</strong>’s <strong class="source-inline">__index</strong> metamethod as the <strong class="source-inline">Destination</strong> table. This is another syntax sugar that you can use to set a table as the metamethod. Then, Lua will redirect the lookup for absent keys to the prototype <span class="No-Break">table directly.</span></li>
<li>It assigns the newly created object to a global variable if <strong class="source-inline">global_name</strong> is provided. Global variables are held in the unique table, <strong class="source-inline">_G</strong>. If we used the code purely in Lua, we<a id="_idIndexMarker263"/> wouldn’t need this step. This is to make the new object easily accessible <span class="No-Break">in C++.</span></li>
<li>It returns the <span class="No-Break">new object.</span></li>
</ol>
<p class="callout-heading">More about design decisions</p>
<p class="callout">We provided an option <a id="_idIndexMarker264"/>to set a global variable in an object creator. This is a bit unusual and can be considered to cause a side effect from a constructor. You should not blindly copy this paradigm. Consider the <span class="No-Break">following options:</span></p>
<p class="callout">You need to create a Lua executor, do something, and then let it go. This is like invoking a shell command. Most examples in this book use Lua in this way. There is little chance of abusing the global scope. So, assigning the object to a global variable is convenient <span class="No-Break">and efficient.</span></p>
<p class="callout">You need to work with a Lua executor heavily for many things. Then, you can implement a special C++ function to create and keep the table in the stack, and another function to remove <span class="No-Break">it later.</span></p>
<p class="callout">You need to work with a table object exclusively. You might create it in C++’s constructor and keep the table at the bottom of the Lua stack, as pointed out earlier in <span class="No-Break">this chapter.</span></p>
<p class="callout">Better yet, do not use Lua tables at all. In this book, we need to learn how to integrate Lua tables with C++ so that you can do very complex interactions when you need to. But maybe you could divide the C++ domain and the Lua domain more cleanly, and they only send each other simple instructions <span class="No-Break">and results.</span></p>
<p>With object<a id="_idIndexMarker265"/> construction sorted out, we can implement its member functions to make <span class="No-Break"><strong class="source-inline">Destinations</strong></span><span class="No-Break"> complete.</span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor127"/>Implementing Lua class member functions</h2>
<p>For a fully functional <a id="_idIndexMarker266"/>destination wish list, we need methods to add a place to the wish list. Mark a place visited and check the status of the wish list. Let’s define the wish list modifying functions first. In <strong class="source-inline">script.lua</strong>, add the <span class="No-Break">following code:</span></p>
<pre class="source-code">
function Destinations:wish(...)
    for _, place in ipairs{...} do
        self.places[place] = false
    end
end
function Destinations:went(...)
    for _, place in ipairs{...} do
        self.places[place] = true
    end
end</pre>
<p>The <strong class="source-inline">wish</strong> function takes a variable number of arguments, adds them to the <strong class="source-inline">places</strong> map as keys, and sets their values as <strong class="source-inline">false</strong> to indicate an unvisited state. The <strong class="source-inline">went</strong> function is similar and marks its arguments <span class="No-Break">as visited.</span></p>
<p>The colon operator (<strong class="source-inline">:</strong>) is a syntax sugar to pass the table as the <strong class="source-inline">self</strong> parameter to the function. For example, our declaration of the <strong class="source-inline">wish</strong> function is equivalent to <span class="No-Break">the following:</span></p>
<pre class="source-code">
function Destinations.wish(self, ...)</pre>
<p>Here, <strong class="source-inline">self</strong> will be the table referenced to call the <strong class="source-inline">wish</strong> method. This <strong class="source-inline">self</strong> argument is how most OOP languages work. C++ hides it from you and passes a <strong class="source-inline">this</strong> pointer to the compiled member methods. Python needs <strong class="source-inline">self</strong> as the first argument explicitly in member function definitions, with no syntax sugar available. But when calling the Python member functions, you do not need to pass <span class="No-Break"><strong class="source-inline">self</strong></span><span class="No-Break"> explicitly.</span></p>
<p>Next, implement the <a id="_idIndexMarker267"/>wish list query functions in <strong class="source-inline">script.lua</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
function Destinations:list_visited()
    local result = {}
    for place, visited in pairs(self.places) do
        if visited then result[#result + 1] = place end
    end
    return table.unpack(result)
end
function Destinations:list_unvisited()
    local result = {}
    for place, visited in pairs(self.places) do
        if not visited then
            result[#result + 1] = place
        end
    end
    return table.unpack(result)
end</pre>
<p>These functions list visited places and unvisited <span class="No-Break">places respectively.</span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor128"/>Testing it out</h2>
<p>You can <a id="_idIndexMarker268"/>test the <strong class="source-inline">Destinations</strong> class in a Lua interpreter to make sure it is implemented correctly before using it in C++. Here’s <span class="No-Break">an example:</span></p>
<pre class="source-code">
Lua 5.4.6  Copyright (C) 1994-2023 Lua.org, PUC-Rio
&gt; dofile("script.lua")
&gt; dst = Destinations.new()
&gt; dst:wish("London", "Paris", "Amsterdam")
&gt; dst:went("Paris")
&gt; dst:list_visited()
Paris
&gt; dst:list_unvisited()
London  Amsterdam</pre>
<p>You can add some cities to the wish list, mark one as visited, and print out <span class="No-Break">the list.</span></p>
<p>With a Lua class ready, we can learn how to call Lua table functions <span class="No-Break">from C++.</span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor129"/>Working with Lua table functions</h1>
<p>For our Lua executor, we<a id="_idIndexMarker269"/> want to call table functions with the same level of support as calling global functions. Similar to <strong class="source-inline">call</strong> and <strong class="source-inline">vcall</strong>, we can define two functions named <strong class="source-inline">tcall</strong> and <strong class="source-inline">vtcall</strong> that call table functions and return a single value and a list of <span class="No-Break">values respectively.</span></p>
<p>We need to add two more pieces of information to the new C++ member functions – namely, <span class="No-Break">the following:</span></p>
<ul>
<li>The table name, which <span class="No-Break">is obvious</span></li>
<li>Whether we should pass the <strong class="source-inline">self</strong> argument to the <span class="No-Break">table function</span></li>
</ul>
<p>More on the <span class="No-Break">latter point:</span></p>
<ul>
<li>When the table function does not refer <strong class="source-inline">self</strong> and is used like C++ static member functions, we do not need to <span class="No-Break">pass </span><span class="No-Break"><strong class="source-inline">self</strong></span></li>
<li>When the table function refers <strong class="source-inline">self</strong> and is used like C++ member functions, we need to <span class="No-Break">pass </span><span class="No-Break"><strong class="source-inline">self</strong></span></li>
</ul>
<p>Let’s implement <a id="_idIndexMarker270"/>the code to reinforce what we have just <span class="No-Break">talked about.</span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor130"/>Implementing table function support</h2>
<p>In <strong class="source-inline">LuaExecutor.h</strong>, add <a id="_idIndexMarker271"/>the <span class="No-Break">following declarations:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    template &lt;typename... Ts&gt;
    LuaValue tcall(
        const std::string &amp;table,
        const std::string &amp;function,
        bool shouldPassSelf,
        const Ts &amp;...params);
    template &lt;typename... Ts&gt;
    std::vector&lt;LuaValue&gt; vtcall(
        const std::string &amp;table,
        const std::string &amp;function,
        bool shouldPassSelf,
        const Ts &amp;...params);
};</pre>
<p><strong class="source-inline">table</strong> is the table name. <strong class="source-inline">function</strong> is the function name, which is a key in the table. <strong class="source-inline">shouldPassSelf</strong> denotes whether we should pass the table as the first argument to the table function. <strong class="source-inline">params</strong> is a list of <span class="No-Break">function arguments.</span></p>
<p>Next, let’s code the <strong class="source-inline">tcall</strong> function in <strong class="source-inline">LuaExecutor.h</strong> as follows; note that the parameter<a id="_idIndexMarker272"/> list has been omitted to <span class="No-Break">save space:</span></p>
<pre class="source-code">
template &lt;typename... Ts&gt;
LuaValue LuaExecutor::tcall(...)
{
    int type = lua_getglobal(L, table.c_str());
    assert(LUA_TTABLE == type);
    type = lua_getfield(L, -1, function.c_str());
    assert(LUA_TFUNCTION == type);
    if (shouldPassSelf) {
        lua_getglobal(L, table.c_str());
    }
    for (auto param :
        std::initializer_list&lt;LuaValue&gt;{params...}) {
        pushValue(param);
    }
    int nparams = sizeof...(params) +
        (shouldPassSelf ? 1 : 0);
    pcall(nparams, 1);
    auto result = popValue();
    lua_pop(L, 1);
    return result;
}</pre>
<p>In the previous listing, it’s doing six steps separated by newlines, <span class="No-Break">as follows:</span></p>
<ol>
<li>It gets a global table and pushes it onto <span class="No-Break">the stack.</span></li>
<li>It pushes the table function onto the stack. We are using the <span class="No-Break"><strong class="source-inline">lua_getfield</strong></span><span class="No-Break"> shortcut.</span></li>
<li>It pushes the table reference onto the stack again, if <strong class="source-inline">shouldPassSelf</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></li>
<li>It pushes the remaining <span class="No-Break">function arguments.</span></li>
<li>It calls the table function. Pay attention to the number of <span class="No-Break">parameters passed.</span></li>
<li>It pops the table function result, pops the table reference pushed in <em class="italic">step 1</em>, and returns the <span class="No-Break">function result.</span></li>
</ol>
<p>If you have done your homework for the previous chapter, you can insert <strong class="source-inline">dumpStack();</strong> at the newlines and see how the Lua <span class="No-Break">stack changes.</span></p>
<p>Take a moment to digest the <strong class="source-inline">vcall</strong> implementation. And now, you need to implement <strong class="source-inline">vtcall</strong> on <span class="No-Break">your own.</span></p>
<p class="callout-heading">Tips</p>
<p class="callout">Reference <strong class="source-inline">vcall</strong> and <strong class="source-inline">tcall</strong>. Pay special attention to getting the count of returned values and where you should put <strong class="source-inline">int stackSz = </strong><span class="No-Break"><strong class="source-inline">lua_gettop(L);</strong></span><span class="No-Break">.</span></p>
<p>You can test if <a id="_idIndexMarker273"/>you have implemented <strong class="source-inline">vtcall</strong> correctly with the test code <span class="No-Break">that follows.</span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor131"/>Testing it out</h2>
<p>We will work with<a id="_idIndexMarker274"/> the Lua <strong class="source-inline">Destinations</strong> class in C++. In <strong class="source-inline">main.cpp</strong>, replace the test code with <span class="No-Break">the following:</span></p>
<pre class="source-code">
lua-&gt;tcall("Destinations", "new", false,
    LuaString::make("dst"));
lua-&gt;tcall("dst", "wish", true,
    LuaString::make("London"),
    LuaString::make("Paris"),
    LuaString::make("Amsterdam"));
lua-&gt;tcall("dst", "went", true,
    LuaString::make("Paris"));
auto visited = lua-&gt;vtcall(
    "dst", "list_visited", true);
auto unvisited = lua-&gt;vtcall(
    "dst", "list_unvisited", true);</pre>
<p>This is doing the same thing as when we tested <strong class="source-inline">Destinations</strong> in the interactive Lua interpreter. An explanation for this is <span class="No-Break">provided here:</span></p>
<ol>
<li>It creates an instance of the class and stores the object in the <strong class="source-inline">dst</strong> global variable. In the <strong class="source-inline">lua-&gt;tcall</strong> invocation we set <strong class="source-inline">shouldPassSelf</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
<li>It adds three<a id="_idIndexMarker275"/> cities to the wish list of <strong class="source-inline">dst</strong>. From now on, we are working with <strong class="source-inline">dst</strong> and are passing the instance as a <strong class="source-inline">self</strong> argument to the <span class="No-Break">table functions.</span></li>
<li>It marks <strong class="source-inline">Paris</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">visited</strong></span><span class="No-Break">.</span></li>
<li>It gets a list of <span class="No-Break">visited cities.</span></li>
<li>It gets a list of <span class="No-Break">unvisited cities.</span></li>
</ol>
<p>Add the following lines to print the <strong class="source-inline">visited</strong> and <span class="No-Break"><strong class="source-inline">unvisited</strong></span><span class="No-Break"> lists:</span></p>
<pre class="source-code">
std::cout &lt;&lt; "Visited:" &lt;&lt; std::endl;
for (auto place : visited) {
    std::cout &lt;&lt; std::get&lt;LuaString&gt;(place).value
              &lt;&lt; std::endl;
}
std::cout &lt;&lt; "Unvisited:" &lt;&lt; std::endl;
for (auto place : unvisited) {
    std::cout &lt;&lt; std::get&lt;LuaString&gt;(place).value
              &lt;&lt; std::endl;
}</pre>
<p>Compile and run the code. If you have done everything correctly, you should see an output <span class="No-Break">as follows:</span></p>
<pre class="source-code">
Visited:
Paris
Unvisited:
London
Amsterdam</pre>
<p>Congratulations! You<a id="_idIndexMarker276"/> have implemented in C++ a mechanism to call Lua table functions. This is by far the most complex logic we <span class="No-Break">have learned!</span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor132"/>Summary</h1>
<p>In this chapter, we learned how to work with Lua tables in C++. We also touched on OOP in Lua and how it differs from that <span class="No-Break">in C++.</span></p>
<p>We also explored some design decisions and why <strong class="source-inline">LuaExecutor</strong> is implemented in the way it is. It is designed to learn how to integrate Lua with C++, with a structure that can be broken down <span class="No-Break">into chapters.</span></p>
<p>By now, you can use <strong class="source-inline">LuaExecutor</strong> to call most Lua scripts, although it has some limitations. For example, we do not support passing another table, except <strong class="source-inline">self</strong>,  as a parameter to a function. You can try to implement such a function on your own, but it is likely not a good idea. It is better to keep the communication between Lua and <span class="No-Break">C++ simple.</span></p>
<p>Take your time to experiment and practice what we have learned. The focus so far is on how to call Lua code from C++. In the next chapter, we will start to learn how to call C++ code <span class="No-Break">from Lua.</span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor133"/>Exercises</h1>
<ol>
<li>Rewrite the string key overload version of <strong class="source-inline">LuaExecutor::getTable</strong> and <strong class="source-inline">LuaExecutor::setTable</strong>. Use the <strong class="source-inline">lua_getfield</strong> and <strong class="source-inline">lua_setfield</strong> Lua library functions. You can use the same test code in this chapter to test whether you have implemented <span class="No-Break">them correctly.</span></li>
<li>Implement <strong class="source-inline">LuaExecutor::vtcall</strong>. You should have already done so whether you have reached <span class="No-Break">this point.</span></li>
</ol>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer036">
<h1 id="_idParaDest-132" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor134"/>Part 3 – Calling C++ from Lua</h1>
<p>With your knowledge of calling Lua from C++, in this part, you will continue to learn how to call C++ <span class="No-Break">from Lua.</span></p>
<p>You will start by learning how to implement and export a C++ function that can be called from Lua scripts. Then, the complexity will increase step by step. You will export a C++ class as a Lua module and improve the process of how it is exported. Finally, you will have a general module exporter that can help you to export any C++ class <span class="No-Break">to Lua.</span></p>
<p>This part comprises the <span class="No-Break">following chapters:</span></p>
<ul>
<li><em class="italic">Chapter 6</em>, <em class="italic">How to Call C++ from Lua</em></li>
<li><em class="italic">Chapter 7</em>, <em class="italic">Working with C++ Types</em></li>
<li><em class="italic">Chapter 8</em>, <em class="italic">Abstracting a C++ Type Exporter</em></li>
</ul>
</div>
<div>
<div id="_idContainer037">
</div>
</div>
<div>
<div id="_idContainer038">
</div>
</div>
<div>
<div id="_idContainer039">
</div>
</div>
<div>
<div id="_idContainer040">
</div>
</div>
<div>
<div id="_idContainer041">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer042">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer043">
</div>
</div>
<div>
<div id="_idContainer044">
</div>
</div>
<div>
<div id="_idContainer045">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer046">
</div>
</div>
</div></body></html>