- en: Chapter 4. Using Multimedia Content
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用多媒体内容
- en: 'In this chapter we will learn about:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Loading and displaying video
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和显示视频
- en: Creating a simple video controller
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的视频控制器
- en: Saving window content as an image
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将窗口内容保存为图像
- en: Saving window animation as video
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将窗口动画保存为视频
- en: Saving window content as a vector graphics image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将窗口内容保存为矢量图形图像
- en: Saving high resolution images with tile renderer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用瓦片渲染器保存高分辨率图像
- en: Sharing graphics between applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序之间共享图形
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Most interesting applications use multimedia content in some form or another.
    In this chapter we will start by learning how to load, manipulate, and display
    video. We will then move on to saving our graphics into images, image sequences,
    or video, and then we will move to recording sound visualization.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数有趣的应用都以某种形式使用多媒体内容。在本章中，我们将首先学习如何加载、操作和显示视频。然后，我们将继续将我们的图形保存为图像、图像序列或视频，然后我们将转向录音可视化。
- en: Lastly, we will learn how to share graphics between applications and how to
    save mesh data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习如何在应用程序之间共享图形以及如何保存网格数据。
- en: Loading and displaying video
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和显示视频
- en: In this recipe, we will learn how to load a video from a file and display it
    on screen using Quicktime and OpenGL. We'll learn how to load a file as a resource
    or from a file selected by the user using a file open dialog.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用Quicktime和OpenGL从文件中加载视频并在屏幕上显示。我们将学习如何将文件作为资源加载，或者通过文件打开对话框由用户选择文件来加载。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have QuickTime installed and also a video file in a format compatible
    with QuickTime.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装QuickTime，并且还需要一个与QuickTime兼容格式的视频文件。
- en: To load the video as a resource it is necessary to copy it to the `resources`
    folder in your project. To learn more on resources, please read the recipes *Using
    resources on Windows* and *Using resources on OSX and iOS* from [Chapter 1](ch01.html
    "Chapter 1. Getting Started"), *Getting Started*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要将视频作为资源加载，需要将其复制到项目中的`resources`文件夹。要了解更多关于资源的信息，请阅读来自第1章的菜谱*在Windows上使用资源*和*在OSX和iOS上使用资源*，*入门*。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We will use Cinder's QuickTime wrappers to load and display vido.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Cinder的QuickTime包装器来加载和显示视频。
- en: 'Include the headers containing the Quicktime and OpenGL functionality by adding
    the following at the beginning of the source file:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在源文件开头添加以下内容来包含包含Quicktime和OpenGL功能的头文件：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a `ci::qtime::MovieGl` member in you application''s class declaration.
    This example will only need the `setup`, `update`, and `draw` methods, so make
    sure at least these are declared:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您应用程序的类声明中声明一个`ci::qtime::MovieGl`成员。此示例只需要`setup`、`update`和`draw`方法，所以请确保至少声明这些方法：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To load the video as a resource use the `ci::app::loadResource` method with
    the file name as `parameter` and pass the resulting `ci::app::DataSourceRef` when
    constructing the movie object. It is also good practice to place the loading resource
    inside a `trycatch` segment in order to catch any resource loading errors. Place
    the following code inside your `setup` method:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将视频作为资源加载，请使用`ci::app::loadResource`方法，将文件名作为`parameter`，并在构造电影对象时传递结果`ci::app::DataSourceRef`。将加载资源放在`trycatch`段中也是一个好习惯，以便捕获任何资源加载错误。请在您的`setup`方法中放置以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also load the video by using a file open dialog and passing the file
    path as an argument when constructing the `mMovie` object. Your `setup` would
    instead have the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以通过使用文件打开对话框并在构造`mMovie`对象时传递文件路径作为参数来加载视频。您的`setup`方法将具有以下代码：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To play the video, call the `play` method on the movie object. You can test
    the successful instantiation of `mMovie` by placing it inside an `if` statement
    just like an ordinary pointer:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要播放视频，请调用电影对象的`play`方法。您可以通过将其放在一个`if`语句中来测试`mMovie`的成功实例化，就像一个普通的指针一样：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `update` method we copy the texture of the current movie frame into
    our `mMovieTexture` to draw it later:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们将当前电影帧的纹理复制到我们的`mMovieTexture`中，以便稍后绘制：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To draw the movie we simply need to draw our texture on screen using the method
    `gl::draw`. We need to check if the texture is valid because `mMovie` may take
    a while to load. We''ll also create `ci::Rectf` with the texture size and center
    it on screen to keep the drawn video centered without stretching:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要绘制电影，我们只需使用`gl::draw`方法在屏幕上绘制我们的纹理。我们需要检查纹理是否有效，因为`mMovie`可能需要一段时间才能加载。我们还将创建`ci::Rectf`与纹理大小，并将其居中在屏幕上，以保持绘制的视频居中而不拉伸：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `ci::qtime::MovieGl` class allows playback and control of movies by wrapping
    around the QuickTime framework. Movie frames are copied into OpenGl textures for
    easy drawing. To access the texture of the current frame of the movie use the
    method `ci::qtime::MovieGl::getTexture()` which returns a `ci::gl::Texture` object.
    Textures used by `ci::qtime::MovieGl` are always bound to the `GL_TEXTURE_RECTANGLE_ARB`
    target.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ci::qtime::MovieGl`类通过封装QuickTime框架允许播放和控制电影。电影帧被复制到OpenGl纹理中，以便于绘制。要访问电影当前帧的纹理，请使用`ci::qtime::MovieGl::getTexture()`方法，它返回一个`ci::gl::Texture`对象。`ci::qtime::MovieGl`使用的纹理始终绑定到`GL_TEXTURE_RECTANGLE_ARB`目标。'
- en: There's more
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: If you wish to do iterations over the pixels of a movie consider using the class
    `ci::qtime::MovieSurface`. This class allows playback of movies by wrapping around
    the QuickTime framework, but converts movie frames into `ci::Surface` objects.
    To access the current frame's surface, use the method `ci::qtime::MovieSurface::getSurface()`
    which returns a `ci::Surface` object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望对电影中的像素进行迭代，请考虑使用`ci::qtime::MovieSurface`类。这个类通过封装QuickTime框架来播放电影，但将电影帧转换为`ci::Surface`对象。要访问当前帧的表面，请使用`ci::qtime::MovieSurface::getSurface()`方法，它返回一个`ci::Surface`对象。
- en: Creating a simple video controller
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的视频控制器
- en: In this recipe we'll learn how to create a simple video controller using the
    built-in GUI functionalities of Cinder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用Cinder的内置GUI功能创建一个简单的视频控制器。
- en: We'll control movie playback, if the movie loops or not, the speed rate, volume,
    and the position.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将控制电影播放，包括电影是否循环、播放速度、音量和位置。
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must have Apple's QuickTime installed and a movie file in a format compatible
    with QuickTime.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须安装Apple的QuickTime，并且有一个与QuickTime兼容的电影文件。
- en: To learn how to load and display a movie please refer to the previous recipe
    *Loading and displaying Video*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何加载和显示电影，请参考之前的菜谱*加载和显示视频*。
- en: How to do it…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We will create a simple interface using Cinder `params` classes to control a
    video.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的界面，使用Cinder `params`类来控制视频。
- en: 'Include the necessary files to work with Cinder `params` (QuickTime and OpenGl)
    by adding the following at the top of the source file:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在源文件顶部添加以下内容，包含必要的文件以使用Cinder `params`（QuickTime和OpenGl）：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the `using` statements before the application''s class declaration to simplify
    calling Cinder commands as shown in the following code lines:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类声明之前添加`using`语句，以简化调用Cinder命令，如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare a `ci::qtime::MovieGl`, `ci::gl::Texture`, and a `ci::params::InterfaceGl`
    object to play, render, and control the video respectively. Add the following
    to your class declaration:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`ci::qtime::MovieGl`、`ci::gl::Texture`和`ci::params::InterfaceGl`对象，分别用于播放、渲染和控制视频。在你的类声明中添加以下内容：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Select a video file by opening an open file dialog and use that path to initialize
    our `mMovie`. The following code should go in the `setup` method:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开一个打开文件对话框选择视频文件，并使用该路径初始化我们的`mMovie`。以下代码应在`setup`方法中：
- en: '[PRE10]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''ll also need some variables to store the values which we''ll manipulate.
    Each controllable parameter of the video will have two variables to represent
    the current and the previous value of that parameter. Now declare the following
    variables:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一些变量来存储我们将要操作的值。每个可控制的视频参数将有两个变量来表示该参数的当前值和前一个值。现在声明以下变量：
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set the default values in the `setup` method:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中设置默认值：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s initialize `mParams` and add a control for each of the previously
    defined variables and set the `max`, `min`, and `step` values when necessary.
    The following code must go in the `setup` method:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们初始化`mParams`并为之前定义的每个变量添加一个控件，并在必要时设置`max`、`min`和`step`值。以下代码必须在`setup`方法中：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `update` method we''ll check if the movie was valid and compare each
    of the parameters to their previous state to see if they changed. If it did, we''ll
    update `mMovie` and set the parameter to the new value. The following code lines
    go in the `update` method:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们将检查电影是否有效，并将每个参数与其前一个状态进行比较，以查看它们是否已更改。如果已更改，我们将更新`mMovie`并将参数设置为新的值。以下代码行应放在`update`方法中：
- en: '[PRE14]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `update` method it is also necessary to get a handle to the movie texture
    and copy it to our previously declared `mMovieTexture`. In the `update` method
    we write:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，还需要获取电影纹理并将其复制到之前声明的`mMovieTexture`。在`update`方法中，我们编写：
- en: '[PRE15]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All that is left is to draw our content. In the `draw` method we''ll clear
    the background with black. We''ll check the validity of `mMovieTexture` and draw
    it in a rectangle that fits on the window. We also call the `draw` command of
    `mParams` to draw the controls on top of the video:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的就是绘制我们的内容了。在 `draw` 方法中，我们将使用黑色清除背景。我们将检查 `mMovieTexture` 的有效性，并在一个适合窗口的矩形内绘制它。我们还调用
    `mParams` 的 `draw` 命令来在视频上方绘制控件：
- en: '[PRE16]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Draw it and you'll see the application's window with a black background along
    with the controls. Change the various parameters in the parameters menu and you'll
    see it affecting the video:![How to do it…](img/8703OS_4_1.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制它，您将看到具有黑色背景和控件的应用程序窗口。在参数菜单中更改各种参数，您将看到它影响视频：![如何做到这一点…](img/8703OS_4_1.jpg)
- en: How it works…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We created a `ci::params::InterfaceGl` object and added a control for each of
    the parameters we wanted to manipulate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `ci::params::InterfaceGl` 对象，并为每个我们想要操作的参数添加了一个控件。
- en: We created a variable for each of the parameters we want to manipulate and a
    variable to store their previous value. In the update we checked to see if these
    values differ, which will only happen when the user has changed their value using
    the `mParams` menu.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个我们想要操作的参数创建了一个变量，并为存储它们的上一个值创建了一个变量。在更新时，我们检查这些值是否不同，这只会发生在用户使用 `mParams`
    菜单更改它们的值时。
- en: When the parameter changes we change the `mMovie` parameter with the value the
    user has set.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数更改时，我们使用用户设置的值更改 `mMovie` 参数。
- en: Some parameters must be kept in a specific range. The movie position is set
    in seconds from `0` to the maximum duration of the video in seconds. The volume
    must be a value between `0` and `1`, `0` meaning no audio and `1` being the maximum
    volume.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数必须保持在特定的范围内。电影位置设置为从 `0` 秒到视频最大持续时间的秒数。音量必须是一个介于 `0` 和 `1` 之间的值，`0` 表示没有音频，而
    `1` 是最大音量。
- en: Saving window content as an image
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将窗口内容保存为图像
- en: In this example we will show you how to save window content to the graphic file
    and how to implement this functionality in your Cinder application. This could
    be useful to save output of a graphics algorithm.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将向您展示如何将窗口内容保存到图形文件，以及如何在您的 Cinder 应用程序中实现此功能。这可以用于保存图形算法的输出。
- en: How to do it…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will add a window content saving function to your application:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在您的应用程序中添加一个窗口内容保存功能：
- en: 'Add necessary headers:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加必要的头文件：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add property to your application''s main class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的应用程序主类添加属性：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Set a default value inside the `setup` method:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中设置默认值：
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the `keyDown` method as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现 `keyDown` 方法：
- en: '[PRE20]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following code at the end of the `draw` method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 方法的末尾添加以下代码：
- en: '[PRE21]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Every time you set `mMakeScreenshot` to `true` the screenshot of your application
    will be selected and saved. In this case the application waits for the *S* key
    to be pressed and then sets the flag `mMakeScreenshot` to `true`. The current
    application window screenshot will be saved inside your documents directory under
    the name `MainApp_screenshot.png`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每次将 `mMakeScreenshot` 设置为 `true` 时，您的应用程序的截图将被选中并保存。在这种情况下，应用程序等待按下 *S* 键，然后将标志
    `mMakeScreenshot` 设置为 `true`。当前应用程序窗口的截图将被保存在您的文档目录下，文件名为 `MainApp_screenshot.png`。
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This is just the basic example of common usage of the `writeImage` function.
    There are many other practical applications.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 `writeImage` 函数常见用法的简单示例。还有许多其他实际应用。
- en: Saving window animation as image sequences
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将窗口动画保存为图像序列
- en: 'Let''s say you want to record a equence of images Perform the following steps
    to do so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要记录一系列图像。执行以下步骤来完成此操作：
- en: 'Modify the previous code snippet shown in step 5 for saving the window content
    as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改步骤 5 中显示的先前代码片段，以将窗口内容保存如下：
- en: '[PRE22]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You have to define `mRecordFrames` and `mFrameCounter` as properties of your
    main application class:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须将 `mRecordFrames` 和 `mFrameCounter` 定义为您的应用程序主类的属性：
- en: '[PRE23]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Set initial values inside the `setup` method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中设置初始值：
- en: '[PRE24]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Recording sound visualization
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 录音声音可视化
- en: 'We assume that you are using `TrackRef` from the `audio` namespace to play
    your sound Perform the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您正在使用 `audio` 命名空间中的 `TrackRef` 来播放您的声音。执行以下步骤：
- en: Implement the previous steps for saving window animations as image sequences.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现之前的步骤以将窗口动画保存为图像序列。
- en: 'Type the following lines of code at the beginning of the `update` method:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `update` 方法的开头输入以下代码行：
- en: '[PRE25]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are calculating the desired audio track position based on the number of frames
    that passed. We are doing that to synchronize animation with the music track.
    In this case we want to produce `30` fps animation so we are dividing `mFramesCounter`
    by `30`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在根据经过的帧数计算所需的音频轨道位置。我们这样做是为了使动画与音乐轨道同步。在这种情况下，我们希望产生 `30` fps 的动画，所以我们把 `mFramesCounter`
    除以 `30`。
- en: Saving window animations as video
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将窗口动画保存为视频
- en: In this recipe,we'll start by drawing a simple animation and learning how to
    export it to video. We will create a video where pressing any key will start or
    stop the recording.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将从绘制一个简单的动画开始，并学习如何将其导出为视频。我们将创建一个视频，按下任意键将开始或停止录制。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must have Apple's QuickTime installed. Make sure you know where you want
    your video to be saved, as you'll have to specify its location at the beginning.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须安装苹果的 QuickTime。确保你知道你想要将视频保存的位置，因为你将不得不在开始时指定其位置。
- en: 'It could be anything that is drawn using OpenGl but for this example, we''ll
    create a yellow circle at the center of the window with a changing radius. The
    radius is calculated by the absolute value of the sine of the elapsed seconds
    since the application launched. We multiply this value by `200` to scale it up.
    Now add the following to the `draw` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是使用 OpenGl 绘制的任何东西，但在这个例子中，我们将在窗口中心创建一个黄色的圆圈，其半径会变化。半径是通过自应用程序启动以来经过的秒数的正弦值的绝对值来计算的。我们将此值乘以
    `200` 以放大它。现在将以下内容添加到 `draw` 方法中：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will use the `ci::qtime::MovieWriter` class to create a video of our rendering.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `ci::qtime::MovieWriter` 类来创建我们的渲染视频。
- en: 'Include the OpenGl and QuickTime files at the beginning of the source file
    by adding the following:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源文件的开头包含 OpenGl 和 QuickTime 文件，通过添加以下内容：
- en: '[PRE27]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now let''s declare a `ci::qtime::MovieWriter` object and a method to initialize
    it. Add the following to your class declaration:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们声明一个 `ci::qtime::MovieWriter` 对象和一个初始化它的方法。将以下内容添加到你的类声明中：
- en: '[PRE28]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the implementation of `initMovieWriter` we start by asking the user to specify
    a path using a save file dialog and use it to initialize the movie writer. The
    movie writer also needs to know the window's width and height. Here's the implementation
    of `initMovieWriter`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initMovieWriter` 的实现中，我们首先要求用户使用保存文件对话框指定一个路径，并使用它来初始化电影写入器。电影写入器还需要知道窗口的宽度和高度。这是
    `initMovieWriter` 的实现。
- en: '[PRE29]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Lets declare a key event handler by declaring the `keyUp` method.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过声明 `keyUp` 方法来声明一个按键事件处理器。
- en: '[PRE30]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In its implementation we will see if there is already a movie being recorded
    by checking the validity of `mMovieWriter`. If it is a valid object then we must
    save the current movie by destroying the object. We can do so by calling the `ci::qtime::MovieWriter`
    default constructor; this will create a null instance. If `mMovieWriter` is not
    a valid object then we initialize a new movie writer by calling the method `initMovieWriter()`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现中，我们将通过检查 `mMovieWriter` 的有效性来查看是否已经在录制电影。如果它是一个有效的对象，那么我们必须通过销毁对象来保存当前的电影。我们可以通过调用
    `ci::qtime::MovieWriter` 默认构造函数来实现；这将创建一个空实例。如果 `mMovieWriter` 不是一个有效的对象，那么我们通过调用
    `initMovieWriter()` 方法来初始化一个新的电影写入器。
- en: '[PRE31]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The last two steps are to check if `mMovieWriter` is valid and to add a frame
    by calling the method `addFrame` with the window's surface. This method has to
    be called in the `draw` method, after our drawing routines have been made. Here's
    the final `draw` method, including the circle drawing code.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后两个步骤是检查 `mMovieWriter` 是否有效，并通过调用带有窗口表面的 `addFrame` 方法来添加一个帧。这个方法必须在 `draw`
    方法中调用，在我们的绘图程序之后。这是最终的 `draw` 方法，包括圆圈绘制代码。
- en: '[PRE32]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Build and run the application. Pressing any key will start or end a video recording.
    Each time a new recording begins, the user will be presented with a save file
    dialog to set where the movie will be saved.![How to do it…](img/8703OS_4_2.jpg)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。按下任意键将开始或结束视频录制。每次开始新的录制时，用户将看到一个保存文件对话框，用于设置电影将保存的位置。![如何操作…](img/8703OS_4_2.jpg)
- en: How it works…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `ci::qtime::MovieWriter` object allows for easy movie writing using Apple's
    QuickTime. Recordings begin by initializing a `ci::qtime::MovieWriter` object
    and are saved when the object is destroyed. By calling the `addFrame` method,
    new frames are added.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ci::qtime::MovieWriter` 对象允许使用苹果的 QuickTime 容易地写入电影。录制开始于初始化一个 `ci::qtime::MovieWriter`
    对象，并在对象被销毁时保存。通过调用 `addFrame` 方法，可以添加新的帧。'
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can also define the format of the video by creating a `ci::qtime::MovieWriter::Format`
    object and passing it as an optional parameter in the movie writer's constructor.
    If no format is specified, the movie writer will use the default PNG codec and
    30 frames per second.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过创建一个`ci::qtime::MovieWriter::Format`对象并将其作为可选参数传递给电影编写器的构造函数来定义视频的格式。如果没有指定格式，电影编写器将使用默认的PNG编解码器和每秒30帧。
- en: 'For example, to create a movie writer with the H264 codec with 50 percent quality
    and 24 frames per second, you could write the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建一个使用H264编解码器、50%质量和24帧每秒的电影编写器，你可以编写以下代码：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can optionally open a **Settings** window and allow the user to define the
    video settings by calling the static method `qtime::MovieWriter::getUserCompressionSettings`.
    This method will populate a `qtime::MovieWriter::Format` object and return `true`
    if successful or `false` if the user canceled the change in the setting.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择打开一个**设置**窗口，并允许用户通过调用静态方法`qtime::MovieWriter::getUserCompressionSettings`来定义视频设置。此方法将填充一个`qtime::MovieWriter::Format`对象，并在成功时返回`true`，如果用户取消了设置更改则返回`false`。
- en: 'To use this method for defining the settings and creating a movie writer, you
    can write the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此方法定义设置并创建一个电影编写器，你可以编写以下代码：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It is also possible to enable **multipass** encoding. For the current version
    of Cinder it is only available using the H264 codec. Multipass encoding will increase
    the movie's quality but at the cost of a greater performance decrease. For this
    reason it is disabled by default.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以启用**多遍**编码。对于Cinder的当前版本，它仅通过H264编解码器可用。多遍编码将提高电影的质量，但会以性能下降为代价。因此，默认情况下它是禁用的。
- en: 'To write a movie with multipass encoding enabled we can write the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用多遍编码写入电影，我们可以编写以下代码：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are plenty of settings and formats that can be set using the `ci::qtime::MovieWriter::Format`
    class and the best way to know the full list of options is to check the documentation
    for the class at [http://libcinder.org/docs/v0.8.4/guide__qtime___movie_writer.html](http://libcinder.org/docs/v0.8.4/guide__qtime___movie_writer.html).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`ci::qtime::MovieWriter::Format`类设置许多设置和格式，要了解完整的选项列表，请查看该类在[http://libcinder.org/docs/v0.8.4/guide__qtime___movie_writer.html](http://libcinder.org/docs/v0.8.4/guide__qtime___movie_writer.html)的文档。
- en: Saving window content as a vector graphics image
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将窗口内容保存为矢量图形图像
- en: In this recipe we'll learn how to draw 2D graphics on screen and save it to
    an image in a vector graphics format using the cairo renderer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用cairo渲染器在屏幕上绘制2D图形并将其保存为矢量图形格式的图像。
- en: Vector graphics can be extremely useful when creating visuals for printing as
    they can be scaled without losing quality.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量图形在创建用于打印的视觉效果时非常有用，因为它们可以缩放而不失真。
- en: Cinder has an integration for the cairo graphics library; a powerful and full-featured
    2D renderer, capable of outputting to a variety of formats including popular vector
    graphics formats.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder集成了cairo图形库；一个功能强大且功能齐全的2D渲染器，能够输出到包括流行的矢量图形格式在内的多种格式。
- en: 'To learn more about the cairo library, please go to its official web page:
    [http://www.cairographics.org](http://www.cairographics.org)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于cairo库的信息，请访问其官方网站：[http://www.cairographics.org](http://www.cairographics.org)
- en: In this example we'll create an application that draws a new circle whenever
    the user presses the mouse. When any key is pressed, the application will open
    a save file dialog and save the content in a format defined by the file's extension.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个应用程序，当用户按下鼠标时，它会绘制一个新的圆。当按下任何键时，应用程序将打开一个保存文件对话框，并将内容以文件扩展名定义的格式保存。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To draw graphics created with the cairo renderer we must define our renderer
    to be `Renderer2d`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制使用cairo渲染器创建的图形，我们必须将我们的渲染器定义为`Renderer2d`。
- en: 'At the end of the source file of our application class there''s a *macro* to
    initialize the application where the second parameter defines the renderer. If
    your application is called `MyApp`, you must change the macro to be the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序类的源文件末尾有一个用于初始化应用程序的**宏**，其中第二个参数定义了渲染器。如果你的应用程序名为`MyApp`，你必须将宏更改为以下内容：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The cairo renderer allows exporting of PDF, SVG, EPS, and PostScript formats.
    When specifying the file to save, make sure you write one of the supported extensions:
    `pdf`, `svg`, `eps`, or `ps`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: cairo渲染器允许导出PDF、SVG、EPS和PostScript格式。在指定要保存的文件时，确保你写了一个受支持的扩展名：`pdf`、`svg`、`eps`或`ps`。
- en: 'Include the following files at the top of your source file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件顶部包含以下文件：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We will use Cinder's cairo wrappers to create images in vector formats from
    our rendering.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Cinder 的 cairo 包装器从我们的渲染中创建矢量格式的图像。
- en: To create a new circle every time the user presses the mouse we must first create
    a `Circle` class. This class will contain position, radius, and color parameters.
    Its constructor will take `ci::Vec2f` to define its position and will generate
    a random radius and color.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当用户按下鼠标时创建一个新圆，我们必须首先创建一个 `Circle` 类。这个类将包含位置、半径和颜色参数。它的构造函数将接受 `ci::Vec2f`
    来定义其位置，并将生成一个随机半径和颜色。
- en: 'Write the following code before the application''s class declaration:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在应用程序的类声明之前写入以下代码：
- en: '[PRE38]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We should now declare `std::vector` of circles where we''ll store the created
    circles. Add the following code to your class declaration:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该声明一个存储创建的圆的 `std::vector` 的圆，并将以下代码添加到类声明中：
- en: '[PRE39]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s create a method which will draw the circles that will take `cairo::Context`
    as their parameter:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个将 `cairo::Context` 作为参数的方法来绘制圆：
- en: '[PRE40]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the method definition, iterate over `mCircles` and draw each one in the
    context:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法定义中，遍历 `mCircles` 并在上下文中绘制每一个：
- en: '[PRE41]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: At this point we only need to add a circle whenever the user presses the mouse.
    To do this, we must implement the `mouseDown` event handler by declaring it in
    the class declaration.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们只需要在用户按下鼠标时添加一个圆。为此，我们必须通过在类声明中声明它来实现 `mouseDown` 事件处理程序。
- en: '[PRE42]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In its implementation we add a `Circle` class to `mCircles` using the mouse
    position.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其实现中，我们使用鼠标位置将一个 `Circle` 类添加到 `mCircles` 中。
- en: '[PRE43]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now draw the circles on the window by creating `cairo::Context` bound
    to the window''s surface. This will let us visualize what we''re drawing. Here''s
    the `draw` method implementation:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过创建绑定到窗口表面的 `cairo::Context` 来在窗口上绘制圆。这将让我们可视化我们正在绘制的。以下是 `draw` 方法的实现：
- en: '[PRE44]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To save the scene to an image file we must create a context bound to a surface
    that represents a file in a vector graphics format. Let's do this whenever the
    user releases a key by declaring the `keyUp` event handler.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将场景保存到图像文件，我们必须创建一个绑定到表示矢量图形格式中文件的表面的上下文。让我们通过声明 `keyUp` 事件处理程序来实现这一点，每当用户释放一个键时执行此操作。
- en: '[PRE45]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the `keyUp` implementation we create `ci::fs::path` and populate it by calling
    a save file dialog. We'll also create an empty `ci::cairo::SurfaceBase` which
    is the base for all the surfaces that the cairo renderer can draw to.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `keyUp` 实现中，我们创建 `ci::fs::path` 并通过调用保存文件对话框来填充它。我们还将创建一个空的 `ci::cairo::SurfaceBase`，它是
    cairo 渲染器可以绘制到的所有表面的基础。
- en: '[PRE46]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We'll now compare the extension of the path with the supported formats and initialize
    the surface accordingly. It can be initialized as `ci::cairo::SurfacePdf`, `ci::cairo::SurfaceSvg`,
    `ci::cairo::SurfaceEps`, or as `ci::cairo::SurfacePs`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将比较路径的扩展名与支持的格式，并相应地初始化表面。它可以初始化为 `ci::cairo::SurfacePdf`、`ci::cairo::SurfaceSvg`、`ci::cairo::SurfaceEps`
    或 `ci::cairo::SurfacePs`。
- en: '[PRE47]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we can create `ci::cairo::Context` and render our scene to it by calling
    the `renderScene` method and passing the context as a parameter. The circles will
    be rendered to the context and a file will be created in the specified format.
    Here''s the final `keyUp` method implementation:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建 `ci::cairo::Context` 并通过调用 `renderScene` 方法并将上下文作为参数传递来将其渲染到场景中。圆将被渲染到上下文中，并将在指定的格式中创建一个文件。以下是最终的
    `keyUp` 方法实现：
- en: '[PRE48]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![How to do it…](img/8703OS_4_3.jpg)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](img/8703OS_4_3.jpg)'
- en: How it works…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Cinder wraps and integrates the cairo 2D vector renderer. It allows use of Cinder's
    types to draw and interact with cairo.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder 包装并集成了 cairo 2D 矢量渲染器。它允许使用 Cinder 的类型来绘制和与 cairo 交互。
- en: The complete drawing is made by calling the drawing methods of a `ci::cairo::Context`
    object. The context in turn, must be created by passing a surface object extending
    `ci::cairo::SurfaceBase`. All drawings will be made in the surface and rasterized
    according to the type of the surface.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的绘图是通过调用 `ci::cairo::Context` 对象的绘图方法来完成的。上下文反过来必须通过传递一个扩展 `ci::cairo::SurfaceBase`
    的表面对象来创建。所有绘图都将在这个表面上完成，并根据表面的类型进行光栅化。
- en: 'The following surfaces allow saving images in a vector graphics format:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表面允许以矢量图形格式保存图像：
- en: '| Surface type | Format |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 表面类型 | 格式 |'
- en: '| --- | --- |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ci::cairo::SurfacePdf` | PDF |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `ci::cairo::SurfacePdf` | PDF |'
- en: '| `ci::cairo::SurfaceSvg` | SVG |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `ci::cairo::SurfaceSvg` | SVG |'
- en: '| `ci::cairo::SurfaceEps` | EPS |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `ci::cairo::SurfaceEps` | EPS |'
- en: '| `ci::cairo::SurfacePs` | PostsSript |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `ci::cairo::SurfacePs` | PostScript |'
- en: There's more...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is also possible to draw using other renderers. Though the renderers aren't
    able to create vector images, they can be useful in other situations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用其他渲染器进行绘制。尽管渲染器无法创建矢量图像，但在其他情况下它们可能很有用。
- en: 'Here are the other available surfaces:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其他可用的表面：
- en: '| Surface Type | Format |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 表面类型 | 格式 |'
- en: '| --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ci::cairo::SurfaceImage` | Anti-aliased pixel-based rasterizer |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `ci::cairo::SurfaceImage` | 基于像素的抗锯齿光栅化器 |'
- en: '| `ci::cairo::SurfaceQuartz` | Apple''s Quartz |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `ci::cairo::SurfaceQuartz` | 苹果的Quartz |'
- en: '| `ci::cairo::SurfaceCgBitmapContext` | Apple''s CoreGraphics |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `ci::cairo::SurfaceCgBitmapContext` | 苹果的CoreGraphics |'
- en: '| `ci::cairo::SurfaceGdi` | Windows GDI |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `ci::cairo::SurfaceGdi` | Windows GDI |'
- en: Saving high resolution images with the tile renderer
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用瓦片渲染器保存高分辨率图像
- en: In this recipe we'll learn how to export a high-resolution image of the content
    being drawn on screen using the `ci::gl::TileRender` class. This can be very useful
    when creating graphics for print.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用`ci::gl::TileRender`类导出屏幕上绘制的内容的高分辨率图像。这在创建用于打印的图形时非常有用。
- en: We'll start by creating a simple scene and drawing it on screen. Next, we'll
    code our example so that whenever the user presses any key, a save file dialog
    will appear and a high-resolution image will be saved to the specified path.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个简单的场景并在屏幕上绘制它。接下来，我们将编写示例代码，以便每当用户按下任何键时，都会出现一个保存文件对话框，并将高分辨率图像保存到指定的路径。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: The `TileRender` class can create high resolution images from anything being
    drawn on screen using OpenGl calls.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`TileRender`类可以从使用OpenGl调用的任何屏幕绘制内容创建高分辨率图像。'
- en: To save an image with `TileRender` we must first draw some content on screen.
    It can be anything but for this example let's create a nice simple pattern with
    circles to fill the screen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`TileRender`保存图像，我们首先必须在屏幕上绘制一些内容。这可以是任何内容，但为了这个示例，让我们创建一个简单的图案，用圆形填充整个屏幕。
- en: 'In the implementation of your `draw` method write the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`方法的实现中，写入以下代码：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Remember that this could be anything that is drawn on screen using OpenGl.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这可以是使用OpenGl在屏幕上绘制的任何内容。
- en: '![Getting ready](img/8703OS_4_4.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/8703OS_4_4.jpg)'
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We will use the `ci::gl::TileRender` class to generate high-resolution images
    of our OpenGL rendering.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ci::gl::TileRender`类来生成OpenGL渲染的高分辨率图像。
- en: 'Include the necessary headers by adding the following at the top of the source
    file:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在源文件顶部添加以下内容来包含必要的头文件：
- en: '[PRE50]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Since we'll save a high-resolution image whenever the user presses any key,
    let's implement the `keyUp` event handler by declaring it in the class declaration.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在用户按下任何键时保存高分辨率图像，让我们通过在类声明中声明来实现`keyUp`事件处理器。
- en: '[PRE51]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the `keyUp` implementation we start by creating a `ci::gl::TileRender` object
    and then set the width and height of the image we are going to create. We are
    going to set it to be four times the size of the application window. It can be
    of any size you want, just take in to account that if you don't respect the window's
    aspect ratio, the image will become stretched.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`keyUp`实现中，我们首先创建一个`ci::gl::TileRender`对象，然后设置我们即将创建的图像的宽度和高度。我们将将其设置为应用程序窗口大小的四倍。它可以是你想要的任何大小，但请注意，如果你不尊重窗口的宽高比，图像将会被拉伸。
- en: '[PRE52]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We must define our scene''s `Modelview` and `Projection` matrices to match
    our window. If we are using only 2D graphics we can call the method `setMatricesWindow`,
    as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须定义场景的`Modelview`和`Projection`矩阵以匹配我们的窗口。如果我们只使用2D图形，我们可以调用`setMatricesWindow`方法，如下所示：
- en: '[PRE53]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To define the scene''s `Modelview` and `Projection` matrices to match the window
    while drawing 3D content, it is necessary to call the method `setMatricesWindowPersp`:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了在绘制3D内容时定义场景的`Modelview`和`Projection`矩阵以匹配窗口，必须调用`setMatricesWindowPersp`方法：
- en: '[PRE54]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next we''ll draw our scene each time a new tile is created by using the method
    `nextTile`. When all the tiles have been created the method will return `false`.
    We can create all the tiles by redrawing our scene in a `while` loop while asking
    if there is a next tile, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`nextTile`方法在创建新瓦片时绘制场景。当所有瓦片都创建完毕后，该方法将返回`false`。我们可以通过在`while`循环中重新绘制场景并询问是否有下一个瓦片来创建所有瓦片，如下所示：
- en: '[PRE55]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now that the scene is fully rendered in `TileRender`, we must save it. Let's
    ask the user to indicate where to save by opening a save file dialog. It is mandatory
    to specify an extension for the image file as it will be used internally to define
    the image format.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，场景已经完全在 `TileRender` 中渲染，我们必须保存它。让我们通过打开一个保存文件对话框来让用户指定保存位置。必须指定图像文件的扩展名，因为它将用于内部定义图像格式。
- en: '[PRE56]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We check if `filePath` is not empty and write the tile render surface as an
    image using the `writeImage` method.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查 `filePath` 是否为空，并使用 `writeImage` 方法将标题渲染表面作为图像写入。
- en: '[PRE57]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'After saving the image it is necessary to redefine the window''s `Modelview`
    and `Projection` matrices. If drawing in 2D you can set the matrices to their
    default values by using the method `setMatricesWindow` with the window''s dimensions,
    as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存图像后，需要重新定义窗口的 `Modelview` 和 `Projection` 矩阵。如果在 2D 中绘图，可以通过使用带有窗口尺寸的 `setMatricesWindow`
    方法将矩阵设置为默认值，如下所示：
- en: '[PRE58]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: The `ci::gl::TileRender` class makes it possible to generate high-resolution
    versions of our rendering by scaling individual portions of our drawing to the
    entire size of the window and storing them as `ci::Surface`. After the entire
    scene has been stored in individual portions it is stitched together as tiles
    to form a single high-resolution `ci::Surface`, which can then be saved as an
    image.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`ci::gl::TileRender` 类使得通过将我们的绘图的部分缩放到整个窗口大小并将它们存储为 `ci::Surface`，从而生成我们渲染的高分辨率版本成为可能。在将整个场景存储在各个部分之后，它们被拼接成瓷砖，形成一个单独的高分辨率
    `ci::Surface`，然后可以将其保存为图像。'
- en: Sharing graphics between applications
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序之间共享图形
- en: 'In this recipe we will show you the way of sharing graphic in real time between
    applications under Mac OS X. To do that, we will use **Syphon** and its implementation
    for Cinder. Syphon is an open source tool that allows an application to share
    graphics as still frames or real-time updated frame sequence. You can read more
    about Syphon here: [http://syphon.v002.info/](http://syphon.v002.info/)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将向您展示在 Mac OS X 下实时在应用程序之间共享图形的方法。为此，我们将使用 **Syphon** 和其针对 Cinder 的实现。Syphon
    是一个开源工具，允许应用程序以静态帧或实时更新的帧序列共享图形。您可以在以下位置了解更多关于 Syphon 的信息：[http://syphon.v002.info/](http://syphon.v002.info/)
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To test if the graphic shared by our application is available, we are going
    to use **Syphon Recorder**, which you can find here: [http://syphon.v002.info/recorder/](http://syphon.v002.info/recorder/)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们应用程序共享的图形是否可用，我们将使用 **Syphon Recorder**，您可以在以下位置找到它：[http://syphon.v002.info/recorder/](http://syphon.v002.info/recorder/)
- en: How to do it…
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Checkout Syphon CinderBlock from the *syphon-implementations* repository [http://code.google.com/p/syphon-implementations/](http://code.google.com/p/syphon-implementations/).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *syphon-implementations* 仓库检出 Syphon CinderBlock [http://code.google.com/p/syphon-implementations/](http://code.google.com/p/syphon-implementations/).
- en: Create a new group inside your project tree and name it `Blocks`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目树中创建一个新的组，并将其命名为 `Blocks`。
- en: Drag-and-drop Syphon CinderBlock into your newly created `Blocks` group.![How
    to do it…](img/8703OS_4_5.jpg)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Syphon CinderBlock 拖放到你新创建的 `Blocks` 组中。![如何操作…](img/8703OS_4_5.jpg)
- en: Make sure **Syphon.framework** is added to the **Copy Files** section of **Build
    Phases** in the **target** settings.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 **target** 设置的 **Build Phases** 的 **Copy Files** 部分添加了 **Syphon.framework**。
- en: 'Add necessary header files:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加必要的头文件：
- en: '[PRE59]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add property to your main application class:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的应用程序主类添加属性：
- en: '[PRE60]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'At the end of `setup` method, add the following code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法的末尾，添加以下代码：
- en: '[PRE61]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Inside the `draw` method add the following code:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 方法内部添加以下代码：
- en: '[PRE62]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works…
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Application draws a simple rotating animation and shares the whole window area
    via Syphon library. Our application window looks like the following screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序绘制一个简单的旋转动画，并通过 Syphon 库共享整个窗口区域。我们的应用程序窗口如下截图所示：
- en: '![How it works…](img/8703OS_4_6.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![它的工作原理…](img/8703OS_4_6.jpg)'
- en: 'To test if the graphic can be received by other applications, we will use Syphon
    Recorder. Run Syphon Recorder and find our Cinder application in the drop-down
    menu under the name: **Cinder Screen – MainApp**. We set up the first part of
    this name at the step 6 of this recipe in the *How to do it...* section while
    the second part is an executable file name. Now, the preview from our Cinder application
    should be available and it would looks like the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试图形是否可以被其他应用程序接收，我们将使用 Syphon Recorder。运行 Syphon Recorder 并在“**Cinder Screen
    – MainApp**”名称下的下拉菜单中找到我们的 Cinder 应用程序。我们在“*如何做...*”部分的步骤 6 中设置了该名称的第一部分，而第二部分是可执行文件名。现在，我们的
    Cinder 应用程序的预览应该可用，并且看起来如下截图所示：
- en: '![How it works…](img/8703OS_4_7.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![How it works…](img/8703OS_4_7.jpg)'
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Syphon library is very useful, simple to use, and is available for other
    applications and libraries.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Syphon 库非常实用，易于使用，并且适用于其他应用程序和库。
- en: Receiving graphics from other applications
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收来自其他应用程序的图形
- en: 'You can receive textures from other applications as well. To do this, you have
    to use the `syphonClient` class as shown in the following steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以接收来自其他应用程序的纹理。为此，您必须使用 `syphonClient` 类，如下步骤所示：
- en: 'Add a property to your application main class:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序主类中添加一个属性：
- en: '[PRE63]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Initialize `mClientSyphon` inside the CIT method:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 CIT 方法中初始化 `mClientSyphon`：
- en: '[PRE64]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'At the end of the `draw` method add the following line which draws graphics
    that the other application is sharing:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 方法的末尾添加以下行，该行绘制其他应用程序共享的图形：
- en: '[PRE65]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
