<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Integrating with Node.js</h1>
                </header>
            
            <article>
                
<p class="mce-root">The modern web leans heavily on Node.js for both development and server-side management. With the advent of increasingly complex browser applications that perform computationally expensive operations, performance increases can be incredibly beneficial. In this chapter, we're going to describe the various ways you can integrate WebAssembly with Node.js through the use of various examples.</p>
<p>Our goal for this chapter is to understand the following:</p>
<ul>
<li class="mce-root">The advantages of integrating WebAssembly with Node.js</li>
<li class="mce-root">How to interact with the Node.js WebAssembly API</li>
<li class="mce-root">How to utilize Wasm modules in a project that uses Webpack</li>
<li class="mce-root">How to write unit tests for WebAssembly modules using <kbd>npm</kbd> libraries</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why Node.js?</h1>
                </header>
            
            <article>
                
<p class="mce-root">In <a href="706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml">Chapter 3</a>, <em>Setting Up a Development Environment</em>, Node.js was described as an asynchronous event-driven JavaScript runtime, which is the definition taken from the official website. What Node.js represents, however, is a profound shift in the way we build and manage web applications. In this section, we will discuss the relationship between WebAssembly and Node.js, and why the two technologies complement each other so well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Seamless integration</h1>
                </header>
            
            <article>
                
<p class="mce-root">Node.js runs on Google's V8 JavaScript engine, which powers Google Chrome. Since V8's WebAssembly implementation adheres to the <em>Core Specification</em>, you can interact with a WebAssembly module using the same API as the browser. Instead of performing a fetch call for a <kbd>.wasm</kbd> file, you can use Node.js's <kbd>fs</kbd> module to read the contents into a buffer, then call <kbd>instantiate()</kbd> on the result.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Complementary technologies</h1>
                </header>
            
            <article>
                
<p class="mce-root">JavaScript has limitations on the server side as well. Expensive computation or working with large numbers can be optimized with WebAssembly's superior performance. As a scripting language, JavaScript excels at automating simple tasks. You could write a script to compile C/C++ to a Wasm file, copy it to a <kbd>build</kbd> folder, and see the changes reflected in the browser if you're using a tool like <kbd>Browsersync</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Development with npm</h1>
                </header>
            
            <article>
                
<p class="mce-root">Node.js has an extensive ecosystem of tools and libraries in the form of <kbd>npm</kbd>. Sven Sauleau and other members of the open source community have created <kbd>webassemblyjs</kbd>, an extensive suite of tooling for WebAssembly built with Node.js. The <kbd>webassemblyjs</kbd> site at <a href="https://webassembly.js.org">https://webassembly.js.org</a> includes the tagline <em>Toolchain for WebAssembly</em>. There are currently over 20 <kbd>npm</kbd> packages to perform various tasks and aid in development, such as an ESLint plugin, an AST validator, and a formatter. AssemblyScript, a TypeScript to WebAssembly compiler, allows you to write performant code that compiles to a Wasm module without having to learn C or C++. The Node.js community is clearly vested in WebAssembly's success.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server-side WebAssembly with Express</h1>
                </header>
            
            <article>
                
<p class="mce-root">Node.js can be used in several ways to add value to a WebAssembly project. In this section, we're going to walk through an example Node.js application that integrates WebAssembly. The application uses Express with some simple routes to call functions from a compiled Wasm module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of the project</h1>
                </header>
            
            <article>
                
<p class="mce-root">The project reuses some of the code from the application we built in <a href="79019325-2d3e-452c-b680-ac90522aa4bf.xhtml">Chapter 7</a>, <em>Creating an Application from Scratch</em> (<em>Cook the Books</em>) to demonstrate how Node.js can be used with WebAssembly. The code for this section is located in the <kbd>/chapter-09-node/server-example</kbd> folder in the <kbd>learn-webassembly</kbd> repository. We're going to review portions of the application directly applicable to Node.js. The following structure represents the file structure for the project:</p>
<pre>├── /lib<br/>│    └── main.c<br/>├── /src<br/>|    ├── Transaction.js<br/>|    ├── /assets<br/>|    │   ├── db.json<br/>|    │   ├── main.wasm<br/>|    │   └── memory.wasm<br/>|    ├── assign-routes.js<br/>|    ├── index.js<br/>|    └── load-assets.js<br/>├── package.json<br/>├── package-lock.json<br/>└── requests.js</pre>
<p class="mce-root"><span>With regard to dependencies, the application uses the</span> <kbd>express</kbd> and <kbd>body-parser</kbd> <span>libraries to set up routes and parse JSON from the body of requests. For data management, it uses</span> <kbd>lowdb</kbd>, <span>a library that provides methods for reading and updating a JSON file. The JSON file is located in</span> <kbd>/src/assets/db.json</kbd> <span>and contains data that was slightly modified from the Cook the Books dataset. We're using <kbd>nodemon</kbd> to watch for changes in the</span> <kbd>/src</kbd> <span>folder and reload the application automatically. We're using</span> <kbd>rimraf</kbd> to manage file deletion. The library is included as a dependency in the event that you didn't install it globally in <a href="706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml">Chapter 3</a>, <em>Setting Up a Development Environment</em>. Finally, the <kbd>node-fetch</kbd> library allows us to use the fetch API to make HTTP requests when testing the application.</p>
<div class="mce-root packt_infobox">To simplify functionality in both the JavaScript and C files, the <kbd>rawAmount</kbd> and <kbd>cookedAmount</kbd> fields were replaced with a single <kbd>amount</kbd> field, and the <kbd>category</kbd> field is now <kbd>categoryId</kbd>, which maps to a <kbd>categories</kbd> array in <kbd>db.json</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Express configuration</h1>
                </header>
            
            <article>
                
<p class="mce-root">The application is loaded in <kbd>/src/index.js</kbd>. The contents of this file are shown as follows:</p>
<pre class="mce-root">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const loadAssets = require('./load-assets');<br/>const assignRoutes = require('./assign-routes');<br/><br/>// If you preface the npm start command with PORT=[Your Port] on<br/>// macOS/Ubuntu or set PORT=[Your Port] on Windows, it will change the port<br/>// that the server is running on, so PORT=3001 will run the app on<br/>// port 3001:<br/>const PORT = process.env.PORT || 3000;<br/><br/>const startApp = async () =&gt; {<br/>  const app = express();<br/><br/>  // Use body-parser for parsing JSON in the body of a request:<br/>  app.use(bodyParser.urlencoded({ extended: true }));<br/>  app.use(bodyParser.json());<br/><br/>  // Instantiate the Wasm module and local database:<br/>  const assets = await loadAssets();<br/><br/>  // Setup routes that can interact with Wasm and the database:<br/>  assignRoutes(app, assets);<br/><br/>  // Start the server with the specified port:<br/>  app.listen(PORT, (err) =&gt; {<br/>    if (err) return Promise.reject(err);<br/>    return Promise.resolve();<br/>  });<br/>};<br/><br/>startApp()<br/>  .then(() =&gt; console.log(`Server is running on port ${PORT}`))<br/>  .catch(err =&gt; console.error(`An error occurred: ${err}`));</pre>
<p class="mce-root">This file sets up a new Express app, adds the <kbd>body-parser</kbd> middleware, loads the mock database and Wasm instance, and assigns routes. Let's move on to discussing the difference between instantiating a Wasm module in the browser and Node.js.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instantiating a Wasm module with Node.js</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Wasm files are instantiated in <kbd>/src/load-assets.js</kbd>. We're using the <kbd>memory.wasm</kbd> file from Cook the Books, but the <kbd>/assets/main.wasm</kbd> file is compiled from a slightly different version of <kbd>main.c</kbd>, which is located in the <kbd>/lib</kbd> folder. The <kbd>loadWasm()</kbd> function performs the same operation as the Wasm initialization code from Cook the Books, but the method for passing in the <kbd>bufferSource</kbd> to <kbd>WebAssembly.instantiate()</kbd> is different. Let's examine this further by reviewing a portion of the code in the <kbd>loadWasm()</kbd> function of the <kbd>load-assets.js file</kbd>:</p>
<pre class="mce-root">const fs = require('fs');<br/>const path = require('path');<br/><br/>const assetsPath = path.resolve(__dirname, 'assets');<br/><br/>const getBufferSource = fileName =&gt; {<br/>  const filePath = path.resolve(assetsPath, fileName);<br/>  return fs.readFileSync(filePath); // &lt;- Replaces the fetch() and .arrayBuffer()<br/>};<br/><br/>// We're using async/await because it simplifies the Promise syntax<br/>const loadWasm = async () =&gt; {<br/>  const wasmMemory = new WebAssembly.Memory({ initial: 1024 });<br/>  const memoryBuffer = getBufferSource('memory.wasm');<br/>  const memoryInstance = await WebAssembly.instantiate(memoryBuffer, {<br/>    env: {<br/>      memory: wasmMemory<br/>    }<br/>  });<br/>  ...</pre>
<p class="mce-root">To elaborate on the differences, here's some code that instantiates a module using <kbd>fetch</kbd>:</p>
<pre class="mce-root">fetch('main.wasm')<br/>  .then(response =&gt; {<br/>    if (response.ok) return response.arrayBuffer();<br/>    throw new Error('Unable to fetch WebAssembly file');<br/>  })<br/>  .then(bytes =&gt; WebAssembly.instantiate(bytes, importObj));</pre>
<p class="mce-root">When using Node.js, the fetch call is replaced by the <kbd>fs.readFileSync()</kbd> function and the <kbd>arrayBuffer()</kbd> function is no longer required because <kbd>fs.readFileSync()</kbd> returns a buffer that can be passed directly into the <kbd>instantiate()</kbd> function. Once the Wasm module is instantiated, we can start interacting with the instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a mock database</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>load-assets.js</kbd> file also contains a method for creating a mock database instance:</p>
<pre class="mce-root">const loadDb = () =&gt; {<br/>  const dbPath = path.resolve(assetsPath, 'db.json');<br/>  const adapter = new FileSync(dbPath);<br/>  return low(adapter);<br/>};</pre>
<p class="mce-root">The <kbd>loadDb()</kbd> function loads the contents of <kbd>/assets/db.json</kbd> into an instance of <kbd>lowdb</kbd>. The default function exported from <kbd>load-assets.js</kbd> calls the <kbd>loadWasm()</kbd> and <kbd>loadDb()</kbd> functions and returns an object containing the mock database and Wasm instance:</p>
<pre class="mce-root">module.exports = async function loadAssets() {<br/>  const db = loadDb();<br/>  const wasmInstance = await loadWasm();<br/>  return {<br/>    db,<br/>    wasmInstance<br/>  };<br/>};</pre>
<p class="mce-root">Going forward, I'll use the term database to refer to the <kbd>lowdb</kbd> instance that accesses the <kbd>db.json</kbd> file. Now that the assets are loaded, let's review how the application interacts with them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with the WebAssembly module</h1>
                </header>
            
            <article>
                
<p class="mce-root">Interaction with the database and Wasm instance takes place across two files in the <kbd>/src</kbd> folder: <kbd>Transaction.js</kbd> and <kbd>assign-routes.js</kbd>. In our example application, all communication with the API is performed via HTTP requests. Sending a request to a specific endpoint will trigger some interaction with the database/Wasm instance on the server. Let's start by reviewing <kbd>Transaction.js</kbd>, which interacts directly with the database and Wasm instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wrapping interaction in Transaction.js</h1>
                </header>
            
            <article>
                
<p class="mce-root">Just as with Cook the Books, there's a class that wraps the Wasm interaction code and provides a clean interface. The contents of <kbd>Transaction.js</kbd> are very similar to the contents of <kbd>/src/store/WasmTransactions.js</kbd> from Cook the Books. Most of the changes accommodate for the <kbd>categoryId</kbd> being present in a transaction record and a single <kbd>amount</kbd> field (no more raw and cooked amounts). Additional functionality was added to interact with the database. For example, here's a function that edits an existing transaction, both in the database and the linked list from the Wasm instance:</p>
<pre class="mce-root">getValidAmount(transaction) {<br/>  const { amount, type } = transaction;<br/>  return type === 'Withdrawal' ? -Math.abs(amount) : amount;<br/>}<br/><br/>edit(transactionId, contents) {<br/>  const updatedTransaction = this.db.get('transactions')<br/>    .find({ id: transactionId })<br/>    .assign(contents)<br/>    .write();<br/><br/>  const { categoryId, ...transaction } = updatedTransaction;<br/>  const amount = this.getValidAmount(transaction);<br/>  this.wasmInstance._editTransaction(transactionId, categoryId, amount);<br/>  <br/>  return updatedTransaction;<br/>}</pre>
<p class="mce-root">The <kbd>edit()</kbd> function updates the database record that corresponds to the <kbd>transactionId</kbd> argument with the values in the <kbd>contents</kbd> argument. <kbd>this.db</kbd> is the database instance that was created in the <kbd>load-assets.js</kbd> file. Since the <kbd>categoryId</kbd> field is available on the <kbd>updatedTransaction</kbd> record, we can pass it directly to <kbd>this.wasmInstance._editTransaction()</kbd>. It gets passed into the constructor when a new instance of <kbd>Transaction</kbd> is created.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transaction operations in assign-routes.js</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>assign-routes.js</kbd> file defines routes and adds them to the <kbd>express</kbd> instance (<kbd>app</kbd>) created in <kbd>index.js</kbd>. In Express, routes can be defined directly on <kbd>app</kbd> (for example, <kbd>app.get()</kbd>), or through the use of a <kbd>Router</kbd>. In this case, a <kbd>Router</kbd> was used to add multiple methods to the same route path. The following code, taken from the <kbd>assign-routes.js</kbd> file, creates a <kbd>Router</kbd> instance and adds two routes: a <kbd>GET</kbd> route that returns all transactions, and a <kbd>POST</kbd> route that creates a new transaction:</p>
<pre class="mce-root">module.exports = function assignRoutes(app, assets) {<br/>  const { db, wasmInstance } = assets;<br/>  const transaction = new Transaction(db, wasmInstance);<br/>  const transactionsRouter = express.Router();<br/><br/>  transactionsRouter<br/>    .route('/')<br/>    .get((req, res) =&gt; {<br/>      const transactions = transaction.findAll();<br/>      res.status(200).send(transactions);<br/>    })<br/>    .post((req, res) =&gt; {<br/>      const { body } = req;<br/>      if (!body) {<br/>        return res.status(400).send('Body of request is empty');<br/>      }<br/>      const newRecord = transaction.add(body);<br/>      res.status(200).send(newRecord);<br/>    });<br/><br/>  ...<br/><br/>  // Set the base path for all routes on transactionsRouter:<br/>  app.use('/api/transactions', transactionsRouter);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root">The <kbd>app.use()</kbd> function at the end of the snippet specifies that all routes defined on the <kbd>transactionsRouter</kbd> instance are prefixed with <kbd>/api/transactions</kbd>. If you were running the application locally on port <kbd>3000</kbd>, you could navigate to <kbd>http://localhost:3000/api/transactions</kbd> in your browser and see an array of all the transactions in JSON format.</p>
<p class="mce-root">As you can see from the body of the <kbd>get()</kbd> and <kbd>post()</kbd> functions, interactions with any transaction records are being delegated to the <kbd>Transaction</kbd> instance created in line <kbd>3</kbd>. That completes our review of pertinent sections of the code base. Each of the files contain comments describing the file's functionality and purpose, so you may want to review those before moving on to the next section. In the next section, we'll build, run, and interact with the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building and running the application</h1>
                </header>
            
            <article>
                
<p>Before we build and test out the project, you'll need to install the <kbd>npm</kbd> dependencies. Open a terminal within the <kbd>/server-example</kbd> folder and run the following command:</p>
<pre><strong>npm install</strong></pre>
<p>Once that's complete, you're ready to move on to the build step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the application</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the case of this application, building refers to compiling the <kbd>lib/main.c</kbd> to a <kbd>.wasm</kbd> file using the <kbd>emcc</kbd> command. Since this is a Node.js project, we can use the <kbd>scripts</kbd> key in our <kbd>package.json</kbd> file to define <span class="packt_screen">Tasks</span>. You can still use VS Code's <span class="packt_screen">Tasks</span> feature because it automatically detects the scripts from your <kbd>package.json</kbd> file and presents them in the list of tasks when you select <span class="packt_screen">Tasks | Run Task...</span> from the menu. The following code contains the contents of the <kbd>scripts</kbd> section in this project's <kbd>package.json</kbd> file:</p>
<pre class="mce-root">"scripts": {<br/>  "prebuild": "rimraf src/assets/main.wasm",<br/>  "build": "emcc lib/main.c -Os -s WASM=1 -s SIDE_MODULE=1<br/>           -s BINARYEN_ASYNC_COMPILATION=0 -s ALLOW_MEMORY_GROWTH=1<br/>           -o src/assets/main.wasm",<br/>  "start": "node src/index.js",<br/>  "watch": "nodemon src/* --exec 'npm start'"<br/>},</pre>
<p class="mce-root">The <kbd>build</kbd> script was split across multiple lines for display purposes, so you'd have to combine those lines for valid JSON. The <kbd>prebuild</kbd> script removes the existing Wasm file, and the <kbd>build</kbd> script runs the <kbd>emcc</kbd> command with the required flags to compile <kbd>lib/main.c</kbd> and output the result to <kbd>src/assets/main.wasm</kbd>. To run the script, open a terminal within the <kbd>/server-example</kbd> folder and run the following command:</p>
<pre class="mce-root"><strong>npm run build</strong></pre>
<p class="mce-root">If the <kbd>/src/assets</kbd> folder contains a file named <kbd>main.wasm</kbd>, the build completed successfully. If an error has occurred, the terminal should provide a description of the error, as well as a stack trace.</p>
<div class="mce-root packt_tip">You can create <kbd>npm</kbd> scripts that run before or after a specific script by creating an entry with the same name and prefixing it with <kbd>pre</kbd> or <kbd>post</kbd>. For example, if you wanted to run a script after the <kbd>build</kbd> script has completed, you can create a script named <kbd>"postbuild"</kbd> and specify the command you want to run.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting and testing out the application</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you're making changes to the application or trying to fix a bug, you could use the <kbd>watch</kbd> script to watch for any changes to the contents of the <kbd>/src</kbd> folder and automatically restart the application if a change was made. Since we're just running and testing out the application, we can use the <kbd>start</kbd> command instead. In the terminal, ensure you're in the <kbd>/server-example</kbd> folder and run the following command:</p>
<pre class="mce-root"><strong>npm start</strong></pre>
<p class="mce-root">You should see a message that says <kbd>Server is running on port 3000</kbd>. You're now able to send HTTP requests to the server. To test the application, open a new terminal instance within the <kbd>server-example</kbd> directory and run the following command:</p>
<pre class="mce-root"><strong>node ./requests.js 1</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">This should log out the response body of the <kbd>GET</kbd> call to the <kbd>/api/transactions</kbd> endpoint. The <kbd>requests.js</kbd> file contains functionality that allows you to make requests to all of the available routes. The <kbd>getFetchActionForId()</kbd> function returns an object with an endpoint and options value, which corresponds to a route in the <kbd>assign-routes.js</kbd> file. The <kbd>actionId</kbd> is an arbitrary number to simplify testing and reduce the amount of typing for running commands. For example, you could run the following command:</p>
<pre class="mce-root"><strong>node ./requests.js 5</strong></pre>
<p class="mce-root">It will log out the sum of all transactions for the <em>Computer &amp; Internet</em> category. You can pass an additional argument to the <kbd>node</kbd> command if you want the total for a different category. To get the sum of all transactions in the <em>Insurance</em> category, run this command:</p>
<pre class="mce-root"><strong>node ./requests.js 5 3</strong></pre>
<p class="mce-root">Try going through each of the requests (there are eight in total). If you make a request that adds, removes, or edits a transaction, you should see the changes in the <kbd>/src/assets/db.json</kbd> file. That's it for the Node.js example project. In the next section, we'll utilize Webpack to load and interact with a Wasm module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client-side WebAssembly with Webpack</h1>
                </header>
            
            <article>
                
<p class="mce-root">Web applications continue to grow in complexity and size. Simply serving up a few handwritten HTML, CSS, and JavaScript files is not feasible for large applications. To manage this complexity, web developers use bundlers to allow for modularization, ensure browser compatibility, and reduce the size of JavaScript files. In this section, we're going to be using a popular bundler, Webpack, to utilize Wasm without using <kbd>emcc</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of the project</h1>
                </header>
            
            <article>
                
<p class="mce-root">The example Webpack application extends the functionality of the C code we wrote in the <em>Compiling C without the glue code</em> section of <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml"/><a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <em>Creating and Loading a WebAssembly Module</em>. Instead of showing a blue rectangle bouncing around a red background, we'll show an alien in a spaceship bouncing around the Horsehead Nebula. The collision detection functionality has been modified to accommodate for bouncing within a rectangle, so the movement of the spaceship will be random. The code for this section is located in the <kbd>/chapter-09-node/webpack-example</kbd> folder in the <kbd>learn-webassembly</kbd> repository. The file structure for the project is shown in the following code:</p>
<pre class="mce-root">├── /src<br/>│    ├── /assets<br/>│    │    ├── background.jpg<br/>│    │    └── spaceship.svg<br/>│    ├── App.js<br/>│    ├── index.html<br/>│    ├── index.js<br/>│    ├── main.c<br/>│    └── styles.css<br/>├── package.json<br/>├── package-lock.json<br/>└── webpack.config.js</pre>
<p class="mce-root">We'll review the Webpack configuration file in a later section. For now, let's take a moment to discuss Webpack in more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is Webpack?</h1>
                </header>
            
            <article>
                
<p class="mce-root">The JavaScript ecosystem has been rapidly evolving over the past several years, resulting in new frameworks and libraries popping up constantly. Bundlers came about as a way to enable developers to split a JavaScript application into several files without having to worry about managing global namespaces, script loading order, or an incredibly long list of <kbd>&lt;script&gt;</kbd> tags in the HTML file. A bundler combines all of the files into one and resolves any naming collisions.</p>
<p class="mce-root">Webpack is, at the time of writing, one of the most popular bundlers for frontend development. It does much more than combine JavaScript files, however. It also performs complex tasks such as code-splitting and tree shaking (dead-code elimination). Webpack was designed with a plugin architecture, which resulted in a massive amount of community-developed plugins. A search for Webpack on <kbd>npm</kbd> currently returns over 12,000 packages! This exhaustive list of plugins, along with its powerful built-in feature set, makes Webpack a full-fledged build tool.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing and configuring Webpack</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before we begin the application walk-through, open up a terminal within the <kbd>/webpack-example</kbd> folder and run the following command:</p>
<pre class="mce-root"><strong>npm install<br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependencies overview</h1>
                </header>
            
            <article>
                
<p class="mce-root">The application uses Version 4 of Webpack (the most recent version as of writing this) to build our application. We need to use Webpack plugins to load the various file types used in the application and Babel to utilize newer JavaScript features. The following snippet lists the <kbd>devDependencies</kbd> we're using in the project (taken from <kbd>package.json</kbd>):</p>
<pre class="mce-root">...<br/>"devDependencies": {<br/>  "@babel/core": "^7.0.0-rc.1",<br/>  "@babel/preset-env": "^7.0.0-rc.1",<br/>  "babel-loader": "^8.0.0-beta.4",<br/>  "cpp-wasm-loader": "0.7.7",<br/>  "css-loader": "1.0.0",<br/>  "file-loader": "1.1.11",<br/>  "html-loader": "0.5.5",<br/>  "html-webpack-plugin": "3.2.0",<br/>  "mini-css-extract-plugin": "0.4.1",<br/>  "rimraf": "2.6.2",<br/>  "webpack": "4.16.5",<br/>  "webpack-cli": "3.1.0",<br/>  "webpack-dev-server": "3.1.5"<br/>},<br/>...</pre>
<p class="mce-root">I specified exact versions for some of the libraries to ensure the application builds and runs successfully. Any libraries with a name ending in <kbd>-loader</kbd> or <kbd>-plugin</kbd> are used in conjunction with Webpack. The <kbd>cpp-wasm-loader</kbd> library allows us to import a C or C++ file directly, without having to compile it to Wasm first. Webpack 4 has built-in support for importing <kbd>.wasm</kbd> files, but you can't specify an <kbd>importObj</kbd> argument, which is required for modules generated with Emscripten.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring loaders and plugins in webpack.config.js</h1>
                </header>
            
            <article>
                
<p class="mce-root">We're using several different file types in addition to JavaScript for the application: CSS, SVG, HTML, and so on. Installing the <kbd>-loader</kbd> dependencies is only part of the equation—you also need to tell Webpack how to load them. You also need to specify configuration details for any plugins you have installed. You can specify the loading and configuration details in a <kbd>webpack.config.js</kbd> file in the root folder of your project. The following snippet contains the contents of <kbd>/webpack-example/webpack.config.js</kbd>:</p>
<pre class="mce-root">const HtmlWebpackPlugin = require('html-webpack-plugin');<br/>const MiniCssExtractPlugin = require('mini-css-extract-plugin');<br/><br/>module.exports = {<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.js$/,<br/>        exclude: /node_modules/,<br/>        use: {<br/>          loader: 'babel-loader',<br/>          options: {<br/>            // We need this to use async/await:<br/>            presets: [<br/>              [<br/>                '@babel/preset-env', {<br/>                  targets: { node: '10' }<br/>                }<br/>              ]<br/>            ]<br/>          }<br/>        }<br/>      },<br/>      {<br/>        test: /\.html$/,<br/>        use: {<br/>          loader: 'html-loader',<br/>          options: { minimize: true }<br/>        }<br/>      },<br/>      {<br/>        test: /\.css$/,<br/>        use: [MiniCssExtractPlugin.loader, 'css-loader']<br/>      },<br/>      {<br/>        test: /\.(c|cpp)$/,<br/>        use: {<br/>          loader: 'cpp-wasm-loader',<br/>          options: {<br/>            emitWasm: true<br/>          }<br/>        }<br/>      },<br/>      {<br/>        test: /\.(png|jpg|gif|svg)$/,<br/>        use: {<br/>          loader: 'file-loader',<br/>          options: {<br/>            name: 'assets/[name].[ext]'<br/>          }<br/>        }<br/>      }<br/>    ]<br/>  },<br/>  plugins: [<br/>    new HtmlWebpackPlugin({<br/>      template: './src/index.html',<br/>      filename: './index.html'<br/>    }),<br/>    // This is used for bundling (building for production):<br/>    new MiniCssExtractPlugin({<br/>      filename: '[name].css',<br/>      chunkFilename: '[id].css'<br/>    })<br/>  ]<br/>};</pre>
<p class="mce-root">The <kbd>rules</kbd> section tells Webpack which loader to use for a file extension. The fourth item in the array handles C/C++ files (note the <kbd>test</kbd> field value containing <kbd>c|cpp</kbd>). The <kbd>HtmlWebpackPlugin</kbd> takes the contents of <kbd>/src/index.html</kbd>, adds any required <kbd>&lt;script&gt;</kbd> tags, minifies it, and creates an <kbd>index.html</kbd> in the <kbd>build</kbd> folder, which defaults to <kbd>/dist</kbd>. The <kbd>MiniCssExtractPlugin</kbd> copies any imported CSS into a single CSS file in the <kbd>/dist</kbd> folder. We'll review how to build the project in a later section, so let's move on to the application code, starting with the C file.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The C code</h1>
                </header>
            
            <article>
                
<p class="mce-root">Since we're allowed to import C and C++ files directly, the C file is located within the <kbd>/src</kbd> folder. This file, <kbd>main.c</kbd>, contains logic to manage collision detection and move the spaceship around the <kbd>&lt;canvas&gt;</kbd>. The code is based on the <kbd>without-glue.c</kbd> file we created in <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <em>Creating and Loading a WebAssembly Module</em>. We're not going to review the entire file, only the sections that have changed and merit explanation. Let's begin with the definitions and declarations section, which includes a new <kbd>struct</kbd>: <kbd>Bounds</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Definitions and declarations</h1>
                </header>
            
            <article>
                
<p class="mce-root">The code containing the definitions and declarations sections is shown as follows:</p>
<pre class="mce-root">typedef struct Bounds {<br/>  int width;<br/>  int height;<br/>} Bounds;<br/><br/>// We're using the term "Rect" to represent the rectangle the<br/>// image occupies:<br/>typedef struct Rect {<br/>  int x;<br/>  int y;<br/>  int width;<br/>  int height;<br/>  // Horizontal direction of travel (L/R):<br/>  char horizDir;<br/>  // Vertical direction of travel (U/D):<br/>  char vertDir;<br/>} Rect;<br/><br/>struct Bounds bounds;<br/>struct Rect rect;</pre>
<p class="mce-root">New properties were added to the existing <kbd>Rect</kbd> definition to accommodate for flexible sizing and tracking movement in the <em>x</em> and <em>y</em> directions. We defined a new <kbd>struct</kbd>, <kbd>Bounds</kbd>, and removed the existing <kbd>#define</kbd> statements because the <kbd>&lt;canvas&gt;</kbd> element is no longer a square with static dimensions. A new instance of both elements is declared when the module loads. The dimensional properties of these instances are assigned in the <kbd>start()</kbd> function, which we'll cover next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The start() function</h1>
                </header>
            
            <article>
                
<p class="mce-root">The updated <kbd>start()</kbd> function, which acts as the entry point to the module, is shown as follows:</p>
<pre class="mce-root">EMSCRIPTEN_KEEPALIVE<br/>void start(int boundsWidth, int boundsHeight, int rectWidth,<br/>           int rectHeight) {<br/>    rect.x = 0;<br/>    rect.y = 0;<br/>    rect.horizDir = 'R';<br/>    rect.vertDir = 'D';<br/>    rect.width = rectWidth;<br/>    rect.height = rectHeight;<br/>    bounds.width = boundsWidth;<br/>    bounds.height = boundsHeight;<br/>    setIsRunning(true);<br/>}</pre>
<p class="mce-root">Any functions that are called from JavaScript are prepended with the <kbd>EMSCRIPTEN_KEEPALIVE</kbd> statement. We're now passing the width and height of both the <kbd>Bounds</kbd> and <kbd>Rect</kbd> elements as arguments to the <kbd>start()</kbd> function, which we assign to the local <kbd>bounds</kbd> and <kbd>rect</kbd> variables. This allows us to easily change the dimensions of either one without having to make any changes to the collision detection logic. In the context of this application, the <kbd>rect</kbd> represents the rectangle in which the spaceship image resides. We set the default horizontal and vertical direction for the <kbd>rect</kbd> so the image initially moves to the right and down. Let's move on to the <kbd>rect</kbd> movement/collision detection code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The updateRectLocation() function</h1>
                </header>
            
            <article>
                
<p class="mce-root">The code related to collision detection and the <kbd>Rect</kbd> movement is handled in the <kbd>updateRectLocation()</kbd> function, which is shown as follows:</p>
<pre class="mce-root">/**<br/> * Updates the rectangle location by +/- 1px in the x or y based on<br/> * the current location.<br/> */<br/>void updateRectLocation() {<br/>    // Determine if the bounding rectangle has "bumped" into either<br/>    // the left/right side or top/bottom side. Depending on which side,<br/>    // flip the direction:<br/>    int xBouncePoint = bounds.width - rect.width;<br/>    if (rect.x == xBouncePoint) rect.horizDir = 'L';<br/>    if (rect.x == 0) rect.horizDir = 'R';<br/><br/>    int yBouncePoint = bounds.height - rect.height;<br/>    if (rect.y == yBouncePoint) rect.vertDir = 'U';<br/>    if (rect.y == 0) rect.vertDir = 'D';<br/><br/>    // If the direction has changed based on the x and y<br/>    // coordinates, ensure the x and y points update<br/>    // accordingly:<br/>    int horizIncrement = 1;<br/>    if (rect.horizDir == 'L') horizIncrement = -1;<br/>    rect.x = rect.x + horizIncrement;<br/><br/>    int vertIncrement = 1;<br/>    if (rect.vertDir == 'U') vertIncrement = -1;<br/>    rect.y = rect.y + vertIncrement;<br/>}</pre>
<p class="mce-root">The primary difference between this code and the code we wrote in <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml"/><a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <em>Creating and Loading a WebAssembly Module</em>, is the collision detection logic. Instead of simply tracking the location of the <kbd>rect</kbd> instance horizontally and changing direction when it hits the right boundary, the function now tracks the horizontal and vertical directions and manages each independently. Although this isn't the most performant algorithm, it does achieve the goal of ensuring the spaceship changes direction when it encounters the edge of the <kbd>&lt;canvas&gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JavaScript code</h1>
                </header>
            
            <article>
                
<p class="mce-root">The only production dependency we're using for the application is Vue. Although the application consists of a single component, Vue makes managing data, functions, and the component life-cycle much simpler than trying to do it manually. The <kbd>index.js</kbd> file contains the Vue initialization code, while the rendering and application logic is in <kbd>/src/App.js</kbd>. This file has a lot of moving parts, so we're going to review the code in chunks, as we did in the previous section. Let's start with the <kbd>import</kbd> statements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The import statements</h1>
                </header>
            
            <article>
                
<p class="mce-root">The following code demonstrates the Webpack loaders in action:</p>
<pre class="mce-root">// This is loaded using the css-loader dependency:<br/>import './styles.css';<br/><br/>// This is loaded using the cpp-wasm-loader dependency:<br/>import wasm from './main.c';<br/><br/>// These are loaded using the file-loader dependency:<br/>import backgroundImage from './assets/background.jpg';<br/>import spaceshipImage from './assets/spaceship.svg';</pre>
<p class="mce-root">The loaders we configured in the <kbd>webpack.config.js</kbd> file understand how to handle CSS, C, and image files. Now that we have the required resources available, we can start defining our component state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component state</h1>
                </header>
            
            <article>
                
<p class="mce-root">The following code initializes the local state in the <kbd>data()</kbd> function for our component:</p>
<pre class="mce-root">export default {<br/>  data() {<br/>    return {<br/>      instance: null,<br/>      bounds: { width: 800, height: 592 },<br/>      rect: { width: 200, height: 120 },<br/>      speed: 5<br/>    };<br/>  },<br/>  ...</pre>
<p class="mce-root">Although the <kbd>bounds</kbd> and <kbd>rect</kbd> properties never change, we defined them in the local state to keep all the data used by the component in a single location. The <kbd>speed</kbd> property dictates how quickly the spaceship moves across the <kbd>&lt;canvas&gt;</kbd> and has a range of <kbd>1</kbd> to <kbd>10</kbd>. The <kbd>instance</kbd> property is initialized to null, but will be used to access the compiled Wasm module's exported functions. Let's move on to the Wasm initialization code that compiles the Wasm file and populates the <kbd>&lt;canvas&gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wasm initialization</h1>
                </header>
            
            <article>
                
<p class="mce-root">The code to compile the Wasm file and populate the <kbd>&lt;canvas&gt;</kbd> element is shown as follows:</p>
<pre class="mce-root">methods: {<br/>  // Create a new Image instance to pass into the drawImage function<br/>  // for the &lt;canvas&gt; element's context:<br/>  loadImage(imageSrc) {<br/>    const loadedImage = new Image();<br/>    loadedImage.src = imageSrc;<br/>    return new Promise((resolve, reject) =&gt; {<br/>      loadedImage.onload = () =&gt; resolve(loadedImage);<br/>      loadedImage.onerror = () =&gt; reject();<br/>    });<br/>  },<br/><br/>  // Compile/load the contents of main.c and assign the resulting<br/>  // Wasm module instance to the components this.instance property:<br/>  async initializeWasm() {<br/>    const ctx = this.$refs.canvas.getContext('2d');<br/><br/>    // Create Image instances of the background and spaceship.<br/>    // These are required to pass into the ctx.drawImage() function:<br/>    const [bouncer, background] = await Promise.all([<br/>      this.loadImage(spaceshipImage),<br/>      this.loadImage(backgroundImage)<br/>    ]);<br/><br/>    // Compile the C code to Wasm and assign the resulting<br/>    // module.exports to this.instance:<br/>    const { width, height } = this.bounds;<br/>    return wasm<br/>      .init(imports =&gt; ({<br/>        ...imports,<br/>        _jsFillRect(x, y, w, h) {<br/>          ctx.drawImage(bouncer, x, y, w, h);<br/>        },<br/>        _jsClearRect() {<br/>          ctx.drawImage(background, 0, 0, width, height);<br/>        }<br/>      }))<br/>        .then(module =&gt; {<br/>          this.instance = module.exports;<br/>          return Promise.resolve();<br/>        });<br/>  },<br/>  ...</pre>
<p class="mce-root">There are additional functions defined in the <kbd>methods</kbd> key of the component, but for now we'll focus on the code that compiles the imported C file to Wasm. After <kbd>Image</kbd> instances are created for the spaceship and background images, the <kbd>main.c</kbd> file (imported as <kbd>.wasm</kbd>) is compiled to a Wasm module and the resulting <kbd>exports</kbd> is assigned to <kbd>this.instance</kbd>. Once these operations complete, the <kbd>start()</kbd> function can be called from the exported Wasm module. Since the <kbd>initializeWasm()</kbd> function calls the <kbd>&lt;canvas&gt;</kbd> element's <kbd>getContext()</kbd> function, the component needs to be mounted before this function can be called. Let's review the rest of the <kbd>methods</kbd> definitions and the <kbd>mounted()</kbd> event handler.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component mounting</h1>
                </header>
            
            <article>
                
<p class="mce-root">The remaining <kbd>methods</kbd> definitions and <kbd>mounted()</kbd> event handler function are shown as follows:</p>
<pre class="mce-root">  ...<br/>  // Looping function to move the spaceship across the canvas.<br/>  loopRectMotion() {<br/>    setTimeout(() =&gt; {<br/>      this.instance.moveRect();<br/>      if (this.instance.getIsRunning()) this.loopRectMotion();<br/>    }, 15 - this.speed);<br/>  },<br/>  // Pauses/resumes the spaceship's movement when the button is<br/>  // clicked:<br/>  onActionClick(event) {<br/>    const newIsRunning = !this.instance.getIsRunning();<br/>    this.instance.setIsRunning(newIsRunning);<br/>    event.target.innerHTML = newIsRunning ? 'Pause' : 'Resume';<br/>    if (newIsRunning) this.loopRectMotion();<br/>  }<br/>},<br/>mounted() {<br/>  this.initializeWasm().then(() =&gt; {<br/>    this.instance.start(<br/>      this.bounds.width,<br/>      this.bounds.height,<br/>      this.rect.width,<br/>      this.rect.height<br/>    );<br/>    this.loopRectMotion();<br/>  });<br/>},</pre>
<p class="mce-root">Once the Wasm module is compiled, the <kbd>start()</kbd> function is accessible on <kbd>this.instance</kbd>. The <kbd>bounds</kbd> and <kbd>rect</kbd> dimensions are passed into the <kbd>start()</kbd> function, and then the <kbd>loopRectFunction()</kbd> is called to start moving the spaceship. The <kbd>onActionClick()</kbd> event handler function pauses or resumes the movement of the spaceship based on whether or not it's currently in motion.</p>
<p class="mce-root"/>
<p class="mce-root">The <kbd>loopRectMotion()</kbd> functions in the same way as the example code from <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml"/><a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <em>Creating and Loading a WebAssembly Module</em>, except the speed is now adjustable. The <kbd>15 - this.speed</kbd> calculation, which dictates the timeout length, may look a little strange. Since the movement speed of the image is based on the amount of time that elapses between function calls, increasing this number would actually slow down the spaceship. Consequently, <kbd>this.speed</kbd> is subtracted from <kbd>15</kbd>, which was chosen because it's slightly greater than <kbd>10</kbd> but won't turn the spaceship into a blur if <kbd>this.speed</kbd> is increased to the maximum. That's it for the component logic; let's move on to the rendering section of the code where the <kbd>template</kbd> is defined.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component rendering</h1>
                </header>
            
            <article>
                
<p class="mce-root">The contents of the <kbd>template</kbd> property, which dictates what to render, are shown as follows:</p>
<pre class="mce-root">template: `<br/>  &lt;div class="flex column"&gt;<br/>   &lt;h1&gt;SPACE WASM!&lt;/h1&gt;<br/>    &lt;canvas<br/>      ref="canvas"<br/>      :height="bounds.height"<br/>      :width="bounds.width"&gt;<br/>    &lt;/canvas&gt;<br/>    &lt;div class="flex controls"&gt;<br/>      &lt;div&gt;<br/>        &lt;button class="defaultText" @click="onActionClick"&gt;<br/>          Pause<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    &lt;div class="flex column"&gt;<br/>      &lt;label class="defaultText" for="speed"&gt;Speed: {{speed}}&lt;/label&gt;<br/>      &lt;input<br/>        v-model="speed"<br/>        id="speed"<br/>        type="range"<br/>        min="1"<br/>        max="10"<br/>        step="1"&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;<br/><br/></pre>
<p class="mce-root"/>
<p class="mce-root">Since we're using Vue, we can bind the attributes and event handlers of HTML elements to properties and methods defined in our component. In addition to a <span class="packt_screen">PAUSE</span>/<span class="packt_screen">RESUME</span> button, there's a range <kbd>&lt;input&gt;</kbd> that allows you to change the speed. By sliding it to the left or right, you're able to slow down or speed up the spaceship and see the changes reflected immediately. That concludes our review; let's see how Webpack can be used to build or run the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building and running the application</h1>
                </header>
            
            <article>
                
<p>Using the <kbd>cpp-wasm-loader</kbd> library eliminates the need for a build step to generate a Wasm module, but we still need to bundle up our application for distribution. In the <kbd>scripts</kbd> section of <kbd>package.json</kbd>, there's a <kbd>build</kbd> and <kbd>start</kbd> script. Running the <kbd>build</kbd> script executes the <kbd>webpack</kbd> command that generates the bundle. To ensure this is working correctly, open a terminal instance in the <kbd>/webpack-example</kbd> folder and run the following command:</p>
<pre><strong>npm run build</strong></pre>
<p>It may take a minute to build the project the first time you run it. This can be attributed to the Wasm compilation step. However, subsequent builds should be much faster. If the build was successful, you should see a newly created <kbd>/dist</kbd> folder with these contents:</p>
<pre class="mce-root">├── /assets<br/>│    ├── background.jpg<br/>│    └── spaceship.svg<br/>├── index.html<br/>├── main.css<br/>├── main.js<br/>└── main.wasm</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the build</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's try out the build to ensure everything is working correctly. Run the following command in your terminal instance to start the application:</p>
<pre class="mce-root"><strong>serve -l 8080 dist</strong></pre>
<p>If you navigate to <kbd>http://127.0.0.1:8080/index.html</kbd> in your browser, you should see this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9d3c1c1f-1f92-41e2-a5e6-27673bc221d8.png"/></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Webpack application running in the browser</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The spaceship image (taken from <a href="https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg">https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg</a>) bounces around within the bounds of the Horsehead Nebula background image (taken from <a href="https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg">https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg</a>). When the <span class="packt_screen">PAUSE</span> button is pressed, the button's caption changes to <span class="packt_screen">RESUME</span> and the ship stops moving. Pressing the button again will change the caption back to <span class="packt_screen">PAUSE</span> and the ship will start moving again. Adjusting the <span class="packt_screen">SPEED</span> slider increases or decreases the speed of the ship.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the start script</h1>
                </header>
            
            <article>
                
<p class="mce-root">The application has the <kbd>webpack-dev-server</kbd> library installed, which operates like <kbd>Browsersync.</kbd> The library uses LiveReloading, which automatically updates the application when you make any changes to the files in <kbd>/src</kbd>. Since we're using a Webpack loader for C and C++ files, the automatic update event will trigger if you change the C file as well. Run the following the command to start the application and watch for changes:</p>
<pre class="mce-root"><strong>npm start</strong></pre>
<p class="mce-root">A browser window should open automatically when the build completes, and then direct you to the running application. To see the live-reloading feature in action, try setting the value of the <kbd>isRunning</kbd> variable in the <kbd>setIsRunning()</kbd> function in <kbd>main.c</kbd> to false instead of <kbd>newIsRunning</kbd>:</p>
<pre class="mce-root">EMSCRIPTEN_KEEPALIVE<br/>void setIsRunning(bool newIsRunning) {<br/>    // isRunning = newIsRunning;<br/><br/>    // Set the value to always false:<br/>    isRunning = false;<br/>}</pre>
<p class="mce-root">The spaceship should be stuck in the upper-left corner. If you change it back, the spaceship starts moving again. In the next section, we will write unit tests in JavaScript to test WebAssembly modules.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing WebAssembly modules with Jest</h1>
                </header>
            
            <article>
                
<p class="mce-root">Well-tested code prevents regression bugs, simplifies refactoring, and alleviates some of the frustrations that go along with adding new features. Once you've compiled a Wasm module, you should write tests to ensure it's functioning as expected, even if you've written tests for C, C++, or Rust code you compiled it from. In this section, we'll use <strong>Jest</strong>, a JavaScript testing framework, to test the functions in a compiled Wasm module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The code being tested</h1>
                </header>
            
            <article>
                
<p class="mce-root">All of the code used in this example is located in the <kbd>/chapter-09-node/testing-example</kbd> folder. The code and corresponding tests are very simple and are not representative of real-world applications, but they're intended to demonstrate how to use Jest for testing. The following code represents the file structure of the <kbd>/testing-example</kbd> folder:</p>
<pre>├── /src<br/>|    ├── /__tests__<br/>|    │    └── main.test.js<br/>|    └── main.c<br/>├── package.json<br/>└── package-lock.json</pre>
<p class="mce-root">The contents of the C file that we'll test, <kbd>/src/main.c</kbd>, is shown as follows:</p>
<pre class="mce-root">int addTwoNumbers(int leftValue, int rightValue) {<br/>    return leftValue + rightValue;<br/>}<br/><br/>float divideTwoNumbers(float leftValue, float rightValue) {<br/>    return leftValue / rightValue;<br/>}<br/><br/>double findFactorial(float value) {<br/>    int i;<br/>    double factorial = 1;<br/>    <br/>    for (i = 1; i &lt;= value; i++) {<br/>        factorial = factorial * i;<br/>    }<br/>    return factorial;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">All three functions in the file are performing simple mathematical operations. The <kbd>package.json</kbd> file includes a script to compile the C file to a Wasm file for testing. Run the following command to compile the C file:</p>
<pre class="mce-root"><strong>npm run build</strong></pre>
<p class="mce-root">There should be a file named <kbd>main.wasm</kbd> in the <kbd>/src</kbd> directory. Let's move on to describing the testing configuration step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing configuration</h1>
                </header>
            
            <article>
                
<p class="mce-root">The only dependency we'll use for this example is Jest, a JavaScript testing framework built by Facebook. Jest is an excellent choice for testing because it includes most of the features you'll need out of the box, such as coverage, assertions, and mocking. In most cases, you can use it with zero configuration, depending on the complexity of your application. If you're interested in learning more, check out Jest's website at <a href="https://jestjs.io">https://jestjs.io</a>. Open a terminal instance in the <kbd>/chapter-09-node/testing-example</kbd> folder and run the following command to install Jest:</p>
<pre class="mce-root"><strong>npm install</strong></pre>
<p class="mce-root">In the <kbd>package.json</kbd> file, there are three entries in the <kbd>scripts</kbd> section: <kbd>build</kbd>, <kbd>pretest</kbd>, and <kbd>test</kbd>. The <kbd>build</kbd> script executes the <kbd>emcc</kbd> command with the required flags to compile <kbd>/src/main.c</kbd> to <kbd>/src/main.wasm</kbd>. The <kbd>test</kbd> script executes the <kbd>jest</kbd> command with the <kbd>--verbose flag</kbd>, which provides additional details for each of the test suites. The <kbd>pretest</kbd> script simply runs the <kbd>build</kbd> script to ensure <kbd>/src/main.wasm</kbd> exists prior to running any tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tests file review</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's walk through the test file, located at <kbd>/src/__tests__/main.test.js</kbd>, and review the purpose of each section of code. The first section of the test file instantiates the <kbd>main.wasm</kbd> file and assigns the result to the local <kbd>wasmInstance</kbd> variable:</p>
<pre class="mce-root">const fs = require('fs');<br/>const path = require('path');<br/><br/>describe('main.wasm Tests', () =&gt; {<br/>  let wasmInstance;<br/><br/>  beforeAll(async () =&gt; {<br/>    const wasmPath = path.resolve(__dirname, '..', 'main.wasm');<br/>    const buffer = fs.readFileSync(wasmPath);<br/>    const results = await WebAssembly.instantiate(buffer, {<br/>      env: {<br/>        memoryBase: 0,<br/>        tableBase: 0,<br/>        memory: new WebAssembly.Memory({ initial: 1024 }),<br/>        table: new WebAssembly.Table({ initial: 16, element: 'anyfunc' }),<br/>        abort: console.log<br/>      }<br/>    });<br/>    wasmInstance = results.instance.exports;<br/>  });<br/> ...</pre>
<p class="mce-root">Jest provides life-cycle methods to perform any setup or teardown actions prior to running tests. You can specify functions to run before or after all of the tests (<kbd>beforeAll()</kbd>/<kbd>afterAll()</kbd>), or before or after each test (<kbd>beforeEach()</kbd>/<kbd>afterEach()</kbd>). We need a compiled instance of the Wasm module from which we can call exported functions, so we put the instantiation code in the <kbd>beforeAll()</kbd> function.</p>
<p class="mce-root">We're wrapping the entire test suite in a <kbd>describe()</kbd> block for the file. Jest uses a <kbd>describe()</kbd> function to encapsulate suites of related tests and <kbd>test()</kbd> or <kbd>it()</kbd> to represent a single test. Here's a simple example of this concept:</p>
<pre class="mce-root">const add = (a, b) =&gt; a + b;<br/><br/>describe('the add function', () =&gt; {<br/>  test('returns 6 when 4 and 2 are passed in', () =&gt; {<br/>    const result = add(4, 2);<br/>    expect(result).toEqual(6);<br/>  });<br/><br/>  test('returns 20 when 12 and 8 are passed in', () =&gt; {<br/>    const result = add(12, 8);<br/>    expect(result).toEqual(20);<br/>  });<br/>});</pre>
<p class="mce-root">The next section of code contains all the test suites and tests for each exported function:</p>
<pre class="mce-root">...<br/>  describe('the _addTwoNumbers function', () =&gt; {<br/>    test('returns 300 when 100 and 200 are passed in', () =&gt; {<br/>      const result = wasmInstance._addTwoNumbers(100, 200);<br/>      expect(result).toEqual(300);<br/>    });<br/><br/>    test('returns -20 when -10 and -10 are passed in', () =&gt; {<br/>      const result = wasmInstance._addTwoNumbers(-10, -10);<br/>      expect(result).toEqual(-20);<br/>    });<br/>  });<br/><br/>  describe('the _divideTwoNumbers function', () =&gt; {<br/>    test.each([<br/>      [10, 100, 10],<br/>      [-2, -10, 5],<br/>    ])('returns %f when %f and %f are passed in', (expected, a, b) =&gt; {<br/>      const result = wasmInstance._divideTwoNumbers(a, b);<br/>      expect(result).toEqual(expected);<br/>    });<br/><br/>    test('returns ~3.77 when 20.75 and 5.5 are passed in', () =&gt; {<br/>      const result = wasmInstance._divideTwoNumbers(20.75, 5.5);<br/>      expect(result).toBeCloseTo(3.77, 2);<br/>    });<br/>  });<br/><br/>  describe('the _findFactorial function', () =&gt; {<br/>    test.each([<br/>      [120, 5],<br/>      [362880, 9.2],<br/>    ])('returns %p when %p is passed in', (expected, input) =&gt; {<br/>      const result = wasmInstance._findFactorial(input);<br/>      expect(result).toEqual(expected);<br/>    });<br/>  });<br/>});</pre>
<p class="mce-root">The first <kbd>describe()</kbd> block, for the <kbd>_addTwoNumbers()</kbd> function, has two <kbd>test()</kbd> instances to ensure that the function returns the sum of the two numbers passed in as arguments. The next two <kbd>describe()</kbd> blocks, for the <kbd>_divideTwoNumbers()</kbd> and <kbd>_findFactorial()</kbd> functions, use Jest's <kbd>.each</kbd> feature, which allows you to run the same test with different data. The <kbd>expect()</kbd> function allows you to make assertions on the value passed in as an argument. The <kbd>.toBeCloseTo()</kbd> assertion in the last <kbd>_divideTwoNumbers()</kbd> test checks whether the result is within two decimal places of <kbd>3.77</kbd>. The rest use the <kbd>.toEqual()</kbd> assertion to check for equality.</p>
<p class="mce-root">Writing tests with Jest is relatively simple, and running them is even easier! Let's try running our tests and reviewing some of the CLI flags that Jest provides.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the tests</h1>
                </header>
            
            <article>
                
<p class="mce-root">To run the tests, open a terminal instance in the <kbd>/chapter-09-node/testing-example</kbd> folder and run the following command:</p>
<pre class="mce-root"><strong>npm test</strong></pre>
<p class="mce-root">You should see the following output in your terminal:</p>
<pre class="mce-root">main.wasm Tests<br/>  the _addTwoNumbers function<br/>    ✓ returns 300 when 100 and 200 are passed in (4ms)<br/>    ✓ returns -20 when -10 and -10 are passed in<br/>  the _divideTwoNumbers function<br/>    ✓ returns 10 when 100 and 10 are passed in<br/>    ✓ returns -2 when -10 and 5 are passed in (1ms)<br/>    ✓ returns ~3.77 when 20.75 and 5.5 are passed in<br/>  the _findFactorial function<br/>    ✓ returns 120 when 5 is passed in (1ms)<br/>    ✓ returns 362880 when 9.2 is passed in<br/><br/>Test Suites: 1 passed, 1 total<br/>Tests: 7 passed, 7 total<br/>Snapshots: 0 total<br/>Time: 1.008s<br/>Ran all test suites.</pre>
<p class="mce-root">If you have a large number of tests, you could remove the <kbd>--verbose</kbd> flag from the <kbd>test</kbd> script in <kbd>package.json</kbd> and only pass the flag to the <kbd>npm test</kbd> command if needed. There are several other CLI flags you can pass to the <kbd>jest</kbd> command. The following list contains some of the more commonly used flags:</p>
<ul>
<li class="mce-root"><kbd>--bail</kbd>: Exits the test suite immediately upon the first failing test suite</li>
<li class="mce-root"><kbd>--coverage</kbd>: Collects test coverage and displays it in the terminal after the tests have run</li>
<li class="mce-root"><kbd>--watch</kbd>: Watches files for changes and reruns tests related to changed files</li>
</ul>
<p class="mce-root">You can pass these flags to the <kbd>npm</kbd> test command by adding them after a <kbd>--</kbd>. For example, if you wanted to use the <kbd>--bail</kbd> flag, you'd run this command:</p>
<pre class="mce-root"><strong>npm test -- --bail</strong></pre>
<p class="mce-root">You can view the entire list of CLI options on the official site at <a href="https://jestjs.io/docs/en/cli">https://jestjs.io/docs/en/cli</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we discussed the advantages of integrating WebAssembly with Node.js and demonstrated how Node.js could be used on the server and client side. We evaluated an Express application that uses a Wasm module to perform calculations on accounting transactions. We then reviewed a browser-based application that utilizes Webpack to import and call functions from a C file without having to write any Wasm instantiation code. Finally, we saw how the Jest testing framework can be leveraged to test a compiled module and ensure it's functioning correctly. In <a href="93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml">Chapter 10</a>, <span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label"><em>Advanced Tools and Upcoming Features</em>,</span></span> we'll cover advanced tools and discuss the features that are on the horizon for WebAssembly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">What is one of the advantages of integrating WebAssembly with Node.js?</li>
<li class="mce-root">What library does the Express application use to read and write data to a JSON file?</li>
<li class="mce-root">What is the difference between loading a module in the browser and in Node.js?</li>
<li class="mce-root">What technique can you use to run an <kbd>npm</kbd> script before or after an existing <kbd>npm</kbd> script?</li>
<li class="mce-root">What is the name of the task Webpack performs to eliminate dead code?</li>
<li class="mce-root">What is the purpose of a loader in Webpack?</li>
<li class="mce-root">What is the difference between the <kbd>describe()</kbd> and <kbd>test()</kbd> functions in Jest?</li>
<li class="mce-root">How do you pass additional CLI flags to the <kbd>npm test</kbd> command?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Express: <a href="https://expressjs.com">https://expressjs.com</a></li>
<li>Webpack: <a href="https://webpack.js.org">https://webpack.js.org</a></li>
<li class="mce-root">Jest API: <a href="https://jestjs.io/docs/en/api">https://jestjs.io/docs/en/api</a></li>
</ul>


            </article>

            
        </section>
    </body></html>