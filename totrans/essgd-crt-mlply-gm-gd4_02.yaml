- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending and Receiving Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how we can establish a connection between two
    computers using the high-level Godot Engine `ENetMultiplayerPeer` API. But what
    do we do after that? Why do we establish connections between computers? The foundation
    of a network is the communication between the connected computers, allowing them
    to send and receive data. This data is transferred by breaking down the content
    into small chunks called **packets**.
  prefs: []
  type: TYPE_NORMAL
- en: Each packet is like a postcard containing the necessary information, such as
    the sender’s and receiver’s IP addresses, the communication port, and the message’s
    content. We then send these packets over the network, where they can be routed
    to their intended recipient. Using communication protocols, such as the UDP protocol,
    we break the data into packets at the sending end and reassemble them at the receiving
    end of the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the fundamentals of how packets are sent and
    received and what makes the UDP protocol unique. For that, we’ll need to go a
    bit lower and use the Godot Engine `UDPServer` and `PacketPeerUDP` classes. These
    are lower-level API classes, so we will go through some intense content here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the **JavaScript Object Notation** (**JSON**) format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending packets with `PacketPeerUDP`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to packets with `UDPServer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading the player’s avatar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to keep up with our project in Godot Engine, but
    this time, we are going to use the files provided in the `res://02.sending-and-receiving-data`
    folder. So, if you haven’t already done so, download the project’s repository
    using this link: [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0).'
  prefs: []
  type: TYPE_NORMAL
- en: Then, with the project added to your Godot Engine project manager, open the
    project and proceed to the `res://02.sending-and-receiving-data` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Packets** are fundamental building blocks of communication over the network
    using the UDP protocol. They are small chunks of data that contain all the necessary
    information to reach their intended recipient. This includes the sender’s and
    receiver’s IP addresses, the communication port, and the message’s content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Senders send packets to the receiver over the network. The receiving end reassembles
    the packets, allowing the receiver to understand the message sent. This process
    is known as **packet switching**. You can see a visual representation of this
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Packet switching process](img/Figure_02.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Packet switching process
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other protocols, such as the TCP protocol, the UDP protocol does not
    guarantee that packets will arrive in the same order as they were sent. This means
    that the protocol is less reliable but more efficient and faster.
  prefs: []
  type: TYPE_NORMAL
- en: UDP is also different from other protocols due to its lack of connection state.
    Each packet contains all the data it needs to reach its receiving end. We address
    them individually, and the network routes them based on each packet’s own information.
    This contrasts with the TCP protocol as the latter needs to set up a prearranged,
    fixed data channel through a traditional handshake procedure.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can send these packets using the UDP protocol without a handshake.
    As long as our server is listening to messages at the specific port we’ve assigned,
    it will be able to receive the sender’s message.
  prefs: []
  type: TYPE_NORMAL
- en: Due to all that, the UDP protocol is more efficient for sending gameplay data
    across a network because it’s fast and doesn’t need to wait for confirmation of
    each packet in order at the receiver’s end. This is a huge advantage for online
    multiplayer games, especially ones where the player’s reaction time is important
    for the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also common to use the UDP protocol for quick message systems and even
    voice calls. One issue that may come with using UDP for voice calls is that sometimes
    the audio doesn’t reach the other side in the correct order, or in any order at
    all. This causes some issues, but since the communication is meant to be real
    time and users can ask the person at the other end of the conversation to repeat,
    the UDP protocol has become the go-to solution for this type of service. And this
    is what is important to understand—when it is and when it isn’t the proper choice.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have taken a glance at the protocols in which we can exchange data
    across the network, we need to understand what this data looks like. Can we send
    instances of objects across the network? How will they assemble at the receiver’s
    end?
  prefs: []
  type: TYPE_NORMAL
- en: Network communication is a bit lower level in this sense; we need to send only
    relevant information in data structures that both the sender and the receiver
    ends can understand. And for that, we commonly avoid passing binary data around,
    such as objects.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we serialize the important information and transmit the necessary chunks
    across the network so that the receiver end can create a whole new clone of the
    object using only the data we transmitted. This is way more reliable and allows
    for smaller bandwidth usage. One common data structure that we use is dictionaries
    in the format of JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the JSON format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In network programming, transmitting objects directly through the network is
    not always reliable, as the data may get corrupted or lost in transit. Moreover,
    transmitting objects containing executable code may pose a security risk if the
    code is malicious. That’s why it’s a common practice to use data serialization
    to convert objects into a format that can be easily transmitted over the network.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most commonly used data serialization formats is JSON. JSON is a
    lightweight, text-based format that can represent complex data structures such
    as arrays and objects, making it an ideal choice for network communication.
  prefs: []
  type: TYPE_NORMAL
- en: When using the Godot Engine network API with UDP, sending and receiving JSON
    files is a common practice. With JSON, we can serialize and deserialize data quickly
    and efficiently. JSON files are human-readable, making it easier for developers
    to debug and troubleshoot issues. JSON files are also flexible, meaning we can
    cherry-pick only the relevant data we need to send, making network communication
    even more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike binary formats, JSON files are easy to read and modify as well. This
    makes it easier to debug and troubleshoot any issues that may arise during the
    transmission of data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the advantages and the overall idea behind the JSON format,
    how do we use it properly? How does a JSON file help us transmit data around a
    network and keep players in the same game context?
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in this section, serialization is how we cherry-pick only the necessary
    information about a data structure, such as an object, and translate it into a
    format that we can pass around, and even store, to reconstruct the previous data
    structure. Serialization is one of the most important skills to learn in software
    engineering fields, including networks.
  prefs: []
  type: TYPE_NORMAL
- en: It is through serialization that we can translate the state of our application
    so that other instances of our application can further replicate this state through
    time—for instance, to make a save and load system or through space, as we are
    going to do in online multiplayer games. So, let’s understand how serialization
    works and how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Sprite2D` node, into a simple, linear representation that we can store in
    a file. For instance, `*.tscn` files are serialized files that represent a scene
    in Godot Engine’s editor.'
  prefs: []
  type: TYPE_NORMAL
- en: Serialization involves converting an object into a format that can be easily
    reconstructed on another machine or in another context. This can involve encoding
    the object’s properties, data, and other relevant information in a standardized
    format, such as JSON. Serialization is essential in network communication because
    it allows data to be transmitted and received efficiently and reliably, while
    also enabling interoperability between different programming languages and systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we want to recreate a `Sprite2D` node on the client’s side
    based on data provided by the server, we can serialize important properties such
    as its position, rotation, scale, and texture. It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, on the client’s side, we instantiate a new `Sprite2D` node and use this
    data to ensure it represents what the server wants the client to see. We are going
    to use serialization a lot moving forward. In Godot, we have the `JSON` helper
    class for creating and parsing JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: The `JSON.stringify()` method is used to serialize an object or a data type,
    such as an integer or a dictionary, into a JSON-formatted string. This method
    takes an object as input and returns a string containing the JSON representation
    of the input object.
  prefs: []
  type: TYPE_NORMAL
- en: The string can then be transmitted over the network, stored in a file, or used
    in any other context where a string representation of the object is needed. The
    resulting string can easily be deserialized back into an object using the `JSON.parse_string()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `JSON.parse_string()` method is used to deserialize a
    JSON-formatted string back into a recognized Godot data type or object. This method
    takes a string as input and returns the deserialized data. The resulting object
    can then be used in any context where the original object was needed.
  prefs: []
  type: TYPE_NORMAL
- en: When deserializing the JSON string, the method takes care of mapping the JSON
    values to the appropriate Godot Engine data types. This includes mapping strings
    to strings, numbers to numbers, and Booleans to Booleans, as well as parsing more
    complex types such as dictionaries and objects.
  prefs: []
  type: TYPE_NORMAL
- en: With both `JSON.stringfy()` and `JSON.parse_string()` methods, Godot Engine
    provides a simple and reliable way to convert data into a format that can be transmitted
    over the network or stored in a file.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how we can translate our relevant data into an understandable standard
    format that we can store, transmit, and recreate at the receiver end. Let’s understand
    how we can pass this data around in the network.
  prefs: []
  type: TYPE_NORMAL
- en: This is fundamental knowledge when we deal with online multiplayer games because
    it’s through this process that we will be able to recreate objects and even the
    whole game state across players, making them share the same game world.
  prefs: []
  type: TYPE_NORMAL
- en: Sending packets with PacketPeerUDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let’s move on to practical knowledge. In this chapter, your task is to
    implement a login system for a game. Our project already has a cool user interface
    and is able to gather player data, such as their login name and password. Your
    mission is to make sure that only authorized players can access the game’s content
    by implementing a secure authentication feature.
  prefs: []
  type: TYPE_NORMAL
- en: Once a player successfully logs in, you need to display their character’s avatar
    based on what we have saved in our database. As a network engineer, you understand
    the importance of security when it comes to online systems. You know that a robust
    authentication system is essential to ensure that only legitimate users are granted
    access to the game’s content.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you will need to develop a login system that checks players’ credentials
    against a secure database and verifies if they have permission to access the game’s
    features or not.
  prefs: []
  type: TYPE_NORMAL
- en: With your skills and experience, you need to create a system that will provide
    an excellent user experience while keeping players’ data secure. So, take up the
    challenge, and let’s create a login system that will be a testament to your skills
    as a network engineer!
  prefs: []
  type: TYPE_NORMAL
- en: In our project repository, open the `res://02.sending-and-receiving-data//MainMenu.tscn`
    scene, and let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AuthenticationCredentials Autoload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Godot Engine, **Autoloads** are singletons that Godot loads automatically
    when the game starts. We can create and edit them in the editor itself and access
    them from any script in the game. We use Autoloads to store game-wide data or
    to provide global functionality, making them a convenient way to carry players’
    credentials across the game.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of using Autoloads for carrying player credentials
    is that they are available throughout scene changes. This means that any script
    in the game can access the Autoload and retrieve the players’ credentials when
    needed. This eliminates the need to pass credentials from one script to another,
    making the code cleaner and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, since Autoloads are persistent throughout the game’s lifetime,
    as long as players don’t close the game, we can access their credentials.
  prefs: []
  type: TYPE_NORMAL
- en: This can make the process of implementing a login system with authentication
    features more efficient and streamlined.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create our `AuthenticationCredentials` Autoload, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene using a `Node` node as the root node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the root node `AuthenticationCredentials`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a new script to it, save it as `AuthenticationCredentials.gd`, and open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable to store the player’s username; we can name this variable
    `user`, and it should be an empty string by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a variable to store the session’s token when we successfully validate
    a login:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the scene, then go to **Project** | **Project Settings** and open the **Autoload**
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Path** field, click on the small folder icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Autoload tab in the Project Settings menu](img/Figure_02.02_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Autoload tab in the Project Settings menu
  prefs: []
  type: TYPE_NORMAL
- en: 'From the pop-up menu, select `AuthenticationCredentials.tscn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Selecting the AuthenticationCredentials scene from the File
    menu](img/Figure_2.03_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Selecting the AuthenticationCredentials scene from the File menu
  prefs: []
  type: TYPE_NORMAL
- en: Leave the **Node Name** field as **AuthenticationCredentials** and click on
    the **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And there we have it. Now, you can access the variables and functions defined
    in the script of the `AuthenticationCredentials.gd` scene from anywhere in your
    project by calling the `AuthenticationCredentials` singleton.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for keeping track of global state across multiple scenes and
    nodes in your game. It’s important to note that this Autoload should only exist
    on the client’s side of a multiplayer game, and not on the server’s side. So,
    make sure to remove it from your server application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can gather and send players’ credentials to the server.
    For that, we are going to work on the very login screen itself! Open `LoginScreen.tscn`
    and let’s move on to the cool stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Sending players’ credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Control` node named **LoginScreen** with a user interface that captures
    players’ credentials so that we can authenticate them and give them access to
    our world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The LoginScreen scene’s node hierarchy](img/Figure_02.04_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The LoginScreen scene’s node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: The interface includes two `LineEdit` nodes, one called `LineEdit` nodes allow
    players to input their login credentials. In case of any errors, we can use the
    **ErrorLabel** node to display any necessary messages.
  prefs: []
  type: TYPE_NORMAL
- en: As we collect the players’ credentials here, we can use the **LoginButton**
    node to trigger the login procedure. With this scene in place, our players can
    securely access their avatar screen once they successfully log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now, we need to work on validating their logins before loading their avatar.
    So, let’s get our hands dirty. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `LoginScreen.gd` script and go to the `send_credentials()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `send_credentials()` function, create a dictionary called `message`
    that contains the user credentials we will authenticate in the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To store these credentials, create a key in the message dictionary called `'authenticate_credentials'`;
    its value should also be a dictionary. We’ll use it to store players’ credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `user_line_edit` and `password_line_edit` text properties to capture
    the player’s input for their username and password, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate a new `PacketPeerUDP` object called `packet` using the `PacketPeerUDP.new()`
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Connect the `packet` object to the server’s address and port using the `connect_to_host()`
    method. Here, we are using our default `ADDRESS` and `PORT` constants that represent
    the IP address and port number of the server to which the client is connecting.
    They are `127.0.0.1` and `9999` respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Serialize the message dictionary object into a JSON-formatted string using
    the `JSON.stringify()` method, and send it to the server using the `packet.put_var()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `while` loop to wait for a response from the server. The `packet.wait()`
    method waits for a packet to arrive at the bound address. It returns an `OK` error
    constant if it receives a packet; otherwise, it returns an error code based on
    Godot’s error constants. So, we can use that to wait for the arrival of our packet
    at the server’s end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we receive a response, we need to deserialize the response data from JSON
    format back into a dictionary object using the `JSON.parse_string()` method. Let’s
    store that in a variable called `response`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the `response` dictionary for the presence of an authentication token
    using the `in` operator. If the `"token"` string is present, store its value in
    `AuthenticationCredentials.session_token`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we can also store the `user` present in the message we got from
    the server as our player’s username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the user interface to indicate a successful authentication, and switch
    to the `AvatarScreen.tscn` scene. If the token is not present, display an error
    message to the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, after all that, we can change the scene to the actual avatar screen using
    the `get_tree().change_scene_to_file("res://AvatarScreen.tscn")` method and break
    the `while` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In case we get a response from the server, and it doesn’t have the `"token"`
    key in it, we display an authentication failed message using the `error_label.text`
    and also break the `while` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, the `send_credentials()` method should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we’ve seen how the client side works and what it will do with players’
    data, let’s understand how the other side of this connection will receive this
    data and handle it. For that, open the `Server.tscn` scene.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to packets with UDPServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to our Godot Engine server scene! This scene is where our game’s server
    logic is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server is the backbone of our game, responsible for authenticating players
    and providing them with data about their avatars, such as their name and texture
    file. This node is called `Server`, and it has a pre-written script that includes
    some essential variables. Among them are two vital variables: `database_file_path`
    and `logged_users`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `database_file_path` variable is the path to the `FakeDatabase` JSON file,
    which represents a fake database that holds the players’ data. The `logged_users`
    variable is a dictionary that stores players who are currently logged in.
  prefs: []
  type: TYPE_NORMAL
- en: These variables are crucial to our server’s functionality, and we will use them
    to authenticate players and provide them with the data they need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the `Server` node’s most important feature, which is to listen
    to packets. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Server.gd` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a `server` variable and set it to `UDPServer.new()`. This creates a
    new instance of the `UDPServer` class that will allow us to listen to incoming
    connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `_ready()` function, call the `listen()` method on the `server` variable,
    passing our default `PORT` constant as an argument. This will start the server
    and make it listen for incoming connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `_process(delta)` function, call the `poll()` method on the `server`
    variable to check for any incoming messages. This method will not block the game
    loop, so we can call it in the `_process(delta)` function safely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `is_connection_available()` method on the `server` variable to check
    whether a client sent a message. If it returns `true`, call the `take_connection()`
    method to obtain a `PacketPeerUDP` instance that we can use to read the incoming
    message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `get_var()` method on the `PacketPeerUDP` instance we get to obtain
    the incoming message. Since we know that the message is a string in JSON format,
    we can use the `JSON.parse_string()` method to convert it to a dictionary object
    that we can work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the incoming message contains the `"authenticate_credentials"`
    key. If it does, call the `authenticate_player()` function, passing `peer` and
    `message` as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create the `authenticate_player()` method in a moment, but for now,
    our script should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We just saw how we can open a communication channel between the client and the
    server and start to listen to messages. With that, we can filter these messages
    so that the server knows what the client is requesting—in our case, to authenticate
    the players’ credentials.
  prefs: []
  type: TYPE_NORMAL
- en: This is a low-level implementation of a network API. With that, we can create
    standard message formats and contents that trigger events on the server side and
    expect standard responses from the server. Let’s see how our server replies to
    this client request.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authenticating player credentials is a crucial aspect of any multiplayer game.
    In our project, we are building a login system for a game using Godot Engine.
    The login system allows players to log in with their username and password and
    then displays their character’s avatar upon successful login.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use a fake database, stored as a JSON file, to represent the
    players’ credentials. While this approach is simpler than using a full-fledged
    database management system, it has its own security risks. So, be aware of the
    risks of this approach in a production-ready project.
  prefs: []
  type: TYPE_NORMAL
- en: To authenticate player credentials in our project, we will also use Godot’s
    `FileAccess` class to load the fake database from the JSON file and parse the
    data. This will allow us to compare players’ login credentials with the data in
    the database and authenticate the player if the credentials match.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a fake database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s load our database so that we can check whether the data we got from
    the player’s client matches anything on our server. In a nutshell, a database
    is an organized collection of data. In our case, we’ll use a JSON file format
    as our database.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using JSON files as databases is that they are easy to manipulate,
    and you don’t need to have prior knowledge of database structures and safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, our fake database consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can even open it in the very Godot Text Editor itself; just double-click
    the `res://FakeDatabase.json` file provided in our base project.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding JSON file represents a simple database that contains two user
    entries, `"user1"` and `"user2"`, each with a corresponding set of data. The data
    contained for each user includes a password, an avatar, and a name.
  prefs: []
  type: TYPE_NORMAL
- en: The `"password"` field holds the plain-text password for each user. This is
    a very simple approach to storing passwords, as it is not secure due to the possibility
    of it being compromised. However, it is suitable for educational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The `"avatar"` field contains a reference to a file that represents the user’s
    avatar. In this case, it is referencing two different image files from our game,
    one for each user.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `"name"` field simply holds a string that represents the player’s
    avatar name.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a database file shouldn’t by any means be available to the client.
    So, in your final project, make sure to remove your database file from Godot’s
    project and into a safe database device.
  prefs: []
  type: TYPE_NORMAL
- en: 'While JSON files are a great choice for certain projects, they may not be suitable
    for others. Here are some pros and cons to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are easy to read and write, making them a great choice for small projects
    or when the speed of development is a priority
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON files can be parsed natively by most programming languages, including GDScript
    as we saw previously, which means you don’t need to install any additional software
    or libraries to work with them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As we just saw, JSON files are human-readable and can be opened and edited using
    a simple text editor, which makes them great for debugging
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don’t scale well for large projects with many concurrent users, as there
    may be issues with data consistency and performance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON files are not as flexible as other database formats when it comes to querying
    data and performing complex operations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To load and read the data from our JSON fake database file, we’ll use Godot
    Engine’s `FileAccess` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `FileAccess` class is a built-in Godot class that provides an interface
    to load, read, write, and save files to and from the user’s disk. It is a powerful
    tool that is essential for any game or application that needs to access files
    from the user’s device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive into the specifics of how to use this class to load and parse our
    JSON fake database file into our game, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `load_database()` function in the `Server.gd` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the function, create a new instance of the `FileAccess` class by calling
    the `open` method and passing in the path to the JSON file as the first argument
    and `FileAccess.READ` as the second argument. The `READ` constant tells the `FileAccess`
    class that the file should be opened for reading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the file is open, call the `get_as_text()` method to read the contents
    of the file as a text string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, parse the contents of the file as a JSON string using the `JSON.parse_string()`
    method and store the resulting dictionary in the `fake_database` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we move on to replying to the player’s authentication request, let’s
    see how this function looks at the end of these steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With our database in place, we can look at our valid players and check whether
    the credentials we receive in the message sent by the client match the credentials
    we have stored. Ideally, we would use a safer format to avoid any data leaks or
    hack attacks, but this should do for our small application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can reply to the client with a valid response based on
    whether the player was successfully authenticated or if the authentication failed.
    In the former case, we will provide an authentication token to the player so that
    they can use it across their play session in order to keep them logged in without
    further authentication procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Replying to the authentication request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a client sends their credentials to the server to be authenticated, the
    server will receive them and start the authentication process. The server will
    use the credentials to search in our fake database, which contains user data,
    for a matching record. If the credentials match, the server will generate a session
    token and send it back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: A session token is a unique string of characters that identifies the client
    on the server side, and the client must present it on all subsequent requests
    to the server to prove their identity.
  prefs: []
  type: TYPE_NORMAL
- en: To validate credentials, we call the `load_database` function, which we can
    do in the `_ready()` function to load the fake database into our server.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will use the username that the player provided through the `logged_users`
    dictionary, along with the username, to keep track of the authenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: If a client tries to use an invalid or expired session token, the server will
    deny the request, and the client will need to authenticate again. This way, we
    can ensure that only authenticated clients have access to the server’s resources
    as they play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s move on to the `authenticate_player()` function and create our authentication
    logic. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the `authenticate_credentials` key from the `message` dictionary and
    store it in the `credentials` variable, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the `user` and `password` keys are present in the `credentials`
    dictionary by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the keys are present, extract the values of the `user` and `password` keys
    from the `credentials` dictionary and store them in separate variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the `user` key we just stored is present in our `fake_database`
    dictionary keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `user` is key present, check whether the `password` key matches the
    one stored in the `fake_database` dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `password` key matches, generate a random integer token and store it
    in the `logged_users` dictionary with `user` as the key so that we can always
    check them when necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a dictionary called `response` with a single key-value pair. The key
    is `token` and the value is the `token` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send the `response` dictionary back to the client in JSON format using the
    `peer.put_var()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the password does not match, send an empty string to the client to indicate
    that the authentication failed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, we should have a method that properly handles and replies to the
    player’s authentication request. Let’s see how it ended up:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s move on to one important part of this whole process. The player will
    get a request with a token that, as we saw in the *Sending Player’s Credentials*
    section, they will store in the `AuthenticationCredentials` Autoload. So, after
    that, the player’s game will change the scene to **AvatarScreen** and try to request
    their avatar.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how players will be able to keep their session valid throughout this
    process. The following section is fundamental even after the player actually starts
    playing the game. So, stay tuned to understand how we can always ensure the player
    is still holding a valid token.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining the player’s session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important aspects of any online game is keeping the player’s
    session alive throughout their playtime. In our project, we are going to make
    sure that the player’s token is available throughout the whole game session, even
    when changing between different scenes. This way, we can maintain the player’s
    identity as they play the game.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will store the token on the player’s machine using the `AuthenticationCredentials`
    singleton. This way, the player’s token will be available to all the game’s scripts,
    allowing us to check whether the player is still authenticated before proceeding
    to any other scene.
  prefs: []
  type: TYPE_NORMAL
- en: By keeping the token on the player’s machine, we can avoid constant login requests
    to the server to authenticate the player again, ensuring faster and smoother gameplay.
    To ensure that the player’s credentials are still valid, we will use the `get_authentication_token()`
    method to allow the player’s client to make a request to the server for their
    authentication token.
  prefs: []
  type: TYPE_NORMAL
- en: We call this method whenever the player is about to transition to a new scene
    or when a certain amount of time has passed since their last request. This way,
    we can ensure that the player is still authenticated and can proceed with their
    gameplay without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, still in the `Server.gd` script, go to the `get_authentication_token()`
    method, and let’s start providing players with what they need to play our game
    moving on! Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `get_authentication_token()` method, let’s extract the user’s information
    from the `message` argument. For that, we can create a new variable called `credentials`
    and assign it the value of the `message` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s check whether the `credentials` dictionary has a key called `"user"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the `token` key provided by the client matches the stored `token`
    key for the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable called `token` to store the `token` key we found in the `logged_users`
    variable. Then, let’s return the user’s authentication `token` key by calling
    the `peer.put_var()` method and passing the JSON-formatted token string so that
    the client receives a response from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our function should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, whenever we need to make any procedure that requires confirmation from
    the server that the player is still in a valid play session, we can call this
    function. But to actually do that, we need to add two lines of code to our server
    so that it understands when the client makes such a request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `_process()` function, we check whether the client is making a request
    for the `authenticate_credentials()` method. Let’s check whether the client is
    making a request for the `get_session_token()` method instead, and if so, we call
    it. The `_process()` function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s move on to the final part of our little project, where we are going
    to provide and load the player’s avatar data.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the player’s avatar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to **AvatarScreen**! This is where the player will be able to customize
    their avatar appearance and select a unique name in the final version of our (fake)
    game. To display their current available avatar, we need to load the player’s
    avatar data from the database and display it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, the `Control` node called `Control` node called **AvatarCard**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – The AvatarScreen scene’s node hierarchy](img/Figure_02.05_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The AvatarScreen scene’s node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: The **AvatarCard** node contains a **TextureRect** node to display the avatar’s
    image using a texture file and a **Label** node to display the avatar’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the player’s avatar, we first need to retrieve the path to the image
    file from our fake database, which we previously populated with avatar information.
    So, before we dive into the action in the `Server.gd` script, and let’s work on
    the `get_avatar()` function this time. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `get_avatar()` function, create a local `dictionary` variable that
    contains the contents of the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether there’s a `"user"` key present in the `dictionary` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we find the `"user"` key in this dictionary, let’s create a local `user`
    variable that is equal to the value of the `user` key in the `dictionary` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the `''token''` key in the `dictionary` variable matches the
    token stored in the `logged_users` dictionary for the user specified by the `user`
    key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this is the case, create a local `avatar` variable that is equal to the
    value of the `''avatar''` key in the `fake_database` dictionary for the user specified
    by the `''``user''` key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a local `nick_name` variable that is equal to the value of the `name`
    key in the `fake_database` dictionary for the user specified by the `user` key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `response` dictionary with the `avatar` and `name` keys and values
    of `avatar` and `nick_name` respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `peer.put_var()` method to send the `response` dictionary as a JSON
    string to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, we wrapped up our server, so we are ready to move to the `get_avatar()`
    function looks after our work:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s open the `AvatarScreen.gd` script so that we can finally display
    our player’s avatar! Go ahead to the `request_authentication()` function because,
    as mentioned before, every time we need to perform operations on the player’s
    data, we need to verify their credentials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the `request_authentication()` function, create a variable called `request`
    that holds a dictionary with the `''get_authentication_token''`, `''user''`, and
    `''token''` keys. The value of `''get_authentication_token''` should be set to
    `true` just so that the server understands the request, while the values of `"user``"`
    and `"token"` should be retrieved from the `AuthenticationCredentials` singleton:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `packet` to send this request to the server by encoding the request as
    a JSON string using `JSON.stringify()` and then using the `put_var()` method to
    send it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a `while` loop to wait for a response from the server. Inside the loop,
    create a variable called `data` to store the JSON response from the server, decoded
    using `JSON.parse_string()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the `data` variable is equal to the `session_token` variable
    stored in the `AuthenticationCredentials` singleton. If it is, call the `request_avatar`
    function and break out of the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end, our `request_authentication()` function should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It’s finally time to retrieve the player’s avatar data and display their avatar
    so that they can engage in our game world! For that, let’s go to the `request_avatar()`
    function and create the avatar request and creation displaying logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the `request_avatar()` function, create a dictionary named `request`
    with the `''get_avatar''`, `''token''`, and `"user"` keys and their respective
    values. We get the user and session tokens from the `AuthenticationCredentials`
    Autoload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `packet.put_var()` method to send the `request` dictionary as a JSON-formatted
    string to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `while` loop to wait for the server to respond. Inside the loop, parse
    the response as a dictionary using the `JSON.parse_string` method and store it
    in a variable named `data`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the dictionary data contains the `"avatar"` key. If it does,
    load the texture of the avatar image from the path in the `"avatar"` key value,
    and set it as the texture of the `texture_rect`. Also, set the value of the `label`
    to the value of the `"name"` key in the `data` dictionary. Finally, exit the `while`
    loop with `break`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have almost finished our login screen! Before we add the final touch, let’s
    see how the `request_avatar()` method ended up:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the final touch is to add yet another check on the `Server.gd` script
    to handle when we receive an avatar request. So, the `_process()` method should
    become something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And if we test our game by hitting the **Play** button, or if we test the **MainMenu**
    scene, we can verify that our game is working!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to select the **Server** button in one of
    the debugging instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Pressing the Server button in the MainMenu scene](img/Figure_02.06_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Pressing the Server button in the MainMenu scene
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in another instance, choose **Client**, and it should immediately open
    the **LoginScreen** scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Inserting the player’s username into the client’s LoginScreen
    UserLineEdit](img/Figure_02.07_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Inserting the player’s username into the client’s LoginScreen UserLineEdit
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose one of the users we have available in our fake database and insert their
    credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Inserting the player’s username into the client’s LoginScreen
    PasswordLineEdit](img/Figure_02.08_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Inserting the player’s username into the client’s LoginScreen PasswordLineEdit
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you press the **Login** button with the correct credentials, it
    should load the **AvatarScreen** scene with the respective avatar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.9 – The AvatarScreen scene displaying the player’s avatar after
    a successful authentication](img/Figure_02.09_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – The AvatarScreen scene displaying the player’s avatar after a successful
    authentication
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve made your first login screen with authentication features,
    serializing and deserializing players’ data all across the network. Be proud of
    yourself—this is a great feat!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how we can establish a connection between server and
    client using the UDP protocol implementation in Godot Engine’s network API. With
    that, the network peers can open a communication channel and exchange data.
  prefs: []
  type: TYPE_NORMAL
- en: Since this implementation works on quite a low-level approach, we saw how we
    can create a simple API for our peers to make, understand, and reply to each other’s
    requests. Depending on the request, it might be necessary to follow a process
    known as serialization, which is how we take relevant information from our game
    state and turn it into a format that we can store and pass around. In our case,
    we saw that JSON format is one of the most common serialization formats.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JSON format, we saw how we can parse our Godot Engine string as JSON
    and also how to turn a JSON file into a dictionary that we can work with more
    efficiently using GDScript.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we saw how we can authenticate players’ credentials,
    matching them against a fake database. With successful authentication, we gathered
    players’ data to display their respective avatars based on their data in our database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to add a new complexity level by allowing
    multiple clients to log in to the same server and finally have a shared experience.
    For that, we will create a `Lobby` node that displays all logged players’ names
    and avatars!
  prefs: []
  type: TYPE_NORMAL
