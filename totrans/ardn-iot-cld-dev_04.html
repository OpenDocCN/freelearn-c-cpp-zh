<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-85"><a id="_idTextAnchor085"/>4</h1>
<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Project #1 – a Smarter Setup for Sensing the Environment</h1>
<p>This chapter guides you through the reasons why a clean environment is necessary for human beings and how to implement air quality, temperature, and humidity monitoring by using <a id="_idIndexMarker342"/>low-cost <strong class="bold">ESP-series boards</strong>, with different open source sensors and<a id="_idIndexMarker343"/> the <strong class="bold">Arduino IoT Cloud</strong>. Moreover, you will learn how to visualize the relevant data and use the Arduino IoT Cloud features to expand the functionalities of your applications/projects.</p>
<p>In this chapter, you will <a id="_idIndexMarker344"/>gain confidence in how to build real-world solutions as we demonstrate <strong class="bold">Printed Circuit Board</strong> (<strong class="bold">PCB</strong>) design, its implementation, and its deployment in the real world. We will cover the following topics:</p>
<ul>
<li>Why is air quality monitoring necessary?</li>
<li>Hardware components – sensors and development boards</li>
<li>Project architecture</li>
<li>Setting up the <strong class="bold">Thing</strong>, network credentials, cloud variables, and code</li>
<li>Setting up a dashboard for web and mobile</li>
<li>What’s next?</li>
</ul>
<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Technical requirements</h1>
<p>The following hardware<a id="_idIndexMarker345"/> components are required to understand this chapter:</p>
<ul>
<li><strong class="bold">WeMos D1 </strong><strong class="bold">MINI ESP8266</strong></li>
<li>A <strong class="bold">DHT11</strong>/<strong class="bold">DHT22</strong> <a id="_idIndexMarker346"/>sensor/module</li>
<li>The <strong class="bold">MQ-135</strong> air quality<a id="_idIndexMarker347"/> module</li>
<li>A PCB (a link is available in the <em class="italic">PCB design and assembling hardware </em><em class="italic">components</em> section)</li>
<li>Female headers</li>
<li>Jumper cables</li>
</ul>
<p>For coding, we will <a id="_idIndexMarker348"/>use the <strong class="bold">Arduino Web Editor</strong>, which includes a large collection of development boards and sensor libraries, and the <strong class="bold">Arduino IoT Cloud</strong> for <a id="_idIndexMarker349"/>Thing and dashboard setup. To develop hardware and sensor designs, we <a id="_idIndexMarker350"/>will need <strong class="bold">Fritzing</strong> desktop software.</p>
<p>The code for this chapter is available at the book’s official GitHub repository, or you can directly download the code by following this link: <a href="https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers/tree/main/Chapter%234%20Project%231%20Sensing%20and%20Monitoring%20the%20Air%20for%20Clean%20Environment">https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers/tree/main/Chapter%234%20Project%231%20Sensing%20and%20Monitoring%20the%20Air%20for%20Clean%20Environment</a>.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Why is air quality monitoring necessary?</h1>
<p>Air quality monitoring<a id="_idIndexMarker351"/> is necessary for human beings because air pollution can have significant negative effects on our health and well-being. Poor air quality can cause a variety of respiratory and cardiovascular problems, such as asthma, chronic bronchitis, lung cancer, and heart disease. It can also exacerbate existing health conditions and reduce our ability to fight off infections and illnesses.</p>
<p>Air pollution can also impact the environment, including ecosystems, wildlife, and plants. Polluted air can lead to <strong class="bold">acid rain</strong>, which can<a id="_idIndexMarker352"/> damage crops, forests, and bodies of water and harm wildlife. It can also lead to the depletion of the ozone layer, which protects us from harmful UV radiation.</p>
<p>By monitoring air quality, we can identify areas where pollution levels are high and take steps to reduce exposure. This can include reducing emissions from factories, power plants, and transportation, as well as encouraging the use of clean energy and transportation alternatives. By improving air quality, we can help to protect our health, support the environment, and promote sustainable development.</p>
<p>Air quality monitoring is <a id="_idIndexMarker353"/>necessary to assess the level of pollutants present in the air we breathe. It helps to identify the sources of pollution and to track changes in air quality over time. There are several reasons why air quality monitoring is important:</p>
<ul>
<li><strong class="bold">Regulatory compliance</strong>: Many countries have regulations in place to limit the amount of pollutants that can be released into the air. Air quality monitoring is necessary to ensure that these regulations are followed and to identify areas where additional regulations may be necessary.</li>
<li><strong class="bold">Economic concerns</strong>: Poor air quality can have a negative impact on economic activity, including reduced productivity, increased healthcare costs, and decreased tourism. Monitoring air quality can help to identify areas where pollution levels are high and take steps to improve air quality and support economic growth.</li>
</ul>
<p>Overall, air quality monitoring is <a id="_idIndexMarker354"/>an essential tool to protect public health, preserve the environment, and promote sustainable economic development. Now we’ve had a theoretical review of air quality monitoring, it’s time to explore the project practically. Firstly, we will start with the hardware, where we will explore all the required components such as development boards, sensors, design diagrams, and PCB design for implementation. Later, we will set up the Thing and cloud variables, upload code to the development board, and set up the dashboard for data visualization.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Exploring the hardware requirements</h1>
<p>Before <a id="_idIndexMarker355"/>moving forward, we will first look at what types of development boards and sensors are required to accomplish the project. We aim to use a board that provides Wi-Fi connectivity, is small in size, and is low in cost. If we talk about Wi-Fi-enabled development<a id="_idIndexMarker356"/> boards, then <a id="_idIndexMarker357"/>there are <a id="_idIndexMarker358"/>a lot of organizations providing them, such as <strong class="bold">Arduino</strong>, the <strong class="bold">ESP32 series</strong>, and the <strong class="bold">ESP8266</strong> series. Arduino development boards such<a id="_idIndexMarker359"/> as <strong class="bold">MKR Wi-Fi 1010</strong> and <strong class="bold">MKR Wi-Fi 1000</strong> are expensive<a id="_idIndexMarker360"/> compared to ESP32 and ESP8266. Now, we have two options: we either go with ESP32 or ESP8266 and leave the Arduino development boards. In this project, we will be using the WeMos D1 Mini, which is part of the ESP8266 series. Although the ESP32 series offers similar features, it is equipped <a id="_idIndexMarker361"/>with <strong class="bold">Bluetooth Low Energy</strong> (<strong class="bold">BLE</strong>) connectivity, which is not currently compatible with this project. Thus, we have opted for the ESP8266 series development boards, which are not only compact in size but also more affordable.</p>
<p>Among the sensors, there is a diverse range of options for measuring temperature, humidity, and air quality. However, our primary goal is to provide sensors that are affordable and readily available to users worldwide. For temperature and humidity measurements, we rely on the widely available and reasonably priced DHT11/DHT22 sensors. The MQ-135 sensor provides a wide detecting scope, fast response, and high sensitivity. It is a stable and long-life, simple drive circuit application. These sensors are used in air quality control equipment and are suitable for detecting NH3, NOx, alcohol, benzene, smoke, CO2, and more. They are easily obtainable on the market and well-suited for small-scale projects.</p>
<p>The ESP8266 <a id="_idIndexMarker362"/>series<a id="_idIndexMarker363"/> has a wide collection of development boards that vary in size and pins. In this chapter, I’m using the WeMos D1 Mini development board, as it’s very compact compared to other boards and, of course, cheaper in cost, and it provides 5V as well as 3.3V pins. The following figure is the complete overview of the WeMos D1 Mini board, and demonstrates all the digital/analog Arduino-based pin numbers, ground and power pins, and so on:</p>
<div><div><img alt="Figure 4.1 – WeMos D1 Mini ESP8266" src="img/B19752_04_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – WeMos D1 Mini ESP8266</p>
<p>WeMos <a id="_idIndexMarker364"/>provides multiple pins for digital input/output, but there is only one analog pin for input/output operations. If you want to use multiple analog sensors, then <strong class="bold">analog-to-digital converters</strong> are <a id="_idIndexMarker365"/>available. One of the most famous analog-to-digital converters <a id="_idIndexMarker366"/>is the <strong class="bold">ADS1115</strong>/<strong class="bold">ADS1015 module</strong>, which provides four analog pins that help cater to the requirement of using multiple sensors.</p>
<p>However, for the current project, we need one digital pin for the <strong class="bold">DHT11</strong>/<strong class="bold">DHT22 sensor</strong> and one <a id="_idIndexMarker367"/>analog pin for the <strong class="bold">MQ-135 air quality sensor</strong>. One of the <a id="_idIndexMarker368"/>best features of the WeMos D1 Mini development board is the 5V power pin, which is not available on most ESP8266 series development boards.</p>
<p>Next, we will use the DHT11 sensor to sense temperature and humidity, but you can also use the DHT22 sensor, depending on your requirements. With regard to features, the DHT22 provides a broader range of sensing compared to the DHT11, but its cost is higher. The following diagram shows the pinout layout of both sensors:</p>
<div><div><img alt="Figure 4.2 – The DHT22 and DHT11 pinout layouts" src="img/B19752_04_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The DHT22 and DHT11 pinout layouts</p>
<p>Pin #1<a id="_idIndexMarker369"/> is the <strong class="bold">voltage common collector</strong> (<strong class="bold">VCC</strong>) and<a id="_idIndexMarker370"/> works with both 3.3V and 5V. Pin #2 is a <strong class="bold">data</strong> pin<a id="_idIndexMarker371"/> that connects with any digital pin of a development board, and Pin #4 is a <strong class="bold">ground</strong> (<strong class="bold">GND</strong>) pin<a id="_idIndexMarker372"/> that connects with the GND pin of a development board. There is another pin in the sensor, Pin #3, which<a id="_idIndexMarker373"/> is <strong class="bold">Not Connected</strong> (<strong class="bold">NC</strong>) – this pin is not used by us during development.</p>
<p>The following table explains all the specification differences between DHT22 and DHT11; the most notable<a id="_idIndexMarker374"/> things are <a id="_idIndexMarker375"/>the <strong class="bold">sensing range</strong> and the <strong class="bold">sensing period</strong>:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Model</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">DHT22</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">DHT11</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Power supply</p>
</td>
<td class="No-Table-Style" colspan="2">
<p>3.3–5V</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Output signal</p>
</td>
<td class="No-Table-Style" colspan="2">
<p>A digital signal via a single bus</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Sensing element</p>
</td>
<td class="No-Table-Style" colspan="2">
<p>Polymer capacitor</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Sensing range</p>
</td>
<td class="No-Table-Style">
<p>Humidity: 0–100% RH</p>
<p>Temperature: 40~80 Celsius</p>
</td>
<td class="No-Table-Style">
<p>Humidity: 20–90% RH</p>
<p>Temperature: 0~50 Celsius</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Accuracy</p>
</td>
<td class="No-Table-Style">
<p>Humidity: ± 2% RH (Max ±5% RH)</p>
<p>Temperature: &lt;±0.5 Celsius</p>
</td>
<td class="No-Table-Style">
<p>Humidity: ±1% RH (Max ± 5% RH)</p>
<p>Temperature: &lt;±2 Celsius</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Sensing period</p>
</td>
<td class="No-Table-Style">
<p>Average 2s</p>
</td>
<td class="No-Table-Style">
<p>Average 1s</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.1 – DHT11 vs DHT22 comparison</p>
<p>Finally, we <a id="_idIndexMarker376"/>will look at the main sensor for our project. The MQ-135 sensor is used to monitor the air quality of a specific area. It is a low-cost environment-monitoring sensor, and it monitors a wide range of parameters, such as smoke, carbon dioxide, ammonia, benzene, nitrogen oxides, and alcohol. The MQ-135 senses all these parameters and provides the value of air<a id="_idIndexMarker377"/> quality in <strong class="bold">parts per million</strong> (<strong class="bold">ppm</strong>). The following figure shows the MQ-135’s shape and its pin layout diagram as well as indicators for the LED and regulator:</p>
<div><div><img alt="Figure 4.3 – MQ-135 sensor and pinout" src="img/B19752_04_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – MQ-135 sensor and pinout</p>
<p>The <a id="_idIndexMarker378"/>MQ-135 sensor <a id="_idIndexMarker379"/>module consists of four<a id="_idIndexMarker380"/> pins, and each pin is marked with a code: <strong class="bold">Analog Output</strong> (<strong class="bold">AO</strong>), <strong class="bold">Digital Output</strong> (<strong class="bold">DO</strong>), GND, and VCC. The module provides readings on both analog and digital modes, but analog mode is best to get values in PPM. The sensor operates better with 5V power, but you can still use 3.3V, although I recommend the former. The MQ-135 requires 20 seconds of preheating to provide better readings, so make sure to get readings after an interval of every 20 seconds, or at least wait 20 seconds for the first-time boot of the development board.</p>
<p>The module also contains a regulator to control the sensitivity of sensors, which could be adjusted according to the environment. Different indicator <strong class="bold">Surface Mount Device</strong> (<strong class="bold">SMD</strong>) LEDs<a id="_idIndexMarker381"/> are available<a id="_idIndexMarker382"/> to verify the module<a id="_idIndexMarker383"/> status, which<a id="_idIndexMarker384"/> includes <strong class="bold">Logic Out LED</strong> and <strong class="bold">Power LED</strong>.</p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Understanding the project architecture</h1>
<p>In the preceding<a id="_idIndexMarker385"/> sections, we discussed the sensors and development board in detail. Now, it’s time to cook the recipe. In hardware development, before getting to work with sensors and development boards, we need to develop design concepts to get a better understanding of how things will be connected. There is a lot of software available to design and develop design concepts regarding electronics projects, but we will opt for Fritzing.</p>
<p>In the next subsection, we will talk about the schematics and the design of the project, which explains how to connect the pins to the development board. In the subsection after that, we will talk about the PCB design and its implementation to make a product ready for deployment in the field.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>Schematics and design</h2>
<p>The <a id="_idIndexMarker386"/>purpose of our design is to get a clear understanding of how sensors will connect with the development board. It helps engineers develop a prototype on <a id="_idIndexMarker387"/>a <strong class="bold">breadboard</strong> or <strong class="bold">Veroboard</strong> by using our design files. The other major benefit of<a id="_idIndexMarker388"/> designing is that Fritzing builds hardware schematics and the PCB design in the background according to your design, which can be adjusted by designers according to system requirements. The following design provides a full overview of how you can connect sensors to a development board:</p>
<div><div><img alt="Figure 4.4 – An air quality-monitoring system design" src="img/B19752_04_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – An air quality-monitoring system design</p>
<p>For better <a id="_idIndexMarker389"/>understanding we have developed the schematics diagram shown in <em class="italic">Figure 4</em><em class="italic">.4</em> as well <em class="italic">Table 4.2</em> for easy understanding. The pin configuration will be discussed in detail in proceeding paragraph.</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">We Mos </strong><strong class="bold">D1 mini</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">MQ-135</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">DHT22</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>5V</p>
</td>
<td class="No-Table-Style">
<p>VCC</p>
</td>
<td class="No-Table-Style">
<p>VCC</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>GND</p>
</td>
<td class="No-Table-Style">
<p>GND</p>
</td>
<td class="No-Table-Style">
<p>GND</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>A0</p>
</td>
<td class="No-Table-Style">
<p>A0</p>
</td>
<td class="No-Table-Style">
<p>-</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>D1</p>
</td>
<td class="No-Table-Style">
<p>-</p>
</td>
<td class="No-Table-Style">
<p>Data</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.2 – Pin configuration table for sensors</p>
<p>According to the design (<em class="italic">Figure 4</em><em class="italic">.4</em> and <em class="italic">Table 4.2</em>), we have a common 5V output and GND from the development board to both sensors. The MQ-135 sensor is an analog sensor, so we connected its AO pin to the AO pin of the WeMos development board, while DHT11/DHT22 are digital sensors, and their Pin 2 is connected to the D1 pin of the development board.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>PCB design and the assembly of hardware components</h2>
<p>In the preceding subsection, we <a id="_idIndexMarker390"/>looked at a design that is ideal for creating a <a id="_idIndexMarker391"/>prototype using a breadboard or Veroboard, but what if we want to deploy that solution in the field? <strong class="bold">Fritzing</strong> is a great<a id="_idIndexMarker392"/> tool that provides the option to design the PCB, but when you develop the design, it automatically creates the PCB design in the backend, which is accessible via the <strong class="bold">PCB Design</strong> tab. Automatic PCB design is just a basic footprint and not suitable for direct production, so it’s mandatory to review and rearrange the design according to professional practices. The following diagram demonstrates the final PCB design of the project:</p>
<div><div><img alt="Figure 4.5 – An air quality-monitoring system PCB design" src="img/B19752_04_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – An air quality-monitoring system PCB design</p>
<p>It’s easy to <a id="_idIndexMarker393"/>develop the PCB; just make sure that the connection<a id="_idIndexMarker394"/> line doesn’t intersect with other connection lines. There are many different tools available for PCB design, such as EasyEDA, CircuitMaker, and Altium, but it is thanks to Fritzing that I could create that design so easily.</p>
<p>After the PCB design, you have two options. First, you can develop the PCB by yourself using a DIY method, which is good for learning purposes but not suitable for a large-scale product. The second method is to choose a professional organization that manufactures the PCB professionally. Many<a id="_idIndexMarker395"/> organizations in China provide PCB manufacturing and<a id="_idIndexMarker396"/> fabrication services, such as <strong class="bold">Seeed Studio</strong>, <strong class="bold">JLCPCB</strong>, and <strong class="bold">PCBWay</strong>. I have tried PCBWay<a id="_idIndexMarker397"/> and was impressed with their manufacturing and shipment delivery time. I have uploaded the PCB design to the PCBWay project repository; from there, you can select and order it easily: <a href="https://www.pcbway.com/project/shareproject/Low_cost_Outdoor_Air_Quality_Monitoring_System_0157f1af.html">https://www.pcbway.com/project/shareproject/Low_cost_Outdoor_Air_Quality_Monitoring_System_0157f1af.html</a>.</p>
<p>After getting the PCB board, it’s time to solder the female headers for the development boards and sensors. Never solder the development board and sensors directly on the PCB, as if anything stops working, then it’s easy to detach and replace. So finally, here we have a product ready<a id="_idIndexMarker398"/> where the sensors and development board are soldered on the PCB for final<a id="_idIndexMarker399"/> deployment.</p>
<div><div><img alt="Figure 4.6 – An air-quality monitoring system on the PCB" src="img/B19752_04_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – An air-quality monitoring system on the PCB</p>
<p>After the female headers are soldered onto the PCB, WeMos and the other sensors are plugged into the headers, as shown in the preceding diagram. In this section and the previous section, we explored what types of sensors and development boards will be used in our project, and the latter part of this section discussed design, which demonstrates the wiring system for connectivity between sensors and the WeMos D1 Mini. Finally, we explored PCB design and assembled all the components of the PCB. Next, we need to set up the Thing, code, and dashboard in the Arduino IoT Cloud to get ready for the final product.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>Setting up the Thing, network credentials, cloud variables, and code</h1>
<p>After setting up the<a id="_idIndexMarker400"/> hardware, it’s time to set up the Thing in the Arduino IoT Cloud. For this project, we need three cloud variables to fetch the monitoring parameters from the device, and the Wi-Fi network settings will be different as compared to Arduino development boards, due to the ESP series-based development board. The following figure provides an overview of the Thing, including <strong class="bold">Cloud Variables</strong>, <strong class="bold">Associating a device</strong>, and <strong class="bold">Network</strong> settings with numbers, which will be discussed next step by step:</p>
<div><div><img alt="Figure 4.7 – The air quality-monitoring system Thing setup" src="img/B19752_04_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The air quality-monitoring system Thing setup</p>
<p>Set up a new Thing with the name <code>Sense the Environment</code>. Follow the next steps to create variables, the associated device, the network configuration, and finally, the code:</p>
<ol>
<li>Firstly, we need to set up three cloud variables regarding air quality, humidity, and temperature. The complete details regarding cloud variables are available in the next subsection.</li>
<li>After that, we need to associate the device with the Thing. In the current project, we will use the WeMos D1 Mini so the wizard will be different from the Arduino boards. The complete details are available in the <em class="italic">Associating a </em><em class="italic">device</em> subsection.</li>
<li>Finally, we need to set up the network configuration for the device, but this time, we need to provide a security key for ESP series boards to make the connection secure. The Arduino-compatible boards are configured by the Arduino IoT Cloud automatically during the device setup wizard.</li>
<li>After the<a id="_idIndexMarker401"/> setup of cloud variables, device, and network settings, we will go through the code.</li>
</ol>
<p>Here, we have given an overview of the Thing and we also discussed the required steps that will be carried out to complete the Thing setup.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Cloud variables</h2>
<p>The <a id="_idIndexMarker402"/>following table explains all the properties of the variable that we need to use when we create the cloud variable. An integer is a very famous data type, but we will use two new variable types for humidity (<code>CloudRelativeHumidity</code>) and temperature (<code>CloudTemperatureSensor</code>), which measure data in percentage and Celsius, respectively. Next, make sure to declare the variables exactly as stated in the given table, including case-sensitive names and variable types. If the example code does not match your naming, you will need to modify it accordingly.</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">S#</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Declaration</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Permission</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Update policy</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>1</p>
</td>
<td class="No-Table-Style">
<p><code>AirQuality</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p><code>airQuality</code></p>
</td>
<td class="No-Table-Style">
<p>Read-only</p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>2</p>
</td>
<td class="No-Table-Style">
<p><code>Humidity</code></p>
</td>
<td class="No-Table-Style">
<p><code>CloudRelative Humidity</code></p>
</td>
<td class="No-Table-Style">
<p><code>humidity</code></p>
</td>
<td class="No-Table-Style">
<p>Read-only</p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>3</p>
</td>
<td class="No-Table-Style">
<p><code>Temperature</code></p>
</td>
<td class="No-Table-Style">
<p><code>CloudTemperature Sensor</code></p>
</td>
<td class="No-Table-Style">
<p><code>temperature</code></p>
</td>
<td class="No-Table-Style">
<p>Read-only</p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.3 – Cloud variables details</p>
<p>Here, we made the <strong class="bold">permission</strong> read-only; although<a id="_idIndexMarker403"/> we have a read/write option, in our project, we only want to receive data from the device instead of a dashboard modification. That’s why read-only mode is used to prevent issues in data consistency. <strong class="bold">Update policy</strong> is set to <strong class="bold">On change</strong>, as the device will send the data after five minutes, and this option is more appropriate compared to periodic updates.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Associating a device</h2>
<p>After creating<a id="_idIndexMarker404"/> the variables, it’s time to add a device and associate it with the Thing. Before adding the device, connect the development board to the computer and <a id="_idIndexMarker405"/>open the <strong class="bold">Arduino Create Agent</strong> application. The following figure shows the different types of third-party boards that are supported by the Arduino IOT Cloud, and in that step, we will select the <strong class="bold">ESP8266</strong> series board.</p>
<div><div><img alt="Figure 4.8 – The device selection wizard" src="img/B19752_04_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The device selection wizard</p>
<p>Please follow<a id="_idIndexMarker406"/> these steps to add the device to the Arduino IoT Cloud:</p>
<ol>
<li>Click on the <strong class="bold">Select Device</strong> button under the <strong class="bold">Associating a device</strong> section on the Thing page.</li>
<li>A popup will appear, where you can see all the devices that are already available. If you have already added your WeMos D1 Mini, select it. Otherwise, click on <strong class="bold">SET UP </strong><strong class="bold">NEW DEVICE</strong>.</li>
<li>Next, click on the <strong class="bold">Third party </strong><strong class="bold">device</strong> option.</li>
<li>Select <strong class="bold">ESP8266</strong> and <strong class="bold">LOLIN(WEMOS) D1 R2 mini</strong> from the dropdown, and click on the <strong class="bold">CONTINUE</strong> button.</li>
<li>Provide the device name and click on the <strong class="bold">Next</strong> button.</li>
<li>In the final wizard, the device ID and secret key will be displayed. Copy the secret<a id="_idIndexMarker407"/> key to a safe place, as it will be used during the network configuration.</li>
</ol>
<p>After setting up the device and associating it with the Thing, it’s time to configure the device network settings. The following sections will cover all the steps to configure your device for a Wi-Fi network.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Network</h2>
<p>After associating the<a id="_idIndexMarker408"/> device with the Thing, it is time to configure the Wi-Fi settings for device communication. Fill in the form with <strong class="bold">Wi-Fi Name</strong> and <strong class="bold">Password</strong>:</p>
<div><div><img alt="Figure 4.9 – The network configuration for the Thing" src="img/B19752_04_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – The network configuration for the Thing</p>
<p>In <em class="italic">Figure 4</em><em class="italic">.9</em>, you will find a new field for <strong class="bold">Secret Key</strong>. Paste the secret key that we received from the system during the device association process, which is explained in <em class="italic">step 6</em> in the <a id="_idIndexMarker409"/>preceding subsection.</p>
<p>Now, we are done with the device association to the Thing as well as with network settings. The next step is to understand and upload the code. The following section will guide you through the code.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Coding</h2>
<p>The chapter’s code <a id="_idIndexMarker410"/>is available at the book’s official GitHub repository, or you can directly download the code by following this link: <a href="https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers/tree/main/Chapter%234%20Project%231%20Sensing%20and%20Monitoring%20the%20Air%20for%20Clean%20Environment/Sense_the_Environment_feb24a">https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers/tree/main/Chapter%234%20Project%231%20Sensing%20and%20Monitoring%20the%20Air%20for%20Clean%20Environment/Sense_the_Environment_feb24a</a></p>
<p>You can download the code and put it into your Thing by navigating to the <code>delay</code> method, as it will block the <code>ArduinoCloud.update()</code> method and then call the <code>STHAM</code> method every five minutes. The following code is demonstrating how to fetch Temperature and Humidity values from <code>dht</code> object, and for <code>airQuality</code> we are simply using <code>analogRead()</code> method.</p>
<pre class="source-code">
  dht.temperature().getEvent(&amp;event);
  if (isnan(event.temperature)) {
    temperature=0;
  }
  else {
    //Send Temperature to Cloud
    temperature=event.temperature;
  }
  // Get humidity event and print its value.
  dht.humidity().getEvent(&amp;event);
  if (isnan(event.relative_humidity)) {
    humidity=0;
  }
  else {
    //Send Humidity to Cloud
    humidity=event.relative_humidity;
  }
  //Send Air Quality to Cloud
  airQuality=analogRead(A0);</pre> <p>The preceding code snippet was taken from the <code>STHAM</code> method; here, we just modified the code to show you how we send values to the Arduino IoT Cloud after taking values from the sensors.</p>
<p>In a previous section, we created the cloud variables. Just recall the cloud variable declaration and assign the sensor readings to those variables. This cloud variable declaration is available in the <code>thingProperties.h</code> file. So, when you assign the values to these variables, the <code>ArduinoCloud.update()</code> method in the loop will automatically send data to the cloud.</p>
<p>Upload the code <a id="_idIndexMarker411"/>to the device and verify the connectivity and readings. If you want to change the reading time, then just modify the <code>interval</code> variable value. Make sure you provide the time in milliseconds, where 1 second equals 1,000 milliseconds.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you used different naming in the variable declaration, then update the code according to your naming scheme. However, it’s better that you first follow all the steps according to the book and later change the cloud variable names and modify your code, in that order.</p>
<p class="callout">Never try to use <code>delay</code> method, which will create a block for the <code>ArduinoCloud.update()</code> method. Always use milliseconds to calculate the waiting time. Review the <code>loop()</code> method to understand how we call the method after 5 minutes.</p>
<p class="callout">The Arduino IoT Cloud only updates the value on the dashboard whenever a variable value is changed. For example, if the temperature is 30 and is still the same after 5 minutes, then the Arduino IoT Cloud will not record the value, so don’t get confused if values don’t change on a graph. This is another benefit of the Arduino IoT Cloud: you will not get duplicated data when you export the content.</p>
<p>We have successfully set up the Thing, which includes cloud variables, device association, network configuration, and code, and uploaded it to the development board. Now, it’s time to explore the dashboard and sensor values visualization in the following section.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Setting up a dashboard for web and mobile</h1>
<p>After <a id="_idIndexMarker412"/>uploading the code to the device, it’s time to set up a dashboard for web and mobile to visualize the data with different widgets. Complete details about widgets and their usage are available in <a href="B19752_03.xhtml#_idTextAnchor056"><em class="italic">Chapter 3</em></a>. If you have directly skipped to this chapter, I recommend going back to <a href="B19752_03.xhtml#_idTextAnchor056"><em class="italic">Chapter 3</em></a> to get a detailed overview of widgets and their usage as this will help you to understand how widgets work and their usage for different use cases. The following figure demonstrates the visualization of readings with different widgets:</p>
<div><div><img alt="Figure 4.10 – The Thing dashboard" src="img/B19752_04_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – The Thing dashboard</p>
<p>We have three<a id="_idIndexMarker413"/> different readings, <strong class="bold">Temperature</strong>, <strong class="bold">Humidity</strong>, and <strong class="bold">Air Quality</strong>. For each reading, we use different widget controls to demonstrate how they all work, but for historical data, graphs are the best widgets.</p>
<p>The <strong class="bold">Temperature</strong> reading is visualized by <strong class="bold">Gauge</strong>, the <strong class="bold">Humidity</strong> reading is connected to the <strong class="bold">Percentage</strong> widget, and the <strong class="bold">Air Quality</strong> reading is connected to the <strong class="bold">Value</strong> widget. These widgets are only capable of displaying current readings of sensors. However, we also want to monitor the historical data, and graphs are the best widgets to display live as well as older data. Here, we have used three graphs, and each one is connected to a specific cloud variable.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>What’s next?</h1>
<p>We still have a lot of options available to explore, but now it’s your turn to use different sensors and development boards to do some more experiments and learn from them. In this chapter, we have only used two sensors, which only offer three parameters, but there are a lot of sensors on the market that provide a wide variety of functionalities, such as air pressure and measurements for different gases.</p>
<p>Try out the following sensors to enhance your practical knowledge and compare them with other sensors in terms of features, range, and cost:</p>
<ul>
<li>The <strong class="bold">BMP280</strong> (pressure and<a id="_idIndexMarker414"/> temperature) sensor</li>
<li>The <strong class="bold">MH-Z19C/D/E series</strong> sensors<a id="_idIndexMarker415"/> for carbon dioxide monitoring</li>
<li>The <strong class="bold">MQ series</strong> sensors, which<a id="_idIndexMarker416"/> are designed to sense different specific gases, including MQ-2, MQ-3, MQ-4, MQ-5, MQ-7, MQ-8, and MQ-9</li>
<li><strong class="bold">Seeed Studio SCD30</strong> (temperature, humidity, and <a id="_idIndexMarker417"/>CO2)</li>
<li><strong class="bold">Gravity</strong>: <strong class="bold">Analog Electrochemical Carbon Dioxide Sensor</strong> (0–10,000 <a id="_idIndexMarker418"/>PPM)</li>
</ul>
<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/>Summary</h1>
<p>In this chapter, we explored how to develop a low-cost air quality monitoring system using DHT11, MQ-135, and the WeMos D1 Mini development board. We set up the Thing, which involved creating cloud variables, associating the device, configuring the network, and coding the development board. Later, we created a dashboard to visualize the Thing’s sensor readings with different types of widgets, displaying the current readings as well as historical data with the help of graphs. Through this project, you will get the confidence to set up the Thing practically and deploy it in the field using a PCB. You have learned about new types of cloud variables for sensor readings and storage, as well as dealing with different types of dashboard widgets.</p>
<p>In the next chapter, we will study GSM technology for IoT. We will learn about different types of global IoT SIM cards and their usage. This project will also demonstrate a Smart Assets tracing example, where we will track the asset with a GPS module and send the data to the Arduino IoT Cloud via global IoT SIM cards. In the end, you will also learn about new widgets in the Arduino IoT Cloud to visualize the location of your assets on the basis of GPS coordinates.</p>
</div>
</body></html>