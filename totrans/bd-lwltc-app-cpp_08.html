<html><head></head><body>
<div id="_idContainer055">
<h1 class="chapter-number" id="_idParaDest-193"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-194"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.2.1">Processing Market Data and Sending Orders to the Exchange in C++</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will build the client’s C++ system that receives and processes market data updates from the trading exchange. </span><span class="koboSpan" id="kobo.3.2">We will also have to deal with creating and reading from UDP sockets, dealing with packet losses, etc. </span><span class="koboSpan" id="kobo.3.3">We will discuss the design of an order book on the client side to track the order book maintained at the trading exchange. </span><span class="koboSpan" id="kobo.3.4">We will also implement the C++ components needed to establish and maintain TCP connections to the trading exchange. </span><span class="koboSpan" id="kobo.3.5">We will also implement functionality to send orders to the exchange from the strategies and receive and process </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">order responses.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Subscribing to market data and decoding the market </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">data protocol</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Building order books from </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">market data</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Connecting to the exchange, sending order requests, and </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">receiving responses</span></span></li>
</ul>
<h1 id="_idParaDest-195"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">All the code for this book can be found in the GitHub repository for this book at </span><a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP"><span class="koboSpan" id="kobo.15.1">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</span></a><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">The source for this chapter is in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.17.1">Chapter 8</span></strong></span><span class="koboSpan" id="kobo.18.1"> directory in </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">the repository.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">You must read and understand the design of the electronic trading ecosystem presented in the chapter </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">The components we build in this chapter will interact with the electronic trading exchange application we built in the chapter </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Communicating With Market Participants</span></em><span class="koboSpan" id="kobo.24.1">, so we assume you are familiar with that. </span><span class="koboSpan" id="kobo.24.2">The limit order book we will build in the client application’s trade engine component is almost identical to the order book we built inside the matching engine in the chapter </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.26.1"> within the </span><em class="italic"><span class="koboSpan" id="kobo.27.1">Building the order book and matching orders</span></em><span class="koboSpan" id="kobo.28.1"> section. </span><span class="koboSpan" id="kobo.28.2">So, we assume the reader is very familiar with that chapter and the code we discussed there as we will make references to that in this chapter. </span><span class="koboSpan" id="kobo.28.3">As before, we will use the building blocks we built in the </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Building the C++ Building Blocks for Low Latency </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.30.1">Applications</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.31.1"> chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">The specifications of the environment in which the source code for this book was developed are shown in the following bullet list. </span><span class="koboSpan" id="kobo.32.2">We present the details of this environment since all the C++ code presented in this book is not necessarily portable and might require some minor changes to work in </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">your environment:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.34.1">OS – </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">x86_64 GNU/Linux</span></strong></span></li>
<li><span class="koboSpan" id="kobo.37.1">GCC – </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">g++ (Ubuntu </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">11.3.0-1ubuntu1~22.04.1) 11.3.0</span></strong></span></li>
<li><span class="koboSpan" id="kobo.40.1">CMAKE – </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">cmake </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">version 3.23.2</span></strong></span></li>
<li><span class="koboSpan" id="kobo.43.1">NINJA – </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">1.10.2</span></strong></span></li>
</ul>
<h1 id="_idParaDest-196"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.45.1">Subscribing to market data and decoding the market data protocol</span></h1>
<p><span class="koboSpan" id="kobo.46.1">The first component we need to build inside the market participants’ trading system is the market data </span><a id="_idIndexMarker1116"/><span class="koboSpan" id="kobo.47.1">consumer. </span><span class="koboSpan" id="kobo.47.2">This component is responsible for </span><a id="_idIndexMarker1117"/><span class="koboSpan" id="kobo.48.1">subscribing to the multicast stream of public market data updates published by the trading exchange. </span><span class="koboSpan" id="kobo.48.2">It needs to decode the market data stream generated by the exchange from the public </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.50.1"> format </span><a id="_idIndexMarker1118"/><span class="koboSpan" id="kobo.51.1">we discussed earlier. </span><span class="koboSpan" id="kobo.51.2">Because of the choice of the </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">Simple Binary Encoding</span></strong><span class="koboSpan" id="kobo.53.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.54.1">SBE</span></strong><span class="koboSpan" id="kobo.55.1">) protocol, the decoding step is straightforward in our application and does not involve any complicated stream decoding logic. </span><span class="koboSpan" id="kobo.55.2">Another important responsibility of this component is detecting packet drops on the incremental market data stream and providing mechanisms to recover and synchronize with the market data stream again. </span><span class="koboSpan" id="kobo.55.3">This mechanism is also required for trading systems that subscribe to the market data stream after there is a non-empty order book, i.e. </span><span class="koboSpan" id="kobo.55.4">after the trading exchange is already open and accepting client orders. </span><span class="koboSpan" id="kobo.55.5">Also, this will be required if the trading application needs to be restarted in the middle of </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the day.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">We present a detailed diagram of the market data consumer component we have seen before. </span><span class="koboSpan" id="kobo.57.2">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.58.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.59.1">.1</span></em><span class="koboSpan" id="kobo.60.1">, it consumes multicast data containing market data updates from the incremental and optionally the snapshot stream. </span><span class="koboSpan" id="kobo.60.2">After checking for sequence numbers </span><a id="_idIndexMarker1119"/><span class="koboSpan" id="kobo.61.1">on the market data updates and potentially needing to </span><a id="_idIndexMarker1120"/><span class="koboSpan" id="kobo.62.1">synchronize between the snapshot and the incremental streams, it decodes the market data updates. </span><span class="koboSpan" id="kobo.62.2">It then generates a stream of decoded and in-order market data updates for the trading engine to consume and publishes them over a </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">lock-free queue:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.64.1"><img alt="Figure 8.1 – An overview of the market data consumer component and its sub-components" src="image/B19434_05_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.65.1">Figure 8.1 – An overview of the market data consumer component and its sub-components</span></p>
<p><span class="koboSpan" id="kobo.66.1">Before we jump into the design and implementation of the market data consumer component, we </span><a id="_idIndexMarker1121"/><span class="koboSpan" id="kobo.67.1">would like to mention that the source code for this </span><a id="_idIndexMarker1122"/><span class="koboSpan" id="kobo.68.1">component can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">Chapter8/trading/market_data/market_data_consumer.h</span></strong><span class="koboSpan" id="kobo.70.1"> source file and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">Chapter8/trading/market_data/market_data_consumer.cpp</span></strong><span class="koboSpan" id="kobo.72.1"> source file. </span><span class="koboSpan" id="kobo.72.2">Next, let us get started by first defining the internal data members that the market data consumer component </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">will need.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.74.1">Defining the data members in the market data consumer</span></h2>
<p><span class="koboSpan" id="kobo.75.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.77.1"> class we are going to build will need a couple of important data </span><a id="_idIndexMarker1123"/><span class="koboSpan" id="kobo.78.1">members as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">bullet list:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.80.1">First, it needs a lock-free </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">incoming_md_updates_</span></strong><span class="koboSpan" id="kobo.82.1"> queue instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">Exchange::MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.84.1"> type, which we defined before. </span><span class="koboSpan" id="kobo.84.2">This is meant to be used by </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.86.1"> to publish the </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.88.1"> messages to the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">engine component.</span></span></li>
<li><span class="koboSpan" id="kobo.90.1">We will maintain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">next_exp_inc_seq_num_</span></strong><span class="koboSpan" id="kobo.92.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">size_t</span></strong><span class="koboSpan" id="kobo.94.1"> type, which will be used to make sure that we process updates from the incremental market data stream in the correct order and detect packet drops on the incremental market </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">data stream.</span></span></li>
<li><span class="koboSpan" id="kobo.96.1">We will have two multicast subscriber sockets – </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">incremental_mcast_socket_</span></strong><span class="koboSpan" id="kobo.98.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">snapshot_mcast_socket_</span></strong><span class="koboSpan" id="kobo.100.1"> of the  </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">Common::McastSocket</span></strong><span class="koboSpan" id="kobo.102.1"> types. </span><span class="koboSpan" id="kobo.102.2">These correspond to the sockets we will use to subscribe to and consume multicast data from the incremental and the snapshot multicast </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">streams, respectively.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.104.1">To perform the recovery/synchronization from the snapshot market data stream when needed, we will need to maintain a couple of extra data members, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">bullet list:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.106.1">First, we will store an </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">in_recovery_</span></strong><span class="koboSpan" id="kobo.108.1"> boolean flag to signify if </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.110.1"> detected a packet drop and is currently trying to recover using the snapshot and incremental market </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">data streams.</span></span></li>
<li><span class="koboSpan" id="kobo.112.1">Since we will join and leave the snapshot multicast stream as needed, we will have the multicast stream and network interface information in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">iface_</span></strong><span class="koboSpan" id="kobo.114.1"> variable, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">snapshot_ip_ variable</span></strong><span class="koboSpan" id="kobo.116.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">snapshot_port_</span></strong><span class="koboSpan" id="kobo.118.1"> variable. </span><span class="koboSpan" id="kobo.118.2">These </span><a id="_idIndexMarker1124"/><span class="koboSpan" id="kobo.119.1">represent the network interface to use, the IP address, and the port of the snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">multicast stream.</span></span></li>
<li><span class="koboSpan" id="kobo.121.1">Finally, we define a type to queue up messages and order them by their corresponding sequence number. </span><span class="koboSpan" id="kobo.121.2">We will use the </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">Standard Template Library</span></strong><span class="koboSpan" id="kobo.123.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.124.1">STL</span></strong><span class="koboSpan" id="kobo.125.1">) </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">std::map</span></strong><span class="koboSpan" id="kobo.127.1"> type here and paramaterize it to use keys of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">size_t</span></strong><span class="koboSpan" id="kobo.129.1"> type (to represent the sequence number of the update), hold objects of </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">Exchange::MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.131.1">, and call this type </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">QueuedMarketUpdates</span></strong><span class="koboSpan" id="kobo.133.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">typedef</span></strong><span class="koboSpan" id="kobo.135.1">. </span><span class="koboSpan" id="kobo.135.2">We chose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">std::map</span></strong><span class="koboSpan" id="kobo.137.1"> type here since it is easier </span><a id="_idIndexMarker1125"/><span class="koboSpan" id="kobo.138.1">to iterate over sorted keys compared to, say, </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">std::unordered _map</span></strong><span class="koboSpan" id="kobo.140.1">. </span><span class="koboSpan" id="kobo.140.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">std::map</span></strong><span class="koboSpan" id="kobo.142.1"> is not efficient for a wide range of reasons – the internal data structure is </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">Red Black Tree</span></strong><span class="koboSpan" id="kobo.144.1">, which has an asymptotic insertion performance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">O(log(N))</span></strong><span class="koboSpan" id="kobo.146.1"> and causes dynamic memory allocations, etc. </span><span class="koboSpan" id="kobo.146.2">However, we make an exception in this </span><a id="_idIndexMarker1126"/><span class="koboSpan" id="kobo.147.1">case because snapshot recovery is expected to be extremely rare, and when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.149.1"> class is recovering from the snapshot stream, trading is generally paused inside the client’s trading application since it does not have an accurate view of the state of the order book. </span><span class="koboSpan" id="kobo.149.2">Additionally, the snapshot stream is delayed and throttled from the exchange’s side, so the snapshot synchronization process itself is not required to be </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">low latency.</span></span></li>
<li><span class="koboSpan" id="kobo.151.1">We create two instances of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">QueuedMarketUpdates</span></strong><span class="koboSpan" id="kobo.153.1"> type – </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">snapshot_queued_msgs_</span></strong><span class="koboSpan" id="kobo.155.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">incremental_queued_msgs_</span></strong><span class="koboSpan" id="kobo.157.1">, one to queue up </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.159.1"> messages from the snapshot stream and one to queue up </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.161.1"> messages from the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">incremental stream.</span></span></li>
<li><span class="koboSpan" id="kobo.163.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.165.1"> class is also a different thread of execution, so similar to the </span><a id="_idIndexMarker1127"/><span class="koboSpan" id="kobo.166.1">classes we have seen before, it has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">run_</span></strong><span class="koboSpan" id="kobo.168.1"> boolean flag to control the execution of the thread and it is marked </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">volatile</span></strong><span class="koboSpan" id="kobo.170.1"> since it is accessed from </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">different threads:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
#pragma once
#include &lt;functional&gt;
#include &lt;map&gt;
#include "common/thread_utils.h"
#include "common/lf_queue.h"
#include "common/macros.h"
#include "common/mcast_socket.h"
#include "exchange/market_data/market_update.h"
namespace Trading {
class MarketDataConsumer {
private:
    size_t next_exp_inc_seq_num_ = 1;
    Exchange::MEMarketUpdateLFQueue *incoming_md_updates_ =
      nullptr;
    volatile bool run_ = false;
    std::string time_str_;
    Logger logger_;
    Common::McastSocket incremental_mcast_socket_,
      snapshot_mcast_socket_;
    bool in_recovery_ = false;
    const std::string iface_, snapshot_ip_;
    const int snapshot_port_;
    typedef std::map&lt;size_t, Exchange::MEMarketUpdate&gt;
      QueuedMarketUpdates;
    QueuedMarketUpdates snapshot_queued_msgs_,
      incremental_queued_msgs_;
};
}</span></pre>
<p><span class="koboSpan" id="kobo.173.1">We will initialize </span><a id="_idIndexMarker1128"/><span class="koboSpan" id="kobo.174.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.176.1"> class and these data members in the </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">next section.</span></span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.178.1">Initializing the market data consumer</span></h2>
<p><span class="koboSpan" id="kobo.179.1">The constructor </span><a id="_idIndexMarker1129"/><span class="koboSpan" id="kobo.180.1">for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.182.1"> class accepts the </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">following arguments:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.184.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">client_id</span></strong><span class="koboSpan" id="kobo.186.1"> argument of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">Common::ClientId</span></strong><span class="koboSpan" id="kobo.188.1"> type, which in this case is used purely to create a unique log filename to be used to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Logger logger_</span></strong><span class="koboSpan" id="kobo.190.1"> component in </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">this class.</span></span></li>
<li><span class="koboSpan" id="kobo.192.1">It also expects a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.194.1"> lock-free queue object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">market_updates</span></strong><span class="koboSpan" id="kobo.196.1">, where it will publish decoded and in-order </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">market updates.</span></span></li>
<li><span class="koboSpan" id="kobo.198.1">It expects the network interface name in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">iface</span></strong><span class="koboSpan" id="kobo.200.1"> argument and the addresses of the snapshot and incremental market data streams. </span><span class="koboSpan" id="kobo.200.2">These will be passed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">snapshot_ip</span></strong><span class="koboSpan" id="kobo.202.1"> argument, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">snapshot_port</span></strong><span class="koboSpan" id="kobo.204.1"> argument, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">incremental_ip</span></strong><span class="koboSpan" id="kobo.206.1"> argument, and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">incremental_port</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.208.1"> argument:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
#include "market_data_consumer.h"
namespace Trading {
  MarketDataConsumer::MarketDataConsumer(Common::ClientId
    client_id, Exchange::MEMarketUpdateLFQueue
      *market_updates,
const std::string &amp;iface,
const std::string &amp;snapshot_ip, int snapshot_port,
const std::string &amp;incremental_ip, int incremental_port)
      : incoming_md_updates_(market_updates), run_(false),
        logger_("trading_market_data_consumer_" + std::
          to_string(client_id) + ".log"),
        incremental_mcast_socket_(logger_),
          snapshot_mcast_socket_(logger_),
        iface_(iface), snapshot_ip_(snapshot_ip),
          snapshot_port_(snapshot_port) {</span></pre>
<p><span class="koboSpan" id="kobo.210.1">The constructor performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">following tasks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.212.1">As we mentioned, the constructor creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Logger</span></strong><span class="koboSpan" id="kobo.214.1"> instance for this class and uses that </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">logger_</span></strong><span class="koboSpan" id="kobo.216.1"> object to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">incremental_mcast_socket_</span></strong><span class="koboSpan" id="kobo.218.1"> variable and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">snapshot_mcast_socket_</span></strong><span class="koboSpan" id="kobo.220.1"> variable. </span><span class="koboSpan" id="kobo.220.2">It also initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">iface_</span></strong><span class="koboSpan" id="kobo.222.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">snapshot_ip_</span></strong><span class="koboSpan" id="kobo.224.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">snapshot_port_</span></strong><span class="koboSpan" id="kobo.226.1"> members from the arguments passed </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">to it.</span></span></li>
<li><span class="koboSpan" id="kobo.228.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">recv_callback()</span></strong><span class="koboSpan" id="kobo.230.1"> lambda method, it initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">recv_callback_</span></strong><span class="koboSpan" id="kobo.232.1"> variable in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">incremental_mcast_socket_</span></strong><span class="koboSpan" id="kobo.234.1"> variable and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">snapshot_mcast_socket_</span></strong><span class="koboSpan" id="kobo.236.1"> variable. </span><span class="koboSpan" id="kobo.236.2">The lambda just forwards the </span><a id="_idIndexMarker1130"/><span class="koboSpan" id="kobo.237.1">callbacks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">recvCallback()</span></strong><span class="koboSpan" id="kobo.239.1"> member method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.241.1"> class, which we will see later. </span><span class="koboSpan" id="kobo.241.2">The key point here is that we expect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">MarketDataConsumer::recvCallback()</span></strong><span class="koboSpan" id="kobo.243.1"> method to be called when there is data available on the incremental or the snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">multicast sockets.</span></span></li>
<li><span class="koboSpan" id="kobo.245.1">The last thing the constructor does is fully initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">incremental_mcast_socket_</span></strong><span class="koboSpan" id="kobo.247.1"> by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">McastSocket::init()</span></strong><span class="koboSpan" id="kobo.249.1"> method, which creates the actual socket internally. </span><span class="koboSpan" id="kobo.249.2">It also calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">McastSocket::join()</span></strong><span class="koboSpan" id="kobo.251.1"> method to subscribe to the multicast stream for this socket. </span><span class="koboSpan" id="kobo.251.2">Note that we do not do the same for </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">snapshot_mcast_socket_</span></strong><span class="koboSpan" id="kobo.253.1"> yet. </span><span class="koboSpan" id="kobo.253.2">That is done on demand as packet drops or sequence gaps </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">are detected:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
    auto recv_callback = [this](auto socket) {
      recvCallback(socket);
    };
    incremental_mcast_socket_.recv_callback_ =
      recv_callback;
    ASSERT(incremental_mcast_socket_.init(incremental_ip,
      iface, incremental_port, /*is_listening*/ true) &gt;= 0,
           "Unable to create incremental mcast socket.
</span><span class="koboSpan" id="kobo.255.2">             error:" + std::string(std::strerror(errno)));
    ASSERT(incremental_mcast_socket_.join(incremental_ip,
      iface, incremental_port),
           "Join failed on:" + std::to_string
              (incremental_mcast_socket_.fd_) + " error:" +
                 std::string(std::strerror(errno)));
    snapshot_mcast_socket_.recv_callback_ = recv_callback;
  }</span></pre>
<p><span class="koboSpan" id="kobo.256.1">We add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">start()</span></strong><span class="koboSpan" id="kobo.258.1"> method like what we have seen for our other components on the side of the trading </span><a id="_idIndexMarker1131"/><span class="koboSpan" id="kobo.259.1">exchange. </span><span class="koboSpan" id="kobo.259.2">This sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">run_</span></strong><span class="koboSpan" id="kobo.261.1"> variable to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">true</span></strong><span class="koboSpan" id="kobo.263.1"> and creates and launches a thread to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">MarketDataConsumer::run()</span></strong><span class="koboSpan" id="kobo.265.1"> method, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">build later:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
    auto start() {
      run_ = true;
      ASSERT(Common::createAndStartThread(-1,
        "Trading/MarketDataConsumer", [this]() { run(); })
          != nullptr, "Failed to start MarketData
             thread.");
    }</span></pre>
<p><span class="koboSpan" id="kobo.268.1">The destructor for this class is straightforward and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">stop()</span></strong><span class="koboSpan" id="kobo.270.1"> method, which simply sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">run_</span></strong><span class="koboSpan" id="kobo.272.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">false</span></strong><span class="koboSpan" id="kobo.274.1"> to end the execution of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">run()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.276.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
    ~MarketDataConsumer() {
      stop();
      using namespace std::literals::chrono_literals;
      std::this_thread::sleep_for(5s);
    }
    auto stop() -&gt; void {
      run_ = false;
    }</span></pre>
<p><span class="koboSpan" id="kobo.278.1">Now that we have initialized </span><a id="_idIndexMarker1132"/><span class="koboSpan" id="kobo.279.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.281.1"> class, we will first look at the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">run()</span></strong><span class="koboSpan" id="kobo.283.1"> loop, which executes a loop of consuming multicast traffic from </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">the exchange.</span></span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.285.1">Running the market data consumer main loop</span></h2>
<p><span class="koboSpan" id="kobo.286.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">run()</span></strong><span class="koboSpan" id="kobo.288.1"> method is </span><a id="_idIndexMarker1133"/><span class="koboSpan" id="kobo.289.1">simple for our market data consumer component. </span><span class="koboSpan" id="kobo.289.2">It simply calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">sendAndRecv()</span></strong><span class="koboSpan" id="kobo.291.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">incremental_mcast_socket_</span></strong><span class="koboSpan" id="kobo.293.1"> socket and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">snapshot_mcast_socket_</span></strong><span class="koboSpan" id="kobo.295.1"> object, which in our case, consumes any additional data received on the incremental or snapshot channels and dispatches </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">the callbacks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.297.1">
  auto MarketDataConsumer::run() noexcept -&gt; void {
    logger_.log("%:% %() %\n", __FILE__, __LINE__,
      __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_));
    while (run_) {
      incremental_mcast_socket_.sendAndRecv();
      snapshot_mcast_socket_.sendAndRecv();
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.298.1">The next section deals </span><a id="_idIndexMarker1134"/><span class="koboSpan" id="kobo.299.1">with the data available on the network sockets within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">recvCallback()</span></strong><span class="koboSpan" id="kobo.301.1"> method that get dispatched from the </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">previous logic.</span></span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.303.1">Processing market data updates and handling packet drops</span></h2>
<p><span class="koboSpan" id="kobo.304.1">This section implements important functionality responsible for processing market data updates received </span><a id="_idIndexMarker1135"/><span class="koboSpan" id="kobo.305.1">on the incremental and the snapshot </span><a id="_idIndexMarker1136"/><span class="koboSpan" id="kobo.306.1">streams. </span><span class="koboSpan" id="kobo.306.2">Market updates on the incremental stream are received during the entire runtime of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.308.1"> component. </span><span class="koboSpan" id="kobo.308.2">However, data is received and processed from the snapshot stream only when a sequence number gap is detected on the incremental stream, which causes </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.310.1"> to initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">snapshot_mcast_socket_</span></strong><span class="koboSpan" id="kobo.312.1"> and subscribe to the snapshot multicast stream. </span><span class="koboSpan" id="kobo.312.2">Remember that in the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.314.1">, we intentionally did not fully initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">snapshot_mcast_socket_</span></strong><span class="koboSpan" id="kobo.316.1"> as we did with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">incremental_mcast_socket_</span></strong><span class="koboSpan" id="kobo.318.1">. </span><span class="koboSpan" id="kobo.318.2">The important thing to understand here is that data on the snapshot socket is only received when we are in recovery mode and </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">not otherwise.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">The first code block in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">recvCallback()</span></strong><span class="koboSpan" id="kobo.322.1"> method determines if the data we are processing came from the incremental or snapshot stream by comparing the file descriptor of the socket on which it was received. </span><span class="koboSpan" id="kobo.322.2">In the extremely unlikely edge case that we received </span><a id="_idIndexMarker1137"/><span class="koboSpan" id="kobo.323.1">data on the snapshot socket but we are not in </span><a id="_idIndexMarker1138"/><span class="koboSpan" id="kobo.324.1">recovery, we simply log a warning, reset the socket receive buffer index, </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">and return:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
  auto MarketDataConsumer::recvCallback(McastSocket
    *socket) noexcept -&gt; void {
    const auto is_snapshot = (socket-&gt;fd_ ==
      snapshot_mcast_socket_.fd_);
    if (UNLIKELY(is_snapshot &amp;&amp; !in_recovery_)) {
      socket-&gt;next_rcv_valid_index_ = 0;
      logger_.log("%:% %() % WARN Not expecting snapshot
        messages.\n",
                  __FILE__, __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_));
      return;
    }</span></pre>
<p><span class="koboSpan" id="kobo.327.1">Otherwise, we proceed further and read </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Exchange::MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.329.1"> messages from the socket buffer using the same code that we have seen before. </span><span class="koboSpan" id="kobo.329.2">We go through the data contained in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">socket-&gt;rcv_buffer_</span></strong><span class="koboSpan" id="kobo.331.1"> buffer and read it in chunks of size equal to the size of </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">Exchange::MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.333.1">. </span><span class="koboSpan" id="kobo.333.2">The goal here is to read as many full </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.335.1"> messages as possible until we have read them all from the buffer. </span><span class="koboSpan" id="kobo.335.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.337.1"> to convert the data in the buffer to an object of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Exchange::MDPMarketUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.340.1">
    if (socket-&gt;next_rcv_valid_index_ &gt;= sizeof
      (Exchange::MDPMarketUpdate)) {
      size_t i = 0;
      for (; i + sizeof(Exchange::MDPMarketUpdate) &lt;=
        socket-&gt;next_rcv_valid_index_; i +=
          sizeof(Exchange::MDPMarketUpdate)) {
        auto request = reinterpret_cast&lt;const
          Exchange::MDPMarketUpdate *&gt;(socket-&gt;rcv_buffer_
            + i);
        logger_.log("%:% %() % Received % socket len:%
          %\n", __FILE__, __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_),
                    (is_snapshot ? </span><span class="koboSpan" id="kobo.340.2">"snapshot" :
                       "incremental"), sizeof
                         (Exchange::MDPMarketUpdate),
                           request-&gt;toString());</span></pre>
<p><span class="koboSpan" id="kobo.341.1">For each </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.343.1"> message, we check the sequence number on the message we just read to </span><a id="_idIndexMarker1139"/><span class="koboSpan" id="kobo.344.1">see if there is a sequence number gap or </span><a id="_idIndexMarker1140"/><span class="koboSpan" id="kobo.345.1">not. </span><span class="koboSpan" id="kobo.345.2">We set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">in_recovery_</span></strong><span class="koboSpan" id="kobo.347.1"> member flag to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">true</span></strong><span class="koboSpan" id="kobo.349.1"> if we detect a sequence number gap or if we were already </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">in recovery:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
        const bool already_in_recovery = in_recovery_;
        in_recovery_ = (already_in_recovery || request-&gt;
          seq_num_ != next_exp_inc_seq_num_);</span></pre>
<p><span class="koboSpan" id="kobo.352.1">First, we will see the handling of the message if we are in recovery mode. </span><span class="koboSpan" id="kobo.352.2">In the next code block, we first check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">already_in_recovery_</span></strong><span class="koboSpan" id="kobo.354.1"> flag to see if we were previously not in recovery and just started recovery due to this message or not. </span><span class="koboSpan" id="kobo.354.2">If we were previously not in recovery and started recovery because we saw a sequence number gap, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">startSnapshotSync()</span></strong><span class="koboSpan" id="kobo.356.1"> method, which we will see shortly. </span><span class="koboSpan" id="kobo.356.2">Just to provide a brief introduction here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">startSnapshotSync()</span></strong><span class="koboSpan" id="kobo.358.1"> method will initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">snapshot_mcast_socket_</span></strong><span class="koboSpan" id="kobo.360.1"> object and subscribe to the snapshot multicast stream, but more on that later. </span><span class="koboSpan" id="kobo.360.2">When in recovery, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">queueMessage()</span></strong><span class="koboSpan" id="kobo.362.1"> method to store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.364.1"> message we just received. </span><span class="koboSpan" id="kobo.364.2">We stay in recovery mode and queue up market data updates on both the snapshot and incremental streams. </span><span class="koboSpan" id="kobo.364.3">We will do this until we have a complete snapshot of the book from </span><a id="_idIndexMarker1141"/><span class="koboSpan" id="kobo.365.1">the snapshot stream and all the incremental messages </span><a id="_idIndexMarker1142"/><span class="koboSpan" id="kobo.366.1">after the snapshot message to catch up with the incremental stream. </span><span class="koboSpan" id="kobo.366.2">We will cover more details on that shortly when we present the actual implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">checkSnapshotSync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.368.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.369.1">
        if (UNLIKELY(in_recovery_)) {
          if (UNLIKELY(!already_in_recovery)) {
            logger_.log("%:% %() % Packet drops on %
              socket. </span><span class="koboSpan" id="kobo.369.2">SeqNum expected:% received:%\n",
                __FILE__, __LINE__, __FUNCTION__,
                        Common::getCurrentTimeStr
                          (&amp;time_str_), (is_snapshot ?
</span><span class="koboSpan" id="kobo.369.3">                            "snapshot" : "incremental"),
                              next_exp_inc_seq_num_,
                                 request-&gt;seq_num_);
            startSnapshotSync();
          }
          queueMessage(is_snapshot, request);
        }</span></pre>
<p><span class="koboSpan" id="kobo.370.1">For the branch where we are not in recovery and the message we received is from the incremental market data stream, we simply update </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">next_exp_inc_seq_num_</span></strong><span class="koboSpan" id="kobo.372.1">. </span><span class="koboSpan" id="kobo.372.2">This a reminder that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">next_exp_inc_seq_num_</span></strong><span class="koboSpan" id="kobo.374.1"> variable tracks the next sequence number we expect </span><a id="_idIndexMarker1143"/><span class="koboSpan" id="kobo.375.1">on the next incremental market data update. </span><span class="koboSpan" id="kobo.375.2">We then </span><a id="_idIndexMarker1144"/><span class="koboSpan" id="kobo.376.1">write the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.378.1"> message to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">incoming_md_updates_</span></strong><span class="koboSpan" id="kobo.380.1"> lock-free queue, which will be consumed by the trading engine component on the </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">other end:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
          else if (!is_snapshot) {
          logger_.log("%:% %() % %\n", __FILE__, __LINE__,
            __FUNCTION__,
                      Common::getCurrentTimeStr
                        (&amp;time_str_), request-&gt;toString());
          ++next_exp_inc_seq_num_;
          auto next_write = incoming_md_updates_-&gt;
            getNextToWriteTo();
          *next_write = std::move(request-&gt;
            me_market_update_);
          incoming_md_updates_-&gt;updateWriteIndex();
        }
      }</span></pre>
<p><span class="koboSpan" id="kobo.383.1">Finally, we shift the remaining partial data left in the socket’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">rcv_buffer_</span></strong><span class="koboSpan" id="kobo.385.1"> buffer and update the next valid receive index for the </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">next read:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.387.1">
      memcpy(socket-&gt;rcv_buffer_, socket-&gt;rcv_buffer_ + i,
        socket-&gt;next_rcv_valid_index_ - i);
      socket-&gt;next_rcv_valid_index_ -= i;
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.388.1">That concludes the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">recvCallback()</span></strong><span class="koboSpan" id="kobo.390.1"> method and we will now look at the methods that handle snapshot subscription and synchronization logic. </span><span class="koboSpan" id="kobo.390.2">First, we investigate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">startSnapshotSync()</span></strong><span class="koboSpan" id="kobo.392.1"> method, which, as we mentioned before, prepares the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.394.1"> class to start the snapshot synchronization mechanism on sequence number gaps. </span><span class="koboSpan" id="kobo.394.2">The first thing we do for this task is clear the two </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">std::map</span></strong><span class="koboSpan" id="kobo.396.1"> containers – </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">snapshot_queued_msgs_</span></strong><span class="koboSpan" id="kobo.398.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">incremental_queued_msgs_</span></strong><span class="koboSpan" id="kobo.400.1">, which we use to queue upmarket update messages from the snapshot and incremental streams. </span><span class="koboSpan" id="kobo.400.2">Then we initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">snapshot_mcast_socket_</span></strong><span class="koboSpan" id="kobo.402.1"> object using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">McastSocket::init()</span></strong><span class="koboSpan" id="kobo.404.1"> method so that the socket gets created for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">snapshot_ip_</span></strong><span class="koboSpan" id="kobo.406.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">snapshot_port_</span></strong><span class="koboSpan" id="kobo.408.1"> address. </span><span class="koboSpan" id="kobo.408.2">Then we </span><a id="_idIndexMarker1145"/><span class="koboSpan" id="kobo.409.1">call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">McastSocket::join()</span></strong><span class="koboSpan" id="kobo.411.1"> method to start the multicast subscription for the snapshot market data stream. </span><span class="koboSpan" id="kobo.411.2">Remember </span><a id="_idIndexMarker1146"/><span class="koboSpan" id="kobo.412.1">that for multicast sockets, we need to make sure that not only do we have a socket that is reading market data, but we also have to issue the IGMP join membership network-level message so that messages can flow to the application, which is achieved by the call </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">snapshot_mcast_socket_.join()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
  auto MarketDataConsumer::startSnapshotSync() -&gt; void {
    snapshot_queued_msgs_.clear();
    incremental_queued_msgs_.clear();
    ASSERT(snapshot_mcast_socket_.init(snapshot_ip_,
      iface_, snapshot_port_, /*is_listening*/ true) &gt;= 0,
           "Unable to create snapshot mcast socket. </span><span class="koboSpan" id="kobo.416.2">error:"
              + std::string(std::strerror(errno)));
    ASSERT(snapshot_mcast_socket_.join(snapshot_ip_,
      iface_, snapshot_port_),
           "Join failed on:" + std::to_string
             (snapshot_mcast_socket_.fd_) + " error:" +
               std::string(std::strerror(errno)));
  }</span></pre>
<p><span class="koboSpan" id="kobo.417.1">The next section </span><a id="_idIndexMarker1147"/><span class="koboSpan" id="kobo.418.1">handles a very important responsibility </span><a id="_idIndexMarker1148"/><span class="koboSpan" id="kobo.419.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.421.1"> component, which is queueing up market data updates from the snapshot and incremental stream and synchronizing </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">when needed.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.423.1">Synchronizing with the snapshot stream</span></h2>
<p><span class="koboSpan" id="kobo.424.1">The first method </span><a id="_idIndexMarker1149"/><span class="koboSpan" id="kobo.425.1">we need to implement is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">MarketDataConsumer::queueMessage()</span></strong><span class="koboSpan" id="kobo.427.1"> method, which we invoked earlier. </span><span class="koboSpan" id="kobo.427.2">This method receives an </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.429.1"> message and a flag that captures whether it was received from the snapshot stream or the </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">incremental stream.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">If the message came over the incremental market data stream, then it adds it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">incremental_queued_msgs_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.433.1">std::map</span></strong><span class="koboSpan" id="kobo.434.1">. </span><span class="koboSpan" id="kobo.434.2">If it is received over the snapshot stream, then first, it checks to see if a market update for that sequence number already exists in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">snapshot_queued_msgs_</span></strong><span class="koboSpan" id="kobo.436.1"> container. </span><span class="koboSpan" id="kobo.436.2">If the entry for that sequence number already exists in the container, then that means that we are receiving a new snapshot messages cycle and we were not able to successfully recover from the previous snapshot messages cycle. </span><span class="koboSpan" id="kobo.436.3">In this case, it clears the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">snapshot_queued_msgs_</span></strong><span class="koboSpan" id="kobo.438.1"> container since we will have to restart the snapshot recovery process from </span><a id="_idIndexMarker1150"/><span class="koboSpan" id="kobo.439.1">the beginning. </span><span class="koboSpan" id="kobo.439.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.441.1"> message is added to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">snapshot_queued_msgs_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.443.1"> container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
auto MarketDataConsumer::queueMessage(bool is_snapshot,
                                        const Exchange::
                                          MDPMarketUpdate
                                            *request) {
    if (is_snapshot) {
      if (snapshot_queued_msgs_.find(request-&gt;seq_num_) !=
        snapshot_queued_msgs_.end()) {
        logger_.log("%:% %() % Packet drops on snapshot
          socket. </span><span class="koboSpan" id="kobo.444.2">Received for a 2nd time:%\n", __FILE__,
            __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_),
                      request-&gt;toString());
        snapshot_queued_msgs_.clear();
      }
      snapshot_queued_msgs_[request-&gt;seq_num_] = request-&gt;
        me_market_update_;
    } else {
      incremental_queued_msgs_[request-&gt;seq_num_] =
        request-&gt;me_market_update_;
    }</span></pre>
<p><span class="koboSpan" id="kobo.445.1">After the new message is queued in the correct container, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">checkSnapshotSync()</span></strong><span class="koboSpan" id="kobo.447.1"> method to see if we can successfully recover from the snapshot and the incremental messages we have queued up </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">so far:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.449.1">
    logger_.log("%:% %() % size snapshot:% incremental:% %
      =&gt; %\n", __FILE__, __LINE__, __FUNCTION__,
                Common::getCurrentTimeStr(&amp;time_str_),
                  snapshot_queued_msgs_.size(),
                    incremental_queued_msgs_.size(),
                      request-&gt;seq_num_, request-&gt;
                        toString());
    checkSnapshotSync();
}</span></pre>
<p><span class="koboSpan" id="kobo.450.1">Now, we will implement </span><a id="_idIndexMarker1151"/><span class="koboSpan" id="kobo.451.1">the last and most important method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.453.1"> class – </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">checkSnapshotSync()</span></strong><span class="koboSpan" id="kobo.455.1">, which inspects the queued </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.457.1"> messages in the snapshot and incremental containers to see if we can successfully recover or synchronize with the snapshot and incremental streams and </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.458.1">catch up</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.460.1">The logic is to queue up messages received on the snapshot and incremental market </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">data streams.</span></span></li>
<li><span class="koboSpan" id="kobo.462.1">Then, when we receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">MarketUpdateType::SNAPSHOT_END</span></strong><span class="koboSpan" id="kobo.464.1">, we make sure that no messages were dropped on the snapshot market data stream by checking that there is no gap in the sequence number field on the </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">snapshot messages.</span></span></li>
<li><span class="koboSpan" id="kobo.466.1">Then, we inspect the queued market updates from the incremental data stream and check to see if we have messages following the last message that was used to synthesize this round of snapshot messages. </span><span class="koboSpan" id="kobo.466.2">We do this by checking if we have market </span><a id="_idIndexMarker1152"/><span class="koboSpan" id="kobo.467.1">updates in the incremental queue starting with a sequence number equal to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">OrderId + 1</span></strong><span class="koboSpan" id="kobo.469.1"> value from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">SNAPSHOT_END</span></strong><span class="koboSpan" id="kobo.471.1"> message in the </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">snapshot queue.</span></span></li>
<li><span class="koboSpan" id="kobo.473.1">Finally, we check to make sure that from that point on in the incremental queued messages, we do not have </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">another gap.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.475.1">To better understand how the snapshot recovery logic works, we present </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.476.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.477.1">.2</span></em><span class="koboSpan" id="kobo.478.1">, a concrete example of when recovery </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">is possible:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.480.1"><img alt="Figure 8.2 – Example state of snapshot and incremental queues when recovery is possible" src="image/B19434_08_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.481.1">Figure 8.2 – Example state of snapshot and incremental queues when recovery is possible</span></p>
<p><span class="koboSpan" id="kobo.482.1">Applying the logic we just presented in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.483.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.484.1">.2</span></em><span class="koboSpan" id="kobo.485.1">, we first check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">snapshot_queued_msgs_</span></strong><span class="koboSpan" id="kobo.487.1"> container to make sure we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">SNAPSHOT_START</span></strong><span class="koboSpan" id="kobo.489.1"> message and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">SNAPSHOT_END</span></strong><span class="koboSpan" id="kobo.491.1"> message. </span><span class="koboSpan" id="kobo.491.2">We also make sure that we do not have any gaps in the snapshot messages by checking the sequence numbers, which start from zero and increment by </span><a id="_idIndexMarker1153"/><span class="koboSpan" id="kobo.492.1">one for each message. </span><span class="koboSpan" id="kobo.492.2">We find the last sequence number, which was used to synthesize this snapshot from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">SNAPSHOT_END</span></strong><span class="koboSpan" id="kobo.494.1"> message and use the order ID field in that message, which in this case, is set </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.496.1">776</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.498.1">Once we determine that we have a complete sequence of snapshot messages, we check the queue of incremental market data updates. </span><span class="koboSpan" id="kobo.498.2">All queued-up incremental messages with a sequence number less than or equal to </span><strong class="bold"><span class="koboSpan" id="kobo.499.1">776</span></strong><span class="koboSpan" id="kobo.500.1"> will be discarded since the snapshot messages incorporate that information. </span><span class="koboSpan" id="kobo.500.2">Then we process/apply all the queued-up incremental updates starting with sequence number </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">777</span></strong><span class="koboSpan" id="kobo.502.1"> and making sure that we do not have a gap in the incremental queued-up messages. </span><span class="koboSpan" id="kobo.502.2">We achieve that by checking the sequence number field on those messages and making sure there is no gap in it. </span><span class="koboSpan" id="kobo.502.3">Once we have processed all the queued-up incremental market data updates, we are done. </span><span class="koboSpan" id="kobo.502.4">At this point, we have finished the recovery/synchronization process and are </span><em class="italic"><span class="koboSpan" id="kobo.503.1">caught up</span></em><span class="koboSpan" id="kobo.504.1">. </span><span class="koboSpan" id="kobo.504.2">Now that we understand how the logic is supposed to work, let us look at the C++ implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">checkSnapshotSync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.506.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">First, we check if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">snapshot_queued_msgs_</span></strong><span class="koboSpan" id="kobo.509.1"> container is empty. </span><span class="koboSpan" id="kobo.509.2">Obviously, we cannot recover since </span><a id="_idIndexMarker1154"/><span class="koboSpan" id="kobo.510.1">we need a full snapshot messages cycle and all the incremental messages from that point on to catch up with the </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">incremental stream:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.512.1">
  auto MarketDataConsumer::checkSnapshotSync() -&gt; void {
    if (snapshot_queued_msgs_.empty()) {
      return;
    }</span></pre>
<p><span class="koboSpan" id="kobo.513.1">The next thing we need to check is if we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.515.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">MarketUpdateType::SNAPSHOT_START</span></strong><span class="koboSpan" id="kobo.517.1"> type. </span><span class="koboSpan" id="kobo.517.2">Otherwise, we clear the queue and wait for the next round of </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">snapshot messages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.519.1">
    const auto &amp;first_snapshot_msg =
      snapshot_queued_msgs_.begin()-&gt;second;
    if (first_snapshot_msg.type_ != Exchange::
      MarketUpdateType::SNAPSHOT_START) {
      logger_.log("%:% %() % Returning because have not
        seen a SNAPSHOT_START yet.\n",
                  __FILE__, __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_));
      snapshot_queued_msgs_.clear();
      return;
    }</span></pre>
<p><span class="koboSpan" id="kobo.520.1">Next, we will iterate through the queued snapshot messages and make sure that there is no gap in the snapshot messages we queued up by checking the sequence numbers. </span><span class="koboSpan" id="kobo.520.2">Remember that the key in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">snapshot_queued_msgs_</span></strong><span class="koboSpan" id="kobo.522.1"> container is actually the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">seq_num_</span></strong><span class="koboSpan" id="kobo.524.1"> field from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.526.1"> messages. </span><span class="koboSpan" id="kobo.526.2">If we detect a gap in the snapshot messages, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">have_complete_snapshot</span></strong><span class="koboSpan" id="kobo.528.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">false</span></strong><span class="koboSpan" id="kobo.530.1"> and exit out of the loop. </span><span class="koboSpan" id="kobo.530.2">We </span><a id="_idIndexMarker1155"/><span class="koboSpan" id="kobo.531.1">collect each message from the snapshot queue into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">final_events</span></strong><span class="koboSpan" id="kobo.533.1"> container of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">std::vector</span></strong><span class="koboSpan" id="kobo.535.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.537.1"> messages, which will be the container of all the events we will process if we successfully recover from </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">this snapshot:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.539.1">
    std::vector&lt;Exchange::MEMarketUpdate&gt; final_events;
    auto have_complete_snapshot = true;
    size_t next_snapshot_seq = 0;
    for (auto &amp;snapshot_itr: snapshot_queued_msgs_) {
      logger_.log("%:% %() % % =&gt; %\n", __FILE__, __LINE__,
        __FUNCTION__,
                  Common::getCurrentTimeStr(&amp;time_str_),
                     snapshot_itr.first,
                       snapshot_itr.second.toString());
      if (snapshot_itr.first != next_snapshot_seq) {
        have_complete_snapshot = false;
        logger_.log("%:% %() % Detected gap in snapshot
          stream expected:% found:% %.\n", __FILE__,
            __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_),
                       next_snapshot_seq,
                          snapshot_itr.first, snapshot_itr.
</span><span class="koboSpan" id="kobo.539.2">                             second.toString());
        break;
      }
      if (snapshot_itr.second.type_ !=
         Exchange::MarketUpdateType::SNAPSHOT_START &amp;&amp;
          snapshot_itr.second.type_ !=
            Exchange::MarketUpdateType::SNAPSHOT_END)
        final_events.push_back(snapshot_itr.second);
      ++next_snapshot_seq;
    }</span></pre>
<p><span class="koboSpan" id="kobo.540.1">Once we finish the loop, we check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">have_complete_snapshot</span></strong><span class="koboSpan" id="kobo.542.1"> flag to see if we found a gap in the </span><a id="_idIndexMarker1156"/><span class="koboSpan" id="kobo.543.1">snapshot messages or not. </span><span class="koboSpan" id="kobo.543.2">If the flag is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">false</span></strong><span class="koboSpan" id="kobo.545.1">, meaning we found a gap, we clear the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">snapshot_queued_msgs_</span></strong><span class="koboSpan" id="kobo.547.1"> container and return, since we cannot recover and must wait for the next round of </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">snapshot messages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.549.1">
    if (!have_complete_snapshot) {
      logger_.log("%:% %() % Returning because found gaps
        in snapshot stream.\n",
                  __FILE__, __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_));
      snapshot_queued_msgs_.clear();
      return;
    }</span></pre>
<p><span class="koboSpan" id="kobo.550.1">Assuming we made it this far, we extract the last message in the queue of snapshot messages and make sure that it is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">MarketUpdateType::SNAPSHOT_END</span></strong><span class="koboSpan" id="kobo.552.1"> type since we will </span><a id="_idIndexMarker1157"/><span class="koboSpan" id="kobo.553.1">need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">order_id_</span></strong><span class="koboSpan" id="kobo.555.1"> field in this message to process the incremental queue </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">of messages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
    const auto &amp;last_snapshot_msg = snapshot_queued_msgs_
      .rbegin()-&gt;second;
    if (last_snapshot_msg.type_ != Exchange::
      MarketUpdateType::SNAPSHOT_END) {
      logger_.log("%:% %() % Returning because have not
        seen a SNAPSHOT_END yet.\n",
                  __FILE__, __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_));
      return;
    }</span></pre>
<p><span class="koboSpan" id="kobo.558.1">Now, we move on to inspecting the queued incremental messages to see if we can synchronize successfully. </span><span class="koboSpan" id="kobo.558.2">We define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">have_complete_incremental</span></strong><span class="koboSpan" id="kobo.560.1"> boolean flag, which will represent if we have all the messages from the incremental stream without any gaps. </span><span class="koboSpan" id="kobo.560.2">We also set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">next_exp_inc_seq_num_</span></strong><span class="koboSpan" id="kobo.562.1"> member variable to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">last_snapshot_msg.order_id_ + 1</span></strong><span class="koboSpan" id="kobo.564.1"> from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">SNAPSHOT_END</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.566.1"> message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.567.1">
    auto have_complete_incremental = true;
    size_t num_incrementals = 0;
    next_exp_inc_seq_num_ = last_snapshot_msg.order_id_ + 1;</span></pre>
<p><span class="koboSpan" id="kobo.568.1">Now we iterate through all the messages in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">incremental_queued_msgs_</span></strong><span class="koboSpan" id="kobo.570.1"> container. </span><span class="koboSpan" id="kobo.570.2">We discard the messages that have sequence numbers less than the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">next_exp_inc_seq_num_</span></strong><span class="koboSpan" id="kobo.572.1"> variable we just assigned. </span><span class="koboSpan" id="kobo.572.2">Otherwise, we make sure that there are no gaps in the </span><a id="_idIndexMarker1158"/><span class="koboSpan" id="kobo.573.1">queue of incremental messages by making sure that the sequence number on the next message is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">next_exp_inc_seq_num_</span></strong><span class="koboSpan" id="kobo.575.1"> and setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">have_complete_incremental</span></strong><span class="koboSpan" id="kobo.577.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">false</span></strong><span class="koboSpan" id="kobo.579.1"> if we detect </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">a gap:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
    for (auto inc_itr = incremental_queued_msgs_.begin();
      inc_itr != incremental_queued_msgs_.end(); ++inc_itr) {
      logger_.log("%:% %() % Checking next_exp:% vs. </span><span class="koboSpan" id="kobo.581.2">seq:%
        %.\n", __FILE__, __LINE__, __FUNCTION__,
                  Common::getCurrentTimeStr(&amp;time_str_),
                    next_exp_inc_seq_num_, inc_itr-&gt;first,
                      inc_itr-&gt;second.toString());
      if (inc_itr-&gt;first &lt; next_exp_inc_seq_num_)
        continue;
      if (inc_itr-&gt;first != next_exp_inc_seq_num_) {
        logger_.log("%:% %() % Detected gap in incremental
          stream expected:% found:% %.\n", __FILE__,
            __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_),
                      next_exp_inc_seq_num_, inc_itr-&gt;
                        first, inc_itr-&gt;second.toString());
        have_complete_incremental = false;
        break;
      }</span></pre>
<p><span class="koboSpan" id="kobo.582.1">If we do not detect </span><a id="_idIndexMarker1159"/><span class="koboSpan" id="kobo.583.1">a gap in the market update message from the incremental queue, we add it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">final_events</span></strong><span class="koboSpan" id="kobo.585.1"> container as we did before. </span><span class="koboSpan" id="kobo.585.2">We also increment the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">next_exp_inc_seq_num_</span></strong><span class="koboSpan" id="kobo.587.1"> variable, since that is the next sequence number we expect if there are </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">no gaps:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
      logger_.log("%:% %() % % =&gt; %\n", __FILE__, __LINE__,
        __FUNCTION__,
                  Common::getCurrentTimeStr(&amp;time_str_),
                    inc_itr-&gt;first, inc_itr-&gt;second
                       .toString());
      if (inc_itr-&gt;second.type_ != Exchange::
        MarketUpdateType::SNAPSHOT_START &amp;&amp;
          inc_itr-&gt;second.type_ != Exchange::
             MarketUpdateType::SNAPSHOT_END)
        final_events.push_back(inc_itr-&gt;second);
      ++next_exp_inc_seq_num_;
      ++num_incrementals;
    }</span></pre>
<p><span class="koboSpan" id="kobo.590.1">After exiting the loop, we check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">have_complete_incremental</span></strong><span class="koboSpan" id="kobo.592.1"> flag to make sure there was no gap in the queue of incremental updates. </span><span class="koboSpan" id="kobo.592.2">If we did find a gap, we clear the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">snapshot_queued_msgs_</span></strong><span class="koboSpan" id="kobo.594.1"> container and return, since we cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">successfully synchronize:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
    if (!have_complete_incremental) {
      logger_.log("%:% %() % Returning because have gaps in
        queued incrementals.\n",
                  __FILE__, __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_));
      snapshot_queued_msgs_.clear();
      return;
    }</span></pre>
<p><span class="koboSpan" id="kobo.597.1">At this point, we have </span><a id="_idIndexMarker1160"/><span class="koboSpan" id="kobo.598.1">successfully recovered, so we iterate through all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.600.1"> messages in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">final_events</span></strong><span class="koboSpan" id="kobo.602.1"> container and write them to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">incoming_md_updates_</span></strong><span class="koboSpan" id="kobo.604.1"> lock-free queue to be sent to the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">engine component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">
    for (const auto &amp;itr: final_events) {
      auto next_write = incoming_md_updates_-&gt;
        getNextToWriteTo();
      *next_write = itr;
      incoming_md_updates_-&gt;updateWriteIndex();
    }</span></pre>
<p><span class="koboSpan" id="kobo.607.1">Finally, we clear the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">snapshot_queued_msgs_</span></strong><span class="koboSpan" id="kobo.609.1"> container and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">incremental_queued_msgs_</span></strong><span class="koboSpan" id="kobo.611.1"> container and set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">in_recovery_</span></strong><span class="koboSpan" id="kobo.613.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">false</span></strong><span class="koboSpan" id="kobo.615.1"> since we are no longer in recovery mode. </span><span class="koboSpan" id="kobo.615.2">Finally, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">McastSocket::leave()</span></strong><span class="koboSpan" id="kobo.617.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">snapshot_mcast_socket_</span></strong><span class="koboSpan" id="kobo.619.1">, since we no longer need to </span><a id="_idIndexMarker1161"/><span class="koboSpan" id="kobo.620.1">be subscribed to the snapshot stream or receive or process the </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">snapshot messages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.622.1">
    logger_.log("%:% %() % Recovered % snapshot and %
      incremental orders.\n", __FILE__, __LINE__,
         __FUNCTION__,
                Common::getCurrentTimeStr(&amp;time_str_),
                  snapshot_queued_msgs_.size() - 2,
                    num_incrementals);
    snapshot_queued_msgs_.clear();
    incremental_queued_msgs_.clear();
    in_recovery_ = false;
    snapshot_mcast_socket_.leave(snapshot_ip_,
      snapshot_port_);;
  }</span></pre>
<p><span class="koboSpan" id="kobo.623.1">With this method, we have concluded the design and implementation of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.625.1"> component. </span><span class="koboSpan" id="kobo.625.2">Next, we will move on to the topic of constructing the limit order book inside the trading engine from these market data </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">update messages.</span></span></p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.627.1">Building order books from market data</span></h1>
<p><span class="koboSpan" id="kobo.628.1">In the previous section, we built the market data consumer component, which subscribes to </span><a id="_idIndexMarker1162"/><span class="koboSpan" id="kobo.629.1">the market data stream, synchronizes </span><a id="_idIndexMarker1163"/><span class="koboSpan" id="kobo.630.1">between the snapshot and incremental streams, and decodes the market data updates and publishes them to the trading engine component. </span><span class="koboSpan" id="kobo.630.2">The trading engine component then needs to process these market data updates and build a limited order book like the one that the matching engine builds, except this is a much more limited version of the matching engine’s order book. </span><span class="koboSpan" id="kobo.630.3">As a reminder, we discussed this in the chapter </span><em class="italic"><span class="koboSpan" id="kobo.631.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.632.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.633.1">Designing a framework for low latency C++ trading algorithms</span></em><span class="koboSpan" id="kobo.634.1"> section. </span><span class="koboSpan" id="kobo.634.2">One last thing to note is that we will re-use the design and code of the order book in the matching engine to create the order book in the client’s system. </span><span class="koboSpan" id="kobo.634.3">We will re-use the source code we built in the chapter </span><em class="italic"><span class="koboSpan" id="kobo.635.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.636.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.637.1">Building the order book and matching orders</span></em><span class="koboSpan" id="kobo.638.1"> section. </span><span class="koboSpan" id="kobo.638.2">Now, let us get started with the implementation of the order book, which we will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.640.1">, to easily differentiate it from the order book inside the matching engine, which was </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">MEOrderBook</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.644.1">Defining the structures for the market order book</span></h2>
<p><span class="koboSpan" id="kobo.645.1">First, we will define the structures and types that make up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.647.1"> data structure. </span><span class="koboSpan" id="kobo.647.2">We </span><a id="_idIndexMarker1164"/><span class="koboSpan" id="kobo.648.1">use an identical design here as </span><a id="_idIndexMarker1165"/><span class="koboSpan" id="kobo.649.1">we did for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.651.1"> class, and that design is presented in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.652.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.653.1">.3</span></em><span class="koboSpan" id="kobo.654.1">. </span><span class="koboSpan" id="kobo.654.2">We recommend revisiting the design of the order book and the motivation behind the different choices presented in the </span><em class="italic"><span class="koboSpan" id="kobo.655.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.656.1"> chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.657.1">Designing the exchange order </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.658.1">book</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.660.1">Each order is represented in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.662.1"> struct, which is a subset of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">MEOrder</span></strong><span class="koboSpan" id="kobo.664.1"> struct we built for the matching engine. </span><span class="koboSpan" id="kobo.664.2">We will also have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">OrderHashMap</span></strong><span class="koboSpan" id="kobo.666.1"> type, as we did in the matching engine, which will be a hash map from </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">OrderId</span></strong><span class="koboSpan" id="kobo.668.1"> to these </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.670.1"> objects. </span><span class="koboSpan" id="kobo.670.2">Orders at the same price are held in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.672.1"> struct as we did in the matching engine, which will be a doubly linked list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.674.1"> objects. </span><span class="koboSpan" id="kobo.674.2">Remember that we need this structure to maintain all the orders with the same price and side attribute and arrange them in FIFO order. </span><span class="koboSpan" id="kobo.674.3">We will also build an </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">OrdersAtPriceHashMap</span></strong><span class="koboSpan" id="kobo.676.1"> map, as we did in the matching engine </span><a id="_idIndexMarker1166"/><span class="koboSpan" id="kobo.677.1">to be a hash map from </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">Price</span></strong><span class="koboSpan" id="kobo.679.1"> to </span><a id="_idIndexMarker1167"/><span class="koboSpan" id="kobo.680.1">these </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.682.1"> objects. </span><span class="koboSpan" id="kobo.682.2">The design is represented in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.683.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.684.1">.3</span></em><span class="koboSpan" id="kobo.685.1">, which is similar to the diagram we presented for the order book in the matching engine, except with different structures in </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">this case:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.687.1"><img alt="Figure 8.3 – Architecture of the limit order book in the market participant’s trading engine" src="image/B19434_08_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.688.1">Figure 8.3 – Architecture of the limit order book in the market participant’s trading engine</span></p>
<p><span class="koboSpan" id="kobo.689.1">All the source code for the structures and types we define in the next two sub-sections can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">Chapter8/trading/strategy/market_order.h</span></strong><span class="koboSpan" id="kobo.691.1"> source file and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">Chapter8/trading/strategy/market_order.cpp</span></strong><span class="koboSpan" id="kobo.693.1"> source file. </span><span class="koboSpan" id="kobo.693.2">Let us get </span><a id="_idIndexMarker1168"/><span class="koboSpan" id="kobo.694.1">started with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.696.1"> implementation </span><a id="_idIndexMarker1169"/><span class="koboSpan" id="kobo.697.1">by first defining the data structures and types we </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">will need.</span></span></p>
<h3><span class="koboSpan" id="kobo.699.1">Defining the MarketOrder structure and OrderHashMap type</span></h3>
<p><span class="koboSpan" id="kobo.700.1">First, we will define </span><a id="_idIndexMarker1170"/><span class="koboSpan" id="kobo.701.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.703.1"> structure, which </span><a id="_idIndexMarker1171"/><span class="koboSpan" id="kobo.704.1">represents a single order in the market data stream. </span><span class="koboSpan" id="kobo.704.2">This structure contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">OrderId</span></strong><span class="koboSpan" id="kobo.706.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">Side</span></strong><span class="koboSpan" id="kobo.708.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">Price</span></strong><span class="koboSpan" id="kobo.710.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">Qty</span></strong><span class="koboSpan" id="kobo.712.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">Priority</span></strong><span class="koboSpan" id="kobo.714.1"> attributes. </span><span class="koboSpan" id="kobo.714.2">It also contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">prev_order_</span></strong><span class="koboSpan" id="kobo.716.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">next_order_</span></strong><span class="koboSpan" id="kobo.718.1"> member of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.720.1"> pointer since we will chain these objects in a doubly </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">linked list</span></span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.723.1">
#pragma once
#include &lt;array&gt;
#include &lt;sstream&gt;
#include "common/types.h"
using namespace Common;
namespace Trading {
  struct MarketOrder {
    OrderId order_id_ = OrderId_INVALID;
    Side side_ = Side::INVALID;
    Price price_ = Price_INVALID;
    Qty qty_ = Qty_INVALID;
    Priority priority_ = Priority_INVALID;
    MarketOrder *prev_order_ = nullptr;
    MarketOrder *next_order_ = nullptr;</span></pre>
<p><span class="koboSpan" id="kobo.724.1">The constructor </span><a id="_idIndexMarker1172"/><span class="koboSpan" id="kobo.725.1">is straightforward; it simply initializes the </span><a id="_idIndexMarker1173"/><span class="koboSpan" id="kobo.726.1">fields it is provided in </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">the constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.728.1">
    // only needed for use with MemPool.
</span><span class="koboSpan" id="kobo.728.2">    MarketOrder() = default;
    MarketOrder(OrderId order_id, Side side, Price price,
      Qty qty, Priority priority, MarketOrder *prev_order,
        MarketOrder *next_order) noexcept
        : order_id_(order_id), side_(side), price_(price),
           qty_(qty), priority_(priority),
             prev_order_(prev_order),
               next_order_(next_order) {}
    auto toString() const -&gt; std::string;
  };</span></pre>
<p><span class="koboSpan" id="kobo.729.1">We also define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">OrderHashMap</span></strong><span class="koboSpan" id="kobo.731.1"> type, which is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">std::array</span></strong><span class="koboSpan" id="kobo.733.1"> array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.735.1"> pointer objects and of size </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">ME_MAX_ORDER_IDS </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">, in the</span></strong><span class="koboSpan" id="kobo.738.1"> same way as we did in the matching engine </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">order book:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.740.1">
  typedef std::array&lt;MarketOrder *, ME_MAX_ORDER_IDS&gt; OrderHashMap;</span></pre>
<p><span class="koboSpan" id="kobo.741.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">toString()</span></strong><span class="koboSpan" id="kobo.743.1"> method we will use for logging purposes </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">is self-explanatory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.745.1">
  auto MarketOrder::toString() const -&gt; std::string {
    std::stringstream ss;
    ss &lt;&lt; "MarketOrder" &lt;&lt; "["
       &lt;&lt; "oid:" &lt;&lt; orderIdToString(order_id_) &lt;&lt; " "
       &lt;&lt; "side:" &lt;&lt; sideToString(side_) &lt;&lt; " "
       &lt;&lt; "price:" &lt;&lt; priceToString(price_) &lt;&lt; " "
       &lt;&lt; "qty:" &lt;&lt; qtyToString(qty_) &lt;&lt; " "
       &lt;&lt; "prio:" &lt;&lt; priorityToString(priority_) &lt;&lt; " "
       &lt;&lt; "prev:" &lt;&lt; orderIdToString(prev_order_ ?
</span><span class="koboSpan" id="kobo.745.2">           prev_order_-&gt;order_id_ : OrderId_INVALID) &lt;&lt; " "
       &lt;&lt; "next:" &lt;&lt; orderIdToString(next_order_ ?
</span><span class="koboSpan" id="kobo.745.3">         next_order_-&gt;order_id_ : OrderId_INVALID) &lt;&lt; "]";
    return ss.str();
  }</span></pre>
<p><span class="koboSpan" id="kobo.746.1">Next, we will </span><a id="_idIndexMarker1174"/><span class="koboSpan" id="kobo.747.1">define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.749.1"> structure, which </span><a id="_idIndexMarker1175"/><span class="koboSpan" id="kobo.750.1">holds a linked list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">MarketOrder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.752.1"> objects.</span></span></p>
<h3><span class="koboSpan" id="kobo.753.1">Defining the MarketOrdersAtPrice structure and OrdersAtPriceHashMap type</span></h3>
<p><span class="koboSpan" id="kobo.754.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.756.1"> struct is identical to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.758.1"> struct we built </span><a id="_idIndexMarker1176"/><span class="koboSpan" id="kobo.759.1">for the matching </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.761.1"> engine. </span><span class="koboSpan" id="kobo.761.2">It </span><a id="_idIndexMarker1177"/><span class="koboSpan" id="kobo.762.1">contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">Side</span></strong><span class="koboSpan" id="kobo.764.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">Price</span></strong><span class="koboSpan" id="kobo.766.1">, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">MarketOrder</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.768.1">first_mkt_order_</span></strong><span class="koboSpan" id="kobo.769.1"> pointer to represent the beginning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.771.1">-linked list at this price. </span><span class="koboSpan" id="kobo.771.2">It also contains two </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.773.1"> pointers, </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">prev_entry_</span></strong><span class="koboSpan" id="kobo.775.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">next_entry_</span></strong><span class="koboSpan" id="kobo.777.1">, since we will create a doubly linked list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.779.1"> objects to represent the </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">price levels:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.781.1">
  struct MarketOrdersAtPrice {
    Side side_ = Side::INVALID;
    Price price_ = Price_INVALID;
    MarketOrder *first_mkt_order_ = nullptr;
    MarketOrdersAtPrice *prev_entry_ = nullptr;
    MarketOrdersAtPrice *next_entry_ = nullptr;</span></pre>
<p><span class="koboSpan" id="kobo.782.1">The constructors </span><a id="_idIndexMarker1178"/><span class="koboSpan" id="kobo.783.1">for this class are self-explanatory. </span><span class="koboSpan" id="kobo.783.2">It </span><a id="_idIndexMarker1179"/><span class="koboSpan" id="kobo.784.1">simply initializes the data members with the </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">arguments provided:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.786.1">
    MarketOrdersAtPrice() = default;
    MarketOrdersAtPrice(Side side, Price price, MarketOrder
      *first_mkt_order, MarketOrdersAtPrice *prev_entry,
         MarketOrdersAtPrice *next_entry)
        : side_(side), price_(price),
          first_mkt_order_(first_mkt_order),
            prev_entry_(prev_entry),
              next_entry_(next_entry) {}</span></pre>
<p><span class="koboSpan" id="kobo.787.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">toString()</span></strong><span class="koboSpan" id="kobo.789.1"> method is identical to the one in the matching engine, so we will skip repeating </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">it here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.791.1">
    auto toString() const;
  };</span></pre>
<p><span class="koboSpan" id="kobo.792.1">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">OrdersAtPriceHashMap</span></strong><span class="koboSpan" id="kobo.794.1"> is </span><a id="_idIndexMarker1180"/><span class="koboSpan" id="kobo.795.1">identical to the one we built for the matching engine. </span><span class="koboSpan" id="kobo.795.2">It </span><a id="_idIndexMarker1181"/><span class="koboSpan" id="kobo.796.1">represents a hash map from </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">Price</span></strong><span class="koboSpan" id="kobo.798.1"> to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">MarketOrdersAtPrice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.800.1"> pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.801.1">
  typedef std::array&lt;MarketOrdersAtPrice *,
    ME_MAX_PRICE_LEVELS&gt; OrdersAtPriceHashMap;</span></pre>
<p><span class="koboSpan" id="kobo.802.1">Now, we can finally implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.804.1"> class in the next section, but before that, we </span><a id="_idIndexMarker1182"/><span class="koboSpan" id="kobo.805.1">need to define one more structure that will be used by various components to build a view of the </span><strong class="bold"><span class="koboSpan" id="kobo.806.1">Best Bid </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.807.1">Offer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.808.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.809.1">BBO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.811.1">Defining the BBO structure</span></h3>
<p><span class="koboSpan" id="kobo.812.1">Finally, we need to define another structure that will represent the total quantity available at the </span><a id="_idIndexMarker1183"/><span class="koboSpan" id="kobo.813.1">best bid and ask prices. </span><span class="koboSpan" id="kobo.813.2">This will represent the best (most aggressive) buy and sell prices available in the market as well as the sum of the quantities of all the orders at those prices. </span><span class="koboSpan" id="kobo.813.3">This structure, called </span><strong class="bold"><span class="koboSpan" id="kobo.814.1">BBO,</span></strong><span class="koboSpan" id="kobo.815.1"> only has four members – </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">bid_price_</span></strong><span class="koboSpan" id="kobo.817.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">ask_price_ (</span></strong><span class="koboSpan" id="kobo.819.1">both </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">Price</span></strong><span class="koboSpan" id="kobo.821.1"> types to represent the best prices), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">bid_qty_</span></strong><span class="koboSpan" id="kobo.823.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">ask_qty_</span></strong><span class="koboSpan" id="kobo.825.1"> to represent the total quantity of all orders at </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">these prices.</span></span></p>
<p><span class="koboSpan" id="kobo.827.1">The BBO abstraction is used by many different components inside the trade engine. </span><span class="koboSpan" id="kobo.827.2">Typically, this is used by components that need a summary of the best market prices and liquidity, instead of the full depth of the book and all the details about each order in the book. </span><span class="koboSpan" id="kobo.827.3">For example, a component such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">RiskManager</span></strong><span class="koboSpan" id="kobo.829.1"> component, which only needs to compute the open </span><strong class="bold"><span class="koboSpan" id="kobo.830.1">Profit and Loss</span></strong><span class="koboSpan" id="kobo.831.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.832.1">PnL</span></strong><span class="koboSpan" id="kobo.833.1">) for an open position when the top-of-book prices change, does not need access to the full order book and instead can be simplified using a BBO abstraction. </span><span class="koboSpan" id="kobo.833.2">Other components, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.835.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.837.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.839.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.841.1">, also use the BBO abstraction where the full order book is </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">not needed.</span></span></p>
<p><span class="koboSpan" id="kobo.843.1">To make it easy </span><a id="_idIndexMarker1184"/><span class="koboSpan" id="kobo.844.1">to log such objects, we will also add a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">toString()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.846.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.847.1">
  struct BBO {
    Price bid_price_ = Price_INVALID, ask_price_ =
      Price_INVALID;
    Qty bid_qty_ = Qty_INVALID, ask_qty_ = Qty_INVALID;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "BBO{"
         &lt;&lt; qtyToString(bid_qty_) &lt;&lt; "@" &lt;&lt;
           priceToString(bid_price_)
         &lt;&lt; "X"
         &lt;&lt; priceToString(ask_price_) &lt;&lt; "@" &lt;&lt;
            qtyToString(ask_qty_)
         &lt;&lt; "}";
      return ss.str();
    };
  };</span></pre>
<p><span class="koboSpan" id="kobo.848.1">Now, we can finally move on to our implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">MarketOrderBook</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.850.1"> class.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.851.1">Defining the data members in the order book</span></h2>
<p><span class="koboSpan" id="kobo.852.1">To build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.854.1"> class, we first need to define the data members in this class. </span><span class="koboSpan" id="kobo.854.2">All the </span><a id="_idIndexMarker1185"/><span class="koboSpan" id="kobo.855.1">source code for this class can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">Chapter8/trading/strategy/market_order_book.h</span></strong><span class="koboSpan" id="kobo.857.1"> source file and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">Chapter8/trading/strategy/market_order_book.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.859.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.860.1">The important data members in this class are </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.862.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">trade_engine_</span></strong><span class="koboSpan" id="kobo.864.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.866.1"> pointer type. </span><span class="koboSpan" id="kobo.866.2">We have not defined this class yet, but we will in this chapter. </span><span class="koboSpan" id="kobo.866.3">For now, it represents the class that is the trading engine framework. </span><span class="koboSpan" id="kobo.866.4">We will communicate changes to the order book using </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">this variable.</span></span></li>
<li><span class="koboSpan" id="kobo.868.1">Two memory pools, </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">order_pool_</span></strong><span class="koboSpan" id="kobo.870.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.872.1"> objects and </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">orders_at_price_pool_</span></strong><span class="koboSpan" id="kobo.874.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.876.1"> objects, are to be used to allocate and deallocate these objects as needed. </span><span class="koboSpan" id="kobo.876.2">The first pool, </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">order_pool_</span></strong><span class="koboSpan" id="kobo.878.1">, is used to allocate and deallocate </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.880.1"> objects. </span><span class="koboSpan" id="kobo.880.2">The second pool, </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">orders_at_price_pool_</span></strong><span class="koboSpan" id="kobo.882.1">, is used to allocate and deallocate </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.884.1"> objects. </span><span class="koboSpan" id="kobo.884.2">Remember that a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">MemPool</span></strong><span class="koboSpan" id="kobo.886.1"> instance is tied to a specific object type provided to it as a </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">template parameter.</span></span></li>
<li><span class="koboSpan" id="kobo.888.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">bbo_</span></strong><span class="koboSpan" id="kobo.890.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">BBO</span></strong><span class="koboSpan" id="kobo.892.1"> type, which will be used to compute and maintain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">BBO</span></strong><span class="koboSpan" id="kobo.894.1">-view of the order book when there are updates and provided to any components that </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">require it.</span></span></li>
<li><span class="koboSpan" id="kobo.896.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">oid_to_order_</span></strong><span class="koboSpan" id="kobo.898.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">OrderHashMap</span></strong><span class="koboSpan" id="kobo.900.1"> type will be used to track </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.902.1"> objects </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">OrderId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.906.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">price_orders_at_price_</span></strong><span class="koboSpan" id="kobo.908.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">OrdersAtPriceHashMap</span></strong><span class="koboSpan" id="kobo.910.1"> type to track </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">OrdersAtPrice</span></strong><span class="koboSpan" id="kobo.912.1"> objects </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">Price</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.916.1">Two pointers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.918.1"> – </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">bids_by_price_</span></strong><span class="koboSpan" id="kobo.920.1"> to represent the doubly linked list of bids sorted by price and </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">asks_by_price_</span></strong><span class="koboSpan" id="kobo.922.1"> to represent the doubly linked list of asks sorted </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">by price.</span></span></li>
<li><span class="koboSpan" id="kobo.924.1">Finally, some </span><a id="_idIndexMarker1186"/><span class="koboSpan" id="kobo.925.1">variables that are not so important, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">ticker_id_</span></strong><span class="koboSpan" id="kobo.927.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">time_str_</span></strong><span class="koboSpan" id="kobo.929.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">logger_</span></strong><span class="koboSpan" id="kobo.931.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">logging purposes:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.933.1">
#pragma once
#include "common/types.h"
#include "common/mem_pool.h"
#include "common/logging.h"
#include "market_order.h"
#include "exchange/market_data/market_update.h"
namespace Trading {
  class TradeEngine;
  class MarketOrderBook final {
  private:
    const TickerId ticker_id_;
    TradeEngine *trade_engine_ = nullptr;
    OrderHashMap oid_to_order_;
    MemPool&lt;MarketOrdersAtPrice&gt; orders_at_price_pool_;
    MarketOrdersAtPrice *bids_by_price_ = nullptr;
    MarketOrdersAtPrice *asks_by_price_ = nullptr;
    OrdersAtPriceHashMap price_orders_at_price_;
    MemPool&lt;MarketOrder&gt; order_pool_;
    BBO bbo_;
    std::string time_str_;
    Logger *logger_ = nullptr;
  };</span></pre>
<p><span class="koboSpan" id="kobo.934.1">We will also define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">MarketOrderBookHashMap</span></strong><span class="koboSpan" id="kobo.936.1"> type, which is just a hash map from </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">TickerId</span></strong><span class="koboSpan" id="kobo.938.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.940.1"> objects of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">ME_MAX_TICKERS</span></strong><span class="koboSpan" id="kobo.942.1"> size. </span><span class="koboSpan" id="kobo.942.2">This constant, as well as the </span><a id="_idIndexMarker1187"/><span class="koboSpan" id="kobo.943.1">others we will encounter in the next code snippet, were defined in the </span><em class="italic"><span class="koboSpan" id="kobo.944.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.945.1"> chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.946.1">Defining the operations and interactions in our matching engine</span></em><span class="koboSpan" id="kobo.947.1"> section, within the </span><em class="italic"><span class="koboSpan" id="kobo.948.1">Defining some types and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.949.1">constants</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.950.1"> sub-section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.951.1">
  typedef std::array&lt;MarketOrderBook *, ME_MAX_TICKERS&gt;
    MarketOrderBookHashMap;
}</span></pre>
<p><span class="koboSpan" id="kobo.952.1">Next, we will see </span><a id="_idIndexMarker1188"/><span class="koboSpan" id="kobo.953.1">how to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.955.1"> class and its </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">member variables.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.957.1">Initializing the order book</span></h2>
<p><span class="koboSpan" id="kobo.958.1">In this sub-section, we </span><a id="_idIndexMarker1189"/><span class="koboSpan" id="kobo.959.1">will implement the code to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.961.1"> class as well as its internal data members. </span><span class="koboSpan" id="kobo.961.2">The constructor is straightforward and accepts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">TickerId</span></strong><span class="koboSpan" id="kobo.963.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">Logger</span></strong><span class="koboSpan" id="kobo.965.1"> instances it will use to log. </span><span class="koboSpan" id="kobo.965.2">It initializes </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">orders_at_price_pool_</span></strong><span class="koboSpan" id="kobo.967.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.969.1"> objects to be of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">ME_MAX_PRICE_LEVELS</span></strong><span class="koboSpan" id="kobo.971.1"> size and </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">order_pool_</span></strong><span class="koboSpan" id="kobo.973.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.975.1"> objects to be of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">ME_MAX_ORDER_IDS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.977.1"> size:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.978.1">
#include "market_order_book.h"
#include "trade_engine.h"
namespace Trading {
  MarketOrderBook::MarketOrderBook(TickerId ticker_id,
    Logger *logger)
      : ticker_id_(ticker_id),
        orders_at_price_pool_(ME_MAX_PRICE_LEVELS),
          order_pool_(ME_MAX_ORDER_IDS), logger_(logger) {
  }</span></pre>
<p><span class="koboSpan" id="kobo.979.1">The destructor for this class just resets the internal </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">data members:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.981.1">
  MarketOrderBook::~MarketOrderBook() {
    logger_-&gt;log("%:% %() % OrderBook\n%\n", __FILE__,
      __LINE__, __FUNCTION__,
                 Common::getCurrentTimeStr(&amp;time_str_),
                   toString(false, true));
    trade_engine_ = nullptr;
    bids_by_price_ = asks_by_price_ = nullptr;
    oid_to_order_.fill(nullptr);
  }</span></pre>
<p><span class="koboSpan" id="kobo.982.1">There is an additional utility method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">setTradeEngine()</span></strong><span class="koboSpan" id="kobo.984.1">, which is a better method to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">trade_engine_</span></strong><span class="koboSpan" id="kobo.986.1"> variable with an instance of a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">TradeEngine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.988.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.989.1">
    auto setTradeEngine(TradeEngine *trade_engine) {
      trade_engine_ = trade_engine;
    }</span></pre>
<p><span class="koboSpan" id="kobo.990.1">Now that we have </span><a id="_idIndexMarker1190"/><span class="koboSpan" id="kobo.991.1">seen how to initialize our </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.993.1"> class, we will discuss the most important functionality for this class, which is updating the order book from </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.995.1"> messages that it will receive from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">TradeEngine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.997.1"> engine.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.998.1">Processing market updates and updating the order book</span></h2>
<p><span class="koboSpan" id="kobo.999.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">onMarketUpdate()</span></strong><span class="koboSpan" id="kobo.1001.1"> method is called along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1003.1"> message that </span><a id="_idIndexMarker1191"/><span class="koboSpan" id="kobo.1004.1">needs to be processed. </span><span class="koboSpan" id="kobo.1004.2">This method updates the order </span><a id="_idIndexMarker1192"/><span class="koboSpan" id="kobo.1005.1">book from the market update, which is passed as an argument. </span><span class="koboSpan" id="kobo.1005.2">We will understand the source code to handle these messages, but we will go code block by code block for each case </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">MarketUpdateType</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1009.1">Before we get into the handling of the actual messages, we will first initialize a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">bid_updated</span></strong><span class="koboSpan" id="kobo.1011.1"> boolean flag and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">ask_updated</span></strong><span class="koboSpan" id="kobo.1013.1"> boolean flag, which will represent if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">BBO</span></strong><span class="koboSpan" id="kobo.1015.1"> will need to be updated because of this market update. </span><span class="koboSpan" id="kobo.1015.2">We figure that out by checking if the market update we received corresponds to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">side_ == Side::BUY</span></strong><span class="koboSpan" id="kobo.1017.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">price_</span></strong><span class="koboSpan" id="kobo.1019.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">market_update</span></strong><span class="koboSpan" id="kobo.1021.1"> is equal to or greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">price_</span></strong><span class="koboSpan" id="kobo.1023.1"> of the current best bid, which we fetch from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">bids_by_price_-&gt;price_</span></strong><span class="koboSpan" id="kobo.1025.1"> variable. </span><span class="koboSpan" id="kobo.1025.2">We do the same thing for the ask side by checking for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">Side::SELL</span></strong><span class="koboSpan" id="kobo.1027.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">market_update_-&gt;side_</span></strong><span class="koboSpan" id="kobo.1029.1"> and checking if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">price_</span></strong><span class="koboSpan" id="kobo.1031.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">market_update</span></strong><span class="koboSpan" id="kobo.1033.1"> is less than or equal to the price of the best </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">ask (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">asks_by_price_-&gt;price_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1037.1">
  auto MarketOrderBook::onMarketUpdate(const
    Exchange::MEMarketUpdate *market_update) noexcept -&gt; void {
    const auto bid_updated = (bids_by_price_ &amp;&amp;
      market_update-&gt;side_ == Side::BUY &amp;&amp; market_update-&gt;
        price_ &gt;= bids_by_price_-&gt;price_);
    const auto ask_updated = (asks_by_price_ &amp;&amp;
      market_update-&gt;side_ == Side::SELL &amp;&amp; market_update-&gt;
         price_ &lt;= asks_by_price_-&gt;price_);</span></pre>
<p><span class="koboSpan" id="kobo.1038.1">First, we see the handling for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">MarketUpdateType::ADD</span></strong><span class="koboSpan" id="kobo.1040.1">. </span><span class="koboSpan" id="kobo.1040.2">We will allocate a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.1042.1"> object </span><a id="_idIndexMarker1193"/><span class="koboSpan" id="kobo.1043.1">and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">addOrder()</span></strong><span class="koboSpan" id="kobo.1045.1"> method </span><a id="_idIndexMarker1194"/><span class="koboSpan" id="kobo.1046.1">on it. </span><span class="koboSpan" id="kobo.1046.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">addOrder()</span></strong><span class="koboSpan" id="kobo.1048.1"> method is identical to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">addOrder()</span></strong><span class="koboSpan" id="kobo.1050.1"> method we built for the matching engine except it operates on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.1052.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1054.1"> objects. </span><span class="koboSpan" id="kobo.1054.2">We will discuss this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">addOrder()</span></strong><span class="koboSpan" id="kobo.1056.1"> method briefly in the next sub-section, but we will not be fully re-implementing it since we have seen all the details in the </span><em class="italic"><span class="koboSpan" id="kobo.1057.1">Building the C++ Matching </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1058.1">Engine</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1"> chapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1060.1">
    switch (market_update-&gt;type_) {
      case Exchange::MarketUpdateType::ADD: {
        auto order = order_pool_.allocate(market_update-&gt;
          order_id_, market_update-&gt;side_, market_update-&gt;
            price_,
            market_update-&gt;qty_, market_update-&gt;priority_,
             nullptr, nullptr);
        addOrder(order);
      }
        break;</span></pre>
<p><span class="koboSpan" id="kobo.1061.1">The handling for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">MarketUpdateType::MODIFY</span></strong><span class="koboSpan" id="kobo.1063.1"> case finds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.1065.1"> structure for </span><a id="_idIndexMarker1195"/><span class="koboSpan" id="kobo.1066.1">which the modified message is targeted. </span><span class="koboSpan" id="kobo.1066.2">It then </span><a id="_idIndexMarker1196"/><span class="koboSpan" id="kobo.1067.1">updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">qty_</span></strong><span class="koboSpan" id="kobo.1069.1"> attribute on </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">that order:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1071.1">
      case Exchange::MarketUpdateType::MODIFY: {
        auto order = oid_to_order_.at(market_update-&gt;
          order_id_);
        order-&gt;qty_ = market_update-&gt;qty_;
      }
        break;</span></pre>
<p><span class="koboSpan" id="kobo.1072.1">The handling for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">MarketUpdateType::CANCEL</span></strong><span class="koboSpan" id="kobo.1074.1"> is straightforward, and it finds </span><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.1076.1">, for which the cancel message is, and then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">removeOrder()</span></strong><span class="koboSpan" id="kobo.1078.1"> method on it. </span><span class="koboSpan" id="kobo.1078.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">removeOrder()</span></strong><span class="koboSpan" id="kobo.1080.1"> method is also identical to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">removeOrder()</span></strong><span class="koboSpan" id="kobo.1082.1"> method we built for the matching engine order book in the </span><em class="italic"><span class="koboSpan" id="kobo.1083.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.1084.1"> chapter, except it operates on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.1086.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1088.1"> objects. </span><span class="koboSpan" id="kobo.1088.2">Again, we will not fully re-implement these methods since they are identical to what we have seen, and the details can be found in that chapter and the </span><span class="No-Break"><span class="koboSpan" id="kobo.1089.1">source files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1090.1">
      case Exchange::MarketUpdateType::CANCEL: {
        auto order = oid_to_order_.at(market_update-&gt;
          order_id_);
        removeOrder(order);
      }
        break;</span></pre>
<p><span class="koboSpan" id="kobo.1091.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">MarketUpdateType::TRADE</span></strong><span class="koboSpan" id="kobo.1093.1"> messages do not change the order book, so here, we simply forward that trade message back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1095.1"> engine using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.1097.1"> method. </span><span class="koboSpan" id="kobo.1097.2">One thing to note here is that in the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">MarketUpdateType::TRADE</span></strong><span class="koboSpan" id="kobo.1099.1">, we simply return after calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">TradeEngine::onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.1101.1"> method. </span><span class="koboSpan" id="kobo.1101.2">This is because the trade messages do not update the order book in our market data protocol, so the subsequent code after this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">switch case</span></strong><span class="koboSpan" id="kobo.1103.1"> does not need to </span><span class="No-Break"><span class="koboSpan" id="kobo.1104.1">be executed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1105.1">
      case Exchange::MarketUpdateType::TRADE: {
        trade_engine_-&gt;onTradeUpdate(market_update, this);
        return;
      }
        break;</span></pre>
<p><span class="koboSpan" id="kobo.1106.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1108.1"> class needs to handle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">MarketUpdateType::CLEAR</span></strong><span class="koboSpan" id="kobo.1110.1"> messages. </span><span class="koboSpan" id="kobo.1110.2">It receives </span><a id="_idIndexMarker1197"/><span class="koboSpan" id="kobo.1111.1">these messages when the book needs to be cleared </span><a id="_idIndexMarker1198"/><span class="koboSpan" id="kobo.1112.1">because we dropped a packet and are recovering from the snapshot stream. </span><span class="koboSpan" id="kobo.1112.2">All it does here is deallocate all the valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.1114.1"> objects in the book and clear the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">oid_to_order_</span></strong><span class="koboSpan" id="kobo.1116.1"> container by setting each entry to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">nullptr</span></strong><span class="koboSpan" id="kobo.1118.1">. </span><span class="koboSpan" id="kobo.1118.2">It then iterates through the double-linked list starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">bids_by_price_</span></strong><span class="koboSpan" id="kobo.1120.1"> pointer and deallocates each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1122.1"> object back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">orders_at_price_pool_</span></strong><span class="koboSpan" id="kobo.1124.1"> memory pool. </span><span class="koboSpan" id="kobo.1124.2">It does the same thing with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">asks_by_price_</span></strong><span class="koboSpan" id="kobo.1126.1"> linked list and, finally, sets both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">bids_by_price_</span></strong><span class="koboSpan" id="kobo.1128.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">asks_by_price_</span></strong><span class="koboSpan" id="kobo.1130.1"> to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">nullptr</span></strong><span class="koboSpan" id="kobo.1132.1"> to represent an </span><span class="No-Break"><span class="koboSpan" id="kobo.1133.1">empty book:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1134.1">
      case Exchange::MarketUpdateType::CLEAR: {
        for (auto &amp;order: oid_to_order_) {
          if (order)
            order_pool_.deallocate(order);
        }
        oid_to_order_.fill(nullptr);
        if(bids_by_price_) {
          for(auto bid = bids_by_price_-&gt;next_entry_; bid
            != bids_by_price_; bid = bid-&gt;next_entry_)
            orders_at_price_pool_.deallocate(bid);
          orders_at_price_pool_.deallocate(bids_by_price_);
        }
        if(asks_by_price_) {
          for(auto ask = asks_by_price_-&gt;next_entry_; ask
            != asks_by_price_; ask = ask-&gt;next_entry_)
            orders_at_price_pool_.deallocate(ask);
          orders_at_price_pool_.deallocate(asks_by_price_);
        }
        bids_by_price_ = asks_by_price_ = nullptr;
      }
        break;</span></pre>
<p><span class="koboSpan" id="kobo.1135.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1137.1"> class does not need to handle </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">INVALID</span></strong><span class="koboSpan" id="kobo.1139.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">SNAPSHOT_START</span></strong><span class="koboSpan" id="kobo.1141.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">SNAPSHOT_END</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">MarketUpdateType</span></strong><span class="koboSpan" id="kobo.1144.1">s, so it does nothing with </span><span class="No-Break"><span class="koboSpan" id="kobo.1145.1">those messages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1146.1">
      case Exchange::MarketUpdateType::INVALID:
      case Exchange::MarketUpdateType::SNAPSHOT_START:
      case Exchange::MarketUpdateType::SNAPSHOT_END:
        break;
    }</span></pre>
<p><span class="koboSpan" id="kobo.1147.1">At this point, we will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">updateBBO()</span></strong><span class="koboSpan" id="kobo.1149.1"> method and pass it to the two boolean flags we computed: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">bid_updated</span></strong><span class="koboSpan" id="kobo.1151.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">ask_updated</span></strong><span class="koboSpan" id="kobo.1153.1">. </span><span class="koboSpan" id="kobo.1153.2">We will look at the implementation </span><a id="_idIndexMarker1199"/><span class="koboSpan" id="kobo.1154.1">of this method shortly, but for now, you should understand </span><a id="_idIndexMarker1200"/><span class="koboSpan" id="kobo.1155.1">that it will use the two boolean flags passed to it to decide if it needs to update the bid side or the ask side </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">BBO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1"> values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1158.1">
    updateBBO(bid_updated, ask_updated);</span></pre>
<p><span class="koboSpan" id="kobo.1159.1">Finally, it notifies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1161.1"> engine that the order book was updated using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.1163.1"> method, which we will discuss later in this chapter and enrich further in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">next chapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1165.1">
    trade_engine_-&gt;onOrderBookUpdate(market_update-&gt;
      ticker_id_, market_update-&gt;price_, market_update-&gt;
        side_);
    logger_-&gt;log("%:% %() % OrderBook\n%\n", __FILE__,
      __LINE__, __FUNCTION__,
                 Common::getCurrentTimeStr(&amp;time_str_),
                   toString(false, true));
  }</span></pre>
<p><span class="koboSpan" id="kobo.1166.1">Before we conclude this section, let us look at the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">updateBBO()</span></strong><span class="koboSpan" id="kobo.1168.1"> method we referred to before. </span><span class="koboSpan" id="kobo.1168.2">The implementation itself is relatively straightforward, so let us look at the handling for the bid side first. </span><span class="koboSpan" id="kobo.1168.3">Once we understand how we handle the bid side, understanding the ask side will be very simple since it is exactly the same. </span><span class="koboSpan" id="kobo.1168.4">The first thing we do is check if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">update_bid</span></strong><span class="koboSpan" id="kobo.1170.1"> parameter passed to it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">true</span></strong><span class="koboSpan" id="kobo.1172.1">. </span><span class="koboSpan" id="kobo.1172.2">Only then do we have to update the bid side of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">BBO</span></strong><span class="koboSpan" id="kobo.1174.1"> object. </span><span class="koboSpan" id="kobo.1174.2">Next, we check if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">bids_by_price_</span></strong><span class="koboSpan" id="kobo.1176.1"> member is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">nullptr</span></strong><span class="koboSpan" id="kobo.1178.1">. </span><span class="koboSpan" id="kobo.1178.2">If it is not valid, then we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">bid_price_</span></strong><span class="koboSpan" id="kobo.1180.1"> variable and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">bid_qty_</span></strong><span class="koboSpan" id="kobo.1182.1"> variable to be invalid (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">Price_INVALID</span></strong><span class="koboSpan" id="kobo.1184.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">Qty_INVALID</span></strong><span class="koboSpan" id="kobo.1186.1"> respectively) since the side is empty. </span><span class="koboSpan" id="kobo.1186.2">The more interesting handling is in the case where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">bids_by_price_</span></strong><span class="koboSpan" id="kobo.1188.1"> member </span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">is valid.</span></span></p>
<p><span class="koboSpan" id="kobo.1190.1">In that case, we set the bid_</span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">price_</span></strong><span class="koboSpan" id="kobo.1192.1"> member variable in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">bbo_</span></strong><span class="koboSpan" id="kobo.1194.1"> object to be the price of the best bid: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">bids_by_price_-&gt;price_</span></strong><span class="koboSpan" id="kobo.1196.1">. </span><span class="koboSpan" id="kobo.1196.2">To compute </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">bid_qty_</span></strong><span class="koboSpan" id="kobo.1198.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">bbo_</span></strong><span class="koboSpan" id="kobo.1200.1"> object, we first assign it </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">qty_</span></strong><span class="koboSpan" id="kobo.1202.1"> of the first order at that price level, which we access using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">bids_by_price_-&gt;first_mkt_order_-&gt;qty_</span></strong><span class="koboSpan" id="kobo.1204.1"> value. </span><span class="koboSpan" id="kobo.1204.2">Then, we linearly iterate over all the orders at that price level by following the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">next_order_</span></strong><span class="koboSpan" id="kobo.1206.1"> pointers until we wrap around, i.e. </span><span class="koboSpan" id="kobo.1206.2">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">next_order_</span></strong><span class="koboSpan" id="kobo.1208.1"> points to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">first_mkt_order_</span></strong><span class="koboSpan" id="kobo.1210.1"> object. </span><span class="koboSpan" id="kobo.1210.2">For each order we iterate over, we accumulate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">qty_</span></strong><span class="koboSpan" id="kobo.1212.1"> value of that order into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">bid_qty_</span></strong><span class="koboSpan" id="kobo.1214.1"> member in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1215.1">bbo_</span></strong><span class="koboSpan" id="kobo.1216.1"> object. </span><span class="koboSpan" id="kobo.1216.2">At this point, we are done </span><a id="_idIndexMarker1201"/><span class="koboSpan" id="kobo.1217.1">updating the bid side of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">BBO</span></strong><span class="koboSpan" id="kobo.1219.1"> object. </span><span class="koboSpan" id="kobo.1219.2">Note here that the </span><a id="_idIndexMarker1202"/><span class="koboSpan" id="kobo.1220.1">linear iteration is slightly inefficient and can be improved for example by tracking and updating these values during the processing of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1222.1"> messages itself, but we leave that (simple) exercise up to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">interested reader:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1224.1">
    auto updateBBO(bool update_bid, bool update_ask)
      noexcept {
      if(update_bid) {
        if(bids_by_price_) {
          bbo_.bid_price_ = bids_by_price_-&gt;price_;
          bbo_.bid_qty_ = bids_by_price_-&gt;first_mkt_order_-
            &gt;qty_;
          for(auto order = bids_by_price_-&gt;
            first_mkt_order_-&gt;next_order_; order !=
              bids_by_price_-&gt;first_mkt_order_; order =
                order-&gt;next_order_)
            bbo_.bid_qty_ += order-&gt;qty_;
        }
        else {
          bbo_.bid_price_ = Price_INVALID;
          bbo_.bid_qty_ = Qty_INVALID;
        }
      }</span></pre>
<p><span class="koboSpan" id="kobo.1225.1">The handling for the </span><a id="_idIndexMarker1203"/><span class="koboSpan" id="kobo.1226.1">ask side of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">BBO</span></strong><span class="koboSpan" id="kobo.1228.1"> is identical to the handling for the </span><a id="_idIndexMarker1204"/><span class="koboSpan" id="kobo.1229.1">bid side we just discussed. </span><span class="koboSpan" id="kobo.1229.2">We will not repeat ourselves, but here is </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">that handling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1231.1">
      if(update_ask) {
        if(asks_by_price_) {
          bbo_.ask_price_ = asks_by_price_-&gt;price_;
          bbo_.ask_qty_ = asks_by_price_-&gt;first_mkt_order_-
            &gt;qty_;
          for(auto order = asks_by_price_-&gt;
            first_mkt_order_-&gt;next_order_; order !=
              asks_by_price_-&gt;first_mkt_order_; order =
                order-&gt;next_order_)
            bbo_.ask_qty_ += order-&gt;qty_;
        }
        else {
          bbo_.ask_price_ = Price_INVALID;
          bbo_.ask_qty_ = Qty_INVALID;
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.1232.1">That concludes </span><a id="_idIndexMarker1205"/><span class="koboSpan" id="kobo.1233.1">most of the functionality we need in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1235.1"> class. </span><span class="koboSpan" id="kobo.1235.2">In the </span><a id="_idIndexMarker1206"/><span class="koboSpan" id="kobo.1236.1">next sub-section, we will quickly recap a couple of the utility methods we built for the order book in the matching engine, and we will replicate them for the trading engine’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">order book.</span></span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.1238.1">Revisiting the generic utility methods for order book management</span></h2>
<p><span class="koboSpan" id="kobo.1239.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.1240.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.1241.1"> chapter, we built </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.1243.1"> in the matching engine in the </span><em class="italic"><span class="koboSpan" id="kobo.1244.1">Building the order book and matching </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1245.1">orders</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.1247.1">We explained </span><a id="_idIndexMarker1207"/><span class="koboSpan" id="kobo.1248.1">and implemented the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">priceToIndex()</span></strong><span class="koboSpan" id="kobo.1250.1"> method and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">getOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1252.1"> method in the </span><em class="italic"><span class="koboSpan" id="kobo.1253.1">Building the internal data structures</span></em><span class="koboSpan" id="kobo.1254.1"> sub-section. </span><span class="koboSpan" id="kobo.1254.2">We have identical methods in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1256.1"> class, except they operate on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1258.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1260.1">. </span><span class="koboSpan" id="kobo.1260.2">We will not discuss them again or re-implement them here, but we provide the signatures for those </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">two methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1262.1">
    auto priceToIndex(Price price) const noexcept;
    auto getOrdersAtPrice(Price price) const noexcept -&gt;
      MarketOrdersAtPrice;</span></pre>
<p><span class="koboSpan" id="kobo.1263.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.1264.1">Handling new passive orders</span></em><span class="koboSpan" id="kobo.1265.1"> sub-section in that chapter, we explained the logic and implemented the methods </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">addOrder()</span></strong><span class="koboSpan" id="kobo.1267.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">addOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1269.1">. </span><span class="koboSpan" id="kobo.1269.2">Again, for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1271.1"> class, the logic is identical except it operates on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.1273.1"> instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1275.1"> structure and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1276.1">MarketOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1277.1"> objects instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1279.1"> objects. </span><span class="koboSpan" id="kobo.1279.2">The signatures for those two methods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1281.1"> class are presented here, but we will skip repeating the explanation and source code here since it </span><span class="No-Break"><span class="koboSpan" id="kobo.1282.1">is identical:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1283.1">
    auto addOrder(MarketOrder *order) noexcept -&gt; void;
    auto addOrdersAtPrice(MarketOrdersAtPrice
      *new_orders_at_price) noexcept;</span></pre>
<p><span class="koboSpan" id="kobo.1284.1">Similarly, in the </span><em class="italic"><span class="koboSpan" id="kobo.1285.1">Handling order cancellation requests</span></em><span class="koboSpan" id="kobo.1286.1"> sub-section, we covered the details </span><a id="_idIndexMarker1208"/><span class="koboSpan" id="kobo.1287.1">behind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1288.1">removeOrder()</span></strong><span class="koboSpan" id="kobo.1289.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">removeOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1291.1"> methods. </span><span class="koboSpan" id="kobo.1291.2">Again, for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1293.1"> class, these methods work exactly the same except they operate on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.1295.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">MarketOrdersAtPrice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1"> structures:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1298.1">
    Auto removeOrdersAtPrice(Side side, Price price)
      noexcept;
    auto removeOrder(MarketOrder *order) noexcept -&gt; void;</span></pre>
<p><span class="koboSpan" id="kobo.1299.1">This concludes the design and implementation of the order book inside the trading engine framework. </span><span class="koboSpan" id="kobo.1299.2">Next, we need to discuss the order gateway infrastructure component, which is what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1301.1"> component will use to communicate with the electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.1302.1">trading exchange.</span></span></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.1303.1">Connecting to the exchange and sending and receiving order flow</span></h1>
<p><span class="koboSpan" id="kobo.1304.1">The order gateway client component in the market participant’s trading infrastructure receives order </span><a id="_idIndexMarker1209"/><span class="koboSpan" id="kobo.1305.1">requests from the trading engine through a lock-free queue </span><a id="_idIndexMarker1210"/><span class="koboSpan" id="kobo.1306.1">and sends order responses back to the trading engine </span><a id="_idIndexMarker1211"/><span class="koboSpan" id="kobo.1307.1">through another lock-free queue. </span><span class="koboSpan" id="kobo.1307.2">It also establishes a TCP connection to the order gateway server in the exchange side infrastructure. </span><span class="koboSpan" id="kobo.1307.3">It encodes order requests in the exchange’s order format and sends them over the TCP connection. </span><span class="koboSpan" id="kobo.1307.4">It also consumes order responses sent by the exchange over that TCP connection and decodes them from the order data format. </span><span class="koboSpan" id="kobo.1307.5">We present the order gateway client diagram again to refresh your memory on that </span><span class="No-Break"><span class="koboSpan" id="kobo.1308.1">component’s design.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.1309.1"><img alt="Figure 8.4 – Diagram presenting the order gateway client component inside the client’s trading infrastructure" src="image/B19434_08_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1310.1">Figure 8.4 – Diagram presenting the order gateway client component inside the client’s trading infrastructure</span></p>
<p><span class="koboSpan" id="kobo.1311.1">We will start the implementation of this order gateway client component by defining the </span><a id="_idIndexMarker1212"/><span class="koboSpan" id="kobo.1312.1">internal data members of that class first. </span><span class="koboSpan" id="kobo.1312.2">All the source code </span><a id="_idIndexMarker1213"/><span class="koboSpan" id="kobo.1313.1">for the order gateway </span><a id="_idIndexMarker1214"/><span class="koboSpan" id="kobo.1314.1">client component is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">Chapter8/trading/order_gw/order_gateway.h</span></strong><span class="koboSpan" id="kobo.1316.1"> source file and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">Chapter8/trading/order_gw/order_gateway.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1318.1">source files.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.1319.1">Defining the data members in the order gateway client</span></h2>
<p><span class="koboSpan" id="kobo.1320.1">The important </span><a id="_idIndexMarker1215"/><span class="koboSpan" id="kobo.1321.1">data members in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1323.1"> class are </span><span class="No-Break"><span class="koboSpan" id="kobo.1324.1">described </span></span><span class="No-Break"><span class="koboSpan" id="kobo.1325.1">here</span></span><span class="No-Break"><span class="koboSpan" id="kobo.1326.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1327.1">Two lock-free queue pointers. </span><span class="koboSpan" id="kobo.1327.2">The first one is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1328.1">outgoing_requests_</span></strong><span class="koboSpan" id="kobo.1329.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.1331.1"> type, which we defined before as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1333.1"> instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1335.1"> structures. </span><span class="koboSpan" id="kobo.1335.2">The other member is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">incoming_responses_</span></strong><span class="koboSpan" id="kobo.1337.1">, which is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.1339.1"> type, which we also defined earlier as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1341.1"> instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1343.1"> structures. </span><span class="koboSpan" id="kobo.1343.2">These will be used by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1345.1"> to receive order requests and send order responses </span><span class="No-Break"><span class="koboSpan" id="kobo.1346.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1347.1">TradeEngine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1348.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1349.1">It also contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">tcp_socket_</span></strong><span class="koboSpan" id="kobo.1351.1"> member variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1353.1"> type, which is the TCP socket client to be used to connect to the exchange order gateway server and to send and </span><span class="No-Break"><span class="koboSpan" id="kobo.1354.1">receive messages.</span></span></li>
<li><span class="koboSpan" id="kobo.1355.1">Two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">size_t</span></strong><span class="koboSpan" id="kobo.1357.1"> variables to represent sequence numbers. </span><span class="koboSpan" id="kobo.1357.2">The first one, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1358.1">next_outgoing_seq_num_</span></strong><span class="koboSpan" id="kobo.1359.1">, tracks the sequence number that will be sent on the next outgoing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.1361.1"> message sent to the exchange. </span><span class="koboSpan" id="kobo.1361.2">The second one, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">next_exp_seq_num_</span></strong><span class="koboSpan" id="kobo.1363.1">, is used to check and validate that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.1365.1"> messages received from the exchange are </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">in sequence.</span></span></li>
<li><span class="koboSpan" id="kobo.1367.1">A boolean </span><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">run_</span></strong><span class="koboSpan" id="kobo.1369.1"> flag, which serves a similar purpose as it did in all the other components we saw before. </span><span class="koboSpan" id="kobo.1369.2">It will be used to start and stop the execution of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1371.1"> thread and is marked </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">volatile</span></strong><span class="koboSpan" id="kobo.1373.1"> since it is accessed from </span><span class="No-Break"><span class="koboSpan" id="kobo.1374.1">different threads.</span></span></li>
<li><span class="koboSpan" id="kobo.1375.1">It also saves the network interface in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">iface_</span></strong><span class="koboSpan" id="kobo.1377.1"> variable and the IP and port of the exchange’s order gateway server in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1378.1">ip_</span></strong><span class="koboSpan" id="kobo.1379.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1380.1">port_</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1381.1">member variables.</span></span></li>
<li><span class="koboSpan" id="kobo.1382.1">Finally, it </span><a id="_idIndexMarker1216"/><span class="koboSpan" id="kobo.1383.1">stores the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">client_id_</span></strong><span class="koboSpan" id="kobo.1385.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">ClientId</span></strong><span class="koboSpan" id="kobo.1387.1"> type to make sure that responses received on the TCP socket are meant for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1388.1">correct client:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.1389.1">
#pragma once
#include &lt;functional&gt;
#include "common/thread_utils.h"
#include "common/macros.h"
#include "common/tcp_server.h"
#include "exchange/order_server/client_request.h"
#include "exchange/order_server/client_response.h"
namespace Trading {
  class OrderGateway {
  private:
    const ClientId client_id_;
    std::string ip_;
    const std::string iface_;
    const int port_ = 0;
    Exchange::ClientRequestLFQueue *outgoing_requests_ =
      nullptr;
    Exchange::ClientResponseLFQueue *incoming_responses_ =
      nullptr;
    volatile bool run_ = false;
    std::string time_str_;
    Logger logger_;
    size_t next_outgoing_seq_num_ = 1;
    size_t next_exp_seq_num_ = 1;
    Common::TCPSocket tcp_socket_;
  };
}</span></pre>
<p><span class="koboSpan" id="kobo.1390.1">In the next section, we </span><a id="_idIndexMarker1217"/><span class="koboSpan" id="kobo.1391.1">will initialize these data members as well as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">OrderGateway</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1393.1">class itself.</span></span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.1394.1">Initializing the order gateway client</span></h2>
<p><span class="koboSpan" id="kobo.1395.1">The constructor </span><a id="_idIndexMarker1218"/><span class="koboSpan" id="kobo.1396.1">accepts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">client_id</span></strong><span class="koboSpan" id="kobo.1398.1"> ID of the trading client, a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">ClientRequestsLFQueue</span></strong><span class="koboSpan" id="kobo.1400.1"> object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">client_requests</span></strong><span class="koboSpan" id="kobo.1402.1">), a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1403.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.1404.1"> object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">client_responses</span></strong><span class="koboSpan" id="kobo.1406.1">), and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">ip</span></strong><span class="koboSpan" id="kobo.1408.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">port</span></strong><span class="koboSpan" id="kobo.1410.1">, and interface information (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">iface</span></strong><span class="koboSpan" id="kobo.1412.1">) for the TCP connection. </span><span class="koboSpan" id="kobo.1412.2">It initializes its own internal variables with these arguments and initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">Logger</span></strong><span class="koboSpan" id="kobo.1414.1"> data member (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">logger_</span></strong><span class="koboSpan" id="kobo.1416.1">) with a filename for the order gateway logs for this client. </span><span class="koboSpan" id="kobo.1416.2">It updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">recv_callback_</span></strong><span class="koboSpan" id="kobo.1418.1"> member inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">tcp_socket_</span></strong><span class="koboSpan" id="kobo.1420.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1421.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1422.1"> type so that callbacks dispatched on data reads will go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">OrderGateway::recvCallback()</span></strong><span class="koboSpan" id="kobo.1424.1"> method. </span><span class="koboSpan" id="kobo.1424.2">We will see the implementation of that </span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1">method briefly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1426.1">
#include "order_gateway.h"
namespace Trading {
  OrderGateway::OrderGateway(ClientId client_id,
     Exchange::ClientRequestLFQueue *client_requests,
Exchange::ClientResponseLFQueue *client_responses,
  std::string ip, const std::string &amp;iface, int port)
      : client_id_(client_id), ip_(ip), iface_(iface),
        port_(port), outgoing_requests_(client_requests),
          incoming_responses_(client_responses),
      logger_("trading_order_gateway_" + std::
        to_string(client_id) + ".log"),
          tcp_socket_(logger_) {
    tcp_socket_.recv_callback_ = [this](auto socket, auto
      rx_time) { recvCallback(socket, rx_time); };
  }</span></pre>
<p><span class="koboSpan" id="kobo.1427.1">Like the design of our other components, we will add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1428.1">start()</span></strong><span class="koboSpan" id="kobo.1429.1"> method, which will enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1430.1">run_</span></strong><span class="koboSpan" id="kobo.1431.1"> flag and create and launch a thread to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1432.1">run()</span></strong><span class="koboSpan" id="kobo.1433.1"> method. </span><span class="koboSpan" id="kobo.1433.2">We will also initialize </span><a id="_idIndexMarker1219"/><span class="koboSpan" id="kobo.1434.1">our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">tcp_socket_</span></strong><span class="koboSpan" id="kobo.1436.1"> member variable and have it connect to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">ip_</span></strong><span class="koboSpan" id="kobo.1438.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1439.1">port_</span></strong><span class="koboSpan" id="kobo.1440.1"> interface information of the order gateway server at </span><span class="No-Break"><span class="koboSpan" id="kobo.1441.1">the exchange:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1442.1">
    auto start() {
      run_ = true;
      ASSERT(tcp_socket_.connect(ip_, iface_, port_, false)
        &gt;= 0,
             "Unable to connect to ip:" + ip_ + " port:" +
               std::to_string(port_) + " on iface:" +
                 iface_ + " error:" +
                   std::string(std::strerror(errno)));
      ASSERT(Common::createAndStartThread(-1,
        "Trading/OrderGateway", [this]() { run(); }) !=
           nullptr, "Failed to start OrderGateway
             thread.");
    }</span></pre>
<p><span class="koboSpan" id="kobo.1443.1">The destructor for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1445.1"> class calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1446.1">stop()</span></strong><span class="koboSpan" id="kobo.1447.1"> method to stop the execution of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">run()</span></strong><span class="koboSpan" id="kobo.1449.1"> method and waits for a little bit </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">before returning:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1451.1">
    ~OrderGateway() {
      stop();
      using namespace std::literals::chrono_literals;
      std::this_thread::sleep_for(5s);
    }</span></pre>
<p><span class="koboSpan" id="kobo.1452.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1453.1">stop()</span></strong><span class="koboSpan" id="kobo.1454.1"> method simply sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">run_</span></strong><span class="koboSpan" id="kobo.1456.1"> flag to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">false</span></strong><span class="koboSpan" id="kobo.1458.1"> to stop the execution of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">run()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1460.1"> loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1461.1">
    auto stop() -&gt; void {
      run_ = false;
    }</span></pre>
<p><span class="koboSpan" id="kobo.1462.1">Now we can move </span><a id="_idIndexMarker1220"/><span class="koboSpan" id="kobo.1463.1">on to the two remaining important tasks: sending order requests to the exchange and receiving order responses from </span><span class="No-Break"><span class="koboSpan" id="kobo.1464.1">the exchange.</span></span></p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.1465.1">Sending order requests to the exchange</span></h2>
<p><span class="koboSpan" id="kobo.1466.1">In this sub-section, we will </span><a id="_idIndexMarker1221"/><span class="koboSpan" id="kobo.1467.1">implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1468.1">run()</span></strong><span class="koboSpan" id="kobo.1469.1"> method, which is the main loop for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1470.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1471.1"> class. </span><span class="koboSpan" id="kobo.1471.2">The goal of this method is to </span><a id="_idIndexMarker1222"/><span class="koboSpan" id="kobo.1472.1">send out any client requests that are ready to be sent out on the TCP socket to read any data available on the socket and dispatch the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1473.1">recv_callback_()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1474.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1475.1">First, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">TCPSocket::sendAndRecv()</span></strong><span class="koboSpan" id="kobo.1477.1"> method to send and receive data on the established </span><span class="No-Break"><span class="koboSpan" id="kobo.1478.1">TCP connection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1479.1">
  auto OrderGateway::run() noexcept -&gt; void {
    logger_.log("%:% %() %\n", __FILE__, __LINE__,
      __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_));
    while (run_) {
      tcp_socket_.sendAndRecv();</span></pre>
<p><span class="koboSpan" id="kobo.1480.1">It also reads any </span><strong class="source-inline"><span class="koboSpan" id="kobo.1481.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1482.1"> messages available on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1483.1">outgoing_requests_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1484.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1485.1"> sent by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1486.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1487.1"> engine and writes them to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">tcp_socket_</span></strong><span class="koboSpan" id="kobo.1489.1"> send buffer using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1490.1">TCPSocket::send()</span></strong><span class="koboSpan" id="kobo.1491.1"> method. </span><span class="koboSpan" id="kobo.1491.2">Note that it </span><a id="_idIndexMarker1223"/><span class="koboSpan" id="kobo.1492.1">needs to write out </span><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.1494.1"> messages, which </span><a id="_idIndexMarker1224"/><span class="koboSpan" id="kobo.1495.1">it achieves by first writing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">next_outgoing_seq_num_</span></strong><span class="koboSpan" id="kobo.1497.1"> field and then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1498.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1499.1"> object that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1500.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1501.1"> sent. </span><span class="koboSpan" id="kobo.1501.2">This works because we designed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1502.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.1503.1"> object to be a struct that contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1504.1">size_t seq_num_</span></strong><span class="koboSpan" id="kobo.1505.1"> field followed by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1506.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1507.1"> object. </span><span class="koboSpan" id="kobo.1507.2">We also increment the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1508.1">next_outgoing_seq_num_</span></strong><span class="koboSpan" id="kobo.1509.1"> instance for the next outgoing </span><span class="No-Break"><span class="koboSpan" id="kobo.1510.1">socket message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1511.1">
      for(auto client_request = outgoing_requests_-&gt;
        getNextToRead(); client_request; client_request =
          outgoing_requests_-&gt;getNextToRead()) {
        logger_.log("%:% %() % Sending cid:% seq:% %\n",
          __FILE__, __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_),
                      client_id_, next_outgoing_seq_num_,
                        client_request-&gt;toString());
        tcp_socket_.send(&amp;next_outgoing_seq_num_,
          sizeof(next_outgoing_seq_num_));
        tcp_socket_.send(client_request,
          sizeof(Exchange::MEClientRequest));
        outgoing_requests_-&gt;updateReadIndex();
        next_outgoing_seq_num_++;
      }
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.1512.1">We will deal </span><a id="_idIndexMarker1225"/><span class="koboSpan" id="kobo.1513.1">with the task of receiving and processing order </span><a id="_idIndexMarker1226"/><span class="koboSpan" id="kobo.1514.1">responses that the exchange sends to the TCP connection </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1515.1">OrderGateway</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1516.1"> establishes.</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.1517.1">Processing order responses from the exchange</span></h2>
<p><span class="koboSpan" id="kobo.1518.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1519.1">recvCallback()</span></strong><span class="koboSpan" id="kobo.1520.1"> method is called when there is data available on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1521.1">tcp_socket_</span></strong><span class="koboSpan" id="kobo.1522.1"> and </span><a id="_idIndexMarker1227"/><span class="koboSpan" id="kobo.1523.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1524.1">TCPSocket::sendAndRecv()</span></strong><span class="koboSpan" id="kobo.1525.1"> method is called from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1526.1">run()</span></strong><span class="koboSpan" id="kobo.1527.1"> method in the previous </span><a id="_idIndexMarker1228"/><span class="koboSpan" id="kobo.1528.1">section. </span><span class="koboSpan" id="kobo.1528.2">We go through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1529.1">rcv_buffer_</span></strong><span class="koboSpan" id="kobo.1530.1"> buffer on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1532.1"> and re-interpret the data as </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">OMClientResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1534.1"> messages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1535.1">
  auto OrderGateway::recvCallback(TCPSocket *socket, Nanos
    rx_time) noexcept -&gt; void {
    logger_.log("%:% %() % Received socket:% len:% %\n",
      __FILE__, __LINE__, __FUNCTION__,
        Common::getCurrentTimeStr(&amp;time_str_), socket-&gt;fd_,
          socket-&gt;next_rcv_valid_index_, rx_time);
    if (socket-&gt;next_rcv_valid_index_ &gt;=
      sizeof(Exchange::OMClientResponse)) {
      size_t i = 0;
      for (; i + sizeof(Exchange::OMClientResponse) &lt;=
        socket-&gt;next_rcv_valid_index_; i +=
          sizeof(Exchange::OMClientResponse)) {
        auto response = reinterpret_cast&lt;const
          Exchange::OMClientResponse *&gt;(socket-&gt;rcv_buffer_
            + i);
        logger_.log("%:% %() % Received %\n", __FILE__,
          __LINE__, __FUNCTION__,
           Common::getCurrentTimeStr(&amp;time_str_), response-
             &gt;toString());</span></pre>
<p><span class="koboSpan" id="kobo.1536.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1537.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.1538.1"> message we just read into the response variable, we check to make </span><a id="_idIndexMarker1229"/><span class="koboSpan" id="kobo.1539.1">sure the client ID on the response </span><a id="_idIndexMarker1230"/><span class="koboSpan" id="kobo.1540.1">matches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1541.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1542.1">’s client ID and ignore the response if it does </span><span class="No-Break"><span class="koboSpan" id="kobo.1543.1">not match:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1544.1">
        if(response-&gt;me_client_response_.client_id_ !=
          client_id_) {
          logger_.log("%:% %() % ERROR Incorrect client id.
</span><span class="koboSpan" id="kobo.1544.2">            ClientId expected:% received:%.\n", __FILE__,
               __LINE__, __FUNCTION__,
                      Common::getCurrentTimeStr(&amp;time_str_)
                       , client_id_, response-&gt;
                          me_client_response_.client_id_);
          continue;
        }</span></pre>
<p><span class="koboSpan" id="kobo.1545.1">We also check to make sure that the sequence number on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1546.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.1547.1"> matches what we expect it to be. </span><span class="koboSpan" id="kobo.1547.2">If there is a mismatch, we log an error and ignore the response. </span><span class="koboSpan" id="kobo.1547.3">There is an opportunity to improve the error handling here, but for the sake of simplicity, we just log an error </span><span class="No-Break"><span class="koboSpan" id="kobo.1548.1">and continue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1549.1">
        if(response-&gt;seq_num_ != next_exp_seq_num_) {
          logger_.log("%:% %() % ERROR Incorrect sequence
            number. </span><span class="koboSpan" id="kobo.1549.2">ClientId:%. </span><span class="koboSpan" id="kobo.1549.3">SeqNum expected:%
              received:%.\n", __FILE__, __LINE__,
                __FUNCTION__,
                      Common::getCurrentTimeStr(&amp;time_str_)
                        , client_id_, next_exp_seq_num_,
                           response-&gt;seq_num_);
          continue;
        }</span></pre>
<p><span class="koboSpan" id="kobo.1550.1">Finally, we </span><a id="_idIndexMarker1231"/><span class="koboSpan" id="kobo.1551.1">increment the expected sequence </span><a id="_idIndexMarker1232"/><span class="koboSpan" id="kobo.1552.1">number on the next </span><strong class="source-inline"><span class="koboSpan" id="kobo.1553.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.1554.1"> and write the response we just read to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1555.1">incoming_responses_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1557.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1559.1"> to read. </span><span class="koboSpan" id="kobo.1559.2">It also updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">rcv_buffer_</span></strong><span class="koboSpan" id="kobo.1561.1"> buffer and the next receive index into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1562.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1563.1"> buffer we just consumed some </span><span class="No-Break"><span class="koboSpan" id="kobo.1564.1">messages from:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1565.1">
        ++next_exp_seq_num_;
        auto next_write = incoming_responses_-&gt;
          getNextToWriteTo();
        *next_write = std::move(response-&gt;
          me_client_response_);
        incoming_responses_-&gt;updateWriteIndex();
      }
      memcpy(socket-&gt;rcv_buffer_, socket-&gt;rcv_buffer_ + i,
        socket-&gt;next_rcv_valid_index_ - i);
      socket-&gt;next_rcv_valid_index_ -= i;
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.1566.1">With this method implementation, we have finished the design and implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1567.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1568.1"> component. </span><span class="koboSpan" id="kobo.1568.2">That will be all the core infrastructure components we build in this chapter, and we will summarize everything we worked on in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1569.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1570.1">One important </span><a id="_idIndexMarker1233"/><span class="koboSpan" id="kobo.1571.1">note is that we will need to build all the </span><a id="_idIndexMarker1234"/><span class="koboSpan" id="kobo.1572.1">components presented in this chapter as well as the </span><em class="italic"><span class="koboSpan" id="kobo.1573.1">Building the C++ Trading Algorithm Building Blocks</span></em><span class="koboSpan" id="kobo.1574.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1575.1">Building the C++ Market Making and Liquidity Taking Algorithms</span></em><span class="koboSpan" id="kobo.1576.1"> chapters before we can build and run a meaningful trading client. </span><span class="koboSpan" id="kobo.1576.2">Since our ecosystem consists of a server (trading exchange) and client (trading client) infrastructure, we will need to wait until the </span><em class="italic"><span class="koboSpan" id="kobo.1577.1">Building and running the main trading application</span></em><span class="koboSpan" id="kobo.1578.1"> section in the </span><em class="italic"><span class="koboSpan" id="kobo.1579.1">Building the C++ Market Making and Liquidity Taking Algorithms</span></em><span class="koboSpan" id="kobo.1580.1"> chapter before we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1581.1">full ecosystem.</span></span></p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.1582.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1583.1">This chapter was dedicated to building the important core infrastructure components inside the market participant’s trading system. </span><span class="koboSpan" id="kobo.1583.2">First, we build the market data consumer component, which is responsible for subscribing to the multicast market data stream generated by the exchange. </span><span class="koboSpan" id="kobo.1583.3">It needs to detect gaps in market data updates on the incremental market data stream and initiate snapshot recovery and synchronization mechanisms to re-synchronize with the incremental market data stream. </span><span class="koboSpan" id="kobo.1583.4">It decodes the market data updates from the format that the exchange publishes to a simpler internal market </span><span class="No-Break"><span class="koboSpan" id="kobo.1584.1">data format.</span></span></p>
<p><span class="koboSpan" id="kobo.1585.1">The order book sub-component inside the trading engine component processes the market data updates it receives from the market data consumer. </span><span class="koboSpan" id="kobo.1585.2">It builds and updates an order book data structure from these updates for the trading engine to get an accurate view of </span><span class="No-Break"><span class="koboSpan" id="kobo.1586.1">the market.</span></span></p>
<p><span class="koboSpan" id="kobo.1587.1">The order gateway component inside the trading system establishes and maintains a bi-directional TCP connection with the electronic trading exchange. </span><span class="koboSpan" id="kobo.1587.2">It receives order action requests from the trading engine and sends them out to the exchange in the exchange’s order data format. </span><span class="koboSpan" id="kobo.1587.3">It also receives order responses that the exchange sends to the trading client, decodes them, and forwards them to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1588.1">trading engine.</span></span></p>
<p><span class="koboSpan" id="kobo.1589.1">Note that we do not have everything we need in the trading client’s trading system, that is, we are missing the components we need to build and run trading strategies and associated components. </span><span class="koboSpan" id="kobo.1589.2">The next chapter will build the additional components we need in the trading strategy framework. </span><span class="koboSpan" id="kobo.1589.3">The chapter after that will tie all the components together and finish the final trading application and the full </span><span class="No-Break"><span class="koboSpan" id="kobo.1590.1">trading ecosystem.</span></span></p>
</div>
</body></html>